var IX = Object.defineProperty;
var OX = (e, t, r) => t in e ? IX(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Bf = (e, t, r) => OX(e, typeof t != "symbol" ? t + "" : t, r);
import * as E from "react";
import H, { createContext as du, forwardRef as yn, useContext as vr, version as LX, isValidElement as FX, useRef as se, useLayoutEffect as as, useEffect as Nt, useMemo as Et, useState as Me, Children as NX, createRef as kX, useCallback as lr, useImperativeHandle as Zc, cloneElement as VX, createElement as CG, useReducer as BX, PureComponent as $X, Fragment as HX, memo as eo, Component as GX } from "react";
import * as zX from "react-dom";
import Bc, { createPortal as yP, unstable_batchedUpdates as WX, flushSync as BE } from "react-dom";
var T0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function of(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var $E = { exports: {} }, $f = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VI;
function jX() {
  if (VI) return $f;
  VI = 1;
  var e = H, t = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, d = {}, h = null, f = null;
    u !== void 0 && (h = "" + u), l.key !== void 0 && (h = "" + l.key), l.ref !== void 0 && (f = l.ref);
    for (c in l) n.call(l, c) && !o.hasOwnProperty(c) && (d[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: s, key: h, ref: f, props: d, _owner: i.current };
  }
  return $f.Fragment = r, $f.jsx = a, $f.jsxs = a, $f;
}
var Hf = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BI;
function UX() {
  return BI || (BI = 1, process.env.NODE_ENV !== "production" && function() {
    var e = H, t = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), p = Symbol.iterator, g = "@@iterator";
    function v(Q) {
      if (Q === null || typeof Q != "object")
        return null;
      var ye = p && Q[p] || Q[g];
      return typeof ye == "function" ? ye : null;
    }
    var m = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function y(Q) {
      {
        for (var ye = arguments.length, me = new Array(ye > 1 ? ye - 1 : 0), Ue = 1; Ue < ye; Ue++)
          me[Ue - 1] = arguments[Ue];
        C("error", Q, me);
      }
    }
    function C(Q, ye, me) {
      {
        var Ue = m.ReactDebugCurrentFrame, pt = Ue.getStackAddendum();
        pt !== "" && (ye += "%s", me = me.concat([pt]));
        var gt = me.map(function(yt) {
          return String(yt);
        });
        gt.unshift("Warning: " + ye), Function.prototype.apply.call(console[Q], console, gt);
      }
    }
    var S = !1, b = !1, w = !1, x = !1, R = !1, _;
    _ = Symbol.for("react.module.reference");
    function T(Q) {
      return !!(typeof Q == "string" || typeof Q == "function" || Q === n || Q === o || R || Q === i || Q === u || Q === c || x || Q === f || S || b || w || typeof Q == "object" && Q !== null && (Q.$$typeof === h || Q.$$typeof === d || Q.$$typeof === a || Q.$$typeof === s || Q.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Q.$$typeof === _ || Q.getModuleId !== void 0));
    }
    function P(Q, ye, me) {
      var Ue = Q.displayName;
      if (Ue)
        return Ue;
      var pt = ye.displayName || ye.name || "";
      return pt !== "" ? me + "(" + pt + ")" : me;
    }
    function D(Q) {
      return Q.displayName || "Context";
    }
    function O(Q) {
      if (Q == null)
        return null;
      if (typeof Q.tag == "number" && y("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Q == "function")
        return Q.displayName || Q.name || null;
      if (typeof Q == "string")
        return Q;
      switch (Q) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof Q == "object")
        switch (Q.$$typeof) {
          case s:
            var ye = Q;
            return D(ye) + ".Consumer";
          case a:
            var me = Q;
            return D(me._context) + ".Provider";
          case l:
            return P(Q, Q.render, "ForwardRef");
          case d:
            var Ue = Q.displayName || null;
            return Ue !== null ? Ue : O(Q.type) || "Memo";
          case h: {
            var pt = Q, gt = pt._payload, yt = pt._init;
            try {
              return O(yt(gt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var A = Object.assign, F = 0, L, N, I, B, M, V, G;
    function k() {
    }
    k.__reactDisabledLog = !0;
    function z() {
      {
        if (F === 0) {
          L = console.log, N = console.info, I = console.warn, B = console.error, M = console.group, V = console.groupCollapsed, G = console.groupEnd;
          var Q = {
            configurable: !0,
            enumerable: !0,
            value: k,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Q,
            log: Q,
            warn: Q,
            error: Q,
            group: Q,
            groupCollapsed: Q,
            groupEnd: Q
          });
        }
        F++;
      }
    }
    function j() {
      {
        if (F--, F === 0) {
          var Q = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: A({}, Q, {
              value: L
            }),
            info: A({}, Q, {
              value: N
            }),
            warn: A({}, Q, {
              value: I
            }),
            error: A({}, Q, {
              value: B
            }),
            group: A({}, Q, {
              value: M
            }),
            groupCollapsed: A({}, Q, {
              value: V
            }),
            groupEnd: A({}, Q, {
              value: G
            })
          });
        }
        F < 0 && y("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var q = m.ReactCurrentDispatcher, K;
    function Z(Q, ye, me) {
      {
        if (K === void 0)
          try {
            throw Error();
          } catch (pt) {
            var Ue = pt.stack.trim().match(/\n( *(at )?)/);
            K = Ue && Ue[1] || "";
          }
        return `
` + K + Q;
      }
    }
    var re = !1, X;
    {
      var Y = typeof WeakMap == "function" ? WeakMap : Map;
      X = new Y();
    }
    function U(Q, ye) {
      if (!Q || re)
        return "";
      {
        var me = X.get(Q);
        if (me !== void 0)
          return me;
      }
      var Ue;
      re = !0;
      var pt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var gt;
      gt = q.current, q.current = null, z();
      try {
        if (ye) {
          var yt = function() {
            throw Error();
          };
          if (Object.defineProperty(yt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(yt, []);
            } catch (wr) {
              Ue = wr;
            }
            Reflect.construct(Q, [], yt);
          } else {
            try {
              yt.call();
            } catch (wr) {
              Ue = wr;
            }
            Q.call(yt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (wr) {
            Ue = wr;
          }
          Q();
        }
      } catch (wr) {
        if (wr && Ue && typeof wr.stack == "string") {
          for (var Rt = wr.stack.split(`
`), et = Ue.stack.split(`
`), Ke = Rt.length - 1, rt = et.length - 1; Ke >= 1 && rt >= 0 && Rt[Ke] !== et[rt]; )
            rt--;
          for (; Ke >= 1 && rt >= 0; Ke--, rt--)
            if (Rt[Ke] !== et[rt]) {
              if (Ke !== 1 || rt !== 1)
                do
                  if (Ke--, rt--, rt < 0 || Rt[Ke] !== et[rt]) {
                    var er = `
` + Rt[Ke].replace(" at new ", " at ");
                    return Q.displayName && er.includes("<anonymous>") && (er = er.replace("<anonymous>", Q.displayName)), typeof Q == "function" && X.set(Q, er), er;
                  }
                while (Ke >= 1 && rt >= 0);
              break;
            }
        }
      } finally {
        re = !1, q.current = gt, j(), Error.prepareStackTrace = pt;
      }
      var Xr = Q ? Q.displayName || Q.name : "", Rn = Xr ? Z(Xr) : "";
      return typeof Q == "function" && X.set(Q, Rn), Rn;
    }
    function oe(Q, ye, me) {
      return U(Q, !1);
    }
    function W(Q) {
      var ye = Q.prototype;
      return !!(ye && ye.isReactComponent);
    }
    function ne(Q, ye, me) {
      if (Q == null)
        return "";
      if (typeof Q == "function")
        return U(Q, W(Q));
      if (typeof Q == "string")
        return Z(Q);
      switch (Q) {
        case u:
          return Z("Suspense");
        case c:
          return Z("SuspenseList");
      }
      if (typeof Q == "object")
        switch (Q.$$typeof) {
          case l:
            return oe(Q.render);
          case d:
            return ne(Q.type, ye, me);
          case h: {
            var Ue = Q, pt = Ue._payload, gt = Ue._init;
            try {
              return ne(gt(pt), ye, me);
            } catch {
            }
          }
        }
      return "";
    }
    var ce = Object.prototype.hasOwnProperty, we = {}, Re = m.ReactDebugCurrentFrame;
    function ve(Q) {
      if (Q) {
        var ye = Q._owner, me = ne(Q.type, Q._source, ye ? ye.type : null);
        Re.setExtraStackFrame(me);
      } else
        Re.setExtraStackFrame(null);
    }
    function xe(Q, ye, me, Ue, pt) {
      {
        var gt = Function.call.bind(ce);
        for (var yt in Q)
          if (gt(Q, yt)) {
            var Rt = void 0;
            try {
              if (typeof Q[yt] != "function") {
                var et = Error((Ue || "React class") + ": " + me + " type `" + yt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Q[yt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw et.name = "Invariant Violation", et;
              }
              Rt = Q[yt](ye, yt, Ue, me, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Ke) {
              Rt = Ke;
            }
            Rt && !(Rt instanceof Error) && (ve(pt), y("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ue || "React class", me, yt, typeof Rt), ve(null)), Rt instanceof Error && !(Rt.message in we) && (we[Rt.message] = !0, ve(pt), y("Failed %s type: %s", me, Rt.message), ve(null));
          }
      }
    }
    var _e = Array.isArray;
    function Ve(Q) {
      return _e(Q);
    }
    function Fe(Q) {
      {
        var ye = typeof Symbol == "function" && Symbol.toStringTag, me = ye && Q[Symbol.toStringTag] || Q.constructor.name || "Object";
        return me;
      }
    }
    function Ne(Q) {
      try {
        return Je(Q), !1;
      } catch {
        return !0;
      }
    }
    function Je(Q) {
      return "" + Q;
    }
    function J(Q) {
      if (Ne(Q))
        return y("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Fe(Q)), Je(Q);
    }
    var he = m.ReactCurrentOwner, Le = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Pe, Ie, Ce;
    Ce = {};
    function De(Q) {
      if (ce.call(Q, "ref")) {
        var ye = Object.getOwnPropertyDescriptor(Q, "ref").get;
        if (ye && ye.isReactWarning)
          return !1;
      }
      return Q.ref !== void 0;
    }
    function ze(Q) {
      if (ce.call(Q, "key")) {
        var ye = Object.getOwnPropertyDescriptor(Q, "key").get;
        if (ye && ye.isReactWarning)
          return !1;
      }
      return Q.key !== void 0;
    }
    function st(Q, ye) {
      if (typeof Q.ref == "string" && he.current && ye && he.current.stateNode !== ye) {
        var me = O(he.current.type);
        Ce[me] || (y('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', O(he.current.type), Q.ref), Ce[me] = !0);
      }
    }
    function Tt(Q, ye) {
      {
        var me = function() {
          Pe || (Pe = !0, y("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ye));
        };
        me.isReactWarning = !0, Object.defineProperty(Q, "key", {
          get: me,
          configurable: !0
        });
      }
    }
    function ot(Q, ye) {
      {
        var me = function() {
          Ie || (Ie = !0, y("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ye));
        };
        me.isReactWarning = !0, Object.defineProperty(Q, "ref", {
          get: me,
          configurable: !0
        });
      }
    }
    var Xe = function(Q, ye, me, Ue, pt, gt, yt) {
      var Rt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: Q,
        key: ye,
        ref: me,
        props: yt,
        // Record the component responsible for creating this element.
        _owner: gt
      };
      return Rt._store = {}, Object.defineProperty(Rt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Rt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ue
      }), Object.defineProperty(Rt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: pt
      }), Object.freeze && (Object.freeze(Rt.props), Object.freeze(Rt)), Rt;
    };
    function Oe(Q, ye, me, Ue, pt) {
      {
        var gt, yt = {}, Rt = null, et = null;
        me !== void 0 && (J(me), Rt = "" + me), ze(ye) && (J(ye.key), Rt = "" + ye.key), De(ye) && (et = ye.ref, st(ye, pt));
        for (gt in ye)
          ce.call(ye, gt) && !Le.hasOwnProperty(gt) && (yt[gt] = ye[gt]);
        if (Q && Q.defaultProps) {
          var Ke = Q.defaultProps;
          for (gt in Ke)
            yt[gt] === void 0 && (yt[gt] = Ke[gt]);
        }
        if (Rt || et) {
          var rt = typeof Q == "function" ? Q.displayName || Q.name || "Unknown" : Q;
          Rt && Tt(yt, rt), et && ot(yt, rt);
        }
        return Xe(Q, Rt, et, pt, Ue, he.current, yt);
      }
    }
    var Qe = m.ReactCurrentOwner, ft = m.ReactDebugCurrentFrame;
    function xt(Q) {
      if (Q) {
        var ye = Q._owner, me = ne(Q.type, Q._source, ye ? ye.type : null);
        ft.setExtraStackFrame(me);
      } else
        ft.setExtraStackFrame(null);
    }
    var $r;
    $r = !1;
    function hr(Q) {
      return typeof Q == "object" && Q !== null && Q.$$typeof === t;
    }
    function Gt() {
      {
        if (Qe.current) {
          var Q = O(Qe.current.type);
          if (Q)
            return `

Check the render method of \`` + Q + "`.";
        }
        return "";
      }
    }
    function Ot(Q) {
      return "";
    }
    var Lt = {};
    function mt(Q) {
      {
        var ye = Gt();
        if (!ye) {
          var me = typeof Q == "string" ? Q : Q.displayName || Q.name;
          me && (ye = `

Check the top-level render call using <` + me + ">.");
        }
        return ye;
      }
    }
    function qe(Q, ye) {
      {
        if (!Q._store || Q._store.validated || Q.key != null)
          return;
        Q._store.validated = !0;
        var me = mt(ye);
        if (Lt[me])
          return;
        Lt[me] = !0;
        var Ue = "";
        Q && Q._owner && Q._owner !== Qe.current && (Ue = " It was passed a child from " + O(Q._owner.type) + "."), xt(Q), y('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', me, Ue), xt(null);
      }
    }
    function zt(Q, ye) {
      {
        if (typeof Q != "object")
          return;
        if (Ve(Q))
          for (var me = 0; me < Q.length; me++) {
            var Ue = Q[me];
            hr(Ue) && qe(Ue, ye);
          }
        else if (hr(Q))
          Q._store && (Q._store.validated = !0);
        else if (Q) {
          var pt = v(Q);
          if (typeof pt == "function" && pt !== Q.entries)
            for (var gt = pt.call(Q), yt; !(yt = gt.next()).done; )
              hr(yt.value) && qe(yt.value, ye);
        }
      }
    }
    function fr(Q) {
      {
        var ye = Q.type;
        if (ye == null || typeof ye == "string")
          return;
        var me;
        if (typeof ye == "function")
          me = ye.propTypes;
        else if (typeof ye == "object" && (ye.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ye.$$typeof === d))
          me = ye.propTypes;
        else
          return;
        if (me) {
          var Ue = O(ye);
          xe(me, Q.props, "prop", Ue, Q);
        } else if (ye.PropTypes !== void 0 && !$r) {
          $r = !0;
          var pt = O(ye);
          y("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", pt || "Unknown");
        }
        typeof ye.getDefaultProps == "function" && !ye.getDefaultProps.isReactClassApproved && y("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Ge(Q) {
      {
        for (var ye = Object.keys(Q.props), me = 0; me < ye.length; me++) {
          var Ue = ye[me];
          if (Ue !== "children" && Ue !== "key") {
            xt(Q), y("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ue), xt(null);
            break;
          }
        }
        Q.ref !== null && (xt(Q), y("Invalid attribute `ref` supplied to `React.Fragment`."), xt(null));
      }
    }
    var Ze = {};
    function tt(Q, ye, me, Ue, pt, gt) {
      {
        var yt = T(Q);
        if (!yt) {
          var Rt = "";
          (Q === void 0 || typeof Q == "object" && Q !== null && Object.keys(Q).length === 0) && (Rt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var et = Ot();
          et ? Rt += et : Rt += Gt();
          var Ke;
          Q === null ? Ke = "null" : Ve(Q) ? Ke = "array" : Q !== void 0 && Q.$$typeof === t ? (Ke = "<" + (O(Q.type) || "Unknown") + " />", Rt = " Did you accidentally export a JSX literal instead of a component?") : Ke = typeof Q, y("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Ke, Rt);
        }
        var rt = Oe(Q, ye, me, pt, gt);
        if (rt == null)
          return rt;
        if (yt) {
          var er = ye.children;
          if (er !== void 0)
            if (Ue)
              if (Ve(er)) {
                for (var Xr = 0; Xr < er.length; Xr++)
                  zt(er[Xr], Q);
                Object.freeze && Object.freeze(er);
              } else
                y("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              zt(er, Q);
        }
        if (ce.call(ye, "key")) {
          var Rn = O(Q), wr = Object.keys(ye).filter(function(_n) {
            return _n !== "key";
          }), Vi = wr.length > 0 ? "{key: someKey, " + wr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Ze[Rn + Vi]) {
            var to = wr.length > 0 ? "{" + wr.join(": ..., ") + ": ...}" : "{}";
            y(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Vi, Rn, to, Rn), Ze[Rn + Vi] = !0;
          }
        }
        return Q === n ? Ge(rt) : fr(rt), rt;
      }
    }
    function ht(Q, ye, me) {
      return tt(Q, ye, me, !0);
    }
    function It(Q, ye, me) {
      return tt(Q, ye, me, !1);
    }
    var qt = It, Hr = ht;
    Hf.Fragment = n, Hf.jsx = qt, Hf.jsxs = Hr;
  }()), Hf;
}
process.env.NODE_ENV === "production" ? $E.exports = jX() : $E.exports = UX();
var ie = $E.exports;
const KX = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M244,56v48a12,12,0,0,1-12,12H184a12,12,0,1,1,0-24H201.1l-19-17.38c-.13-.12-.26-.24-.38-.37A76,76,0,1,0,127,204h1a75.53,75.53,0,0,0,52.15-20.72,12,12,0,0,1,16.49,17.45A99.45,99.45,0,0,1,128,228h-1.37A100,100,0,1,1,198.51,57.06L220,76.72V56a12,12,0,0,1,24,0Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,128a88,88,0,1,1-88-88A88,88,0,0,1,216,128Z", opacity: "0.2" }), /* @__PURE__ */ H.createElement("path", { d: "M240,56v48a8,8,0,0,1-8,8H184a8,8,0,0,1,0-16H211.4L184.81,71.64l-.25-.24a80,80,0,1,0-1.67,114.78,8,8,0,0,1,11,11.63A95.44,95.44,0,0,1,128,224h-1.32A96,96,0,1,1,195.75,60L224,85.8V56a8,8,0,1,1,16,0Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M240,56v48a8,8,0,0,1-8,8H184a8,8,0,0,1-5.66-13.66l17-17-10.55-9.65-.25-.24a80,80,0,1,0-1.67,114.78,8,8,0,1,1,11,11.63A95.44,95.44,0,0,1,128,224h-1.32A96,96,0,1,1,195.75,60l10.93,10L226.34,50.3A8,8,0,0,1,240,56Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M238,56v48a6,6,0,0,1-6,6H184a6,6,0,0,1,0-12h32.55l-30.38-27.8c-.06-.06-.12-.13-.19-.19a82,82,0,1,0-1.7,117.65,6,6,0,0,1,8.24,8.73A93.46,93.46,0,0,1,128,222h-1.28A94,94,0,1,1,194.37,61.4L226,90.35V56a6,6,0,1,1,12,0Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M240,56v48a8,8,0,0,1-8,8H184a8,8,0,0,1,0-16H211.4L184.81,71.64l-.25-.24a80,80,0,1,0-1.67,114.78,8,8,0,0,1,11,11.63A95.44,95.44,0,0,1,128,224h-1.32A96,96,0,1,1,195.75,60L224,85.8V56a8,8,0,1,1,16,0Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M236,56v48a4,4,0,0,1-4,4H184a4,4,0,0,1,0-8h37.7L187.53,68.69l-.13-.12a84,84,0,1,0-1.75,120.51,4,4,0,0,1,5.5,5.82A91.43,91.43,0,0,1,128,220h-1.26A92,92,0,1,1,193,62.84l35,32.05V56a4,4,0,1,1,8,0Z" }))
  ]
]), YX = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216.49,104.49l-80,80a12,12,0,0,1-17,0l-80-80a12,12,0,0,1,17-17L128,159l71.51-71.52a12,12,0,0,1,17,17Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M208,96l-80,80L48,96Z", opacity: "0.2" }), /* @__PURE__ */ H.createElement("path", { d: "M215.39,92.94A8,8,0,0,0,208,88H48a8,8,0,0,0-5.66,13.66l80,80a8,8,0,0,0,11.32,0l80-80A8,8,0,0,0,215.39,92.94ZM128,164.69,67.31,104H188.69Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M213.66,101.66l-80,80a8,8,0,0,1-11.32,0l-80-80A8,8,0,0,1,48,88H208a8,8,0,0,1,5.66,13.66Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M212.24,100.24l-80,80a6,6,0,0,1-8.48,0l-80-80a6,6,0,0,1,8.48-8.48L128,167.51l75.76-75.75a6,6,0,0,1,8.48,8.48Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M213.66,101.66l-80,80a8,8,0,0,1-11.32,0l-80-80A8,8,0,0,1,53.66,90.34L128,164.69l74.34-74.35a8,8,0,0,1,11.32,11.32Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M210.83,98.83l-80,80a4,4,0,0,1-5.66,0l-80-80a4,4,0,0,1,5.66-5.66L128,170.34l77.17-77.17a4,4,0,1,1,5.66,5.66Z" }))
  ]
]), qX = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M176.49,95.51a12,12,0,0,1,0,17l-56,56a12,12,0,0,1-17,0l-24-24a12,12,0,1,1,17-17L112,143l47.51-47.52A12,12,0,0,1,176.49,95.51ZM236,128A108,108,0,1,1,128,20,108.12,108.12,0,0,1,236,128Zm-24,0a84,84,0,1,0-84,84A84.09,84.09,0,0,0,212,128Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M224,128a96,96,0,1,1-96-96A96,96,0,0,1,224,128Z", opacity: "0.2" }), /* @__PURE__ */ H.createElement("path", { d: "M173.66,98.34a8,8,0,0,1,0,11.32l-56,56a8,8,0,0,1-11.32,0l-24-24a8,8,0,0,1,11.32-11.32L112,148.69l50.34-50.35A8,8,0,0,1,173.66,98.34ZM232,128A104,104,0,1,1,128,24,104.11,104.11,0,0,1,232,128Zm-16,0a88,88,0,1,0-88,88A88.1,88.1,0,0,0,216,128Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm45.66,85.66-56,56a8,8,0,0,1-11.32,0l-24-24a8,8,0,0,1,11.32-11.32L112,148.69l50.34-50.35a8,8,0,0,1,11.32,11.32Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M172.24,99.76a6,6,0,0,1,0,8.48l-56,56a6,6,0,0,1-8.48,0l-24-24a6,6,0,0,1,8.48-8.48L112,151.51l51.76-51.75A6,6,0,0,1,172.24,99.76ZM230,128A102,102,0,1,1,128,26,102.12,102.12,0,0,1,230,128Zm-12,0a90,90,0,1,0-90,90A90.1,90.1,0,0,0,218,128Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M173.66,98.34a8,8,0,0,1,0,11.32l-56,56a8,8,0,0,1-11.32,0l-24-24a8,8,0,0,1,11.32-11.32L112,148.69l50.34-50.35A8,8,0,0,1,173.66,98.34ZM232,128A104,104,0,1,1,128,24,104.11,104.11,0,0,1,232,128Zm-16,0a88,88,0,1,0-88,88A88.1,88.1,0,0,0,216,128Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M170.83,101.17a4,4,0,0,1,0,5.66l-56,56a4,4,0,0,1-5.66,0l-24-24a4,4,0,0,1,5.66-5.66L112,154.34l53.17-53.17A4,4,0,0,1,170.83,101.17ZM228,128A100,100,0,1,1,128,28,100.11,100.11,0,0,1,228,128Zm-8,0a92,92,0,1,0-92,92A92.1,92.1,0,0,0,220,128Z" }))
  ]
]), XX = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,28H165.47a51.88,51.88,0,0,0-74.94,0H56A20,20,0,0,0,36,48V216a20,20,0,0,0,20,20H200a20,20,0,0,0,20-20V48A20,20,0,0,0,200,28ZM155.71,60H100.29a28,28,0,0,1,55.42,0ZM196,212H60V52H77.41A52.13,52.13,0,0,0,76,64v8A12,12,0,0,0,88,84h80a12,12,0,0,0,12-12V64a52.13,52.13,0,0,0-1.41-12H196Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M208,48V216a8,8,0,0,1-8,8H56a8,8,0,0,1-8-8V48a8,8,0,0,1,8-8H96a39.83,39.83,0,0,0-8,24v8h80V64a39.83,39.83,0,0,0-8-24h40A8,8,0,0,1,208,48Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M200,32H163.74a47.92,47.92,0,0,0-71.48,0H56A16,16,0,0,0,40,48V216a16,16,0,0,0,16,16H200a16,16,0,0,0,16-16V48A16,16,0,0,0,200,32Zm-72,0a32,32,0,0,1,32,32H96A32,32,0,0,1,128,32Zm72,184H56V48H82.75A47.93,47.93,0,0,0,80,64v8a8,8,0,0,0,8,8h80a8,8,0,0,0,8-8V64a47.93,47.93,0,0,0-2.75-16H200Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,32H163.74a47.92,47.92,0,0,0-71.48,0H56A16,16,0,0,0,40,48V216a16,16,0,0,0,16,16H200a16,16,0,0,0,16-16V48A16,16,0,0,0,200,32Zm-72,0a32,32,0,0,1,32,32H96A32,32,0,0,1,128,32Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,34H162.83a45.91,45.91,0,0,0-69.66,0H56A14,14,0,0,0,42,48V216a14,14,0,0,0,14,14H200a14,14,0,0,0,14-14V48A14,14,0,0,0,200,34Zm-72-4a34,34,0,0,1,34,34v2H94V64A34,34,0,0,1,128,30Zm74,186a2,2,0,0,1-2,2H56a2,2,0,0,1-2-2V48a2,2,0,0,1,2-2H85.67A45.77,45.77,0,0,0,82,64v8a6,6,0,0,0,6,6h80a6,6,0,0,0,6-6V64a45.77,45.77,0,0,0-3.67-18H200a2,2,0,0,1,2,2Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,32H163.74a47.92,47.92,0,0,0-71.48,0H56A16,16,0,0,0,40,48V216a16,16,0,0,0,16,16H200a16,16,0,0,0,16-16V48A16,16,0,0,0,200,32Zm-72,0a32,32,0,0,1,32,32H96A32,32,0,0,1,128,32Zm72,184H56V48H82.75A47.93,47.93,0,0,0,80,64v8a8,8,0,0,0,8,8h80a8,8,0,0,0,8-8V64a47.93,47.93,0,0,0-2.75-16H200Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,36H161.92a44,44,0,0,0-67.84,0H56A12,12,0,0,0,44,48V216a12,12,0,0,0,12,12H200a12,12,0,0,0,12-12V48A12,12,0,0,0,200,36Zm-72-8a36,36,0,0,1,36,36v4H92V64A36,36,0,0,1,128,28Zm76,188a4,4,0,0,1-4,4H56a4,4,0,0,1-4-4V48a4,4,0,0,1,4-4H88.83A43.71,43.71,0,0,0,84,64v8a4,4,0,0,0,4,4h80a4,4,0,0,0,4-4V64a43.71,43.71,0,0,0-4.83-20H200a4,4,0,0,1,4,4Z" }))
  ]
]), ZX = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M71.51,88.49a12,12,0,0,1,17-17L116,99V24a12,12,0,0,1,24,0V99l27.51-27.52a12,12,0,0,1,17,17l-48,48a12,12,0,0,1-17,0ZM224,116H188a12,12,0,0,0,0,24h32v56H36V140H68a12,12,0,0,0,0-24H32a20,20,0,0,0-20,20v64a20,20,0,0,0,20,20H224a20,20,0,0,0,20-20V136A20,20,0,0,0,224,116Zm-20,52a16,16,0,1,0-16,16A16,16,0,0,0,204,168Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M232,136v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H224A8,8,0,0,1,232,136Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H72a8,8,0,0,1,0,16H32v64H224V136H184a8,8,0,0,1,0-16h40A16,16,0,0,1,240,136Zm-117.66-2.34a8,8,0,0,0,11.32,0l48-48a8,8,0,0,0-11.32-11.32L136,108.69V24a8,8,0,0,0-16,0v84.69L85.66,74.34A8,8,0,0,0,74.34,85.66ZM200,168a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145A24,24,0,0,0,145,145l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M238,136v64a14,14,0,0,1-14,14H32a14,14,0,0,1-14-14V136a14,14,0,0,1,14-14H72a6,6,0,0,1,0,12H32a2,2,0,0,0-2,2v64a2,2,0,0,0,2,2H224a2,2,0,0,0,2-2V136a2,2,0,0,0-2-2H184a6,6,0,0,1,0-12h40A14,14,0,0,1,238,136Zm-114.24-3.76a6,6,0,0,0,8.48,0l48-48a6,6,0,0,0-8.48-8.48L134,113.51V24a6,6,0,0,0-12,0v89.51L84.24,75.76a6,6,0,0,0-8.48,8.48ZM198,168a10,10,0,1,0-10,10A10,10,0,0,0,198,168Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H72a8,8,0,0,1,0,16H32v64H224V136H184a8,8,0,0,1,0-16h40A16,16,0,0,1,240,136Zm-117.66-2.34a8,8,0,0,0,11.32,0l48-48a8,8,0,0,0-11.32-11.32L136,108.69V24a8,8,0,0,0-16,0v84.69L85.66,74.34A8,8,0,0,0,74.34,85.66ZM200,168a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M236,136v64a12,12,0,0,1-12,12H32a12,12,0,0,1-12-12V136a12,12,0,0,1,12-12H72a4,4,0,0,1,0,8H32a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4H224a4,4,0,0,0,4-4V136a4,4,0,0,0-4-4H184a4,4,0,0,1,0-8h40A12,12,0,0,1,236,136Zm-110.83-5.17a4,4,0,0,0,5.66,0l48-48a4,4,0,1,0-5.66-5.66L132,118.34V24a4,4,0,0,0-8,0v94.34L82.83,77.17a4,4,0,0,0-5.66,5.66ZM196,168a8,8,0,1,0-8,8A8,8,0,0,0,196,168Z" }))
  ]
]), QX = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,20A108,108,0,1,0,236,128,108.12,108.12,0,0,0,128,20Zm84,108a83.64,83.64,0,0,1-4.47,27L167,130a19.65,19.65,0,0,0-7.8-2.78l-22.82-3.08A20.14,20.14,0,0,0,117.72,132h-4.07l-2.71-5.6a19.88,19.88,0,0,0-13.8-10.84L94.46,115l4-7h14.39a20,20,0,0,0,9.66-2.49l12.25-6.76a20.57,20.57,0,0,0,3.74-2.68l26.92-24.33A20,20,0,0,0,172,56.49,84,84,0,0,1,212,128ZM140.76,45l6.2,11.1L122.75,78l-10.93,6H96.14A20.05,20.05,0,0,0,78.78,94.06l-4.49,7.85L67.68,84.28l9.91-23.42A83.91,83.91,0,0,1,140.76,45ZM44,128a83.52,83.52,0,0,1,4.4-26.77l7.74,20.65a19.89,19.89,0,0,0,14.52,12.53l19.53,4.2,3,6.1a20.11,20.11,0,0,0,13.55,10.77l-5,11.12a20,20,0,0,0,3.58,21.71l.21.22,18.16,18.7-.89,4.59A84.09,84.09,0,0,1,44,128Zm103.65,81.66a20.11,20.11,0,0,0-5-17.3l-.21-.22-17.72-18.25,11.37-25.52,19,2.56,41.43,25.48A84.2,84.2,0,0,1,147.65,209.66Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M213.09,172.48a96,96,0,0,1-80.41,51.41l3.17-16.44a8,8,0,0,0-2-6.95l-19.74-20.33a8,8,0,0,1-1.44-8.69l13.7-30.74a8,8,0,0,1,8.38-4.67l22.82,3.08a8.11,8.11,0,0,1,3.12,1.11ZM116.71,95,129,88.24a7.46,7.46,0,0,0,1.5-1.07l26.91-24.33A8,8,0,0,0,159,53l-10.5-18.81A96.62,96.62,0,0,0,128,32,95.61,95.61,0,0,0,67.78,53.23L56,81.08A8,8,0,0,0,55.88,87l11.5,30.67a8,8,0,0,0,5.81,5l2.69.58L89.2,100a8,8,0,0,1,6.94-4h16.71A7.9,7.9,0,0,0,116.71,95Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm88,104a87.62,87.62,0,0,1-6.4,32.94l-44.7-27.49a15.92,15.92,0,0,0-6.24-2.23l-22.82-3.08a16.11,16.11,0,0,0-16,7.86h-8.72l-3.8-7.86a15.91,15.91,0,0,0-11-8.67l-8-1.73L96.14,104h16.71a16.06,16.06,0,0,0,7.73-2l12.25-6.76a16.62,16.62,0,0,0,3-2.14l26.91-24.34A15.93,15.93,0,0,0,166,49.1l-.36-.65A88.11,88.11,0,0,1,216,128ZM143.31,41.34,152,56.9,125.09,81.24,112.85,88H96.14a16,16,0,0,0-13.88,8l-8.73,15.23L63.38,84.19,74.32,58.32a87.87,87.87,0,0,1,69-17ZM40,128a87.53,87.53,0,0,1,8.54-37.8l11.34,30.27a16,16,0,0,0,11.62,10l21.43,4.61L96.74,143a16.09,16.09,0,0,0,14.4,9h1.48l-7.23,16.23a16,16,0,0,0,2.86,17.37l.14.14L128,205.94l-1.94,10A88.11,88.11,0,0,1,40,128Zm102.58,86.78,1.13-5.81a16.09,16.09,0,0,0-4-13.9,1.85,1.85,0,0,1-.14-.14L120,174.74,133.7,144l22.82,3.08,45.72,28.12A88.18,88.18,0,0,1,142.58,214.78Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm88,104a87.62,87.62,0,0,1-6.4,32.94l-44.7-27.49a15.92,15.92,0,0,0-6.24-2.23l-22.82-3.08a16.11,16.11,0,0,0-16,7.86h-8.72l-3.8-7.86a15.91,15.91,0,0,0-11-8.67l-8-1.73L96.14,104h16.71a16.06,16.06,0,0,0,7.73-2l12.25-6.76a16.62,16.62,0,0,0,3-2.14l26.91-24.34A15.93,15.93,0,0,0,166,49.1l-.36-.65A88.11,88.11,0,0,1,216,128ZM40,128a87.53,87.53,0,0,1,8.54-37.8l11.34,30.27a16,16,0,0,0,11.62,10l21.43,4.61L96.74,143a16.09,16.09,0,0,0,14.4,9h1.48l-7.23,16.23a16,16,0,0,0,2.86,17.37l.14.14L128,205.94l-1.94,10A88.11,88.11,0,0,1,40,128Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,26A102,102,0,1,0,230,128,102.12,102.12,0,0,0,128,26Zm90,102a89.55,89.55,0,0,1-7.46,35.86l-46.69-28.71a13.94,13.94,0,0,0-5.46-2l-22.82-3.07A14.06,14.06,0,0,0,121.06,138h-9.92a2,2,0,0,1-1.8-1.13l-3.8-7.86a13.94,13.94,0,0,0-9.66-7.59l-10.71-2.3L94.4,103a2,2,0,0,1,1.74-1h16.71a13.9,13.9,0,0,0,6.76-1.75l12.25-6.75a14.73,14.73,0,0,0,2.62-1.88l26.91-24.33a13.93,13.93,0,0,0,2.83-17.21L161,44.25A90.16,90.16,0,0,1,218,128ZM144.6,39.54l9.15,16.39a2,2,0,0,1-.41,2.46L126.43,82.72a1.84,1.84,0,0,1-.37.27l-12.25,6.76a2,2,0,0,1-1,.25H96.14A14,14,0,0,0,84,97L73.18,115.91a2,2,0,0,1-.19-.35L61.5,84.89a2,2,0,0,1,0-1.48L72.68,57.06A89.9,89.9,0,0,1,144.6,39.54ZM38,128A89.52,89.52,0,0,1,49.38,84.23a13.85,13.85,0,0,0,.89,4.87l11.49,30.67a13.94,13.94,0,0,0,10.16,8.78l21.44,4.6a2,2,0,0,1,1.38,1.09l3.8,7.86a14.07,14.07,0,0,0,12.6,7.9h4.56l-8.49,19a14,14,0,0,0,2.51,15.2l.1.11,19.68,20.26a2,2,0,0,1,.46,1.7L127.7,218A90.1,90.1,0,0,1,38,128Zm102.08,89.19,1.67-8.6a14.07,14.07,0,0,0-3.47-12.16l-.1-.11L118.5,176.06a2,2,0,0,1-.33-2.14l13.7-30.73A2,2,0,0,1,134,142l22.82,3.08a2,2,0,0,1,.78.27L205,174.55A90.18,90.18,0,0,1,140.08,217.19Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm88,104a87.62,87.62,0,0,1-6.4,32.94l-44.7-27.49a15.92,15.92,0,0,0-6.24-2.23l-22.82-3.08a16.11,16.11,0,0,0-16,7.86h-8.72l-3.8-7.86a15.91,15.91,0,0,0-11-8.67l-8-1.73L96.14,104h16.71a16.06,16.06,0,0,0,7.73-2l12.25-6.76a16.62,16.62,0,0,0,3-2.14l26.91-24.34A15.93,15.93,0,0,0,166,49.1l-.36-.65A88.11,88.11,0,0,1,216,128ZM143.31,41.34,152,56.9,125.09,81.24,112.85,88H96.14a16,16,0,0,0-13.88,8l-8.73,15.23L63.38,84.19,74.32,58.32a87.87,87.87,0,0,1,69-17ZM40,128a87.53,87.53,0,0,1,8.54-37.8l11.34,30.27a16,16,0,0,0,11.62,10l21.43,4.61L96.74,143a16.09,16.09,0,0,0,14.4,9h1.48l-7.23,16.23a16,16,0,0,0,2.86,17.37l.14.14L128,205.94l-1.94,10A88.11,88.11,0,0,1,40,128Zm102.58,86.78,1.13-5.81a16.09,16.09,0,0,0-4-13.9,1.85,1.85,0,0,1-.14-.14L120,174.74,133.7,144l22.82,3.08,45.72,28.12A88.18,88.18,0,0,1,142.58,214.78Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,28A100,100,0,1,0,228,128,100.11,100.11,0,0,0,128,28Zm92,100a91.44,91.44,0,0,1-8.58,38.76L162.8,136.85a12.07,12.07,0,0,0-4.68-1.67l-22.82-3.07a12,12,0,0,0-12.56,7l-.4.88h-11.2a4,4,0,0,1-3.6-2.26l-3.8-7.86a11.93,11.93,0,0,0-8.28-6.5L82.07,120.5,92.67,102a4,4,0,0,1,3.47-2h16.71a12,12,0,0,0,5.8-1.5l12.24-6.76a11.79,11.79,0,0,0,2.25-1.6L160.05,65.8a12,12,0,0,0,2.43-14.75l-5.86-10.49A92.17,92.17,0,0,1,220,128ZM145.89,37.75l9.6,17.2a4,4,0,0,1-.81,4.92L127.77,84.21a4.41,4.41,0,0,1-.75.53L114.78,91.5a4,4,0,0,1-1.93.5H96.14a12,12,0,0,0-10.41,6l-11.86,20.7a4,4,0,0,1-2.75-2.47L59.63,85.6a4,4,0,0,1,.06-3L71,55.81A91.51,91.51,0,0,1,128,36,92.53,92.53,0,0,1,145.89,37.75ZM36,128A91.52,91.52,0,0,1,56,70.77l-3.71,8.75a12,12,0,0,0-.18,8.88l11.49,30.67a11.93,11.93,0,0,0,8.72,7.52l21.43,4.61a4,4,0,0,1,2.76,2.17l3.8,7.86a12.07,12.07,0,0,0,10.8,6.77h7.64L109,169.85A12,12,0,0,0,111.26,183l19.68,20.26a4,4,0,0,1,1,3.47L129.36,220,128,220A92.1,92.1,0,0,1,36,128Zm101.6,91.5,2.18-11.29a12.08,12.08,0,0,0-3-10.49l-19.68-20.26a4,4,0,0,1-.71-4.35l13.7-30.74a4,4,0,0,1,4.18-2.33l22.82,3.07a4.12,4.12,0,0,1,1.56.56l49.11,30.2A92.12,92.12,0,0,1,137.6,219.5Z" }))
  ]
]), JX = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,20H40A20,20,0,0,0,20,40V216a20,20,0,0,0,20,20H216a20,20,0,0,0,20-20V40A20,20,0,0,0,216,20Zm-4,192H44V44H212ZM112,176V120a12,12,0,0,1,21.43-7.41A40,40,0,0,1,192,148v28a12,12,0,0,1-24,0V148a16,16,0,0,0-32,0v28a12,12,0,0,1-24,0ZM96,120v56a12,12,0,0,1-24,0V120a12,12,0,0,1,24,0ZM68,80A16,16,0,1,1,84,96,16,16,0,0,1,68,80Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M224,40V216a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V40a8,8,0,0,1,8-8H216A8,8,0,0,1,224,40Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M216,24H40A16,16,0,0,0,24,40V216a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V40A16,16,0,0,0,216,24Zm0,192H40V40H216V216ZM96,112v64a8,8,0,0,1-16,0V112a8,8,0,0,1,16,0Zm88,28v36a8,8,0,0,1-16,0V140a20,20,0,0,0-40,0v36a8,8,0,0,1-16,0V112a8,8,0,0,1,15.79-1.78A36,36,0,0,1,184,140ZM100,84A12,12,0,1,1,88,72,12,12,0,0,1,100,84Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,24H40A16,16,0,0,0,24,40V216a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V40A16,16,0,0,0,216,24ZM96,176a8,8,0,0,1-16,0V112a8,8,0,0,1,16,0ZM88,96a12,12,0,1,1,12-12A12,12,0,0,1,88,96Zm96,80a8,8,0,0,1-16,0V140a20,20,0,0,0-40,0v36a8,8,0,0,1-16,0V112a8,8,0,0,1,15.79-1.78A36,36,0,0,1,184,140Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,26H40A14,14,0,0,0,26,40V216a14,14,0,0,0,14,14H216a14,14,0,0,0,14-14V40A14,14,0,0,0,216,26Zm2,190a2,2,0,0,1-2,2H40a2,2,0,0,1-2-2V40a2,2,0,0,1,2-2H216a2,2,0,0,1,2,2ZM94,112v64a6,6,0,0,1-12,0V112a6,6,0,0,1,12,0Zm88,28v36a6,6,0,0,1-12,0V140a22,22,0,0,0-44,0v36a6,6,0,0,1-12,0V112a6,6,0,0,1,12,0v2.11A34,34,0,0,1,182,140ZM98,84A10,10,0,1,1,88,74,10,10,0,0,1,98,84Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,24H40A16,16,0,0,0,24,40V216a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V40A16,16,0,0,0,216,24Zm0,192H40V40H216V216ZM96,112v64a8,8,0,0,1-16,0V112a8,8,0,0,1,16,0Zm88,28v36a8,8,0,0,1-16,0V140a20,20,0,0,0-40,0v36a8,8,0,0,1-16,0V112a8,8,0,0,1,15.79-1.78A36,36,0,0,1,184,140ZM100,84A12,12,0,1,1,88,72,12,12,0,0,1,100,84Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,28H40A12,12,0,0,0,28,40V216a12,12,0,0,0,12,12H216a12,12,0,0,0,12-12V40A12,12,0,0,0,216,28Zm4,188a4,4,0,0,1-4,4H40a4,4,0,0,1-4-4V40a4,4,0,0,1,4-4H216a4,4,0,0,1,4,4ZM92,112v64a4,4,0,0,1-8,0V112a4,4,0,0,1,8,0Zm88,28v36a4,4,0,0,1-8,0V140a24,24,0,0,0-48,0v36a4,4,0,0,1-8,0V112a4,4,0,0,1,8,0v6.87A32,32,0,0,1,180,140ZM96,84a8,8,0,1,1-8-8A8,8,0,0,1,96,84Z" }))
  ]
]), eZ = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M230.14,25.86a20,20,0,0,0-19.57-5.11l-.22.07L18.44,79a20,20,0,0,0-3.06,37.25L99,157l40.71,83.65a19.81,19.81,0,0,0,18,11.38c.57,0,1.15,0,1.73-.07A19.82,19.82,0,0,0,177,237.56L235.18,45.65a1.42,1.42,0,0,0,.07-.22A20,20,0,0,0,230.14,25.86ZM156.91,221.07l-34.37-70.64,46-45.95a12,12,0,0,0-17-17l-46,46L34.93,99.09,210,46Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M223.69,42.18l-58.22,192a8,8,0,0,1-14.92,1.25L108,148,20.58,105.45a8,8,0,0,1,1.25-14.92l192-58.22A8,8,0,0,1,223.69,42.18Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M227.32,28.68a16,16,0,0,0-15.66-4.08l-.15,0L19.57,82.84a16,16,0,0,0-2.49,29.8L102,154l41.3,84.87A15.86,15.86,0,0,0,157.74,248q.69,0,1.38-.06a15.88,15.88,0,0,0,14-11.51l58.2-191.94c0-.05,0-.1,0-.15A16,16,0,0,0,227.32,28.68ZM157.83,231.85l-.05.14,0-.07-40.06-82.3,48-48a8,8,0,0,0-11.31-11.31l-48,48L24.08,98.25l-.07,0,.14,0L216,40Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M231.4,44.34s0,.1,0,.15l-58.2,191.94a15.88,15.88,0,0,1-14,11.51q-.69.06-1.38.06a15.86,15.86,0,0,1-14.42-9.15L107,164.15a4,4,0,0,1,.77-4.58l57.92-57.92a8,8,0,0,0-11.31-11.31L96.43,148.26a4,4,0,0,1-4.58.77L17.08,112.64a16,16,0,0,1,2.49-29.8l191.94-58.2.15,0A16,16,0,0,1,231.4,44.34Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M225.88,30.12a13.83,13.83,0,0,0-13.7-3.58l-.11,0L20.14,84.77A14,14,0,0,0,18,110.85l85.56,41.64L145.12,238a13.87,13.87,0,0,0,12.61,8c.4,0,.81,0,1.21-.05a13.9,13.9,0,0,0,12.29-10.09l58.2-191.93,0-.11A13.83,13.83,0,0,0,225.88,30.12Zm-8,10.4L159.73,232.43l0,.11a2,2,0,0,1-3.76.26l-40.68-83.58,49-49a6,6,0,1,0-8.49-8.49l-49,49L23.15,100a2,2,0,0,1,.31-3.74l.11,0L215.48,38.08a1.94,1.94,0,0,1,1.92.52A2,2,0,0,1,217.92,40.52Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M227.32,28.68a16,16,0,0,0-15.66-4.08l-.15,0L19.57,82.84a16,16,0,0,0-2.49,29.8L102,154l41.3,84.87A15.86,15.86,0,0,0,157.74,248q.69,0,1.38-.06a15.88,15.88,0,0,0,14-11.51l58.2-191.94c0-.05,0-.1,0-.15A16,16,0,0,0,227.32,28.68ZM157.83,231.85l-.05.14,0-.07-40.06-82.3,48-48a8,8,0,0,0-11.31-11.31l-48,48L24.08,98.25l-.07,0,.14,0L216,40Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M224.47,31.52a11.87,11.87,0,0,0-11.82-3L20.74,86.67a12,12,0,0,0-1.91,22.38L105,151l41.92,86.15A11.88,11.88,0,0,0,157.74,244c.34,0,.69,0,1,0a11.89,11.89,0,0,0,10.52-8.63l58.21-192,0-.08A11.85,11.85,0,0,0,224.47,31.52Zm-4.62,9.54-58.23,192a4,4,0,0,1-7.48.59l-41.3-84.86,50-50a4,4,0,1,0-5.66-5.66l-50,50-84.9-41.31a3.88,3.88,0,0,1-2.27-4,3.93,3.93,0,0,1,3-3.54L214.9,36.16A3.93,3.93,0,0,1,216,36a4,4,0,0,1,2.79,1.19A3.93,3.93,0,0,1,219.85,41.06Z" }))
  ]
]), tZ = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M250.73,210.63l-56-112a12,12,0,0,0-21.46,0l-20.52,41A84.2,84.2,0,0,1,114,126.22,107.48,107.48,0,0,0,139.33,68H160a12,12,0,0,0,0-24H108V32a12,12,0,0,0-24,0V44H32a12,12,0,0,0,0,24h83.13A83.69,83.69,0,0,1,96,110.35,84,84,0,0,1,83.6,91a12,12,0,1,0-21.81,10A107.55,107.55,0,0,0,78,126.24,83.54,83.54,0,0,1,32,140a12,12,0,0,0,0,24,107.47,107.47,0,0,0,64-21.07,108.4,108.4,0,0,0,45.39,19.44l-24.13,48.26a12,12,0,1,0,21.46,10.73L151.41,196h65.17l12.68,25.36a12,12,0,1,0,21.47-10.73ZM163.41,172,184,130.83,204.58,172Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M224,184H144l40-80ZM96,127.56h0A95.78,95.78,0,0,0,128,56H64A95.78,95.78,0,0,0,96,127.56Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M247.15,212.42l-56-112a8,8,0,0,0-14.31,0l-21.71,43.43A88,88,0,0,1,108,126.93,103.65,103.65,0,0,0,135.69,64H160a8,8,0,0,0,0-16H104V32a8,8,0,0,0-16,0V48H32a8,8,0,0,0,0,16h87.63A87.7,87.7,0,0,1,96,116.35a87.74,87.74,0,0,1-19-31,8,8,0,1,0-15.08,5.34A103.63,103.63,0,0,0,84,127a87.55,87.55,0,0,1-52,17,8,8,0,0,0,0,16,103.46,103.46,0,0,0,64-22.08,104.18,104.18,0,0,0,51.44,21.31l-26.6,53.19a8,8,0,0,0,14.31,7.16L148.94,192h70.11l13.79,27.58A8,8,0,0,0,240,224a8,8,0,0,0,7.15-11.58ZM156.94,176,184,121.89,211.05,176Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M160,129.89,175.06,160H144.94l6.36-12.7v0ZM224,48V208a16,16,0,0,1-16,16H48a16,16,0,0,1-16-16V48A16,16,0,0,1,48,32H208A16,16,0,0,1,224,48ZM207.16,188.42l-40-80a8,8,0,0,0-14.32,0L139.66,134.8a62.31,62.31,0,0,1-23.61-10A79.61,79.61,0,0,0,135.6,80H152a8,8,0,0,0,0-16H112V56a8,8,0,0,0-16,0v8H56a8,8,0,0,0,0,16h63.48a63.73,63.73,0,0,1-15.3,34.05,65.93,65.93,0,0,1-9-13.61,8,8,0,0,0-14.32,7.12,81.75,81.75,0,0,0,11.4,17.15A63.62,63.62,0,0,1,56,136a8,8,0,0,0,0,16,79.56,79.56,0,0,0,48.11-16.13,78.33,78.33,0,0,0,28.18,13.66l-19.45,38.89a8,8,0,0,0,14.32,7.16L136.94,176h46.12l9.78,19.58a8,8,0,1,0,14.32-7.16Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M245.37,213.32l-56-112a6,6,0,0,0-10.74,0l-22.3,44.6A90,90,0,0,1,105,127.19,101.73,101.73,0,0,0,133.82,62H160a6,6,0,0,0,0-12H102V32a6,6,0,0,0-12,0V50H32a6,6,0,0,0,0,12h89.79A89.71,89.71,0,0,1,96,119.23,89.81,89.81,0,0,1,75.11,86,6,6,0,1,0,63.8,90,101.66,101.66,0,0,0,87,127.2,89.56,89.56,0,0,1,32,146a6,6,0,0,0,0,12,101.55,101.55,0,0,0,64-22.63,102.11,102.11,0,0,0,54.53,22.17l-27.89,55.78a6,6,0,0,0,10.74,5.36L147.71,190h72.58l14.34,28.68A6,6,0,0,0,240,222a5.87,5.87,0,0,0,2.68-.64A6,6,0,0,0,245.37,213.32ZM153.71,178,184,117.42,214.29,178Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M247.15,212.42l-56-112a8,8,0,0,0-14.31,0l-21.71,43.43A88,88,0,0,1,108,126.93,103.65,103.65,0,0,0,135.69,64H160a8,8,0,0,0,0-16H104V32a8,8,0,0,0-16,0V48H32a8,8,0,0,0,0,16h87.63A87.76,87.76,0,0,1,96,116.35a87.74,87.74,0,0,1-19-31,8,8,0,1,0-15.08,5.34A103.63,103.63,0,0,0,84,127a87.55,87.55,0,0,1-52,17,8,8,0,0,0,0,16,103.46,103.46,0,0,0,64-22.08,104.18,104.18,0,0,0,51.44,21.31l-26.6,53.19a8,8,0,0,0,14.31,7.16L148.94,192h70.11l13.79,27.58A8,8,0,0,0,240,224a8,8,0,0,0,7.15-11.58ZM156.94,176,184,121.89,211.05,176Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M243.58,214.21l-56-112a4,4,0,0,0-7.16,0L157.55,148A92.05,92.05,0,0,1,102,127.36,99.68,99.68,0,0,0,131.91,60H160a4,4,0,0,0,0-8H100V32a4,4,0,0,0-8,0V52H32a4,4,0,0,0,0,8h91.91A91.8,91.8,0,0,1,96,122.05,92,92,0,0,1,73.23,86.67a4,4,0,1,0-7.54,2.66,99.59,99.59,0,0,0,24.3,38A91.59,91.59,0,0,1,32,148a4,4,0,0,0,0,8,99.54,99.54,0,0,0,64-23.21,100.09,100.09,0,0,0,57.66,23l-29.22,58.43a4,4,0,1,0,7.16,3.58L146.47,188h75.06l14.89,29.79A4,4,0,0,0,240,220a4.12,4.12,0,0,0,1.79-.42A4,4,0,0,0,243.58,214.21ZM150.47,180,184,112.94,217.53,180Z" }))
  ]
]), rZ = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M218.12,209.56l-61-95.8,59.72-65.69a12,12,0,0,0-17.76-16.14L143.81,92.77,106.12,33.56A12,12,0,0,0,96,28H48A12,12,0,0,0,37.88,46.44l61,95.8L39.12,207.93a12,12,0,1,0,17.76,16.14l55.31-60.84,37.69,59.21A12,12,0,0,0,160,228h48a12,12,0,0,0,10.12-18.44ZM166.59,204,69.86,52H89.41l96.73,152Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M208,216H160L48,40H96Z", opacity: "0.2" }), /* @__PURE__ */ H.createElement("path", { d: "M214.75,211.71l-62.6-98.38,61.77-67.95a8,8,0,0,0-11.84-10.76L143.24,99.34,102.75,35.71A8,8,0,0,0,96,32H48a8,8,0,0,0-6.75,12.3l62.6,98.37-61.77,68a8,8,0,1,0,11.84,10.76l58.84-64.72,40.49,63.63A8,8,0,0,0,160,224h48a8,8,0,0,0,6.75-12.29ZM164.39,208,62.57,48h29L193.43,208Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M215,219.85a8,8,0,0,1-7,4.15H160a8,8,0,0,1-6.75-3.71l-40.49-63.63L53.92,221.38a8,8,0,0,1-11.84-10.76l61.77-68L41.25,44.3A8,8,0,0,1,48,32H96a8,8,0,0,1,6.75,3.71l40.49,63.63,58.84-64.72a8,8,0,0,1,11.84,10.76l-61.77,67.95,62.6,98.38A8,8,0,0,1,215,219.85Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M213.06,212.78l-63.42-99.66L212.44,44A6,6,0,1,0,203.56,36L143,102.62l-41.9-65.84A6,6,0,0,0,96,34H48a6,6,0,0,0-5.06,9.22l63.42,99.66L43.56,212A6,6,0,0,0,52.44,220L113,153.38l41.9,65.84A6,6,0,0,0,160,222h48a6,6,0,0,0,5.06-9.22ZM163.29,210,58.93,46H92.71L197.07,210Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M214.75,211.71l-62.6-98.38,61.77-67.95a8,8,0,0,0-11.84-10.76L143.24,99.34,102.75,35.71A8,8,0,0,0,96,32H48a8,8,0,0,0-6.75,12.3l62.6,98.37-61.77,68a8,8,0,1,0,11.84,10.76l58.84-64.72,40.49,63.63A8,8,0,0,0,160,224h48a8,8,0,0,0,6.75-12.29ZM164.39,208,62.57,48h29L193.43,208Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M211.37,213.85,147.13,112.9,211,42.69A4,4,0,0,0,205,37.31L142.68,105.9,99.38,37.85A4,4,0,0,0,96,36H48a4,4,0,0,0-3.37,6.15L108.87,143.1,45,213.31A4,4,0,1,0,51,218.69l62.36-68.59,43.3,68.05A4,4,0,0,0,160,220h48a4,4,0,0,0,3.37-6.15ZM162.2,212,55.29,44H93.8L200.71,212Z" }))
  ]
]), nZ = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M170.49,117.91l-56-36A12,12,0,0,0,96,92v72a12,12,0,0,0,18.49,10.09l56-36a12,12,0,0,0,0-20.18ZM120,142V114l21.81,14Zm118.21-73.5a28.05,28.05,0,0,0-16.93-19.14C186.4,35.91,131.29,36,128,36s-58.4-.09-93.28,13.38A28.05,28.05,0,0,0,17.79,68.52C15.15,78.72,12,97.32,12,128s3.15,49.28,5.79,59.48a28.05,28.05,0,0,0,16.93,19.14C68.21,219.55,120.36,220,127.37,220h1.26c7,0,59.16-.45,92.65-13.38a28.05,28.05,0,0,0,16.93-19.14c2.64-10.2,5.79-28.8,5.79-59.48S240.85,78.72,238.21,68.52ZM215,181.46a4,4,0,0,1-2.34,2.77C182.78,195.76,132.27,196,128.32,196h-.39c-.53,0-53.64.17-84.56-11.77A4,4,0,0,1,41,181.46c-1.88-7.24-5-23.82-5-53.46s3.15-46.22,5-53.46a4,4,0,0,1,2.34-2.77C74.29,59.83,127.39,60,127.92,60h.15c.54,0,53.64-.17,84.56,11.77A4,4,0,0,1,215,74.54c1.88,7.24,5,23.82,5,53.46S216.85,174.22,215,181.46Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M226.59,71.53a16,16,0,0,0-9.63-11C183.48,47.65,128,48,128,48s-55.48-.35-89,12.58a16,16,0,0,0-9.63,11C27.07,80.54,24,98.09,24,128s3.07,47.46,5.41,56.47A16,16,0,0,0,39,195.42C72.52,208.35,128,208,128,208s55.48.35,89-12.58a16,16,0,0,0,9.63-10.95c2.34-9,5.41-26.56,5.41-56.47S228.93,80.54,226.59,71.53ZM112,160V96l48,32Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M164.44,121.34l-48-32A8,8,0,0,0,104,96v64a8,8,0,0,0,12.44,6.66l48-32a8,8,0,0,0,0-13.32ZM120,145.05V111l25.58,17ZM234.33,69.52a24,24,0,0,0-14.49-16.4C185.56,39.88,131,40,128,40s-57.56-.12-91.84,13.12a24,24,0,0,0-14.49,16.4C19.08,79.5,16,97.74,16,128s3.08,48.5,5.67,58.48a24,24,0,0,0,14.49,16.41C69,215.56,120.4,216,127.34,216h1.32c6.94,0,58.37-.44,91.18-13.11a24,24,0,0,0,14.49-16.41c2.59-10,5.67-28.22,5.67-58.48S236.92,79.5,234.33,69.52Zm-15.49,113a8,8,0,0,1-4.77,5.49c-31.65,12.22-85.48,12-86.12,12s-54.37.18-86-12a8,8,0,0,1-4.77-5.49C34.8,173.39,32,156.57,32,128s2.8-45.39,5.16-54.47A8,8,0,0,1,41.93,68C73.58,55.82,127.4,56,128.05,56s54.37-.18,86,12a8,8,0,0,1,4.77,5.49C221.2,82.61,224,99.43,224,128S221.2,173.39,218.84,182.47Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M234.33,69.52a24,24,0,0,0-14.49-16.4C185.56,39.88,131,40,128,40s-57.56-.12-91.84,13.12a24,24,0,0,0-14.49,16.4C19.08,79.5,16,97.74,16,128s3.08,48.5,5.67,58.48a24,24,0,0,0,14.49,16.41C69,215.56,120.4,216,127.34,216h1.32c6.94,0,58.37-.44,91.18-13.11a24,24,0,0,0,14.49-16.41c2.59-10,5.67-28.22,5.67-58.48S236.92,79.5,234.33,69.52Zm-73.74,65-40,28A8,8,0,0,1,108,156V100a8,8,0,0,1,12.59-6.55l40,28a8,8,0,0,1,0,13.1Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M163.33,123l-48-32A6,6,0,0,0,106,96v64a6,6,0,0,0,9.33,5l48-32a6,6,0,0,0,0-10ZM118,148.79V107.21L149.18,128ZM232.4,70a22,22,0,0,0-13.28-15C185,41.79,130.27,42,128,42s-57-.21-91.16,13A22,22,0,0,0,23.6,70C21.05,79.89,18,98,18,128s3.05,48.11,5.6,58a22,22,0,0,0,13.28,15C71,214.21,125.72,214,128,214h.71c6.91,0,58-.44,90.45-13a22,22,0,0,0,13.28-15c2.55-9.87,5.6-27.93,5.6-58S235,79.89,232.4,70ZM220.78,183a10,10,0,0,1-6,6.86C182.78,202.19,128.58,202,128,202s-54.71.2-86.75-12.17a10,10,0,0,1-6-6.86C32.84,173.78,30,156.78,30,128s2.84-45.78,5.22-55a10,10,0,0,1,6-6.86C72.06,54.26,123.53,54,127.76,54H128c.54,0,54.71-.2,86.75,12.17a10,10,0,0,1,6,6.86c2.38,9.19,5.22,26.19,5.22,55S223.16,173.78,220.78,183Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M164.44,121.34l-48-32A8,8,0,0,0,104,96v64a8,8,0,0,0,12.44,6.66l48-32a8,8,0,0,0,0-13.32ZM120,145.05V111l25.58,17ZM234.33,69.52a24,24,0,0,0-14.49-16.4C185.56,39.88,131,40,128,40s-57.56-.12-91.84,13.12a24,24,0,0,0-14.49,16.4C19.08,79.5,16,97.74,16,128s3.08,48.5,5.67,58.48a24,24,0,0,0,14.49,16.41C69,215.56,120.4,216,127.34,216h1.32c6.94,0,58.37-.44,91.18-13.11a24,24,0,0,0,14.49-16.41c2.59-10,5.67-28.22,5.67-58.48S236.92,79.5,234.33,69.52Zm-15.49,113a8,8,0,0,1-4.77,5.49c-31.65,12.22-85.48,12-86,12H128c-.54,0-54.33.2-86-12a8,8,0,0,1-4.77-5.49C34.8,173.39,32,156.57,32,128s2.8-45.39,5.16-54.47A8,8,0,0,1,41.93,68c30.52-11.79,81.66-12,85.85-12h.27c.54,0,54.38-.18,86,12a8,8,0,0,1,4.77,5.49C221.2,82.61,224,99.43,224,128S221.2,173.39,218.84,182.47Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M162.22,124.67l-48-32A4,4,0,0,0,108,96v64a4,4,0,0,0,2.11,3.53,4,4,0,0,0,4.11-.2l48-32a4,4,0,0,0,0-6.66ZM116,152.53V103.47L152.79,128Zm114.46-82A20,20,0,0,0,218.4,56.85C184.6,43.79,130.27,44,128,44S71.4,43.79,37.6,56.85A20,20,0,0,0,25.54,70.52C23,80.27,20,98.16,20,128s3,47.73,5.54,57.48A20,20,0,0,0,37.6,199.15C71.4,212.21,125.73,212,128,212h.71c6.89,0,57.58-.43,89.72-12.85a20,20,0,0,0,12.06-13.67C233,175.72,236,157.84,236,128S233,80.27,230.46,70.52Zm-7.74,113a12,12,0,0,1-7.21,8.22C183.14,204.19,128.57,204,128,204s-55.11.19-87.48-12.31a12,12,0,0,1-7.21-8.22C30.87,174.17,28,157,28,128s2.87-46.17,5.28-55.47a12,12,0,0,1,7.21-8.22C72.86,51.81,127.43,52,128,52s55.11-.2,87.48,12.31a12,12,0,0,1,7.21,8.22C225.13,81.83,228,99,228,128S225.13,174.17,222.72,183.47Z" }))
  ]
]), iZ = du({
  color: "currentColor",
  size: "1em",
  weight: "regular",
  mirrored: !1
});
var oZ = Object.defineProperty, P0 = Object.getOwnPropertySymbols, SG = Object.prototype.hasOwnProperty, wG = Object.prototype.propertyIsEnumerable, $I = (e, t, r) => t in e ? oZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, HI = (e, t) => {
  for (var r in t || (t = {}))
    SG.call(t, r) && $I(e, r, t[r]);
  if (P0)
    for (var r of P0(t))
      wG.call(t, r) && $I(e, r, t[r]);
  return e;
}, GI = (e, t) => {
  var r = {};
  for (var n in e)
    SG.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && P0)
    for (var n of P0(e))
      t.indexOf(n) < 0 && wG.call(e, n) && (r[n] = e[n]);
  return r;
};
const bG = yn((e, t) => {
  const r = e, {
    alt: n,
    color: i,
    size: o,
    weight: a,
    mirrored: s,
    children: l,
    weights: u
  } = r, c = GI(r, [
    "alt",
    "color",
    "size",
    "weight",
    "mirrored",
    "children",
    "weights"
  ]), d = vr(iZ), {
    color: h = "currentColor",
    size: f,
    weight: p = "regular",
    mirrored: g = !1
  } = d, v = GI(d, [
    "color",
    "size",
    "weight",
    "mirrored"
  ]);
  return /* @__PURE__ */ H.createElement(
    "svg",
    HI(HI({
      ref: t,
      xmlns: "http://www.w3.org/2000/svg",
      width: o ?? f,
      height: o ?? f,
      fill: i ?? h,
      viewBox: "0 0 256 256",
      transform: s || g ? "scale(-1, 1)" : void 0
    }, v), c),
    !!n && /* @__PURE__ */ H.createElement("title", null, n),
    l,
    u.get(a ?? p)
  );
});
bG.displayName = "IconBase";
const ka = bG;
var aZ = Object.defineProperty, sZ = Object.defineProperties, lZ = Object.getOwnPropertyDescriptors, zI = Object.getOwnPropertySymbols, uZ = Object.prototype.hasOwnProperty, cZ = Object.prototype.propertyIsEnumerable, WI = (e, t, r) => t in e ? aZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, dZ = (e, t) => {
  for (var r in t || (t = {}))
    uZ.call(t, r) && WI(e, r, t[r]);
  if (zI)
    for (var r of zI(t))
      cZ.call(t, r) && WI(e, r, t[r]);
  return e;
}, hZ = (e, t) => sZ(e, lZ(t));
const xG = yn((e, t) => /* @__PURE__ */ H.createElement(ka, hZ(dZ({ ref: t }, e), { weights: KX })));
xG.displayName = "ArrowClockwise";
var fZ = Object.defineProperty, pZ = Object.defineProperties, gZ = Object.getOwnPropertyDescriptors, jI = Object.getOwnPropertySymbols, vZ = Object.prototype.hasOwnProperty, mZ = Object.prototype.propertyIsEnumerable, UI = (e, t, r) => t in e ? fZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, yZ = (e, t) => {
  for (var r in t || (t = {}))
    vZ.call(t, r) && UI(e, r, t[r]);
  if (jI)
    for (var r of jI(t))
      mZ.call(t, r) && UI(e, r, t[r]);
  return e;
}, CZ = (e, t) => pZ(e, gZ(t));
const HE = yn((e, t) => /* @__PURE__ */ H.createElement(ka, CZ(yZ({ ref: t }, e), { weights: YX })));
HE.displayName = "CaretDown";
var SZ = Object.defineProperty, wZ = Object.defineProperties, bZ = Object.getOwnPropertyDescriptors, KI = Object.getOwnPropertySymbols, xZ = Object.prototype.hasOwnProperty, EZ = Object.prototype.propertyIsEnumerable, YI = (e, t, r) => t in e ? SZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, RZ = (e, t) => {
  for (var r in t || (t = {}))
    xZ.call(t, r) && YI(e, r, t[r]);
  if (KI)
    for (var r of KI(t))
      EZ.call(t, r) && YI(e, r, t[r]);
  return e;
}, _Z = (e, t) => wZ(e, bZ(t));
const EG = yn((e, t) => /* @__PURE__ */ H.createElement(ka, _Z(RZ({ ref: t }, e), { weights: qX })));
EG.displayName = "CheckCircle";
var TZ = Object.defineProperty, PZ = Object.defineProperties, MZ = Object.getOwnPropertyDescriptors, qI = Object.getOwnPropertySymbols, DZ = Object.prototype.hasOwnProperty, AZ = Object.prototype.propertyIsEnumerable, XI = (e, t, r) => t in e ? TZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, IZ = (e, t) => {
  for (var r in t || (t = {}))
    DZ.call(t, r) && XI(e, r, t[r]);
  if (qI)
    for (var r of qI(t))
      AZ.call(t, r) && XI(e, r, t[r]);
  return e;
}, OZ = (e, t) => PZ(e, MZ(t));
const RG = yn((e, t) => /* @__PURE__ */ H.createElement(ka, OZ(IZ({ ref: t }, e), { weights: XX })));
RG.displayName = "Clipboard";
var LZ = Object.defineProperty, FZ = Object.defineProperties, NZ = Object.getOwnPropertyDescriptors, ZI = Object.getOwnPropertySymbols, kZ = Object.prototype.hasOwnProperty, VZ = Object.prototype.propertyIsEnumerable, QI = (e, t, r) => t in e ? LZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, BZ = (e, t) => {
  for (var r in t || (t = {}))
    kZ.call(t, r) && QI(e, r, t[r]);
  if (ZI)
    for (var r of ZI(t))
      VZ.call(t, r) && QI(e, r, t[r]);
  return e;
}, $Z = (e, t) => FZ(e, NZ(t));
const _G = yn((e, t) => /* @__PURE__ */ H.createElement(ka, $Z(BZ({ ref: t }, e), { weights: ZX })));
_G.displayName = "Download";
var HZ = Object.defineProperty, GZ = Object.defineProperties, zZ = Object.getOwnPropertyDescriptors, JI = Object.getOwnPropertySymbols, WZ = Object.prototype.hasOwnProperty, jZ = Object.prototype.propertyIsEnumerable, e2 = (e, t, r) => t in e ? HZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, UZ = (e, t) => {
  for (var r in t || (t = {}))
    WZ.call(t, r) && e2(e, r, t[r]);
  if (JI)
    for (var r of JI(t))
      jZ.call(t, r) && e2(e, r, t[r]);
  return e;
}, KZ = (e, t) => GZ(e, zZ(t));
const TG = yn((e, t) => /* @__PURE__ */ H.createElement(ka, KZ(UZ({ ref: t }, e), { weights: QX })));
TG.displayName = "GlobeHemisphereWest";
var YZ = Object.defineProperty, qZ = Object.defineProperties, XZ = Object.getOwnPropertyDescriptors, t2 = Object.getOwnPropertySymbols, ZZ = Object.prototype.hasOwnProperty, QZ = Object.prototype.propertyIsEnumerable, r2 = (e, t, r) => t in e ? YZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, JZ = (e, t) => {
  for (var r in t || (t = {}))
    ZZ.call(t, r) && r2(e, r, t[r]);
  if (t2)
    for (var r of t2(t))
      QZ.call(t, r) && r2(e, r, t[r]);
  return e;
}, eQ = (e, t) => qZ(e, XZ(t));
const PG = yn((e, t) => /* @__PURE__ */ H.createElement(ka, eQ(JZ({ ref: t }, e), { weights: JX })));
PG.displayName = "LinkedinLogo";
var tQ = Object.defineProperty, rQ = Object.defineProperties, nQ = Object.getOwnPropertyDescriptors, n2 = Object.getOwnPropertySymbols, iQ = Object.prototype.hasOwnProperty, oQ = Object.prototype.propertyIsEnumerable, i2 = (e, t, r) => t in e ? tQ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, aQ = (e, t) => {
  for (var r in t || (t = {}))
    iQ.call(t, r) && i2(e, r, t[r]);
  if (n2)
    for (var r of n2(t))
      oQ.call(t, r) && i2(e, r, t[r]);
  return e;
}, sQ = (e, t) => rQ(e, nQ(t));
const CP = yn((e, t) => /* @__PURE__ */ H.createElement(ka, sQ(aQ({ ref: t }, e), { weights: eZ })));
CP.displayName = "PaperPlaneTilt";
var lQ = Object.defineProperty, uQ = Object.defineProperties, cQ = Object.getOwnPropertyDescriptors, o2 = Object.getOwnPropertySymbols, dQ = Object.prototype.hasOwnProperty, hQ = Object.prototype.propertyIsEnumerable, a2 = (e, t, r) => t in e ? lQ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, fQ = (e, t) => {
  for (var r in t || (t = {}))
    dQ.call(t, r) && a2(e, r, t[r]);
  if (o2)
    for (var r of o2(t))
      hQ.call(t, r) && a2(e, r, t[r]);
  return e;
}, pQ = (e, t) => uQ(e, cQ(t));
const MG = yn((e, t) => /* @__PURE__ */ H.createElement(ka, pQ(fQ({ ref: t }, e), { weights: tZ })));
MG.displayName = "Translate";
var gQ = Object.defineProperty, vQ = Object.defineProperties, mQ = Object.getOwnPropertyDescriptors, s2 = Object.getOwnPropertySymbols, yQ = Object.prototype.hasOwnProperty, CQ = Object.prototype.propertyIsEnumerable, l2 = (e, t, r) => t in e ? gQ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, SQ = (e, t) => {
  for (var r in t || (t = {}))
    yQ.call(t, r) && l2(e, r, t[r]);
  if (s2)
    for (var r of s2(t))
      CQ.call(t, r) && l2(e, r, t[r]);
  return e;
}, wQ = (e, t) => vQ(e, mQ(t));
const DG = yn((e, t) => /* @__PURE__ */ H.createElement(ka, wQ(SQ({ ref: t }, e), { weights: rZ })));
DG.displayName = "XLogo";
var bQ = Object.defineProperty, xQ = Object.defineProperties, EQ = Object.getOwnPropertyDescriptors, u2 = Object.getOwnPropertySymbols, RQ = Object.prototype.hasOwnProperty, _Q = Object.prototype.propertyIsEnumerable, c2 = (e, t, r) => t in e ? bQ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, TQ = (e, t) => {
  for (var r in t || (t = {}))
    RQ.call(t, r) && c2(e, r, t[r]);
  if (u2)
    for (var r of u2(t))
      _Q.call(t, r) && c2(e, r, t[r]);
  return e;
}, PQ = (e, t) => xQ(e, EQ(t));
const AG = yn((e, t) => /* @__PURE__ */ H.createElement(ka, PQ(TQ({ ref: t }, e), { weights: nZ })));
AG.displayName = "YoutubeLogo";
var IG = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function r() {
      for (var o = "", a = 0; a < arguments.length; a++) {
        var s = arguments[a];
        s && (o = i(o, n(s)));
      }
      return o;
    }
    function n(o) {
      if (typeof o == "string" || typeof o == "number")
        return o;
      if (typeof o != "object")
        return "";
      if (Array.isArray(o))
        return r.apply(null, o);
      if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]"))
        return o.toString();
      var a = "";
      for (var s in o)
        t.call(o, s) && o[s] && (a = i(a, s));
      return a;
    }
    function i(o, a) {
      return a ? o ? o + " " + a : o + a : o;
    }
    e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
  })();
})(IG);
var MQ = IG.exports;
const ue = /* @__PURE__ */ of(MQ);
function $e() {
  return $e = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, $e.apply(null, arguments);
}
var GE = { exports: {} }, Ir = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var d2;
function DQ() {
  if (d2) return Ir;
  d2 = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), s = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), p;
  p = Symbol.for("react.module.reference");
  function g(v) {
    if (typeof v == "object" && v !== null) {
      var m = v.$$typeof;
      switch (m) {
        case e:
          switch (v = v.type, v) {
            case r:
            case i:
            case n:
            case u:
            case c:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case a:
                case l:
                case h:
                case d:
                case o:
                  return v;
                default:
                  return m;
              }
          }
        case t:
          return m;
      }
    }
  }
  return Ir.ContextConsumer = a, Ir.ContextProvider = o, Ir.Element = e, Ir.ForwardRef = l, Ir.Fragment = r, Ir.Lazy = h, Ir.Memo = d, Ir.Portal = t, Ir.Profiler = i, Ir.StrictMode = n, Ir.Suspense = u, Ir.SuspenseList = c, Ir.isAsyncMode = function() {
    return !1;
  }, Ir.isConcurrentMode = function() {
    return !1;
  }, Ir.isContextConsumer = function(v) {
    return g(v) === a;
  }, Ir.isContextProvider = function(v) {
    return g(v) === o;
  }, Ir.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, Ir.isForwardRef = function(v) {
    return g(v) === l;
  }, Ir.isFragment = function(v) {
    return g(v) === r;
  }, Ir.isLazy = function(v) {
    return g(v) === h;
  }, Ir.isMemo = function(v) {
    return g(v) === d;
  }, Ir.isPortal = function(v) {
    return g(v) === t;
  }, Ir.isProfiler = function(v) {
    return g(v) === i;
  }, Ir.isStrictMode = function(v) {
    return g(v) === n;
  }, Ir.isSuspense = function(v) {
    return g(v) === u;
  }, Ir.isSuspenseList = function(v) {
    return g(v) === c;
  }, Ir.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === i || v === n || v === u || v === c || v === f || typeof v == "object" && v !== null && (v.$$typeof === h || v.$$typeof === d || v.$$typeof === o || v.$$typeof === a || v.$$typeof === l || v.$$typeof === p || v.getModuleId !== void 0);
  }, Ir.typeOf = g, Ir;
}
var Or = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h2;
function AQ() {
  return h2 || (h2 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), s = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), p = !1, g = !1, v = !1, m = !1, y = !1, C;
    C = Symbol.for("react.module.reference");
    function S(W) {
      return !!(typeof W == "string" || typeof W == "function" || W === r || W === i || y || W === n || W === u || W === c || m || W === f || p || g || v || typeof W == "object" && W !== null && (W.$$typeof === h || W.$$typeof === d || W.$$typeof === o || W.$$typeof === a || W.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      W.$$typeof === C || W.getModuleId !== void 0));
    }
    function b(W) {
      if (typeof W == "object" && W !== null) {
        var ne = W.$$typeof;
        switch (ne) {
          case e:
            var ce = W.type;
            switch (ce) {
              case r:
              case i:
              case n:
              case u:
              case c:
                return ce;
              default:
                var we = ce && ce.$$typeof;
                switch (we) {
                  case s:
                  case a:
                  case l:
                  case h:
                  case d:
                  case o:
                    return we;
                  default:
                    return ne;
                }
            }
          case t:
            return ne;
        }
      }
    }
    var w = a, x = o, R = e, _ = l, T = r, P = h, D = d, O = t, A = i, F = n, L = u, N = c, I = !1, B = !1;
    function M(W) {
      return I || (I = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function V(W) {
      return B || (B = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function G(W) {
      return b(W) === a;
    }
    function k(W) {
      return b(W) === o;
    }
    function z(W) {
      return typeof W == "object" && W !== null && W.$$typeof === e;
    }
    function j(W) {
      return b(W) === l;
    }
    function q(W) {
      return b(W) === r;
    }
    function K(W) {
      return b(W) === h;
    }
    function Z(W) {
      return b(W) === d;
    }
    function re(W) {
      return b(W) === t;
    }
    function X(W) {
      return b(W) === i;
    }
    function Y(W) {
      return b(W) === n;
    }
    function U(W) {
      return b(W) === u;
    }
    function oe(W) {
      return b(W) === c;
    }
    Or.ContextConsumer = w, Or.ContextProvider = x, Or.Element = R, Or.ForwardRef = _, Or.Fragment = T, Or.Lazy = P, Or.Memo = D, Or.Portal = O, Or.Profiler = A, Or.StrictMode = F, Or.Suspense = L, Or.SuspenseList = N, Or.isAsyncMode = M, Or.isConcurrentMode = V, Or.isContextConsumer = G, Or.isContextProvider = k, Or.isElement = z, Or.isForwardRef = j, Or.isFragment = q, Or.isLazy = K, Or.isMemo = Z, Or.isPortal = re, Or.isProfiler = X, Or.isStrictMode = Y, Or.isSuspense = U, Or.isSuspenseList = oe, Or.isValidElementType = S, Or.typeOf = b;
  }()), Or;
}
process.env.NODE_ENV === "production" ? GE.exports = DQ() : GE.exports = AQ();
var Up = GE.exports;
function Zo(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = [];
  return H.Children.forEach(e, function(n) {
    n == null && !t.keepEmpty || (Array.isArray(n) ? r = r.concat(Zo(n)) : Up.isFragment(n) && n.props ? r = r.concat(Zo(n.props.children, t)) : r.push(n));
  }), r;
}
var zE = {}, SP = [], IQ = function(t) {
  SP.push(t);
};
function fs(e, t) {
  if (process.env.NODE_ENV !== "production" && !e && console !== void 0) {
    var r = SP.reduce(function(n, i) {
      return i(n ?? "", "warning");
    }, t);
    r && console.error("Warning: ".concat(r));
  }
}
function OQ(e, t) {
  if (process.env.NODE_ENV !== "production" && !e && console !== void 0) {
    var r = SP.reduce(function(n, i) {
      return i(n ?? "", "note");
    }, t);
    r && console.warn("Note: ".concat(r));
  }
}
function OG() {
  zE = {};
}
function LG(e, t, r) {
  !t && !zE[r] && (e(!1, r), zE[r] = !0);
}
function Qt(e, t) {
  LG(fs, e, t);
}
function WE(e, t) {
  LG(OQ, e, t);
}
Qt.preMessage = IQ;
Qt.resetWarned = OG;
Qt.noteOnce = WE;
function vt(e) {
  "@babel/helpers - typeof";
  return vt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, vt(e);
}
function LQ(e, t) {
  if (vt(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (vt(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function FG(e) {
  var t = LQ(e, "string");
  return vt(t) == "symbol" ? t : t + "";
}
function te(e, t, r) {
  return (t = FG(t)) in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function f2(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function ee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f2(Object(r), !0).forEach(function(n) {
      te(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : f2(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function bg(e) {
  return e instanceof HTMLElement || e instanceof SVGElement;
}
function FQ(e) {
  return e && vt(e) === "object" && bg(e.nativeElement) ? e.nativeElement : bg(e) ? e : null;
}
function Kp(e) {
  var t = FQ(e);
  if (t)
    return t;
  if (e instanceof H.Component) {
    var r;
    return (r = Bc.findDOMNode) === null || r === void 0 ? void 0 : r.call(Bc, e);
  }
  return null;
}
function vv(e, t, r) {
  var n = E.useRef({});
  return (!("value" in n.current) || r(n.current.condition, t)) && (n.current.value = e(), n.current.condition = t), n.current.value;
}
var wP = function(t, r) {
  typeof t == "function" ? t(r) : vt(t) === "object" && t && "current" in t && (t.current = r);
}, Eo = function() {
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  var i = r.filter(Boolean);
  return i.length <= 1 ? i[0] : function(o) {
    r.forEach(function(a) {
      wP(a, o);
    });
  };
}, Qc = function() {
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  return vv(function() {
    return Eo.apply(void 0, r);
  }, r, function(i, o) {
    return i.length !== o.length || i.every(function(a, s) {
      return a !== o[s];
    });
  });
}, Jc = function(t) {
  var r, n, i = Up.isMemo(t) ? t.type.type : t.type;
  return !(typeof i == "function" && !((r = i.prototype) !== null && r !== void 0 && r.render) && i.$$typeof !== Up.ForwardRef || typeof t == "function" && !((n = t.prototype) !== null && n !== void 0 && n.render) && t.$$typeof !== Up.ForwardRef);
};
function p2(e) {
  return /* @__PURE__ */ FX(e) && !Up.isFragment(e);
}
Number(LX.split(".")[0]) >= 19;
var jE = /* @__PURE__ */ E.createContext(null);
function NQ(e) {
  var t = e.children, r = e.onBatchResize, n = E.useRef(0), i = E.useRef([]), o = E.useContext(jE), a = E.useCallback(function(s, l, u) {
    n.current += 1;
    var c = n.current;
    i.current.push({
      size: s,
      element: l,
      data: u
    }), Promise.resolve().then(function() {
      c === n.current && (r == null || r(i.current), i.current = []);
    }), o == null || o(s, l, u);
  }, [r, o]);
  return /* @__PURE__ */ E.createElement(jE.Provider, {
    value: a
  }, t);
}
var NG = function() {
  if (typeof Map < "u")
    return Map;
  function e(t, r) {
    var n = -1;
    return t.some(function(i, o) {
      return i[0] === r ? (n = o, !0) : !1;
    }), n;
  }
  return (
    /** @class */
    function() {
      function t() {
        this.__entries__ = [];
      }
      return Object.defineProperty(t.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.get = function(r) {
        var n = e(this.__entries__, r), i = this.__entries__[n];
        return i && i[1];
      }, t.prototype.set = function(r, n) {
        var i = e(this.__entries__, r);
        ~i ? this.__entries__[i][1] = n : this.__entries__.push([r, n]);
      }, t.prototype.delete = function(r) {
        var n = this.__entries__, i = e(n, r);
        ~i && n.splice(i, 1);
      }, t.prototype.has = function(r) {
        return !!~e(this.__entries__, r);
      }, t.prototype.clear = function() {
        this.__entries__.splice(0);
      }, t.prototype.forEach = function(r, n) {
        n === void 0 && (n = null);
        for (var i = 0, o = this.__entries__; i < o.length; i++) {
          var a = o[i];
          r.call(n, a[1], a[0]);
        }
      }, t;
    }()
  );
}(), UE = typeof window < "u" && typeof document < "u" && window.document === document, M0 = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), kQ = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(M0) : function(e) {
    return setTimeout(function() {
      return e(Date.now());
    }, 1e3 / 60);
  };
}(), VQ = 2;
function BQ(e, t) {
  var r = !1, n = !1, i = 0;
  function o() {
    r && (r = !1, e()), n && s();
  }
  function a() {
    kQ(o);
  }
  function s() {
    var l = Date.now();
    if (r) {
      if (l - i < VQ)
        return;
      n = !0;
    } else
      r = !0, n = !1, setTimeout(a, t);
    i = l;
  }
  return s;
}
var $Q = 20, HQ = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], GQ = typeof MutationObserver < "u", zQ = (
  /** @class */
  function() {
    function e() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = BQ(this.refresh.bind(this), $Q);
    }
    return e.prototype.addObserver = function(t) {
      ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
    }, e.prototype.removeObserver = function(t) {
      var r = this.observers_, n = r.indexOf(t);
      ~n && r.splice(n, 1), !r.length && this.connected_ && this.disconnect_();
    }, e.prototype.refresh = function() {
      var t = this.updateObservers_();
      t && this.refresh();
    }, e.prototype.updateObservers_ = function() {
      var t = this.observers_.filter(function(r) {
        return r.gatherActive(), r.hasActive();
      });
      return t.forEach(function(r) {
        return r.broadcastActive();
      }), t.length > 0;
    }, e.prototype.connect_ = function() {
      !UE || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), GQ ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, e.prototype.disconnect_ = function() {
      !UE || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, e.prototype.onTransitionEnd_ = function(t) {
      var r = t.propertyName, n = r === void 0 ? "" : r, i = HQ.some(function(o) {
        return !!~n.indexOf(o);
      });
      i && this.refresh();
    }, e.getInstance = function() {
      return this.instance_ || (this.instance_ = new e()), this.instance_;
    }, e.instance_ = null, e;
  }()
), kG = function(e, t) {
  for (var r = 0, n = Object.keys(t); r < n.length; r++) {
    var i = n[r];
    Object.defineProperty(e, i, {
      value: t[i],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return e;
}, Fh = function(e) {
  var t = e && e.ownerDocument && e.ownerDocument.defaultView;
  return t || M0;
}, VG = lS(0, 0, 0, 0);
function D0(e) {
  return parseFloat(e) || 0;
}
function g2(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  return t.reduce(function(n, i) {
    var o = e["border-" + i + "-width"];
    return n + D0(o);
  }, 0);
}
function WQ(e) {
  for (var t = ["top", "right", "bottom", "left"], r = {}, n = 0, i = t; n < i.length; n++) {
    var o = i[n], a = e["padding-" + o];
    r[o] = D0(a);
  }
  return r;
}
function jQ(e) {
  var t = e.getBBox();
  return lS(0, 0, t.width, t.height);
}
function UQ(e) {
  var t = e.clientWidth, r = e.clientHeight;
  if (!t && !r)
    return VG;
  var n = Fh(e).getComputedStyle(e), i = WQ(n), o = i.left + i.right, a = i.top + i.bottom, s = D0(n.width), l = D0(n.height);
  if (n.boxSizing === "border-box" && (Math.round(s + o) !== t && (s -= g2(n, "left", "right") + o), Math.round(l + a) !== r && (l -= g2(n, "top", "bottom") + a)), !YQ(e)) {
    var u = Math.round(s + o) - t, c = Math.round(l + a) - r;
    Math.abs(u) !== 1 && (s -= u), Math.abs(c) !== 1 && (l -= c);
  }
  return lS(i.left, i.top, s, l);
}
var KQ = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(e) {
    return e instanceof Fh(e).SVGGraphicsElement;
  } : function(e) {
    return e instanceof Fh(e).SVGElement && typeof e.getBBox == "function";
  };
}();
function YQ(e) {
  return e === Fh(e).document.documentElement;
}
function qQ(e) {
  return UE ? KQ(e) ? jQ(e) : UQ(e) : VG;
}
function XQ(e) {
  var t = e.x, r = e.y, n = e.width, i = e.height, o = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, a = Object.create(o.prototype);
  return kG(a, {
    x: t,
    y: r,
    width: n,
    height: i,
    top: r,
    right: t + n,
    bottom: i + r,
    left: t
  }), a;
}
function lS(e, t, r, n) {
  return { x: e, y: t, width: r, height: n };
}
var ZQ = (
  /** @class */
  function() {
    function e(t) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = lS(0, 0, 0, 0), this.target = t;
    }
    return e.prototype.isActive = function() {
      var t = qQ(this.target);
      return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
    }, e.prototype.broadcastRect = function() {
      var t = this.contentRect_;
      return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
    }, e;
  }()
), QQ = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, r) {
      var n = XQ(r);
      kG(this, { target: t, contentRect: n });
    }
    return e;
  }()
), JQ = (
  /** @class */
  function() {
    function e(t, r, n) {
      if (this.activeObservations_ = [], this.observations_ = new NG(), typeof t != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = t, this.controller_ = r, this.callbackCtx_ = n;
    }
    return e.prototype.observe = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof Fh(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(t) || (r.set(t, new ZQ(t)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, e.prototype.unobserve = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof Fh(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(t) && (r.delete(t), r.size || this.controller_.removeObserver(this));
      }
    }, e.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, e.prototype.gatherActive = function() {
      var t = this;
      this.clearActive(), this.observations_.forEach(function(r) {
        r.isActive() && t.activeObservations_.push(r);
      });
    }, e.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var t = this.callbackCtx_, r = this.activeObservations_.map(function(n) {
          return new QQ(n.target, n.broadcastRect());
        });
        this.callback_.call(t, r, t), this.clearActive();
      }
    }, e.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, e.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, e;
  }()
), BG = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new NG(), $G = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      if (!(this instanceof e))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var r = zQ.getInstance(), n = new JQ(t, r, this);
      BG.set(this, n);
    }
    return e;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(e) {
  $G.prototype[e] = function() {
    var t;
    return (t = BG.get(this))[e].apply(t, arguments);
  };
});
var eJ = function() {
  return typeof M0.ResizeObserver < "u" ? M0.ResizeObserver : $G;
}(), Ns = /* @__PURE__ */ new Map();
function HG(e) {
  e.forEach(function(t) {
    var r, n = t.target;
    (r = Ns.get(n)) === null || r === void 0 || r.forEach(function(i) {
      return i(n);
    });
  });
}
var GG = new eJ(HG);
process.env.NODE_ENV;
process.env.NODE_ENV;
function tJ(e, t) {
  Ns.has(e) || (Ns.set(e, /* @__PURE__ */ new Set()), GG.observe(e)), Ns.get(e).add(t);
}
function rJ(e, t) {
  Ns.has(e) && (Ns.get(e).delete(t), Ns.get(e).size || (GG.unobserve(e), Ns.delete(e)));
}
function Kn(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function v2(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, FG(n.key), n);
  }
}
function Yn(e, t, r) {
  return t && v2(e.prototype, t), r && v2(e, r), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function xg(e, t) {
  return xg = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, xg(e, t);
}
function hu(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && xg(e, t);
}
function Eg(e) {
  return Eg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Eg(e);
}
function bP() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (bP = function() {
    return !!e;
  })();
}
function cr(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function nJ(e, t) {
  if (t && (vt(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return cr(e);
}
function fu(e) {
  var t = bP();
  return function() {
    var r, n = Eg(e);
    if (t) {
      var i = Eg(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else r = n.apply(this, arguments);
    return nJ(this, r);
  };
}
var iJ = /* @__PURE__ */ function(e) {
  hu(r, e);
  var t = fu(r);
  function r() {
    return Kn(this, r), t.apply(this, arguments);
  }
  return Yn(r, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), r;
}(E.Component);
function oJ(e, t) {
  var r = e.children, n = e.disabled, i = E.useRef(null), o = E.useRef(null), a = E.useContext(jE), s = typeof r == "function", l = s ? r(i) : r, u = E.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  }), c = !s && /* @__PURE__ */ E.isValidElement(l) && Jc(l), d = c ? l.ref : null, h = Qc(d, i), f = function() {
    var m;
    return Kp(i.current) || // Support `nativeElement` format
    (i.current && vt(i.current) === "object" ? Kp((m = i.current) === null || m === void 0 ? void 0 : m.nativeElement) : null) || Kp(o.current);
  };
  E.useImperativeHandle(t, function() {
    return f();
  });
  var p = E.useRef(e);
  p.current = e;
  var g = E.useCallback(function(v) {
    var m = p.current, y = m.onResize, C = m.data, S = v.getBoundingClientRect(), b = S.width, w = S.height, x = v.offsetWidth, R = v.offsetHeight, _ = Math.floor(b), T = Math.floor(w);
    if (u.current.width !== _ || u.current.height !== T || u.current.offsetWidth !== x || u.current.offsetHeight !== R) {
      var P = {
        width: _,
        height: T,
        offsetWidth: x,
        offsetHeight: R
      };
      u.current = P;
      var D = x === Math.round(b) ? b : x, O = R === Math.round(w) ? w : R, A = ee(ee({}, P), {}, {
        offsetWidth: D,
        offsetHeight: O
      });
      a == null || a(A, v, C), y && Promise.resolve().then(function() {
        y(A, v);
      });
    }
  }, []);
  return E.useEffect(function() {
    var v = f();
    return v && !n && tJ(v, g), function() {
      return rJ(v, g);
    };
  }, [i.current, n]), /* @__PURE__ */ E.createElement(iJ, {
    ref: o
  }, c ? /* @__PURE__ */ E.cloneElement(l, {
    ref: h
  }) : l);
}
var zG = /* @__PURE__ */ E.forwardRef(oJ);
process.env.NODE_ENV !== "production" && (zG.displayName = "SingleObserver");
var aJ = "rc-observer-key";
function sJ(e, t) {
  var r = e.children, n = typeof r == "function" ? [r] : Zo(r);
  return process.env.NODE_ENV !== "production" && (n.length > 1 ? fs(!1, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.") : n.length === 0 && fs(!1, "`children` of ResizeObserver is empty. Nothing is in observe.")), n.map(function(i, o) {
    var a = (i == null ? void 0 : i.key) || "".concat(aJ, "-").concat(o);
    return /* @__PURE__ */ E.createElement(zG, $e({}, e, {
      key: a,
      ref: o === 0 ? t : void 0
    }), i);
  });
}
var Co = /* @__PURE__ */ E.forwardRef(sJ);
process.env.NODE_ENV !== "production" && (Co.displayName = "ResizeObserver");
Co.Collection = NQ;
function ni(e, t) {
  var r = Object.assign({}, e);
  return Array.isArray(t) && t.forEach(function(n) {
    delete r[n];
  }), r;
}
function KE(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function lJ(e) {
  if (Array.isArray(e)) return KE(e);
}
function WG(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function xP(e, t) {
  if (e) {
    if (typeof e == "string") return KE(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? KE(e, t) : void 0;
  }
}
function uJ() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function it(e) {
  return lJ(e) || WG(e) || xP(e) || uJ();
}
var jG = function(t) {
  return +setTimeout(t, 16);
}, UG = function(t) {
  return clearTimeout(t);
};
typeof window < "u" && "requestAnimationFrame" in window && (jG = function(t) {
  return window.requestAnimationFrame(t);
}, UG = function(t) {
  return window.cancelAnimationFrame(t);
});
var m2 = 0, uS = /* @__PURE__ */ new Map();
function KG(e) {
  uS.delete(e);
}
var Ar = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  m2 += 1;
  var n = m2;
  function i(o) {
    if (o === 0)
      KG(n), t();
    else {
      var a = jG(function() {
        i(o - 1);
      });
      uS.set(n, a);
    }
  }
  return i(r), n;
};
Ar.cancel = function(e) {
  var t = uS.get(e);
  return KG(e), UG(t);
};
process.env.NODE_ENV !== "production" && (Ar.ids = function() {
  return uS;
});
function YG(e) {
  if (Array.isArray(e)) return e;
}
function cJ(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, a, s = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (n = o.call(r)).done) && (s.push(n.value), s.length !== t); l = !0) ;
    } catch (c) {
      u = !0, i = c;
    } finally {
      try {
        if (!l && r.return != null && (a = r.return(), Object(a) !== a)) return;
      } finally {
        if (u) throw i;
      }
    }
    return s;
  }
}
function qG() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ae(e, t) {
  return YG(e) || cJ(e, t) || xP(e, t) || qG();
}
function Rg(e) {
  for (var t = 0, r, n = 0, i = e.length; i >= 4; ++n, i -= 4)
    r = e.charCodeAt(n) & 255 | (e.charCodeAt(++n) & 255) << 8 | (e.charCodeAt(++n) & 255) << 16 | (e.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
    r >>> 24, t = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(n + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(n + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(n) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
function Zn() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function YE(e, t) {
  if (!e)
    return !1;
  if (e.contains)
    return e.contains(t);
  for (var r = t; r; ) {
    if (r === e)
      return !0;
    r = r.parentNode;
  }
  return !1;
}
var y2 = "data-rc-order", C2 = "data-rc-priority", dJ = "rc-util-key", qE = /* @__PURE__ */ new Map();
function XG() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.mark;
  return t ? t.startsWith("data-") ? t : "data-".concat(t) : dJ;
}
function cS(e) {
  if (e.attachTo)
    return e.attachTo;
  var t = document.querySelector("head");
  return t || document.body;
}
function hJ(e) {
  return e === "queue" ? "prependQueue" : e ? "prepend" : "append";
}
function EP(e) {
  return Array.from((qE.get(e) || e).children).filter(function(t) {
    return t.tagName === "STYLE";
  });
}
function ZG(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!Zn())
    return null;
  var r = t.csp, n = t.prepend, i = t.priority, o = i === void 0 ? 0 : i, a = hJ(n), s = a === "prependQueue", l = document.createElement("style");
  l.setAttribute(y2, a), s && o && l.setAttribute(C2, "".concat(o)), r != null && r.nonce && (l.nonce = r == null ? void 0 : r.nonce), l.innerHTML = e;
  var u = cS(t), c = u.firstChild;
  if (n) {
    if (s) {
      var d = (t.styles || EP(u)).filter(function(h) {
        if (!["prepend", "prependQueue"].includes(h.getAttribute(y2)))
          return !1;
        var f = Number(h.getAttribute(C2) || 0);
        return o >= f;
      });
      if (d.length)
        return u.insertBefore(l, d[d.length - 1].nextSibling), l;
    }
    u.insertBefore(l, c);
  } else
    u.appendChild(l);
  return l;
}
function QG(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = cS(t);
  return (t.styles || EP(r)).find(function(n) {
    return n.getAttribute(XG(t)) === e;
  });
}
function _g(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = QG(e, t);
  if (r) {
    var n = cS(t);
    n.removeChild(r);
  }
}
function fJ(e, t) {
  var r = qE.get(e);
  if (!r || !YE(document, r)) {
    var n = ZG("", t), i = n.parentNode;
    qE.set(e, i), e.removeChild(n);
  }
}
function Gs(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = cS(r), i = EP(n), o = ee(ee({}, r), {}, {
    styles: i
  });
  fJ(n, o);
  var a = QG(t, o);
  if (a) {
    var s, l;
    if ((s = o.csp) !== null && s !== void 0 && s.nonce && a.nonce !== ((l = o.csp) === null || l === void 0 ? void 0 : l.nonce)) {
      var u;
      a.nonce = (u = o.csp) === null || u === void 0 ? void 0 : u.nonce;
    }
    return a.innerHTML !== e && (a.innerHTML = e), a;
  }
  var c = ZG(e, o);
  return c.setAttribute(XG(o), t), c;
}
function pJ(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.indexOf(n) >= 0) continue;
    r[n] = e[n];
  }
  return r;
}
function $t(e, t) {
  if (e == null) return {};
  var r, n, i = pJ(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++) r = o[n], t.indexOf(r) >= 0 || {}.propertyIsEnumerable.call(e, r) && (i[r] = e[r]);
  }
  return i;
}
function Nh(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = /* @__PURE__ */ new Set();
  function i(o, a) {
    var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, l = n.has(o);
    if (Qt(!l, "Warning: There may be circular references"), l)
      return !1;
    if (o === a)
      return !0;
    if (r && s > 1)
      return !1;
    n.add(o);
    var u = s + 1;
    if (Array.isArray(o)) {
      if (!Array.isArray(a) || o.length !== a.length)
        return !1;
      for (var c = 0; c < o.length; c++)
        if (!i(o[c], a[c], u))
          return !1;
      return !0;
    }
    if (o && a && vt(o) === "object" && vt(a) === "object") {
      var d = Object.keys(o);
      return d.length !== Object.keys(a).length ? !1 : d.every(function(h) {
        return i(o[h], a[h], u);
      });
    }
    return !1;
  }
  return i(e, t);
}
var gJ = "%";
function XE(e) {
  return e.join(gJ);
}
var vJ = /* @__PURE__ */ function() {
  function e(t) {
    Kn(this, e), te(this, "instanceId", void 0), te(this, "cache", /* @__PURE__ */ new Map()), this.instanceId = t;
  }
  return Yn(e, [{
    key: "get",
    value: function(r) {
      return this.opGet(XE(r));
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opGet",
    value: function(r) {
      return this.cache.get(r) || null;
    }
  }, {
    key: "update",
    value: function(r, n) {
      return this.opUpdate(XE(r), n);
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opUpdate",
    value: function(r, n) {
      var i = this.cache.get(r), o = n(i);
      o === null ? this.cache.delete(r) : this.cache.set(r, o);
    }
  }]), e;
}(), kh = "data-token-hash", Ra = "data-css-hash", mJ = "data-cache-path", Al = "__cssinjs_instance__";
function yJ() {
  var e = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    var t = document.body.querySelectorAll("style[".concat(Ra, "]")) || [], r = document.head.firstChild;
    Array.from(t).forEach(function(i) {
      i[Al] = i[Al] || e, i[Al] === e && document.head.insertBefore(i, r);
    });
    var n = {};
    Array.from(document.querySelectorAll("style[".concat(Ra, "]"))).forEach(function(i) {
      var o = i.getAttribute(Ra);
      if (n[o]) {
        if (i[Al] === e) {
          var a;
          (a = i.parentNode) === null || a === void 0 || a.removeChild(i);
        }
      } else
        n[o] = !0;
    });
  }
  return new vJ(e);
}
var dS = /* @__PURE__ */ E.createContext({
  hashPriority: "low",
  cache: yJ(),
  defaultCache: !0
}), JG = /* @__PURE__ */ Yn(function e() {
  Kn(this, e);
}), ez = "CALC_UNIT", CJ = new RegExp(ez, "g");
function Kw(e) {
  return typeof e == "number" ? "".concat(e).concat(ez) : e;
}
var SJ = /* @__PURE__ */ function(e) {
  hu(r, e);
  var t = fu(r);
  function r(n, i) {
    var o;
    Kn(this, r), o = t.call(this), te(cr(o), "result", ""), te(cr(o), "unitlessCssVar", void 0), te(cr(o), "lowPriority", void 0);
    var a = vt(n);
    return o.unitlessCssVar = i, n instanceof r ? o.result = "(".concat(n.result, ")") : a === "number" ? o.result = Kw(n) : a === "string" && (o.result = n), o;
  }
  return Yn(r, [{
    key: "add",
    value: function(i) {
      return i instanceof r ? this.result = "".concat(this.result, " + ").concat(i.getResult()) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " + ").concat(Kw(i))), this.lowPriority = !0, this;
    }
  }, {
    key: "sub",
    value: function(i) {
      return i instanceof r ? this.result = "".concat(this.result, " - ").concat(i.getResult()) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " - ").concat(Kw(i))), this.lowPriority = !0, this;
    }
  }, {
    key: "mul",
    value: function(i) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), i instanceof r ? this.result = "".concat(this.result, " * ").concat(i.getResult(!0)) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " * ").concat(i)), this.lowPriority = !1, this;
    }
  }, {
    key: "div",
    value: function(i) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), i instanceof r ? this.result = "".concat(this.result, " / ").concat(i.getResult(!0)) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " / ").concat(i)), this.lowPriority = !1, this;
    }
  }, {
    key: "getResult",
    value: function(i) {
      return this.lowPriority || i ? "(".concat(this.result, ")") : this.result;
    }
  }, {
    key: "equal",
    value: function(i) {
      var o = this, a = i || {}, s = a.unit, l = !0;
      return typeof s == "boolean" ? l = s : Array.from(this.unitlessCssVar).some(function(u) {
        return o.result.includes(u);
      }) && (l = !1), this.result = this.result.replace(CJ, l ? "px" : ""), typeof this.lowPriority < "u" ? "calc(".concat(this.result, ")") : this.result;
    }
  }]), r;
}(JG), wJ = /* @__PURE__ */ function(e) {
  hu(r, e);
  var t = fu(r);
  function r(n) {
    var i;
    return Kn(this, r), i = t.call(this), te(cr(i), "result", 0), n instanceof r ? i.result = n.result : typeof n == "number" && (i.result = n), i;
  }
  return Yn(r, [{
    key: "add",
    value: function(i) {
      return i instanceof r ? this.result += i.result : typeof i == "number" && (this.result += i), this;
    }
  }, {
    key: "sub",
    value: function(i) {
      return i instanceof r ? this.result -= i.result : typeof i == "number" && (this.result -= i), this;
    }
  }, {
    key: "mul",
    value: function(i) {
      return i instanceof r ? this.result *= i.result : typeof i == "number" && (this.result *= i), this;
    }
  }, {
    key: "div",
    value: function(i) {
      return i instanceof r ? this.result /= i.result : typeof i == "number" && (this.result /= i), this;
    }
  }, {
    key: "equal",
    value: function() {
      return this.result;
    }
  }]), r;
}(JG), bJ = function(t, r) {
  var n = t === "css" ? SJ : wJ;
  return function(i) {
    return new n(i, r);
  };
};
function xJ(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
var RP = /* @__PURE__ */ function() {
  function e() {
    Kn(this, e), te(this, "cache", void 0), te(this, "keys", void 0), te(this, "cacheCallTimes", void 0), this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  return Yn(e, [{
    key: "size",
    value: function() {
      return this.keys.length;
    }
  }, {
    key: "internalGet",
    value: function(r) {
      var n, i, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, a = {
        map: this.cache
      };
      return r.forEach(function(s) {
        if (!a)
          a = void 0;
        else {
          var l;
          a = (l = a) === null || l === void 0 || (l = l.map) === null || l === void 0 ? void 0 : l.get(s);
        }
      }), (n = a) !== null && n !== void 0 && n.value && o && (a.value[1] = this.cacheCallTimes++), (i = a) === null || i === void 0 ? void 0 : i.value;
    }
  }, {
    key: "get",
    value: function(r) {
      var n;
      return (n = this.internalGet(r, !0)) === null || n === void 0 ? void 0 : n[0];
    }
  }, {
    key: "has",
    value: function(r) {
      return !!this.internalGet(r);
    }
  }, {
    key: "set",
    value: function(r, n) {
      var i = this;
      if (!this.has(r)) {
        if (this.size() + 1 > e.MAX_CACHE_SIZE + e.MAX_CACHE_OFFSET) {
          var o = this.keys.reduce(function(u, c) {
            var d = ae(u, 2), h = d[1];
            return i.internalGet(c)[1] < h ? [c, i.internalGet(c)[1]] : u;
          }, [this.keys[0], this.cacheCallTimes]), a = ae(o, 1), s = a[0];
          this.delete(s);
        }
        this.keys.push(r);
      }
      var l = this.cache;
      r.forEach(function(u, c) {
        if (c === r.length - 1)
          l.set(u, {
            value: [n, i.cacheCallTimes++]
          });
        else {
          var d = l.get(u);
          d ? d.map || (d.map = /* @__PURE__ */ new Map()) : l.set(u, {
            map: /* @__PURE__ */ new Map()
          }), l = l.get(u).map;
        }
      });
    }
  }, {
    key: "deleteByPath",
    value: function(r, n) {
      var i = r.get(n[0]);
      if (n.length === 1) {
        var o;
        return i.map ? r.set(n[0], {
          map: i.map
        }) : r.delete(n[0]), (o = i.value) === null || o === void 0 ? void 0 : o[0];
      }
      var a = this.deleteByPath(i.map, n.slice(1));
      return (!i.map || i.map.size === 0) && !i.value && r.delete(n[0]), a;
    }
  }, {
    key: "delete",
    value: function(r) {
      if (this.has(r))
        return this.keys = this.keys.filter(function(n) {
          return !xJ(n, r);
        }), this.deleteByPath(this.cache, r);
    }
  }]), e;
}();
te(RP, "MAX_CACHE_SIZE", 20);
te(RP, "MAX_CACHE_OFFSET", 5);
var S2 = 0, tz = /* @__PURE__ */ function() {
  function e(t) {
    Kn(this, e), te(this, "derivatives", void 0), te(this, "id", void 0), this.derivatives = Array.isArray(t) ? t : [t], this.id = S2, t.length === 0 && fs(t.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function."), S2 += 1;
  }
  return Yn(e, [{
    key: "getDerivativeToken",
    value: function(r) {
      return this.derivatives.reduce(function(n, i) {
        return i(r, n);
      }, void 0);
    }
  }]), e;
}(), Yw = new RP();
function ZE(e) {
  var t = Array.isArray(e) ? e : [e];
  return Yw.has(t) || Yw.set(t, new tz(t)), Yw.get(t);
}
var EJ = /* @__PURE__ */ new WeakMap(), qw = {};
function RJ(e, t) {
  for (var r = EJ, n = 0; n < t.length; n += 1) {
    var i = t[n];
    r.has(i) || r.set(i, /* @__PURE__ */ new WeakMap()), r = r.get(i);
  }
  return r.has(qw) || r.set(qw, e()), r.get(qw);
}
var w2 = /* @__PURE__ */ new WeakMap();
function Yp(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = w2.get(e) || "";
  return r || (Object.keys(e).forEach(function(n) {
    var i = e[n];
    r += n, i instanceof tz ? r += i.id : i && vt(i) === "object" ? r += Yp(i, t) : r += i;
  }), t && (r = Rg(r)), w2.set(e, r)), r;
}
function b2(e, t) {
  return Rg("".concat(t, "_").concat(Yp(e, !0)));
}
var QE = Zn();
function de(e) {
  return typeof e == "number" ? "".concat(e, "px") : e;
}
function A0(e, t, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  if (i)
    return e;
  var o = ee(ee({}, n), {}, te(te({}, kh, t), Ra, r)), a = Object.keys(o).map(function(s) {
    var l = o[s];
    return l ? "".concat(s, '="').concat(l, '"') : null;
  }).filter(function(s) {
    return s;
  }).join(" ");
  return "<style ".concat(a, ">").concat(e, "</style>");
}
var jy = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return "--".concat(r ? "".concat(r, "-") : "").concat(t).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
}, _J = function(t, r, n) {
  return Object.keys(t).length ? ".".concat(r).concat(n != null && n.scope ? ".".concat(n.scope) : "", "{").concat(Object.entries(t).map(function(i) {
    var o = ae(i, 2), a = o[0], s = o[1];
    return "".concat(a, ":").concat(s, ";");
  }).join(""), "}") : "";
}, rz = function(t, r, n) {
  var i = {}, o = {};
  return Object.entries(t).forEach(function(a) {
    var s, l, u = ae(a, 2), c = u[0], d = u[1];
    if (n != null && (s = n.preserve) !== null && s !== void 0 && s[c])
      o[c] = d;
    else if ((typeof d == "string" || typeof d == "number") && !(n != null && (l = n.ignore) !== null && l !== void 0 && l[c])) {
      var h, f = jy(c, n == null ? void 0 : n.prefix);
      i[f] = typeof d == "number" && !(n != null && (h = n.unitless) !== null && h !== void 0 && h[c]) ? "".concat(d, "px") : String(d), o[c] = "var(".concat(f, ")");
    }
  }), [o, _J(i, r, {
    scope: n == null ? void 0 : n.scope
  })];
}, x2 = process.env.NODE_ENV !== "test" && Zn() ? E.useLayoutEffect : E.useEffect, kr = function(t, r) {
  var n = E.useRef(!0);
  x2(function() {
    return t(n.current);
  }, r), x2(function() {
    return n.current = !1, function() {
      n.current = !0;
    };
  }, []);
}, JE = function(t, r) {
  kr(function(n) {
    if (!n)
      return t();
  }, r);
}, TJ = ee({}, E), E2 = TJ.useInsertionEffect, PJ = function(t, r, n) {
  E.useMemo(t, n), kr(function() {
    return r(!0);
  }, n);
}, MJ = E2 ? function(e, t, r) {
  return E2(function() {
    return e(), t();
  }, r);
} : PJ, DJ = ee({}, E), AJ = DJ.useInsertionEffect, IJ = function(t) {
  var r = [], n = !1;
  function i(o) {
    if (n) {
      process.env.NODE_ENV !== "production" && fs(!1, "[Ant Design CSS-in-JS] You are registering a cleanup function after unmount, which will not have any effect.");
      return;
    }
    r.push(o);
  }
  return E.useEffect(function() {
    return n = !1, function() {
      n = !0, r.length && r.forEach(function(o) {
        return o();
      });
    };
  }, t), i;
}, OJ = function() {
  return function(t) {
    t();
  };
}, LJ = typeof AJ < "u" ? IJ : OJ;
function FJ() {
  return !1;
}
var eR = !1;
function NJ() {
  return eR;
}
const kJ = process.env.NODE_ENV === "production" ? FJ : NJ;
if (process.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  var Xw = window;
  if (typeof Xw.webpackHotUpdate == "function") {
    var VJ = Xw.webpackHotUpdate;
    Xw.webpackHotUpdate = function() {
      return eR = !0, setTimeout(function() {
        eR = !1;
      }, 0), VJ.apply(void 0, arguments);
    };
  }
}
function _P(e, t, r, n, i) {
  var o = E.useContext(dS), a = o.cache, s = [e].concat(it(t)), l = XE(s), u = LJ([l]), c = kJ(), d = function(g) {
    a.opUpdate(l, function(v) {
      var m = v || [void 0, void 0], y = ae(m, 2), C = y[0], S = C === void 0 ? 0 : C, b = y[1], w = b;
      process.env.NODE_ENV !== "production" && b && c && (n == null || n(w, c), w = null);
      var x = w || r(), R = [S, x];
      return g ? g(R) : R;
    });
  };
  E.useMemo(
    function() {
      d();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [l]
    /* eslint-enable */
  );
  var h = a.opGet(l);
  process.env.NODE_ENV !== "production" && !h && (d(), h = a.opGet(l));
  var f = h[1];
  return MJ(function() {
    i == null || i(f);
  }, function(p) {
    return d(function(g) {
      var v = ae(g, 2), m = v[0], y = v[1];
      return p && m === 0 && (i == null || i(f)), [m + 1, y];
    }), function() {
      a.opUpdate(l, function(g) {
        var v = g || [], m = ae(v, 2), y = m[0], C = y === void 0 ? 0 : y, S = m[1], b = C - 1;
        return b === 0 ? (u(function() {
          (p || !a.opGet(l)) && (n == null || n(S, !1));
        }), null) : [C - 1, S];
      });
    };
  }, [l]), f;
}
var BJ = {}, $J = process.env.NODE_ENV !== "production" ? "css-dev-only-do-not-override" : "css", oc = /* @__PURE__ */ new Map();
function HJ(e) {
  oc.set(e, (oc.get(e) || 0) + 1);
}
function GJ(e, t) {
  if (typeof document < "u") {
    var r = document.querySelectorAll("style[".concat(kh, '="').concat(e, '"]'));
    r.forEach(function(n) {
      if (n[Al] === t) {
        var i;
        (i = n.parentNode) === null || i === void 0 || i.removeChild(n);
      }
    });
  }
}
var zJ = 0;
function WJ(e, t) {
  oc.set(e, (oc.get(e) || 0) - 1);
  var r = Array.from(oc.keys()), n = r.filter(function(i) {
    var o = oc.get(i) || 0;
    return o <= 0;
  });
  r.length - n.length > zJ && n.forEach(function(i) {
    GJ(i, t), oc.delete(i);
  });
}
var jJ = function(t, r, n, i) {
  var o = n.getDerivativeToken(t), a = ee(ee({}, o), r);
  return i && (a = i(a)), a;
}, nz = "token";
function UJ(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = vr(dS), i = n.cache.instanceId, o = n.container, a = r.salt, s = a === void 0 ? "" : a, l = r.override, u = l === void 0 ? BJ : l, c = r.formatToken, d = r.getComputedToken, h = r.cssVar, f = RJ(function() {
    return Object.assign.apply(Object, [{}].concat(it(t)));
  }, t), p = Yp(f), g = Yp(u), v = h ? Yp(h) : "", m = _P(nz, [s, e.id, p, g, v], function() {
    var y, C = d ? d(f, u, e) : jJ(f, u, e, c), S = ee({}, C), b = "";
    if (h) {
      var w = rz(C, h.key, {
        prefix: h.prefix,
        ignore: h.ignore,
        unitless: h.unitless,
        preserve: h.preserve
      }), x = ae(w, 2);
      C = x[0], b = x[1];
    }
    var R = b2(C, s);
    C._tokenKey = R, S._tokenKey = b2(S, s);
    var _ = (y = h == null ? void 0 : h.key) !== null && y !== void 0 ? y : R;
    C._themeKey = _, HJ(_);
    var T = "".concat($J, "-").concat(Rg(R));
    return C._hashId = T, [C, T, S, b, (h == null ? void 0 : h.key) || ""];
  }, function(y) {
    WJ(y[0]._themeKey, i);
  }, function(y) {
    var C = ae(y, 4), S = C[0], b = C[3];
    if (h && b) {
      var w = Gs(b, Rg("css-variables-".concat(S._themeKey)), {
        mark: Ra,
        prepend: "queue",
        attachTo: o,
        priority: -999
      });
      w[Al] = i, w.setAttribute(kh, S._themeKey);
    }
  });
  return m;
}
var KJ = function(t, r, n) {
  var i = ae(t, 5), o = i[2], a = i[3], s = i[4], l = n || {}, u = l.plain;
  if (!a)
    return null;
  var c = o._tokenKey, d = -999, h = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(d)
  }, f = A0(a, s, c, h, u);
  return [d, c, f];
}, YJ = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, iz = "comm", oz = "rule", az = "decl", qJ = "@import", XJ = "@keyframes", ZJ = "@layer", sz = Math.abs, TP = String.fromCharCode;
function lz(e) {
  return e.trim();
}
function Uy(e, t, r) {
  return e.replace(t, r);
}
function QJ(e, t, r) {
  return e.indexOf(t, r);
}
function Tg(e, t) {
  return e.charCodeAt(t) | 0;
}
function Pg(e, t, r) {
  return e.slice(t, r);
}
function Ls(e) {
  return e.length;
}
function JJ(e) {
  return e.length;
}
function lm(e, t) {
  return t.push(e), e;
}
var hS = 1, Vh = 1, uz = 0, Qo = 0, Dn = 0, af = "";
function PP(e, t, r, n, i, o, a, s) {
  return { value: e, root: t, parent: r, type: n, props: i, children: o, line: hS, column: Vh, length: a, return: "", siblings: s };
}
function eee() {
  return Dn;
}
function tee() {
  return Dn = Qo > 0 ? Tg(af, --Qo) : 0, Vh--, Dn === 10 && (Vh = 1, hS--), Dn;
}
function _a() {
  return Dn = Qo < uz ? Tg(af, Qo++) : 0, Vh++, Dn === 10 && (Vh = 1, hS++), Dn;
}
function Ec() {
  return Tg(af, Qo);
}
function Ky() {
  return Qo;
}
function fS(e, t) {
  return Pg(af, e, t);
}
function tR(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function ree(e) {
  return hS = Vh = 1, uz = Ls(af = e), Qo = 0, [];
}
function nee(e) {
  return af = "", e;
}
function Zw(e) {
  return lz(fS(Qo - 1, rR(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function iee(e) {
  for (; (Dn = Ec()) && Dn < 33; )
    _a();
  return tR(e) > 2 || tR(Dn) > 3 ? "" : " ";
}
function oee(e, t) {
  for (; --t && _a() && !(Dn < 48 || Dn > 102 || Dn > 57 && Dn < 65 || Dn > 70 && Dn < 97); )
    ;
  return fS(e, Ky() + (t < 6 && Ec() == 32 && _a() == 32));
}
function rR(e) {
  for (; _a(); )
    switch (Dn) {
      case e:
        return Qo;
      case 34:
      case 39:
        e !== 34 && e !== 39 && rR(Dn);
        break;
      case 40:
        e === 41 && rR(e);
        break;
      case 92:
        _a();
        break;
    }
  return Qo;
}
function aee(e, t) {
  for (; _a() && e + Dn !== 57; )
    if (e + Dn === 84 && Ec() === 47)
      break;
  return "/*" + fS(t, Qo - 1) + "*" + TP(e === 47 ? e : _a());
}
function see(e) {
  for (; !tR(Ec()); )
    _a();
  return fS(e, Qo);
}
function lee(e) {
  return nee(Yy("", null, null, null, [""], e = ree(e), 0, [0], e));
}
function Yy(e, t, r, n, i, o, a, s, l) {
  for (var u = 0, c = 0, d = a, h = 0, f = 0, p = 0, g = 1, v = 1, m = 1, y = 0, C = "", S = i, b = o, w = n, x = C; v; )
    switch (p = y, y = _a()) {
      case 40:
        if (p != 108 && Tg(x, d - 1) == 58) {
          QJ(x += Uy(Zw(y), "&", "&\f"), "&\f", sz(u ? s[u - 1] : 0)) != -1 && (m = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        x += Zw(y);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        x += iee(p);
        break;
      case 92:
        x += oee(Ky() - 1, 7);
        continue;
      case 47:
        switch (Ec()) {
          case 42:
          case 47:
            lm(uee(aee(_a(), Ky()), t, r, l), l);
            break;
          default:
            x += "/";
        }
        break;
      case 123 * g:
        s[u++] = Ls(x) * m;
      case 125 * g:
      case 59:
      case 0:
        switch (y) {
          case 0:
          case 125:
            v = 0;
          case 59 + c:
            m == -1 && (x = Uy(x, /\f/g, "")), f > 0 && Ls(x) - d && lm(f > 32 ? _2(x + ";", n, r, d - 1, l) : _2(Uy(x, " ", "") + ";", n, r, d - 2, l), l);
            break;
          case 59:
            x += ";";
          default:
            if (lm(w = R2(x, t, r, u, c, i, s, C, S = [], b = [], d, o), o), y === 123)
              if (c === 0)
                Yy(x, t, w, w, S, o, d, s, b);
              else
                switch (h === 99 && Tg(x, 3) === 110 ? 100 : h) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Yy(e, w, w, n && lm(R2(e, w, w, 0, 0, i, s, C, i, S = [], d, b), b), i, b, d, s, n ? S : b);
                    break;
                  default:
                    Yy(x, w, w, w, [""], b, 0, s, b);
                }
        }
        u = c = f = 0, g = m = 1, C = x = "", d = a;
        break;
      case 58:
        d = 1 + Ls(x), f = p;
      default:
        if (g < 1) {
          if (y == 123)
            --g;
          else if (y == 125 && g++ == 0 && tee() == 125)
            continue;
        }
        switch (x += TP(y), y * g) {
          case 38:
            m = c > 0 ? 1 : (x += "\f", -1);
            break;
          case 44:
            s[u++] = (Ls(x) - 1) * m, m = 1;
            break;
          case 64:
            Ec() === 45 && (x += Zw(_a())), h = Ec(), c = d = Ls(C = x += see(Ky())), y++;
            break;
          case 45:
            p === 45 && Ls(x) == 2 && (g = 0);
        }
    }
  return o;
}
function R2(e, t, r, n, i, o, a, s, l, u, c, d) {
  for (var h = i - 1, f = i === 0 ? o : [""], p = JJ(f), g = 0, v = 0, m = 0; g < n; ++g)
    for (var y = 0, C = Pg(e, h + 1, h = sz(v = a[g])), S = e; y < p; ++y)
      (S = lz(v > 0 ? f[y] + " " + C : Uy(C, /&\f/g, f[y]))) && (l[m++] = S);
  return PP(e, t, r, i === 0 ? oz : s, l, u, c, d);
}
function uee(e, t, r, n) {
  return PP(e, t, r, iz, TP(eee()), Pg(e, 2, -2), 0, n);
}
function _2(e, t, r, n, i) {
  return PP(e, t, r, az, Pg(e, 0, n), Pg(e, n + 1, -1), n, i);
}
function nR(e, t) {
  for (var r = "", n = 0; n < e.length; n++)
    r += t(e[n], n, e, t) || "";
  return r;
}
function cee(e, t, r, n) {
  switch (e.type) {
    case ZJ:
      if (e.children.length) break;
    case qJ:
    case az:
      return e.return = e.return || e.value;
    case iz:
      return "";
    case XJ:
      return e.return = e.value + "{" + nR(e.children, n) + "}";
    case oz:
      if (!Ls(e.value = e.props.join(","))) return "";
  }
  return Ls(r = nR(e.children, n)) ? e.return = e.value + "{" + r + "}" : "";
}
function cz(e, t) {
  var r = t.path, n = t.parentSelectors;
  Qt(!1, "[Ant Design CSS-in-JS] ".concat(r ? "Error in ".concat(r, ": ") : "").concat(e).concat(n.length ? " Selector: ".concat(n.join(" | ")) : ""));
}
var dee = function(t, r, n) {
  if (t === "content") {
    var i = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, o = ["normal", "none", "initial", "inherit", "unset"];
    (typeof r != "string" || o.indexOf(r) === -1 && !i.test(r) && (r.charAt(0) !== r.charAt(r.length - 1) || r.charAt(0) !== '"' && r.charAt(0) !== "'")) && cz("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"".concat(r, "\"'`."), n);
  }
}, hee = function(t, r, n) {
  t === "animation" && n.hashId && r !== "none" && cz("You seem to be using hashed animation '".concat(r, "', in which case 'animationName' with Keyframe as value is recommended."), n);
}, T2 = "data-ant-cssinjs-cache-path", dz = "_FILE_STYLE__", Rc, hz = !0;
function fee() {
  if (!Rc && (Rc = {}, Zn())) {
    var e = document.createElement("div");
    e.className = T2, e.style.position = "fixed", e.style.visibility = "hidden", e.style.top = "-9999px", document.body.appendChild(e);
    var t = getComputedStyle(e).content || "";
    t = t.replace(/^"/, "").replace(/"$/, ""), t.split(";").forEach(function(i) {
      var o = i.split(":"), a = ae(o, 2), s = a[0], l = a[1];
      Rc[s] = l;
    });
    var r = document.querySelector("style[".concat(T2, "]"));
    if (r) {
      var n;
      hz = !1, (n = r.parentNode) === null || n === void 0 || n.removeChild(r);
    }
    document.body.removeChild(e);
  }
}
function pee(e) {
  return fee(), !!Rc[e];
}
function gee(e) {
  var t = Rc[e], r = null;
  if (t && Zn())
    if (hz)
      r = dz;
    else {
      var n = document.querySelector("style[".concat(Ra, '="').concat(Rc[e], '"]'));
      n ? r = n.innerHTML : delete Rc[e];
    }
  return [r, t];
}
var fz = "_skip_check_", pz = "_multi_value_";
function qy(e) {
  var t = nR(lee(e), cee);
  return t.replace(/\{%%%\:[^;];}/g, ";");
}
function vee(e) {
  return vt(e) === "object" && e && (fz in e || pz in e);
}
function mee(e, t, r) {
  if (!t)
    return e;
  var n = ".".concat(t), i = r === "low" ? ":where(".concat(n, ")") : n, o = e.split(",").map(function(a) {
    var s, l = a.trim().split(/\s+/), u = l[0] || "", c = ((s = u.match(/^\w+/)) === null || s === void 0 ? void 0 : s[0]) || "";
    return u = "".concat(c).concat(i).concat(u.slice(c.length)), [u].concat(it(l.slice(1))).join(" ");
  });
  return o.join(",");
}
var yee = function e(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  }, i = n.root, o = n.injectHash, a = n.parentSelectors, s = r.hashId, l = r.layer, u = r.path, c = r.hashPriority, d = r.transformers, h = d === void 0 ? [] : d, f = r.linters, p = f === void 0 ? [] : f, g = "", v = {};
  function m(S) {
    var b = S.getName(s);
    if (!v[b]) {
      var w = e(S.style, r, {
        root: !1,
        parentSelectors: a
      }), x = ae(w, 1), R = x[0];
      v[b] = "@keyframes ".concat(S.getName(s)).concat(R);
    }
  }
  function y(S) {
    var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return S.forEach(function(w) {
      Array.isArray(w) ? y(w, b) : w && b.push(w);
    }), b;
  }
  var C = y(Array.isArray(t) ? t : [t]);
  return C.forEach(function(S) {
    var b = typeof S == "string" && !i ? {} : S;
    if (typeof b == "string")
      g += "".concat(b, `
`);
    else if (b._keyframe)
      m(b);
    else {
      var w = h.reduce(function(x, R) {
        var _;
        return (R == null || (_ = R.visit) === null || _ === void 0 ? void 0 : _.call(R, x)) || x;
      }, b);
      Object.keys(w).forEach(function(x) {
        var R = w[x];
        if (vt(R) === "object" && R && (x !== "animationName" || !R._keyframe) && !vee(R)) {
          var _ = !1, T = x.trim(), P = !1;
          (i || o) && s ? T.startsWith("@") ? _ = !0 : T = mee(x, s, c) : i && !s && (T === "&" || T === "") && (T = "", P = !0);
          var D = e(R, r, {
            root: P,
            injectHash: _,
            parentSelectors: [].concat(it(a), [T])
          }), O = ae(D, 2), A = O[0], F = O[1];
          v = ee(ee({}, v), F), g += "".concat(T).concat(A);
        } else {
          let I = function(B, M) {
            process.env.NODE_ENV !== "production" && (vt(R) !== "object" || !(R != null && R[fz])) && [dee, hee].concat(it(p)).forEach(function(k) {
              return k(B, M, {
                path: u,
                hashId: s,
                parentSelectors: a
              });
            });
            var V = B.replace(/[A-Z]/g, function(k) {
              return "-".concat(k.toLowerCase());
            }), G = M;
            !YJ[B] && typeof G == "number" && G !== 0 && (G = "".concat(G, "px")), B === "animationName" && M !== null && M !== void 0 && M._keyframe && (m(M), G = M.getName(s)), g += "".concat(V, ":").concat(G, ";");
          };
          var L, N = (L = R == null ? void 0 : R.value) !== null && L !== void 0 ? L : R;
          vt(R) === "object" && R !== null && R !== void 0 && R[pz] && Array.isArray(N) ? N.forEach(function(B) {
            I(x, B);
          }) : I(x, N);
        }
      });
    }
  }), i ? l && (g = "@layer ".concat(l.name, " {").concat(g, "}"), l.dependencies && (v["@layer ".concat(l.name)] = l.dependencies.map(function(S) {
    return "@layer ".concat(S, ", ").concat(l.name, ";");
  }).join(`
`))) : g = "{".concat(g, "}"), [g, v];
};
function gz(e, t) {
  return Rg("".concat(e.join("%")).concat(t));
}
function Cee() {
  return null;
}
var vz = "style";
function iR(e, t) {
  var r = e.token, n = e.path, i = e.hashId, o = e.layer, a = e.nonce, s = e.clientOnly, l = e.order, u = l === void 0 ? 0 : l, c = E.useContext(dS), d = c.autoClear, h = c.mock, f = c.defaultCache, p = c.hashPriority, g = c.container, v = c.ssrInline, m = c.transformers, y = c.linters, C = c.cache, S = c.layer, b = r._tokenKey, w = [b];
  S && w.push("layer"), w.push.apply(w, it(n));
  var x = QE;
  process.env.NODE_ENV !== "production" && h !== void 0 && (x = h === "client");
  var R = _P(
    vz,
    w,
    // Create cache if needed
    function() {
      var O = w.join("|");
      if (pee(O)) {
        var A = gee(O), F = ae(A, 2), L = F[0], N = F[1];
        if (L)
          return [L, b, N, {}, s, u];
      }
      var I = t(), B = yee(I, {
        hashId: i,
        hashPriority: p,
        layer: S ? o : void 0,
        path: n.join("-"),
        transformers: m,
        linters: y
      }), M = ae(B, 2), V = M[0], G = M[1], k = qy(V), z = gz(w, k);
      return [k, b, z, G, s, u];
    },
    // Remove cache if no need
    function(O, A) {
      var F = ae(O, 3), L = F[2];
      (A || d) && QE && _g(L, {
        mark: Ra
      });
    },
    // Effect: Inject style here
    function(O) {
      var A = ae(O, 4), F = A[0];
      A[1];
      var L = A[2], N = A[3];
      if (x && F !== dz) {
        var I = {
          mark: Ra,
          prepend: S ? !1 : "queue",
          attachTo: g,
          priority: u
        }, B = typeof a == "function" ? a() : a;
        B && (I.csp = {
          nonce: B
        });
        var M = [], V = [];
        Object.keys(N).forEach(function(k) {
          k.startsWith("@layer") ? M.push(k) : V.push(k);
        }), M.forEach(function(k) {
          Gs(qy(N[k]), "_layer-".concat(k), ee(ee({}, I), {}, {
            prepend: !0
          }));
        });
        var G = Gs(F, L, I);
        G[Al] = C.instanceId, G.setAttribute(kh, b), process.env.NODE_ENV !== "production" && G.setAttribute(mJ, w.join("|")), V.forEach(function(k) {
          Gs(qy(N[k]), "_effect-".concat(k), I);
        });
      }
    }
  ), _ = ae(R, 3), T = _[0], P = _[1], D = _[2];
  return function(O) {
    var A;
    return !v || x || !f ? A = /* @__PURE__ */ E.createElement(Cee, null) : A = /* @__PURE__ */ E.createElement("style", $e({}, te(te({}, kh, P), Ra, D), {
      dangerouslySetInnerHTML: {
        __html: T
      }
    })), /* @__PURE__ */ E.createElement(E.Fragment, null, A, O);
  };
}
var See = function(t, r, n) {
  var i = ae(t, 6), o = i[0], a = i[1], s = i[2], l = i[3], u = i[4], c = i[5], d = n || {}, h = d.plain;
  if (u)
    return null;
  var f = o, p = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(c)
  };
  return f = A0(o, a, s, p, h), l && Object.keys(l).forEach(function(g) {
    if (!r[g]) {
      r[g] = !0;
      var v = qy(l[g]), m = A0(v, a, "_effect-".concat(g), p, h);
      g.startsWith("@layer") ? f = m + f : f += m;
    }
  }), [c, s, f];
}, mz = "cssVar", wee = function(t, r) {
  var n = t.key, i = t.prefix, o = t.unitless, a = t.ignore, s = t.token, l = t.scope, u = l === void 0 ? "" : l, c = vr(dS), d = c.cache.instanceId, h = c.container, f = s._tokenKey, p = [].concat(it(t.path), [n, u, f]), g = _P(mz, p, function() {
    var v = r(), m = rz(v, n, {
      prefix: i,
      unitless: o,
      ignore: a,
      scope: u
    }), y = ae(m, 2), C = y[0], S = y[1], b = gz(p, S);
    return [C, S, b, n];
  }, function(v) {
    var m = ae(v, 3), y = m[2];
    QE && _g(y, {
      mark: Ra
    });
  }, function(v) {
    var m = ae(v, 3), y = m[1], C = m[2];
    if (y) {
      var S = Gs(y, C, {
        mark: Ra,
        prepend: "queue",
        attachTo: h,
        priority: -999
      });
      S[Al] = d, S.setAttribute(kh, n);
    }
  });
  return g;
}, bee = function(t, r, n) {
  var i = ae(t, 4), o = i[1], a = i[2], s = i[3], l = n || {}, u = l.plain;
  if (!o)
    return null;
  var c = -999, d = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(c)
  }, h = A0(o, s, a, d, u);
  return [c, a, h];
};
te(te(te({}, vz, See), nz, KJ), mz, bee);
var Mr = /* @__PURE__ */ function() {
  function e(t, r) {
    Kn(this, e), te(this, "name", void 0), te(this, "style", void 0), te(this, "_keyframe", !0), this.name = t, this.style = r;
  }
  return Yn(e, [{
    key: "getName",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return r ? "".concat(r, "-").concat(this.name) : this.name;
    }
  }]), e;
}();
function Cd(e) {
  return e.notSplit = !0, e;
}
Cd(["borderTop", "borderBottom"]), Cd(["borderTop"]), Cd(["borderBottom"]), Cd(["borderLeft", "borderRight"]), Cd(["borderLeft"]), Cd(["borderRight"]);
var MP = /* @__PURE__ */ du({});
function yz(e) {
  return YG(e) || WG(e) || xP(e) || qG();
}
function rs(e, t) {
  for (var r = e, n = 0; n < t.length; n += 1) {
    if (r == null)
      return;
    r = r[t[n]];
  }
  return r;
}
function Cz(e, t, r, n) {
  if (!t.length)
    return r;
  var i = yz(t), o = i[0], a = i.slice(1), s;
  return !e && typeof o == "number" ? s = [] : Array.isArray(e) ? s = it(e) : s = ee({}, e), n && r === void 0 && a.length === 1 ? delete s[o][a[0]] : s[o] = Cz(s[o], a, r, n), s;
}
function ya(e, t, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return t.length && n && r === void 0 && !rs(e, t.slice(0, -1)) ? e : Cz(e, t, r, n);
}
function xee(e) {
  return vt(e) === "object" && e !== null && Object.getPrototypeOf(e) === Object.prototype;
}
function P2(e) {
  return Array.isArray(e) ? [] : {};
}
var Eee = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function uh() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = P2(t[0]);
  return t.forEach(function(i) {
    function o(a, s) {
      var l = new Set(s), u = rs(i, a), c = Array.isArray(u);
      if (c || xee(u)) {
        if (!l.has(u)) {
          l.add(u);
          var d = rs(n, a);
          c ? n = ya(n, a, []) : (!d || vt(d) !== "object") && (n = ya(n, a, P2(u))), Eee(u).forEach(function(h) {
            o([].concat(it(a), [h]), l);
          });
        }
      } else
        n = ya(n, a, u);
    }
    o([]);
  }), n;
}
function Sz() {
}
let As = null;
function Ree() {
  As = null, OG();
}
let sf = Sz;
process.env.NODE_ENV !== "production" && (sf = (e, t, r) => {
  Qt(e, `[antd: ${t}] ${r}`), process.env.NODE_ENV === "test" && Ree();
});
const wz = /* @__PURE__ */ E.createContext({}), en = process.env.NODE_ENV !== "production" ? (e) => {
  const {
    strict: t
  } = E.useContext(wz), r = (n, i, o) => {
    if (!n)
      if (t === !1 && i === "deprecated") {
        const a = As;
        As || (As = {}), As[e] = As[e] || [], As[e].includes(o || "") || As[e].push(o || ""), a || console.warn("[antd] There exists deprecated usage in your code:", As);
      } else
        process.env.NODE_ENV !== "production" && sf(n, e, o);
  };
  return r.deprecated = (n, i, o, a) => {
    r(n, "deprecated", `\`${i}\` is deprecated. Please use \`${o}\` instead.${a ? ` ${a}` : ""}`);
  }, r;
} : () => {
  const e = () => {
  };
  return e.deprecated = Sz, e;
}, _ee = /* @__PURE__ */ du(void 0);
var Tee = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
}, Pee = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: !0,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
const bz = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
}, M2 = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, Pee),
  timePickerLocale: Object.assign({}, bz)
}, no = "${label} is not a valid ${type}", Ys = {
  locale: "en",
  Pagination: Tee,
  DatePicker: M2,
  TimePicker: bz,
  Calendar: M2,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: no,
        method: no,
        array: no,
        object: no,
        number: no,
        date: no,
        boolean: no,
        integer: no,
        float: no,
        regexp: no,
        email: no,
        url: no,
        hex: no
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty"
  }
};
Object.assign({}, Ys.Modal);
let Xy = [];
const D2 = () => Xy.reduce((e, t) => Object.assign(Object.assign({}, e), t), Ys.Modal);
function Mee(e) {
  if (e) {
    const t = Object.assign({}, e);
    return Xy.push(t), D2(), () => {
      Xy = Xy.filter((r) => r !== t), D2();
    };
  }
  Object.assign({}, Ys.Modal);
}
const DP = /* @__PURE__ */ du(void 0), AP = (e, t) => {
  const r = E.useContext(DP), n = E.useMemo(() => {
    var o;
    const a = t || Ys[e], s = (o = r == null ? void 0 : r[e]) !== null && o !== void 0 ? o : {};
    return Object.assign(Object.assign({}, typeof a == "function" ? a() : a), s || {});
  }, [e, t, r]), i = E.useMemo(() => {
    const o = r == null ? void 0 : r.locale;
    return r != null && r.exist && !o ? Ys.locale : o;
  }, [r]);
  return [n, i];
}, xz = "internalMark", Ez = (e) => {
  const {
    locale: t = {},
    children: r,
    _ANT_MARK__: n
  } = e;
  if (process.env.NODE_ENV !== "production") {
    const o = en("LocaleProvider");
    process.env.NODE_ENV !== "production" && o(n === xz, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale");
  }
  E.useEffect(() => Mee(t == null ? void 0 : t.Modal), [t]);
  const i = E.useMemo(() => Object.assign(Object.assign({}, t), {
    exist: !0
  }), [t]);
  return /* @__PURE__ */ E.createElement(DP.Provider, {
    value: i
  }, r);
};
process.env.NODE_ENV !== "production" && (Ez.displayName = "LocaleProvider");
function Qn(e, t) {
  Dee(e) && (e = "100%");
  var r = Aee(e);
  return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), r && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
}
function um(e) {
  return Math.min(1, Math.max(0, e));
}
function Dee(e) {
  return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
}
function Aee(e) {
  return typeof e == "string" && e.indexOf("%") !== -1;
}
function Rz(e) {
  return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function cm(e) {
  return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
}
function fc(e) {
  return e.length === 1 ? "0" + e : String(e);
}
function Iee(e, t, r) {
  return {
    r: Qn(e, 255) * 255,
    g: Qn(t, 255) * 255,
    b: Qn(r, 255) * 255
  };
}
function A2(e, t, r) {
  e = Qn(e, 255), t = Qn(t, 255), r = Qn(r, 255);
  var n = Math.max(e, t, r), i = Math.min(e, t, r), o = 0, a = 0, s = (n + i) / 2;
  if (n === i)
    a = 0, o = 0;
  else {
    var l = n - i;
    switch (a = s > 0.5 ? l / (2 - n - i) : l / (n + i), n) {
      case e:
        o = (t - r) / l + (t < r ? 6 : 0);
        break;
      case t:
        o = (r - e) / l + 2;
        break;
      case r:
        o = (e - t) / l + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: a, l: s };
}
function Qw(e, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * (6 * r) : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function Oee(e, t, r) {
  var n, i, o;
  if (e = Qn(e, 360), t = Qn(t, 100), r = Qn(r, 100), t === 0)
    i = r, o = r, n = r;
  else {
    var a = r < 0.5 ? r * (1 + t) : r + t - r * t, s = 2 * r - a;
    n = Qw(s, a, e + 1 / 3), i = Qw(s, a, e), o = Qw(s, a, e - 1 / 3);
  }
  return { r: n * 255, g: i * 255, b: o * 255 };
}
function oR(e, t, r) {
  e = Qn(e, 255), t = Qn(t, 255), r = Qn(r, 255);
  var n = Math.max(e, t, r), i = Math.min(e, t, r), o = 0, a = n, s = n - i, l = n === 0 ? 0 : s / n;
  if (n === i)
    o = 0;
  else {
    switch (n) {
      case e:
        o = (t - r) / s + (t < r ? 6 : 0);
        break;
      case t:
        o = (r - e) / s + 2;
        break;
      case r:
        o = (e - t) / s + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: l, v: a };
}
function Lee(e, t, r) {
  e = Qn(e, 360) * 6, t = Qn(t, 100), r = Qn(r, 100);
  var n = Math.floor(e), i = e - n, o = r * (1 - t), a = r * (1 - i * t), s = r * (1 - (1 - i) * t), l = n % 6, u = [r, a, o, o, s, r][l], c = [s, r, r, a, o, o][l], d = [o, o, s, r, r, a][l];
  return { r: u * 255, g: c * 255, b: d * 255 };
}
function aR(e, t, r, n) {
  var i = [
    fc(Math.round(e).toString(16)),
    fc(Math.round(t).toString(16)),
    fc(Math.round(r).toString(16))
  ];
  return n && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function Fee(e, t, r, n, i) {
  var o = [
    fc(Math.round(e).toString(16)),
    fc(Math.round(t).toString(16)),
    fc(Math.round(r).toString(16)),
    fc(Nee(n))
  ];
  return i && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) && o[3].startsWith(o[3].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0) : o.join("");
}
function Nee(e) {
  return Math.round(parseFloat(e) * 255).toString(16);
}
function I2(e) {
  return so(e) / 255;
}
function so(e) {
  return parseInt(e, 16);
}
function kee(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255
  };
}
var sR = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function rh(e) {
  var t = { r: 0, g: 0, b: 0 }, r = 1, n = null, i = null, o = null, a = !1, s = !1;
  return typeof e == "string" && (e = $ee(e)), typeof e == "object" && (Es(e.r) && Es(e.g) && Es(e.b) ? (t = Iee(e.r, e.g, e.b), a = !0, s = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : Es(e.h) && Es(e.s) && Es(e.v) ? (n = cm(e.s), i = cm(e.v), t = Lee(e.h, n, i), a = !0, s = "hsv") : Es(e.h) && Es(e.s) && Es(e.l) && (n = cm(e.s), o = cm(e.l), t = Oee(e.h, n, o), a = !0, s = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (r = e.a)), r = Rz(r), {
    ok: a,
    format: e.format || s,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: r
  };
}
var Vee = "[-\\+]?\\d+%?", Bee = "[-\\+]?\\d*\\.\\d+%?", Il = "(?:".concat(Bee, ")|(?:").concat(Vee, ")"), Jw = "[\\s|\\(]+(".concat(Il, ")[,|\\s]+(").concat(Il, ")[,|\\s]+(").concat(Il, ")\\s*\\)?"), eb = "[\\s|\\(]+(".concat(Il, ")[,|\\s]+(").concat(Il, ")[,|\\s]+(").concat(Il, ")[,|\\s]+(").concat(Il, ")\\s*\\)?"), fa = {
  CSS_UNIT: new RegExp(Il),
  rgb: new RegExp("rgb" + Jw),
  rgba: new RegExp("rgba" + eb),
  hsl: new RegExp("hsl" + Jw),
  hsla: new RegExp("hsla" + eb),
  hsv: new RegExp("hsv" + Jw),
  hsva: new RegExp("hsva" + eb),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function $ee(e) {
  if (e = e.trim().toLowerCase(), e.length === 0)
    return !1;
  var t = !1;
  if (sR[e])
    e = sR[e], t = !0;
  else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var r = fa.rgb.exec(e);
  return r ? { r: r[1], g: r[2], b: r[3] } : (r = fa.rgba.exec(e), r ? { r: r[1], g: r[2], b: r[3], a: r[4] } : (r = fa.hsl.exec(e), r ? { h: r[1], s: r[2], l: r[3] } : (r = fa.hsla.exec(e), r ? { h: r[1], s: r[2], l: r[3], a: r[4] } : (r = fa.hsv.exec(e), r ? { h: r[1], s: r[2], v: r[3] } : (r = fa.hsva.exec(e), r ? { h: r[1], s: r[2], v: r[3], a: r[4] } : (r = fa.hex8.exec(e), r ? {
    r: so(r[1]),
    g: so(r[2]),
    b: so(r[3]),
    a: I2(r[4]),
    format: t ? "name" : "hex8"
  } : (r = fa.hex6.exec(e), r ? {
    r: so(r[1]),
    g: so(r[2]),
    b: so(r[3]),
    format: t ? "name" : "hex"
  } : (r = fa.hex4.exec(e), r ? {
    r: so(r[1] + r[1]),
    g: so(r[2] + r[2]),
    b: so(r[3] + r[3]),
    a: I2(r[4] + r[4]),
    format: t ? "name" : "hex8"
  } : (r = fa.hex3.exec(e), r ? {
    r: so(r[1] + r[1]),
    g: so(r[2] + r[2]),
    b: so(r[3] + r[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function Es(e) {
  return !!fa.CSS_UNIT.exec(String(e));
}
var Jr = (
  /** @class */
  function() {
    function e(t, r) {
      t === void 0 && (t = ""), r === void 0 && (r = {});
      var n;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = kee(t)), this.originalInput = t;
      var i = rh(t);
      this.originalInput = t, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (n = r.format) !== null && n !== void 0 ? n : i.format, this.gradientType = r.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), r, n, i, o = t.r / 255, a = t.g / 255, s = t.b / 255;
      return o <= 0.03928 ? r = o / 12.92 : r = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? n = a / 12.92 : n = Math.pow((a + 0.055) / 1.055, 2.4), s <= 0.03928 ? i = s / 12.92 : i = Math.pow((s + 0.055) / 1.055, 2.4), 0.2126 * r + 0.7152 * n + 0.0722 * i;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = Rz(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = oR(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = oR(this.r, this.g, this.b), r = Math.round(t.h * 360), n = Math.round(t.s * 100), i = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(r, ", ").concat(n, "%, ").concat(i, "%)") : "hsva(".concat(r, ", ").concat(n, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = A2(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = A2(this.r, this.g, this.b), r = Math.round(t.h * 360), n = Math.round(t.s * 100), i = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(r, ", ").concat(n, "%, ").concat(i, "%)") : "hsla(".concat(r, ", ").concat(n, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), aR(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), Fee(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), r = Math.round(this.g), n = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(r, ", ").concat(n, ")") : "rgba(".concat(t, ", ").concat(r, ", ").concat(n, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(r) {
        return "".concat(Math.round(Qn(r, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(r) {
        return Math.round(Qn(r, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + aR(this.r, this.g, this.b, !1), r = 0, n = Object.entries(sR); r < n.length; r++) {
        var i = n[r], o = i[0], a = i[1];
        if (t === a)
          return o;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var r = !!t;
      t = t ?? this.format;
      var n = !1, i = this.a < 1 && this.a >= 0, o = !r && i && (t.startsWith("hex") || t === "name");
      return o ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (n = this.toRgbString()), t === "prgb" && (n = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (n = this.toHexString()), t === "hex3" && (n = this.toHexString(!0)), t === "hex4" && (n = this.toHex8String(!0)), t === "hex8" && (n = this.toHex8String()), t === "name" && (n = this.toName()), t === "hsl" && (n = this.toHslString()), t === "hsv" && (n = this.toHsvString()), n || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.l += t / 100, r.l = um(r.l), new e(r);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var r = this.toRgb();
      return r.r = Math.max(0, Math.min(255, r.r - Math.round(255 * -(t / 100)))), r.g = Math.max(0, Math.min(255, r.g - Math.round(255 * -(t / 100)))), r.b = Math.max(0, Math.min(255, r.b - Math.round(255 * -(t / 100)))), new e(r);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.l -= t / 100, r.l = um(r.l), new e(r);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.s -= t / 100, r.s = um(r.s), new e(r);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.s += t / 100, r.s = um(r.s), new e(r);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var r = this.toHsl(), n = (r.h + t) % 360;
      return r.h = n < 0 ? 360 + n : n, new e(r);
    }, e.prototype.mix = function(t, r) {
      r === void 0 && (r = 50);
      var n = this.toRgb(), i = new e(t).toRgb(), o = r / 100, a = {
        r: (i.r - n.r) * o + n.r,
        g: (i.g - n.g) * o + n.g,
        b: (i.b - n.b) * o + n.b,
        a: (i.a - n.a) * o + n.a
      };
      return new e(a);
    }, e.prototype.analogous = function(t, r) {
      t === void 0 && (t = 6), r === void 0 && (r = 30);
      var n = this.toHsl(), i = 360 / r, o = [this];
      for (n.h = (n.h - (i * t >> 1) + 720) % 360; --t; )
        n.h = (n.h + i) % 360, o.push(new e(n));
      return o;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var r = this.toHsv(), n = r.h, i = r.s, o = r.v, a = [], s = 1 / t; t--; )
        a.push(new e({ h: n, s: i, v: o })), o = (o + s) % 1;
      return a;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), r = t.h;
      return [
        this,
        new e({ h: (r + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (r + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var r = this.toRgb(), n = new e(t).toRgb(), i = r.a + n.a * (1 - r.a);
      return new e({
        r: (r.r * r.a + n.r * n.a * (1 - r.a)) / i,
        g: (r.g * r.a + n.g * n.a * (1 - r.a)) / i,
        b: (r.b * r.a + n.b * n.a * (1 - r.a)) / i,
        a: i
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var r = this.toHsl(), n = r.h, i = [this], o = 360 / t, a = 1; a < t; a++)
        i.push(new e({ h: (n + a * o) % 360, s: r.s, l: r.l }));
      return i;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }()
), dm = 2, O2 = 0.16, Hee = 0.05, Gee = 0.05, zee = 0.15, _z = 5, Tz = 4, Wee = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function L2(e) {
  var t = e.r, r = e.g, n = e.b, i = oR(t, r, n);
  return {
    h: i.h * 360,
    s: i.s,
    v: i.v
  };
}
function hm(e) {
  var t = e.r, r = e.g, n = e.b;
  return "#".concat(aR(t, r, n, !1));
}
function jee(e, t, r) {
  var n = r / 100, i = {
    r: (t.r - e.r) * n + e.r,
    g: (t.g - e.g) * n + e.g,
    b: (t.b - e.b) * n + e.b
  };
  return i;
}
function F2(e, t, r) {
  var n;
  return Math.round(e.h) >= 60 && Math.round(e.h) <= 240 ? n = r ? Math.round(e.h) - dm * t : Math.round(e.h) + dm * t : n = r ? Math.round(e.h) + dm * t : Math.round(e.h) - dm * t, n < 0 ? n += 360 : n >= 360 && (n -= 360), n;
}
function N2(e, t, r) {
  if (e.h === 0 && e.s === 0)
    return e.s;
  var n;
  return r ? n = e.s - O2 * t : t === Tz ? n = e.s + O2 : n = e.s + Hee * t, n > 1 && (n = 1), r && t === _z && n > 0.1 && (n = 0.1), n < 0.06 && (n = 0.06), Number(n.toFixed(2));
}
function k2(e, t, r) {
  var n;
  return r ? n = e.v + Gee * t : n = e.v - zee * t, n > 1 && (n = 1), Number(n.toFixed(2));
}
function Mg(e) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = [], n = rh(e), i = _z; i > 0; i -= 1) {
    var o = L2(n), a = hm(rh({
      h: F2(o, i, !0),
      s: N2(o, i, !0),
      v: k2(o, i, !0)
    }));
    r.push(a);
  }
  r.push(hm(n));
  for (var s = 1; s <= Tz; s += 1) {
    var l = L2(n), u = hm(rh({
      h: F2(l, s),
      s: N2(l, s),
      v: k2(l, s)
    }));
    r.push(u);
  }
  return t.theme === "dark" ? Wee.map(function(c) {
    var d = c.index, h = c.opacity, f = hm(jee(rh(t.backgroundColor || "#141414"), rh(r[d]), h * 100));
    return f;
  }) : r;
}
var lR = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1677FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, uR = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
uR.primary = uR[5];
var cR = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
cR.primary = cR[5];
const Pz = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, Dg = Object.assign(Object.assign({}, Pz), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorLink: "",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1,
  // Motion
  motion: !0
});
function Uee(e, t) {
  let {
    generateColorPalettes: r,
    generateNeutralColorPalettes: n
  } = t;
  const {
    colorSuccess: i,
    colorWarning: o,
    colorError: a,
    colorInfo: s,
    colorPrimary: l,
    colorBgBase: u,
    colorTextBase: c
  } = e, d = r(l), h = r(i), f = r(o), p = r(a), g = r(s), v = n(u, c), m = e.colorLink || e.colorInfo, y = r(m);
  return Object.assign(Object.assign({}, v), {
    colorPrimaryBg: d[1],
    colorPrimaryBgHover: d[2],
    colorPrimaryBorder: d[3],
    colorPrimaryBorderHover: d[4],
    colorPrimaryHover: d[5],
    colorPrimary: d[6],
    colorPrimaryActive: d[7],
    colorPrimaryTextHover: d[8],
    colorPrimaryText: d[9],
    colorPrimaryTextActive: d[10],
    colorSuccessBg: h[1],
    colorSuccessBgHover: h[2],
    colorSuccessBorder: h[3],
    colorSuccessBorderHover: h[4],
    colorSuccessHover: h[4],
    colorSuccess: h[6],
    colorSuccessActive: h[7],
    colorSuccessTextHover: h[8],
    colorSuccessText: h[9],
    colorSuccessTextActive: h[10],
    colorErrorBg: p[1],
    colorErrorBgHover: p[2],
    colorErrorBgActive: p[3],
    colorErrorBorder: p[3],
    colorErrorBorderHover: p[4],
    colorErrorHover: p[5],
    colorError: p[6],
    colorErrorActive: p[7],
    colorErrorTextHover: p[8],
    colorErrorText: p[9],
    colorErrorTextActive: p[10],
    colorWarningBg: f[1],
    colorWarningBgHover: f[2],
    colorWarningBorder: f[3],
    colorWarningBorderHover: f[4],
    colorWarningHover: f[4],
    colorWarning: f[6],
    colorWarningActive: f[7],
    colorWarningTextHover: f[8],
    colorWarningText: f[9],
    colorWarningTextActive: f[10],
    colorInfoBg: g[1],
    colorInfoBgHover: g[2],
    colorInfoBorder: g[3],
    colorInfoBorderHover: g[4],
    colorInfoHover: g[4],
    colorInfo: g[6],
    colorInfoActive: g[7],
    colorInfoTextHover: g[8],
    colorInfoText: g[9],
    colorInfoTextActive: g[10],
    colorLinkHover: y[4],
    colorLink: y[6],
    colorLinkActive: y[7],
    colorBgMask: new Jr("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const Kee = (e) => {
  let t = e, r = e, n = e, i = e;
  return e < 6 && e >= 5 ? t = e + 1 : e < 16 && e >= 6 ? t = e + 2 : e >= 16 && (t = 16), e < 7 && e >= 5 ? r = 4 : e < 8 && e >= 7 ? r = 5 : e < 14 && e >= 8 ? r = 6 : e < 16 && e >= 14 ? r = 7 : e >= 16 && (r = 8), e < 6 && e >= 2 ? n = 1 : e >= 6 && (n = 2), e > 4 && e < 8 ? i = 4 : e >= 8 && (i = 6), {
    borderRadius: e,
    borderRadiusXS: n,
    borderRadiusSM: r,
    borderRadiusLG: t,
    borderRadiusOuter: i
  };
};
function Yee(e) {
  const {
    motionUnit: t,
    motionBase: r,
    borderRadius: n,
    lineWidth: i
  } = e;
  return Object.assign({
    // motion
    motionDurationFast: `${(r + t).toFixed(1)}s`,
    motionDurationMid: `${(r + t * 2).toFixed(1)}s`,
    motionDurationSlow: `${(r + t * 3).toFixed(1)}s`,
    // line
    lineWidthBold: i + 1
  }, Kee(n));
}
const qee = (e) => {
  const {
    controlHeight: t
  } = e;
  return {
    controlHeightSM: t * 0.75,
    controlHeightXS: t * 0.5,
    controlHeightLG: t * 1.25
  };
};
function Zy(e) {
  return (e + 8) / e;
}
function Xee(e) {
  const t = new Array(10).fill(null).map((r, n) => {
    const i = n - 1, o = e * Math.pow(Math.E, i / 5), a = n > 1 ? Math.floor(o) : Math.ceil(o);
    return Math.floor(a / 2) * 2;
  });
  return t[1] = e, t.map((r) => ({
    size: r,
    lineHeight: Zy(r)
  }));
}
const Zee = (e) => {
  const t = Xee(e), r = t.map((c) => c.size), n = t.map((c) => c.lineHeight), i = r[1], o = r[0], a = r[2], s = n[1], l = n[0], u = n[2];
  return {
    fontSizeSM: o,
    fontSize: i,
    fontSizeLG: a,
    fontSizeXL: r[3],
    fontSizeHeading1: r[6],
    fontSizeHeading2: r[5],
    fontSizeHeading3: r[4],
    fontSizeHeading4: r[3],
    fontSizeHeading5: r[2],
    lineHeight: s,
    lineHeightLG: u,
    lineHeightSM: l,
    fontHeight: Math.round(s * i),
    fontHeightLG: Math.round(u * a),
    fontHeightSM: Math.round(l * o),
    lineHeightHeading1: n[6],
    lineHeightHeading2: n[5],
    lineHeightHeading3: n[4],
    lineHeightHeading4: n[3],
    lineHeightHeading5: n[2]
  };
};
function Qee(e) {
  const {
    sizeUnit: t,
    sizeStep: r
  } = e;
  return {
    sizeXXL: t * (r + 8),
    // 48
    sizeXL: t * (r + 4),
    // 32
    sizeLG: t * (r + 2),
    // 24
    sizeMD: t * (r + 1),
    // 20
    sizeMS: t * r,
    // 16
    size: t * r,
    // 16
    sizeSM: t * (r - 1),
    // 12
    sizeXS: t * (r - 2),
    // 8
    sizeXXS: t * (r - 3)
    // 4
  };
}
const Rs = (e, t) => new Jr(e).setAlpha(t).toRgbString(), Gf = (e, t) => new Jr(e).darken(t).toHexString(), Jee = (e) => {
  const t = Mg(e);
  return {
    1: t[0],
    2: t[1],
    3: t[2],
    4: t[3],
    5: t[4],
    6: t[5],
    7: t[6],
    8: t[4],
    9: t[5],
    10: t[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, ete = (e, t) => {
  const r = e || "#fff", n = t || "#000";
  return {
    colorBgBase: r,
    colorTextBase: n,
    colorText: Rs(n, 0.88),
    colorTextSecondary: Rs(n, 0.65),
    colorTextTertiary: Rs(n, 0.45),
    colorTextQuaternary: Rs(n, 0.25),
    colorFill: Rs(n, 0.15),
    colorFillSecondary: Rs(n, 0.06),
    colorFillTertiary: Rs(n, 0.04),
    colorFillQuaternary: Rs(n, 0.02),
    colorBgLayout: Gf(r, 4),
    colorBgContainer: Gf(r, 0),
    colorBgElevated: Gf(r, 0),
    colorBgSpotlight: Rs(n, 0.85),
    colorBgBlur: "transparent",
    colorBorder: Gf(r, 15),
    colorBorderSecondary: Gf(r, 6)
  };
};
function tte(e) {
  const t = Object.keys(Pz).map((r) => {
    const n = Mg(e[r]);
    return new Array(10).fill(1).reduce((i, o, a) => (i[`${r}-${a + 1}`] = n[a], i[`${r}${a + 1}`] = n[a], i), {});
  }).reduce((r, n) => (r = Object.assign(Object.assign({}, r), n), r), {});
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, e), t), Uee(e, {
    generateColorPalettes: Jee,
    generateNeutralColorPalettes: ete
  })), Zee(e.fontSize)), Qee(e)), qee(e)), Yee(e));
}
const Mz = ZE(tte), dR = {
  token: Dg,
  override: {
    override: Dg
  },
  hashed: !0
}, Dz = /* @__PURE__ */ H.createContext(dR), Az = "anticon", rte = ["outlined", "borderless", "filled"], nte = (e, t) => t || (e ? `ant-${e}` : "ant"), Yt = /* @__PURE__ */ E.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: nte,
  iconPrefixCls: Az
}), ite = `-ant-${Date.now()}-${Math.random()}`;
function ote(e, t) {
  const r = {}, n = (a, s) => {
    let l = a.clone();
    return l = (s == null ? void 0 : s(l)) || l, l.toRgbString();
  }, i = (a, s) => {
    const l = new Jr(a), u = Mg(l.toRgbString());
    r[`${s}-color`] = n(l), r[`${s}-color-disabled`] = u[1], r[`${s}-color-hover`] = u[4], r[`${s}-color-active`] = u[6], r[`${s}-color-outline`] = l.clone().setAlpha(0.2).toRgbString(), r[`${s}-color-deprecated-bg`] = u[0], r[`${s}-color-deprecated-border`] = u[2];
  };
  if (t.primaryColor) {
    i(t.primaryColor, "primary");
    const a = new Jr(t.primaryColor), s = Mg(a.toRgbString());
    s.forEach((u, c) => {
      r[`primary-${c + 1}`] = u;
    }), r["primary-color-deprecated-l-35"] = n(a, (u) => u.lighten(35)), r["primary-color-deprecated-l-20"] = n(a, (u) => u.lighten(20)), r["primary-color-deprecated-t-20"] = n(a, (u) => u.tint(20)), r["primary-color-deprecated-t-50"] = n(a, (u) => u.tint(50)), r["primary-color-deprecated-f-12"] = n(a, (u) => u.setAlpha(u.getAlpha() * 0.12));
    const l = new Jr(s[0]);
    r["primary-color-active-deprecated-f-30"] = n(l, (u) => u.setAlpha(u.getAlpha() * 0.3)), r["primary-color-active-deprecated-d-02"] = n(l, (u) => u.darken(2));
  }
  return t.successColor && i(t.successColor, "success"), t.warningColor && i(t.warningColor, "warning"), t.errorColor && i(t.errorColor, "error"), t.infoColor && i(t.infoColor, "info"), `
  :root {
    ${Object.keys(r).map((a) => `--${e}-${a}: ${r[a]};`).join(`
`)}
  }
  `.trim();
}
function ate(e, t) {
  const r = ote(e, t);
  Zn() ? Gs(r, `${ite}-dynamic-theme`) : process.env.NODE_ENV !== "production" && sf(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
const $c = /* @__PURE__ */ E.createContext(!1), ste = (e) => {
  let {
    children: t,
    disabled: r
  } = e;
  const n = E.useContext($c);
  return /* @__PURE__ */ E.createElement($c.Provider, {
    value: r ?? n
  }, t);
}, Bh = /* @__PURE__ */ E.createContext(void 0), lte = (e) => {
  let {
    children: t,
    size: r
  } = e;
  const n = E.useContext(Bh);
  return /* @__PURE__ */ E.createElement(Bh.Provider, {
    value: r || n
  }, t);
};
function ute() {
  const e = vr($c), t = vr(Bh);
  return {
    componentDisabled: e,
    componentSize: t
  };
}
const Ag = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"], cte = "5.19.0";
function tb(e) {
  return e >= 0 && e <= 255;
}
function fm(e, t) {
  const {
    r,
    g: n,
    b: i,
    a: o
  } = new Jr(e).toRgb();
  if (o < 1)
    return e;
  const {
    r: a,
    g: s,
    b: l
  } = new Jr(t).toRgb();
  for (let u = 0.01; u <= 1; u += 0.01) {
    const c = Math.round((r - a * (1 - u)) / u), d = Math.round((n - s * (1 - u)) / u), h = Math.round((i - l * (1 - u)) / u);
    if (tb(c) && tb(d) && tb(h))
      return new Jr({
        r: c,
        g: d,
        b: h,
        a: Math.round(u * 100) / 100
      }).toRgbString();
  }
  return new Jr({
    r,
    g: n,
    b: i,
    a: 1
  }).toRgbString();
}
var dte = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function Iz(e) {
  const {
    override: t
  } = e, r = dte(e, ["override"]), n = Object.assign({}, t);
  Object.keys(Dg).forEach((h) => {
    delete n[h];
  });
  const i = Object.assign(Object.assign({}, r), n), o = 480, a = 576, s = 768, l = 992, u = 1200, c = 1600;
  if (i.motion === !1) {
    const h = "0s";
    i.motionDurationFast = h, i.motionDurationMid = h, i.motionDurationSlow = h;
  }
  return Object.assign(Object.assign(Object.assign({}, i), {
    // ============== Background ============== //
    colorFillContent: i.colorFillSecondary,
    colorFillContentHover: i.colorFill,
    colorFillAlter: i.colorFillQuaternary,
    colorBgContainerDisabled: i.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: i.colorBgContainer,
    colorSplit: fm(i.colorBorderSecondary, i.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: i.colorTextQuaternary,
    colorTextDisabled: i.colorTextQuaternary,
    colorTextHeading: i.colorText,
    colorTextLabel: i.colorTextSecondary,
    colorTextDescription: i.colorTextTertiary,
    colorTextLightSolid: i.colorWhite,
    colorHighlight: i.colorError,
    colorBgTextHover: i.colorFillSecondary,
    colorBgTextActive: i.colorFill,
    colorIcon: i.colorTextTertiary,
    colorIconHover: i.colorText,
    colorErrorOutline: fm(i.colorErrorBg, i.colorBgContainer),
    colorWarningOutline: fm(i.colorWarningBg, i.colorBgContainer),
    // Font
    fontSizeIcon: i.fontSizeSM,
    // Line
    lineWidthFocus: i.lineWidth * 4,
    // Control
    lineWidth: i.lineWidth,
    controlOutlineWidth: i.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: i.controlHeight / 2,
    controlItemBgHover: i.colorFillTertiary,
    controlItemBgActive: i.colorPrimaryBg,
    controlItemBgActiveHover: i.colorPrimaryBgHover,
    controlItemBgActiveDisabled: i.colorFill,
    controlTmpOutline: i.colorFillQuaternary,
    controlOutline: fm(i.colorPrimaryBg, i.colorBgContainer),
    lineType: i.lineType,
    borderRadius: i.borderRadius,
    borderRadiusXS: i.borderRadiusXS,
    borderRadiusSM: i.borderRadiusSM,
    borderRadiusLG: i.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: i.sizeXXS,
    paddingXS: i.sizeXS,
    paddingSM: i.sizeSM,
    padding: i.size,
    paddingMD: i.sizeMD,
    paddingLG: i.sizeLG,
    paddingXL: i.sizeXL,
    paddingContentHorizontalLG: i.sizeLG,
    paddingContentVerticalLG: i.sizeMS,
    paddingContentHorizontal: i.sizeMS,
    paddingContentVertical: i.sizeSM,
    paddingContentHorizontalSM: i.size,
    paddingContentVerticalSM: i.sizeXS,
    marginXXS: i.sizeXXS,
    marginXS: i.sizeXS,
    marginSM: i.sizeSM,
    margin: i.size,
    marginMD: i.sizeMD,
    marginLG: i.sizeLG,
    marginXL: i.sizeXL,
    marginXXL: i.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS: o,
    screenXSMin: o,
    screenXSMax: a - 1,
    screenSM: a,
    screenSMMin: a,
    screenSMMax: s - 1,
    screenMD: s,
    screenMDMin: s,
    screenMDMax: l - 1,
    screenLG: l,
    screenLGMin: l,
    screenLGMax: u - 1,
    screenXL: u,
    screenXLMin: u,
    screenXLMax: c - 1,
    screenXXL: c,
    screenXXLMin: c,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new Jr("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new Jr("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new Jr("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), n);
}
var V2 = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Oz = {
  lineHeight: !0,
  lineHeightSM: !0,
  lineHeightLG: !0,
  lineHeightHeading1: !0,
  lineHeightHeading2: !0,
  lineHeightHeading3: !0,
  lineHeightHeading4: !0,
  lineHeightHeading5: !0,
  opacityLoading: !0,
  fontWeightStrong: !0,
  zIndexPopupBase: !0,
  zIndexBase: !0
}, Lz = {
  size: !0,
  sizeSM: !0,
  sizeLG: !0,
  sizeMD: !0,
  sizeXS: !0,
  sizeXXS: !0,
  sizeMS: !0,
  sizeXL: !0,
  sizeXXL: !0,
  sizeUnit: !0,
  sizeStep: !0,
  motionBase: !0,
  motionUnit: !0
}, hte = {
  screenXS: !0,
  screenXSMin: !0,
  screenXSMax: !0,
  screenSM: !0,
  screenSMMin: !0,
  screenSMMax: !0,
  screenMD: !0,
  screenMDMin: !0,
  screenMDMax: !0,
  screenLG: !0,
  screenLGMin: !0,
  screenLGMax: !0,
  screenXL: !0,
  screenXLMin: !0,
  screenXLMax: !0,
  screenXXL: !0,
  screenXXLMin: !0
}, Fz = (e, t, r) => {
  const n = r.getDerivativeToken(e), {
    override: i
  } = t, o = V2(t, ["override"]);
  let a = Object.assign(Object.assign({}, n), {
    override: i
  });
  return a = Iz(a), o && Object.entries(o).forEach((s) => {
    let [l, u] = s;
    const {
      theme: c
    } = u, d = V2(u, ["theme"]);
    let h = d;
    c && (h = Fz(Object.assign(Object.assign({}, a), d), {
      override: d
    }, c)), a[l] = h;
  }), a;
};
function Qi() {
  const {
    token: e,
    hashed: t,
    theme: r,
    override: n,
    cssVar: i
  } = H.useContext(Dz), o = `${cte}-${t || ""}`, a = r || Mz, [s, l, u] = UJ(a, [Dg, e], {
    salt: o,
    override: n,
    getComputedToken: Fz,
    // formatToken will not be consumed after 1.15.0 with getComputedToken.
    // But token will break if @ant-design/cssinjs is under 1.15.0 without it
    formatToken: Iz,
    cssVar: i && {
      prefix: i.prefix,
      key: i.key,
      unitless: Oz,
      ignore: Lz,
      preserve: hte
    }
  });
  return [a, u, t ? l : "", s, i];
}
function An(e) {
  var t = E.useRef();
  t.current = e;
  var r = E.useCallback(function() {
    for (var n, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return (n = t.current) === null || n === void 0 ? void 0 : n.call.apply(n, [t].concat(o));
  }, []);
  return r;
}
function $h(e) {
  var t = E.useRef(!1), r = E.useState(e), n = ae(r, 2), i = n[0], o = n[1];
  E.useEffect(function() {
    return t.current = !1, function() {
      t.current = !0;
    };
  }, []);
  function a(s, l) {
    l && t.current || o(s);
  }
  return [i, a];
}
function rb(e) {
  return e !== void 0;
}
function xn(e, t) {
  var r = t || {}, n = r.defaultValue, i = r.value, o = r.onChange, a = r.postState, s = $h(function() {
    return rb(i) ? i : rb(n) ? typeof n == "function" ? n() : n : typeof e == "function" ? e() : e;
  }), l = ae(s, 2), u = l[0], c = l[1], d = i !== void 0 ? i : u, h = a ? a(d) : d, f = An(o), p = $h([d]), g = ae(p, 2), v = g[0], m = g[1];
  JE(function() {
    var C = v[0];
    u !== C && f(u, C);
  }, [v]), JE(function() {
    rb(i) || c(i);
  }, [i]);
  var y = An(function(C, S) {
    c(C, S), m([d], S);
  });
  return [h, y];
}
const fte = 1e3 * 60 * 10;
let pte = /* @__PURE__ */ function() {
  function e() {
    Kn(this, e), this.map = /* @__PURE__ */ new Map(), this.objectIDMap = /* @__PURE__ */ new WeakMap(), this.nextID = 0, this.lastAccessBeat = /* @__PURE__ */ new Map(), this.accessBeat = 0;
  }
  return Yn(e, [{
    key: "set",
    value: function(r, n) {
      this.clear();
      const i = this.getCompositeKey(r);
      this.map.set(i, n), this.lastAccessBeat.set(i, Date.now());
    }
  }, {
    key: "get",
    value: function(r) {
      const n = this.getCompositeKey(r), i = this.map.get(n);
      return this.lastAccessBeat.set(n, Date.now()), this.accessBeat += 1, i;
    }
  }, {
    key: "getCompositeKey",
    value: function(r) {
      return r.map((i) => i && typeof i == "object" ? `obj_${this.getObjectID(i)}` : `${typeof i}_${i}`).join("|");
    }
  }, {
    key: "getObjectID",
    value: function(r) {
      if (this.objectIDMap.has(r))
        return this.objectIDMap.get(r);
      const n = this.nextID;
      return this.objectIDMap.set(r, n), this.nextID += 1, n;
    }
  }, {
    key: "clear",
    value: function() {
      if (this.accessBeat > 1e4) {
        const r = Date.now();
        this.lastAccessBeat.forEach((n, i) => {
          r - n > fte && (this.map.delete(i), this.lastAccessBeat.delete(i));
        }), this.accessBeat = 0;
      }
    }
  }]);
}();
const B2 = new pte();
function gte(e, t) {
  return H.useMemo(() => {
    const r = B2.get(t);
    if (r)
      return r;
    const n = e();
    return B2.set(t, n), n;
  }, t);
}
const Nz = (e) => ({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: e.colorLink,
  textDecoration: "none",
  outline: "none",
  cursor: "pointer",
  transition: `color ${e.motionDurationSlow}`,
  "&:focus, &:hover": {
    color: e.colorLinkHover
  },
  "&:active": {
    color: e.colorLinkActive
  }
}), Xl = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
}, Fi = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return {
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: e.colorText,
    fontSize: e.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: e.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: t ? "inherit" : e.fontFamily
  };
}, IP = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), mv = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), vte = (e) => ({
  a: {
    color: e.colorLink,
    textDecoration: e.linkDecoration,
    backgroundColor: "transparent",
    // remove the gray background on active links in IE 10.
    outline: "none",
    cursor: "pointer",
    transition: `color ${e.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    // remove gaps in links underline in iOS 8+ and Safari 8+.
    "&:hover": {
      color: e.colorLinkHover
    },
    "&:active": {
      color: e.colorLinkActive
    },
    "&:active, &:hover": {
      textDecoration: e.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: e.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: e.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), mte = (e, t, r, n) => {
  const i = `[class^="${t}"], [class*=" ${t}"]`, o = r ? `.${r}` : i, a = {
    boxSizing: "border-box",
    "&::before, &::after": {
      boxSizing: "border-box"
    }
  };
  let s = {};
  return n !== !1 && (s = {
    fontFamily: e.fontFamily,
    fontSize: e.fontSize
  }), {
    [o]: Object.assign(Object.assign(Object.assign({}, s), a), {
      [i]: a
    })
  };
}, yte = (e) => ({
  outline: `${de(e.lineWidthFocus)} solid ${e.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), pS = (e) => ({
  "&:focus-visible": Object.assign({}, yte(e))
});
function Cte(e) {
  return e === "js" ? {
    max: Math.max,
    min: Math.min
  } : {
    max: function() {
      for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
        r[n] = arguments[n];
      return `max(${r.map((i) => de(i)).join(",")})`;
    },
    min: function() {
      for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
        r[n] = arguments[n];
      return `min(${r.map((i) => de(i)).join(",")})`;
    }
  };
}
const kz = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u";
let hR = !0;
function Br() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  if (!kz)
    return Object.assign.apply(Object, [{}].concat(t));
  hR = !1;
  const n = {};
  return t.forEach((i) => {
    Object.keys(i).forEach((a) => {
      Object.defineProperty(n, a, {
        configurable: !0,
        enumerable: !0,
        get: () => i[a]
      });
    });
  }), hR = !0, n;
}
const $2 = {};
function Ste() {
}
const wte = (e) => {
  let t, r = e, n = Ste;
  return kz && typeof Proxy < "u" && (t = /* @__PURE__ */ new Set(), r = new Proxy(e, {
    get(i, o) {
      return hR && t.add(o), i[o];
    }
  }), n = (i, o) => {
    var a;
    $2[i] = {
      global: Array.from(t),
      component: Object.assign(Object.assign({}, (a = $2[i]) === null || a === void 0 ? void 0 : a.component), o)
    };
  }), {
    token: r,
    keys: t,
    flush: n
  };
}, Vz = (e, t) => {
  const [r, n] = Qi();
  return iR({
    theme: r,
    token: n,
    hashId: "",
    path: ["ant-design-icons", e],
    nonce: () => t == null ? void 0 : t.nonce,
    layer: {
      name: "antd"
    }
  }, () => [{
    [`.${e}`]: Object.assign(Object.assign({}, IP()), {
      [`.${e} .${e}-icon`]: {
        display: "block"
      }
    })
  }]);
}, Bz = (e, t, r) => {
  var n;
  return typeof r == "function" ? r(Br(t, (n = t[e]) !== null && n !== void 0 ? n : {})) : r ?? {};
}, $z = (e, t, r, n) => {
  const i = Object.assign({}, t[e]);
  if (n != null && n.deprecatedTokens) {
    const {
      deprecatedTokens: a
    } = n;
    a.forEach((s) => {
      let [l, u] = s;
      var c;
      process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && Qt(!(i != null && i[l]), `Component Token \`${String(l)}\` of ${e} is deprecated. Please use \`${String(u)}\` instead.`), (i != null && i[l] || i != null && i[u]) && ((c = i[u]) !== null && c !== void 0 || (i[u] = i == null ? void 0 : i[l]));
    });
  }
  const o = Object.assign(Object.assign({}, r), i);
  return Object.keys(o).forEach((a) => {
    o[a] === t[a] && delete o[a];
  }), o;
}, H2 = (e, t) => `${[t, e.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-")}`;
function OP(e, t, r) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const i = Array.isArray(e) ? e : [e, e], [o] = i, a = i.join("-");
  return function(s) {
    let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
    const [u, c, d, h, f] = Qi(), {
      getPrefixCls: p,
      iconPrefixCls: g,
      csp: v
    } = vr(Yt), m = p(), y = f ? "css" : "js", C = gte(() => {
      const R = /* @__PURE__ */ new Set();
      return f && Object.keys(n.unitless || {}).forEach((_) => {
        R.add(jy(_, f.prefix)), R.add(jy(_, H2(o, f.prefix)));
      }), bJ(y, R);
    }, [y, o, f == null ? void 0 : f.prefix]), {
      max: S,
      min: b
    } = Cte(y), w = {
      theme: u,
      token: h,
      hashId: d,
      nonce: () => v == null ? void 0 : v.nonce,
      clientOnly: n.clientOnly,
      layer: {
        name: "antd"
      },
      // antd is always at top of styles
      order: n.order || -999
    };
    return iR(Object.assign(Object.assign({}, w), {
      clientOnly: !1,
      path: ["Shared", m]
    }), () => [{
      // Link
      "&": vte(h)
    }]), Vz(g, v), [iR(Object.assign(Object.assign({}, w), {
      path: [a, s, g]
    }), () => {
      if (n.injectStyle === !1)
        return [];
      const {
        token: R,
        flush: _
      } = wte(h), T = Bz(o, c, r), P = `.${s}`, D = $z(o, c, T, {
        deprecatedTokens: n.deprecatedTokens
      });
      f && Object.keys(T).forEach((F) => {
        T[F] = `var(${jy(F, H2(o, f.prefix))})`;
      });
      const O = Br(R, {
        componentCls: P,
        prefixCls: s,
        iconCls: `.${g}`,
        antCls: `.${m}`,
        calc: C,
        // @ts-ignore
        max: S,
        // @ts-ignore
        min: b
      }, f ? T : D), A = t(O, {
        hashId: d,
        prefixCls: s,
        rootPrefixCls: m,
        iconPrefixCls: g
      });
      return _(o, D), [n.resetStyle === !1 ? null : mte(O, s, l, n.resetFont), A];
    }), d];
  };
}
const LP = (e, t, r, n) => {
  const i = OP(e, t, r, Object.assign({
    resetStyle: !1,
    // Sub Style should default after root one
    order: -998
  }, n)), o = (a) => {
    let {
      prefixCls: s,
      rootCls: l = s
    } = a;
    return i(s, l), null;
  };
  return process.env.NODE_ENV !== "production" && (o.displayName = `SubStyle_${Array.isArray(e) ? e.join(".") : e}`), o;
}, bte = (e, t, r) => {
  const {
    unitless: n,
    injectStyle: i = !0,
    prefixToken: o
  } = r, a = (l) => {
    let {
      rootCls: u,
      cssVar: c
    } = l;
    const [, d] = Qi();
    return wee({
      path: [e],
      prefix: c.prefix,
      key: c == null ? void 0 : c.key,
      unitless: n,
      ignore: Lz,
      token: d,
      scope: u
    }, () => {
      const h = Bz(e, d, t), f = $z(e, d, h, {
        deprecatedTokens: r == null ? void 0 : r.deprecatedTokens
      });
      return Object.keys(h).forEach((p) => {
        f[o(p)] = f[p], delete f[p];
      }), f;
    }), null;
  };
  return (l) => {
    const [, , , , u] = Qi();
    return [(c) => i && u ? /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(a, {
      rootCls: l,
      cssVar: u,
      component: e
    }), c) : c, u == null ? void 0 : u.key];
  };
}, Gn = (e, t, r, n) => {
  const i = Array.isArray(e) ? e[0] : e;
  function o(d) {
    return `${i}${d.slice(0, 1).toUpperCase()}${d.slice(1)}`;
  }
  const a = (n == null ? void 0 : n.unitless) || {}, s = Object.assign(Object.assign({}, Oz), {
    [o("zIndexPopup")]: !0
  });
  Object.keys(a).forEach((d) => {
    s[o(d)] = a[d];
  });
  const l = Object.assign(Object.assign({}, n), {
    unitless: s,
    prefixToken: o
  }), u = OP(e, t, r, l), c = bte(i, r, l);
  return function(d) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : d;
    const [, f] = u(d, h), [p, g] = c(h);
    return [p, f, g];
  };
};
function Hz(e, t) {
  return Ag.reduce((r, n) => {
    const i = e[`${n}1`], o = e[`${n}3`], a = e[`${n}6`], s = e[`${n}7`];
    return Object.assign(Object.assign({}, r), t(n, {
      lightColor: i,
      lightBorderColor: o,
      darkColor: a,
      textColor: s
    }));
  }, {});
}
const xte = Object.assign({}, E), {
  useId: G2
} = xte, Ete = () => "", Rte = typeof G2 > "u" ? Ete : G2;
function _te(e, t, r) {
  var n, i;
  const o = en("ConfigProvider"), a = e || {}, s = a.inherit === !1 || !t ? Object.assign(Object.assign({}, dR), {
    hashed: (n = t == null ? void 0 : t.hashed) !== null && n !== void 0 ? n : dR.hashed,
    cssVar: t == null ? void 0 : t.cssVar
  }) : t, l = Rte();
  if (process.env.NODE_ENV !== "production") {
    const u = a.cssVar || s.cssVar, c = !!(typeof a.cssVar == "object" && (!((i = a.cssVar) === null || i === void 0) && i.key) || l);
    process.env.NODE_ENV !== "production" && o(!u || c, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.");
  }
  return vv(() => {
    var u, c;
    if (!e)
      return t;
    const d = Object.assign({}, s.components);
    Object.keys(e.components || {}).forEach((p) => {
      d[p] = Object.assign(Object.assign({}, d[p]), e.components[p]);
    });
    const h = `css-var-${l.replace(/:/g, "")}`, f = ((u = a.cssVar) !== null && u !== void 0 ? u : s.cssVar) && Object.assign(Object.assign(Object.assign({
      prefix: r == null ? void 0 : r.prefixCls
    }, typeof s.cssVar == "object" ? s.cssVar : {}), typeof a.cssVar == "object" ? a.cssVar : {}), {
      key: typeof a.cssVar == "object" && ((c = a.cssVar) === null || c === void 0 ? void 0 : c.key) || h
    });
    return Object.assign(Object.assign(Object.assign({}, s), a), {
      token: Object.assign(Object.assign({}, s.token), a.token),
      components: d,
      cssVar: f
    });
  }, [a, s], (u, c) => u.some((d, h) => {
    const f = c[h];
    return !Nh(d, f, !0);
  }));
}
var Tte = ["children"], Gz = /* @__PURE__ */ E.createContext({});
function Pte(e) {
  var t = e.children, r = $t(e, Tte);
  return /* @__PURE__ */ E.createElement(Gz.Provider, {
    value: r
  }, t);
}
var Mte = /* @__PURE__ */ function(e) {
  hu(r, e);
  var t = fu(r);
  function r() {
    return Kn(this, r), t.apply(this, arguments);
  }
  return Yn(r, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), r;
}(E.Component);
function Dte(e) {
  var t = E.useReducer(function(s) {
    return s + 1;
  }, 0), r = ae(t, 2), n = r[1], i = E.useRef(e), o = An(function() {
    return i.current;
  }), a = An(function(s) {
    i.current = typeof s == "function" ? s(i.current) : s, n();
  });
  return [o, a];
}
var Rl = "none", pm = "appear", gm = "enter", vm = "leave", z2 = "none", Ca = "prepare", ch = "start", dh = "active", FP = "end", zz = "prepared";
function W2(e, t) {
  var r = {};
  return r[e.toLowerCase()] = t.toLowerCase(), r["Webkit".concat(e)] = "webkit".concat(t), r["Moz".concat(e)] = "moz".concat(t), r["ms".concat(e)] = "MS".concat(t), r["O".concat(e)] = "o".concat(t.toLowerCase()), r;
}
function Ate(e, t) {
  var r = {
    animationend: W2("Animation", "AnimationEnd"),
    transitionend: W2("Transition", "TransitionEnd")
  };
  return e && ("AnimationEvent" in t || delete r.animationend.animation, "TransitionEvent" in t || delete r.transitionend.transition), r;
}
var Ite = Ate(Zn(), typeof window < "u" ? window : {}), Wz = {};
if (Zn()) {
  var Ote = document.createElement("div");
  Wz = Ote.style;
}
var mm = {};
function jz(e) {
  if (mm[e])
    return mm[e];
  var t = Ite[e];
  if (t)
    for (var r = Object.keys(t), n = r.length, i = 0; i < n; i += 1) {
      var o = r[i];
      if (Object.prototype.hasOwnProperty.call(t, o) && o in Wz)
        return mm[e] = t[o], mm[e];
    }
  return "";
}
var Uz = jz("animationend"), Kz = jz("transitionend"), Yz = !!(Uz && Kz), j2 = Uz || "animationend", U2 = Kz || "transitionend";
function K2(e, t) {
  if (!e) return null;
  if (vt(e) === "object") {
    var r = t.replace(/-\w/g, function(n) {
      return n[1].toUpperCase();
    });
    return e[r];
  }
  return "".concat(e, "-").concat(t);
}
const Lte = function(e) {
  var t = se();
  function r(i) {
    i && (i.removeEventListener(U2, e), i.removeEventListener(j2, e));
  }
  function n(i) {
    t.current && t.current !== i && r(t.current), i && i !== t.current && (i.addEventListener(U2, e), i.addEventListener(j2, e), t.current = i);
  }
  return E.useEffect(function() {
    return function() {
      r(t.current);
    };
  }, []), [n, r];
};
var qz = Zn() ? as : Nt;
const Fte = function() {
  var e = E.useRef(null);
  function t() {
    Ar.cancel(e.current);
  }
  function r(n) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    t();
    var o = Ar(function() {
      i <= 1 ? n({
        isCanceled: function() {
          return o !== e.current;
        }
      }) : r(n, i - 1);
    });
    e.current = o;
  }
  return E.useEffect(function() {
    return function() {
      t();
    };
  }, []), [r, t];
};
var Nte = [Ca, ch, dh, FP], kte = [Ca, zz], Xz = !1, Vte = !0;
function Zz(e) {
  return e === dh || e === FP;
}
const Bte = function(e, t, r) {
  var n = $h(z2), i = ae(n, 2), o = i[0], a = i[1], s = Fte(), l = ae(s, 2), u = l[0], c = l[1];
  function d() {
    a(Ca, !0);
  }
  var h = t ? kte : Nte;
  return qz(function() {
    if (o !== z2 && o !== FP) {
      var f = h.indexOf(o), p = h[f + 1], g = r(o);
      g === Xz ? a(p, !0) : p && u(function(v) {
        function m() {
          v.isCanceled() || a(p, !0);
        }
        g === !0 ? m() : Promise.resolve(g).then(m);
      });
    }
  }, [e, o]), E.useEffect(function() {
    return function() {
      c();
    };
  }, []), [d, o];
};
function $te(e, t, r, n) {
  var i = n.motionEnter, o = i === void 0 ? !0 : i, a = n.motionAppear, s = a === void 0 ? !0 : a, l = n.motionLeave, u = l === void 0 ? !0 : l, c = n.motionDeadline, d = n.motionLeaveImmediately, h = n.onAppearPrepare, f = n.onEnterPrepare, p = n.onLeavePrepare, g = n.onAppearStart, v = n.onEnterStart, m = n.onLeaveStart, y = n.onAppearActive, C = n.onEnterActive, S = n.onLeaveActive, b = n.onAppearEnd, w = n.onEnterEnd, x = n.onLeaveEnd, R = n.onVisibleChanged, _ = $h(), T = ae(_, 2), P = T[0], D = T[1], O = Dte(Rl), A = ae(O, 2), F = A[0], L = A[1], N = $h(null), I = ae(N, 2), B = I[0], M = I[1], V = F(), G = se(!1), k = se(null);
  function z() {
    return r();
  }
  var j = se(!1);
  function q() {
    L(Rl), M(null, !0);
  }
  var K = An(function(xe) {
    var _e = F();
    if (_e !== Rl) {
      var Ve = z();
      if (!(xe && !xe.deadline && xe.target !== Ve)) {
        var Fe = j.current, Ne;
        _e === pm && Fe ? Ne = b == null ? void 0 : b(Ve, xe) : _e === gm && Fe ? Ne = w == null ? void 0 : w(Ve, xe) : _e === vm && Fe && (Ne = x == null ? void 0 : x(Ve, xe)), Fe && Ne !== !1 && q();
      }
    }
  }), Z = Lte(K), re = ae(Z, 1), X = re[0], Y = function(_e) {
    switch (_e) {
      case pm:
        return te(te(te({}, Ca, h), ch, g), dh, y);
      case gm:
        return te(te(te({}, Ca, f), ch, v), dh, C);
      case vm:
        return te(te(te({}, Ca, p), ch, m), dh, S);
      default:
        return {};
    }
  }, U = E.useMemo(function() {
    return Y(V);
  }, [V]), oe = Bte(V, !e, function(xe) {
    if (xe === Ca) {
      var _e = U[Ca];
      return _e ? _e(z()) : Xz;
    }
    if (ce in U) {
      var Ve;
      M(((Ve = U[ce]) === null || Ve === void 0 ? void 0 : Ve.call(U, z(), null)) || null);
    }
    return ce === dh && V !== Rl && (X(z()), c > 0 && (clearTimeout(k.current), k.current = setTimeout(function() {
      K({
        deadline: !0
      });
    }, c))), ce === zz && q(), Vte;
  }), W = ae(oe, 2), ne = W[0], ce = W[1], we = Zz(ce);
  j.current = we, qz(function() {
    D(t);
    var xe = G.current;
    G.current = !0;
    var _e;
    !xe && t && s && (_e = pm), xe && t && o && (_e = gm), (xe && !t && u || !xe && d && !t && u) && (_e = vm);
    var Ve = Y(_e);
    _e && (e || Ve[Ca]) ? (L(_e), ne()) : L(Rl);
  }, [t]), Nt(function() {
    // Cancel appear
    (V === pm && !s || // Cancel enter
    V === gm && !o || // Cancel leave
    V === vm && !u) && L(Rl);
  }, [s, o, u]), Nt(function() {
    return function() {
      G.current = !1, clearTimeout(k.current);
    };
  }, []);
  var Re = E.useRef(!1);
  Nt(function() {
    P && (Re.current = !0), P !== void 0 && V === Rl && ((Re.current || P) && (R == null || R(P)), Re.current = !0);
  }, [P, V]);
  var ve = B;
  return U[Ca] && ce === ch && (ve = ee({
    transition: "none"
  }, ve)), [V, ce, ve, P ?? t];
}
function Hte(e) {
  var t = e;
  vt(e) === "object" && (t = e.transitionSupport);
  function r(i, o) {
    return !!(i.motionName && t && o !== !1);
  }
  var n = /* @__PURE__ */ E.forwardRef(function(i, o) {
    var a = i.visible, s = a === void 0 ? !0 : a, l = i.removeOnLeave, u = l === void 0 ? !0 : l, c = i.forceRender, d = i.children, h = i.motionName, f = i.leavedClassName, p = i.eventProps, g = E.useContext(Gz), v = g.motion, m = r(i, v), y = se(), C = se();
    function S() {
      try {
        return y.current instanceof HTMLElement ? y.current : Kp(C.current);
      } catch {
        return null;
      }
    }
    var b = $te(m, s, S, i), w = ae(b, 4), x = w[0], R = w[1], _ = w[2], T = w[3], P = E.useRef(T);
    T && (P.current = !0);
    var D = E.useCallback(function(B) {
      y.current = B, wP(o, B);
    }, [o]), O, A = ee(ee({}, p), {}, {
      visible: s
    });
    if (!d)
      O = null;
    else if (x === Rl)
      T ? O = d(ee({}, A), D) : !u && P.current && f ? O = d(ee(ee({}, A), {}, {
        className: f
      }), D) : c || !u && !f ? O = d(ee(ee({}, A), {}, {
        style: {
          display: "none"
        }
      }), D) : O = null;
    else {
      var F;
      R === Ca ? F = "prepare" : Zz(R) ? F = "active" : R === ch && (F = "start");
      var L = K2(h, "".concat(x, "-").concat(F));
      O = d(ee(ee({}, A), {}, {
        className: ue(K2(h, x), te(te({}, L, L && F), h, typeof h == "string")),
        style: _
      }), D);
    }
    if (/* @__PURE__ */ E.isValidElement(O) && Jc(O)) {
      var N = O, I = N.ref;
      I || (O = /* @__PURE__ */ E.cloneElement(O, {
        ref: D
      }));
    }
    return /* @__PURE__ */ E.createElement(Mte, {
      ref: C
    }, O);
  });
  return n.displayName = "CSSMotion", n;
}
const Cs = Hte(Yz);
var fR = "add", pR = "keep", gR = "remove", nb = "removed";
function Gte(e) {
  var t;
  return e && vt(e) === "object" && "key" in e ? t = e : t = {
    key: e
  }, ee(ee({}, t), {}, {
    key: String(t.key)
  });
}
function vR() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return e.map(Gte);
}
function zte() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = [], n = 0, i = t.length, o = vR(e), a = vR(t);
  o.forEach(function(u) {
    for (var c = !1, d = n; d < i; d += 1) {
      var h = a[d];
      if (h.key === u.key) {
        n < d && (r = r.concat(a.slice(n, d).map(function(f) {
          return ee(ee({}, f), {}, {
            status: fR
          });
        })), n = d), r.push(ee(ee({}, h), {}, {
          status: pR
        })), n += 1, c = !0;
        break;
      }
    }
    c || r.push(ee(ee({}, u), {}, {
      status: gR
    }));
  }), n < i && (r = r.concat(a.slice(n).map(function(u) {
    return ee(ee({}, u), {}, {
      status: fR
    });
  })));
  var s = {};
  r.forEach(function(u) {
    var c = u.key;
    s[c] = (s[c] || 0) + 1;
  });
  var l = Object.keys(s).filter(function(u) {
    return s[u] > 1;
  });
  return l.forEach(function(u) {
    r = r.filter(function(c) {
      var d = c.key, h = c.status;
      return d !== u || h !== gR;
    }), r.forEach(function(c) {
      c.key === u && (c.status = pR);
    });
  }), r;
}
var Wte = ["component", "children", "onVisibleChanged", "onAllRemoved"], jte = ["status"], Ute = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function Kte(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Cs, r = /* @__PURE__ */ function(n) {
    hu(o, n);
    var i = fu(o);
    function o() {
      var a;
      Kn(this, o);
      for (var s = arguments.length, l = new Array(s), u = 0; u < s; u++)
        l[u] = arguments[u];
      return a = i.call.apply(i, [this].concat(l)), te(cr(a), "state", {
        keyEntities: []
      }), te(cr(a), "removeKey", function(c) {
        var d = a.state.keyEntities, h = d.map(function(f) {
          return f.key !== c ? f : ee(ee({}, f), {}, {
            status: nb
          });
        });
        return a.setState({
          keyEntities: h
        }), h.filter(function(f) {
          var p = f.status;
          return p !== nb;
        }).length;
      }), a;
    }
    return Yn(o, [{
      key: "render",
      value: function() {
        var s = this, l = this.state.keyEntities, u = this.props, c = u.component, d = u.children, h = u.onVisibleChanged, f = u.onAllRemoved, p = $t(u, Wte), g = c || E.Fragment, v = {};
        return Ute.forEach(function(m) {
          v[m] = p[m], delete p[m];
        }), delete p.keys, /* @__PURE__ */ E.createElement(g, p, l.map(function(m, y) {
          var C = m.status, S = $t(m, jte), b = C === fR || C === pR;
          return /* @__PURE__ */ E.createElement(t, $e({}, v, {
            key: S.key,
            visible: b,
            eventProps: S,
            onVisibleChanged: function(x) {
              if (h == null || h(x, {
                key: S.key
              }), !x) {
                var R = s.removeKey(S.key);
                R === 0 && f && f();
              }
            }
          }), function(w, x) {
            return d(ee(ee({}, w), {}, {
              index: y
            }), x);
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(s, l) {
        var u = s.keys, c = l.keyEntities, d = vR(u), h = zte(c, d);
        return {
          keyEntities: h.filter(function(f) {
            var p = c.find(function(g) {
              var v = g.key;
              return f.key === v;
            });
            return !(p && p.status === nb && f.status === gR);
          })
        };
      }
    }]), o;
  }(E.Component);
  return te(r, "defaultProps", {
    component: "div"
  }), r;
}
Kte(Yz);
function Yte(e) {
  const {
    children: t
  } = e, [, r] = Qi(), {
    motion: n
  } = r, i = E.useRef(!1);
  return i.current = i.current || n === !1, i.current ? /* @__PURE__ */ E.createElement(Pte, {
    motion: n
  }, t) : t;
}
const Qz = /* @__PURE__ */ E.memo((e) => {
  let {
    dropdownMatchSelectWidth: t
  } = e;
  return en("ConfigProvider").deprecated(t === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), null;
});
process.env.NODE_ENV !== "production" && (Qz.displayName = "PropWarning");
const qte = process.env.NODE_ENV !== "production" ? Qz : () => null;
var Xte = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
let mR = !1;
process.env.NODE_ENV;
const Zte = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"], Jz = "ant";
let e5;
function Qte() {
  return e5 || Jz;
}
function Jte(e) {
  return Object.keys(e).some((t) => t.endsWith("Color"));
}
const ere = (e) => {
  const {
    prefixCls: t,
    iconPrefixCls: r,
    theme: n,
    holderRender: i
  } = e;
  t !== void 0 && (e5 = t), n && Jte(n) && (process.env.NODE_ENV !== "production" && sf(!1, "ConfigProvider", "`config` of css variable theme is not work in v5. Please use new `theme` config instead."), ate(Qte(), n));
}, tre = (e) => {
  const {
    children: t,
    csp: r,
    autoInsertSpaceInButton: n,
    alert: i,
    anchor: o,
    form: a,
    locale: s,
    componentSize: l,
    direction: u,
    space: c,
    virtual: d,
    dropdownMatchSelectWidth: h,
    popupMatchSelectWidth: f,
    popupOverflow: p,
    legacyLocale: g,
    parentContext: v,
    iconPrefixCls: m,
    theme: y,
    componentDisabled: C,
    segmented: S,
    statistic: b,
    spin: w,
    calendar: x,
    carousel: R,
    cascader: _,
    collapse: T,
    typography: P,
    checkbox: D,
    descriptions: O,
    divider: A,
    drawer: F,
    skeleton: L,
    steps: N,
    image: I,
    layout: B,
    list: M,
    mentions: V,
    modal: G,
    progress: k,
    result: z,
    slider: j,
    breadcrumb: q,
    menu: K,
    pagination: Z,
    input: re,
    textArea: X,
    empty: Y,
    badge: U,
    radio: oe,
    rate: W,
    switch: ne,
    transfer: ce,
    avatar: we,
    message: Re,
    tag: ve,
    table: xe,
    card: _e,
    tabs: Ve,
    timeline: Fe,
    timePicker: Ne,
    upload: Je,
    notification: J,
    tree: he,
    colorPicker: Le,
    datePicker: Pe,
    rangePicker: Ie,
    flex: Ce,
    wave: De,
    dropdown: ze,
    warning: st,
    tour: Tt,
    floatButtonGroup: ot,
    variant: Xe,
    inputNumber: Oe,
    treeSelect: Qe
  } = e, ft = E.useCallback((Ge, Ze) => {
    const {
      prefixCls: tt
    } = e;
    if (Ze)
      return Ze;
    const ht = tt || v.getPrefixCls("");
    return Ge ? `${ht}-${Ge}` : ht;
  }, [v.getPrefixCls, e.prefixCls]), xt = m || v.iconPrefixCls || Az, $r = r || v.csp;
  Vz(xt, $r);
  const hr = _te(y, v.theme, {
    prefixCls: ft("")
  });
  process.env.NODE_ENV !== "production" && (mR = mR || !!hr);
  const Gt = {
    csp: $r,
    autoInsertSpaceInButton: n,
    alert: i,
    anchor: o,
    locale: s || g,
    direction: u,
    space: c,
    virtual: d,
    popupMatchSelectWidth: f ?? h,
    popupOverflow: p,
    getPrefixCls: ft,
    iconPrefixCls: xt,
    theme: hr,
    segmented: S,
    statistic: b,
    spin: w,
    calendar: x,
    carousel: R,
    cascader: _,
    collapse: T,
    typography: P,
    checkbox: D,
    descriptions: O,
    divider: A,
    drawer: F,
    skeleton: L,
    steps: N,
    image: I,
    input: re,
    textArea: X,
    layout: B,
    list: M,
    mentions: V,
    modal: G,
    progress: k,
    result: z,
    slider: j,
    breadcrumb: q,
    menu: K,
    pagination: Z,
    empty: Y,
    badge: U,
    radio: oe,
    rate: W,
    switch: ne,
    transfer: ce,
    avatar: we,
    message: Re,
    tag: ve,
    table: xe,
    card: _e,
    tabs: Ve,
    timeline: Fe,
    timePicker: Ne,
    upload: Je,
    notification: J,
    tree: he,
    colorPicker: Le,
    datePicker: Pe,
    rangePicker: Ie,
    flex: Ce,
    wave: De,
    dropdown: ze,
    warning: st,
    tour: Tt,
    floatButtonGroup: ot,
    variant: Xe,
    inputNumber: Oe,
    treeSelect: Qe
  };
  process.env.NODE_ENV !== "production" && en("ConfigProvider")(!("autoInsertSpaceInButton" in e), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
  const Ot = Object.assign({}, v);
  Object.keys(Gt).forEach((Ge) => {
    Gt[Ge] !== void 0 && (Ot[Ge] = Gt[Ge]);
  }), Zte.forEach((Ge) => {
    const Ze = e[Ge];
    Ze && (Ot[Ge] = Ze);
  }), typeof n < "u" && (Ot.button = Object.assign({
    autoInsertSpace: n
  }, Ot.button));
  const Lt = vv(() => Ot, Ot, (Ge, Ze) => {
    const tt = Object.keys(Ge), ht = Object.keys(Ze);
    return tt.length !== ht.length || tt.some((It) => Ge[It] !== Ze[It]);
  }), mt = E.useMemo(() => ({
    prefixCls: xt,
    csp: $r
  }), [xt, $r]);
  let qe = /* @__PURE__ */ E.createElement(E.Fragment, null, /* @__PURE__ */ E.createElement(qte, {
    dropdownMatchSelectWidth: h
  }), t);
  const zt = E.useMemo(() => {
    var Ge, Ze, tt, ht;
    return uh(((Ge = Ys.Form) === null || Ge === void 0 ? void 0 : Ge.defaultValidateMessages) || {}, ((tt = (Ze = Lt.locale) === null || Ze === void 0 ? void 0 : Ze.Form) === null || tt === void 0 ? void 0 : tt.defaultValidateMessages) || {}, ((ht = Lt.form) === null || ht === void 0 ? void 0 : ht.validateMessages) || {}, (a == null ? void 0 : a.validateMessages) || {});
  }, [Lt, a == null ? void 0 : a.validateMessages]);
  Object.keys(zt).length > 0 && (qe = /* @__PURE__ */ E.createElement(_ee.Provider, {
    value: zt
  }, qe)), s && (qe = /* @__PURE__ */ E.createElement(Ez, {
    locale: s,
    _ANT_MARK__: xz
  }, qe)), (xt || $r) && (qe = /* @__PURE__ */ E.createElement(MP.Provider, {
    value: mt
  }, qe)), l && (qe = /* @__PURE__ */ E.createElement(lte, {
    size: l
  }, qe)), qe = /* @__PURE__ */ E.createElement(Yte, null, qe);
  const fr = E.useMemo(() => {
    const Ge = hr || {}, {
      algorithm: Ze,
      token: tt,
      components: ht,
      cssVar: It
    } = Ge, qt = Xte(Ge, ["algorithm", "token", "components", "cssVar"]), Hr = Ze && (!Array.isArray(Ze) || Ze.length > 0) ? ZE(Ze) : Mz, Q = {};
    Object.entries(ht || {}).forEach((me) => {
      let [Ue, pt] = me;
      const gt = Object.assign({}, pt);
      "algorithm" in gt && (gt.algorithm === !0 ? gt.theme = Hr : (Array.isArray(gt.algorithm) || typeof gt.algorithm == "function") && (gt.theme = ZE(gt.algorithm)), delete gt.algorithm), Q[Ue] = gt;
    });
    const ye = Object.assign(Object.assign({}, Dg), tt);
    return Object.assign(Object.assign({}, qt), {
      theme: Hr,
      token: ye,
      components: Q,
      override: Object.assign({
        override: ye
      }, Q),
      cssVar: It
    });
  }, [hr]);
  return y && (qe = /* @__PURE__ */ E.createElement(Dz.Provider, {
    value: fr
  }, qe)), Lt.warning && (qe = /* @__PURE__ */ E.createElement(wz.Provider, {
    value: Lt.warning
  }, qe)), C !== void 0 && (qe = /* @__PURE__ */ E.createElement(ste, {
    disabled: C
  }, qe)), /* @__PURE__ */ E.createElement(Yt.Provider, {
    value: Lt
  }, qe);
}, pu = (e) => {
  const t = E.useContext(Yt), r = E.useContext(DP);
  return /* @__PURE__ */ E.createElement(tre, Object.assign({
    parentContext: t,
    legacyLocale: r
  }, e));
};
pu.ConfigContext = Yt;
pu.SizeContext = Bh;
pu.config = ere;
pu.useConfig = ute;
Object.defineProperty(pu, "SizeContext", {
  get: () => (process.env.NODE_ENV !== "production" && sf(!1, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead."), Bh)
});
process.env.NODE_ENV !== "production" && (pu.displayName = "ConfigProvider");
var rre = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, name: "check-circle", theme: "filled" };
function t5(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
}
function nre(e) {
  return t5(e) instanceof ShadowRoot;
}
function I0(e) {
  return nre(e) ? t5(e) : null;
}
function ire(e) {
  return e.replace(/-(.)/g, function(t, r) {
    return r.toUpperCase();
  });
}
function ore(e, t) {
  Qt(e, "[@ant-design/icons] ".concat(t));
}
function Y2(e) {
  return vt(e) === "object" && typeof e.name == "string" && typeof e.theme == "string" && (vt(e.icon) === "object" || typeof e.icon == "function");
}
function q2() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(e).reduce(function(t, r) {
    var n = e[r];
    switch (r) {
      case "class":
        t.className = n, delete t.class;
        break;
      default:
        delete t[r], t[ire(r)] = n;
    }
    return t;
  }, {});
}
function yR(e, t, r) {
  return r ? /* @__PURE__ */ H.createElement(e.tag, ee(ee({
    key: t
  }, q2(e.attrs)), r), (e.children || []).map(function(n, i) {
    return yR(n, "".concat(t, "-").concat(e.tag, "-").concat(i));
  })) : /* @__PURE__ */ H.createElement(e.tag, ee({
    key: t
  }, q2(e.attrs)), (e.children || []).map(function(n, i) {
    return yR(n, "".concat(t, "-").concat(e.tag, "-").concat(i));
  }));
}
function r5(e) {
  return Mg(e)[0];
}
function n5(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
var are = `
.anticon {
  display: inline-flex;
  align-items: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`, sre = function(t) {
  var r = vr(MP), n = r.csp, i = r.prefixCls, o = are;
  i && (o = o.replace(/anticon/g, i)), Nt(function() {
    var a = t.current, s = I0(a);
    Gs(o, "@ant-design-icons", {
      prepend: !0,
      csp: n,
      attachTo: s
    });
  }, []);
}, lre = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"], qp = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
};
function ure(e) {
  var t = e.primaryColor, r = e.secondaryColor;
  qp.primaryColor = t, qp.secondaryColor = r || r5(t), qp.calculated = !!r;
}
function cre() {
  return ee({}, qp);
}
var lf = function(t) {
  var r = t.icon, n = t.className, i = t.onClick, o = t.style, a = t.primaryColor, s = t.secondaryColor, l = $t(t, lre), u = E.useRef(), c = qp;
  if (a && (c = {
    primaryColor: a,
    secondaryColor: s || r5(a)
  }), sre(u), ore(Y2(r), "icon should be icon definiton, but got ".concat(r)), !Y2(r))
    return null;
  var d = r;
  return d && typeof d.icon == "function" && (d = ee(ee({}, d), {}, {
    icon: d.icon(c.primaryColor, c.secondaryColor)
  })), yR(d.icon, "svg-".concat(d.name), ee(ee({
    className: n,
    onClick: i,
    style: o,
    "data-icon": d.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, l), {}, {
    ref: u
  }));
};
lf.displayName = "IconReact";
lf.getTwoToneColors = cre;
lf.setTwoToneColors = ure;
function i5(e) {
  var t = n5(e), r = ae(t, 2), n = r[0], i = r[1];
  return lf.setTwoToneColors({
    primaryColor: n,
    secondaryColor: i
  });
}
function dre() {
  var e = lf.getTwoToneColors();
  return e.calculated ? [e.primaryColor, e.secondaryColor] : e.primaryColor;
}
var hre = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
i5(cR.primary);
var rn = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.className, n = e.icon, i = e.spin, o = e.rotate, a = e.tabIndex, s = e.onClick, l = e.twoToneColor, u = $t(e, hre), c = E.useContext(MP), d = c.prefixCls, h = d === void 0 ? "anticon" : d, f = c.rootClassName, p = ue(f, h, te(te({}, "".concat(h, "-").concat(n.name), !!n.name), "".concat(h, "-spin"), !!i || n.name === "loading"), r), g = a;
  g === void 0 && s && (g = -1);
  var v = o ? {
    msTransform: "rotate(".concat(o, "deg)"),
    transform: "rotate(".concat(o, "deg)")
  } : void 0, m = n5(l), y = ae(m, 2), C = y[0], S = y[1];
  return /* @__PURE__ */ E.createElement("span", $e({
    role: "img",
    "aria-label": n.name
  }, u, {
    ref: t,
    tabIndex: g,
    onClick: s,
    className: p
  }), /* @__PURE__ */ E.createElement(lf, {
    icon: n,
    primaryColor: C,
    secondaryColor: S,
    style: v
  }));
});
rn.displayName = "AntdIcon";
rn.getTwoToneColor = dre;
rn.setTwoToneColor = i5;
var fre = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: rre
  }));
}, o5 = /* @__PURE__ */ E.forwardRef(fre);
process.env.NODE_ENV !== "production" && (o5.displayName = "CheckCircleFilled");
var pre = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" }, gre = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: pre
  }));
}, gS = /* @__PURE__ */ E.forwardRef(gre);
process.env.NODE_ENV !== "production" && (gS.displayName = "CloseCircleFilled");
var vre = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" }, mre = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: vre
  }));
}, uf = /* @__PURE__ */ E.forwardRef(mre);
process.env.NODE_ENV !== "production" && (uf.displayName = "CloseOutlined");
var yre = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "exclamation-circle", theme: "filled" }, Cre = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: yre
  }));
}, NP = /* @__PURE__ */ E.forwardRef(Cre);
process.env.NODE_ENV !== "production" && (NP.displayName = "ExclamationCircleFilled");
var Sre = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`, wre = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`, bre = "".concat(Sre, " ").concat(wre).split(/[\s\n]+/), xre = "aria-", Ere = "data-";
function X2(e, t) {
  return e.indexOf(t) === 0;
}
function Zl(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r;
  t === !1 ? r = {
    aria: !0,
    data: !0,
    attr: !0
  } : t === !0 ? r = {
    aria: !0
  } : r = ee({}, t);
  var n = {};
  return Object.keys(e).forEach(function(i) {
    // Aria
    (r.aria && (i === "role" || X2(i, xre)) || // Data
    r.data && X2(i, Ere) || // Attr
    r.attr && bre.includes(i)) && (n[i] = e[i]);
  }), n;
}
function a5(e) {
  return e && /* @__PURE__ */ H.isValidElement(e) && e.type === H.Fragment;
}
const s5 = (e, t, r) => /* @__PURE__ */ H.isValidElement(e) ? /* @__PURE__ */ H.cloneElement(e, typeof r == "function" ? r(e.props || {}) : r) : t;
function Hc(e, t) {
  return s5(e, e, t);
}
const ed = (e) => {
  const [, , , , t] = Qi();
  return t ? `${e}-css-var` : "";
};
var Ae = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function(t) {
    var r = t.keyCode;
    if (t.altKey && !t.ctrlKey || t.metaKey || // Function keys don't generate text
    r >= Ae.F1 && r <= Ae.F12)
      return !1;
    switch (r) {
      case Ae.ALT:
      case Ae.CAPS_LOCK:
      case Ae.CONTEXT_MENU:
      case Ae.CTRL:
      case Ae.DOWN:
      case Ae.END:
      case Ae.ESC:
      case Ae.HOME:
      case Ae.INSERT:
      case Ae.LEFT:
      case Ae.MAC_FF_META:
      case Ae.META:
      case Ae.NUMLOCK:
      case Ae.NUM_CENTER:
      case Ae.PAGE_DOWN:
      case Ae.PAGE_UP:
      case Ae.PAUSE:
      case Ae.PRINT_SCREEN:
      case Ae.RIGHT:
      case Ae.SHIFT:
      case Ae.UP:
      case Ae.WIN_KEY:
      case Ae.WIN_KEY_RIGHT:
        return !1;
      default:
        return !0;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function(t) {
    if (t >= Ae.ZERO && t <= Ae.NINE || t >= Ae.NUM_ZERO && t <= Ae.NUM_MULTIPLY || t >= Ae.A && t <= Ae.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && t === 0)
      return !0;
    switch (t) {
      case Ae.SPACE:
      case Ae.QUESTION_MARK:
      case Ae.NUM_PLUS:
      case Ae.NUM_MINUS:
      case Ae.NUM_PERIOD:
      case Ae.NUM_DIVISION:
      case Ae.SEMICOLON:
      case Ae.DASH:
      case Ae.EQUALS:
      case Ae.COMMA:
      case Ae.PERIOD:
      case Ae.SLASH:
      case Ae.APOSTROPHE:
      case Ae.SINGLE_QUOTE:
      case Ae.OPEN_SQUARE_BRACKET:
      case Ae.BACKSLASH:
      case Ae.CLOSE_SQUARE_BRACKET:
        return !0;
      default:
        return !1;
    }
  }
}, Rre = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" }, _re = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: Rre
  }));
}, vS = /* @__PURE__ */ E.forwardRef(_re);
process.env.NODE_ENV !== "production" && (vS.displayName = "LoadingOutlined");
const kP = /* @__PURE__ */ H.createContext(void 0);
process.env.NODE_ENV !== "production" && (kP.displayName = "zIndexContext");
const Xu = 100, Tre = 10, Pre = Xu * Tre, l5 = {
  Modal: Xu,
  Drawer: Xu,
  Popover: Xu,
  Popconfirm: Xu,
  Tooltip: Xu,
  Tour: Xu
}, Mre = {
  SelectLike: 50,
  Dropdown: 50,
  DatePicker: 50,
  Menu: 50,
  ImagePreview: 1
};
function Dre(e) {
  return e in l5;
}
function mS(e, t) {
  const [, r] = Qi(), n = H.useContext(kP), i = Dre(e);
  if (t !== void 0)
    return [t, t];
  let o = n ?? 0;
  return i ? (o += // Use preset token zIndex by default but not stack when has parent container
  (n ? 0 : r.zIndexPopupBase) + // Container offset
  l5[e], o = Math.min(o, r.zIndexPopupBase + Pre)) : o += Mre[e], [n === void 0 ? t : o, o];
}
function Di() {
  Di = function() {
    return t;
  };
  var e, t = {}, r = Object.prototype, n = r.hasOwnProperty, i = Object.defineProperty || function(L, N, I) {
    L[N] = I.value;
  }, o = typeof Symbol == "function" ? Symbol : {}, a = o.iterator || "@@iterator", s = o.asyncIterator || "@@asyncIterator", l = o.toStringTag || "@@toStringTag";
  function u(L, N, I) {
    return Object.defineProperty(L, N, {
      value: I,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), L[N];
  }
  try {
    u({}, "");
  } catch {
    u = function(I, B, M) {
      return I[B] = M;
    };
  }
  function c(L, N, I, B) {
    var M = N && N.prototype instanceof m ? N : m, V = Object.create(M.prototype), G = new A(B || []);
    return i(V, "_invoke", {
      value: T(L, I, G)
    }), V;
  }
  function d(L, N, I) {
    try {
      return {
        type: "normal",
        arg: L.call(N, I)
      };
    } catch (B) {
      return {
        type: "throw",
        arg: B
      };
    }
  }
  t.wrap = c;
  var h = "suspendedStart", f = "suspendedYield", p = "executing", g = "completed", v = {};
  function m() {
  }
  function y() {
  }
  function C() {
  }
  var S = {};
  u(S, a, function() {
    return this;
  });
  var b = Object.getPrototypeOf, w = b && b(b(F([])));
  w && w !== r && n.call(w, a) && (S = w);
  var x = C.prototype = m.prototype = Object.create(S);
  function R(L) {
    ["next", "throw", "return"].forEach(function(N) {
      u(L, N, function(I) {
        return this._invoke(N, I);
      });
    });
  }
  function _(L, N) {
    function I(M, V, G, k) {
      var z = d(L[M], L, V);
      if (z.type !== "throw") {
        var j = z.arg, q = j.value;
        return q && vt(q) == "object" && n.call(q, "__await") ? N.resolve(q.__await).then(function(K) {
          I("next", K, G, k);
        }, function(K) {
          I("throw", K, G, k);
        }) : N.resolve(q).then(function(K) {
          j.value = K, G(j);
        }, function(K) {
          return I("throw", K, G, k);
        });
      }
      k(z.arg);
    }
    var B;
    i(this, "_invoke", {
      value: function(V, G) {
        function k() {
          return new N(function(z, j) {
            I(V, G, z, j);
          });
        }
        return B = B ? B.then(k, k) : k();
      }
    });
  }
  function T(L, N, I) {
    var B = h;
    return function(M, V) {
      if (B === p) throw Error("Generator is already running");
      if (B === g) {
        if (M === "throw") throw V;
        return {
          value: e,
          done: !0
        };
      }
      for (I.method = M, I.arg = V; ; ) {
        var G = I.delegate;
        if (G) {
          var k = P(G, I);
          if (k) {
            if (k === v) continue;
            return k;
          }
        }
        if (I.method === "next") I.sent = I._sent = I.arg;
        else if (I.method === "throw") {
          if (B === h) throw B = g, I.arg;
          I.dispatchException(I.arg);
        } else I.method === "return" && I.abrupt("return", I.arg);
        B = p;
        var z = d(L, N, I);
        if (z.type === "normal") {
          if (B = I.done ? g : f, z.arg === v) continue;
          return {
            value: z.arg,
            done: I.done
          };
        }
        z.type === "throw" && (B = g, I.method = "throw", I.arg = z.arg);
      }
    };
  }
  function P(L, N) {
    var I = N.method, B = L.iterator[I];
    if (B === e) return N.delegate = null, I === "throw" && L.iterator.return && (N.method = "return", N.arg = e, P(L, N), N.method === "throw") || I !== "return" && (N.method = "throw", N.arg = new TypeError("The iterator does not provide a '" + I + "' method")), v;
    var M = d(B, L.iterator, N.arg);
    if (M.type === "throw") return N.method = "throw", N.arg = M.arg, N.delegate = null, v;
    var V = M.arg;
    return V ? V.done ? (N[L.resultName] = V.value, N.next = L.nextLoc, N.method !== "return" && (N.method = "next", N.arg = e), N.delegate = null, v) : V : (N.method = "throw", N.arg = new TypeError("iterator result is not an object"), N.delegate = null, v);
  }
  function D(L) {
    var N = {
      tryLoc: L[0]
    };
    1 in L && (N.catchLoc = L[1]), 2 in L && (N.finallyLoc = L[2], N.afterLoc = L[3]), this.tryEntries.push(N);
  }
  function O(L) {
    var N = L.completion || {};
    N.type = "normal", delete N.arg, L.completion = N;
  }
  function A(L) {
    this.tryEntries = [{
      tryLoc: "root"
    }], L.forEach(D, this), this.reset(!0);
  }
  function F(L) {
    if (L || L === "") {
      var N = L[a];
      if (N) return N.call(L);
      if (typeof L.next == "function") return L;
      if (!isNaN(L.length)) {
        var I = -1, B = function M() {
          for (; ++I < L.length; ) if (n.call(L, I)) return M.value = L[I], M.done = !1, M;
          return M.value = e, M.done = !0, M;
        };
        return B.next = B;
      }
    }
    throw new TypeError(vt(L) + " is not iterable");
  }
  return y.prototype = C, i(x, "constructor", {
    value: C,
    configurable: !0
  }), i(C, "constructor", {
    value: y,
    configurable: !0
  }), y.displayName = u(C, l, "GeneratorFunction"), t.isGeneratorFunction = function(L) {
    var N = typeof L == "function" && L.constructor;
    return !!N && (N === y || (N.displayName || N.name) === "GeneratorFunction");
  }, t.mark = function(L) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(L, C) : (L.__proto__ = C, u(L, l, "GeneratorFunction")), L.prototype = Object.create(x), L;
  }, t.awrap = function(L) {
    return {
      __await: L
    };
  }, R(_.prototype), u(_.prototype, s, function() {
    return this;
  }), t.AsyncIterator = _, t.async = function(L, N, I, B, M) {
    M === void 0 && (M = Promise);
    var V = new _(c(L, N, I, B), M);
    return t.isGeneratorFunction(N) ? V : V.next().then(function(G) {
      return G.done ? G.value : V.next();
    });
  }, R(x), u(x, l, "Generator"), u(x, a, function() {
    return this;
  }), u(x, "toString", function() {
    return "[object Generator]";
  }), t.keys = function(L) {
    var N = Object(L), I = [];
    for (var B in N) I.push(B);
    return I.reverse(), function M() {
      for (; I.length; ) {
        var V = I.pop();
        if (V in N) return M.value = V, M.done = !1, M;
      }
      return M.done = !0, M;
    };
  }, t.values = F, A.prototype = {
    constructor: A,
    reset: function(N) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(O), !N) for (var I in this) I.charAt(0) === "t" && n.call(this, I) && !isNaN(+I.slice(1)) && (this[I] = e);
    },
    stop: function() {
      this.done = !0;
      var N = this.tryEntries[0].completion;
      if (N.type === "throw") throw N.arg;
      return this.rval;
    },
    dispatchException: function(N) {
      if (this.done) throw N;
      var I = this;
      function B(j, q) {
        return G.type = "throw", G.arg = N, I.next = j, q && (I.method = "next", I.arg = e), !!q;
      }
      for (var M = this.tryEntries.length - 1; M >= 0; --M) {
        var V = this.tryEntries[M], G = V.completion;
        if (V.tryLoc === "root") return B("end");
        if (V.tryLoc <= this.prev) {
          var k = n.call(V, "catchLoc"), z = n.call(V, "finallyLoc");
          if (k && z) {
            if (this.prev < V.catchLoc) return B(V.catchLoc, !0);
            if (this.prev < V.finallyLoc) return B(V.finallyLoc);
          } else if (k) {
            if (this.prev < V.catchLoc) return B(V.catchLoc, !0);
          } else {
            if (!z) throw Error("try statement without catch or finally");
            if (this.prev < V.finallyLoc) return B(V.finallyLoc);
          }
        }
      }
    },
    abrupt: function(N, I) {
      for (var B = this.tryEntries.length - 1; B >= 0; --B) {
        var M = this.tryEntries[B];
        if (M.tryLoc <= this.prev && n.call(M, "finallyLoc") && this.prev < M.finallyLoc) {
          var V = M;
          break;
        }
      }
      V && (N === "break" || N === "continue") && V.tryLoc <= I && I <= V.finallyLoc && (V = null);
      var G = V ? V.completion : {};
      return G.type = N, G.arg = I, V ? (this.method = "next", this.next = V.finallyLoc, v) : this.complete(G);
    },
    complete: function(N, I) {
      if (N.type === "throw") throw N.arg;
      return N.type === "break" || N.type === "continue" ? this.next = N.arg : N.type === "return" ? (this.rval = this.arg = N.arg, this.method = "return", this.next = "end") : N.type === "normal" && I && (this.next = I), v;
    },
    finish: function(N) {
      for (var I = this.tryEntries.length - 1; I >= 0; --I) {
        var B = this.tryEntries[I];
        if (B.finallyLoc === N) return this.complete(B.completion, B.afterLoc), O(B), v;
      }
    },
    catch: function(N) {
      for (var I = this.tryEntries.length - 1; I >= 0; --I) {
        var B = this.tryEntries[I];
        if (B.tryLoc === N) {
          var M = B.completion;
          if (M.type === "throw") {
            var V = M.arg;
            O(B);
          }
          return V;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(N, I, B) {
      return this.delegate = {
        iterator: F(N),
        resultName: I,
        nextLoc: B
      }, this.method === "next" && (this.arg = e), v;
    }
  }, t;
}
function Z2(e, t, r, n, i, o, a) {
  try {
    var s = e[o](a), l = s.value;
  } catch (u) {
    return void r(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(n, i);
}
function td(e) {
  return function() {
    var t = this, r = arguments;
    return new Promise(function(n, i) {
      var o = e.apply(t, r);
      function a(l) {
        Z2(o, n, i, a, s, "next", l);
      }
      function s(l) {
        Z2(o, n, i, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
var yv = ee({}, zX), Are = yv.version, Ire = yv.render, Ore = yv.unmountComponentAtNode, yS;
try {
  var Lre = Number((Are || "").split(".")[0]);
  Lre >= 18 && (yS = yv.createRoot);
} catch {
}
function Q2(e) {
  var t = yv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  t && vt(t) === "object" && (t.usingClientEntryPoint = e);
}
var O0 = "__rc_react_root__";
function Fre(e, t) {
  Q2(!0);
  var r = t[O0] || yS(t);
  Q2(!1), r.render(e), t[O0] = r;
}
function Nre(e, t) {
  Ire(e, t);
}
function kre(e, t) {
  if (yS) {
    Fre(e, t);
    return;
  }
  Nre(e, t);
}
function Vre(e) {
  return CR.apply(this, arguments);
}
function CR() {
  return CR = td(/* @__PURE__ */ Di().mark(function e(t) {
    return Di().wrap(function(n) {
      for (; ; ) switch (n.prev = n.next) {
        case 0:
          return n.abrupt("return", Promise.resolve().then(function() {
            var i;
            (i = t[O0]) === null || i === void 0 || i.unmount(), delete t[O0];
          }));
        case 1:
        case "end":
          return n.stop();
      }
    }, e);
  })), CR.apply(this, arguments);
}
function Bre(e) {
  Ore(e);
}
function $re(e) {
  return SR.apply(this, arguments);
}
function SR() {
  return SR = td(/* @__PURE__ */ Di().mark(function e(t) {
    return Di().wrap(function(n) {
      for (; ; ) switch (n.prev = n.next) {
        case 0:
          if (yS === void 0) {
            n.next = 2;
            break;
          }
          return n.abrupt("return", Vre(t));
        case 2:
          Bre(t);
        case 3:
        case "end":
          return n.stop();
      }
    }, e);
  })), SR.apply(this, arguments);
}
const Ql = (e, t, r) => r !== void 0 ? r : `${e}-${t}`, VP = function(e) {
  if (!e)
    return !1;
  if (e instanceof Element) {
    if (e.offsetParent)
      return !0;
    if (e.getBBox) {
      var t = e.getBBox(), r = t.width, n = t.height;
      if (r || n)
        return !0;
    }
    if (e.getBoundingClientRect) {
      var i = e.getBoundingClientRect(), o = i.width, a = i.height;
      if (o || a)
        return !0;
    }
  }
  return !1;
}, Hre = (e) => {
  const {
    componentCls: t,
    colorPrimary: r
  } = e;
  return {
    [t]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${r})`,
      boxShadow: "0 0 0 0 currentcolor",
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${e.motionEaseOutCirc}`, `opacity 2s ${e.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: "0 0 0 6px currentcolor",
          opacity: 0
        },
        "&.wave-quick": {
          transition: [`box-shadow ${e.motionDurationSlow} ${e.motionEaseInOut}`, `opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`].join(",")
        }
      }
    }
  };
}, Gre = OP("Wave", (e) => [Hre(e)]), u5 = `${Jz}-wave-target`;
function zre(e) {
  const t = (e || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return t && t[1] && t[2] && t[3] ? !(t[1] === t[2] && t[2] === t[3]) : !0;
}
function ib(e) {
  return e && e !== "#fff" && e !== "#ffffff" && e !== "rgb(255, 255, 255)" && e !== "rgba(255, 255, 255, 1)" && zre(e) && !/rgba\((?:\d*, ){3}0\)/.test(e) && // any transparent rgba color
  e !== "transparent";
}
function Wre(e) {
  const {
    borderTopColor: t,
    borderColor: r,
    backgroundColor: n
  } = getComputedStyle(e);
  return ib(t) ? t : ib(r) ? r : ib(n) ? n : null;
}
function ob(e) {
  return Number.isNaN(e) ? 0 : e;
}
const jre = (e) => {
  const {
    className: t,
    target: r,
    component: n
  } = e, i = E.useRef(null), [o, a] = E.useState(null), [s, l] = E.useState([]), [u, c] = E.useState(0), [d, h] = E.useState(0), [f, p] = E.useState(0), [g, v] = E.useState(0), [m, y] = E.useState(!1), C = {
    left: u,
    top: d,
    width: f,
    height: g,
    borderRadius: s.map((w) => `${w}px`).join(" ")
  };
  o && (C["--wave-color"] = o);
  function S() {
    const w = getComputedStyle(r);
    a(Wre(r));
    const x = w.position === "static", {
      borderLeftWidth: R,
      borderTopWidth: _
    } = w;
    c(x ? r.offsetLeft : ob(-parseFloat(R))), h(x ? r.offsetTop : ob(-parseFloat(_))), p(r.offsetWidth), v(r.offsetHeight);
    const {
      borderTopLeftRadius: T,
      borderTopRightRadius: P,
      borderBottomLeftRadius: D,
      borderBottomRightRadius: O
    } = w;
    l([T, P, O, D].map((A) => ob(parseFloat(A))));
  }
  if (E.useEffect(() => {
    if (r) {
      const w = Ar(() => {
        S(), y(!0);
      });
      let x;
      return typeof ResizeObserver < "u" && (x = new ResizeObserver(S), x.observe(r)), () => {
        Ar.cancel(w), x == null || x.disconnect();
      };
    }
  }, []), !m)
    return null;
  const b = (n === "Checkbox" || n === "Radio") && (r == null ? void 0 : r.classList.contains(u5));
  return /* @__PURE__ */ E.createElement(Cs, {
    visible: !0,
    motionAppear: !0,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: (w, x) => {
      var R;
      if (x.deadline || x.propertyName === "opacity") {
        const _ = (R = i.current) === null || R === void 0 ? void 0 : R.parentElement;
        $re(_).then(() => {
          _ == null || _.remove();
        });
      }
      return !1;
    }
  }, (w, x) => {
    let {
      className: R
    } = w;
    return /* @__PURE__ */ E.createElement("div", {
      ref: Eo(i, x),
      className: ue(t, R, {
        "wave-quick": b
      }),
      style: C
    });
  });
}, Ure = (e, t) => {
  var r;
  const {
    component: n
  } = t;
  if (n === "Checkbox" && !(!((r = e.querySelector("input")) === null || r === void 0) && r.checked))
    return;
  const i = document.createElement("div");
  i.style.position = "absolute", i.style.left = "0px", i.style.top = "0px", e == null || e.insertBefore(i, e == null ? void 0 : e.firstChild), kre(/* @__PURE__ */ E.createElement(jre, Object.assign({}, t, {
    target: e
  })), i);
}, Kre = (e, t, r) => {
  const {
    wave: n
  } = E.useContext(Yt), [, i, o] = Qi(), a = An((u) => {
    const c = e.current;
    if (n != null && n.disabled || !c)
      return;
    const d = c.querySelector(`.${u5}`) || c, {
      showEffect: h
    } = n || {};
    (h || Ure)(d, {
      className: t,
      token: i,
      component: r,
      event: u,
      hashId: o
    });
  }), s = E.useRef();
  return (u) => {
    Ar.cancel(s.current), s.current = Ar(() => {
      a(u);
    });
  };
}, BP = (e) => {
  const {
    children: t,
    disabled: r,
    component: n
  } = e, {
    getPrefixCls: i
  } = vr(Yt), o = se(null), a = i("wave"), [, s] = Gre(a), l = Kre(o, ue(a, s), n);
  if (H.useEffect(() => {
    const c = o.current;
    if (!c || c.nodeType !== 1 || r)
      return;
    const d = (h) => {
      !VP(h.target) || // No need wave
      !c.getAttribute || c.getAttribute("disabled") || c.disabled || c.className.includes("disabled") || c.className.includes("-leave") || l(h);
    };
    return c.addEventListener("click", d, !0), () => {
      c.removeEventListener("click", d, !0);
    };
  }, [r]), !/* @__PURE__ */ H.isValidElement(t))
    return t ?? null;
  const u = Jc(t) ? Eo(t.ref, o) : o;
  return Hc(t, {
    ref: u
  });
};
process.env.NODE_ENV !== "production" && (BP.displayName = "Wave");
const sl = (e) => {
  const t = H.useContext(Bh);
  return H.useMemo(() => e ? typeof e == "string" ? e ?? t : e instanceof Function ? e(t) : t : t, [e, t]);
}, c5 = /* @__PURE__ */ E.createContext(null), CS = (e, t) => {
  const r = E.useContext(c5), n = E.useMemo(() => {
    if (!r)
      return "";
    const {
      compactDirection: i,
      isFirstItem: o,
      isLastItem: a
    } = r, s = i === "vertical" ? "-vertical-" : "-";
    return ue(`${e}-compact${s}item`, {
      [`${e}-compact${s}first-item`]: o,
      [`${e}-compact${s}last-item`]: a,
      [`${e}-compact${s}item-rtl`]: t === "rtl"
    });
  }, [e, t, r]);
  return {
    compactSize: r == null ? void 0 : r.compactSize,
    compactDirection: r == null ? void 0 : r.compactDirection,
    compactItemClassnames: n
  };
}, Yre = (e) => {
  let {
    children: t
  } = e;
  return /* @__PURE__ */ E.createElement(c5.Provider, {
    value: null
  }, t);
};
var qre = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const d5 = /* @__PURE__ */ E.createContext(void 0), Xre = (e) => {
  const {
    getPrefixCls: t,
    direction: r
  } = E.useContext(Yt), {
    prefixCls: n,
    size: i,
    className: o
  } = e, a = qre(e, ["prefixCls", "size", "className"]), s = t("btn-group", n), [, , l] = Qi();
  let u = "";
  switch (i) {
    case "large":
      u = "lg";
      break;
    case "small":
      u = "sm";
      break;
  }
  if (process.env.NODE_ENV !== "production") {
    const d = en("Button.Group");
    process.env.NODE_ENV !== "production" && d(!i || ["large", "small", "middle"].includes(i), "usage", "Invalid prop `size`.");
  }
  const c = ue(s, {
    [`${s}-${u}`]: u,
    [`${s}-rtl`]: r === "rtl"
  }, o, l);
  return /* @__PURE__ */ E.createElement(d5.Provider, {
    value: i
  }, /* @__PURE__ */ E.createElement("div", Object.assign({}, a, {
    className: c
  })));
}, J2 = /^[\u4e00-\u9fa5]{2}$/, wR = J2.test.bind(J2);
function h5(e) {
  return e === "danger" ? {
    danger: !0
  } : {
    type: e
  };
}
function eO(e) {
  return typeof e == "string";
}
function ym(e) {
  return e === "text" || e === "link";
}
function Zre(e, t) {
  if (e == null)
    return;
  const r = t ? " " : "";
  return typeof e != "string" && typeof e != "number" && eO(e.type) && wR(e.props.children) ? Hc(e, {
    children: e.props.children.split("").join(r)
  }) : eO(e) ? wR(e) ? /* @__PURE__ */ H.createElement("span", null, e.split("").join(r)) : /* @__PURE__ */ H.createElement("span", null, e) : a5(e) ? /* @__PURE__ */ H.createElement("span", null, e) : e;
}
function Qre(e, t) {
  let r = !1;
  const n = [];
  return H.Children.forEach(e, (i) => {
    const o = typeof i, a = o === "string" || o === "number";
    if (r && a) {
      const s = n.length - 1, l = n[s];
      n[s] = `${l}${i}`;
    } else
      n.push(i);
    r = a;
  }), H.Children.map(n, (i) => Zre(i, t));
}
const f5 = /* @__PURE__ */ yn((e, t) => {
  const {
    className: r,
    style: n,
    children: i,
    prefixCls: o
  } = e, a = ue(`${o}-icon`, r);
  return /* @__PURE__ */ H.createElement("span", {
    ref: t,
    className: a,
    style: n
  }, i);
}), tO = /* @__PURE__ */ yn((e, t) => {
  const {
    prefixCls: r,
    className: n,
    style: i,
    iconClassName: o
  } = e, a = ue(`${r}-loading-icon`, n);
  return /* @__PURE__ */ H.createElement(f5, {
    prefixCls: r,
    className: a,
    style: i,
    ref: t
  }, /* @__PURE__ */ H.createElement(vS, {
    className: o
  }));
}), ab = () => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
}), sb = (e) => ({
  width: e.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
}), Jre = (e) => {
  const {
    prefixCls: t,
    loading: r,
    existIcon: n,
    className: i,
    style: o
  } = e, a = !!r;
  return n ? /* @__PURE__ */ H.createElement(tO, {
    prefixCls: t,
    className: i,
    style: o
  }) : /* @__PURE__ */ H.createElement(Cs, {
    visible: a,
    // We do not really use this motionName
    motionName: `${t}-loading-icon-motion`,
    motionLeave: a,
    removeOnLeave: !0,
    onAppearStart: ab,
    onAppearActive: sb,
    onEnterStart: ab,
    onEnterActive: sb,
    onLeaveStart: sb,
    onLeaveActive: ab
  }, (s, l) => {
    let {
      className: u,
      style: c
    } = s;
    return /* @__PURE__ */ H.createElement(tO, {
      prefixCls: t,
      className: i,
      style: Object.assign(Object.assign({}, o), c),
      ref: l,
      iconClassName: u
    });
  });
}, rO = (e, t) => ({
  // Border
  [`> span, > ${e}`]: {
    "&:not(:last-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: t
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: t
        }
      }
    }
  }
}), ene = (e) => {
  const {
    componentCls: t,
    fontSize: r,
    lineWidth: n,
    groupBorderColor: i,
    colorErrorHover: o
  } = e;
  return {
    [`${t}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${t}`]: {
          "&:not(:last-child)": {
            [`&, & > ${t}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: e.calc(n).mul(-1).equal(),
            [`&, & > ${t}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [t]: {
          position: "relative",
          zIndex: 1,
          "&:hover, &:focus, &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${t}-icon-only`]: {
          fontSize: r
        }
      },
      // Border Color
      rO(`${t}-primary`, i),
      rO(`${t}-danger`, o)
    ]
  };
}, p5 = (e) => {
  const {
    paddingInline: t,
    onlyIconSize: r,
    paddingBlock: n
  } = e;
  return Br(e, {
    buttonPaddingHorizontal: t,
    buttonPaddingVertical: n,
    buttonIconOnlyFontSize: r
  });
}, g5 = (e) => {
  var t, r, n, i, o, a;
  const s = (t = e.contentFontSize) !== null && t !== void 0 ? t : e.fontSize, l = (r = e.contentFontSizeSM) !== null && r !== void 0 ? r : e.fontSize, u = (n = e.contentFontSizeLG) !== null && n !== void 0 ? n : e.fontSizeLG, c = (i = e.contentLineHeight) !== null && i !== void 0 ? i : Zy(s), d = (o = e.contentLineHeightSM) !== null && o !== void 0 ? o : Zy(l), h = (a = e.contentLineHeightLG) !== null && a !== void 0 ? a : Zy(u);
  return {
    fontWeight: 400,
    defaultShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlTmpOutline}`,
    primaryShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlOutline}`,
    dangerShadow: `0 ${e.controlOutlineWidth}px 0 ${e.colorErrorOutline}`,
    primaryColor: e.colorTextLightSolid,
    dangerColor: e.colorTextLightSolid,
    borderColorDisabled: e.colorBorder,
    defaultGhostColor: e.colorBgContainer,
    ghostBg: "transparent",
    defaultGhostBorderColor: e.colorBgContainer,
    paddingInline: e.paddingContentHorizontal - e.lineWidth,
    paddingInlineLG: e.paddingContentHorizontal - e.lineWidth,
    paddingInlineSM: 8 - e.lineWidth,
    onlyIconSize: e.fontSizeLG,
    onlyIconSizeSM: e.fontSizeLG - 2,
    onlyIconSizeLG: e.fontSizeLG + 2,
    groupBorderColor: e.colorPrimaryHover,
    linkHoverBg: "transparent",
    textHoverBg: e.colorBgTextHover,
    defaultColor: e.colorText,
    defaultBg: e.colorBgContainer,
    defaultBorderColor: e.colorBorder,
    defaultBorderColorDisabled: e.colorBorder,
    defaultHoverBg: e.colorBgContainer,
    defaultHoverColor: e.colorPrimaryHover,
    defaultHoverBorderColor: e.colorPrimaryHover,
    defaultActiveBg: e.colorBgContainer,
    defaultActiveColor: e.colorPrimaryActive,
    defaultActiveBorderColor: e.colorPrimaryActive,
    contentFontSize: s,
    contentFontSizeSM: l,
    contentFontSizeLG: u,
    contentLineHeight: c,
    contentLineHeightSM: d,
    contentLineHeightLG: h,
    paddingBlock: Math.max((e.controlHeight - s * c) / 2 - e.lineWidth, 0),
    paddingBlockSM: Math.max((e.controlHeightSM - l * d) / 2 - e.lineWidth, 0),
    paddingBlockLG: Math.max((e.controlHeightLG - u * h) / 2 - e.lineWidth, 0)
  };
}, tne = (e) => {
  const {
    componentCls: t,
    iconCls: r,
    fontWeight: n
  } = e;
  return {
    [t]: {
      outline: "none",
      position: "relative",
      display: "inline-flex",
      gap: e.marginXS,
      alignItems: "center",
      justifyContent: "center",
      fontWeight: n,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      background: "transparent",
      border: `${de(e.lineWidth)} ${e.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      color: e.colorText,
      "&:disabled > *": {
        pointerEvents: "none"
      },
      "> span": {
        display: "inline-block"
      },
      [`${t}-icon`]: {
        lineHeight: 1
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": Object.assign({}, pS(e)),
      [`&${t}-two-chinese-chars::first-letter`]: {
        letterSpacing: "0.34em"
      },
      [`&${t}-two-chinese-chars > *:not(${r})`]: {
        marginInlineEnd: "-0.34em",
        letterSpacing: "0.34em"
      },
      // iconPosition="end"
      "&-icon-end": {
        flexDirection: "row-reverse"
      }
    }
  };
}, qs = (e, t, r) => ({
  [`&:not(:disabled):not(${e}-disabled)`]: {
    "&:hover": t,
    "&:active": r
  }
}), rne = (e) => ({
  minWidth: e.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), nne = (e) => ({
  borderRadius: e.controlHeight,
  paddingInlineStart: e.calc(e.controlHeight).div(2).equal(),
  paddingInlineEnd: e.calc(e.controlHeight).div(2).equal()
}), ine = (e) => ({
  cursor: "not-allowed",
  borderColor: e.borderColorDisabled,
  color: e.colorTextDisabled,
  background: e.colorBgContainerDisabled,
  boxShadow: "none"
}), Ig = (e, t, r, n, i, o, a, s) => ({
  [`&${e}-background-ghost`]: Object.assign(Object.assign({
    color: r || void 0,
    background: t,
    borderColor: n || void 0,
    boxShadow: "none"
  }, qs(e, Object.assign({
    background: t
  }, a), Object.assign({
    background: t
  }, s))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: i || void 0,
      borderColor: o || void 0
    }
  })
}), $P = (e) => ({
  [`&:disabled, &${e.componentCls}-disabled`]: Object.assign({}, ine(e))
}), v5 = (e) => Object.assign({}, $P(e)), L0 = (e) => ({
  [`&:disabled, &${e.componentCls}-disabled`]: {
    cursor: "not-allowed",
    color: e.colorTextDisabled
  }
}), m5 = (e) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, v5(e)), {
  background: e.defaultBg,
  borderColor: e.defaultBorderColor,
  color: e.defaultColor,
  boxShadow: e.defaultShadow
}), qs(e.componentCls, {
  color: e.defaultHoverColor,
  borderColor: e.defaultHoverBorderColor,
  background: e.defaultHoverBg
}, {
  color: e.defaultActiveColor,
  borderColor: e.defaultActiveBorderColor,
  background: e.defaultActiveBg
})), Ig(e.componentCls, e.ghostBg, e.defaultGhostColor, e.defaultGhostBorderColor, e.colorTextDisabled, e.colorBorder)), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    color: e.colorError,
    borderColor: e.colorError
  }, qs(e.componentCls, {
    color: e.colorErrorHover,
    borderColor: e.colorErrorBorderHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), Ig(e.componentCls, e.ghostBg, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder)), $P(e))
}), one = (e) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, v5(e)), {
  color: e.primaryColor,
  background: e.colorPrimary,
  boxShadow: e.primaryShadow
}), qs(e.componentCls, {
  color: e.colorTextLightSolid,
  background: e.colorPrimaryHover
}, {
  color: e.colorTextLightSolid,
  background: e.colorPrimaryActive
})), Ig(e.componentCls, e.ghostBg, e.colorPrimary, e.colorPrimary, e.colorTextDisabled, e.colorBorder, {
  color: e.colorPrimaryHover,
  borderColor: e.colorPrimaryHover
}, {
  color: e.colorPrimaryActive,
  borderColor: e.colorPrimaryActive
})), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    background: e.colorError,
    boxShadow: e.dangerShadow,
    color: e.dangerColor
  }, qs(e.componentCls, {
    background: e.colorErrorHover
  }, {
    background: e.colorErrorActive
  })), Ig(e.componentCls, e.ghostBg, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder, {
    color: e.colorErrorHover,
    borderColor: e.colorErrorHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), $P(e))
}), ane = (e) => Object.assign(Object.assign({}, m5(e)), {
  borderStyle: "dashed"
}), sne = (e) => Object.assign(Object.assign(Object.assign({
  color: e.colorLink
}, qs(e.componentCls, {
  color: e.colorLinkHover,
  background: e.linkHoverBg
}, {
  color: e.colorLinkActive
})), L0(e)), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: e.colorError
  }, qs(e.componentCls, {
    color: e.colorErrorHover
  }, {
    color: e.colorErrorActive
  })), L0(e))
}), lne = (e) => Object.assign(Object.assign(Object.assign({}, qs(e.componentCls, {
  color: e.colorText,
  background: e.textHoverBg
}, {
  color: e.colorText,
  background: e.colorBgTextActive
})), L0(e)), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: e.colorError
  }, L0(e)), qs(e.componentCls, {
    color: e.colorErrorHover,
    background: e.colorErrorBg
  }, {
    color: e.colorErrorHover,
    background: e.colorErrorBgActive
  }))
}), une = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-default`]: m5(e),
    [`${t}-primary`]: one(e),
    [`${t}-dashed`]: ane(e),
    [`${t}-link`]: sne(e),
    [`${t}-text`]: lne(e),
    [`${t}-ghost`]: Ig(e.componentCls, e.ghostBg, e.colorBgContainer, e.colorBgContainer, e.colorTextDisabled, e.colorBorder)
  };
}, HP = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls: r,
    controlHeight: n,
    fontSize: i,
    lineHeight: o,
    borderRadius: a,
    buttonPaddingHorizontal: s,
    iconCls: l,
    buttonPaddingVertical: u
  } = e, c = `${r}-icon-only`;
  return [
    {
      [`${t}`]: {
        fontSize: i,
        lineHeight: o,
        height: n,
        padding: `${de(u)} ${de(s)}`,
        borderRadius: a,
        [`&${c}`]: {
          width: n,
          paddingInline: 0,
          // make `btn-icon-only` not too narrow
          [`&${r}-compact-item`]: {
            flex: "none"
          },
          [`&${r}-round`]: {
            width: "auto"
          },
          [l]: {
            fontSize: e.buttonIconOnlyFontSize
          }
        },
        // Loading
        [`&${r}-loading`]: {
          opacity: e.opacityLoading,
          cursor: "default"
        },
        [`${r}-loading-icon`]: {
          transition: `width ${e.motionDurationSlow} ${e.motionEaseInOut}, opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${r}${r}-circle${t}`]: rne(e)
    },
    {
      [`${r}${r}-round${t}`]: nne(e)
    }
  ];
}, cne = (e) => {
  const t = Br(e, {
    fontSize: e.contentFontSize,
    lineHeight: e.contentLineHeight
  });
  return HP(t, e.componentCls);
}, dne = (e) => {
  const t = Br(e, {
    controlHeight: e.controlHeightSM,
    fontSize: e.contentFontSizeSM,
    lineHeight: e.contentLineHeightSM,
    padding: e.paddingXS,
    buttonPaddingHorizontal: e.paddingInlineSM,
    buttonPaddingVertical: e.paddingBlockSM,
    borderRadius: e.borderRadiusSM,
    buttonIconOnlyFontSize: e.onlyIconSizeSM
  });
  return HP(t, `${e.componentCls}-sm`);
}, hne = (e) => {
  const t = Br(e, {
    controlHeight: e.controlHeightLG,
    fontSize: e.contentFontSizeLG,
    lineHeight: e.contentLineHeightLG,
    buttonPaddingHorizontal: e.paddingInlineLG,
    buttonPaddingVertical: e.paddingBlockLG,
    borderRadius: e.borderRadiusLG,
    buttonIconOnlyFontSize: e.onlyIconSizeLG
  });
  return HP(t, `${e.componentCls}-lg`);
}, fne = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`&${t}-block`]: {
        width: "100%"
      }
    }
  };
}, pne = Gn("Button", (e) => {
  const t = p5(e);
  return [
    // Shared
    tne(t),
    // Size
    cne(t),
    dne(t),
    hne(t),
    // Block
    fne(t),
    // Group (type, ghost, danger, loading)
    une(t),
    // Button Group
    ene(t)
  ];
}, g5, {
  unitless: {
    fontWeight: !0,
    contentLineHeight: !0,
    contentLineHeightSM: !0,
    contentLineHeightLG: !0
  }
});
function gne(e, t, r) {
  const {
    focusElCls: n,
    focus: i,
    borderElCls: o
  } = r, a = o ? "> *" : "", s = ["hover", i ? "focus" : null, "active"].filter(Boolean).map((l) => `&:${l} ${a}`).join(",");
  return {
    [`&-item:not(${t}-last-item)`]: {
      marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal()
    },
    "&-item": Object.assign(Object.assign({
      [s]: {
        zIndex: 2
      }
    }, n ? {
      [`&${n}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${a}`]: {
        zIndex: 0
      }
    })
  };
}
function vne(e, t, r) {
  const {
    borderElCls: n
  } = r, i = n ? `> ${n}` : "";
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item) ${i}`]: {
      borderRadius: 0
    },
    [`&-item:not(${t}-last-item)${t}-first-item`]: {
      [`& ${i}, &${e}-sm ${i}, &${e}-lg ${i}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${t}-first-item)${t}-last-item`]: {
      [`& ${i}, &${e}-sm ${i}, &${e}-lg ${i}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function GP(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls: r
  } = e, n = `${r}-compact`;
  return {
    [n]: Object.assign(Object.assign({}, gne(e, n, t)), vne(r, n, t))
  };
}
function mne(e, t) {
  return {
    // border collapse
    [`&-item:not(${t}-last-item)`]: {
      marginBottom: e.calc(e.lineWidth).mul(-1).equal()
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function yne(e, t) {
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${t}-first-item:not(${t}-last-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${t}-last-item:not(${t}-first-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function Cne(e) {
  const t = `${e.componentCls}-compact-vertical`;
  return {
    [t]: Object.assign(Object.assign({}, mne(e, t)), yne(e.componentCls, t))
  };
}
const Sne = (e) => {
  const {
    componentCls: t,
    calc: r
  } = e;
  return {
    [t]: {
      // Special styles for Primary Button
      [`&-compact-item${t}-primary`]: {
        [`&:not([disabled]) + ${t}-compact-item${t}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: r(e.lineWidth).mul(-1).equal(),
            insetInlineStart: r(e.lineWidth).mul(-1).equal(),
            display: "inline-block",
            width: e.lineWidth,
            height: `calc(100% + ${de(e.lineWidth)} * 2)`,
            backgroundColor: e.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${t}-primary`]: {
          [`&:not([disabled]) + ${t}-compact-vertical-item${t}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: r(e.lineWidth).mul(-1).equal(),
              insetInlineStart: r(e.lineWidth).mul(-1).equal(),
              display: "inline-block",
              width: `calc(100% + ${de(e.lineWidth)} * 2)`,
              height: e.lineWidth,
              backgroundColor: e.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
}, wne = LP(["Button", "compact"], (e) => {
  const t = p5(e);
  return [
    // Space Compact
    GP(t),
    Cne(t),
    Sne(t)
  ];
}, g5);
var bne = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function xne(e) {
  if (typeof e == "object" && e) {
    let t = e == null ? void 0 : e.delay;
    return t = !Number.isNaN(t) && typeof t == "number" ? t : 0, {
      loading: t <= 0,
      delay: t
    };
  }
  return {
    loading: !!e,
    delay: 0
  };
}
const Ene = /* @__PURE__ */ H.forwardRef((e, t) => {
  var r, n, i;
  const {
    loading: o = !1,
    prefixCls: a,
    type: s,
    danger: l = !1,
    shape: u = "default",
    size: c,
    styles: d,
    disabled: h,
    className: f,
    rootClassName: p,
    children: g,
    icon: v,
    iconPosition: m = "start",
    ghost: y = !1,
    block: C = !1,
    // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
    htmlType: S = "button",
    classNames: b,
    style: w = {},
    autoInsertSpace: x
  } = e, R = bne(e, ["loading", "prefixCls", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "iconPosition", "ghost", "block", "htmlType", "classNames", "style", "autoInsertSpace"]), _ = s || "default", {
    getPrefixCls: T,
    direction: P,
    button: D
  } = vr(Yt), O = (r = x ?? (D == null ? void 0 : D.autoInsertSpace)) !== null && r !== void 0 ? r : !0, A = T("btn", a), [F, L, N] = pne(A), I = vr($c), B = h ?? I, M = vr(d5), V = Et(() => xne(o), [o]), [G, k] = Me(V.loading), [z, j] = Me(!1), K = Eo(t, /* @__PURE__ */ kX()), Z = NX.count(g) === 1 && !v && !ym(_);
  Nt(() => {
    let Ne = null;
    V.delay > 0 ? Ne = setTimeout(() => {
      Ne = null, k(!0);
    }, V.delay) : k(V.loading);
    function Je() {
      Ne && (clearTimeout(Ne), Ne = null);
    }
    return Je;
  }, [V]), Nt(() => {
    if (!K || !K.current || !O)
      return;
    const Ne = K.current.textContent;
    Z && wR(Ne) ? z || j(!0) : z && j(!1);
  }, [K]);
  const re = (Ne) => {
    const {
      onClick: Je
    } = e;
    if (G || B) {
      Ne.preventDefault();
      return;
    }
    Je == null || Je(Ne);
  };
  if (process.env.NODE_ENV !== "production") {
    const Ne = en("Button");
    process.env.NODE_ENV !== "production" && Ne(!(typeof v == "string" && v.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${v}\` at https://ant.design/components/icon`), process.env.NODE_ENV !== "production" && Ne(!(y && ym(_)), "usage", "`link` or `text` button can't be a `ghost` button.");
  }
  const {
    compactSize: X,
    compactItemClassnames: Y
  } = CS(A, P), U = {
    large: "lg",
    small: "sm",
    middle: void 0
  }, oe = sl((Ne) => {
    var Je, J;
    return (J = (Je = c ?? X) !== null && Je !== void 0 ? Je : M) !== null && J !== void 0 ? J : Ne;
  }), W = oe && U[oe] || "", ne = G ? "loading" : v, ce = ni(R, ["navigate"]), we = ue(A, L, N, {
    [`${A}-${u}`]: u !== "default" && u,
    [`${A}-${_}`]: _,
    [`${A}-${W}`]: W,
    [`${A}-icon-only`]: !g && g !== 0 && !!ne,
    [`${A}-background-ghost`]: y && !ym(_),
    [`${A}-loading`]: G,
    [`${A}-two-chinese-chars`]: z && O && !G,
    [`${A}-block`]: C,
    [`${A}-dangerous`]: l,
    [`${A}-rtl`]: P === "rtl",
    [`${A}-icon-end`]: m === "end"
  }, Y, f, p, D == null ? void 0 : D.className), Re = Object.assign(Object.assign({}, D == null ? void 0 : D.style), w), ve = ue(b == null ? void 0 : b.icon, (n = D == null ? void 0 : D.classNames) === null || n === void 0 ? void 0 : n.icon), xe = Object.assign(Object.assign({}, (d == null ? void 0 : d.icon) || {}), ((i = D == null ? void 0 : D.styles) === null || i === void 0 ? void 0 : i.icon) || {}), _e = v && !G ? /* @__PURE__ */ H.createElement(f5, {
    prefixCls: A,
    className: ve,
    style: xe
  }, v) : /* @__PURE__ */ H.createElement(Jre, {
    existIcon: !!v,
    prefixCls: A,
    loading: G
  }), Ve = g || g === 0 ? Qre(g, Z && O) : null;
  if (ce.href !== void 0)
    return F(/* @__PURE__ */ H.createElement("a", Object.assign({}, ce, {
      className: ue(we, {
        [`${A}-disabled`]: B
      }),
      href: B ? void 0 : ce.href,
      style: Re,
      onClick: re,
      ref: K,
      tabIndex: B ? -1 : 0
    }), _e, Ve));
  let Fe = /* @__PURE__ */ H.createElement("button", Object.assign({}, R, {
    type: S,
    className: we,
    style: Re,
    onClick: re,
    disabled: B,
    ref: K
  }), _e, Ve, !!Y && /* @__PURE__ */ H.createElement(wne, {
    key: "compact",
    prefixCls: A
  }));
  return ym(_) || (Fe = /* @__PURE__ */ H.createElement(BP, {
    component: "Button",
    disabled: G
  }, Fe)), F(Fe);
}), jn = Ene;
jn.Group = Xre;
jn.__ANT_BUTTON = !0;
process.env.NODE_ENV !== "production" && (jn.displayName = "Button");
function lb(e) {
  return !!(e != null && e.then);
}
const Rne = (e) => {
  const {
    type: t,
    children: r,
    prefixCls: n,
    buttonProps: i,
    close: o,
    autoFocus: a,
    emitEvent: s,
    isSilent: l,
    quitOnNullishReturnValue: u,
    actionFn: c
  } = e, d = E.useRef(!1), h = E.useRef(null), [f, p] = $h(!1), g = function() {
    o == null || o.apply(void 0, arguments);
  };
  E.useEffect(() => {
    let y = null;
    return a && (y = setTimeout(() => {
      var C;
      (C = h.current) === null || C === void 0 || C.focus();
    })), () => {
      y && clearTimeout(y);
    };
  }, []);
  const v = (y) => {
    lb(y) && (p(!0), y.then(function() {
      p(!1, !0), g.apply(void 0, arguments), d.current = !1;
    }, (C) => {
      if (p(!1, !0), d.current = !1, !(l != null && l()))
        return Promise.reject(C);
    }));
  }, m = (y) => {
    if (d.current)
      return;
    if (d.current = !0, !c) {
      g();
      return;
    }
    let C;
    if (s) {
      if (C = c(y), u && !lb(C)) {
        d.current = !1, g(y);
        return;
      }
    } else if (c.length)
      C = c(o), d.current = !1;
    else if (C = c(), !lb(C)) {
      g();
      return;
    }
    v(C);
  };
  return /* @__PURE__ */ E.createElement(jn, Object.assign({}, h5(t), {
    onClick: m,
    loading: f,
    prefixCls: n
  }, i, {
    ref: h
  }), r);
};
var y5 = /* @__PURE__ */ E.createContext(null), nO = [];
function _ne(e, t) {
  var r = E.useState(function() {
    if (!Zn())
      return null;
    var p = document.createElement("div");
    return process.env.NODE_ENV !== "production" && t && p.setAttribute("data-debug", t), p;
  }), n = ae(r, 1), i = n[0], o = E.useRef(!1), a = E.useContext(y5), s = E.useState(nO), l = ae(s, 2), u = l[0], c = l[1], d = a || (o.current ? void 0 : function(p) {
    c(function(g) {
      var v = [p].concat(it(g));
      return v;
    });
  });
  function h() {
    i.parentElement || document.body.appendChild(i), o.current = !0;
  }
  function f() {
    var p;
    (p = i.parentElement) === null || p === void 0 || p.removeChild(i), o.current = !1;
  }
  return kr(function() {
    return e ? a ? a(h) : h() : f(), f;
  }, [e]), kr(function() {
    u.length && (u.forEach(function(p) {
      return p();
    }), c(nO));
  }, [u]), [i, d];
}
function Tne(e) {
  var t = "rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7)), r = document.createElement("div");
  r.id = t;
  var n = r.style;
  n.position = "absolute", n.left = "0", n.top = "0", n.width = "100px", n.height = "100px", n.overflow = "scroll";
  var i, o;
  if (e) {
    var a = getComputedStyle(e);
    n.scrollbarColor = a.scrollbarColor, n.scrollbarWidth = a.scrollbarWidth;
    var s = getComputedStyle(e, "::-webkit-scrollbar"), l = parseInt(s.width, 10), u = parseInt(s.height, 10);
    try {
      var c = l ? "width: ".concat(s.width, ";") : "", d = u ? "height: ".concat(s.height, ";") : "";
      Gs(`
#`.concat(t, `::-webkit-scrollbar {
`).concat(c, `
`).concat(d, `
}`), t);
    } catch (p) {
      console.error(p), i = l, o = u;
    }
  }
  document.body.appendChild(r);
  var h = e && i && !isNaN(i) ? i : r.offsetWidth - r.clientWidth, f = e && o && !isNaN(o) ? o : r.offsetHeight - r.clientHeight;
  return document.body.removeChild(r), _g(t), {
    width: h,
    height: f
  };
}
function Pne(e) {
  return typeof document > "u" || !e || !(e instanceof Element) ? {
    width: 0,
    height: 0
  } : Tne(e);
}
function Mne() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var Dne = "rc-util-locker-".concat(Date.now()), iO = 0;
function Ane(e) {
  var t = !!e, r = E.useState(function() {
    return iO += 1, "".concat(Dne, "_").concat(iO);
  }), n = ae(r, 1), i = n[0];
  kr(function() {
    if (t) {
      var o = Pne(document.body).width, a = Mne();
      Gs(`
html body {
  overflow-y: hidden;
  `.concat(a ? "width: calc(100% - ".concat(o, "px);") : "", `
}`), i);
    } else
      _g(i);
    return function() {
      _g(i);
    };
  }, [t, i]);
}
var Ine = !1;
function One(e) {
  return Ine;
}
var oO = function(t) {
  return t === !1 ? !1 : !Zn() || !t ? null : typeof t == "string" ? document.querySelector(t) : typeof t == "function" ? t() : t;
}, Cv = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.open, n = e.autoLock, i = e.getContainer, o = e.debug, a = e.autoDestroy, s = a === void 0 ? !0 : a, l = e.children, u = E.useState(r), c = ae(u, 2), d = c[0], h = c[1], f = d || r;
  process.env.NODE_ENV !== "production" && Qt(Zn() || !r, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR."), E.useEffect(function() {
    (s || r) && h(r);
  }, [r, s]);
  var p = E.useState(function() {
    return oO(i);
  }), g = ae(p, 2), v = g[0], m = g[1];
  E.useEffect(function() {
    var D = oO(i);
    m(D ?? null);
  });
  var y = _ne(f && !v, o), C = ae(y, 2), S = C[0], b = C[1], w = v ?? S;
  Ane(n && r && Zn() && (w === S || w === document.body));
  var x = null;
  if (l && Jc(l) && t) {
    var R = l;
    x = R.ref;
  }
  var _ = Qc(x, t);
  if (!f || !Zn() || v === void 0)
    return null;
  var T = w === !1 || One(), P = l;
  return t && (P = /* @__PURE__ */ E.cloneElement(l, {
    ref: _
  })), /* @__PURE__ */ E.createElement(y5.Provider, {
    value: b
  }, T ? P : /* @__PURE__ */ yP(P, w));
});
process.env.NODE_ENV !== "production" && (Cv.displayName = "Portal");
var C5 = /* @__PURE__ */ E.createContext({});
function Lne() {
  var e = ee({}, E);
  return e.useId;
}
var aO = 0, sO = Lne();
const S5 = sO ? (
  // Use React `useId`
  function(t) {
    var r = sO();
    return t || (process.env.NODE_ENV === "test" ? "test-id" : r);
  }
) : (
  // Use compatible of `useId`
  function(t) {
    var r = E.useState("ssr-id"), n = ae(r, 2), i = n[0], o = n[1];
    return E.useEffect(function() {
      var a = aO;
      aO += 1, o("rc_unique_".concat(a));
    }, []), t || (process.env.NODE_ENV === "test" ? "test-id" : i);
  }
);
function lO(e, t, r) {
  var n = t;
  return !n && r && (n = "".concat(e, "-").concat(r)), n;
}
function uO(e, t) {
  var r = e["page".concat(t ? "Y" : "X", "Offset")], n = "scroll".concat(t ? "Top" : "Left");
  if (typeof r != "number") {
    var i = e.document;
    r = i.documentElement[n], typeof r != "number" && (r = i.body[n]);
  }
  return r;
}
function Fne(e) {
  var t = e.getBoundingClientRect(), r = {
    left: t.left,
    top: t.top
  }, n = e.ownerDocument, i = n.defaultView || n.parentWindow;
  return r.left += uO(i), r.top += uO(i, !0), r;
}
const Nne = /* @__PURE__ */ E.memo(function(e) {
  var t = e.children;
  return t;
}, function(e, t) {
  var r = t.shouldUpdate;
  return !r;
});
var cO = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
}, kne = {
  outline: "none"
}, w5 = /* @__PURE__ */ H.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.className, i = e.style, o = e.title, a = e.ariaId, s = e.footer, l = e.closable, u = e.closeIcon, c = e.onClose, d = e.children, h = e.bodyStyle, f = e.bodyProps, p = e.modalRender, g = e.onMouseDown, v = e.onMouseUp, m = e.holderRef, y = e.visible, C = e.forceRender, S = e.width, b = e.height, w = e.classNames, x = e.styles, R = H.useContext(C5), _ = R.panel, T = Qc(m, _), P = se(), D = se(), O = se();
  H.useImperativeHandle(t, function() {
    return {
      focus: function() {
        var k;
        (k = O.current) === null || k === void 0 || k.focus({
          preventScroll: !0
        });
      },
      changeActive: function(k) {
        var z = document, j = z.activeElement;
        k && j === D.current ? P.current.focus({
          preventScroll: !0
        }) : !k && j === P.current && D.current.focus({
          preventScroll: !0
        });
      }
    };
  });
  var A = {};
  S !== void 0 && (A.width = S), b !== void 0 && (A.height = b);
  var F = s ? /* @__PURE__ */ H.createElement("div", {
    className: ue("".concat(r, "-footer"), w == null ? void 0 : w.footer),
    style: ee({}, x == null ? void 0 : x.footer)
  }, s) : null, L = o ? /* @__PURE__ */ H.createElement("div", {
    className: ue("".concat(r, "-header"), w == null ? void 0 : w.header),
    style: ee({}, x == null ? void 0 : x.header)
  }, /* @__PURE__ */ H.createElement("div", {
    className: "".concat(r, "-title"),
    id: a
  }, o)) : null, N = Et(function() {
    return vt(l) === "object" && l !== null ? l : l ? {
      closeIcon: u ?? /* @__PURE__ */ H.createElement("span", {
        className: "".concat(r, "-close-x")
      })
    } : {};
  }, [l, u, r]), I = Zl(N, !0), B = vt(l) === "object" && l.disabled, M = l ? /* @__PURE__ */ H.createElement("button", $e({
    type: "button",
    onClick: c,
    "aria-label": "Close"
  }, I, {
    className: "".concat(r, "-close"),
    disabled: B
  }), N.closeIcon) : null, V = /* @__PURE__ */ H.createElement("div", {
    className: ue("".concat(r, "-content"), w == null ? void 0 : w.content),
    style: x == null ? void 0 : x.content
  }, M, L, /* @__PURE__ */ H.createElement("div", $e({
    className: ue("".concat(r, "-body"), w == null ? void 0 : w.body),
    style: ee(ee({}, h), x == null ? void 0 : x.body)
  }, f), d), F);
  return /* @__PURE__ */ H.createElement("div", {
    key: "dialog-element",
    role: "dialog",
    "aria-labelledby": o ? a : null,
    "aria-modal": "true",
    ref: T,
    style: ee(ee({}, i), A),
    className: ue(r, n),
    onMouseDown: g,
    onMouseUp: v
  }, /* @__PURE__ */ H.createElement("div", {
    tabIndex: 0,
    ref: P,
    style: cO,
    "aria-hidden": "true"
  }), /* @__PURE__ */ H.createElement("div", {
    ref: O,
    tabIndex: -1,
    style: kne
  }, /* @__PURE__ */ H.createElement(Nne, {
    shouldUpdate: y || C
  }, p ? p(V) : V)), /* @__PURE__ */ H.createElement("div", {
    tabIndex: 0,
    ref: D,
    style: cO,
    "aria-hidden": "true"
  }));
});
process.env.NODE_ENV !== "production" && (w5.displayName = "Panel");
var b5 = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.title, i = e.style, o = e.className, a = e.visible, s = e.forceRender, l = e.destroyOnClose, u = e.motionName, c = e.ariaId, d = e.onVisibleChanged, h = e.mousePosition, f = se(), p = E.useState(), g = ae(p, 2), v = g[0], m = g[1], y = {};
  v && (y.transformOrigin = v);
  function C() {
    var S = Fne(f.current);
    m(h && (h.x || h.y) ? "".concat(h.x - S.left, "px ").concat(h.y - S.top, "px") : "");
  }
  return /* @__PURE__ */ E.createElement(Cs, {
    visible: a,
    onVisibleChanged: d,
    onAppearPrepare: C,
    onEnterPrepare: C,
    forceRender: s,
    motionName: u,
    removeOnLeave: l,
    ref: f
  }, function(S, b) {
    var w = S.className, x = S.style;
    return /* @__PURE__ */ E.createElement(w5, $e({}, e, {
      ref: t,
      title: n,
      ariaId: c,
      prefixCls: r,
      holderRef: b,
      style: ee(ee(ee({}, x), i), y),
      className: ue(o, w)
    }));
  });
});
b5.displayName = "Content";
var Vne = function(t) {
  var r = t.prefixCls, n = t.style, i = t.visible, o = t.maskProps, a = t.motionName, s = t.className;
  return /* @__PURE__ */ E.createElement(Cs, {
    key: "mask",
    visible: i,
    motionName: a,
    leavedClassName: "".concat(r, "-mask-hidden")
  }, function(l, u) {
    var c = l.className, d = l.style;
    return /* @__PURE__ */ E.createElement("div", $e({
      ref: u,
      style: ee(ee({}, d), n),
      className: ue("".concat(r, "-mask"), c, s)
    }, o));
  });
}, Bne = function(t) {
  var r = t.prefixCls, n = r === void 0 ? "rc-dialog" : r, i = t.zIndex, o = t.visible, a = o === void 0 ? !1 : o, s = t.keyboard, l = s === void 0 ? !0 : s, u = t.focusTriggerAfterClose, c = u === void 0 ? !0 : u, d = t.wrapStyle, h = t.wrapClassName, f = t.wrapProps, p = t.onClose, g = t.afterOpenChange, v = t.afterClose, m = t.transitionName, y = t.animation, C = t.closable, S = C === void 0 ? !0 : C, b = t.mask, w = b === void 0 ? !0 : b, x = t.maskTransitionName, R = t.maskAnimation, _ = t.maskClosable, T = _ === void 0 ? !0 : _, P = t.maskStyle, D = t.maskProps, O = t.rootClassName, A = t.classNames, F = t.styles;
  process.env.NODE_ENV !== "production" && (["wrapStyle", "bodyStyle", "maskStyle"].forEach(function(ne) {
    fs(!(ne in t), "".concat(ne, " is deprecated, please use styles instead."));
  }), "wrapClassName" in t && fs(!1, "wrapClassName is deprecated, please use classNames instead."));
  var L = se(), N = se(), I = se(), B = E.useState(a), M = ae(B, 2), V = M[0], G = M[1], k = S5();
  function z() {
    YE(N.current, document.activeElement) || (L.current = document.activeElement);
  }
  function j() {
    if (!YE(N.current, document.activeElement)) {
      var ne;
      (ne = I.current) === null || ne === void 0 || ne.focus();
    }
  }
  function q(ne) {
    if (ne)
      j();
    else {
      if (G(!1), w && L.current && c) {
        try {
          L.current.focus({
            preventScroll: !0
          });
        } catch {
        }
        L.current = null;
      }
      V && (v == null || v());
    }
    g == null || g(ne);
  }
  function K(ne) {
    p == null || p(ne);
  }
  var Z = se(!1), re = se(), X = function() {
    clearTimeout(re.current), Z.current = !0;
  }, Y = function() {
    re.current = setTimeout(function() {
      Z.current = !1;
    });
  }, U = null;
  T && (U = function(ce) {
    Z.current ? Z.current = !1 : N.current === ce.target && K(ce);
  });
  function oe(ne) {
    if (l && ne.keyCode === Ae.ESC) {
      ne.stopPropagation(), K(ne);
      return;
    }
    a && ne.keyCode === Ae.TAB && I.current.changeActive(!ne.shiftKey);
  }
  Nt(function() {
    a && (G(!0), z());
  }, [a]), Nt(function() {
    return function() {
      clearTimeout(re.current);
    };
  }, []);
  var W = ee(ee(ee({
    zIndex: i
  }, d), F == null ? void 0 : F.wrapper), {}, {
    display: V ? null : "none"
  });
  return /* @__PURE__ */ E.createElement("div", $e({
    className: ue("".concat(n, "-root"), O)
  }, Zl(t, {
    data: !0
  })), /* @__PURE__ */ E.createElement(Vne, {
    prefixCls: n,
    visible: w && a,
    motionName: lO(n, x, R),
    style: ee(ee({
      zIndex: i
    }, P), F == null ? void 0 : F.mask),
    maskProps: D,
    className: A == null ? void 0 : A.mask
  }), /* @__PURE__ */ E.createElement("div", $e({
    tabIndex: -1,
    onKeyDown: oe,
    className: ue("".concat(n, "-wrap"), h, A == null ? void 0 : A.wrapper),
    ref: N,
    onClick: U,
    style: W
  }, f), /* @__PURE__ */ E.createElement(b5, $e({}, t, {
    onMouseDown: X,
    onMouseUp: Y,
    ref: I,
    closable: S,
    ariaId: k,
    prefixCls: n,
    visible: a && V,
    onClose: K,
    onVisibleChanged: q,
    motionName: lO(n, m, y)
  }))));
}, x5 = function(t) {
  var r = t.visible, n = t.getContainer, i = t.forceRender, o = t.destroyOnClose, a = o === void 0 ? !1 : o, s = t.afterClose, l = t.panelRef, u = E.useState(r), c = ae(u, 2), d = c[0], h = c[1], f = E.useMemo(function() {
    return {
      panel: l
    };
  }, [l]);
  return E.useEffect(function() {
    r && h(!0);
  }, [r]), !i && a && !d ? null : /* @__PURE__ */ E.createElement(C5.Provider, {
    value: f
  }, /* @__PURE__ */ E.createElement(Cv, {
    open: r || i || d,
    autoDestroy: !1,
    getContainer: n,
    autoLock: r || d
  }, /* @__PURE__ */ E.createElement(Bne, $e({}, t, {
    destroyOnClose: a,
    afterClose: function() {
      s == null || s(), h(!1);
    }
  }))));
};
x5.displayName = "Dialog";
var pc = "RC_FORM_INTERNAL_HOOKS", Wr = function() {
  Qt(!1, "Can not find FormContext. Please make sure you wrap Field under Form.");
}, Hh = /* @__PURE__ */ E.createContext({
  getFieldValue: Wr,
  getFieldsValue: Wr,
  getFieldError: Wr,
  getFieldWarning: Wr,
  getFieldsError: Wr,
  isFieldsTouched: Wr,
  isFieldTouched: Wr,
  isFieldValidating: Wr,
  isFieldsValidating: Wr,
  resetFields: Wr,
  setFields: Wr,
  setFieldValue: Wr,
  setFieldsValue: Wr,
  validateFields: Wr,
  submit: Wr,
  getInternalHooks: function() {
    return Wr(), {
      dispatch: Wr,
      initEntityValue: Wr,
      registerField: Wr,
      useSubscribe: Wr,
      setInitialValues: Wr,
      destroyForm: Wr,
      setCallbacks: Wr,
      registerWatch: Wr,
      getFields: Wr,
      setValidateMessages: Wr,
      setPreserve: Wr,
      getInitialValue: Wr
    };
  }
}), F0 = /* @__PURE__ */ E.createContext(null);
function bR(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function $ne(e) {
  return e && !!e._init;
}
function xR() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var ER = xR();
function Hne(e) {
  try {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  } catch {
    return typeof e == "function";
  }
}
function Gne(e, t, r) {
  if (bP()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, t);
  var i = new (e.bind.apply(e, n))();
  return r && xg(i, r.prototype), i;
}
function RR(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return RR = function(n) {
    if (n === null || !Hne(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (t !== void 0) {
      if (t.has(n)) return t.get(n);
      t.set(n, i);
    }
    function i() {
      return Gne(n, arguments, Eg(this).constructor);
    }
    return i.prototype = Object.create(n.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), xg(i, n);
  }, RR(e);
}
var zne = /%[sdj%]/g, E5 = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (E5 = function(t, r) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && r.every(function(n) {
    return typeof n == "string";
  }) && console.warn(t, r);
});
function _R(e) {
  if (!e || !e.length) return null;
  var t = {};
  return e.forEach(function(r) {
    var n = r.field;
    t[n] = t[n] || [], t[n].push(r);
  }), t;
}
function po(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  var i = 0, o = r.length;
  if (typeof e == "function")
    return e.apply(null, r);
  if (typeof e == "string") {
    var a = e.replace(zne, function(s) {
      if (s === "%%")
        return "%";
      if (i >= o)
        return s;
      switch (s) {
        case "%s":
          return String(r[i++]);
        case "%d":
          return Number(r[i++]);
        case "%j":
          try {
            return JSON.stringify(r[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return a;
  }
  return e;
}
function Wne(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function Bn(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || Wne(t) && typeof e == "string" && !e);
}
function jne(e, t, r) {
  var n = [], i = 0, o = e.length;
  function a(s) {
    n.push.apply(n, it(s || [])), i++, i === o && r(n);
  }
  e.forEach(function(s) {
    t(s, a);
  });
}
function dO(e, t, r) {
  var n = 0, i = e.length;
  function o(a) {
    if (a && a.length) {
      r(a);
      return;
    }
    var s = n;
    n = n + 1, s < i ? t(e[s], o) : r([]);
  }
  o([]);
}
function Une(e) {
  var t = [];
  return Object.keys(e).forEach(function(r) {
    t.push.apply(t, it(e[r] || []));
  }), t;
}
var hO = /* @__PURE__ */ function(e) {
  hu(r, e);
  var t = fu(r);
  function r(n, i) {
    var o;
    return Kn(this, r), o = t.call(this, "Async Validation Error"), te(cr(o), "errors", void 0), te(cr(o), "fields", void 0), o.errors = n, o.fields = i, o;
  }
  return Yn(r);
}(/* @__PURE__ */ RR(Error));
function Kne(e, t, r, n, i) {
  if (t.first) {
    var o = new Promise(function(h, f) {
      var p = function(m) {
        return n(m), m.length ? f(new hO(m, _R(m))) : h(i);
      }, g = Une(e);
      dO(g, r, p);
    });
    return o.catch(function(h) {
      return h;
    }), o;
  }
  var a = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], s = Object.keys(e), l = s.length, u = 0, c = [], d = new Promise(function(h, f) {
    var p = function(v) {
      if (c.push.apply(c, v), u++, u === l)
        return n(c), c.length ? f(new hO(c, _R(c))) : h(i);
    };
    s.length || (n(c), h(i)), s.forEach(function(g) {
      var v = e[g];
      a.indexOf(g) !== -1 ? dO(v, r, p) : jne(v, r, p);
    });
  });
  return d.catch(function(h) {
    return h;
  }), d;
}
function Yne(e) {
  return !!(e && e.message !== void 0);
}
function qne(e, t) {
  for (var r = e, n = 0; n < t.length; n++) {
    if (r == null)
      return r;
    r = r[t[n]];
  }
  return r;
}
function fO(e, t) {
  return function(r) {
    var n;
    return e.fullFields ? n = qne(t, e.fullFields) : n = t[r.field || e.fullField], Yne(r) ? (r.field = r.field || e.fullField, r.fieldValue = n, r) : {
      message: typeof r == "function" ? r() : r,
      fieldValue: n,
      field: r.field || e.fullField
    };
  };
}
function pO(e, t) {
  if (t) {
    for (var r in t)
      if (t.hasOwnProperty(r)) {
        var n = t[r];
        vt(n) === "object" && vt(e[r]) === "object" ? e[r] = ee(ee({}, e[r]), n) : e[r] = n;
      }
  }
  return e;
}
var Sd = "enum", Xne = function(t, r, n, i, o) {
  t[Sd] = Array.isArray(t[Sd]) ? t[Sd] : [], t[Sd].indexOf(r) === -1 && i.push(po(o.messages[Sd], t.fullField, t[Sd].join(", ")));
}, Zne = function(t, r, n, i, o) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(r) || i.push(po(o.messages.pattern.mismatch, t.fullField, r, t.pattern));
    else if (typeof t.pattern == "string") {
      var a = new RegExp(t.pattern);
      a.test(r) || i.push(po(o.messages.pattern.mismatch, t.fullField, r, t.pattern));
    }
  }
}, Qne = function(t, r, n, i, o) {
  var a = typeof t.len == "number", s = typeof t.min == "number", l = typeof t.max == "number", u = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c = r, d = null, h = typeof r == "number", f = typeof r == "string", p = Array.isArray(r);
  if (h ? d = "number" : f ? d = "string" : p && (d = "array"), !d)
    return !1;
  p && (c = r.length), f && (c = r.replace(u, "_").length), a ? c !== t.len && i.push(po(o.messages[d].len, t.fullField, t.len)) : s && !l && c < t.min ? i.push(po(o.messages[d].min, t.fullField, t.min)) : l && !s && c > t.max ? i.push(po(o.messages[d].max, t.fullField, t.max)) : s && l && (c < t.min || c > t.max) && i.push(po(o.messages[d].range, t.fullField, t.min, t.max));
}, R5 = function(t, r, n, i, o, a) {
  t.required && (!n.hasOwnProperty(t.field) || Bn(r, a || t.type)) && i.push(po(o.messages.required, t.fullField));
}, Cm;
const Jne = function() {
  if (Cm)
    return Cm;
  var e = "[a-fA-F\\d:]", t = function(w) {
    return w && w.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(e, ")|(?<=").concat(e, ")(?=\\s|$))") : "";
  }, r = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", n = "[a-fA-F\\d]{1,4}", i = [
    "(?:".concat(n, ":){7}(?:").concat(n, "|:)"),
    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
    "(?:".concat(n, ":){6}(?:").concat(r, "|:").concat(n, "|:)"),
    // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
    "(?:".concat(n, ":){5}(?::").concat(r, "|(?::").concat(n, "){1,2}|:)"),
    // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
    "(?:".concat(n, ":){4}(?:(?::").concat(n, "){0,1}:").concat(r, "|(?::").concat(n, "){1,3}|:)"),
    // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
    "(?:".concat(n, ":){3}(?:(?::").concat(n, "){0,2}:").concat(r, "|(?::").concat(n, "){1,4}|:)"),
    // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
    "(?:".concat(n, ":){2}(?:(?::").concat(n, "){0,3}:").concat(r, "|(?::").concat(n, "){1,5}|:)"),
    // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
    "(?:".concat(n, ":){1}(?:(?::").concat(n, "){0,4}:").concat(r, "|(?::").concat(n, "){1,6}|:)"),
    // 1::              1::3:4:5:6:7:8   1::8            1::
    "(?::(?:(?::".concat(n, "){0,5}:").concat(r, "|(?::").concat(n, "){1,7}|:))")
    // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
  ], o = "(?:%[0-9a-zA-Z]{1,})?", a = "(?:".concat(i.join("|"), ")").concat(o), s = new RegExp("(?:^".concat(r, "$)|(?:^").concat(a, "$)")), l = new RegExp("^".concat(r, "$")), u = new RegExp("^".concat(a, "$")), c = function(w) {
    return w && w.exact ? s : new RegExp("(?:".concat(t(w)).concat(r).concat(t(w), ")|(?:").concat(t(w)).concat(a).concat(t(w), ")"), "g");
  };
  c.v4 = function(b) {
    return b && b.exact ? l : new RegExp("".concat(t(b)).concat(r).concat(t(b)), "g");
  }, c.v6 = function(b) {
    return b && b.exact ? u : new RegExp("".concat(t(b)).concat(a).concat(t(b)), "g");
  };
  var d = "(?:(?:[a-z]+:)?//)", h = "(?:\\S+(?::\\S*)?@)?", f = c.v4().source, p = c.v6().source, g = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", v = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", m = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", y = "(?::\\d{2,5})?", C = '(?:[/?#][^\\s"]*)?', S = "(?:".concat(d, "|www\\.)").concat(h, "(?:localhost|").concat(f, "|").concat(p, "|").concat(g).concat(v).concat(m, ")").concat(y).concat(C);
  return Cm = new RegExp("(?:^".concat(S, "$)"), "i"), Cm;
};
var gO = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, Tp = {
  integer: function(t) {
    return Tp.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return Tp.number(t) && !Tp.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(t);
    } catch {
      return !1;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? !1 : typeof t == "number";
  },
  object: function(t) {
    return vt(t) === "object" && !Tp.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(gO.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(Jne());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(gO.hex);
  }
}, eie = function(t, r, n, i, o) {
  if (t.required && r === void 0) {
    R5(t, r, n, i, o);
    return;
  }
  var a = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = t.type;
  a.indexOf(s) > -1 ? Tp[s](r) || i.push(po(o.messages.types[s], t.fullField, t.type)) : s && vt(r) !== t.type && i.push(po(o.messages.types[s], t.fullField, t.type));
}, tie = function(t, r, n, i, o) {
  (/^\s+$/.test(r) || r === "") && i.push(po(o.messages.whitespace, t.fullField));
};
const yr = {
  required: R5,
  whitespace: tie,
  type: eie,
  range: Qne,
  enum: Xne,
  pattern: Zne
};
var rie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r) && !t.required)
      return n();
    yr.required(t, r, i, a, o);
  }
  n(a);
}, nie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (r == null && !t.required)
      return n();
    yr.required(t, r, i, a, o, "array"), r != null && (yr.type(t, r, i, a, o), yr.range(t, r, i, a, o));
  }
  n(a);
}, iie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r) && !t.required)
      return n();
    yr.required(t, r, i, a, o), r !== void 0 && yr.type(t, r, i, a, o);
  }
  n(a);
}, oie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r, "date") && !t.required)
      return n();
    if (yr.required(t, r, i, a, o), !Bn(r, "date")) {
      var l;
      r instanceof Date ? l = r : l = new Date(r), yr.type(t, l, i, a, o), l && yr.range(t, l.getTime(), i, a, o);
    }
  }
  n(a);
}, aie = "enum", sie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r) && !t.required)
      return n();
    yr.required(t, r, i, a, o), r !== void 0 && yr[aie](t, r, i, a, o);
  }
  n(a);
}, lie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r) && !t.required)
      return n();
    yr.required(t, r, i, a, o), r !== void 0 && (yr.type(t, r, i, a, o), yr.range(t, r, i, a, o));
  }
  n(a);
}, uie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r) && !t.required)
      return n();
    yr.required(t, r, i, a, o), r !== void 0 && (yr.type(t, r, i, a, o), yr.range(t, r, i, a, o));
  }
  n(a);
}, cie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r) && !t.required)
      return n();
    yr.required(t, r, i, a, o), r !== void 0 && yr.type(t, r, i, a, o);
  }
  n(a);
}, die = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (r === "" && (r = void 0), Bn(r) && !t.required)
      return n();
    yr.required(t, r, i, a, o), r !== void 0 && (yr.type(t, r, i, a, o), yr.range(t, r, i, a, o));
  }
  n(a);
}, hie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r) && !t.required)
      return n();
    yr.required(t, r, i, a, o), r !== void 0 && yr.type(t, r, i, a, o);
  }
  n(a);
}, fie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r, "string") && !t.required)
      return n();
    yr.required(t, r, i, a, o), Bn(r, "string") || yr.pattern(t, r, i, a, o);
  }
  n(a);
}, pie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r) && !t.required)
      return n();
    yr.required(t, r, i, a, o), Bn(r) || yr.type(t, r, i, a, o);
  }
  n(a);
}, gie = function(t, r, n, i, o) {
  var a = [], s = Array.isArray(r) ? "array" : vt(r);
  yr.required(t, r, i, a, o, s), n(a);
}, vie = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (Bn(r, "string") && !t.required)
      return n();
    yr.required(t, r, i, a, o, "string"), Bn(r, "string") || (yr.type(t, r, i, a, o), yr.range(t, r, i, a, o), yr.pattern(t, r, i, a, o), t.whitespace === !0 && yr.whitespace(t, r, i, a, o));
  }
  n(a);
}, ub = function(t, r, n, i, o) {
  var a = t.type, s = [], l = t.required || !t.required && i.hasOwnProperty(t.field);
  if (l) {
    if (Bn(r, a) && !t.required)
      return n();
    yr.required(t, r, i, s, o, a), Bn(r, a) || yr.type(t, r, i, s, o);
  }
  n(s);
};
const Xp = {
  string: vie,
  method: cie,
  number: die,
  boolean: iie,
  regexp: pie,
  integer: uie,
  float: lie,
  array: nie,
  object: hie,
  enum: sie,
  pattern: fie,
  date: oie,
  url: ub,
  hex: ub,
  email: ub,
  required: gie,
  any: rie
};
var Sv = /* @__PURE__ */ function() {
  function e(t) {
    Kn(this, e), te(this, "rules", null), te(this, "_messages", ER), this.define(t);
  }
  return Yn(e, [{
    key: "define",
    value: function(r) {
      var n = this;
      if (!r)
        throw new Error("Cannot configure a schema with no rules");
      if (vt(r) !== "object" || Array.isArray(r))
        throw new Error("Rules must be an object");
      this.rules = {}, Object.keys(r).forEach(function(i) {
        var o = r[i];
        n.rules[i] = Array.isArray(o) ? o : [o];
      });
    }
  }, {
    key: "messages",
    value: function(r) {
      return r && (this._messages = pO(xR(), r)), this._messages;
    }
  }, {
    key: "validate",
    value: function(r) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      }, a = r, s = i, l = o;
      if (typeof s == "function" && (l = s, s = {}), !this.rules || Object.keys(this.rules).length === 0)
        return l && l(null, a), Promise.resolve(a);
      function u(p) {
        var g = [], v = {};
        function m(C) {
          if (Array.isArray(C)) {
            var S;
            g = (S = g).concat.apply(S, it(C));
          } else
            g.push(C);
        }
        for (var y = 0; y < p.length; y++)
          m(p[y]);
        g.length ? (v = _R(g), l(g, v)) : l(null, a);
      }
      if (s.messages) {
        var c = this.messages();
        c === ER && (c = xR()), pO(c, s.messages), s.messages = c;
      } else
        s.messages = this.messages();
      var d = {}, h = s.keys || Object.keys(this.rules);
      h.forEach(function(p) {
        var g = n.rules[p], v = a[p];
        g.forEach(function(m) {
          var y = m;
          typeof y.transform == "function" && (a === r && (a = ee({}, a)), v = a[p] = y.transform(v), v != null && (y.type = y.type || (Array.isArray(v) ? "array" : vt(v)))), typeof y == "function" ? y = {
            validator: y
          } : y = ee({}, y), y.validator = n.getValidationMethod(y), y.validator && (y.field = p, y.fullField = y.fullField || p, y.type = n.getType(y), d[p] = d[p] || [], d[p].push({
            rule: y,
            value: v,
            source: a,
            field: p
          }));
        });
      });
      var f = {};
      return Kne(d, s, function(p, g) {
        var v = p.rule, m = (v.type === "object" || v.type === "array") && (vt(v.fields) === "object" || vt(v.defaultField) === "object");
        m = m && (v.required || !v.required && p.value), v.field = p.field;
        function y(x, R) {
          return ee(ee({}, R), {}, {
            fullField: "".concat(v.fullField, ".").concat(x),
            fullFields: v.fullFields ? [].concat(it(v.fullFields), [x]) : [x]
          });
        }
        function C() {
          var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], R = Array.isArray(x) ? x : [x];
          !s.suppressWarning && R.length && e.warning("async-validator:", R), R.length && v.message !== void 0 && (R = [].concat(v.message));
          var _ = R.map(fO(v, a));
          if (s.first && _.length)
            return f[v.field] = 1, g(_);
          if (!m)
            g(_);
          else {
            if (v.required && !p.value)
              return v.message !== void 0 ? _ = [].concat(v.message).map(fO(v, a)) : s.error && (_ = [s.error(v, po(s.messages.required, v.field))]), g(_);
            var T = {};
            v.defaultField && Object.keys(p.value).map(function(O) {
              T[O] = v.defaultField;
            }), T = ee(ee({}, T), p.rule.fields);
            var P = {};
            Object.keys(T).forEach(function(O) {
              var A = T[O], F = Array.isArray(A) ? A : [A];
              P[O] = F.map(y.bind(null, O));
            });
            var D = new e(P);
            D.messages(s.messages), p.rule.options && (p.rule.options.messages = s.messages, p.rule.options.error = s.error), D.validate(p.value, p.rule.options || s, function(O) {
              var A = [];
              _ && _.length && A.push.apply(A, it(_)), O && O.length && A.push.apply(A, it(O)), g(A.length ? A : null);
            });
          }
        }
        var S;
        if (v.asyncValidator)
          S = v.asyncValidator(v, p.value, C, p.source, s);
        else if (v.validator) {
          try {
            S = v.validator(v, p.value, C, p.source, s);
          } catch (x) {
            var b, w;
            (b = (w = console).error) === null || b === void 0 || b.call(w, x), s.suppressValidatorError || setTimeout(function() {
              throw x;
            }, 0), C(x.message);
          }
          S === !0 ? C() : S === !1 ? C(typeof v.message == "function" ? v.message(v.fullField || v.field) : v.message || "".concat(v.fullField || v.field, " fails")) : S instanceof Array ? C(S) : S instanceof Error && C(S.message);
        }
        S && S.then && S.then(function() {
          return C();
        }, function(x) {
          return C(x);
        });
      }, function(p) {
        u(p);
      }, a);
    }
  }, {
    key: "getType",
    value: function(r) {
      if (r.type === void 0 && r.pattern instanceof RegExp && (r.type = "pattern"), typeof r.validator != "function" && r.type && !Xp.hasOwnProperty(r.type))
        throw new Error(po("Unknown rule type %s", r.type));
      return r.type || "string";
    }
  }, {
    key: "getValidationMethod",
    value: function(r) {
      if (typeof r.validator == "function")
        return r.validator;
      var n = Object.keys(r), i = n.indexOf("message");
      return i !== -1 && n.splice(i, 1), n.length === 1 && n[0] === "required" ? Xp.required : Xp[this.getType(r)] || void 0;
    }
  }]), e;
}();
te(Sv, "register", function(t, r) {
  if (typeof r != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  Xp[t] = r;
});
te(Sv, "warning", E5);
te(Sv, "messages", ER);
te(Sv, "validators", Xp);
var io = "'${name}' is not a valid ${type}", _5 = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: io,
    method: io,
    array: io,
    object: io,
    number: io,
    date: io,
    boolean: io,
    integer: io,
    float: io,
    regexp: io,
    email: io,
    url: io,
    hex: io
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
}, vO = Sv;
function mie(e, t) {
  return e.replace(/\$\{\w+\}/g, function(r) {
    var n = r.slice(2, -1);
    return t[n];
  });
}
var mO = "CODE_LOGIC_ERROR";
function TR(e, t, r, n, i) {
  return PR.apply(this, arguments);
}
function PR() {
  return PR = td(/* @__PURE__ */ Di().mark(function e(t, r, n, i, o) {
    var a, s, l, u, c, d, h, f, p;
    return Di().wrap(function(v) {
      for (; ; ) switch (v.prev = v.next) {
        case 0:
          return a = ee({}, n), delete a.ruleIndex, vO.warning = function() {
          }, a.validator && (s = a.validator, a.validator = function() {
            try {
              return s.apply(void 0, arguments);
            } catch (m) {
              return console.error(m), Promise.reject(mO);
            }
          }), l = null, a && a.type === "array" && a.defaultField && (l = a.defaultField, delete a.defaultField), u = new vO(te({}, t, [a])), c = uh(_5, i.validateMessages), u.messages(c), d = [], v.prev = 10, v.next = 13, Promise.resolve(u.validate(te({}, t, r), ee({}, i)));
        case 13:
          v.next = 18;
          break;
        case 15:
          v.prev = 15, v.t0 = v.catch(10), v.t0.errors && (d = v.t0.errors.map(function(m, y) {
            var C = m.message, S = C === mO ? c.default : C;
            return /* @__PURE__ */ E.isValidElement(S) ? (
              // Wrap ReactNode with `key`
              /* @__PURE__ */ E.cloneElement(S, {
                key: "error_".concat(y)
              })
            ) : S;
          }));
        case 18:
          if (!(!d.length && l)) {
            v.next = 23;
            break;
          }
          return v.next = 21, Promise.all(r.map(function(m, y) {
            return TR("".concat(t, ".").concat(y), m, l, i, o);
          }));
        case 21:
          return h = v.sent, v.abrupt("return", h.reduce(function(m, y) {
            return [].concat(it(m), it(y));
          }, []));
        case 23:
          return f = ee(ee({}, n), {}, {
            name: t,
            enum: (n.enum || []).join(", ")
          }, o), p = d.map(function(m) {
            return typeof m == "string" ? mie(m, f) : m;
          }), v.abrupt("return", p);
        case 26:
        case "end":
          return v.stop();
      }
    }, e, null, [[10, 15]]);
  })), PR.apply(this, arguments);
}
function yie(e, t, r, n, i, o) {
  var a = e.join("."), s = r.map(function(c, d) {
    var h = c.validator, f = ee(ee({}, c), {}, {
      ruleIndex: d
    });
    return h && (f.validator = function(p, g, v) {
      var m = !1, y = function() {
        for (var b = arguments.length, w = new Array(b), x = 0; x < b; x++)
          w[x] = arguments[x];
        Promise.resolve().then(function() {
          Qt(!m, "Your validator function has already return a promise. `callback` will be ignored."), m || v.apply(void 0, w);
        });
      }, C = h(p, g, y);
      m = C && typeof C.then == "function" && typeof C.catch == "function", Qt(m, "`callback` is deprecated. Please return a promise instead."), m && C.then(function() {
        v();
      }).catch(function(S) {
        v(S || " ");
      });
    }), f;
  }).sort(function(c, d) {
    var h = c.warningOnly, f = c.ruleIndex, p = d.warningOnly, g = d.ruleIndex;
    return !!h == !!p ? f - g : h ? 1 : -1;
  }), l;
  if (i === !0)
    l = new Promise(/* @__PURE__ */ function() {
      var c = td(/* @__PURE__ */ Di().mark(function d(h, f) {
        var p, g, v;
        return Di().wrap(function(y) {
          for (; ; ) switch (y.prev = y.next) {
            case 0:
              p = 0;
            case 1:
              if (!(p < s.length)) {
                y.next = 12;
                break;
              }
              return g = s[p], y.next = 5, TR(a, t, g, n, o);
            case 5:
              if (v = y.sent, !v.length) {
                y.next = 9;
                break;
              }
              return f([{
                errors: v,
                rule: g
              }]), y.abrupt("return");
            case 9:
              p += 1, y.next = 1;
              break;
            case 12:
              h([]);
            case 13:
            case "end":
              return y.stop();
          }
        }, d);
      }));
      return function(d, h) {
        return c.apply(this, arguments);
      };
    }());
  else {
    var u = s.map(function(c) {
      return TR(a, t, c, n, o).then(function(d) {
        return {
          errors: d,
          rule: c
        };
      });
    });
    l = (i ? Sie(u) : Cie(u)).then(function(c) {
      return Promise.reject(c);
    });
  }
  return l.catch(function(c) {
    return c;
  }), l;
}
function Cie(e) {
  return MR.apply(this, arguments);
}
function MR() {
  return MR = td(/* @__PURE__ */ Di().mark(function e(t) {
    return Di().wrap(function(n) {
      for (; ; ) switch (n.prev = n.next) {
        case 0:
          return n.abrupt("return", Promise.all(t).then(function(i) {
            var o, a = (o = []).concat.apply(o, it(i));
            return a;
          }));
        case 1:
        case "end":
          return n.stop();
      }
    }, e);
  })), MR.apply(this, arguments);
}
function Sie(e) {
  return DR.apply(this, arguments);
}
function DR() {
  return DR = td(/* @__PURE__ */ Di().mark(function e(t) {
    var r;
    return Di().wrap(function(i) {
      for (; ; ) switch (i.prev = i.next) {
        case 0:
          return r = 0, i.abrupt("return", new Promise(function(o) {
            t.forEach(function(a) {
              a.then(function(s) {
                s.errors.length && o([s]), r += 1, r === t.length && o([]);
              });
            });
          }));
        case 2:
        case "end":
          return i.stop();
      }
    }, e);
  })), DR.apply(this, arguments);
}
function Cn(e) {
  return bR(e);
}
function yO(e, t) {
  var r = {};
  return t.forEach(function(n) {
    var i = rs(e, n);
    r = ya(r, n, i);
  }), r;
}
function wh(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return e && e.some(function(n) {
    return T5(t, n, r);
  });
}
function T5(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return !e || !t || !r && e.length !== t.length ? !1 : t.every(function(n, i) {
    return e[i] === n;
  });
}
function wie(e, t) {
  if (e === t)
    return !0;
  if (!e && t || e && !t || !e || !t || vt(e) !== "object" || vt(t) !== "object")
    return !1;
  var r = Object.keys(e), n = Object.keys(t), i = new Set([].concat(r, n));
  return it(i).every(function(o) {
    var a = e[o], s = t[o];
    return typeof a == "function" && typeof s == "function" ? !0 : a === s;
  });
}
function bie(e) {
  var t = arguments.length <= 1 ? void 0 : arguments[1];
  return t && t.target && vt(t.target) === "object" && e in t.target ? t.target[e] : t;
}
function CO(e, t, r) {
  var n = e.length;
  if (t < 0 || t >= n || r < 0 || r >= n)
    return e;
  var i = e[t], o = t - r;
  return o > 0 ? [].concat(it(e.slice(0, r)), [i], it(e.slice(r, t)), it(e.slice(t + 1, n))) : o < 0 ? [].concat(it(e.slice(0, t)), it(e.slice(t + 1, r + 1)), [i], it(e.slice(r + 1, n))) : e;
}
var xie = ["name"], _o = [];
function SO(e, t, r, n, i, o) {
  return typeof e == "function" ? e(t, r, "source" in o ? {
    source: o.source
  } : {}) : n !== i;
}
var zP = /* @__PURE__ */ function(e) {
  hu(r, e);
  var t = fu(r);
  function r(n) {
    var i;
    if (Kn(this, r), i = t.call(this, n), te(cr(i), "state", {
      resetCount: 0
    }), te(cr(i), "cancelRegisterFunc", null), te(cr(i), "mounted", !1), te(cr(i), "touched", !1), te(cr(i), "dirty", !1), te(cr(i), "validatePromise", void 0), te(cr(i), "prevValidating", void 0), te(cr(i), "errors", _o), te(cr(i), "warnings", _o), te(cr(i), "cancelRegister", function() {
      var l = i.props, u = l.preserve, c = l.isListField, d = l.name;
      i.cancelRegisterFunc && i.cancelRegisterFunc(c, u, Cn(d)), i.cancelRegisterFunc = null;
    }), te(cr(i), "getNamePath", function() {
      var l = i.props, u = l.name, c = l.fieldContext, d = c.prefixName, h = d === void 0 ? [] : d;
      return u !== void 0 ? [].concat(it(h), it(u)) : [];
    }), te(cr(i), "getRules", function() {
      var l = i.props, u = l.rules, c = u === void 0 ? [] : u, d = l.fieldContext;
      return c.map(function(h) {
        return typeof h == "function" ? h(d) : h;
      });
    }), te(cr(i), "refresh", function() {
      i.mounted && i.setState(function(l) {
        var u = l.resetCount;
        return {
          resetCount: u + 1
        };
      });
    }), te(cr(i), "metaCache", null), te(cr(i), "triggerMetaEvent", function(l) {
      var u = i.props.onMetaChange;
      if (u) {
        var c = ee(ee({}, i.getMeta()), {}, {
          destroy: l
        });
        Nh(i.metaCache, c) || u(c), i.metaCache = c;
      } else
        i.metaCache = null;
    }), te(cr(i), "onStoreChange", function(l, u, c) {
      var d = i.props, h = d.shouldUpdate, f = d.dependencies, p = f === void 0 ? [] : f, g = d.onReset, v = c.store, m = i.getNamePath(), y = i.getValue(l), C = i.getValue(v), S = u && wh(u, m);
      switch (c.type === "valueUpdate" && c.source === "external" && !Nh(y, C) && (i.touched = !0, i.dirty = !0, i.validatePromise = null, i.errors = _o, i.warnings = _o, i.triggerMetaEvent()), c.type) {
        case "reset":
          if (!u || S) {
            i.touched = !1, i.dirty = !1, i.validatePromise = void 0, i.errors = _o, i.warnings = _o, i.triggerMetaEvent(), g == null || g(), i.refresh();
            return;
          }
          break;
        case "remove": {
          if (h) {
            i.reRender();
            return;
          }
          break;
        }
        case "setField": {
          var b = c.data;
          if (S) {
            "touched" in b && (i.touched = b.touched), "validating" in b && !("originRCField" in b) && (i.validatePromise = b.validating ? Promise.resolve([]) : null), "errors" in b && (i.errors = b.errors || _o), "warnings" in b && (i.warnings = b.warnings || _o), i.dirty = !0, i.triggerMetaEvent(), i.reRender();
            return;
          } else if ("value" in b && wh(u, m, !0)) {
            i.reRender();
            return;
          }
          if (h && !m.length && SO(h, l, v, y, C, c)) {
            i.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var w = p.map(Cn);
          if (w.some(function(x) {
            return wh(c.relatedFields, x);
          })) {
            i.reRender();
            return;
          }
          break;
        }
        default:
          if (S || (!p.length || m.length || h) && SO(h, l, v, y, C, c)) {
            i.reRender();
            return;
          }
          break;
      }
      h === !0 && i.reRender();
    }), te(cr(i), "validateRules", function(l) {
      var u = i.getNamePath(), c = i.getValue(), d = l || {}, h = d.triggerName, f = d.validateOnly, p = f === void 0 ? !1 : f, g = Promise.resolve().then(/* @__PURE__ */ td(/* @__PURE__ */ Di().mark(function v() {
        var m, y, C, S, b, w, x;
        return Di().wrap(function(_) {
          for (; ; ) switch (_.prev = _.next) {
            case 0:
              if (i.mounted) {
                _.next = 2;
                break;
              }
              return _.abrupt("return", []);
            case 2:
              if (m = i.props, y = m.validateFirst, C = y === void 0 ? !1 : y, S = m.messageVariables, b = m.validateDebounce, w = i.getRules(), h && (w = w.filter(function(T) {
                return T;
              }).filter(function(T) {
                var P = T.validateTrigger;
                if (!P)
                  return !0;
                var D = bR(P);
                return D.includes(h);
              })), !(b && h)) {
                _.next = 10;
                break;
              }
              return _.next = 8, new Promise(function(T) {
                setTimeout(T, b);
              });
            case 8:
              if (i.validatePromise === g) {
                _.next = 10;
                break;
              }
              return _.abrupt("return", []);
            case 10:
              return x = yie(u, c, w, l, C, S), x.catch(function(T) {
                return T;
              }).then(function() {
                var T = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _o;
                if (i.validatePromise === g) {
                  var P;
                  i.validatePromise = null;
                  var D = [], O = [];
                  (P = T.forEach) === null || P === void 0 || P.call(T, function(A) {
                    var F = A.rule.warningOnly, L = A.errors, N = L === void 0 ? _o : L;
                    F ? O.push.apply(O, it(N)) : D.push.apply(D, it(N));
                  }), i.errors = D, i.warnings = O, i.triggerMetaEvent(), i.reRender();
                }
              }), _.abrupt("return", x);
            case 13:
            case "end":
              return _.stop();
          }
        }, v);
      })));
      return p || (i.validatePromise = g, i.dirty = !0, i.errors = _o, i.warnings = _o, i.triggerMetaEvent(), i.reRender()), g;
    }), te(cr(i), "isFieldValidating", function() {
      return !!i.validatePromise;
    }), te(cr(i), "isFieldTouched", function() {
      return i.touched;
    }), te(cr(i), "isFieldDirty", function() {
      if (i.dirty || i.props.initialValue !== void 0)
        return !0;
      var l = i.props.fieldContext, u = l.getInternalHooks(pc), c = u.getInitialValue;
      return c(i.getNamePath()) !== void 0;
    }), te(cr(i), "getErrors", function() {
      return i.errors;
    }), te(cr(i), "getWarnings", function() {
      return i.warnings;
    }), te(cr(i), "isListField", function() {
      return i.props.isListField;
    }), te(cr(i), "isList", function() {
      return i.props.isList;
    }), te(cr(i), "isPreserve", function() {
      return i.props.preserve;
    }), te(cr(i), "getMeta", function() {
      i.prevValidating = i.isFieldValidating();
      var l = {
        touched: i.isFieldTouched(),
        validating: i.prevValidating,
        errors: i.errors,
        warnings: i.warnings,
        name: i.getNamePath(),
        validated: i.validatePromise === null
      };
      return l;
    }), te(cr(i), "getOnlyChild", function(l) {
      if (typeof l == "function") {
        var u = i.getMeta();
        return ee(ee({}, i.getOnlyChild(l(i.getControlled(), u, i.props.fieldContext))), {}, {
          isFunction: !0
        });
      }
      var c = Zo(l);
      return c.length !== 1 || !/* @__PURE__ */ E.isValidElement(c[0]) ? {
        child: c,
        isFunction: !1
      } : {
        child: c[0],
        isFunction: !1
      };
    }), te(cr(i), "getValue", function(l) {
      var u = i.props.fieldContext.getFieldsValue, c = i.getNamePath();
      return rs(l || u(!0), c);
    }), te(cr(i), "getControlled", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = i.props, c = u.name, d = u.trigger, h = u.validateTrigger, f = u.getValueFromEvent, p = u.normalize, g = u.valuePropName, v = u.getValueProps, m = u.fieldContext, y = h !== void 0 ? h : m.validateTrigger, C = i.getNamePath(), S = m.getInternalHooks, b = m.getFieldsValue, w = S(pc), x = w.dispatch, R = i.getValue(), _ = v || function(A) {
        return te({}, g, A);
      }, T = l[d], P = c !== void 0 ? _(R) : {};
      process.env.NODE_ENV !== "production" && P && Object.keys(P).forEach(function(A) {
        Qt(typeof P[A] != "function", "It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: ".concat(A, ")"));
      });
      var D = ee(ee({}, l), P);
      D[d] = function() {
        i.touched = !0, i.dirty = !0, i.triggerMetaEvent();
        for (var A, F = arguments.length, L = new Array(F), N = 0; N < F; N++)
          L[N] = arguments[N];
        f ? A = f.apply(void 0, L) : A = bie.apply(void 0, [g].concat(L)), p && (A = p(A, R, b(!0))), x({
          type: "updateValue",
          namePath: C,
          value: A
        }), T && T.apply(void 0, L);
      };
      var O = bR(y || []);
      return O.forEach(function(A) {
        var F = D[A];
        D[A] = function() {
          F && F.apply(void 0, arguments);
          var L = i.props.rules;
          L && L.length && x({
            type: "validateField",
            namePath: C,
            triggerName: A
          });
        };
      }), D;
    }), n.fieldContext) {
      var o = n.fieldContext.getInternalHooks, a = o(pc), s = a.initEntityValue;
      s(cr(i));
    }
    return i;
  }
  return Yn(r, [{
    key: "componentDidMount",
    value: function() {
      var i = this.props, o = i.shouldUpdate, a = i.fieldContext;
      if (this.mounted = !0, a) {
        var s = a.getInternalHooks, l = s(pc), u = l.registerField;
        this.cancelRegisterFunc = u(this);
      }
      o === !0 && this.reRender();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.cancelRegister(), this.triggerMetaEvent(!0), this.mounted = !1;
    }
  }, {
    key: "reRender",
    value: function() {
      this.mounted && this.forceUpdate();
    }
  }, {
    key: "render",
    value: function() {
      var i = this.state.resetCount, o = this.props.children, a = this.getOnlyChild(o), s = a.child, l = a.isFunction, u;
      return l ? u = s : /* @__PURE__ */ E.isValidElement(s) ? u = /* @__PURE__ */ E.cloneElement(s, this.getControlled(s.props)) : (Qt(!s, "`children` of Field is not validate ReactElement."), u = s), /* @__PURE__ */ E.createElement(E.Fragment, {
        key: i
      }, u);
    }
  }]), r;
}(E.Component);
te(zP, "contextType", Hh);
te(zP, "defaultProps", {
  trigger: "onChange",
  valuePropName: "value"
});
function P5(e) {
  var t = e.name, r = $t(e, xie), n = E.useContext(Hh), i = E.useContext(F0), o = t !== void 0 ? Cn(t) : void 0, a = "keep";
  return r.isListField || (a = "_".concat((o || []).join("_"))), process.env.NODE_ENV !== "production" && r.preserve === !1 && r.isListField && o.length <= 1 && Qt(!1, "`preserve` should not apply on Form.List fields."), /* @__PURE__ */ E.createElement(zP, $e({
    key: a,
    name: o,
    isListField: !!i
  }, r, {
    fieldContext: n
  }));
}
function Eie(e) {
  var t = e.name, r = e.initialValue, n = e.children, i = e.rules, o = e.validateTrigger, a = e.isListField, s = E.useContext(Hh), l = E.useContext(F0), u = E.useRef({
    keys: [],
    id: 0
  }), c = u.current, d = E.useMemo(function() {
    var g = Cn(s.prefixName) || [];
    return [].concat(it(g), it(Cn(t)));
  }, [s.prefixName, t]), h = E.useMemo(function() {
    return ee(ee({}, s), {}, {
      prefixName: d
    });
  }, [s, d]), f = E.useMemo(function() {
    return {
      getKey: function(v) {
        var m = d.length, y = v[m];
        return [c.keys[y], v.slice(m + 1)];
      }
    };
  }, [d]);
  if (typeof n != "function")
    return Qt(!1, "Form.List only accepts function as children."), null;
  var p = function(v, m, y) {
    var C = y.source;
    return C === "internal" ? !1 : v !== m;
  };
  return /* @__PURE__ */ E.createElement(F0.Provider, {
    value: f
  }, /* @__PURE__ */ E.createElement(Hh.Provider, {
    value: h
  }, /* @__PURE__ */ E.createElement(P5, {
    name: [],
    shouldUpdate: p,
    rules: i,
    validateTrigger: o,
    initialValue: r,
    isList: !0,
    isListField: a ?? !!l
  }, function(g, v) {
    var m = g.value, y = m === void 0 ? [] : m, C = g.onChange, S = s.getFieldValue, b = function() {
      var _ = S(d || []);
      return _ || [];
    }, w = {
      add: function(_, T) {
        var P = b();
        T >= 0 && T <= P.length ? (c.keys = [].concat(it(c.keys.slice(0, T)), [c.id], it(c.keys.slice(T))), C([].concat(it(P.slice(0, T)), [_], it(P.slice(T))))) : (process.env.NODE_ENV !== "production" && (T < 0 || T > P.length) && Qt(!1, "The second parameter of the add function should be a valid positive number."), c.keys = [].concat(it(c.keys), [c.id]), C([].concat(it(P), [_]))), c.id += 1;
      },
      remove: function(_) {
        var T = b(), P = new Set(Array.isArray(_) ? _ : [_]);
        P.size <= 0 || (c.keys = c.keys.filter(function(D, O) {
          return !P.has(O);
        }), C(T.filter(function(D, O) {
          return !P.has(O);
        })));
      },
      move: function(_, T) {
        if (_ !== T) {
          var P = b();
          _ < 0 || _ >= P.length || T < 0 || T >= P.length || (c.keys = CO(c.keys, _, T), C(CO(P, _, T)));
        }
      }
    }, x = y || [];
    return Array.isArray(x) || (x = [], process.env.NODE_ENV !== "production" && Qt(!1, "Current value of '".concat(d.join(" > "), "' is not an array type."))), n(x.map(function(R, _) {
      var T = c.keys[_];
      return T === void 0 && (c.keys[_] = c.id, T = c.keys[_], c.id += 1), {
        name: _,
        key: T,
        isListField: !0
      };
    }), w, v);
  })));
}
function Rie(e) {
  var t = !1, r = e.length, n = [];
  return e.length ? new Promise(function(i, o) {
    e.forEach(function(a, s) {
      a.catch(function(l) {
        return t = !0, l;
      }).then(function(l) {
        r -= 1, n[s] = l, !(r > 0) && (t && o(n), i(n));
      });
    });
  }) : Promise.resolve([]);
}
var M5 = "__@field_split__";
function cb(e) {
  return e.map(function(t) {
    return "".concat(vt(t), ":").concat(t);
  }).join(M5);
}
var wd = /* @__PURE__ */ function() {
  function e() {
    Kn(this, e), te(this, "kvs", /* @__PURE__ */ new Map());
  }
  return Yn(e, [{
    key: "set",
    value: function(r, n) {
      this.kvs.set(cb(r), n);
    }
  }, {
    key: "get",
    value: function(r) {
      return this.kvs.get(cb(r));
    }
  }, {
    key: "update",
    value: function(r, n) {
      var i = this.get(r), o = n(i);
      o ? this.set(r, o) : this.delete(r);
    }
  }, {
    key: "delete",
    value: function(r) {
      this.kvs.delete(cb(r));
    }
    // Since we only use this in test, let simply realize this
  }, {
    key: "map",
    value: function(r) {
      return it(this.kvs.entries()).map(function(n) {
        var i = ae(n, 2), o = i[0], a = i[1], s = o.split(M5);
        return r({
          key: s.map(function(l) {
            var u = l.match(/^([^:]*):(.*)$/), c = ae(u, 3), d = c[1], h = c[2];
            return d === "number" ? Number(h) : h;
          }),
          value: a
        });
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      var r = {};
      return this.map(function(n) {
        var i = n.key, o = n.value;
        return r[i.join(".")] = o, null;
      }), r;
    }
  }]), e;
}(), _ie = ["name"], Tie = /* @__PURE__ */ Yn(function e(t) {
  var r = this;
  Kn(this, e), te(this, "formHooked", !1), te(this, "forceRootUpdate", void 0), te(this, "subscribable", !0), te(this, "store", {}), te(this, "fieldEntities", []), te(this, "initialValues", {}), te(this, "callbacks", {}), te(this, "validateMessages", null), te(this, "preserve", null), te(this, "lastValidatePromise", null), te(this, "getForm", function() {
    return {
      getFieldValue: r.getFieldValue,
      getFieldsValue: r.getFieldsValue,
      getFieldError: r.getFieldError,
      getFieldWarning: r.getFieldWarning,
      getFieldsError: r.getFieldsError,
      isFieldsTouched: r.isFieldsTouched,
      isFieldTouched: r.isFieldTouched,
      isFieldValidating: r.isFieldValidating,
      isFieldsValidating: r.isFieldsValidating,
      resetFields: r.resetFields,
      setFields: r.setFields,
      setFieldValue: r.setFieldValue,
      setFieldsValue: r.setFieldsValue,
      validateFields: r.validateFields,
      submit: r.submit,
      _init: !0,
      getInternalHooks: r.getInternalHooks
    };
  }), te(this, "getInternalHooks", function(n) {
    return n === pc ? (r.formHooked = !0, {
      dispatch: r.dispatch,
      initEntityValue: r.initEntityValue,
      registerField: r.registerField,
      useSubscribe: r.useSubscribe,
      setInitialValues: r.setInitialValues,
      destroyForm: r.destroyForm,
      setCallbacks: r.setCallbacks,
      setValidateMessages: r.setValidateMessages,
      getFields: r.getFields,
      setPreserve: r.setPreserve,
      getInitialValue: r.getInitialValue,
      registerWatch: r.registerWatch
    }) : (Qt(!1, "`getInternalHooks` is internal usage. Should not call directly."), null);
  }), te(this, "useSubscribe", function(n) {
    r.subscribable = n;
  }), te(this, "prevWithoutPreserves", null), te(this, "setInitialValues", function(n, i) {
    if (r.initialValues = n || {}, i) {
      var o, a = uh(n, r.store);
      (o = r.prevWithoutPreserves) === null || o === void 0 || o.map(function(s) {
        var l = s.key;
        a = ya(a, l, rs(n, l));
      }), r.prevWithoutPreserves = null, r.updateStore(a);
    }
  }), te(this, "destroyForm", function(n) {
    if (n)
      r.updateStore({});
    else {
      var i = new wd();
      r.getFieldEntities(!0).forEach(function(o) {
        r.isMergedPreserve(o.isPreserve()) || i.set(o.getNamePath(), !0);
      }), r.prevWithoutPreserves = i;
    }
  }), te(this, "getInitialValue", function(n) {
    var i = rs(r.initialValues, n);
    return n.length ? uh(i) : i;
  }), te(this, "setCallbacks", function(n) {
    r.callbacks = n;
  }), te(this, "setValidateMessages", function(n) {
    r.validateMessages = n;
  }), te(this, "setPreserve", function(n) {
    r.preserve = n;
  }), te(this, "watchList", []), te(this, "registerWatch", function(n) {
    return r.watchList.push(n), function() {
      r.watchList = r.watchList.filter(function(i) {
        return i !== n;
      });
    };
  }), te(this, "notifyWatch", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (r.watchList.length) {
      var i = r.getFieldsValue(), o = r.getFieldsValue(!0);
      r.watchList.forEach(function(a) {
        a(i, o, n);
      });
    }
  }), te(this, "timeoutId", null), te(this, "warningUnhooked", function() {
    process.env.NODE_ENV !== "production" && !r.timeoutId && typeof window < "u" && (r.timeoutId = setTimeout(function() {
      r.timeoutId = null, r.formHooked || Qt(!1, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
    }));
  }), te(this, "updateStore", function(n) {
    r.store = n;
  }), te(this, "getFieldEntities", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    return n ? r.fieldEntities.filter(function(i) {
      return i.getNamePath().length;
    }) : r.fieldEntities;
  }), te(this, "getFieldsMap", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, i = new wd();
    return r.getFieldEntities(n).forEach(function(o) {
      var a = o.getNamePath();
      i.set(a, o);
    }), i;
  }), te(this, "getFieldEntitiesForNamePathList", function(n) {
    if (!n)
      return r.getFieldEntities(!0);
    var i = r.getFieldsMap(!0);
    return n.map(function(o) {
      var a = Cn(o);
      return i.get(a) || {
        INVALIDATE_NAME_PATH: Cn(o)
      };
    });
  }), te(this, "getFieldsValue", function(n, i) {
    r.warningUnhooked();
    var o, a, s;
    if (n === !0 || Array.isArray(n) ? (o = n, a = i) : n && vt(n) === "object" && (s = n.strict, a = n.filter), o === !0 && !a)
      return r.store;
    var l = r.getFieldEntitiesForNamePathList(Array.isArray(o) ? o : null), u = [];
    return l.forEach(function(c) {
      var d, h, f = "INVALIDATE_NAME_PATH" in c ? c.INVALIDATE_NAME_PATH : c.getNamePath();
      if (s) {
        var p, g;
        if ((p = (g = c).isList) !== null && p !== void 0 && p.call(g))
          return;
      } else if (!o && (d = (h = c).isListField) !== null && d !== void 0 && d.call(h))
        return;
      if (!a)
        u.push(f);
      else {
        var v = "getMeta" in c ? c.getMeta() : null;
        a(v) && u.push(f);
      }
    }), yO(r.store, u.map(Cn));
  }), te(this, "getFieldValue", function(n) {
    r.warningUnhooked();
    var i = Cn(n);
    return rs(r.store, i);
  }), te(this, "getFieldsError", function(n) {
    r.warningUnhooked();
    var i = r.getFieldEntitiesForNamePathList(n);
    return i.map(function(o, a) {
      return o && !("INVALIDATE_NAME_PATH" in o) ? {
        name: o.getNamePath(),
        errors: o.getErrors(),
        warnings: o.getWarnings()
      } : {
        name: Cn(n[a]),
        errors: [],
        warnings: []
      };
    });
  }), te(this, "getFieldError", function(n) {
    r.warningUnhooked();
    var i = Cn(n), o = r.getFieldsError([i])[0];
    return o.errors;
  }), te(this, "getFieldWarning", function(n) {
    r.warningUnhooked();
    var i = Cn(n), o = r.getFieldsError([i])[0];
    return o.warnings;
  }), te(this, "isFieldsTouched", function() {
    r.warningUnhooked();
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    var a = i[0], s = i[1], l, u = !1;
    i.length === 0 ? l = null : i.length === 1 ? Array.isArray(a) ? (l = a.map(Cn), u = !1) : (l = null, u = a) : (l = a.map(Cn), u = s);
    var c = r.getFieldEntities(!0), d = function(v) {
      return v.isFieldTouched();
    };
    if (!l)
      return u ? c.every(function(g) {
        return d(g) || g.isList();
      }) : c.some(d);
    var h = new wd();
    l.forEach(function(g) {
      h.set(g, []);
    }), c.forEach(function(g) {
      var v = g.getNamePath();
      l.forEach(function(m) {
        m.every(function(y, C) {
          return v[C] === y;
        }) && h.update(m, function(y) {
          return [].concat(it(y), [g]);
        });
      });
    });
    var f = function(v) {
      return v.some(d);
    }, p = h.map(function(g) {
      var v = g.value;
      return v;
    });
    return u ? p.every(f) : p.some(f);
  }), te(this, "isFieldTouched", function(n) {
    return r.warningUnhooked(), r.isFieldsTouched([n]);
  }), te(this, "isFieldsValidating", function(n) {
    r.warningUnhooked();
    var i = r.getFieldEntities();
    if (!n)
      return i.some(function(a) {
        return a.isFieldValidating();
      });
    var o = n.map(Cn);
    return i.some(function(a) {
      var s = a.getNamePath();
      return wh(o, s) && a.isFieldValidating();
    });
  }), te(this, "isFieldValidating", function(n) {
    return r.warningUnhooked(), r.isFieldsValidating([n]);
  }), te(this, "resetWithFieldInitialValue", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = new wd(), o = r.getFieldEntities(!0);
    o.forEach(function(l) {
      var u = l.props.initialValue, c = l.getNamePath();
      if (u !== void 0) {
        var d = i.get(c) || /* @__PURE__ */ new Set();
        d.add({
          entity: l,
          value: u
        }), i.set(c, d);
      }
    });
    var a = function(u) {
      u.forEach(function(c) {
        var d = c.props.initialValue;
        if (d !== void 0) {
          var h = c.getNamePath(), f = r.getInitialValue(h);
          if (f !== void 0)
            Qt(!1, "Form already set 'initialValues' with path '".concat(h.join("."), "'. Field can not overwrite it."));
          else {
            var p = i.get(h);
            if (p && p.size > 1)
              Qt(!1, "Multiple Field with path '".concat(h.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            else if (p) {
              var g = r.getFieldValue(h), v = c.isListField();
              !v && (!n.skipExist || g === void 0) && r.updateStore(ya(r.store, h, it(p)[0].value));
            }
          }
        }
      });
    }, s;
    n.entities ? s = n.entities : n.namePathList ? (s = [], n.namePathList.forEach(function(l) {
      var u = i.get(l);
      if (u) {
        var c;
        (c = s).push.apply(c, it(it(u).map(function(d) {
          return d.entity;
        })));
      }
    })) : s = o, a(s);
  }), te(this, "resetFields", function(n) {
    r.warningUnhooked();
    var i = r.store;
    if (!n) {
      r.updateStore(uh(r.initialValues)), r.resetWithFieldInitialValue(), r.notifyObservers(i, null, {
        type: "reset"
      }), r.notifyWatch();
      return;
    }
    var o = n.map(Cn);
    o.forEach(function(a) {
      var s = r.getInitialValue(a);
      r.updateStore(ya(r.store, a, s));
    }), r.resetWithFieldInitialValue({
      namePathList: o
    }), r.notifyObservers(i, o, {
      type: "reset"
    }), r.notifyWatch(o);
  }), te(this, "setFields", function(n) {
    r.warningUnhooked();
    var i = r.store, o = [];
    n.forEach(function(a) {
      var s = a.name, l = $t(a, _ie), u = Cn(s);
      o.push(u), "value" in l && r.updateStore(ya(r.store, u, l.value)), r.notifyObservers(i, [u], {
        type: "setField",
        data: a
      });
    }), r.notifyWatch(o);
  }), te(this, "getFields", function() {
    var n = r.getFieldEntities(!0), i = n.map(function(o) {
      var a = o.getNamePath(), s = o.getMeta(), l = ee(ee({}, s), {}, {
        name: a,
        value: r.getFieldValue(a)
      });
      return Object.defineProperty(l, "originRCField", {
        value: !0
      }), l;
    });
    return i;
  }), te(this, "initEntityValue", function(n) {
    var i = n.props.initialValue;
    if (i !== void 0) {
      var o = n.getNamePath(), a = rs(r.store, o);
      a === void 0 && r.updateStore(ya(r.store, o, i));
    }
  }), te(this, "isMergedPreserve", function(n) {
    var i = n !== void 0 ? n : r.preserve;
    return i ?? !0;
  }), te(this, "registerField", function(n) {
    r.fieldEntities.push(n);
    var i = n.getNamePath();
    if (r.notifyWatch([i]), n.props.initialValue !== void 0) {
      var o = r.store;
      r.resetWithFieldInitialValue({
        entities: [n],
        skipExist: !0
      }), r.notifyObservers(o, [n.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(a, s) {
      var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (r.fieldEntities = r.fieldEntities.filter(function(d) {
        return d !== n;
      }), !r.isMergedPreserve(s) && (!a || l.length > 1)) {
        var u = a ? void 0 : r.getInitialValue(i);
        if (i.length && r.getFieldValue(i) !== u && r.fieldEntities.every(function(d) {
          return (
            // Only reset when no namePath exist
            !T5(d.getNamePath(), i)
          );
        })) {
          var c = r.store;
          r.updateStore(ya(c, i, u, !0)), r.notifyObservers(c, [i], {
            type: "remove"
          }), r.triggerDependenciesUpdate(c, i);
        }
      }
      r.notifyWatch([i]);
    };
  }), te(this, "dispatch", function(n) {
    switch (n.type) {
      case "updateValue": {
        var i = n.namePath, o = n.value;
        r.updateValue(i, o);
        break;
      }
      case "validateField": {
        var a = n.namePath, s = n.triggerName;
        r.validateFields([a], {
          triggerName: s
        });
        break;
      }
    }
  }), te(this, "notifyObservers", function(n, i, o) {
    if (r.subscribable) {
      var a = ee(ee({}, o), {}, {
        store: r.getFieldsValue(!0)
      });
      r.getFieldEntities().forEach(function(s) {
        var l = s.onStoreChange;
        l(n, i, a);
      });
    } else
      r.forceRootUpdate();
  }), te(this, "triggerDependenciesUpdate", function(n, i) {
    var o = r.getDependencyChildrenFields(i);
    return o.length && r.validateFields(o), r.notifyObservers(n, o, {
      type: "dependenciesUpdate",
      relatedFields: [i].concat(it(o))
    }), o;
  }), te(this, "updateValue", function(n, i) {
    var o = Cn(n), a = r.store;
    r.updateStore(ya(r.store, o, i)), r.notifyObservers(a, [o], {
      type: "valueUpdate",
      source: "internal"
    }), r.notifyWatch([o]);
    var s = r.triggerDependenciesUpdate(a, o), l = r.callbacks.onValuesChange;
    if (l) {
      var u = yO(r.store, [o]);
      l(u, r.getFieldsValue());
    }
    r.triggerOnFieldsChange([o].concat(it(s)));
  }), te(this, "setFieldsValue", function(n) {
    r.warningUnhooked();
    var i = r.store;
    if (n) {
      var o = uh(r.store, n);
      r.updateStore(o);
    }
    r.notifyObservers(i, null, {
      type: "valueUpdate",
      source: "external"
    }), r.notifyWatch();
  }), te(this, "setFieldValue", function(n, i) {
    r.setFields([{
      name: n,
      value: i
    }]);
  }), te(this, "getDependencyChildrenFields", function(n) {
    var i = /* @__PURE__ */ new Set(), o = [], a = new wd();
    r.getFieldEntities().forEach(function(l) {
      var u = l.props.dependencies;
      (u || []).forEach(function(c) {
        var d = Cn(c);
        a.update(d, function() {
          var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          return h.add(l), h;
        });
      });
    });
    var s = function l(u) {
      var c = a.get(u) || /* @__PURE__ */ new Set();
      c.forEach(function(d) {
        if (!i.has(d)) {
          i.add(d);
          var h = d.getNamePath();
          d.isFieldDirty() && h.length && (o.push(h), l(h));
        }
      });
    };
    return s(n), o;
  }), te(this, "triggerOnFieldsChange", function(n, i) {
    var o = r.callbacks.onFieldsChange;
    if (o) {
      var a = r.getFields();
      if (i) {
        var s = new wd();
        i.forEach(function(u) {
          var c = u.name, d = u.errors;
          s.set(c, d);
        }), a.forEach(function(u) {
          u.errors = s.get(u.name) || u.errors;
        });
      }
      var l = a.filter(function(u) {
        var c = u.name;
        return wh(n, c);
      });
      l.length && o(l, a);
    }
  }), te(this, "validateFields", function(n, i) {
    r.warningUnhooked();
    var o, a;
    Array.isArray(n) || typeof n == "string" || typeof i == "string" ? (o = n, a = i) : a = n;
    var s = !!o, l = s ? o.map(Cn) : [], u = [], c = String(Date.now()), d = /* @__PURE__ */ new Set(), h = a || {}, f = h.recursive, p = h.dirty;
    r.getFieldEntities(!0).forEach(function(y) {
      if (s || l.push(y.getNamePath()), !(!y.props.rules || !y.props.rules.length) && !(p && !y.isFieldDirty())) {
        var C = y.getNamePath();
        if (d.add(C.join(c)), !s || wh(l, C, f)) {
          var S = y.validateRules(ee({
            validateMessages: ee(ee({}, _5), r.validateMessages)
          }, a));
          u.push(S.then(function() {
            return {
              name: C,
              errors: [],
              warnings: []
            };
          }).catch(function(b) {
            var w, x = [], R = [];
            return (w = b.forEach) === null || w === void 0 || w.call(b, function(_) {
              var T = _.rule.warningOnly, P = _.errors;
              T ? R.push.apply(R, it(P)) : x.push.apply(x, it(P));
            }), x.length ? Promise.reject({
              name: C,
              errors: x,
              warnings: R
            }) : {
              name: C,
              errors: x,
              warnings: R
            };
          }));
        }
      }
    });
    var g = Rie(u);
    r.lastValidatePromise = g, g.catch(function(y) {
      return y;
    }).then(function(y) {
      var C = y.map(function(S) {
        var b = S.name;
        return b;
      });
      r.notifyObservers(r.store, C, {
        type: "validateFinish"
      }), r.triggerOnFieldsChange(C, y);
    });
    var v = g.then(function() {
      return r.lastValidatePromise === g ? Promise.resolve(r.getFieldsValue(l)) : Promise.reject([]);
    }).catch(function(y) {
      var C = y.filter(function(S) {
        return S && S.errors.length;
      });
      return Promise.reject({
        values: r.getFieldsValue(l),
        errorFields: C,
        outOfDate: r.lastValidatePromise !== g
      });
    });
    v.catch(function(y) {
      return y;
    });
    var m = l.filter(function(y) {
      return d.has(y.join(c));
    });
    return r.triggerOnFieldsChange(m), v;
  }), te(this, "submit", function() {
    r.warningUnhooked(), r.validateFields().then(function(n) {
      var i = r.callbacks.onFinish;
      if (i)
        try {
          i(n);
        } catch (o) {
          console.error(o);
        }
    }).catch(function(n) {
      var i = r.callbacks.onFinishFailed;
      i && i(n);
    });
  }), this.forceRootUpdate = t;
});
function D5(e) {
  var t = E.useRef(), r = E.useState({}), n = ae(r, 2), i = n[1];
  if (!t.current)
    if (e)
      t.current = e;
    else {
      var o = function() {
        i({});
      }, a = new Tie(o);
      t.current = a.getForm();
    }
  return [t.current];
}
var AR = /* @__PURE__ */ E.createContext({
  triggerFormChange: function() {
  },
  triggerFormFinish: function() {
  },
  registerForm: function() {
  },
  unregisterForm: function() {
  }
}), Pie = function(t) {
  var r = t.validateMessages, n = t.onFormChange, i = t.onFormFinish, o = t.children, a = E.useContext(AR), s = E.useRef({});
  return /* @__PURE__ */ E.createElement(AR.Provider, {
    value: ee(ee({}, a), {}, {
      validateMessages: ee(ee({}, a.validateMessages), r),
      // =========================================================
      // =                  Global Form Control                  =
      // =========================================================
      triggerFormChange: function(u, c) {
        n && n(u, {
          changedFields: c,
          forms: s.current
        }), a.triggerFormChange(u, c);
      },
      triggerFormFinish: function(u, c) {
        i && i(u, {
          values: c,
          forms: s.current
        }), a.triggerFormFinish(u, c);
      },
      registerForm: function(u, c) {
        u && (s.current = ee(ee({}, s.current), {}, te({}, u, c))), a.registerForm(u, c);
      },
      unregisterForm: function(u) {
        var c = ee({}, s.current);
        delete c[u], s.current = c, a.unregisterForm(u);
      }
    })
  }, o);
}, Mie = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed", "clearOnDestroy"], Die = function(t, r) {
  var n = t.name, i = t.initialValues, o = t.fields, a = t.form, s = t.preserve, l = t.children, u = t.component, c = u === void 0 ? "form" : u, d = t.validateMessages, h = t.validateTrigger, f = h === void 0 ? "onChange" : h, p = t.onValuesChange, g = t.onFieldsChange, v = t.onFinish, m = t.onFinishFailed, y = t.clearOnDestroy, C = $t(t, Mie), S = E.useRef(null), b = E.useContext(AR), w = D5(a), x = ae(w, 1), R = x[0], _ = R.getInternalHooks(pc), T = _.useSubscribe, P = _.setInitialValues, D = _.setCallbacks, O = _.setValidateMessages, A = _.setPreserve, F = _.destroyForm;
  E.useImperativeHandle(r, function() {
    return ee(ee({}, R), {}, {
      nativeElement: S.current
    });
  }), E.useEffect(function() {
    return b.registerForm(n, R), function() {
      b.unregisterForm(n);
    };
  }, [b, R, n]), O(ee(ee({}, b.validateMessages), d)), D({
    onValuesChange: p,
    onFieldsChange: function(z) {
      if (b.triggerFormChange(n, z), g) {
        for (var j = arguments.length, q = new Array(j > 1 ? j - 1 : 0), K = 1; K < j; K++)
          q[K - 1] = arguments[K];
        g.apply(void 0, [z].concat(q));
      }
    },
    onFinish: function(z) {
      b.triggerFormFinish(n, z), v && v(z);
    },
    onFinishFailed: m
  }), A(s);
  var L = E.useRef(null);
  P(i, !L.current), L.current || (L.current = !0), E.useEffect(
    function() {
      return function() {
        return F(y);
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  var N, I = typeof l == "function";
  if (I) {
    var B = R.getFieldsValue(!0);
    N = l(B, R);
  } else
    N = l;
  T(!I);
  var M = E.useRef();
  E.useEffect(function() {
    wie(M.current || [], o || []) || R.setFields(o || []), M.current = o;
  }, [o, R]);
  var V = E.useMemo(function() {
    return ee(ee({}, R), {}, {
      validateTrigger: f
    });
  }, [R, f]), G = /* @__PURE__ */ E.createElement(F0.Provider, {
    value: null
  }, /* @__PURE__ */ E.createElement(Hh.Provider, {
    value: V
  }, N));
  return c === !1 ? G : /* @__PURE__ */ E.createElement(c, $e({}, C, {
    ref: S,
    onSubmit: function(z) {
      z.preventDefault(), z.stopPropagation(), R.submit();
    },
    onReset: function(z) {
      var j;
      z.preventDefault(), R.resetFields(), (j = C.onReset) === null || j === void 0 || j.call(C, z);
    }
  }), G);
};
function wO(e) {
  try {
    return JSON.stringify(e);
  } catch {
    return Math.random();
  }
}
var Aie = process.env.NODE_ENV !== "production" ? function(e) {
  var t = e.join("__RC_FIELD_FORM_SPLIT__"), r = se(t);
  Qt(r.current === t, "`useWatch` is not support dynamic `namePath`. Please provide static instead.");
} : function() {
};
function Iie() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = t[0], i = t[1], o = i === void 0 ? {} : i, a = $ne(o) ? {
    form: o
  } : o, s = a.form, l = Me(), u = ae(l, 2), c = u[0], d = u[1], h = Et(function() {
    return wO(c);
  }, [c]), f = se(h);
  f.current = h;
  var p = vr(Hh), g = s || p, v = g && g._init;
  process.env.NODE_ENV !== "production" && Qt(t.length === 2 ? s ? v : !0 : v, "useWatch requires a form instance since it can not auto detect from context.");
  var m = Cn(n), y = se(m);
  return y.current = m, Aie(m), Nt(
    function() {
      if (v) {
        var C = g.getFieldsValue, S = g.getInternalHooks, b = S(pc), w = b.registerWatch, x = function(P, D) {
          var O = a.preserve ? D : P;
          return typeof n == "function" ? n(O) : rs(O, y.current);
        }, R = w(function(T, P) {
          var D = x(T, P), O = wO(D);
          f.current !== O && (f.current = O, d(D));
        }), _ = x(C(), C(!0));
        return c !== _ && d(_), R;
      }
    },
    // We do not need re-register since namePath content is the same
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [v]
  ), c;
}
var Oie = /* @__PURE__ */ E.forwardRef(Die), wv = Oie;
wv.FormProvider = Pie;
wv.Field = P5;
wv.List = Eie;
wv.useForm = D5;
wv.useWatch = Iie;
const ps = /* @__PURE__ */ E.createContext({});
process.env.NODE_ENV !== "production" && (ps.displayName = "FormItemInputContext");
const Lie = (e) => {
  let {
    children: t,
    status: r,
    override: n
  } = e;
  const i = vr(ps), o = Et(() => {
    const a = Object.assign({}, i);
    return n && delete a.isFormItemInput, r && (delete a.status, delete a.hasFeedback, delete a.feedbackIcon), a;
  }, [r, n, i]);
  return /* @__PURE__ */ E.createElement(ps.Provider, {
    value: o
  }, t);
}, Fie = /* @__PURE__ */ du(void 0), IR = (e) => {
  const {
    space: t,
    form: r,
    children: n
  } = e;
  if (n == null)
    return null;
  let i = n;
  return r && (i = /* @__PURE__ */ H.createElement(Lie, {
    override: !0,
    status: !0
  }, i)), t && (i = /* @__PURE__ */ H.createElement(Yre, null, i)), i;
};
function bO(e) {
  if (e)
    return {
      closable: e.closable,
      closeIcon: e.closeIcon
    };
}
function xO(e) {
  const {
    closable: t,
    closeIcon: r
  } = e || {};
  return H.useMemo(() => {
    if (
      // If `closable`, whatever rest be should be true
      !t && (t === !1 || r === !1 || r === null)
    )
      return !1;
    if (t === void 0 && r === void 0)
      return null;
    let n = {
      closeIcon: typeof r != "boolean" && r !== null ? r : void 0
    };
    return t && typeof t == "object" && (n = Object.assign(Object.assign({}, n), t)), n;
  }, [t, r]);
}
function EO() {
  const e = {};
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  return r.forEach((i) => {
    i && Object.keys(i).forEach((o) => {
      i[o] !== void 0 && (e[o] = i[o]);
    });
  }), e;
}
const Nie = {};
function kie(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Nie;
  const n = xO(e), i = xO(t), o = H.useMemo(() => Object.assign({
    closeIcon: /* @__PURE__ */ H.createElement(uf, null)
  }, r), [r]), a = H.useMemo(() => n === !1 ? !1 : n ? EO(o, i, n) : i === !1 ? !1 : i ? EO(o, i) : o.closable ? o : !1, [n, i, o]);
  return H.useMemo(() => {
    if (a === !1)
      return [!1, null];
    const {
      closeIconRender: s
    } = o, {
      closeIcon: l
    } = a;
    let u = l;
    if (u != null) {
      s && (u = s(l));
      const c = Zl(a, !0);
      Object.keys(c).length && (u = /* @__PURE__ */ H.isValidElement(u) ? /* @__PURE__ */ H.cloneElement(u, c) : /* @__PURE__ */ H.createElement("span", Object.assign({}, c), u));
    }
    return [!0, u];
  }, [a, o]);
}
var A5 = function(t) {
  if (Zn() && window.document.documentElement) {
    var r = Array.isArray(t) ? t : [t], n = window.document.documentElement;
    return r.some(function(i) {
      return i in n.style;
    });
  }
  return !1;
}, Vie = function(t, r) {
  if (!A5(t))
    return !1;
  var n = document.createElement("div"), i = n.style[t];
  return n.style[t] = r, n.style[t] !== i;
};
function RO(e, t) {
  return !Array.isArray(e) && t !== void 0 ? Vie(e, t) : A5(e);
}
const SS = (e) => {
  const {
    prefixCls: t,
    className: r,
    style: n,
    size: i,
    shape: o
  } = e, a = ue({
    [`${t}-lg`]: i === "large",
    [`${t}-sm`]: i === "small"
  }), s = ue({
    [`${t}-circle`]: o === "circle",
    [`${t}-square`]: o === "square",
    [`${t}-round`]: o === "round"
  }), l = E.useMemo(() => typeof i == "number" ? {
    width: i,
    height: i,
    lineHeight: `${i}px`
  } : {}, [i]);
  return /* @__PURE__ */ E.createElement("span", {
    className: ue(t, a, s, r),
    style: Object.assign(Object.assign({}, l), n)
  });
}, Bie = new Mr("ant-skeleton-loading", {
  "0%": {
    backgroundPosition: "100% 50%"
  },
  "100%": {
    backgroundPosition: "0 50%"
  }
}), wS = (e) => ({
  height: e,
  lineHeight: de(e)
}), bh = (e) => Object.assign({
  width: e
}, wS(e)), $ie = (e) => ({
  background: e.skeletonLoadingBackground,
  backgroundSize: "400% 100%",
  animationName: Bie,
  animationDuration: e.skeletonLoadingMotionDuration,
  animationTimingFunction: "ease",
  animationIterationCount: "infinite"
}), db = (e, t) => Object.assign({
  width: t(e).mul(5).equal(),
  minWidth: t(e).mul(5).equal()
}, wS(e)), Hie = (e) => {
  const {
    skeletonAvatarCls: t,
    gradientFromColor: r,
    controlHeight: n,
    controlHeightLG: i,
    controlHeightSM: o
  } = e;
  return {
    [`${t}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: r
    }, bh(n)),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    },
    [`${t}${t}-lg`]: Object.assign({}, bh(i)),
    [`${t}${t}-sm`]: Object.assign({}, bh(o))
  };
}, Gie = (e) => {
  const {
    controlHeight: t,
    borderRadiusSM: r,
    skeletonInputCls: n,
    controlHeightLG: i,
    controlHeightSM: o,
    gradientFromColor: a,
    calc: s
  } = e;
  return {
    [`${n}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: a,
      borderRadius: r
    }, db(t, s)),
    [`${n}-lg`]: Object.assign({}, db(i, s)),
    [`${n}-sm`]: Object.assign({}, db(o, s))
  };
}, _O = (e) => Object.assign({
  width: e
}, wS(e)), zie = (e) => {
  const {
    skeletonImageCls: t,
    imageSizeBase: r,
    gradientFromColor: n,
    borderRadiusSM: i,
    calc: o
  } = e;
  return {
    [`${t}`]: Object.assign(Object.assign({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: n,
      borderRadius: i
    }, _O(o(r).mul(2).equal())), {
      [`${t}-path`]: {
        fill: "#bfbfbf"
      },
      [`${t}-svg`]: Object.assign(Object.assign({}, _O(r)), {
        maxWidth: o(r).mul(4).equal(),
        maxHeight: o(r).mul(4).equal()
      }),
      [`${t}-svg${t}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    }
  };
}, hb = (e, t, r) => {
  const {
    skeletonButtonCls: n
  } = e;
  return {
    [`${r}${n}-circle`]: {
      width: t,
      minWidth: t,
      borderRadius: "50%"
    },
    [`${r}${n}-round`]: {
      borderRadius: t
    }
  };
}, fb = (e, t) => Object.assign({
  width: t(e).mul(2).equal(),
  minWidth: t(e).mul(2).equal()
}, wS(e)), Wie = (e) => {
  const {
    borderRadiusSM: t,
    skeletonButtonCls: r,
    controlHeight: n,
    controlHeightLG: i,
    controlHeightSM: o,
    gradientFromColor: a,
    calc: s
  } = e;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    [`${r}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: a,
      borderRadius: t,
      width: s(n).mul(2).equal(),
      minWidth: s(n).mul(2).equal()
    }, fb(n, s))
  }, hb(e, n, r)), {
    [`${r}-lg`]: Object.assign({}, fb(i, s))
  }), hb(e, i, `${r}-lg`)), {
    [`${r}-sm`]: Object.assign({}, fb(o, s))
  }), hb(e, o, `${r}-sm`));
}, jie = (e) => {
  const {
    componentCls: t,
    skeletonAvatarCls: r,
    skeletonTitleCls: n,
    skeletonParagraphCls: i,
    skeletonButtonCls: o,
    skeletonInputCls: a,
    skeletonImageCls: s,
    controlHeight: l,
    controlHeightLG: u,
    controlHeightSM: c,
    gradientFromColor: d,
    padding: h,
    marginSM: f,
    borderRadius: p,
    titleHeight: g,
    blockRadius: v,
    paragraphLiHeight: m,
    controlHeightXS: y,
    paragraphMarginTop: C
  } = e;
  return {
    [`${t}`]: {
      display: "table",
      width: "100%",
      [`${t}-header`]: {
        display: "table-cell",
        paddingInlineEnd: h,
        verticalAlign: "top",
        // Avatar
        [`${r}`]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: d
        }, bh(l)),
        [`${r}-circle`]: {
          borderRadius: "50%"
        },
        [`${r}-lg`]: Object.assign({}, bh(u)),
        [`${r}-sm`]: Object.assign({}, bh(c))
      },
      [`${t}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [`${n}`]: {
          width: "100%",
          height: g,
          background: d,
          borderRadius: v,
          [`+ ${i}`]: {
            marginBlockStart: c
          }
        },
        // paragraph
        [`${i}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: m,
            listStyle: "none",
            background: d,
            borderRadius: v,
            "+ li": {
              marginBlockStart: y
            }
          }
        },
        [`${i}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${t}-content`]: {
        [`${n}, ${i} > li`]: {
          borderRadius: p
        }
      }
    },
    [`${t}-with-avatar ${t}-content`]: {
      // Title
      [`${n}`]: {
        marginBlockStart: f,
        [`+ ${i}`]: {
          marginBlockStart: C
        }
      }
    },
    // Skeleton element
    [`${t}${t}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
      display: "inline-block",
      width: "auto"
    }, Wie(e)), Hie(e)), Gie(e)), zie(e)),
    // Skeleton Block Button, Input
    [`${t}${t}-block`]: {
      width: "100%",
      [`${o}`]: {
        width: "100%"
      },
      [`${a}`]: {
        width: "100%"
      }
    },
    // With active animation
    [`${t}${t}-active`]: {
      [`
        ${n},
        ${i} > li,
        ${r},
        ${o},
        ${a},
        ${s}
      `]: Object.assign({}, $ie(e))
    }
  };
}, Uie = (e) => {
  const {
    colorFillContent: t,
    colorFill: r
  } = e, n = t, i = r;
  return {
    color: n,
    colorGradientEnd: i,
    gradientFromColor: n,
    gradientToColor: i,
    titleHeight: e.controlHeight / 2,
    blockRadius: e.borderRadiusSM,
    paragraphMarginTop: e.marginLG + e.marginXXS,
    paragraphLiHeight: e.controlHeight / 2
  };
}, cf = Gn("Skeleton", (e) => {
  const {
    componentCls: t,
    calc: r
  } = e, n = Br(e, {
    skeletonAvatarCls: `${t}-avatar`,
    skeletonTitleCls: `${t}-title`,
    skeletonParagraphCls: `${t}-paragraph`,
    skeletonButtonCls: `${t}-button`,
    skeletonInputCls: `${t}-input`,
    skeletonImageCls: `${t}-image`,
    imageSizeBase: r(e.controlHeight).mul(1.5).equal(),
    borderRadius: 100,
    // Large number to make capsule shape
    skeletonLoadingBackground: `linear-gradient(90deg, ${e.gradientFromColor} 25%, ${e.gradientToColor} 37%, ${e.gradientFromColor} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [jie(n)];
}, Uie, {
  deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
}), Kie = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    active: i,
    shape: o = "circle",
    size: a = "default"
  } = e, {
    getPrefixCls: s
  } = E.useContext(Yt), l = s("skeleton", t), [u, c, d] = cf(l), h = ni(e, ["prefixCls", "className"]), f = ue(l, `${l}-element`, {
    [`${l}-active`]: i
  }, r, n, c, d);
  return u(/* @__PURE__ */ E.createElement("div", {
    className: f
  }, /* @__PURE__ */ E.createElement(SS, Object.assign({
    prefixCls: `${l}-avatar`,
    shape: o,
    size: a
  }, h))));
}, Yie = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    active: i,
    block: o = !1,
    size: a = "default"
  } = e, {
    getPrefixCls: s
  } = E.useContext(Yt), l = s("skeleton", t), [u, c, d] = cf(l), h = ni(e, ["prefixCls"]), f = ue(l, `${l}-element`, {
    [`${l}-active`]: i,
    [`${l}-block`]: o
  }, r, n, c, d);
  return u(/* @__PURE__ */ E.createElement("div", {
    className: f
  }, /* @__PURE__ */ E.createElement(SS, Object.assign({
    prefixCls: `${l}-button`,
    size: a
  }, h))));
}, qie = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z", Xie = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    style: i,
    active: o
  } = e, {
    getPrefixCls: a
  } = E.useContext(Yt), s = a("skeleton", t), [l, u, c] = cf(s), d = ue(s, `${s}-element`, {
    [`${s}-active`]: o
  }, r, n, u, c);
  return l(/* @__PURE__ */ E.createElement("div", {
    className: d
  }, /* @__PURE__ */ E.createElement("div", {
    className: ue(`${s}-image`, r),
    style: i
  }, /* @__PURE__ */ E.createElement("svg", {
    viewBox: "0 0 1098 1024",
    xmlns: "http://www.w3.org/2000/svg",
    className: `${s}-image-svg`
  }, /* @__PURE__ */ E.createElement("title", null, "Image placeholder"), /* @__PURE__ */ E.createElement("path", {
    d: qie,
    className: `${s}-image-path`
  })))));
}, Zie = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    active: i,
    block: o,
    size: a = "default"
  } = e, {
    getPrefixCls: s
  } = E.useContext(Yt), l = s("skeleton", t), [u, c, d] = cf(l), h = ni(e, ["prefixCls"]), f = ue(l, `${l}-element`, {
    [`${l}-active`]: i,
    [`${l}-block`]: o
  }, r, n, c, d);
  return u(/* @__PURE__ */ E.createElement("div", {
    className: f
  }, /* @__PURE__ */ E.createElement(SS, Object.assign({
    prefixCls: `${l}-input`,
    size: a
  }, h))));
};
var Qie = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "dot-chart", theme: "outlined" }, Jie = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: Qie
  }));
}, I5 = /* @__PURE__ */ E.forwardRef(Jie);
process.env.NODE_ENV !== "production" && (I5.displayName = "DotChartOutlined");
const eoe = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    style: i,
    active: o,
    children: a
  } = e, {
    getPrefixCls: s
  } = E.useContext(Yt), l = s("skeleton", t), [u, c, d] = cf(l), h = ue(l, `${l}-element`, {
    [`${l}-active`]: o
  }, c, r, n, d), f = a ?? /* @__PURE__ */ E.createElement(I5, null);
  return u(/* @__PURE__ */ E.createElement("div", {
    className: h
  }, /* @__PURE__ */ E.createElement("div", {
    className: ue(`${l}-image`, r),
    style: i
  }, f)));
}, toe = (e, t) => {
  const {
    width: r,
    rows: n = 2
  } = t;
  if (Array.isArray(r))
    return r[e];
  if (n - 1 === e)
    return r;
}, roe = (e) => {
  const {
    prefixCls: t,
    className: r,
    style: n,
    rows: i
  } = e, o = it(Array(i)).map((a, s) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ E.createElement("li", {
      key: s,
      style: {
        width: toe(s, e)
      }
    })
  ));
  return /* @__PURE__ */ E.createElement("ul", {
    className: ue(t, r),
    style: n
  }, o);
}, noe = (e) => {
  let {
    prefixCls: t,
    className: r,
    width: n,
    style: i
  } = e;
  return (
    // biome-ignore lint/a11y/useHeadingContent: HOC here
    /* @__PURE__ */ E.createElement("h3", {
      className: ue(t, r),
      style: Object.assign({
        width: n
      }, i)
    })
  );
};
function pb(e) {
  return e && typeof e == "object" ? e : {};
}
function ioe(e, t) {
  return e && !t ? {
    size: "large",
    shape: "square"
  } : {
    size: "large",
    shape: "circle"
  };
}
function ooe(e, t) {
  return !e && t ? {
    width: "38%"
  } : e && t ? {
    width: "50%"
  } : {};
}
function aoe(e, t) {
  const r = {};
  return (!e || !t) && (r.width = "61%"), !e && t ? r.rows = 3 : r.rows = 2, r;
}
const gu = (e) => {
  const {
    prefixCls: t,
    loading: r,
    className: n,
    rootClassName: i,
    style: o,
    children: a,
    avatar: s = !1,
    title: l = !0,
    paragraph: u = !0,
    active: c,
    round: d
  } = e, {
    getPrefixCls: h,
    direction: f,
    skeleton: p
  } = E.useContext(Yt), g = h("skeleton", t), [v, m, y] = cf(g);
  if (r || !("loading" in e)) {
    const C = !!s, S = !!l, b = !!u;
    let w;
    if (C) {
      const _ = Object.assign(Object.assign({
        prefixCls: `${g}-avatar`
      }, ioe(S, b)), pb(s));
      w = /* @__PURE__ */ E.createElement("div", {
        className: `${g}-header`
      }, /* @__PURE__ */ E.createElement(SS, Object.assign({}, _)));
    }
    let x;
    if (S || b) {
      let _;
      if (S) {
        const P = Object.assign(Object.assign({
          prefixCls: `${g}-title`
        }, ooe(C, b)), pb(l));
        _ = /* @__PURE__ */ E.createElement(noe, Object.assign({}, P));
      }
      let T;
      if (b) {
        const P = Object.assign(Object.assign({
          prefixCls: `${g}-paragraph`
        }, aoe(C, S)), pb(u));
        T = /* @__PURE__ */ E.createElement(roe, Object.assign({}, P));
      }
      x = /* @__PURE__ */ E.createElement("div", {
        className: `${g}-content`
      }, _, T);
    }
    const R = ue(g, {
      [`${g}-with-avatar`]: C,
      [`${g}-active`]: c,
      [`${g}-rtl`]: f === "rtl",
      [`${g}-round`]: d
    }, p == null ? void 0 : p.className, n, i, m, y);
    return v(/* @__PURE__ */ E.createElement("div", {
      className: R,
      style: Object.assign(Object.assign({}, p == null ? void 0 : p.style), o)
    }, w, x));
  }
  return a ?? null;
};
gu.Button = Yie;
gu.Avatar = Kie;
gu.Input = Zie;
gu.Image = Xie;
gu.Node = eoe;
process.env.NODE_ENV !== "production" && (gu.displayName = "Skeleton");
const soe = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), loe = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), bS = function(e, t, r, n) {
  const o = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
  return {
    [`
      ${o}${e}-enter,
      ${o}${e}-appear
    `]: Object.assign(Object.assign({}, soe(n)), {
      animationPlayState: "paused"
    }),
    [`${o}${e}-leave`]: Object.assign(Object.assign({}, loe(n)), {
      animationPlayState: "paused"
    }),
    [`
      ${o}${e}-enter${e}-enter-active,
      ${o}${e}-appear${e}-appear-active
    `]: {
      animationName: t,
      animationPlayState: "running"
    },
    [`${o}${e}-leave${e}-leave-active`]: {
      animationName: r,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, uoe = new Mr("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), coe = new Mr("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
}), O5 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const {
    antCls: r
  } = e, n = `${r}-fade`, i = t ? "&" : "";
  return [bS(n, uoe, coe, e.motionDurationMid, t), {
    [`
        ${i}${n}-enter,
        ${i}${n}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${i}${n}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
}, doe = new Mr("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), hoe = new Mr("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), foe = new Mr("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), poe = new Mr("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), goe = new Mr("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), voe = new Mr("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), moe = new Mr("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), yoe = new Mr("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), Coe = {
  "move-up": {
    inKeyframes: moe,
    outKeyframes: yoe
  },
  "move-down": {
    inKeyframes: doe,
    outKeyframes: hoe
  },
  "move-left": {
    inKeyframes: foe,
    outKeyframes: poe
  },
  "move-right": {
    inKeyframes: goe,
    outKeyframes: voe
  }
}, TO = (e, t) => {
  const {
    antCls: r
  } = e, n = `${r}-${t}`, {
    inKeyframes: i,
    outKeyframes: o
  } = Coe[t];
  return [bS(n, i, o, e.motionDurationMid), {
    [`
        ${n}-enter,
        ${n}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc
    },
    [`${n}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
}, L5 = new Mr("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), F5 = new Mr("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), N5 = new Mr("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
}), k5 = new Mr("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
}), Soe = new Mr("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), woe = new Mr("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), boe = new Mr("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
}), xoe = new Mr("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
}), Eoe = {
  "slide-up": {
    inKeyframes: L5,
    outKeyframes: F5
  },
  "slide-down": {
    inKeyframes: N5,
    outKeyframes: k5
  },
  "slide-left": {
    inKeyframes: Soe,
    outKeyframes: woe
  },
  "slide-right": {
    inKeyframes: boe,
    outKeyframes: xoe
  }
}, N0 = (e, t) => {
  const {
    antCls: r
  } = e, n = `${r}-${t}`, {
    inKeyframes: i,
    outKeyframes: o
  } = Eoe[t];
  return [bS(n, i, o, e.motionDurationMid), {
    [`
      ${n}-enter,
      ${n}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutQuint,
      "&-prepare": {
        transform: "scale(1)"
      }
    },
    [`${n}-leave`]: {
      animationTimingFunction: e.motionEaseInQuint
    }
  }];
}, Roe = new Mr("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), _oe = new Mr("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
}), PO = new Mr("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), MO = new Mr("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
}), Toe = new Mr("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
}), Poe = new Mr("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
}), Moe = new Mr("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
}), Doe = new Mr("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
}), Aoe = new Mr("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
}), Ioe = new Mr("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
}), Ooe = new Mr("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
}), Loe = new Mr("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
}), Foe = {
  zoom: {
    inKeyframes: Roe,
    outKeyframes: _oe
  },
  "zoom-big": {
    inKeyframes: PO,
    outKeyframes: MO
  },
  "zoom-big-fast": {
    inKeyframes: PO,
    outKeyframes: MO
  },
  "zoom-left": {
    inKeyframes: Moe,
    outKeyframes: Doe
  },
  "zoom-right": {
    inKeyframes: Aoe,
    outKeyframes: Ioe
  },
  "zoom-up": {
    inKeyframes: Toe,
    outKeyframes: Poe
  },
  "zoom-down": {
    inKeyframes: Ooe,
    outKeyframes: Loe
  }
}, xS = (e, t) => {
  const {
    antCls: r
  } = e, n = `${r}-${t}`, {
    inKeyframes: i,
    outKeyframes: o
  } = Foe[t];
  return [bS(n, i, o, t === "zoom-big-fast" ? e.motionDurationFast : e.motionDurationMid), {
    [`
        ${n}-enter,
        ${n}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${n}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
};
function DO(e) {
  return {
    position: e,
    inset: 0
  };
}
const V5 = (e) => {
  const {
    componentCls: t,
    antCls: r
  } = e;
  return [{
    [`${t}-root`]: {
      [`${t}${r}-zoom-enter, ${t}${r}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: e.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      // https://github.com/ant-design/ant-design/issues/37329
      // https://github.com/ant-design/ant-design/issues/40272
      [`${t}${r}-zoom-leave ${t}-content`]: {
        pointerEvents: "none"
      },
      [`${t}-mask`]: Object.assign(Object.assign({}, DO("fixed")), {
        zIndex: e.zIndexPopupBase,
        height: "100%",
        backgroundColor: e.colorBgMask,
        pointerEvents: "none",
        [`${t}-hidden`]: {
          display: "none"
        }
      }),
      [`${t}-wrap`]: Object.assign(Object.assign({}, DO("fixed")), {
        zIndex: e.zIndexPopupBase,
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      })
    }
  }, {
    [`${t}-root`]: O5(e)
  }];
}, Noe = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    // ======================== Root =========================
    {
      [`${t}-root`]: {
        [`${t}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${t}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [t]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${e.screenSMMax}px)`]: {
          [t]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${de(e.marginXS)} auto`
          },
          [`${t}-centered`]: {
            [t]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [t]: Object.assign(Object.assign({}, Fi(e)), {
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${de(e.calc(e.margin).mul(2).equal())})`,
        margin: "0 auto",
        paddingBottom: e.paddingLG,
        [`${t}-title`]: {
          margin: 0,
          color: e.titleColor,
          fontWeight: e.fontWeightStrong,
          fontSize: e.titleFontSize,
          lineHeight: e.titleLineHeight,
          wordWrap: "break-word"
        },
        [`${t}-content`]: {
          position: "relative",
          backgroundColor: e.contentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: e.borderRadiusLG,
          boxShadow: e.boxShadow,
          pointerEvents: "auto",
          padding: e.contentPadding
        },
        [`${t}-close`]: Object.assign({
          position: "absolute",
          top: e.calc(e.modalHeaderHeight).sub(e.modalCloseBtnSize).div(2).equal(),
          insetInlineEnd: e.calc(e.modalHeaderHeight).sub(e.modalCloseBtnSize).div(2).equal(),
          zIndex: e.calc(e.zIndexPopupBase).add(10).equal(),
          padding: 0,
          color: e.modalCloseIconColor,
          fontWeight: e.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: e.borderRadiusSM,
          width: e.modalCloseBtnSize,
          height: e.modalCloseBtnSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${e.motionDurationMid}, background-color ${e.motionDurationMid}`,
          "&-x": {
            display: "flex",
            fontSize: e.fontSizeLG,
            fontStyle: "normal",
            lineHeight: `${de(e.modalCloseBtnSize)}`,
            justifyContent: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:hover": {
            color: e.modalCloseIconHoverColor,
            backgroundColor: e.colorBgTextHover,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: e.colorBgTextActive
          }
        }, pS(e)),
        [`${t}-header`]: {
          color: e.colorText,
          background: e.headerBg,
          borderRadius: `${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)} 0 0`,
          marginBottom: e.headerMarginBottom,
          padding: e.headerPadding,
          borderBottom: e.headerBorderBottom
        },
        [`${t}-body`]: {
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          wordWrap: "break-word",
          padding: e.bodyPadding,
          [`${t}-body-skeleton`]: {
            width: "100%",
            height: "100%",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            margin: `${de(e.margin)} auto`
          }
        },
        [`${t}-footer`]: {
          textAlign: "end",
          background: e.footerBg,
          marginTop: e.footerMarginTop,
          padding: e.footerPadding,
          borderTop: e.footerBorderTop,
          borderRadius: e.footerBorderRadius,
          [`> ${e.antCls}-btn + ${e.antCls}-btn`]: {
            marginInlineStart: e.marginXS
          }
        },
        [`${t}-open`]: {
          overflow: "hidden"
        }
      })
    },
    // ======================== Pure =========================
    {
      [`${t}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${t}-content,
          ${t}-body,
          ${t}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${t}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
}, koe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-root`]: {
      [`${t}-wrap-rtl`]: {
        direction: "rtl",
        [`${t}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
}, Voe = (e) => {
  const t = e.padding, r = e.fontSizeHeading5, n = e.lineHeightHeading5;
  return Br(e, {
    modalHeaderHeight: e.calc(e.calc(n).mul(r).equal()).add(e.calc(t).mul(2).equal()).equal(),
    modalFooterBorderColorSplit: e.colorSplit,
    modalFooterBorderStyle: e.lineType,
    modalFooterBorderWidth: e.lineWidth,
    modalCloseIconColor: e.colorIcon,
    modalCloseIconHoverColor: e.colorIconHover,
    modalCloseBtnSize: e.controlHeight,
    modalConfirmIconSize: e.fontHeight,
    modalTitleHeight: e.calc(e.titleFontSize).mul(e.titleLineHeight).equal()
  });
}, Boe = (e) => ({
  footerBg: "transparent",
  headerBg: e.colorBgElevated,
  titleLineHeight: e.lineHeightHeading5,
  titleFontSize: e.fontSizeHeading5,
  contentBg: e.colorBgElevated,
  titleColor: e.colorTextHeading,
  // internal
  contentPadding: e.wireframe ? 0 : `${de(e.paddingMD)} ${de(e.paddingContentHorizontalLG)}`,
  headerPadding: e.wireframe ? `${de(e.padding)} ${de(e.paddingLG)}` : 0,
  headerBorderBottom: e.wireframe ? `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}` : "none",
  headerMarginBottom: e.wireframe ? 0 : e.marginXS,
  bodyPadding: e.wireframe ? e.paddingLG : 0,
  footerPadding: e.wireframe ? `${de(e.paddingXS)} ${de(e.padding)}` : 0,
  footerBorderTop: e.wireframe ? `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}` : "none",
  footerBorderRadius: e.wireframe ? `0 0 ${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)}` : 0,
  footerMarginTop: e.wireframe ? 0 : e.marginSM,
  confirmBodyPadding: e.wireframe ? `${de(e.padding * 2)} ${de(e.padding * 2)} ${de(e.paddingLG)}` : 0,
  confirmIconMarginInlineEnd: e.wireframe ? e.margin : e.marginSM,
  confirmBtnsMarginTop: e.wireframe ? e.marginLG : e.marginSM
});
Gn("Modal", (e) => {
  const t = Voe(e);
  return [Noe(t), koe(t), V5(t), xS(t, "zoom")];
}, Boe, {
  unitless: {
    titleLineHeight: !0
  }
});
function $oe(e) {
  return (t) => /* @__PURE__ */ E.createElement(pu, {
    theme: {
      token: {
        motion: !1,
        zIndexPopupBase: 0
      }
    }
  }, /* @__PURE__ */ E.createElement(e, Object.assign({}, t)));
}
const Hoe = (e, t, r, n) => $oe((o) => {
  const {
    prefixCls: a,
    style: s
  } = o, l = E.useRef(null), [u, c] = E.useState(0), [d, h] = E.useState(0), [f, p] = xn(!1, {
    value: o.open
  }), {
    getPrefixCls: g
  } = E.useContext(Yt), v = g("select", a);
  E.useEffect(() => {
    if (p(!0), typeof ResizeObserver < "u") {
      const C = new ResizeObserver((b) => {
        const w = b[0].target;
        c(w.offsetHeight + 8), h(w.offsetWidth);
      }), S = setInterval(() => {
        var b;
        const w = `.${v}-dropdown`, x = (b = l.current) === null || b === void 0 ? void 0 : b.querySelector(w);
        x && (clearInterval(S), C.observe(x));
      }, 10);
      return () => {
        clearInterval(S), C.disconnect();
      };
    }
  }, []);
  let m = Object.assign(Object.assign({}, o), {
    style: Object.assign(Object.assign({}, s), {
      margin: 0
    }),
    open: f,
    visible: f,
    getPopupContainer: () => l.current
  });
  const y = {
    paddingBottom: u,
    position: "relative",
    minWidth: d
  };
  return /* @__PURE__ */ E.createElement("div", {
    ref: l,
    style: y
  }, /* @__PURE__ */ E.createElement(e, Object.assign({}, m)));
}), WP = function() {
  if (typeof navigator > "u" || typeof window > "u")
    return !1;
  var e = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e == null ? void 0 : e.substr(0, 4));
};
var ES = function(t) {
  var r = t.className, n = t.customizeIcon, i = t.customizeIconProps, o = t.children, a = t.onMouseDown, s = t.onClick, l = typeof n == "function" ? n(i) : n;
  return /* @__PURE__ */ E.createElement("span", {
    className: r,
    onMouseDown: function(c) {
      c.preventDefault(), a == null || a(c);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick: s,
    "aria-hidden": !0
  }, l !== void 0 ? l : /* @__PURE__ */ E.createElement("span", {
    className: ue(r.split(/\s+/).map(function(u) {
      return "".concat(u, "-icon");
    }))
  }, o));
}, Goe = function(t, r, n, i, o) {
  var a = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !1, s = arguments.length > 6 ? arguments[6] : void 0, l = arguments.length > 7 ? arguments[7] : void 0, u = H.useMemo(function() {
    if (vt(i) === "object")
      return i.clearIcon;
    if (o)
      return o;
  }, [i, o]), c = H.useMemo(function() {
    return !!(!a && i && (n.length || s) && !(l === "combobox" && s === ""));
  }, [i, a, n.length, s, l]);
  return {
    allowClear: c,
    clearIcon: /* @__PURE__ */ H.createElement(ES, {
      className: "".concat(t, "-clear"),
      onMouseDown: r,
      customizeIcon: u
    }, "")
  };
}, B5 = /* @__PURE__ */ E.createContext(null);
function zoe() {
  return E.useContext(B5);
}
function Woe() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10, t = E.useState(!1), r = ae(t, 2), n = r[0], i = r[1], o = E.useRef(null), a = function() {
    window.clearTimeout(o.current);
  };
  E.useEffect(function() {
    return a;
  }, []);
  var s = function(u, c) {
    a(), o.current = window.setTimeout(function() {
      i(u), c && c();
    }, e);
  };
  return [n, s, a];
}
function $5() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250, t = E.useRef(null), r = E.useRef(null);
  E.useEffect(function() {
    return function() {
      window.clearTimeout(r.current);
    };
  }, []);
  function n(i) {
    (i || t.current === null) && (t.current = i), window.clearTimeout(r.current), r.current = window.setTimeout(function() {
      t.current = null;
    }, e);
  }
  return [function() {
    return t.current;
  }, n];
}
function joe(e, t, r, n) {
  var i = E.useRef(null);
  i.current = {
    open: t,
    triggerOpen: r,
    customizedTrigger: n
  }, E.useEffect(function() {
    function o(a) {
      var s;
      if (!((s = i.current) !== null && s !== void 0 && s.customizedTrigger)) {
        var l = a.target;
        l.shadowRoot && a.composed && (l = a.composedPath()[0] || l), i.current.open && e().filter(function(u) {
          return u;
        }).every(function(u) {
          return !u.contains(l) && u !== l;
        }) && i.current.triggerOpen(!1);
      }
    }
    return window.addEventListener("mousedown", o), function() {
      return window.removeEventListener("mousedown", o);
    };
  }, []);
}
function Uoe(e) {
  return ![
    // System function button
    Ae.ESC,
    Ae.SHIFT,
    Ae.BACKSPACE,
    Ae.TAB,
    Ae.WIN_KEY,
    Ae.ALT,
    Ae.META,
    Ae.WIN_KEY_RIGHT,
    Ae.CTRL,
    Ae.SEMICOLON,
    Ae.EQUALS,
    Ae.CAPS_LOCK,
    Ae.CONTEXT_MENU,
    // F1-F12
    Ae.F1,
    Ae.F2,
    Ae.F3,
    Ae.F4,
    Ae.F5,
    Ae.F6,
    Ae.F7,
    Ae.F8,
    Ae.F9,
    Ae.F10,
    Ae.F11,
    Ae.F12
  ].includes(e);
}
var Koe = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"], bd = void 0;
function Yoe(e, t) {
  var r = e.prefixCls, n = e.invalidate, i = e.item, o = e.renderItem, a = e.responsive, s = e.responsiveDisabled, l = e.registerSize, u = e.itemKey, c = e.className, d = e.style, h = e.children, f = e.display, p = e.order, g = e.component, v = g === void 0 ? "div" : g, m = $t(e, Koe), y = a && !f;
  function C(R) {
    l(u, R);
  }
  E.useEffect(function() {
    return function() {
      C(null);
    };
  }, []);
  var S = o && i !== bd ? o(i) : h, b;
  n || (b = {
    opacity: y ? 0 : 1,
    height: y ? 0 : bd,
    overflowY: y ? "hidden" : bd,
    order: a ? p : bd,
    pointerEvents: y ? "none" : bd,
    position: y ? "absolute" : bd
  });
  var w = {};
  y && (w["aria-hidden"] = !0);
  var x = /* @__PURE__ */ E.createElement(v, $e({
    className: ue(!n && r, c),
    style: ee(ee({}, b), d)
  }, w, m, {
    ref: t
  }), S);
  return a && (x = /* @__PURE__ */ E.createElement(Co, {
    onResize: function(_) {
      var T = _.offsetWidth;
      C(T);
    },
    disabled: s
  }, x)), x;
}
var Zp = /* @__PURE__ */ E.forwardRef(Yoe);
Zp.displayName = "Item";
function qoe(e) {
  if (typeof MessageChannel > "u")
    Ar(e);
  else {
    var t = new MessageChannel();
    t.port1.onmessage = function() {
      return e();
    }, t.port2.postMessage(void 0);
  }
}
function Xoe() {
  var e = E.useRef(null), t = function(n) {
    e.current || (e.current = [], qoe(function() {
      WX(function() {
        e.current.forEach(function(i) {
          i();
        }), e.current = null;
      });
    })), e.current.push(n);
  };
  return t;
}
function zf(e, t) {
  var r = E.useState(t), n = ae(r, 2), i = n[0], o = n[1], a = An(function(s) {
    e(function() {
      o(s);
    });
  });
  return [i, a];
}
var k0 = /* @__PURE__ */ H.createContext(null), Zoe = ["component"], Qoe = ["className"], Joe = ["className"], eae = function(t, r) {
  var n = E.useContext(k0);
  if (!n) {
    var i = t.component, o = i === void 0 ? "div" : i, a = $t(t, Zoe);
    return /* @__PURE__ */ E.createElement(o, $e({}, a, {
      ref: r
    }));
  }
  var s = n.className, l = $t(n, Qoe), u = t.className, c = $t(t, Joe);
  return /* @__PURE__ */ E.createElement(k0.Provider, {
    value: null
  }, /* @__PURE__ */ E.createElement(Zp, $e({
    ref: r,
    className: ue(s, u)
  }, l, c)));
}, H5 = /* @__PURE__ */ E.forwardRef(eae);
H5.displayName = "RawItem";
var tae = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"], G5 = "responsive", z5 = "invalidate";
function rae(e) {
  return "+ ".concat(e.length, " ...");
}
function nae(e, t) {
  var r = e.prefixCls, n = r === void 0 ? "rc-overflow" : r, i = e.data, o = i === void 0 ? [] : i, a = e.renderItem, s = e.renderRawItem, l = e.itemKey, u = e.itemWidth, c = u === void 0 ? 10 : u, d = e.ssr, h = e.style, f = e.className, p = e.maxCount, g = e.renderRest, v = e.renderRawRest, m = e.suffix, y = e.component, C = y === void 0 ? "div" : y, S = e.itemComponent, b = e.onVisibleChange, w = $t(e, tae), x = d === "full", R = Xoe(), _ = zf(R, null), T = ae(_, 2), P = T[0], D = T[1], O = P || 0, A = zf(R, /* @__PURE__ */ new Map()), F = ae(A, 2), L = F[0], N = F[1], I = zf(R, 0), B = ae(I, 2), M = B[0], V = B[1], G = zf(R, 0), k = ae(G, 2), z = k[0], j = k[1], q = zf(R, 0), K = ae(q, 2), Z = K[0], re = K[1], X = Me(null), Y = ae(X, 2), U = Y[0], oe = Y[1], W = Me(null), ne = ae(W, 2), ce = ne[0], we = ne[1], Re = E.useMemo(function() {
    return ce === null && x ? Number.MAX_SAFE_INTEGER : ce || 0;
  }, [ce, P]), ve = Me(!1), xe = ae(ve, 2), _e = xe[0], Ve = xe[1], Fe = "".concat(n, "-item"), Ne = Math.max(M, z), Je = p === G5, J = o.length && Je, he = p === z5, Le = J || typeof p == "number" && o.length > p, Pe = Et(function() {
    var mt = o;
    return J ? P === null && x ? mt = o : mt = o.slice(0, Math.min(o.length, O / c)) : typeof p == "number" && (mt = o.slice(0, p)), mt;
  }, [o, c, P, p, J]), Ie = Et(function() {
    return J ? o.slice(Re + 1) : o.slice(Pe.length);
  }, [o, Pe, J, Re]), Ce = lr(function(mt, qe) {
    var zt;
    return typeof l == "function" ? l(mt) : (zt = l && (mt == null ? void 0 : mt[l])) !== null && zt !== void 0 ? zt : qe;
  }, [l]), De = lr(a || function(mt) {
    return mt;
  }, [a]);
  function ze(mt, qe, zt) {
    ce === mt && (qe === void 0 || qe === U) || (we(mt), zt || (Ve(mt < o.length - 1), b == null || b(mt)), qe !== void 0 && oe(qe));
  }
  function st(mt, qe) {
    D(qe.clientWidth);
  }
  function Tt(mt, qe) {
    N(function(zt) {
      var fr = new Map(zt);
      return qe === null ? fr.delete(mt) : fr.set(mt, qe), fr;
    });
  }
  function ot(mt, qe) {
    j(qe), V(z);
  }
  function Xe(mt, qe) {
    re(qe);
  }
  function Oe(mt) {
    return L.get(Ce(Pe[mt], mt));
  }
  kr(function() {
    if (O && typeof Ne == "number" && Pe) {
      var mt = Z, qe = Pe.length, zt = qe - 1;
      if (!qe) {
        ze(0, null);
        return;
      }
      for (var fr = 0; fr < qe; fr += 1) {
        var Ge = Oe(fr);
        if (x && (Ge = Ge || 0), Ge === void 0) {
          ze(fr - 1, void 0, !0);
          break;
        }
        if (mt += Ge, // Only one means `totalWidth` is the final width
        zt === 0 && mt <= O || // Last two width will be the final width
        fr === zt - 1 && mt + Oe(zt) <= O) {
          ze(zt, null);
          break;
        } else if (mt + Ne > O) {
          ze(fr - 1, mt - Ge - Z + z);
          break;
        }
      }
      m && Oe(0) + Z > O && oe(null);
    }
  }, [O, L, z, Z, Ce, Pe]);
  var Qe = _e && !!Ie.length, ft = {};
  U !== null && J && (ft = {
    position: "absolute",
    left: U,
    top: 0
  });
  var xt = {
    prefixCls: Fe,
    responsive: J,
    component: S,
    invalidate: he
  }, $r = s ? function(mt, qe) {
    var zt = Ce(mt, qe);
    return /* @__PURE__ */ E.createElement(k0.Provider, {
      key: zt,
      value: ee(ee({}, xt), {}, {
        order: qe,
        item: mt,
        itemKey: zt,
        registerSize: Tt,
        display: qe <= Re
      })
    }, s(mt, qe));
  } : function(mt, qe) {
    var zt = Ce(mt, qe);
    return /* @__PURE__ */ E.createElement(Zp, $e({}, xt, {
      order: qe,
      key: zt,
      item: mt,
      renderItem: De,
      itemKey: zt,
      registerSize: Tt,
      display: qe <= Re
    }));
  }, hr, Gt = {
    order: Qe ? Re : Number.MAX_SAFE_INTEGER,
    className: "".concat(Fe, "-rest"),
    registerSize: ot,
    display: Qe
  };
  if (v)
    v && (hr = /* @__PURE__ */ E.createElement(k0.Provider, {
      value: ee(ee({}, xt), Gt)
    }, v(Ie)));
  else {
    var Ot = g || rae;
    hr = /* @__PURE__ */ E.createElement(Zp, $e({}, xt, Gt), typeof Ot == "function" ? Ot(Ie) : Ot);
  }
  var Lt = /* @__PURE__ */ E.createElement(C, $e({
    className: ue(!he && n, f),
    style: h,
    ref: t
  }, w), Pe.map($r), Le ? hr : null, m && /* @__PURE__ */ E.createElement(Zp, $e({}, xt, {
    responsive: Je,
    responsiveDisabled: !J,
    order: Re,
    className: "".concat(Fe, "-suffix"),
    registerSize: Xe,
    display: !0,
    style: ft
  }), m));
  return Je && (Lt = /* @__PURE__ */ E.createElement(Co, {
    onResize: st,
    disabled: !J
  }, Lt)), Lt;
}
var ss = /* @__PURE__ */ E.forwardRef(nae);
ss.displayName = "Overflow";
ss.Item = H5;
ss.RESPONSIVE = G5;
ss.INVALIDATE = z5;
var iae = function(t, r) {
  var n, i = t.prefixCls, o = t.id, a = t.inputElement, s = t.disabled, l = t.tabIndex, u = t.autoFocus, c = t.autoComplete, d = t.editable, h = t.activeDescendantId, f = t.value, p = t.maxLength, g = t.onKeyDown, v = t.onMouseDown, m = t.onChange, y = t.onPaste, C = t.onCompositionStart, S = t.onCompositionEnd, b = t.open, w = t.attrs, x = a || /* @__PURE__ */ E.createElement("input", null), R = x, _ = R.ref, T = R.props, P = T.onKeyDown, D = T.onChange, O = T.onMouseDown, A = T.onCompositionStart, F = T.onCompositionEnd, L = T.style;
  return fs(!("maxLength" in x.props), "Passing 'maxLength' to input element directly may not work because input in BaseSelect is controlled."), x = /* @__PURE__ */ E.cloneElement(x, ee(ee(ee({
    type: "search"
  }, T), {}, {
    // Override over origin props
    id: o,
    ref: Eo(r, _),
    disabled: s,
    tabIndex: l,
    autoComplete: c || "off",
    autoFocus: u,
    className: ue("".concat(i, "-selection-search-input"), (n = x) === null || n === void 0 || (n = n.props) === null || n === void 0 ? void 0 : n.className),
    role: "combobox",
    "aria-expanded": b || !1,
    "aria-haspopup": "listbox",
    "aria-owns": "".concat(o, "_list"),
    "aria-autocomplete": "list",
    "aria-controls": "".concat(o, "_list"),
    "aria-activedescendant": b ? h : void 0
  }, w), {}, {
    value: d ? f : "",
    maxLength: p,
    readOnly: !d,
    unselectable: d ? null : "on",
    style: ee(ee({}, L), {}, {
      opacity: d ? null : 0
    }),
    onKeyDown: function(I) {
      g(I), P && P(I);
    },
    onMouseDown: function(I) {
      v(I), O && O(I);
    },
    onChange: function(I) {
      m(I), D && D(I);
    },
    onCompositionStart: function(I) {
      C(I), A && A(I);
    },
    onCompositionEnd: function(I) {
      S(I), F && F(I);
    },
    onPaste: y
  })), x;
}, jP = /* @__PURE__ */ E.forwardRef(iae);
process.env.NODE_ENV !== "production" && (jP.displayName = "Input");
function UP(e) {
  return Array.isArray(e) ? e : e !== void 0 ? [e] : [];
}
var oae = typeof window < "u" && window.document && window.document.documentElement, aae = process.env.NODE_ENV !== "test" && oae;
function sae(e) {
  return e != null;
}
function lae(e) {
  return !e && e !== 0;
}
function AO(e) {
  return ["string", "number"].includes(vt(e));
}
function W5(e) {
  var t = void 0;
  return e && (AO(e.title) ? t = e.title.toString() : AO(e.label) && (t = e.label.toString())), t;
}
function uae(e, t) {
  aae ? E.useLayoutEffect(e, t) : E.useEffect(e, t);
}
function cae(e) {
  var t;
  return (t = e.key) !== null && t !== void 0 ? t : e.value;
}
var IO = function(t) {
  t.preventDefault(), t.stopPropagation();
}, dae = function(t) {
  var r = t.id, n = t.prefixCls, i = t.values, o = t.open, a = t.searchValue, s = t.autoClearSearchValue, l = t.inputRef, u = t.placeholder, c = t.disabled, d = t.mode, h = t.showSearch, f = t.autoFocus, p = t.autoComplete, g = t.activeDescendantId, v = t.tabIndex, m = t.removeIcon, y = t.maxTagCount, C = t.maxTagTextLength, S = t.maxTagPlaceholder, b = S === void 0 ? function(oe) {
    return "+ ".concat(oe.length, " ...");
  } : S, w = t.tagRender, x = t.onToggleOpen, R = t.onRemove, _ = t.onInputChange, T = t.onInputPaste, P = t.onInputKeyDown, D = t.onInputMouseDown, O = t.onInputCompositionStart, A = t.onInputCompositionEnd, F = E.useRef(null), L = Me(0), N = ae(L, 2), I = N[0], B = N[1], M = Me(!1), V = ae(M, 2), G = V[0], k = V[1], z = "".concat(n, "-selection"), j = o || d === "multiple" && s === !1 || d === "tags" ? a : "", q = d === "tags" || d === "multiple" && s === !1 || h && (o || G);
  uae(function() {
    B(F.current.scrollWidth);
  }, [j]);
  var K = function(W, ne, ce, we, Re) {
    return /* @__PURE__ */ E.createElement("span", {
      title: W5(W),
      className: ue("".concat(z, "-item"), te({}, "".concat(z, "-item-disabled"), ce))
    }, /* @__PURE__ */ E.createElement("span", {
      className: "".concat(z, "-item-content")
    }, ne), we && /* @__PURE__ */ E.createElement(ES, {
      className: "".concat(z, "-item-remove"),
      onMouseDown: IO,
      onClick: Re,
      customizeIcon: m
    }, ""));
  }, Z = function(W, ne, ce, we, Re, ve) {
    var xe = function(Ve) {
      IO(Ve), x(!o);
    };
    return /* @__PURE__ */ E.createElement("span", {
      onMouseDown: xe
    }, w({
      label: ne,
      value: W,
      disabled: ce,
      closable: we,
      onClose: Re,
      isMaxTag: !!ve
    }));
  }, re = function(W) {
    var ne = W.disabled, ce = W.label, we = W.value, Re = !c && !ne, ve = ce;
    if (typeof C == "number" && (typeof ce == "string" || typeof ce == "number")) {
      var xe = String(ve);
      xe.length > C && (ve = "".concat(xe.slice(0, C), "..."));
    }
    var _e = function(Fe) {
      Fe && Fe.stopPropagation(), R(W);
    };
    return typeof w == "function" ? Z(we, ve, ne, Re, _e) : K(W, ve, ne, Re, _e);
  }, X = function(W) {
    var ne = typeof b == "function" ? b(W) : b;
    return typeof w == "function" ? Z(void 0, ne, !1, !1, void 0, !0) : K({
      title: ne
    }, ne, !1);
  }, Y = /* @__PURE__ */ E.createElement("div", {
    className: "".concat(z, "-search"),
    style: {
      width: I
    },
    onFocus: function() {
      k(!0);
    },
    onBlur: function() {
      k(!1);
    }
  }, /* @__PURE__ */ E.createElement(jP, {
    ref: l,
    open: o,
    prefixCls: n,
    id: r,
    inputElement: null,
    disabled: c,
    autoFocus: f,
    autoComplete: p,
    editable: q,
    activeDescendantId: g,
    value: j,
    onKeyDown: P,
    onMouseDown: D,
    onChange: _,
    onPaste: T,
    onCompositionStart: O,
    onCompositionEnd: A,
    tabIndex: v,
    attrs: Zl(t, !0)
  }), /* @__PURE__ */ E.createElement("span", {
    ref: F,
    className: "".concat(z, "-search-mirror"),
    "aria-hidden": !0
  }, j, "")), U = /* @__PURE__ */ E.createElement(ss, {
    prefixCls: "".concat(z, "-overflow"),
    data: i,
    renderItem: re,
    renderRest: X,
    suffix: Y,
    itemKey: cae,
    maxCount: y
  });
  return /* @__PURE__ */ E.createElement(E.Fragment, null, U, !i.length && !j && /* @__PURE__ */ E.createElement("span", {
    className: "".concat(z, "-placeholder")
  }, u));
}, hae = function(t) {
  var r = t.inputElement, n = t.prefixCls, i = t.id, o = t.inputRef, a = t.disabled, s = t.autoFocus, l = t.autoComplete, u = t.activeDescendantId, c = t.mode, d = t.open, h = t.values, f = t.placeholder, p = t.tabIndex, g = t.showSearch, v = t.searchValue, m = t.activeValue, y = t.maxLength, C = t.onInputKeyDown, S = t.onInputMouseDown, b = t.onInputChange, w = t.onInputPaste, x = t.onInputCompositionStart, R = t.onInputCompositionEnd, _ = t.title, T = E.useState(!1), P = ae(T, 2), D = P[0], O = P[1], A = c === "combobox", F = A || g, L = h[0], N = v || "";
  A && m && !D && (N = m), E.useEffect(function() {
    A && O(!1);
  }, [A, m]);
  var I = c !== "combobox" && !d && !g ? !1 : !!N, B = _ === void 0 ? W5(L) : _, M = E.useMemo(function() {
    return L ? null : /* @__PURE__ */ E.createElement("span", {
      className: "".concat(n, "-selection-placeholder"),
      style: I ? {
        visibility: "hidden"
      } : void 0
    }, f);
  }, [L, I, f, n]);
  return /* @__PURE__ */ E.createElement(E.Fragment, null, /* @__PURE__ */ E.createElement("span", {
    className: "".concat(n, "-selection-search")
  }, /* @__PURE__ */ E.createElement(jP, {
    ref: o,
    prefixCls: n,
    id: i,
    open: d,
    inputElement: r,
    disabled: a,
    autoFocus: s,
    autoComplete: l,
    editable: F,
    activeDescendantId: u,
    value: N,
    onKeyDown: C,
    onMouseDown: S,
    onChange: function(G) {
      O(!0), b(G);
    },
    onPaste: w,
    onCompositionStart: x,
    onCompositionEnd: R,
    tabIndex: p,
    attrs: Zl(t, !0),
    maxLength: A ? y : void 0
  })), !A && L ? /* @__PURE__ */ E.createElement("span", {
    className: "".concat(n, "-selection-item"),
    title: B,
    style: I ? {
      visibility: "hidden"
    } : void 0
  }, L.label) : null, M);
}, fae = function(t, r) {
  var n = se(null), i = se(!1), o = t.prefixCls, a = t.open, s = t.mode, l = t.showSearch, u = t.tokenWithEnter, c = t.disabled, d = t.autoClearSearchValue, h = t.onSearch, f = t.onSearchSubmit, p = t.onToggleOpen, g = t.onInputKeyDown, v = t.domRef;
  E.useImperativeHandle(r, function() {
    return {
      focus: function(I) {
        n.current.focus(I);
      },
      blur: function() {
        n.current.blur();
      }
    };
  });
  var m = $5(0), y = ae(m, 2), C = y[0], S = y[1], b = function(I) {
    var B = I.which;
    (B === Ae.UP || B === Ae.DOWN) && I.preventDefault(), g && g(I), B === Ae.ENTER && s === "tags" && !i.current && !a && (f == null || f(I.target.value)), Uoe(B) && p(!0);
  }, w = function() {
    S(!0);
  }, x = se(null), R = function(I) {
    h(I, !0, i.current) !== !1 && p(!0);
  }, _ = function() {
    i.current = !0;
  }, T = function(I) {
    i.current = !1, s !== "combobox" && R(I.target.value);
  }, P = function(I) {
    var B = I.target.value;
    if (u && x.current && /[\r\n]/.test(x.current)) {
      var M = x.current.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
      B = B.replace(M, x.current);
    }
    x.current = null, R(B);
  }, D = function(I) {
    var B = I.clipboardData, M = B == null ? void 0 : B.getData("text");
    x.current = M || "";
  }, O = function(I) {
    var B = I.target;
    if (B !== n.current) {
      var M = document.body.style.msTouchAction !== void 0;
      M ? setTimeout(function() {
        n.current.focus();
      }) : n.current.focus();
    }
  }, A = function(I) {
    var B = C();
    I.target !== n.current && !B && !(s === "combobox" && c) && I.preventDefault(), (s !== "combobox" && (!l || !B) || !a) && (a && d !== !1 && h("", !0, !1), p());
  }, F = {
    inputRef: n,
    onInputKeyDown: b,
    onInputMouseDown: w,
    onInputChange: P,
    onInputPaste: D,
    onInputCompositionStart: _,
    onInputCompositionEnd: T
  }, L = s === "multiple" || s === "tags" ? /* @__PURE__ */ E.createElement(dae, $e({}, t, F)) : /* @__PURE__ */ E.createElement(hae, $e({}, t, F));
  return /* @__PURE__ */ E.createElement("div", {
    ref: v,
    className: "".concat(o, "-selector"),
    onClick: O,
    onMouseDown: A
  }, L);
}, j5 = /* @__PURE__ */ E.forwardRef(fae);
process.env.NODE_ENV !== "production" && (j5.displayName = "Selector");
function pae(e) {
  var t = e.prefixCls, r = e.align, n = e.arrow, i = e.arrowPos, o = n || {}, a = o.className, s = o.content, l = i.x, u = l === void 0 ? 0 : l, c = i.y, d = c === void 0 ? 0 : c, h = E.useRef();
  if (!r || !r.points)
    return null;
  var f = {
    position: "absolute"
  };
  if (r.autoArrow !== !1) {
    var p = r.points[0], g = r.points[1], v = p[0], m = p[1], y = g[0], C = g[1];
    v === y || !["t", "b"].includes(v) ? f.top = d : v === "t" ? f.top = 0 : f.bottom = 0, m === C || !["l", "r"].includes(m) ? f.left = u : m === "l" ? f.left = 0 : f.right = 0;
  }
  return /* @__PURE__ */ E.createElement("div", {
    ref: h,
    className: ue("".concat(t, "-arrow"), a),
    style: f
  }, s);
}
function gae(e) {
  var t = e.prefixCls, r = e.open, n = e.zIndex, i = e.mask, o = e.motion;
  return i ? /* @__PURE__ */ E.createElement(Cs, $e({}, o, {
    motionAppear: !0,
    visible: r,
    removeOnLeave: !0
  }), function(a) {
    var s = a.className;
    return /* @__PURE__ */ E.createElement("div", {
      style: {
        zIndex: n
      },
      className: ue("".concat(t, "-mask"), s)
    });
  }) : null;
}
var U5 = /* @__PURE__ */ E.memo(function(e) {
  var t = e.children;
  return t;
}, function(e, t) {
  return t.cache;
});
process.env.NODE_ENV !== "production" && (U5.displayName = "PopupContent");
var K5 = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.popup, n = e.className, i = e.prefixCls, o = e.style, a = e.target, s = e.onVisibleChanged, l = e.open, u = e.keepDom, c = e.fresh, d = e.onClick, h = e.mask, f = e.arrow, p = e.arrowPos, g = e.align, v = e.motion, m = e.maskMotion, y = e.forceRender, C = e.getPopupContainer, S = e.autoDestroy, b = e.portal, w = e.zIndex, x = e.onMouseEnter, R = e.onMouseLeave, _ = e.onPointerEnter, T = e.ready, P = e.offsetX, D = e.offsetY, O = e.offsetR, A = e.offsetB, F = e.onAlign, L = e.onPrepare, N = e.stretch, I = e.targetWidth, B = e.targetHeight, M = typeof r == "function" ? r() : r, V = l || u, G = (C == null ? void 0 : C.length) > 0, k = E.useState(!C || !G), z = ae(k, 2), j = z[0], q = z[1];
  if (kr(function() {
    !j && G && a && q(!0);
  }, [j, G, a]), !j)
    return null;
  var K = "auto", Z = {
    left: "-1000vw",
    top: "-1000vh",
    right: K,
    bottom: K
  };
  if (T || !l) {
    var re, X = g.points, Y = g.dynamicInset || ((re = g._experimental) === null || re === void 0 ? void 0 : re.dynamicInset), U = Y && X[0][1] === "r", oe = Y && X[0][0] === "b";
    U ? (Z.right = O, Z.left = K) : (Z.left = P, Z.right = K), oe ? (Z.bottom = A, Z.top = K) : (Z.top = D, Z.bottom = K);
  }
  var W = {};
  return N && (N.includes("height") && B ? W.height = B : N.includes("minHeight") && B && (W.minHeight = B), N.includes("width") && I ? W.width = I : N.includes("minWidth") && I && (W.minWidth = I)), l || (W.pointerEvents = "none"), /* @__PURE__ */ E.createElement(b, {
    open: y || V,
    getContainer: C && function() {
      return C(a);
    },
    autoDestroy: S
  }, /* @__PURE__ */ E.createElement(gae, {
    prefixCls: i,
    open: l,
    zIndex: w,
    mask: h,
    motion: m
  }), /* @__PURE__ */ E.createElement(Co, {
    onResize: F,
    disabled: !l
  }, function(ne) {
    return /* @__PURE__ */ E.createElement(Cs, $e({
      motionAppear: !0,
      motionEnter: !0,
      motionLeave: !0,
      removeOnLeave: !1,
      forceRender: y,
      leavedClassName: "".concat(i, "-hidden")
    }, v, {
      onAppearPrepare: L,
      onEnterPrepare: L,
      visible: l,
      onVisibleChanged: function(we) {
        var Re;
        v == null || (Re = v.onVisibleChanged) === null || Re === void 0 || Re.call(v, we), s(we);
      }
    }), function(ce, we) {
      var Re = ce.className, ve = ce.style, xe = ue(i, Re, n);
      return /* @__PURE__ */ E.createElement("div", {
        ref: Eo(ne, t, we),
        className: xe,
        style: ee(ee(ee(ee({
          "--arrow-x": "".concat(p.x || 0, "px"),
          "--arrow-y": "".concat(p.y || 0, "px")
        }, Z), W), ve), {}, {
          boxSizing: "border-box",
          zIndex: w
        }, o),
        onMouseEnter: x,
        onMouseLeave: R,
        onPointerEnter: _,
        onClick: d
      }, f && /* @__PURE__ */ E.createElement(pae, {
        prefixCls: i,
        arrow: f,
        arrowPos: p,
        align: g
      }), /* @__PURE__ */ E.createElement(U5, {
        cache: !l && !c
      }, M));
    });
  }));
});
process.env.NODE_ENV !== "production" && (K5.displayName = "Popup");
var Y5 = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.children, n = e.getTriggerDOMNode, i = Jc(r), o = E.useCallback(function(s) {
    wP(t, n ? n(s) : s);
  }, [n]), a = Qc(o, r.ref);
  return i ? /* @__PURE__ */ E.cloneElement(r, {
    ref: a
  }) : r;
});
process.env.NODE_ENV !== "production" && (Y5.displayName = "TriggerWrapper");
var OO = /* @__PURE__ */ E.createContext(null);
function LO(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
function vae(e, t, r, n) {
  return E.useMemo(function() {
    var i = LO(r ?? t), o = LO(n ?? t), a = new Set(i), s = new Set(o);
    return e && (a.has("hover") && (a.delete("hover"), a.add("click")), s.has("hover") && (s.delete("hover"), s.add("click"))), [a, s];
  }, [e, t, r, n]);
}
function mae() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = arguments.length > 2 ? arguments[2] : void 0;
  return r ? e[0] === t[0] : e[0] === t[0] && e[1] === t[1];
}
function yae(e, t, r, n) {
  for (var i = r.points, o = Object.keys(e), a = 0; a < o.length; a += 1) {
    var s, l = o[a];
    if (mae((s = e[l]) === null || s === void 0 ? void 0 : s.points, i, n))
      return "".concat(t, "-placement-").concat(l);
  }
  return "";
}
function FO(e, t, r, n) {
  return t || (r ? {
    motionName: "".concat(e, "-").concat(r)
  } : n ? {
    motionName: n
  } : null);
}
function bv(e) {
  return e.ownerDocument.defaultView;
}
function OR(e) {
  for (var t = [], r = e == null ? void 0 : e.parentElement, n = ["hidden", "scroll", "clip", "auto"]; r; ) {
    var i = bv(r).getComputedStyle(r), o = i.overflowX, a = i.overflowY, s = i.overflow;
    [o, a, s].some(function(l) {
      return n.includes(l);
    }) && t.push(r), r = r.parentElement;
  }
  return t;
}
function Og(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  return Number.isNaN(e) ? t : e;
}
function Wf(e) {
  return Og(parseFloat(e), 0);
}
function NO(e, t) {
  var r = ee({}, e);
  return (t || []).forEach(function(n) {
    if (!(n instanceof HTMLBodyElement || n instanceof HTMLHtmlElement)) {
      var i = bv(n).getComputedStyle(n), o = i.overflow, a = i.overflowClipMargin, s = i.borderTopWidth, l = i.borderBottomWidth, u = i.borderLeftWidth, c = i.borderRightWidth, d = n.getBoundingClientRect(), h = n.offsetHeight, f = n.clientHeight, p = n.offsetWidth, g = n.clientWidth, v = Wf(s), m = Wf(l), y = Wf(u), C = Wf(c), S = Og(Math.round(d.width / p * 1e3) / 1e3), b = Og(Math.round(d.height / h * 1e3) / 1e3), w = (p - g - y - C) * S, x = (h - f - v - m) * b, R = v * b, _ = m * b, T = y * S, P = C * S, D = 0, O = 0;
      if (o === "clip") {
        var A = Wf(a);
        D = A * S, O = A * b;
      }
      var F = d.x + T - D, L = d.y + R - O, N = F + d.width + 2 * D - T - P - w, I = L + d.height + 2 * O - R - _ - x;
      r.left = Math.max(r.left, F), r.top = Math.max(r.top, L), r.right = Math.min(r.right, N), r.bottom = Math.min(r.bottom, I);
    }
  }), r;
}
function kO(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = "".concat(t), n = r.match(/^(.*)\%$/);
  return n ? e * (parseFloat(n[1]) / 100) : parseFloat(r);
}
function VO(e, t) {
  var r = t || [], n = ae(r, 2), i = n[0], o = n[1];
  return [kO(e.width, i), kO(e.height, o)];
}
function BO() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return [e[0], e[1]];
}
function xd(e, t) {
  var r = t[0], n = t[1], i, o;
  return r === "t" ? o = e.y : r === "b" ? o = e.y + e.height : o = e.y + e.height / 2, n === "l" ? i = e.x : n === "r" ? i = e.x + e.width : i = e.x + e.width / 2, {
    x: i,
    y: o
  };
}
function pl(e, t) {
  var r = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  return e.map(function(n, i) {
    return i === t ? r[n] || "c" : n;
  }).join("");
}
function Cae(e, t, r, n, i, o, a) {
  var s = E.useState({
    ready: !1,
    offsetX: 0,
    offsetY: 0,
    offsetR: 0,
    offsetB: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: i[n] || {}
  }), l = ae(s, 2), u = l[0], c = l[1], d = E.useRef(0), h = E.useMemo(function() {
    return t ? OR(t) : [];
  }, [t]), f = E.useRef({}), p = function() {
    f.current = {};
  };
  e || p();
  var g = An(function() {
    if (t && r && e) {
      let mi = function(yi, ca) {
        var fl = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : xe, yd = M.x + yi, kf = M.y + ca, Vf = yd + re, om = kf + Z, Gw = Math.max(yd, fl.left), zw = Math.max(kf, fl.top), Ww = Math.min(Vf, fl.right), jw = Math.min(om, fl.bottom);
        return Math.max(0, (Ww - Gw) * (jw - zw));
      }, Eu = function() {
        Q = M.y + Ot, ye = Q + Z, me = M.x + Gt, Ue = me + re;
      };
      var y, C, S = t, b = S.ownerDocument, w = bv(S), x = w.getComputedStyle(S), R = x.width, _ = x.height, T = x.position, P = S.style.left, D = S.style.top, O = S.style.right, A = S.style.bottom, F = S.style.overflow, L = ee(ee({}, i[n]), o), N = b.createElement("div");
      (y = S.parentElement) === null || y === void 0 || y.appendChild(N), N.style.left = "".concat(S.offsetLeft, "px"), N.style.top = "".concat(S.offsetTop, "px"), N.style.position = T, N.style.height = "".concat(S.offsetHeight, "px"), N.style.width = "".concat(S.offsetWidth, "px"), S.style.left = "0", S.style.top = "0", S.style.right = "auto", S.style.bottom = "auto", S.style.overflow = "hidden";
      var I;
      if (Array.isArray(r))
        I = {
          x: r[0],
          y: r[1],
          width: 0,
          height: 0
        };
      else {
        var B = r.getBoundingClientRect();
        I = {
          x: B.x,
          y: B.y,
          width: B.width,
          height: B.height
        };
      }
      var M = S.getBoundingClientRect(), V = b.documentElement, G = V.clientWidth, k = V.clientHeight, z = V.scrollWidth, j = V.scrollHeight, q = V.scrollTop, K = V.scrollLeft, Z = M.height, re = M.width, X = I.height, Y = I.width, U = {
        left: 0,
        top: 0,
        right: G,
        bottom: k
      }, oe = {
        left: -K,
        top: -q,
        right: z - K,
        bottom: j - q
      }, W = L.htmlRegion, ne = "visible", ce = "visibleFirst";
      W !== "scroll" && W !== ce && (W = ne);
      var we = W === ce, Re = NO(oe, h), ve = NO(U, h), xe = W === ne ? ve : Re, _e = we ? ve : xe;
      S.style.left = "auto", S.style.top = "auto", S.style.right = "0", S.style.bottom = "0";
      var Ve = S.getBoundingClientRect();
      S.style.left = P, S.style.top = D, S.style.right = O, S.style.bottom = A, S.style.overflow = F, (C = S.parentElement) === null || C === void 0 || C.removeChild(N);
      var Fe = Og(Math.round(re / parseFloat(R) * 1e3) / 1e3), Ne = Og(Math.round(Z / parseFloat(_) * 1e3) / 1e3);
      if (Fe === 0 || Ne === 0 || bg(r) && !VP(r))
        return;
      var Je = L.offset, J = L.targetOffset, he = VO(M, Je), Le = ae(he, 2), Pe = Le[0], Ie = Le[1], Ce = VO(I, J), De = ae(Ce, 2), ze = De[0], st = De[1];
      I.x -= ze, I.y -= st;
      var Tt = L.points || [], ot = ae(Tt, 2), Xe = ot[0], Oe = ot[1], Qe = BO(Oe), ft = BO(Xe), xt = xd(I, Qe), $r = xd(M, ft), hr = ee({}, L), Gt = xt.x - $r.x + Pe, Ot = xt.y - $r.y + Ie, Lt = mi(Gt, Ot), mt = mi(Gt, Ot, ve), qe = xd(I, ["t", "l"]), zt = xd(M, ["t", "l"]), fr = xd(I, ["b", "r"]), Ge = xd(M, ["b", "r"]), Ze = L.overflow || {}, tt = Ze.adjustX, ht = Ze.adjustY, It = Ze.shiftX, qt = Ze.shiftY, Hr = function(ca) {
        return typeof ca == "boolean" ? ca : ca >= 0;
      }, Q, ye, me, Ue;
      Eu();
      var pt = Hr(ht), gt = ft[0] === Qe[0];
      if (pt && ft[0] === "t" && (ye > _e.bottom || f.current.bt)) {
        var yt = Ot;
        gt ? yt -= Z - X : yt = qe.y - Ge.y - Ie;
        var Rt = mi(Gt, yt), et = mi(Gt, yt, ve);
        // Of course use larger one
        Rt > Lt || Rt === Lt && (!we || // Choose recommend one
        et >= mt) ? (f.current.bt = !0, Ot = yt, Ie = -Ie, hr.points = [pl(ft, 0), pl(Qe, 0)]) : f.current.bt = !1;
      }
      if (pt && ft[0] === "b" && (Q < _e.top || f.current.tb)) {
        var Ke = Ot;
        gt ? Ke += Z - X : Ke = fr.y - zt.y - Ie;
        var rt = mi(Gt, Ke), er = mi(Gt, Ke, ve);
        // Of course use larger one
        rt > Lt || rt === Lt && (!we || // Choose recommend one
        er >= mt) ? (f.current.tb = !0, Ot = Ke, Ie = -Ie, hr.points = [pl(ft, 0), pl(Qe, 0)]) : f.current.tb = !1;
      }
      var Xr = Hr(tt), Rn = ft[1] === Qe[1];
      if (Xr && ft[1] === "l" && (Ue > _e.right || f.current.rl)) {
        var wr = Gt;
        Rn ? wr -= re - Y : wr = qe.x - Ge.x - Pe;
        var Vi = mi(wr, Ot), to = mi(wr, Ot, ve);
        // Of course use larger one
        Vi > Lt || Vi === Lt && (!we || // Choose recommend one
        to >= mt) ? (f.current.rl = !0, Gt = wr, Pe = -Pe, hr.points = [pl(ft, 1), pl(Qe, 1)]) : f.current.rl = !1;
      }
      if (Xr && ft[1] === "r" && (me < _e.left || f.current.lr)) {
        var _n = Gt;
        Rn ? _n += re - Y : _n = fr.x - zt.x - Pe;
        var gi = mi(_n, Ot), hl = mi(_n, Ot, ve);
        // Of course use larger one
        gi > Lt || gi === Lt && (!we || // Choose recommend one
        hl >= mt) ? (f.current.lr = !0, Gt = _n, Pe = -Pe, hr.points = [pl(ft, 1), pl(Qe, 1)]) : f.current.lr = !1;
      }
      Eu();
      var Bi = It === !0 ? 0 : It;
      typeof Bi == "number" && (me < ve.left && (Gt -= me - ve.left - Pe, I.x + Y < ve.left + Bi && (Gt += I.x - ve.left + Y - Bi)), Ue > ve.right && (Gt -= Ue - ve.right - Pe, I.x > ve.right - Bi && (Gt += I.x - ve.right + Bi)));
      var $i = qt === !0 ? 0 : qt;
      typeof $i == "number" && (Q < ve.top && (Ot -= Q - ve.top - Ie, I.y + X < ve.top + $i && (Ot += I.y - ve.top + X - $i)), ye > ve.bottom && (Ot -= ye - ve.bottom - Ie, I.y > ve.bottom - $i && (Ot += I.y - ve.bottom + $i)));
      var Ba = M.x + Gt, la = Ba + re, Ro = M.y + Ot, ua = Ro + Z, $a = I.x, ro = $a + Y, Xt = I.y, Ut = Xt + X, Tn = Math.max(Ba, $a), Pn = Math.min(la, ro), Kr = (Tn + Pn) / 2, tr = Kr - Ba, Jt = Math.max(Ro, Xt), pr = Math.min(ua, Ut), Yr = (Jt + pr) / 2, on = Yr - Ro;
      a == null || a(t, hr);
      var On = Ve.right - M.x - (Gt + M.width), vi = Ve.bottom - M.y - (Ot + M.height);
      Fe === 1 && (Gt = Math.round(Gt), On = Math.round(On)), Ne === 1 && (Ot = Math.round(Ot), vi = Math.round(vi));
      var Nf = {
        ready: !0,
        offsetX: Gt / Fe,
        offsetY: Ot / Ne,
        offsetR: On / Fe,
        offsetB: vi / Ne,
        arrowX: tr / Fe,
        arrowY: on / Ne,
        scaleX: Fe,
        scaleY: Ne,
        align: hr
      };
      c(Nf);
    }
  }), v = function() {
    d.current += 1;
    var C = d.current;
    Promise.resolve().then(function() {
      d.current === C && g();
    });
  }, m = function() {
    c(function(C) {
      return ee(ee({}, C), {}, {
        ready: !1
      });
    });
  };
  return kr(m, [n]), kr(function() {
    e || m();
  }, [e]), [u.ready, u.offsetX, u.offsetY, u.offsetR, u.offsetB, u.arrowX, u.arrowY, u.scaleX, u.scaleY, u.align, v];
}
function Sae(e, t, r, n, i) {
  kr(function() {
    if (e && t && r) {
      let d = function() {
        n(), i();
      };
      var o = t, a = r, s = OR(o), l = OR(a), u = bv(a), c = new Set([u].concat(it(s), it(l)));
      return c.forEach(function(h) {
        h.addEventListener("scroll", d, {
          passive: !0
        });
      }), u.addEventListener("resize", d, {
        passive: !0
      }), n(), function() {
        c.forEach(function(h) {
          h.removeEventListener("scroll", d), u.removeEventListener("resize", d);
        });
      };
    }
  }, [e, t, r]);
}
function wae(e, t, r, n, i, o, a, s) {
  var l = E.useRef(e);
  l.current = e, E.useEffect(function() {
    if (t && n && (!i || o)) {
      var u = function(m) {
        var y = m.target;
        l.current && !a(y) && s(!1);
      }, c = bv(n);
      c.addEventListener("mousedown", u, !0), c.addEventListener("contextmenu", u, !0);
      var d = I0(r);
      if (d && (d.addEventListener("mousedown", u, !0), d.addEventListener("contextmenu", u, !0)), process.env.NODE_ENV !== "production") {
        var h, f, p = r == null || (h = r.getRootNode) === null || h === void 0 ? void 0 : h.call(r), g = (f = n.getRootNode) === null || f === void 0 ? void 0 : f.call(n);
        fs(p === g, "trigger element and popup element should in same shadow root.");
      }
      return function() {
        c.removeEventListener("mousedown", u, !0), c.removeEventListener("contextmenu", u, !0), d && (d.removeEventListener("mousedown", u, !0), d.removeEventListener("contextmenu", u, !0));
      };
    }
  }, [t, r, n, i, o]);
}
var bae = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
function xae() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Cv, t = /* @__PURE__ */ E.forwardRef(function(r, n) {
    var i = r.prefixCls, o = i === void 0 ? "rc-trigger-popup" : i, a = r.children, s = r.action, l = s === void 0 ? "hover" : s, u = r.showAction, c = r.hideAction, d = r.popupVisible, h = r.defaultPopupVisible, f = r.onPopupVisibleChange, p = r.afterPopupVisibleChange, g = r.mouseEnterDelay, v = r.mouseLeaveDelay, m = v === void 0 ? 0.1 : v, y = r.focusDelay, C = r.blurDelay, S = r.mask, b = r.maskClosable, w = b === void 0 ? !0 : b, x = r.getPopupContainer, R = r.forceRender, _ = r.autoDestroy, T = r.destroyPopupOnHide, P = r.popup, D = r.popupClassName, O = r.popupStyle, A = r.popupPlacement, F = r.builtinPlacements, L = F === void 0 ? {} : F, N = r.popupAlign, I = r.zIndex, B = r.stretch, M = r.getPopupClassNameFromAlign, V = r.fresh, G = r.alignPoint, k = r.onPopupClick, z = r.onPopupAlign, j = r.arrow, q = r.popupMotion, K = r.maskMotion, Z = r.popupTransitionName, re = r.popupAnimation, X = r.maskTransitionName, Y = r.maskAnimation, U = r.className, oe = r.getTriggerDOMNode, W = $t(r, bae), ne = _ || T || !1, ce = E.useState(!1), we = ae(ce, 2), Re = we[0], ve = we[1];
    kr(function() {
      ve(WP());
    }, []);
    var xe = E.useRef({}), _e = E.useContext(OO), Ve = E.useMemo(function() {
      return {
        registerSubPopup: function(Kt, dn) {
          xe.current[Kt] = dn, _e == null || _e.registerSubPopup(Kt, dn);
        }
      };
    }, [_e]), Fe = S5(), Ne = E.useState(null), Je = ae(Ne, 2), J = Je[0], he = Je[1], Le = E.useRef(null), Pe = An(function(wt) {
      Le.current = wt, bg(wt) && J !== wt && he(wt), _e == null || _e.registerSubPopup(Fe, wt);
    }), Ie = E.useState(null), Ce = ae(Ie, 2), De = Ce[0], ze = Ce[1], st = E.useRef(null), Tt = An(function(wt) {
      bg(wt) && De !== wt && (ze(wt), st.current = wt);
    }), ot = E.Children.only(a), Xe = (ot == null ? void 0 : ot.props) || {}, Oe = {}, Qe = An(function(wt) {
      var Kt, dn, Ln = De;
      return (Ln == null ? void 0 : Ln.contains(wt)) || ((Kt = I0(Ln)) === null || Kt === void 0 ? void 0 : Kt.host) === wt || wt === Ln || (J == null ? void 0 : J.contains(wt)) || ((dn = I0(J)) === null || dn === void 0 ? void 0 : dn.host) === wt || wt === J || Object.values(xe.current).some(function(hn) {
        return (hn == null ? void 0 : hn.contains(wt)) || wt === hn;
      });
    }), ft = FO(o, q, re, Z), xt = FO(o, K, Y, X), $r = E.useState(h || !1), hr = ae($r, 2), Gt = hr[0], Ot = hr[1], Lt = d ?? Gt, mt = An(function(wt) {
      d === void 0 && Ot(wt);
    });
    kr(function() {
      Ot(d || !1);
    }, [d]);
    var qe = E.useRef(Lt);
    qe.current = Lt;
    var zt = E.useRef([]);
    zt.current = [];
    var fr = An(function(wt) {
      var Kt;
      mt(wt), ((Kt = zt.current[zt.current.length - 1]) !== null && Kt !== void 0 ? Kt : Lt) !== wt && (zt.current.push(wt), f == null || f(wt));
    }), Ge = E.useRef(), Ze = function() {
      clearTimeout(Ge.current);
    }, tt = function(Kt) {
      var dn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      Ze(), dn === 0 ? fr(Kt) : Ge.current = setTimeout(function() {
        fr(Kt);
      }, dn * 1e3);
    };
    E.useEffect(function() {
      return Ze;
    }, []);
    var ht = E.useState(!1), It = ae(ht, 2), qt = It[0], Hr = It[1];
    kr(function(wt) {
      (!wt || Lt) && Hr(!0);
    }, [Lt]);
    var Q = E.useState(null), ye = ae(Q, 2), me = ye[0], Ue = ye[1], pt = E.useState([0, 0]), gt = ae(pt, 2), yt = gt[0], Rt = gt[1], et = function(Kt) {
      Rt([Kt.clientX, Kt.clientY]);
    }, Ke = Cae(Lt, J, G ? yt : De, A, L, N, z), rt = ae(Ke, 11), er = rt[0], Xr = rt[1], Rn = rt[2], wr = rt[3], Vi = rt[4], to = rt[5], _n = rt[6], gi = rt[7], hl = rt[8], Bi = rt[9], $i = rt[10], Ba = vae(Re, l, u, c), la = ae(Ba, 2), Ro = la[0], ua = la[1], $a = Ro.has("click"), ro = ua.has("click") || ua.has("contextMenu"), Xt = An(function() {
      qt || $i();
    }), Ut = function() {
      qe.current && G && ro && tt(!1);
    };
    Sae(Lt, De, J, Xt, Ut), kr(function() {
      Xt();
    }, [yt, A]), kr(function() {
      Lt && !(L != null && L[A]) && Xt();
    }, [JSON.stringify(N)]);
    var Tn = E.useMemo(function() {
      var wt = yae(L, o, Bi, G);
      return ue(wt, M == null ? void 0 : M(Bi));
    }, [Bi, M, L, o, G]);
    E.useImperativeHandle(n, function() {
      return {
        nativeElement: st.current,
        popupElement: Le.current,
        forceAlign: Xt
      };
    });
    var Pn = E.useState(0), Kr = ae(Pn, 2), tr = Kr[0], Jt = Kr[1], pr = E.useState(0), Yr = ae(pr, 2), on = Yr[0], On = Yr[1], vi = function() {
      if (B && De) {
        var Kt = De.getBoundingClientRect();
        Jt(Kt.width), On(Kt.height);
      }
    }, Nf = function() {
      vi(), Xt();
    }, mi = function(Kt) {
      Hr(!1), $i(), p == null || p(Kt);
    }, Eu = function() {
      return new Promise(function(Kt) {
        vi(), Ue(function() {
          return Kt;
        });
      });
    };
    kr(function() {
      me && ($i(), me(), Ue(null));
    }, [me]);
    function yi(wt, Kt, dn, Ln) {
      Oe[wt] = function(hn) {
        var am;
        Ln == null || Ln(hn), tt(Kt, dn);
        for (var Uw = arguments.length, kI = new Array(Uw > 1 ? Uw - 1 : 0), sm = 1; sm < Uw; sm++)
          kI[sm - 1] = arguments[sm];
        (am = Xe[wt]) === null || am === void 0 || am.call.apply(am, [Xe, hn].concat(kI));
      };
    }
    ($a || ro) && (Oe.onClick = function(wt) {
      var Kt;
      qe.current && ro ? tt(!1) : !qe.current && $a && (et(wt), tt(!0));
      for (var dn = arguments.length, Ln = new Array(dn > 1 ? dn - 1 : 0), hn = 1; hn < dn; hn++)
        Ln[hn - 1] = arguments[hn];
      (Kt = Xe.onClick) === null || Kt === void 0 || Kt.call.apply(Kt, [Xe, wt].concat(Ln));
    }), wae(Lt, ro, De, J, S, w, Qe, tt);
    var ca = Ro.has("hover"), fl = ua.has("hover"), yd, kf;
    ca && (yi("onMouseEnter", !0, g, function(wt) {
      et(wt);
    }), yi("onPointerEnter", !0, g, function(wt) {
      et(wt);
    }), yd = function(Kt) {
      (Lt || qt) && J !== null && J !== void 0 && J.contains(Kt.target) && tt(!0, g);
    }, G && (Oe.onMouseMove = function(wt) {
      var Kt;
      (Kt = Xe.onMouseMove) === null || Kt === void 0 || Kt.call(Xe, wt);
    })), fl && (yi("onMouseLeave", !1, m), yi("onPointerLeave", !1, m), kf = function() {
      tt(!1, m);
    }), Ro.has("focus") && yi("onFocus", !0, y), ua.has("focus") && yi("onBlur", !1, C), Ro.has("contextMenu") && (Oe.onContextMenu = function(wt) {
      var Kt;
      qe.current && ua.has("contextMenu") ? tt(!1) : (et(wt), tt(!0)), wt.preventDefault();
      for (var dn = arguments.length, Ln = new Array(dn > 1 ? dn - 1 : 0), hn = 1; hn < dn; hn++)
        Ln[hn - 1] = arguments[hn];
      (Kt = Xe.onContextMenu) === null || Kt === void 0 || Kt.call.apply(Kt, [Xe, wt].concat(Ln));
    }), U && (Oe.className = ue(Xe.className, U));
    var Vf = ee(ee({}, Xe), Oe), om = {}, Gw = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
    Gw.forEach(function(wt) {
      W[wt] && (om[wt] = function() {
        for (var Kt, dn = arguments.length, Ln = new Array(dn), hn = 0; hn < dn; hn++)
          Ln[hn] = arguments[hn];
        (Kt = Vf[wt]) === null || Kt === void 0 || Kt.call.apply(Kt, [Vf].concat(Ln)), W[wt].apply(W, Ln);
      });
    });
    var zw = /* @__PURE__ */ E.cloneElement(ot, ee(ee({}, Vf), om)), Ww = {
      x: to,
      y: _n
    }, jw = j ? ee({}, j !== !0 ? j : {}) : null;
    return /* @__PURE__ */ E.createElement(E.Fragment, null, /* @__PURE__ */ E.createElement(Co, {
      disabled: !Lt,
      ref: Tt,
      onResize: Nf
    }, /* @__PURE__ */ E.createElement(Y5, {
      getTriggerDOMNode: oe
    }, zw)), /* @__PURE__ */ E.createElement(OO.Provider, {
      value: Ve
    }, /* @__PURE__ */ E.createElement(K5, {
      portal: e,
      ref: Pe,
      prefixCls: o,
      popup: P,
      className: ue(D, Tn),
      style: O,
      target: De,
      onMouseEnter: yd,
      onMouseLeave: kf,
      onPointerEnter: yd,
      zIndex: I,
      open: Lt,
      keepDom: qt,
      fresh: V,
      onClick: k,
      mask: S,
      motion: ft,
      maskMotion: xt,
      onVisibleChanged: mi,
      onPrepare: Eu,
      forceRender: R,
      autoDestroy: ne,
      getPopupContainer: x,
      align: Bi,
      arrow: jw,
      arrowPos: Ww,
      ready: er,
      offsetX: Xr,
      offsetY: Rn,
      offsetR: wr,
      offsetB: Vi,
      onAlign: Xt,
      stretch: B,
      targetWidth: tr / gi,
      targetHeight: on / hl
    })));
  });
  return process.env.NODE_ENV !== "production" && (t.displayName = "Trigger"), t;
}
const RS = xae(Cv);
var Eae = ["prefixCls", "disabled", "visible", "children", "popupElement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "builtinPlacements", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"], Rae = function(t) {
  var r = t === !0 ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX: r,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX: r,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX: r,
        adjustY: 1
      },
      htmlRegion: "scroll"
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX: r,
        adjustY: 1
      },
      htmlRegion: "scroll"
    }
  };
}, _ae = function(t, r) {
  var n = t.prefixCls;
  t.disabled;
  var i = t.visible, o = t.children, a = t.popupElement, s = t.animation, l = t.transitionName, u = t.dropdownStyle, c = t.dropdownClassName, d = t.direction, h = d === void 0 ? "ltr" : d, f = t.placement, p = t.builtinPlacements, g = t.dropdownMatchSelectWidth, v = t.dropdownRender, m = t.dropdownAlign, y = t.getPopupContainer, C = t.empty, S = t.getTriggerDOMNode, b = t.onPopupVisibleChange, w = t.onPopupMouseEnter, x = $t(t, Eae), R = "".concat(n, "-dropdown"), _ = a;
  v && (_ = v(a));
  var T = E.useMemo(function() {
    return p || Rae(g);
  }, [p, g]), P = s ? "".concat(R, "-").concat(s) : l, D = typeof g == "number", O = E.useMemo(function() {
    return D ? null : g === !1 ? "minWidth" : "width";
  }, [g, D]), A = u;
  D && (A = ee(ee({}, A), {}, {
    width: g
  }));
  var F = E.useRef(null);
  return E.useImperativeHandle(r, function() {
    return {
      getPopupElement: function() {
        var N;
        return (N = F.current) === null || N === void 0 ? void 0 : N.popupElement;
      }
    };
  }), /* @__PURE__ */ E.createElement(RS, $e({}, x, {
    showAction: b ? ["click"] : [],
    hideAction: b ? ["click"] : [],
    popupPlacement: f || (h === "rtl" ? "bottomRight" : "bottomLeft"),
    builtinPlacements: T,
    prefixCls: R,
    popupTransitionName: P,
    popup: /* @__PURE__ */ E.createElement("div", {
      onMouseEnter: w
    }, _),
    ref: F,
    stretch: O,
    popupAlign: m,
    popupVisible: i,
    getPopupContainer: y,
    popupClassName: ue(c, te({}, "".concat(R, "-empty"), C)),
    popupStyle: A,
    getTriggerDOMNode: S,
    onPopupVisibleChange: b
  }), o);
}, q5 = /* @__PURE__ */ E.forwardRef(_ae);
process.env.NODE_ENV !== "production" && (q5.displayName = "SelectTrigger");
function $O(e, t) {
  var r = e.key, n;
  return "value" in e && (n = e.value), r ?? (n !== void 0 ? n : "rc-index-key-".concat(t));
}
function LR(e) {
  return typeof e < "u" && !Number.isNaN(e);
}
function X5(e, t) {
  var r = e || {}, n = r.label, i = r.value, o = r.options, a = r.groupLabel, s = n || (t ? "children" : "label");
  return {
    label: s,
    value: i || "value",
    options: o || "options",
    groupLabel: a || s
  };
}
function Tae(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = t.fieldNames, n = t.childrenAsData, i = [], o = X5(r, !1), a = o.label, s = o.value, l = o.options, u = o.groupLabel;
  function c(d, h) {
    Array.isArray(d) && d.forEach(function(f) {
      if (h || !(l in f)) {
        var p = f[s];
        i.push({
          key: $O(f, i.length),
          groupOption: h,
          data: f,
          label: f[a],
          value: p
        });
      } else {
        var g = f[u];
        g === void 0 && n && (g = f.label), i.push({
          key: $O(f, i.length),
          group: !0,
          data: f,
          label: g
        }), c(f[l], !0);
      }
    });
  }
  return c(e, !1), i;
}
function FR(e) {
  var t = ee({}, e);
  return "props" in t || Object.defineProperty(t, "props", {
    get: function() {
      return Qt(!1, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."), t;
    }
  }), t;
}
var Pae = function(t, r, n) {
  if (!r || !r.length)
    return null;
  var i = !1, o = function s(l, u) {
    var c = yz(u), d = c[0], h = c.slice(1);
    if (!d)
      return [l];
    var f = l.split(d);
    return i = i || f.length > 1, f.reduce(function(p, g) {
      return [].concat(it(p), it(s(g, h)));
    }, []).filter(Boolean);
  }, a = o(t, r);
  return i ? typeof n < "u" ? a.slice(0, n) : a : null;
}, KP = /* @__PURE__ */ E.createContext(null);
function Mae(e) {
  var t = e.visible, r = e.values;
  if (!t)
    return null;
  var n = 50;
  return /* @__PURE__ */ E.createElement("span", {
    "aria-live": "polite",
    style: {
      width: 0,
      height: 0,
      position: "absolute",
      overflow: "hidden",
      opacity: 0
    }
  }, "".concat(r.slice(0, n).map(function(i) {
    var o = i.label, a = i.value;
    return ["number", "string"].includes(vt(o)) ? o : a;
  }).join(", ")), r.length > n ? ", ..." : null);
}
var Dae = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "autoClearSearchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "suffixIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "builtinPlacements", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"], Aae = ["value", "onChange", "removeIcon", "placeholder", "autoFocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabIndex"], V0 = function(t) {
  return t === "tags" || t === "multiple";
}, Z5 = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r, n = e.id, i = e.prefixCls, o = e.className, a = e.showSearch, s = e.tagRender, l = e.direction, u = e.omitDomProps, c = e.displayValues, d = e.onDisplayValuesChange, h = e.emptyOptions, f = e.notFoundContent, p = f === void 0 ? "Not Found" : f, g = e.onClear, v = e.mode, m = e.disabled, y = e.loading, C = e.getInputElement, S = e.getRawInputElement, b = e.open, w = e.defaultOpen, x = e.onDropdownVisibleChange, R = e.activeValue, _ = e.onActiveValueChange, T = e.activeDescendantId, P = e.searchValue, D = e.autoClearSearchValue, O = e.onSearch, A = e.onSearchSplit, F = e.tokenSeparators, L = e.allowClear, N = e.suffixIcon, I = e.clearIcon, B = e.OptionList, M = e.animation, V = e.transitionName, G = e.dropdownStyle, k = e.dropdownClassName, z = e.dropdownMatchSelectWidth, j = e.dropdownRender, q = e.dropdownAlign, K = e.placement, Z = e.builtinPlacements, re = e.getPopupContainer, X = e.showAction, Y = X === void 0 ? [] : X, U = e.onFocus, oe = e.onBlur, W = e.onKeyUp, ne = e.onKeyDown, ce = e.onMouseDown, we = $t(e, Dae), Re = V0(v), ve = (a !== void 0 ? a : Re) || v === "combobox", xe = ee({}, we);
  Aae.forEach(function(Xt) {
    delete xe[Xt];
  }), u == null || u.forEach(function(Xt) {
    delete xe[Xt];
  });
  var _e = E.useState(!1), Ve = ae(_e, 2), Fe = Ve[0], Ne = Ve[1];
  E.useEffect(function() {
    Ne(WP());
  }, []);
  var Je = E.useRef(null), J = E.useRef(null), he = E.useRef(null), Le = E.useRef(null), Pe = E.useRef(null), Ie = E.useRef(!1), Ce = Woe(), De = ae(Ce, 3), ze = De[0], st = De[1], Tt = De[2];
  E.useImperativeHandle(t, function() {
    var Xt, Ut;
    return {
      focus: (Xt = Le.current) === null || Xt === void 0 ? void 0 : Xt.focus,
      blur: (Ut = Le.current) === null || Ut === void 0 ? void 0 : Ut.blur,
      scrollTo: function(Pn) {
        var Kr;
        return (Kr = Pe.current) === null || Kr === void 0 ? void 0 : Kr.scrollTo(Pn);
      },
      nativeElement: Je.current || J.current
    };
  });
  var ot = E.useMemo(function() {
    var Xt;
    if (v !== "combobox")
      return P;
    var Ut = (Xt = c[0]) === null || Xt === void 0 ? void 0 : Xt.value;
    return typeof Ut == "string" || typeof Ut == "number" ? String(Ut) : "";
  }, [P, v, c]), Xe = v === "combobox" && typeof C == "function" && C() || null, Oe = typeof S == "function" && S(), Qe = Qc(J, Oe == null || (r = Oe.props) === null || r === void 0 ? void 0 : r.ref), ft = E.useState(!1), xt = ae(ft, 2), $r = xt[0], hr = xt[1];
  kr(function() {
    hr(!0);
  }, []);
  var Gt = xn(!1, {
    defaultValue: w,
    value: b
  }), Ot = ae(Gt, 2), Lt = Ot[0], mt = Ot[1], qe = $r ? Lt : !1, zt = !p && h;
  (m || zt && qe && v === "combobox") && (qe = !1);
  var fr = zt ? !1 : qe, Ge = E.useCallback(function(Xt) {
    var Ut = Xt !== void 0 ? Xt : !qe;
    m || (mt(Ut), qe !== Ut && (x == null || x(Ut)));
  }, [m, qe, mt, x]), Ze = E.useMemo(function() {
    return (F || []).some(function(Xt) {
      return [`
`, `\r
`].includes(Xt);
    });
  }, [F]), tt = E.useContext(KP) || {}, ht = tt.maxCount, It = tt.rawValues, qt = function(Ut, Tn, Pn) {
    if (!(Re && LR(ht) && (It == null ? void 0 : It.size) >= ht)) {
      var Kr = !0, tr = Ut;
      _ == null || _(null);
      var Jt = Pae(Ut, F, LR(ht) ? ht - It.size : void 0), pr = Pn ? null : Jt;
      return v !== "combobox" && pr && (tr = "", A == null || A(pr), Ge(!1), Kr = !1), O && ot !== tr && O(tr, {
        source: Tn ? "typing" : "effect"
      }), Kr;
    }
  }, Hr = function(Ut) {
    !Ut || !Ut.trim() || O(Ut, {
      source: "submit"
    });
  };
  E.useEffect(function() {
    !qe && !Re && v !== "combobox" && qt("", !1, !1);
  }, [qe]), E.useEffect(function() {
    Lt && m && mt(!1), m && !Ie.current && st(!1);
  }, [m]);
  var Q = $5(), ye = ae(Q, 2), me = ye[0], Ue = ye[1], pt = function(Ut) {
    var Tn = me(), Pn = Ut.which;
    if (Pn === Ae.ENTER && (v !== "combobox" && Ut.preventDefault(), qe || Ge(!0)), Ue(!!ot), Pn === Ae.BACKSPACE && !Tn && Re && !ot && c.length) {
      for (var Kr = it(c), tr = null, Jt = Kr.length - 1; Jt >= 0; Jt -= 1) {
        var pr = Kr[Jt];
        if (!pr.disabled) {
          Kr.splice(Jt, 1), tr = pr;
          break;
        }
      }
      tr && d(Kr, {
        type: "remove",
        values: [tr]
      });
    }
    for (var Yr = arguments.length, on = new Array(Yr > 1 ? Yr - 1 : 0), On = 1; On < Yr; On++)
      on[On - 1] = arguments[On];
    if (qe) {
      var vi;
      (vi = Pe.current) === null || vi === void 0 || vi.onKeyDown.apply(vi, [Ut].concat(on));
    }
    ne == null || ne.apply(void 0, [Ut].concat(on));
  }, gt = function(Ut) {
    for (var Tn = arguments.length, Pn = new Array(Tn > 1 ? Tn - 1 : 0), Kr = 1; Kr < Tn; Kr++)
      Pn[Kr - 1] = arguments[Kr];
    if (qe) {
      var tr;
      (tr = Pe.current) === null || tr === void 0 || tr.onKeyUp.apply(tr, [Ut].concat(Pn));
    }
    W == null || W.apply(void 0, [Ut].concat(Pn));
  }, yt = function(Ut) {
    var Tn = c.filter(function(Pn) {
      return Pn !== Ut;
    });
    d(Tn, {
      type: "remove",
      values: [Ut]
    });
  }, Rt = E.useRef(!1), et = function() {
    st(!0), m || (U && !Rt.current && U.apply(void 0, arguments), Y.includes("focus") && Ge(!0)), Rt.current = !0;
  }, Ke = function() {
    Ie.current = !0, st(!1, function() {
      Rt.current = !1, Ie.current = !1, Ge(!1);
    }), !m && (ot && (v === "tags" ? O(ot, {
      source: "submit"
    }) : v === "multiple" && O("", {
      source: "blur"
    })), oe && oe.apply(void 0, arguments));
  }, rt = [];
  E.useEffect(function() {
    return function() {
      rt.forEach(function(Xt) {
        return clearTimeout(Xt);
      }), rt.splice(0, rt.length);
    };
  }, []);
  var er = function(Ut) {
    var Tn, Pn = Ut.target, Kr = (Tn = he.current) === null || Tn === void 0 ? void 0 : Tn.getPopupElement();
    if (Kr && Kr.contains(Pn)) {
      var tr = setTimeout(function() {
        var on = rt.indexOf(tr);
        if (on !== -1 && rt.splice(on, 1), Tt(), !Fe && !Kr.contains(document.activeElement)) {
          var On;
          (On = Le.current) === null || On === void 0 || On.focus();
        }
      });
      rt.push(tr);
    }
    for (var Jt = arguments.length, pr = new Array(Jt > 1 ? Jt - 1 : 0), Yr = 1; Yr < Jt; Yr++)
      pr[Yr - 1] = arguments[Yr];
    ce == null || ce.apply(void 0, [Ut].concat(pr));
  }, Xr = E.useState({}), Rn = ae(Xr, 2), wr = Rn[1];
  function Vi() {
    wr({});
  }
  var to;
  Oe && (to = function(Ut) {
    Ge(Ut);
  }), joe(function() {
    var Xt;
    return [Je.current, (Xt = he.current) === null || Xt === void 0 ? void 0 : Xt.getPopupElement()];
  }, fr, Ge, !!Oe);
  var _n = E.useMemo(function() {
    return ee(ee({}, e), {}, {
      notFoundContent: p,
      open: qe,
      triggerOpen: fr,
      id: n,
      showSearch: ve,
      multiple: Re,
      toggleOpen: Ge
    });
  }, [e, p, fr, qe, n, ve, Re, Ge]), gi = !!N || y, hl;
  gi && (hl = /* @__PURE__ */ E.createElement(ES, {
    className: ue("".concat(i, "-arrow"), te({}, "".concat(i, "-arrow-loading"), y)),
    customizeIcon: N,
    customizeIconProps: {
      loading: y,
      searchValue: ot,
      open: qe,
      focused: ze,
      showSearch: ve
    }
  }));
  var Bi = function() {
    var Ut;
    g == null || g(), (Ut = Le.current) === null || Ut === void 0 || Ut.focus(), d([], {
      type: "clear",
      values: c
    }), qt("", !1, !1);
  }, $i = Goe(i, Bi, c, L, I, m, ot, v), Ba = $i.allowClear, la = $i.clearIcon, Ro = /* @__PURE__ */ E.createElement(B, {
    ref: Pe
  }), ua = ue(i, o, te(te(te(te(te(te(te(te(te(te({}, "".concat(i, "-focused"), ze), "".concat(i, "-multiple"), Re), "".concat(i, "-single"), !Re), "".concat(i, "-allow-clear"), L), "".concat(i, "-show-arrow"), gi), "".concat(i, "-disabled"), m), "".concat(i, "-loading"), y), "".concat(i, "-open"), qe), "".concat(i, "-customize-input"), Xe), "".concat(i, "-show-search"), ve)), $a = /* @__PURE__ */ E.createElement(q5, {
    ref: he,
    disabled: m,
    prefixCls: i,
    visible: fr,
    popupElement: Ro,
    animation: M,
    transitionName: V,
    dropdownStyle: G,
    dropdownClassName: k,
    direction: l,
    dropdownMatchSelectWidth: z,
    dropdownRender: j,
    dropdownAlign: q,
    placement: K,
    builtinPlacements: Z,
    getPopupContainer: re,
    empty: h,
    getTriggerDOMNode: function(Ut) {
      return (
        // TODO: This is workaround and should be removed in `rc-select`
        // And use new standard `nativeElement` for ref.
        // But we should update `rc-resize-observer` first.
        J.current || Ut
      );
    },
    onPopupVisibleChange: to,
    onPopupMouseEnter: Vi
  }, Oe ? /* @__PURE__ */ E.cloneElement(Oe, {
    ref: Qe
  }) : /* @__PURE__ */ E.createElement(j5, $e({}, e, {
    domRef: J,
    prefixCls: i,
    inputElement: Xe,
    ref: Le,
    id: n,
    showSearch: ve,
    autoClearSearchValue: D,
    mode: v,
    activeDescendantId: T,
    tagRender: s,
    values: c,
    open: qe,
    onToggleOpen: Ge,
    activeValue: R,
    searchValue: ot,
    onSearch: qt,
    onSearchSubmit: Hr,
    onRemove: yt,
    tokenWithEnter: Ze
  }))), ro;
  return Oe ? ro = $a : ro = /* @__PURE__ */ E.createElement("div", $e({
    className: ua
  }, xe, {
    ref: Je,
    onMouseDown: er,
    onKeyDown: pt,
    onKeyUp: gt,
    onFocus: et,
    onBlur: Ke
  }), /* @__PURE__ */ E.createElement(Mae, {
    visible: ze && !qe,
    values: c
  }), $a, hl, Ba && la), /* @__PURE__ */ E.createElement(B5.Provider, {
    value: _n
  }, ro);
});
process.env.NODE_ENV !== "production" && (Z5.displayName = "BaseSelect");
var YP = function() {
  return null;
};
YP.isSelectOptGroup = !0;
var qP = function() {
  return null;
};
qP.isSelectOption = !0;
var Q5 = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.height, n = e.offsetY, i = e.offsetX, o = e.children, a = e.prefixCls, s = e.onInnerResize, l = e.innerProps, u = e.rtl, c = e.extra, d = {}, h = {
    display: "flex",
    flexDirection: "column"
  };
  return n !== void 0 && (d = {
    height: r,
    position: "relative",
    overflow: "hidden"
  }, h = ee(ee({}, h), {}, te(te(te(te(te({
    transform: "translateY(".concat(n, "px)")
  }, u ? "marginRight" : "marginLeft", -i), "position", "absolute"), "left", 0), "right", 0), "top", 0))), /* @__PURE__ */ E.createElement("div", {
    style: d
  }, /* @__PURE__ */ E.createElement(Co, {
    onResize: function(p) {
      var g = p.offsetHeight;
      g && s && s();
    }
  }, /* @__PURE__ */ E.createElement("div", $e({
    style: h,
    className: ue(te({}, "".concat(a, "-holder-inner"), a)),
    ref: t
  }, l), o, c)));
});
Q5.displayName = "Filler";
function Iae(e) {
  var t = e.children, r = e.setRef, n = E.useCallback(function(i) {
    r(i);
  }, []);
  return /* @__PURE__ */ E.cloneElement(t, {
    ref: n
  });
}
function Oae(e, t, r, n, i, o, a, s) {
  var l = s.getKey;
  return e.slice(t, r + 1).map(function(u, c) {
    var d = t + c, h = a(u, d, {
      style: {
        width: n
      },
      offsetX: i
    }), f = l(u);
    return /* @__PURE__ */ E.createElement(Iae, {
      key: f,
      setRef: function(g) {
        return o(u, g);
      }
    }, h);
  });
}
function Lae(e, t, r) {
  var n = e.length, i = t.length, o, a;
  if (n === 0 && i === 0)
    return null;
  n < i ? (o = e, a = t) : (o = t, a = e);
  var s = {
    __EMPTY_ITEM__: !0
  };
  function l(p) {
    return p !== void 0 ? r(p) : s;
  }
  for (var u = null, c = Math.abs(n - i) !== 1, d = 0; d < a.length; d += 1) {
    var h = l(o[d]), f = l(a[d]);
    if (h !== f) {
      u = d, c = c || h !== l(a[d + 1]);
      break;
    }
  }
  return u === null ? null : {
    index: u,
    multiple: c
  };
}
function Fae(e, t, r) {
  var n = E.useState(e), i = ae(n, 2), o = i[0], a = i[1], s = E.useState(null), l = ae(s, 2), u = l[0], c = l[1];
  return E.useEffect(function() {
    var d = Lae(o || [], e || [], t);
    (d == null ? void 0 : d.index) !== void 0 && c(e[d.index]), a(e);
  }, [e]), [u];
}
var HO = (typeof navigator > "u" ? "undefined" : vt(navigator)) === "object" && /Firefox/i.test(navigator.userAgent);
const J5 = function(e, t, r, n) {
  var i = se(!1), o = se(null);
  function a() {
    clearTimeout(o.current), i.current = !0, o.current = setTimeout(function() {
      i.current = !1;
    }, 50);
  }
  var s = se({
    top: e,
    bottom: t,
    left: r,
    right: n
  });
  return s.current.top = e, s.current.bottom = t, s.current.left = r, s.current.right = n, function(l, u) {
    var c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, d = l ? (
      // Pass origin wheel when on the left
      u < 0 && s.current.left || // Pass origin wheel when on the right
      u > 0 && s.current.right
    ) : u < 0 && s.current.top || // Pass origin wheel when on the bottom
    u > 0 && s.current.bottom;
    return c && d ? (clearTimeout(o.current), i.current = !1) : (!d || i.current) && a(), !i.current && d;
  };
};
function Nae(e, t, r, n, i, o, a) {
  var s = se(0), l = se(null), u = se(null), c = se(!1), d = J5(t, r, n, i);
  function h(y, C) {
    Ar.cancel(l.current), s.current += C, u.current = C, !d(!1, C) && (HO || y.preventDefault(), l.current = Ar(function() {
      var S = c.current ? 10 : 1;
      a(s.current * S), s.current = 0;
    }));
  }
  function f(y, C) {
    a(C, !0), HO || y.preventDefault();
  }
  var p = se(null), g = se(null);
  function v(y) {
    if (e) {
      Ar.cancel(g.current), g.current = Ar(function() {
        p.current = null;
      }, 2);
      var C = y.deltaX, S = y.deltaY, b = y.shiftKey, w = C, x = S;
      (p.current === "sx" || !p.current && b && S && !C) && (w = S, x = 0, p.current = "sx");
      var R = Math.abs(w), _ = Math.abs(x);
      p.current === null && (p.current = o && R > _ ? "x" : "y"), p.current === "y" ? h(y, x) : f(y, w);
    }
  }
  function m(y) {
    e && (c.current = y.detail === u.current);
  }
  return [v, m];
}
function kae(e, t, r, n) {
  var i = E.useMemo(function() {
    return [/* @__PURE__ */ new Map(), []];
  }, [e, r.id, n]), o = ae(i, 2), a = o[0], s = o[1], l = function(c) {
    var d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : c, h = a.get(c), f = a.get(d);
    if (h === void 0 || f === void 0)
      for (var p = e.length, g = s.length; g < p; g += 1) {
        var v, m = e[g], y = t(m);
        a.set(y, g);
        var C = (v = r.get(y)) !== null && v !== void 0 ? v : n;
        if (s[g] = (s[g - 1] || 0) + C, y === c && (h = g), y === d && (f = g), h !== void 0 && f !== void 0)
          break;
      }
    return {
      top: s[h - 1] || 0,
      bottom: s[f]
    };
  };
  return l;
}
var Vae = /* @__PURE__ */ function() {
  function e() {
    Kn(this, e), te(this, "maps", void 0), te(this, "id", 0), this.maps = /* @__PURE__ */ Object.create(null);
  }
  return Yn(e, [{
    key: "set",
    value: function(r, n) {
      this.maps[r] = n, this.id += 1;
    }
  }, {
    key: "get",
    value: function(r) {
      return this.maps[r];
    }
  }]), e;
}();
function Bae(e, t, r) {
  var n = E.useState(0), i = ae(n, 2), o = i[0], a = i[1], s = se(/* @__PURE__ */ new Map()), l = se(new Vae()), u = se();
  function c() {
    Ar.cancel(u.current);
  }
  function d() {
    var f = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    c();
    var p = function() {
      s.current.forEach(function(v, m) {
        if (v && v.offsetParent) {
          var y = Kp(v), C = y.offsetHeight;
          l.current.get(m) !== C && l.current.set(m, y.offsetHeight);
        }
      }), a(function(v) {
        return v + 1;
      });
    };
    f ? p() : u.current = Ar(p);
  }
  function h(f, p) {
    var g = e(f);
    s.current.get(g), p ? (s.current.set(g, p), d()) : s.current.delete(g);
  }
  return Nt(function() {
    return c;
  }, []), [h, d, l.current, o];
}
var GO = 14 / 15;
function $ae(e, t, r) {
  var n = se(!1), i = se(0), o = se(0), a = se(null), s = se(null), l, u = function(f) {
    if (n.current) {
      var p = Math.ceil(f.touches[0].pageX), g = Math.ceil(f.touches[0].pageY), v = i.current - p, m = o.current - g, y = Math.abs(v) > Math.abs(m);
      y ? i.current = p : o.current = g, r(y, y ? v : m) && f.preventDefault(), clearInterval(s.current), s.current = setInterval(function() {
        y ? v *= GO : m *= GO;
        var C = Math.floor(y ? v : m);
        (!r(y, C, !0) || Math.abs(C) <= 0.1) && clearInterval(s.current);
      }, 16);
    }
  }, c = function() {
    n.current = !1, l();
  }, d = function(f) {
    l(), f.touches.length === 1 && !n.current && (n.current = !0, i.current = Math.ceil(f.touches[0].pageX), o.current = Math.ceil(f.touches[0].pageY), a.current = f.target, a.current.addEventListener("touchmove", u, {
      passive: !1
    }), a.current.addEventListener("touchend", c, {
      passive: !0
    }));
  };
  l = function() {
    a.current && (a.current.removeEventListener("touchmove", u), a.current.removeEventListener("touchend", c));
  }, kr(function() {
    return e && t.current.addEventListener("touchstart", d, {
      passive: !0
    }), function() {
      var h;
      (h = t.current) === null || h === void 0 || h.removeEventListener("touchstart", d), l(), clearInterval(s.current);
    };
  }, [e]);
}
var zO = 10;
function Hae(e, t, r, n, i, o, a, s) {
  var l = E.useRef(), u = E.useState(null), c = ae(u, 2), d = c[0], h = c[1];
  return kr(function() {
    if (d && d.times < zO) {
      if (!e.current) {
        h(function(B) {
          return ee({}, B);
        });
        return;
      }
      o();
      var f = d.targetAlign, p = d.originAlign, g = d.index, v = d.offset, m = e.current.clientHeight, y = !1, C = f, S = null;
      if (m) {
        for (var b = f || p, w = 0, x = 0, R = 0, _ = Math.min(t.length - 1, g), T = 0; T <= _; T += 1) {
          var P = i(t[T]);
          x = w;
          var D = r.get(P);
          R = x + (D === void 0 ? n : D), w = R;
        }
        for (var O = b === "top" ? v : m - v, A = _; A >= 0; A -= 1) {
          var F = i(t[A]), L = r.get(F);
          if (L === void 0) {
            y = !0;
            break;
          }
          if (O -= L, O <= 0)
            break;
        }
        switch (b) {
          case "top":
            S = x - v;
            break;
          case "bottom":
            S = R - m + v;
            break;
          default: {
            var N = e.current.scrollTop, I = N + m;
            x < N ? C = "top" : R > I && (C = "bottom");
          }
        }
        S !== null && a(S), S !== d.lastTop && (y = !0);
      }
      y && h(ee(ee({}, d), {}, {
        times: d.times + 1,
        targetAlign: C,
        lastTop: S
      }));
    } else process.env.NODE_ENV !== "production" && (d == null ? void 0 : d.times) === zO && Qt(!1, "Seems `scrollTo` with `rc-virtual-list` reach the max limitation. Please fire issue for us. Thanks.");
  }, [d, e.current]), function(f) {
    if (f == null) {
      s();
      return;
    }
    if (Ar.cancel(l.current), typeof f == "number")
      a(f);
    else if (f && vt(f) === "object") {
      var p, g = f.align;
      "index" in f ? p = f.index : p = t.findIndex(function(y) {
        return i(y) === f.key;
      });
      var v = f.offset, m = v === void 0 ? 0 : v;
      h({
        times: 0,
        index: p,
        offset: m,
        originAlign: g
      });
    }
  };
}
function WO(e, t) {
  var r = "touches" in e ? e.touches[0] : e;
  return r[t ? "pageX" : "pageY"];
}
var NR = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.rtl, i = e.scrollOffset, o = e.scrollRange, a = e.onStartMove, s = e.onStopMove, l = e.onScroll, u = e.horizontal, c = e.spinSize, d = e.containerSize, h = e.style, f = e.thumbStyle, p = E.useState(!1), g = ae(p, 2), v = g[0], m = g[1], y = E.useState(null), C = ae(y, 2), S = C[0], b = C[1], w = E.useState(null), x = ae(w, 2), R = x[0], _ = x[1], T = !n, P = E.useRef(), D = E.useRef(), O = E.useState(!1), A = ae(O, 2), F = A[0], L = A[1], N = E.useRef(), I = function() {
    clearTimeout(N.current), L(!0), N.current = setTimeout(function() {
      L(!1);
    }, 3e3);
  }, B = o - d || 0, M = d - c || 0, V = E.useMemo(function() {
    if (i === 0 || B === 0)
      return 0;
    var X = i / B;
    return X * M;
  }, [i, B, M]), G = function(Y) {
    Y.stopPropagation(), Y.preventDefault();
  }, k = E.useRef({
    top: V,
    dragging: v,
    pageY: S,
    startTop: R
  });
  k.current = {
    top: V,
    dragging: v,
    pageY: S,
    startTop: R
  };
  var z = function(Y) {
    m(!0), b(WO(Y, u)), _(k.current.top), a(), Y.stopPropagation(), Y.preventDefault();
  };
  E.useEffect(function() {
    var X = function(W) {
      W.preventDefault();
    }, Y = P.current, U = D.current;
    return Y.addEventListener("touchstart", X, {
      passive: !1
    }), U.addEventListener("touchstart", z, {
      passive: !1
    }), function() {
      Y.removeEventListener("touchstart", X), U.removeEventListener("touchstart", z);
    };
  }, []);
  var j = E.useRef();
  j.current = B;
  var q = E.useRef();
  q.current = M, E.useEffect(function() {
    if (v) {
      var X, Y = function(W) {
        var ne = k.current, ce = ne.dragging, we = ne.pageY, Re = ne.startTop;
        Ar.cancel(X);
        var ve = P.current.getBoundingClientRect(), xe = d / (u ? ve.width : ve.height);
        if (ce) {
          var _e = (WO(W, u) - we) * xe, Ve = Re;
          !T && u ? Ve -= _e : Ve += _e;
          var Fe = j.current, Ne = q.current, Je = Ne ? Ve / Ne : 0, J = Math.ceil(Je * Fe);
          J = Math.max(J, 0), J = Math.min(J, Fe), X = Ar(function() {
            l(J, u);
          });
        }
      }, U = function() {
        m(!1), s();
      };
      return window.addEventListener("mousemove", Y, {
        passive: !0
      }), window.addEventListener("touchmove", Y, {
        passive: !0
      }), window.addEventListener("mouseup", U, {
        passive: !0
      }), window.addEventListener("touchend", U, {
        passive: !0
      }), function() {
        window.removeEventListener("mousemove", Y), window.removeEventListener("touchmove", Y), window.removeEventListener("mouseup", U), window.removeEventListener("touchend", U), Ar.cancel(X);
      };
    }
  }, [v]), E.useEffect(function() {
    return I(), function() {
      clearTimeout(N.current);
    };
  }, [i]), E.useImperativeHandle(t, function() {
    return {
      delayHidden: I
    };
  });
  var K = "".concat(r, "-scrollbar"), Z = {
    position: "absolute",
    visibility: F ? null : "hidden"
  }, re = {
    position: "absolute",
    background: "rgba(0, 0, 0, 0.5)",
    borderRadius: 99,
    cursor: "pointer",
    userSelect: "none"
  };
  return u ? (Z.height = 8, Z.left = 0, Z.right = 0, Z.bottom = 0, re.height = "100%", re.width = c, T ? re.left = V : re.right = V) : (Z.width = 8, Z.top = 0, Z.bottom = 0, T ? Z.right = 0 : Z.left = 0, re.width = "100%", re.height = c, re.top = V), /* @__PURE__ */ E.createElement("div", {
    ref: P,
    className: ue(K, te(te(te({}, "".concat(K, "-horizontal"), u), "".concat(K, "-vertical"), !u), "".concat(K, "-visible"), F)),
    style: ee(ee({}, Z), h),
    onMouseDown: G,
    onMouseMove: I
  }, /* @__PURE__ */ E.createElement("div", {
    ref: D,
    className: ue("".concat(K, "-thumb"), te({}, "".concat(K, "-thumb-moving"), v)),
    style: ee(ee({}, re), f),
    onMouseDown: z
  }));
});
process.env.NODE_ENV !== "production" && (NR.displayName = "ScrollBar");
var Gae = 20;
function jO() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = e / t * e;
  return isNaN(r) && (r = 0), r = Math.max(r, Gae), Math.floor(r);
}
var zae = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "direction", "scrollWidth", "component", "onScroll", "onVirtualScroll", "onVisibleChange", "innerProps", "extraRender", "styles"], Wae = [], jae = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function Uae(e, t) {
  var r = e.prefixCls, n = r === void 0 ? "rc-virtual-list" : r, i = e.className, o = e.height, a = e.itemHeight, s = e.fullHeight, l = s === void 0 ? !0 : s, u = e.style, c = e.data, d = e.children, h = e.itemKey, f = e.virtual, p = e.direction, g = e.scrollWidth, v = e.component, m = v === void 0 ? "div" : v, y = e.onScroll, C = e.onVirtualScroll, S = e.onVisibleChange, b = e.innerProps, w = e.extraRender, x = e.styles, R = $t(e, zae), _ = E.useCallback(function(et) {
    return typeof h == "function" ? h(et) : et == null ? void 0 : et[h];
  }, [h]), T = Bae(_), P = ae(T, 4), D = P[0], O = P[1], A = P[2], F = P[3], L = !!(f !== !1 && o && a), N = E.useMemo(function() {
    return Object.values(A.maps).reduce(function(et, Ke) {
      return et + Ke;
    }, 0);
  }, [A.id, A.maps]), I = L && c && (Math.max(a * c.length, N) > o || !!g), B = p === "rtl", M = ue(n, te({}, "".concat(n, "-rtl"), B), i), V = c || Wae, G = se(), k = se(), z = se(), j = Me(0), q = ae(j, 2), K = q[0], Z = q[1], re = Me(0), X = ae(re, 2), Y = X[0], U = X[1], oe = Me(!1), W = ae(oe, 2), ne = W[0], ce = W[1], we = function() {
    ce(!0);
  }, Re = function() {
    ce(!1);
  }, ve = {
    getKey: _
  };
  function xe(et) {
    Z(function(Ke) {
      var rt;
      typeof et == "function" ? rt = et(Ke) : rt = et;
      var er = $r(rt);
      return G.current.scrollTop = er, er;
    });
  }
  var _e = se({
    start: 0,
    end: V.length
  }), Ve = se(), Fe = Fae(V, _), Ne = ae(Fe, 1), Je = Ne[0];
  Ve.current = Je;
  var J = E.useMemo(function() {
    if (!L)
      return {
        scrollHeight: void 0,
        start: 0,
        end: V.length - 1,
        offset: void 0
      };
    if (!I) {
      var et;
      return {
        scrollHeight: ((et = k.current) === null || et === void 0 ? void 0 : et.offsetHeight) || 0,
        start: 0,
        end: V.length - 1,
        offset: void 0
      };
    }
    for (var Ke = 0, rt, er, Xr, Rn = V.length, wr = 0; wr < Rn; wr += 1) {
      var Vi = V[wr], to = _(Vi), _n = A.get(to), gi = Ke + (_n === void 0 ? a : _n);
      gi >= K && rt === void 0 && (rt = wr, er = Ke), gi > K + o && Xr === void 0 && (Xr = wr), Ke = gi;
    }
    return rt === void 0 && (rt = 0, er = 0, Xr = Math.ceil(o / a)), Xr === void 0 && (Xr = V.length - 1), Xr = Math.min(Xr + 1, V.length - 1), {
      scrollHeight: Ke,
      start: rt,
      end: Xr,
      offset: er
    };
  }, [I, L, K, V, F, o]), he = J.scrollHeight, Le = J.start, Pe = J.end, Ie = J.offset;
  _e.current.start = Le, _e.current.end = Pe;
  var Ce = E.useState({
    width: 0,
    height: o
  }), De = ae(Ce, 2), ze = De[0], st = De[1], Tt = function(Ke) {
    st({
      width: Ke.offsetWidth,
      height: Ke.offsetHeight
    });
  }, ot = se(), Xe = se(), Oe = E.useMemo(function() {
    return jO(ze.width, g);
  }, [ze.width, g]), Qe = E.useMemo(function() {
    return jO(ze.height, he);
  }, [ze.height, he]), ft = he - o, xt = se(ft);
  xt.current = ft;
  function $r(et) {
    var Ke = et;
    return Number.isNaN(xt.current) || (Ke = Math.min(Ke, xt.current)), Ke = Math.max(Ke, 0), Ke;
  }
  var hr = K <= 0, Gt = K >= ft, Ot = Y <= 0, Lt = Y >= g, mt = J5(hr, Gt, Ot, Lt), qe = function() {
    return {
      x: B ? -Y : Y,
      y: K
    };
  }, zt = se(qe()), fr = An(function(et) {
    if (C) {
      var Ke = ee(ee({}, qe()), et);
      (zt.current.x !== Ke.x || zt.current.y !== Ke.y) && (C(Ke), zt.current = Ke);
    }
  });
  function Ge(et, Ke) {
    var rt = et;
    Ke ? (BE(function() {
      U(rt);
    }), fr()) : xe(rt);
  }
  function Ze(et) {
    var Ke = et.currentTarget.scrollTop;
    Ke !== K && xe(Ke), y == null || y(et), fr();
  }
  var tt = function(Ke) {
    var rt = Ke, er = g ? g - ze.width : 0;
    return rt = Math.max(rt, 0), rt = Math.min(rt, er), rt;
  }, ht = An(function(et, Ke) {
    Ke ? (BE(function() {
      U(function(rt) {
        var er = rt + (B ? -et : et);
        return tt(er);
      });
    }), fr()) : xe(function(rt) {
      var er = rt + et;
      return er;
    });
  }), It = Nae(L, hr, Gt, Ot, Lt, !!g, ht), qt = ae(It, 2), Hr = qt[0], Q = qt[1];
  $ae(L, G, function(et, Ke, rt) {
    return mt(et, Ke, rt) ? !1 : (Hr({
      preventDefault: function() {
      },
      deltaX: et ? Ke : 0,
      deltaY: et ? 0 : Ke
    }), !0);
  }), kr(function() {
    function et(rt) {
      L && rt.preventDefault();
    }
    var Ke = G.current;
    return Ke.addEventListener("wheel", Hr, {
      passive: !1
    }), Ke.addEventListener("DOMMouseScroll", Q, {
      passive: !0
    }), Ke.addEventListener("MozMousePixelScroll", et, {
      passive: !1
    }), function() {
      Ke.removeEventListener("wheel", Hr), Ke.removeEventListener("DOMMouseScroll", Q), Ke.removeEventListener("MozMousePixelScroll", et);
    };
  }, [L]), kr(function() {
    if (g) {
      var et = tt(Y);
      U(et), fr({
        x: et
      });
    }
  }, [ze.width, g]);
  var ye = function() {
    var Ke, rt;
    (Ke = ot.current) === null || Ke === void 0 || Ke.delayHidden(), (rt = Xe.current) === null || rt === void 0 || rt.delayHidden();
  }, me = Hae(G, V, A, a, _, function() {
    return O(!0);
  }, xe, ye);
  E.useImperativeHandle(t, function() {
    return {
      nativeElement: z.current,
      getScrollInfo: qe,
      scrollTo: function(Ke) {
        function rt(er) {
          return er && vt(er) === "object" && ("left" in er || "top" in er);
        }
        rt(Ke) ? (Ke.left !== void 0 && U(tt(Ke.left)), me(Ke.top)) : me(Ke);
      }
    };
  }), kr(function() {
    if (S) {
      var et = V.slice(Le, Pe + 1);
      S(et, V);
    }
  }, [Le, Pe, V]);
  var Ue = kae(V, _, A, a), pt = w == null ? void 0 : w({
    start: Le,
    end: Pe,
    virtual: I,
    offsetX: Y,
    offsetY: Ie,
    rtl: B,
    getSize: Ue
  }), gt = Oae(V, Le, Pe, g, Y, D, d, ve), yt = null;
  o && (yt = ee(te({}, l ? "height" : "maxHeight", o), jae), L && (yt.overflowY = "hidden", g && (yt.overflowX = "hidden"), ne && (yt.pointerEvents = "none")));
  var Rt = {};
  return B && (Rt.dir = "rtl"), /* @__PURE__ */ E.createElement("div", $e({
    ref: z,
    style: ee(ee({}, u), {}, {
      position: "relative"
    }),
    className: M
  }, Rt, R), /* @__PURE__ */ E.createElement(Co, {
    onResize: Tt
  }, /* @__PURE__ */ E.createElement(m, {
    className: "".concat(n, "-holder"),
    style: yt,
    ref: G,
    onScroll: Ze,
    onMouseEnter: ye
  }, /* @__PURE__ */ E.createElement(Q5, {
    prefixCls: n,
    height: he,
    offsetX: Y,
    offsetY: Ie,
    scrollWidth: g,
    onInnerResize: O,
    ref: k,
    innerProps: b,
    rtl: B,
    extra: pt
  }, gt))), I && he > o && /* @__PURE__ */ E.createElement(NR, {
    ref: ot,
    prefixCls: n,
    scrollOffset: K,
    scrollRange: he,
    rtl: B,
    onScroll: Ge,
    onStartMove: we,
    onStopMove: Re,
    spinSize: Qe,
    containerSize: ze.height,
    style: x == null ? void 0 : x.verticalScrollBar,
    thumbStyle: x == null ? void 0 : x.verticalScrollBarThumb
  }), I && g > ze.width && /* @__PURE__ */ E.createElement(NR, {
    ref: Xe,
    prefixCls: n,
    scrollOffset: Y,
    scrollRange: g,
    rtl: B,
    onScroll: Ge,
    onStartMove: we,
    onStopMove: Re,
    spinSize: Oe,
    containerSize: ze.width,
    horizontal: !0,
    style: x == null ? void 0 : x.horizontalScrollBar,
    thumbStyle: x == null ? void 0 : x.horizontalScrollBarThumb
  }));
}
var e8 = /* @__PURE__ */ E.forwardRef(Uae);
e8.displayName = "List";
function Kae() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
var Yae = ["disabled", "title", "children", "style", "className"];
function UO(e) {
  return typeof e == "string" || typeof e == "number";
}
var qae = function(t, r) {
  var n = zoe(), i = n.prefixCls, o = n.id, a = n.open, s = n.multiple, l = n.mode, u = n.searchValue, c = n.toggleOpen, d = n.notFoundContent, h = n.onPopupScroll, f = E.useContext(KP), p = f.maxCount, g = f.flattenOptions, v = f.onActiveValue, m = f.defaultActiveFirstOption, y = f.onSelect, C = f.menuItemSelectedIcon, S = f.rawValues, b = f.fieldNames, w = f.virtual, x = f.direction, R = f.listHeight, _ = f.listItemHeight, T = f.optionRender, P = "".concat(i, "-item"), D = vv(function() {
    return g;
  }, [a, g], function(X, Y) {
    return Y[0] && X[1] !== Y[1];
  }), O = E.useRef(null), A = E.useMemo(function() {
    return s && LR(p) && (S == null ? void 0 : S.size) >= p;
  }, [s, p, S == null ? void 0 : S.size]), F = function(Y) {
    Y.preventDefault();
  }, L = function(Y) {
    var U;
    (U = O.current) === null || U === void 0 || U.scrollTo(typeof Y == "number" ? {
      index: Y
    } : Y);
  }, N = function(Y) {
    for (var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1, oe = D.length, W = 0; W < oe; W += 1) {
      var ne = (Y + W * U + oe) % oe, ce = D[ne] || {}, we = ce.group, Re = ce.data;
      if (!we && !(Re != null && Re.disabled) && !A)
        return ne;
    }
    return -1;
  }, I = E.useState(function() {
    return N(0);
  }), B = ae(I, 2), M = B[0], V = B[1], G = function(Y) {
    var U = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    V(Y);
    var oe = {
      source: U ? "keyboard" : "mouse"
    }, W = D[Y];
    if (!W) {
      v(null, -1, oe);
      return;
    }
    v(W.value, Y, oe);
  };
  Nt(function() {
    G(m !== !1 ? N(0) : -1);
  }, [D.length, u]);
  var k = E.useCallback(function(X) {
    return S.has(X) && l !== "combobox";
  }, [l, it(S).toString(), S.size]);
  Nt(function() {
    var X = setTimeout(function() {
      if (!s && a && S.size === 1) {
        var U = Array.from(S)[0], oe = D.findIndex(function(W) {
          var ne = W.data;
          return ne.value === U;
        });
        oe !== -1 && (G(oe), L(oe));
      }
    });
    if (a) {
      var Y;
      (Y = O.current) === null || Y === void 0 || Y.scrollTo(void 0);
    }
    return function() {
      return clearTimeout(X);
    };
  }, [a, u]);
  var z = function(Y) {
    Y !== void 0 && y(Y, {
      selected: !S.has(Y)
    }), s || c(!1);
  };
  if (E.useImperativeHandle(r, function() {
    return {
      onKeyDown: function(Y) {
        var U = Y.which, oe = Y.ctrlKey;
        switch (U) {
          case Ae.N:
          case Ae.P:
          case Ae.UP:
          case Ae.DOWN: {
            var W = 0;
            if (U === Ae.UP ? W = -1 : U === Ae.DOWN ? W = 1 : Kae() && oe && (U === Ae.N ? W = 1 : U === Ae.P && (W = -1)), W !== 0) {
              var ne = N(M + W, W);
              L(ne), G(ne, !0);
            }
            break;
          }
          case Ae.ENTER: {
            var ce, we = D[M];
            we && !(we != null && (ce = we.data) !== null && ce !== void 0 && ce.disabled) && !A ? z(we.value) : z(void 0), a && Y.preventDefault();
            break;
          }
          case Ae.ESC:
            c(!1), a && Y.stopPropagation();
        }
      },
      onKeyUp: function() {
      },
      scrollTo: function(Y) {
        L(Y);
      }
    };
  }), D.length === 0)
    return /* @__PURE__ */ E.createElement("div", {
      role: "listbox",
      id: "".concat(o, "_list"),
      className: "".concat(P, "-empty"),
      onMouseDown: F
    }, d);
  var j = Object.keys(b).map(function(X) {
    return b[X];
  }), q = function(Y) {
    return Y.label;
  };
  function K(X, Y) {
    var U = X.group;
    return {
      role: U ? "presentation" : "option",
      id: "".concat(o, "_list_").concat(Y)
    };
  }
  var Z = function(Y) {
    var U = D[Y];
    if (!U)
      return null;
    var oe = U.data || {}, W = oe.value, ne = U.group, ce = Zl(oe, !0), we = q(U);
    return U ? /* @__PURE__ */ E.createElement("div", $e({
      "aria-label": typeof we == "string" && !ne ? we : null
    }, ce, {
      key: Y
    }, K(U, Y), {
      "aria-selected": k(W)
    }), W) : null;
  }, re = {
    role: "listbox",
    id: "".concat(o, "_list")
  };
  return /* @__PURE__ */ E.createElement(E.Fragment, null, w && /* @__PURE__ */ E.createElement("div", $e({}, re, {
    style: {
      height: 0,
      width: 0,
      overflow: "hidden"
    }
  }), Z(M - 1), Z(M), Z(M + 1)), /* @__PURE__ */ E.createElement(e8, {
    itemKey: "key",
    ref: O,
    data: D,
    height: R,
    itemHeight: _,
    fullHeight: !1,
    onMouseDown: F,
    onScroll: h,
    virtual: w,
    direction: x,
    innerProps: w ? null : re
  }, function(X, Y) {
    var U = X.group, oe = X.groupOption, W = X.data, ne = X.label, ce = X.value, we = W.key;
    if (U) {
      var Re, ve = (Re = W.title) !== null && Re !== void 0 ? Re : UO(ne) ? ne.toString() : void 0;
      return /* @__PURE__ */ E.createElement("div", {
        className: ue(P, "".concat(P, "-group"), W.className),
        title: ve
      }, ne !== void 0 ? ne : we);
    }
    var xe = W.disabled, _e = W.title;
    W.children;
    var Ve = W.style, Fe = W.className, Ne = $t(W, Yae), Je = ni(Ne, j), J = k(ce), he = xe || !J && A, Le = "".concat(P, "-option"), Pe = ue(P, Le, Fe, te(te(te(te({}, "".concat(Le, "-grouped"), oe), "".concat(Le, "-active"), M === Y && !he), "".concat(Le, "-disabled"), he), "".concat(Le, "-selected"), J)), Ie = q(X), Ce = !C || typeof C == "function" || J, De = typeof Ie == "number" ? Ie : Ie || ce, ze = UO(De) ? De.toString() : void 0;
    return _e !== void 0 && (ze = _e), /* @__PURE__ */ E.createElement("div", $e({}, Zl(Je), w ? {} : K(X, Y), {
      "aria-selected": J,
      className: Pe,
      title: ze,
      onMouseMove: function() {
        M === Y || he || G(Y);
      },
      onClick: function() {
        he || z(ce);
      },
      style: Ve
    }), /* @__PURE__ */ E.createElement("div", {
      className: "".concat(Le, "-content")
    }, typeof T == "function" ? T(X, {
      index: Y
    }) : De), /* @__PURE__ */ E.isValidElement(C) || J, Ce && /* @__PURE__ */ E.createElement(ES, {
      className: "".concat(P, "-option-state"),
      customizeIcon: C,
      customizeIconProps: {
        value: ce,
        disabled: he,
        isSelected: J
      }
    }, J ? "" : null));
  }));
}, t8 = /* @__PURE__ */ E.forwardRef(qae);
process.env.NODE_ENV !== "production" && (t8.displayName = "OptionList");
const Xae = function(e, t) {
  var r = E.useRef({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  }), n = E.useMemo(function() {
    var o = r.current, a = o.values, s = o.options, l = e.map(function(d) {
      if (d.label === void 0) {
        var h;
        return ee(ee({}, d), {}, {
          label: (h = a.get(d.value)) === null || h === void 0 ? void 0 : h.label
        });
      }
      return d;
    }), u = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
    return l.forEach(function(d) {
      u.set(d.value, d), c.set(d.value, t.get(d.value) || s.get(d.value));
    }), r.current.values = u, r.current.options = c, l;
  }, [e, t]), i = E.useCallback(function(o) {
    return t.get(o) || r.current.options.get(o);
  }, [t]);
  return [n, i];
};
function gb(e, t) {
  return UP(e).join("").toUpperCase().includes(t);
}
const Zae = function(e, t, r, n, i) {
  return E.useMemo(function() {
    if (!r || n === !1)
      return e;
    var o = t.options, a = t.label, s = t.value, l = [], u = typeof n == "function", c = r.toUpperCase(), d = u ? n : function(f, p) {
      return i ? gb(p[i], c) : p[o] ? gb(p[a !== "children" ? a : "label"], c) : gb(p[s], c);
    }, h = u ? function(f) {
      return FR(f);
    } : function(f) {
      return f;
    };
    return e.forEach(function(f) {
      if (f[o]) {
        var p = d(r, h(f));
        if (p)
          l.push(f);
        else {
          var g = f[o].filter(function(v) {
            return d(r, h(v));
          });
          g.length && l.push(ee(ee({}, f), {}, te({}, o, g)));
        }
        return;
      }
      d(r, h(f)) && l.push(f);
    }), l;
  }, [e, n, i, r, t]);
};
var KO = 0, Qae = process.env.NODE_ENV !== "test" && Zn();
function Jae() {
  var e;
  return Qae ? (e = KO, KO += 1) : e = "TEST_OR_SSR", e;
}
function ese(e) {
  var t = E.useState(), r = ae(t, 2), n = r[0], i = r[1];
  return E.useEffect(function() {
    i("rc_select_".concat(Jae()));
  }, []), e || n;
}
var tse = ["children", "value"], rse = ["children"];
function nse(e) {
  var t = e, r = t.key, n = t.props, i = n.children, o = n.value, a = $t(n, tse);
  return ee({
    key: r,
    value: o !== void 0 ? o : r,
    children: i
  }, a);
}
function XP(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return Zo(e).map(function(r, n) {
    if (!/* @__PURE__ */ E.isValidElement(r) || !r.type)
      return null;
    var i = r, o = i.type.isSelectOptGroup, a = i.key, s = i.props, l = s.children, u = $t(s, rse);
    return t || !o ? nse(r) : ee(ee({
      key: "__RC_SELECT_GRP__".concat(a === null ? n : a, "__"),
      label: a
    }, u), {}, {
      options: XP(l)
    });
  }).filter(function(r) {
    return r;
  });
}
var ise = function(t, r, n, i, o) {
  return E.useMemo(function() {
    var a = t, s = !t;
    s && (a = XP(r));
    var l = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), c = function(f, p, g) {
      g && typeof g == "string" && f.set(p[g], p);
    }, d = function h(f) {
      for (var p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, g = 0; g < f.length; g += 1) {
        var v = f[g];
        !v[n.options] || p ? (l.set(v[n.value], v), c(u, v, n.label), c(u, v, i), c(u, v, o)) : h(v[n.options], !0);
      }
    };
    return d(a), {
      options: a,
      valueOptions: l,
      labelOptions: u
    };
  }, [t, r, n, i, o]);
};
function YO(e) {
  var t = E.useRef();
  t.current = e;
  var r = E.useCallback(function() {
    return t.current.apply(t, arguments);
  }, []);
  return r;
}
function ose(e) {
  var t = e.mode, r = e.options, n = e.children, i = e.backfill, o = e.allowClear, a = e.placeholder, s = e.getInputElement, l = e.showSearch, u = e.onSearch, c = e.defaultOpen, d = e.autoFocus, h = e.labelInValue, f = e.value, p = e.inputValue, g = e.optionLabelProp, v = V0(t), m = l !== void 0 ? l : v || t === "combobox", y = r || XP(n);
  if (Qt(t !== "tags" || y.every(function(w) {
    return !w.disabled;
  }), "Please avoid setting option to disabled in tags mode since user can always type text as tag."), t === "tags" || t === "combobox") {
    var C = y.some(function(w) {
      return w.options ? w.options.some(function(x) {
        return typeof ("value" in x ? x.value : x.key) == "number";
      }) : typeof ("value" in w ? w.value : w.key) == "number";
    });
    Qt(!C, "`value` of Option should not use number type when `mode` is `tags` or `combobox`.");
  }
  if (Qt(t !== "combobox" || !g, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."), Qt(t === "combobox" || !i, "`backfill` only works with `combobox` mode."), Qt(t === "combobox" || !s, "`getInputElement` only work with `combobox` mode."), WE(t !== "combobox" || !s || !o || !a, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."), u && !m && t !== "combobox" && t !== "tags" && Qt(!1, "`onSearch` should work with `showSearch` instead of use alone."), WE(!c || d, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed."), f != null) {
    var S = UP(f);
    Qt(!h || S.every(function(w) {
      return vt(w) === "object" && ("key" in w || "value" in w);
    }), "`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`"), Qt(!v || Array.isArray(f), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (n) {
    var b = null;
    Zo(n).some(function(w) {
      if (!/* @__PURE__ */ E.isValidElement(w) || !w.type)
        return !1;
      var x = w, R = x.type;
      if (R.isSelectOption)
        return !1;
      if (R.isSelectOptGroup) {
        var _ = Zo(w.props.children).every(function(T) {
          return !/* @__PURE__ */ E.isValidElement(T) || !w.type || T.type.isSelectOption ? !0 : (b = T.type, !1);
        });
        return !_;
      }
      return b = R, !0;
    }), b && Qt(!1, "`children` should be `Select.Option` or `Select.OptGroup` instead of `".concat(b.displayName || b.name || b, "`.")), Qt(p === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
  }
}
function ase(e, t) {
  if (e) {
    var r = function n(i) {
      for (var o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, a = 0; a < i.length; a++) {
        var s = i[a];
        if (s[t == null ? void 0 : t.value] === null)
          return Qt(!1, "`value` in Select options should not be `null`."), !0;
        if (!o && Array.isArray(s[t == null ? void 0 : t.options]) && n(s[t == null ? void 0 : t.options], !0))
          break;
      }
    };
    r(e);
  }
}
var sse = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "optionRender", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "direction", "listHeight", "listItemHeight", "labelRender", "value", "defaultValue", "labelInValue", "onChange", "maxCount"], lse = ["inputValue"];
function use(e) {
  return !e || vt(e) !== "object";
}
var r8 = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.id, n = e.mode, i = e.prefixCls, o = i === void 0 ? "rc-select" : i, a = e.backfill, s = e.fieldNames, l = e.inputValue, u = e.searchValue, c = e.onSearch, d = e.autoClearSearchValue, h = d === void 0 ? !0 : d, f = e.onSelect, p = e.onDeselect, g = e.dropdownMatchSelectWidth, v = g === void 0 ? !0 : g, m = e.filterOption, y = e.filterSort, C = e.optionFilterProp, S = e.optionLabelProp, b = e.options, w = e.optionRender, x = e.children, R = e.defaultActiveFirstOption, _ = e.menuItemSelectedIcon, T = e.virtual, P = e.direction, D = e.listHeight, O = D === void 0 ? 200 : D, A = e.listItemHeight, F = A === void 0 ? 20 : A, L = e.labelRender, N = e.value, I = e.defaultValue, B = e.labelInValue, M = e.onChange, V = e.maxCount, G = $t(e, sse), k = ese(r), z = V0(n), j = !!(!b && x), q = E.useMemo(function() {
    return m === void 0 && n === "combobox" ? !1 : m;
  }, [m, n]), K = E.useMemo(
    function() {
      return X5(s, j);
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [
      // We stringify fieldNames to avoid unnecessary re-renders.
      JSON.stringify(s),
      j
    ]
    /* eslint-enable react-hooks/exhaustive-deps */
  ), Z = xn("", {
    value: u !== void 0 ? u : l,
    postState: function(Ze) {
      return Ze || "";
    }
  }), re = ae(Z, 2), X = re[0], Y = re[1], U = ise(b, x, K, C, S), oe = U.valueOptions, W = U.labelOptions, ne = U.options, ce = E.useCallback(function(Ge) {
    var Ze = UP(Ge);
    return Ze.map(function(tt) {
      var ht, It, qt, Hr, Q;
      if (use(tt))
        ht = tt;
      else {
        var ye;
        qt = tt.key, It = tt.label, ht = (ye = tt.value) !== null && ye !== void 0 ? ye : qt;
      }
      var me = oe.get(ht);
      if (me) {
        var Ue;
        if (It === void 0 && (It = me == null ? void 0 : me[S || K.label]), qt === void 0 && (qt = (Ue = me == null ? void 0 : me.key) !== null && Ue !== void 0 ? Ue : ht), Hr = me == null ? void 0 : me.disabled, Q = me == null ? void 0 : me.title, process.env.NODE_ENV !== "production" && !S) {
          var pt = me == null ? void 0 : me[K.label];
          pt !== void 0 && !/* @__PURE__ */ E.isValidElement(pt) && !/* @__PURE__ */ E.isValidElement(It) && pt !== It && Qt(!1, "`label` of `value` is not same as `label` in Select options.");
        }
      }
      return {
        label: It,
        value: ht,
        key: qt,
        disabled: Hr,
        title: Q
      };
    });
  }, [K, S, oe]), we = xn(I, {
    value: N
  }), Re = ae(we, 2), ve = Re[0], xe = Re[1], _e = E.useMemo(function() {
    var Ge, Ze = z && ve === null ? [] : ve, tt = ce(Ze);
    return n === "combobox" && lae((Ge = tt[0]) === null || Ge === void 0 ? void 0 : Ge.value) ? [] : tt;
  }, [ve, ce, n, z]), Ve = Xae(_e, oe), Fe = ae(Ve, 2), Ne = Fe[0], Je = Fe[1], J = E.useMemo(function() {
    if (!n && Ne.length === 1) {
      var Ge = Ne[0];
      if (Ge.value === null && (Ge.label === null || Ge.label === void 0))
        return [];
    }
    return Ne.map(function(Ze) {
      var tt;
      return ee(ee({}, Ze), {}, {
        label: (tt = typeof L == "function" ? L(Ze) : Ze.label) !== null && tt !== void 0 ? tt : Ze.value
      });
    });
  }, [n, Ne, L]), he = E.useMemo(function() {
    return new Set(Ne.map(function(Ge) {
      return Ge.value;
    }));
  }, [Ne]);
  E.useEffect(function() {
    if (n === "combobox") {
      var Ge, Ze = (Ge = Ne[0]) === null || Ge === void 0 ? void 0 : Ge.value;
      Y(sae(Ze) ? String(Ze) : "");
    }
  }, [Ne]);
  var Le = YO(function(Ge, Ze) {
    var tt = Ze ?? Ge;
    return te(te({}, K.value, Ge), K.label, tt);
  }), Pe = E.useMemo(function() {
    if (n !== "tags")
      return ne;
    var Ge = it(ne), Ze = function(ht) {
      return oe.has(ht);
    };
    return it(Ne).sort(function(tt, ht) {
      return tt.value < ht.value ? -1 : 1;
    }).forEach(function(tt) {
      var ht = tt.value;
      Ze(ht) || Ge.push(Le(ht, tt.label));
    }), Ge;
  }, [Le, ne, oe, Ne, n]), Ie = Zae(Pe, K, X, q, C), Ce = E.useMemo(function() {
    return n !== "tags" || !X || Ie.some(function(Ge) {
      return Ge[C || "value"] === X;
    }) || Ie.some(function(Ge) {
      return Ge[K.value] === X;
    }) ? Ie : [Le(X)].concat(it(Ie));
  }, [Le, C, n, Ie, X, K]), De = E.useMemo(function() {
    return y ? it(Ce).sort(function(Ge, Ze) {
      return y(Ge, Ze, {
        searchValue: X
      });
    }) : Ce;
  }, [Ce, y, X]), ze = E.useMemo(function() {
    return Tae(De, {
      fieldNames: K,
      childrenAsData: j
    });
  }, [De, K, j]), st = function(Ze) {
    var tt = ce(Ze);
    if (xe(tt), M && // Trigger event only when value changed
    (tt.length !== Ne.length || tt.some(function(qt, Hr) {
      var Q;
      return ((Q = Ne[Hr]) === null || Q === void 0 ? void 0 : Q.value) !== (qt == null ? void 0 : qt.value);
    }))) {
      var ht = B ? tt : tt.map(function(qt) {
        return qt.value;
      }), It = tt.map(function(qt) {
        return FR(Je(qt.value));
      });
      M(
        // Value
        z ? ht : ht[0],
        // Option
        z ? It : It[0]
      );
    }
  }, Tt = E.useState(null), ot = ae(Tt, 2), Xe = ot[0], Oe = ot[1], Qe = E.useState(0), ft = ae(Qe, 2), xt = ft[0], $r = ft[1], hr = R !== void 0 ? R : n !== "combobox", Gt = E.useCallback(function(Ge, Ze) {
    var tt = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, ht = tt.source, It = ht === void 0 ? "keyboard" : ht;
    $r(Ze), a && n === "combobox" && Ge !== null && It === "keyboard" && Oe(String(Ge));
  }, [a, n]), Ot = function(Ze, tt, ht) {
    var It = function() {
      var Rt, et = Je(Ze);
      return [B ? {
        label: et == null ? void 0 : et[K.label],
        value: Ze,
        key: (Rt = et == null ? void 0 : et.key) !== null && Rt !== void 0 ? Rt : Ze
      } : Ze, FR(et)];
    };
    if (tt && f) {
      var qt = It(), Hr = ae(qt, 2), Q = Hr[0], ye = Hr[1];
      f(Q, ye);
    } else if (!tt && p && ht !== "clear") {
      var me = It(), Ue = ae(me, 2), pt = Ue[0], gt = Ue[1];
      p(pt, gt);
    }
  }, Lt = YO(function(Ge, Ze) {
    var tt, ht = z ? Ze.selected : !0;
    ht ? tt = z ? [].concat(it(Ne), [Ge]) : [Ge] : tt = Ne.filter(function(It) {
      return It.value !== Ge;
    }), st(tt), Ot(Ge, ht), n === "combobox" ? Oe("") : (!V0 || h) && (Y(""), Oe(""));
  }), mt = function(Ze, tt) {
    st(Ze);
    var ht = tt.type, It = tt.values;
    (ht === "remove" || ht === "clear") && It.forEach(function(qt) {
      Ot(qt.value, !1, ht);
    });
  }, qe = function(Ze, tt) {
    if (Y(Ze), Oe(null), tt.source === "submit") {
      var ht = (Ze || "").trim();
      if (ht) {
        var It = Array.from(new Set([].concat(it(he), [ht])));
        st(It), Ot(ht, !0), Y("");
      }
      return;
    }
    tt.source !== "blur" && (n === "combobox" && st(Ze), c == null || c(Ze));
  }, zt = function(Ze) {
    var tt = Ze;
    n !== "tags" && (tt = Ze.map(function(It) {
      var qt = W.get(It);
      return qt == null ? void 0 : qt.value;
    }).filter(function(It) {
      return It !== void 0;
    }));
    var ht = Array.from(new Set([].concat(it(he), it(tt))));
    st(ht), ht.forEach(function(It) {
      Ot(It, !0);
    });
  }, fr = E.useMemo(function() {
    var Ge = T !== !1 && v !== !1;
    return ee(ee({}, U), {}, {
      flattenOptions: ze,
      onActiveValue: Gt,
      defaultActiveFirstOption: hr,
      onSelect: Lt,
      menuItemSelectedIcon: _,
      rawValues: he,
      fieldNames: K,
      virtual: Ge,
      direction: P,
      listHeight: O,
      listItemHeight: F,
      childrenAsData: j,
      maxCount: V,
      optionRender: w
    });
  }, [V, U, ze, Gt, hr, Lt, _, he, K, T, v, P, O, F, j, w]);
  return process.env.NODE_ENV !== "production" && (ose(e), ase(ne, K)), /* @__PURE__ */ E.createElement(KP.Provider, {
    value: fr
  }, /* @__PURE__ */ E.createElement(Z5, $e({}, G, {
    // >>> MISC
    id: k,
    prefixCls: o,
    ref: t,
    omitDomProps: lse,
    mode: n,
    displayValues: J,
    onDisplayValuesChange: mt,
    direction: P,
    searchValue: X,
    onSearch: qe,
    autoClearSearchValue: h,
    onSearchSplit: zt,
    dropdownMatchSelectWidth: v,
    OptionList: t8,
    emptyOptions: !ze.length,
    activeValue: Xe,
    activeDescendantId: "".concat(k, "_list_").concat(xt)
  })));
});
process.env.NODE_ENV !== "production" && (r8.displayName = "Select");
var ZP = r8;
ZP.Option = qP;
ZP.OptGroup = YP;
function B0(e, t, r) {
  return ue({
    [`${e}-status-success`]: t === "success",
    [`${e}-status-warning`]: t === "warning",
    [`${e}-status-error`]: t === "error",
    [`${e}-status-validating`]: t === "validating",
    [`${e}-has-feedback`]: r
  });
}
const _S = (e, t) => t || e, n8 = () => {
  const [, e] = Qi(), r = new Jr(e.colorBgBase).toHsl().l < 0.5 ? {
    opacity: 0.65
  } : {};
  return /* @__PURE__ */ E.createElement("svg", {
    style: r,
    width: "184",
    height: "152",
    viewBox: "0 0 184 152",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ E.createElement("title", null, "empty image"), /* @__PURE__ */ E.createElement("g", {
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ E.createElement("g", {
    transform: "translate(24 31.67)"
  }, /* @__PURE__ */ E.createElement("ellipse", {
    fillOpacity: ".8",
    fill: "#F5F5F7",
    cx: "67.797",
    cy: "106.89",
    rx: "67.797",
    ry: "12.668"
  }), /* @__PURE__ */ E.createElement("path", {
    d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
    fill: "#AEB8C2"
  }), /* @__PURE__ */ E.createElement("path", {
    d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
    fill: "url(#linearGradient-1)",
    transform: "translate(13.56)"
  }), /* @__PURE__ */ E.createElement("path", {
    d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
    fill: "#F5F5F7"
  }), /* @__PURE__ */ E.createElement("path", {
    d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
    fill: "#DCE0E6"
  })), /* @__PURE__ */ E.createElement("path", {
    d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
    fill: "#DCE0E6"
  }), /* @__PURE__ */ E.createElement("g", {
    transform: "translate(149.65 15.383)",
    fill: "#FFF"
  }, /* @__PURE__ */ E.createElement("ellipse", {
    cx: "20.654",
    cy: "3.167",
    rx: "2.849",
    ry: "2.815"
  }), /* @__PURE__ */ E.createElement("path", {
    d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
  }))));
};
process.env.NODE_ENV !== "production" && (n8.displayName = "EmptyImage");
const i8 = () => {
  const [, e] = Qi(), {
    colorFill: t,
    colorFillTertiary: r,
    colorFillQuaternary: n,
    colorBgContainer: i
  } = e, {
    borderColor: o,
    shadowColor: a,
    contentColor: s
  } = Et(() => ({
    borderColor: new Jr(t).onBackground(i).toHexShortString(),
    shadowColor: new Jr(r).onBackground(i).toHexShortString(),
    contentColor: new Jr(n).onBackground(i).toHexShortString()
  }), [t, r, n, i]);
  return /* @__PURE__ */ E.createElement("svg", {
    width: "64",
    height: "41",
    viewBox: "0 0 64 41",
    xmlns: "http://www.w3.org/2000/svg"
  }, /* @__PURE__ */ E.createElement("title", null, "Simple Empty"), /* @__PURE__ */ E.createElement("g", {
    transform: "translate(0 1)",
    fill: "none",
    fillRule: "evenodd"
  }, /* @__PURE__ */ E.createElement("ellipse", {
    fill: a,
    cx: "32",
    cy: "33",
    rx: "32",
    ry: "7"
  }), /* @__PURE__ */ E.createElement("g", {
    fillRule: "nonzero",
    stroke: o
  }, /* @__PURE__ */ E.createElement("path", {
    d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
  }), /* @__PURE__ */ E.createElement("path", {
    d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
    fill: s
  }))));
};
process.env.NODE_ENV !== "production" && (i8.displayName = "SimpleImage");
const cse = (e) => {
  const {
    componentCls: t,
    margin: r,
    marginXS: n,
    marginXL: i,
    fontSize: o,
    lineHeight: a
  } = e;
  return {
    [t]: {
      marginInline: n,
      fontSize: o,
      lineHeight: a,
      textAlign: "center",
      //  &-image hashId
      [`${t}-image`]: {
        height: e.emptyImgHeight,
        marginBottom: n,
        opacity: e.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          maxWidth: "100%",
          height: "100%",
          margin: "auto"
        }
      },
      [`${t}-description`]: {
        color: e.colorTextDescription
      },
      //  &-footer hashId
      [`${t}-footer`]: {
        marginTop: r
      },
      "&-normal": {
        marginBlock: i,
        color: e.colorTextDescription,
        [`${t}-description`]: {
          color: e.colorTextDescription
        },
        [`${t}-image`]: {
          height: e.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: n,
        color: e.colorTextDescription,
        [`${t}-image`]: {
          height: e.emptyImgHeightSM
        }
      }
    }
  };
}, dse = Gn("Empty", (e) => {
  const {
    componentCls: t,
    controlHeightLG: r,
    calc: n
  } = e, i = Br(e, {
    emptyImgCls: `${t}-img`,
    emptyImgHeight: n(r).mul(2.5).equal(),
    emptyImgHeightMD: r,
    emptyImgHeightSM: n(r).mul(0.875).equal()
  });
  return [cse(i)];
});
var hse = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const o8 = /* @__PURE__ */ E.createElement(n8, null), a8 = /* @__PURE__ */ E.createElement(i8, null), Dl = (e) => {
  var {
    className: t,
    rootClassName: r,
    prefixCls: n,
    image: i = o8,
    description: o,
    children: a,
    imageStyle: s,
    style: l
  } = e, u = hse(e, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle", "style"]);
  const {
    getPrefixCls: c,
    direction: d,
    empty: h
  } = E.useContext(Yt), f = c("empty", n), [p, g, v] = dse(f), [m] = AP("Empty"), y = typeof o < "u" ? o : m == null ? void 0 : m.description, C = typeof y == "string" ? y : "empty";
  let S = null;
  return typeof i == "string" ? S = /* @__PURE__ */ E.createElement("img", {
    alt: C,
    src: i
  }) : S = i, p(/* @__PURE__ */ E.createElement("div", Object.assign({
    className: ue(g, v, f, h == null ? void 0 : h.className, {
      [`${f}-normal`]: i === a8,
      [`${f}-rtl`]: d === "rtl"
    }, t, r),
    style: Object.assign(Object.assign({}, h == null ? void 0 : h.style), l)
  }, u), /* @__PURE__ */ E.createElement("div", {
    className: `${f}-image`,
    style: s
  }, S), y && /* @__PURE__ */ E.createElement("div", {
    className: `${f}-description`
  }, y), a && /* @__PURE__ */ E.createElement("div", {
    className: `${f}-footer`
  }, a)));
};
Dl.PRESENTED_IMAGE_DEFAULT = o8;
Dl.PRESENTED_IMAGE_SIMPLE = a8;
process.env.NODE_ENV !== "production" && (Dl.displayName = "Empty");
const fse = (e) => {
  const {
    componentName: t
  } = e, {
    getPrefixCls: r
  } = vr(Yt), n = r("empty");
  switch (t) {
    case "Table":
    case "List":
      return /* @__PURE__ */ H.createElement(Dl, {
        image: Dl.PRESENTED_IMAGE_SIMPLE
      });
    case "Select":
    case "TreeSelect":
    case "Cascader":
    case "Transfer":
    case "Mentions":
      return /* @__PURE__ */ H.createElement(Dl, {
        image: Dl.PRESENTED_IMAGE_SIMPLE,
        className: `${n}-small`
      });
    default:
      return /* @__PURE__ */ H.createElement(Dl, null);
  }
}, QP = function(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
  var n, i;
  const {
    variant: o,
    [e]: a
  } = vr(Yt), s = vr(Fie), l = a == null ? void 0 : a.variant;
  let u;
  typeof t < "u" ? u = t : r === !1 ? u = "borderless" : u = (i = (n = s ?? l) !== null && n !== void 0 ? n : o) !== null && i !== void 0 ? i : "outlined";
  const c = rte.includes(u);
  return [u, c];
}, pse = (e) => {
  const r = {
    overflow: {
      adjustX: !0,
      adjustY: !0,
      shiftY: !0
    },
    htmlRegion: e === "scroll" ? "scroll" : "visible",
    dynamicInset: !0
  };
  return {
    bottomLeft: Object.assign(Object.assign({}, r), {
      points: ["tl", "bl"],
      offset: [0, 4]
    }),
    bottomRight: Object.assign(Object.assign({}, r), {
      points: ["tr", "br"],
      offset: [0, 4]
    }),
    topLeft: Object.assign(Object.assign({}, r), {
      points: ["bl", "tl"],
      offset: [0, -4]
    }),
    topRight: Object.assign(Object.assign({}, r), {
      points: ["br", "tr"],
      offset: [0, -4]
    })
  };
};
function gse(e, t) {
  return e || pse(t);
}
const qO = (e) => {
  const {
    optionHeight: t,
    optionFontSize: r,
    optionLineHeight: n,
    optionPadding: i
  } = e;
  return {
    position: "relative",
    display: "block",
    minHeight: t,
    padding: i,
    color: e.colorText,
    fontWeight: "normal",
    fontSize: r,
    lineHeight: n,
    boxSizing: "border-box"
  };
}, vse = (e) => {
  const {
    antCls: t,
    componentCls: r
  } = e, n = `${r}-item`, i = `&${t}-slide-up-enter${t}-slide-up-enter-active`, o = `&${t}-slide-up-appear${t}-slide-up-appear-active`, a = `&${t}-slide-up-leave${t}-slide-up-leave-active`, s = `${r}-dropdown-placement-`;
  return [
    {
      [`${r}-dropdown`]: Object.assign(Object.assign({}, Fi(e)), {
        position: "absolute",
        top: -9999,
        zIndex: e.zIndexPopup,
        boxSizing: "border-box",
        padding: e.paddingXXS,
        overflow: "hidden",
        fontSize: e.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: e.colorBgElevated,
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        [`
          ${i}${s}bottomLeft,
          ${o}${s}bottomLeft
        `]: {
          animationName: L5
        },
        [`
          ${i}${s}topLeft,
          ${o}${s}topLeft,
          ${i}${s}topRight,
          ${o}${s}topRight
        `]: {
          animationName: N5
        },
        [`${a}${s}bottomLeft`]: {
          animationName: F5
        },
        [`
          ${a}${s}topLeft,
          ${a}${s}topRight
        `]: {
          animationName: k5
        },
        "&-hidden": {
          display: "none"
        },
        [`${n}`]: Object.assign(Object.assign({}, qO(e)), {
          cursor: "pointer",
          transition: `background ${e.motionDurationSlow} ease`,
          borderRadius: e.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": Object.assign({
              flex: "auto"
            }, Xl),
            "&-state": {
              flex: "none",
              display: "flex",
              alignItems: "center"
            },
            [`&-active:not(${n}-option-disabled)`]: {
              backgroundColor: e.optionActiveBg
            },
            [`&-selected:not(${n}-option-disabled)`]: {
              color: e.optionSelectedColor,
              fontWeight: e.optionSelectedFontWeight,
              backgroundColor: e.optionSelectedBg,
              [`${n}-option-state`]: {
                color: e.colorPrimary
              },
              [`&:has(+ ${n}-option-selected:not(${n}-option-disabled))`]: {
                borderEndStartRadius: 0,
                borderEndEndRadius: 0,
                [`& + ${n}-option-selected:not(${n}-option-disabled)`]: {
                  borderStartStartRadius: 0,
                  borderStartEndRadius: 0
                }
              }
            },
            "&-disabled": {
              [`&${n}-option-selected`]: {
                backgroundColor: e.colorBgContainerDisabled
              },
              color: e.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: e.calc(e.controlPaddingHorizontal).mul(2).equal()
            }
          },
          "&-empty": Object.assign(Object.assign({}, qO(e)), {
            color: e.colorTextDisabled
          })
        }),
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Follow code may reuse in other components
    N0(e, "slide-up"),
    N0(e, "slide-down"),
    TO(e, "move-up"),
    TO(e, "move-down")
  ];
}, mse = (e) => {
  const {
    multipleSelectItemHeight: t,
    paddingXXS: r,
    lineWidth: n,
    INTERNAL_FIXED_ITEM_MARGIN: i
  } = e, o = e.max(e.calc(r).sub(n).equal(), 0), a = e.max(e.calc(o).sub(i).equal(), 0);
  return {
    basePadding: o,
    containerPadding: a,
    itemHeight: de(t),
    itemLineHeight: de(e.calc(t).sub(e.calc(e.lineWidth).mul(2)).equal())
  };
}, yse = (e) => {
  const {
    multipleSelectItemHeight: t,
    selectHeight: r,
    lineWidth: n
  } = e;
  return e.calc(r).sub(t).div(2).sub(n).equal();
}, Cse = (e) => {
  const {
    componentCls: t,
    iconCls: r,
    borderRadiusSM: n,
    motionDurationSlow: i,
    paddingXS: o,
    multipleItemColorDisabled: a,
    multipleItemBorderColorDisabled: s,
    colorIcon: l,
    colorIconHover: u,
    INTERNAL_FIXED_ITEM_MARGIN: c
  } = e;
  return {
    /**
     * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
     * may update to redesign with its align logic.
     */
    // =========================== Overflow ===========================
    [`${t}-selection-overflow`]: {
      position: "relative",
      display: "flex",
      flex: "auto",
      flexWrap: "wrap",
      maxWidth: "100%",
      "&-item": {
        flex: "none",
        alignSelf: "center",
        maxWidth: "100%",
        display: "inline-flex"
      },
      // ======================== Selections ==========================
      [`${t}-selection-item`]: {
        display: "flex",
        alignSelf: "center",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        marginBlock: c,
        borderRadius: n,
        cursor: "default",
        transition: `font-size ${i}, line-height ${i}, height ${i}`,
        marginInlineEnd: e.calc(c).mul(2).equal(),
        paddingInlineStart: o,
        paddingInlineEnd: e.calc(o).div(2).equal(),
        [`${t}-disabled&`]: {
          color: a,
          borderColor: s,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: e.calc(o).div(2).equal(),
          overflow: "hidden",
          whiteSpace: "pre",
          // fix whitespace wrapping. custom tags display all whitespace within.
          textOverflow: "ellipsis"
        },
        "&-remove": Object.assign(Object.assign({}, IP()), {
          display: "inline-flex",
          alignItems: "center",
          color: l,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${r}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: u
          }
        })
      }
    }
  };
}, Sse = (e, t) => {
  const {
    componentCls: r,
    INTERNAL_FIXED_ITEM_MARGIN: n
  } = e, i = `${r}-selection-overflow`, o = e.multipleSelectItemHeight, a = yse(e), s = t ? `${r}-${t}` : "", l = mse(e);
  return {
    [`${r}-multiple${s}`]: Object.assign(Object.assign({}, Cse(e)), {
      // ========================= Selector =========================
      [`${r}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        height: "100%",
        // Multiple is little different that horizontal is follow the vertical
        paddingInline: l.basePadding,
        paddingBlock: l.containerPadding,
        borderRadius: e.borderRadius,
        [`${r}-disabled&`]: {
          background: e.multipleSelectorBgDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${de(n)} 0`,
          lineHeight: de(o),
          visibility: "hidden",
          content: '"\\a0"'
        }
      },
      // ======================== Selections ========================
      [`${r}-selection-item`]: {
        height: l.itemHeight,
        lineHeight: de(l.itemLineHeight)
      },
      // ========================== Input ==========================
      [`${i}-item + ${i}-item`]: {
        [`${r}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      // https://github.com/ant-design/ant-design/issues/44754
      [`${i}-item-suffix`]: {
        height: "100%"
      },
      [`${r}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: e.calc(e.inputPaddingHorizontalBase).sub(a).equal(),
        "\n          &-input,\n          &-mirror\n        ": {
          height: o,
          fontFamily: e.fontFamily,
          lineHeight: de(o),
          transition: `all ${e.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          // fix whitespace wrapping caused width calculation bug
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${r}-selection-placeholder`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: e.inputPaddingHorizontalBase,
        insetInlineEnd: e.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${e.motionDurationSlow}`
      }
    })
  };
};
function vb(e, t) {
  const {
    componentCls: r
  } = e, n = t ? `${r}-${t}` : "", i = {
    [`${r}-multiple${n}`]: {
      fontSize: e.fontSize,
      // ========================= Selector =========================
      [`${r}-selector`]: {
        [`${r}-show-search&`]: {
          cursor: "text"
        }
      },
      [`
        &${r}-show-arrow ${r}-selector,
        &${r}-allow-clear ${r}-selector
      `]: {
        paddingInlineEnd: e.calc(e.fontSizeIcon).add(e.controlPaddingHorizontal).equal()
      }
    }
  };
  return [Sse(e, t), i];
}
const wse = (e) => {
  const {
    componentCls: t
  } = e, r = Br(e, {
    selectHeight: e.controlHeightSM,
    multipleSelectItemHeight: e.multipleItemHeightSM,
    borderRadius: e.borderRadiusSM,
    borderRadiusSM: e.borderRadiusXS
  }), n = Br(e, {
    fontSize: e.fontSizeLG,
    selectHeight: e.controlHeightLG,
    multipleSelectItemHeight: e.multipleItemHeightLG,
    borderRadius: e.borderRadiusLG,
    borderRadiusSM: e.borderRadius
  });
  return [
    vb(e),
    // ======================== Small ========================
    vb(r, "sm"),
    // Padding
    {
      [`${t}-multiple${t}-sm`]: {
        [`${t}-selection-placeholder`]: {
          insetInline: e.calc(e.controlPaddingHorizontalSM).sub(e.lineWidth).equal()
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${t}-selection-search`]: {
          marginInlineStart: 2
          // Magic Number
        }
      }
    },
    // ======================== Large ========================
    vb(n, "lg")
  ];
};
function mb(e, t) {
  const {
    componentCls: r,
    inputPaddingHorizontalBase: n,
    borderRadius: i
  } = e, o = e.calc(e.controlHeight).sub(e.calc(e.lineWidth).mul(2)).equal(), a = t ? `${r}-${t}` : "";
  return {
    [`${r}-single${a}`]: {
      fontSize: e.fontSize,
      height: e.controlHeight,
      // ========================= Selector =========================
      [`${r}-selector`]: Object.assign(Object.assign({}, Fi(e, !0)), {
        display: "flex",
        borderRadius: i,
        [`${r}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: n,
          insetInlineEnd: n,
          bottom: 0,
          "&-input": {
            width: "100%",
            WebkitAppearance: "textfield"
          }
        },
        [`
          ${r}-selection-item,
          ${r}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: de(o),
          transition: `all ${e.motionDurationSlow}, visibility 0s`,
          alignSelf: "center"
        },
        [`${r}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${r}-selection-item:empty:after`,
          /* For undefined value baseline align */
          `${r}-selection-placeholder:empty:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${r}-show-arrow ${r}-selection-item,
        &${r}-show-arrow ${r}-selection-placeholder
      `]: {
        paddingInlineEnd: e.showArrowPaddingInlineEnd
      },
      // Opacity selection if open
      [`&${r}-open ${r}-selection-item`]: {
        color: e.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${r}-customize-input)`]: {
        [`${r}-selector`]: {
          width: "100%",
          height: "100%",
          padding: `0 ${de(n)}`,
          [`${r}-selection-search-input`]: {
            height: o
          },
          "&:after": {
            lineHeight: de(o)
          }
        }
      },
      [`&${r}-customize-input`]: {
        [`${r}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${r}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${r}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${de(n)}`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
function bse(e) {
  const {
    componentCls: t
  } = e, r = e.calc(e.controlPaddingHorizontalSM).sub(e.lineWidth).equal();
  return [
    mb(e),
    // ======================== Small ========================
    // Shared
    mb(Br(e, {
      controlHeight: e.controlHeightSM,
      borderRadius: e.borderRadiusSM
    }), "sm"),
    // padding
    {
      [`${t}-single${t}-sm`]: {
        [`&:not(${t}-customize-input)`]: {
          [`${t}-selection-search`]: {
            insetInlineStart: r,
            insetInlineEnd: r
          },
          [`${t}-selector`]: {
            padding: `0 ${de(r)}`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${t}-show-arrow ${t}-selection-search`]: {
            insetInlineEnd: e.calc(r).add(e.calc(e.fontSize).mul(1.5)).equal()
          },
          [`
            &${t}-show-arrow ${t}-selection-item,
            &${t}-show-arrow ${t}-selection-placeholder
          `]: {
            paddingInlineEnd: e.calc(e.fontSize).mul(1.5).equal()
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    mb(Br(e, {
      controlHeight: e.singleItemHeightLG,
      fontSize: e.fontSizeLG,
      borderRadius: e.borderRadiusLG
    }), "lg")
  ];
}
const xse = (e) => {
  const {
    fontSize: t,
    lineHeight: r,
    lineWidth: n,
    controlHeight: i,
    controlHeightSM: o,
    controlHeightLG: a,
    paddingXXS: s,
    controlPaddingHorizontal: l,
    zIndexPopupBase: u,
    colorText: c,
    fontWeightStrong: d,
    controlItemBgActive: h,
    controlItemBgHover: f,
    colorBgContainer: p,
    colorFillSecondary: g,
    colorBgContainerDisabled: v,
    colorTextDisabled: m
  } = e, y = s * 2, C = n * 2, S = Math.min(i - y, i - C), b = Math.min(o - y, o - C), w = Math.min(a - y, a - C);
  return {
    INTERNAL_FIXED_ITEM_MARGIN: Math.floor(s / 2),
    zIndexPopup: u + 50,
    optionSelectedColor: c,
    optionSelectedFontWeight: d,
    optionSelectedBg: h,
    optionActiveBg: f,
    optionPadding: `${(i - t * r) / 2}px ${l}px`,
    optionFontSize: t,
    optionLineHeight: r,
    optionHeight: i,
    selectorBg: p,
    clearBg: p,
    singleItemHeightLG: a,
    multipleItemBg: g,
    multipleItemBorderColor: "transparent",
    multipleItemHeight: S,
    multipleItemHeightSM: b,
    multipleItemHeightLG: w,
    multipleSelectorBgDisabled: v,
    multipleItemColorDisabled: m,
    multipleItemBorderColorDisabled: "transparent",
    showArrowPaddingInlineEnd: Math.ceil(e.fontSize * 1.25)
  };
}, s8 = (e, t) => {
  const {
    componentCls: r,
    antCls: n,
    controlOutlineWidth: i
  } = e;
  return {
    [`&:not(${r}-customize-input) ${r}-selector`]: {
      border: `${de(e.lineWidth)} ${e.lineType} ${t.borderColor}`,
      background: e.selectorBg
    },
    [`&:not(${r}-disabled):not(${r}-customize-input):not(${n}-pagination-size-changer)`]: {
      [`&:hover ${r}-selector`]: {
        borderColor: t.hoverBorderHover
      },
      [`${r}-focused& ${r}-selector`]: {
        borderColor: t.activeBorderColor,
        boxShadow: `0 0 0 ${de(i)} ${t.activeShadowColor}`,
        outline: 0
      }
    }
  };
}, XO = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}`]: Object.assign({}, s8(e, t))
}), Ese = (e) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign({}, s8(e, {
    borderColor: e.colorBorder,
    hoverBorderHover: e.colorPrimaryHover,
    activeBorderColor: e.colorPrimary,
    activeShadowColor: e.controlOutline
  })), XO(e, {
    status: "error",
    borderColor: e.colorError,
    hoverBorderHover: e.colorErrorHover,
    activeBorderColor: e.colorError,
    activeShadowColor: e.colorErrorOutline
  })), XO(e, {
    status: "warning",
    borderColor: e.colorWarning,
    hoverBorderHover: e.colorWarningHover,
    activeBorderColor: e.colorWarning,
    activeShadowColor: e.colorWarningOutline
  })), {
    [`&${e.componentCls}-disabled`]: {
      [`&:not(${e.componentCls}-customize-input) ${e.componentCls}-selector`]: {
        background: e.colorBgContainerDisabled,
        color: e.colorTextDisabled
      }
    },
    [`&${e.componentCls}-multiple ${e.componentCls}-selection-item`]: {
      background: e.multipleItemBg,
      border: `${de(e.lineWidth)} ${e.lineType} ${e.multipleItemBorderColor}`
    }
  })
}), l8 = (e, t) => {
  const {
    componentCls: r,
    antCls: n
  } = e;
  return {
    [`&:not(${r}-customize-input) ${r}-selector`]: {
      background: t.bg,
      border: `${de(e.lineWidth)} ${e.lineType} transparent`,
      color: t.color
    },
    [`&:not(${r}-disabled):not(${r}-customize-input):not(${n}-pagination-size-changer)`]: {
      [`&:hover ${r}-selector`]: {
        background: t.hoverBg
      },
      [`${r}-focused& ${r}-selector`]: {
        background: e.selectorBg,
        borderColor: t.activeBorderColor,
        outline: 0
      }
    }
  };
}, ZO = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}`]: Object.assign({}, l8(e, t))
}), Rse = (e) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign({}, l8(e, {
    bg: e.colorFillTertiary,
    hoverBg: e.colorFillSecondary,
    activeBorderColor: e.colorPrimary,
    color: e.colorText
  })), ZO(e, {
    status: "error",
    bg: e.colorErrorBg,
    hoverBg: e.colorErrorBgHover,
    activeBorderColor: e.colorError,
    color: e.colorError
  })), ZO(e, {
    status: "warning",
    bg: e.colorWarningBg,
    hoverBg: e.colorWarningBgHover,
    activeBorderColor: e.colorWarning,
    color: e.colorWarning
  })), {
    [`&${e.componentCls}-disabled`]: {
      [`&:not(${e.componentCls}-customize-input) ${e.componentCls}-selector`]: {
        borderColor: e.colorBorder,
        background: e.colorBgContainerDisabled,
        color: e.colorTextDisabled
      }
    },
    [`&${e.componentCls}-multiple ${e.componentCls}-selection-item`]: {
      background: e.colorBgContainer,
      border: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`
    }
  })
}), _se = (e) => ({
  "&-borderless": {
    [`${e.componentCls}-selector`]: {
      background: "transparent",
      borderColor: "transparent"
    },
    [`&${e.componentCls}-disabled`]: {
      [`&:not(${e.componentCls}-customize-input) ${e.componentCls}-selector`]: {
        color: e.colorTextDisabled
      }
    },
    [`&${e.componentCls}-multiple ${e.componentCls}-selection-item`]: {
      background: e.multipleItemBg,
      border: `${de(e.lineWidth)} ${e.lineType} ${e.multipleItemBorderColor}`
    },
    // Status
    [`&${e.componentCls}-status-error`]: {
      [`${e.componentCls}-selection-item`]: {
        color: e.colorError
      }
    },
    [`&${e.componentCls}-status-warning`]: {
      [`${e.componentCls}-selection-item`]: {
        color: e.colorWarning
      }
    }
  }
}), Tse = (e) => ({
  [e.componentCls]: Object.assign(Object.assign(Object.assign({}, Ese(e)), Rse(e)), _se(e))
}), Pse = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    position: "relative",
    transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${t}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit",
        height: "100%"
      }
    },
    [`${t}-disabled&`]: {
      cursor: "not-allowed",
      input: {
        cursor: "not-allowed"
      }
    }
  };
}, Mse = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      fontFamily: "inherit",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
}, Dse = (e) => {
  const {
    antCls: t,
    componentCls: r,
    inputPaddingHorizontalBase: n,
    iconCls: i
  } = e;
  return {
    [r]: Object.assign(Object.assign({}, Fi(e)), {
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${r}-customize-input) ${r}-selector`]: Object.assign(Object.assign({}, Pse(e)), Mse(e)),
      // ======================== Selection ========================
      [`${r}-selection-item`]: Object.assign(Object.assign({
        flex: 1,
        fontWeight: "normal",
        position: "relative",
        userSelect: "none"
      }, Xl), {
        // https://github.com/ant-design/ant-design/issues/40421
        [`> ${t}-typography`]: {
          display: "inline"
        }
      }),
      // ======================= Placeholder =======================
      [`${r}-selection-placeholder`]: Object.assign(Object.assign({}, Xl), {
        flex: 1,
        color: e.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      // ========================== Arrow ==========================
      [`${r}-arrow`]: Object.assign(Object.assign({}, IP()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        height: e.fontSizeIcon,
        marginTop: e.calc(e.fontSizeIcon).mul(-1).div(2).equal(),
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        transition: `opacity ${e.motionDurationSlow} ease`,
        [i]: {
          verticalAlign: "top",
          transition: `transform ${e.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${r}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${r}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      }),
      // ========================== Clear ==========================
      [`${r}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        zIndex: 1,
        display: "inline-block",
        width: e.fontSizeIcon,
        height: e.fontSizeIcon,
        marginTop: e.calc(e.fontSizeIcon).mul(-1).div(2).equal(),
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        cursor: "pointer",
        opacity: 0,
        transition: `color ${e.motionDurationMid} ease, opacity ${e.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: e.colorTextTertiary
        }
      },
      "&:hover": {
        [`${r}-clear`]: {
          opacity: 1
        },
        // Should use the following selector, but since `:has` has poor compatibility,
        // we use `:not(:last-child)` instead, which may cause some problems in some cases.
        // [`${componentCls}-arrow:has(+ ${componentCls}-clear)`]: {
        [`${r}-arrow:not(:last-child)`]: {
          opacity: 0
        }
      }
    }),
    // ========================= Feedback ==========================
    [`${r}-has-feedback`]: {
      [`${r}-clear`]: {
        insetInlineEnd: e.calc(n).add(e.fontSize).add(e.paddingXS).equal()
      }
    }
  };
}, Ase = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    {
      [t]: {
        // ==================== In Form ====================
        [`&${t}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    Dse(e),
    // Single
    bse(e),
    // Multiple
    wse(e),
    // Dropdown
    vse(e),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${t}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    GP(e, {
      borderElCls: `${t}-selector`,
      focusElCls: `${t}-focused`
    })
  ];
}, Ise = Gn("Select", (e, t) => {
  let {
    rootPrefixCls: r
  } = t;
  const n = Br(e, {
    rootPrefixCls: r,
    inputPaddingHorizontalBase: e.calc(e.paddingSM).sub(1).equal(),
    multipleSelectItemHeight: e.multipleItemHeight,
    selectHeight: e.controlHeight
  });
  return [Ase(n), Tse(n)];
}, xse, {
  unitless: {
    optionLineHeight: !0,
    optionSelectedFontWeight: !0
  }
});
var Ose = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" }, Lse = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: Ose
  }));
}, TS = /* @__PURE__ */ E.forwardRef(Lse);
process.env.NODE_ENV !== "production" && (TS.displayName = "CheckOutlined");
var Fse = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, name: "down", theme: "outlined" }, Nse = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: Fse
  }));
}, u8 = /* @__PURE__ */ E.forwardRef(Nse);
process.env.NODE_ENV !== "production" && (u8.displayName = "DownOutlined");
var kse = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" }, Vse = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: kse
  }));
}, JP = /* @__PURE__ */ E.forwardRef(Vse);
process.env.NODE_ENV !== "production" && (JP.displayName = "SearchOutlined");
function Bse(e) {
  let {
    suffixIcon: t,
    clearIcon: r,
    menuItemSelectedIcon: n,
    removeIcon: i,
    loading: o,
    multiple: a,
    hasFeedback: s,
    prefixCls: l,
    showSuffixIcon: u,
    feedbackIcon: c,
    showArrow: d,
    componentName: h
  } = e;
  process.env.NODE_ENV !== "production" && en(h).deprecated(!r, "clearIcon", "allowClear={{ clearIcon: React.ReactNode }}");
  const f = r ?? /* @__PURE__ */ E.createElement(gS, null), p = (y) => t === null && !s && !d ? null : /* @__PURE__ */ E.createElement(E.Fragment, null, u !== !1 && y, s && c);
  let g = null;
  if (t !== void 0)
    g = p(t);
  else if (o)
    g = p(/* @__PURE__ */ E.createElement(vS, {
      spin: !0
    }));
  else {
    const y = `${l}-suffix`;
    g = (C) => {
      let {
        open: S,
        showSearch: b
      } = C;
      return p(S && b ? /* @__PURE__ */ E.createElement(JP, {
        className: y
      }) : /* @__PURE__ */ E.createElement(u8, {
        className: y
      }));
    };
  }
  let v = null;
  n !== void 0 ? v = n : a ? v = /* @__PURE__ */ E.createElement(TS, null) : v = null;
  let m = null;
  return i !== void 0 ? m = i : m = /* @__PURE__ */ E.createElement(uf, null), {
    clearIcon: f,
    suffixIcon: g,
    itemIcon: v,
    removeIcon: m
  };
}
function $se(e, t) {
  return t !== void 0 ? t : e !== null;
}
var Hse = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const c8 = "SECRET_COMBOBOX_MODE_DO_NOT_USE", d8 = (e, t) => {
  var r;
  const {
    prefixCls: n,
    bordered: i,
    className: o,
    rootClassName: a,
    getPopupContainer: s,
    popupClassName: l,
    dropdownClassName: u,
    listHeight: c = 256,
    placement: d,
    listItemHeight: h,
    size: f,
    disabled: p,
    notFoundContent: g,
    status: v,
    builtinPlacements: m,
    dropdownMatchSelectWidth: y,
    popupMatchSelectWidth: C,
    direction: S,
    style: b,
    allowClear: w,
    variant: x,
    dropdownStyle: R,
    transitionName: _,
    tagRender: T,
    maxCount: P
  } = e, D = Hse(e, ["prefixCls", "bordered", "className", "rootClassName", "getPopupContainer", "popupClassName", "dropdownClassName", "listHeight", "placement", "listItemHeight", "size", "disabled", "notFoundContent", "status", "builtinPlacements", "dropdownMatchSelectWidth", "popupMatchSelectWidth", "direction", "style", "allowClear", "variant", "dropdownStyle", "transitionName", "tagRender", "maxCount"]), {
    getPopupContainer: O,
    getPrefixCls: A,
    renderEmpty: F,
    direction: L,
    virtual: N,
    popupMatchSelectWidth: I,
    popupOverflow: B,
    select: M
  } = E.useContext(Yt), [, V] = Qi(), G = h ?? (V == null ? void 0 : V.controlHeight), k = A("select", n), z = A(), j = S ?? L, {
    compactSize: q,
    compactItemClassnames: K
  } = CS(k, j), [Z, re] = QP("select", x, i), X = ed(k), [Y, U, oe] = Ise(k, X), W = E.useMemo(() => {
    const {
      mode: Xe
    } = e;
    if (Xe !== "combobox")
      return Xe === c8 ? "combobox" : Xe;
  }, [e.mode]), ne = W === "multiple" || W === "tags", ce = $se(e.suffixIcon, e.showArrow), we = (r = C ?? y) !== null && r !== void 0 ? r : I, {
    status: Re,
    hasFeedback: ve,
    isFormItemInput: xe,
    feedbackIcon: _e
  } = E.useContext(ps), Ve = _S(Re, v);
  let Fe;
  g !== void 0 ? Fe = g : W === "combobox" ? Fe = null : Fe = (F == null ? void 0 : F("Select")) || /* @__PURE__ */ E.createElement(fse, {
    componentName: "Select"
  });
  const {
    suffixIcon: Ne,
    itemIcon: Je,
    removeIcon: J,
    clearIcon: he
  } = Bse(Object.assign(Object.assign({}, D), {
    multiple: ne,
    hasFeedback: ve,
    feedbackIcon: _e,
    showSuffixIcon: ce,
    prefixCls: k,
    componentName: "Select"
  })), Le = w === !0 ? {
    clearIcon: he
  } : w, Pe = ni(D, ["suffixIcon", "itemIcon"]), Ie = ue(l || u, {
    [`${k}-dropdown-${j}`]: j === "rtl"
  }, a, oe, X, U), Ce = sl((Xe) => {
    var Oe;
    return (Oe = f ?? q) !== null && Oe !== void 0 ? Oe : Xe;
  }), De = E.useContext($c), ze = p ?? De, st = ue({
    [`${k}-lg`]: Ce === "large",
    [`${k}-sm`]: Ce === "small",
    [`${k}-rtl`]: j === "rtl",
    [`${k}-${Z}`]: re,
    [`${k}-in-form-item`]: xe
  }, B0(k, Ve, ve), K, M == null ? void 0 : M.className, o, a, oe, X, U), Tt = E.useMemo(() => d !== void 0 ? d : j === "rtl" ? "bottomRight" : "bottomLeft", [d, j]);
  if (process.env.NODE_ENV !== "production") {
    const Xe = en("Select");
    Xe.deprecated(!u, "dropdownClassName", "popupClassName"), Xe.deprecated(y === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), process.env.NODE_ENV !== "production" && Xe(!("showArrow" in e), "deprecated", "`showArrow` is deprecated which will be removed in next major version. It will be a default behavior, you can hide it by setting `suffixIcon` to null."), Xe.deprecated(!("bordered" in e), "bordered", "variant"), process.env.NODE_ENV !== "production" && Xe(!(typeof P < "u" && !ne), "usage", "`maxCount` only works with mode `multiple` or `tags`");
  }
  const [ot] = mS("SelectLike", R == null ? void 0 : R.zIndex);
  return Y(/* @__PURE__ */ E.createElement(ZP, Object.assign({
    ref: t,
    virtual: N,
    showSearch: M == null ? void 0 : M.showSearch
  }, Pe, {
    style: Object.assign(Object.assign({}, M == null ? void 0 : M.style), b),
    dropdownMatchSelectWidth: we,
    transitionName: Ql(z, "slide-up", _),
    builtinPlacements: gse(m, B),
    listHeight: c,
    listItemHeight: G,
    mode: W,
    prefixCls: k,
    placement: Tt,
    direction: j,
    suffixIcon: Ne,
    menuItemSelectedIcon: Je,
    removeIcon: J,
    allowClear: Le,
    notFoundContent: Fe,
    className: st,
    getPopupContainer: s || O,
    dropdownClassName: Ie,
    disabled: ze,
    dropdownStyle: Object.assign(Object.assign({}, R), {
      zIndex: ot
    }),
    maxCount: ne ? P : void 0,
    tagRender: ne ? T : void 0
  })));
};
process.env.NODE_ENV !== "production" && (d8.displayName = "Select");
const Jl = /* @__PURE__ */ E.forwardRef(d8), Gse = Hoe(Jl);
Jl.SECRET_COMBOBOX_MODE_DO_NOT_USE = c8;
Jl.Option = qP;
Jl.OptGroup = YP;
Jl._InternalPanelDoNotUseOrYouWillBeFired = Gse;
process.env.NODE_ENV !== "production" && (Jl.displayName = "Select");
const kR = ["xxl", "xl", "lg", "md", "sm", "xs"], zse = (e) => ({
  xs: `(max-width: ${e.screenXSMax}px)`,
  sm: `(min-width: ${e.screenSM}px)`,
  md: `(min-width: ${e.screenMD}px)`,
  lg: `(min-width: ${e.screenLG}px)`,
  xl: `(min-width: ${e.screenXL}px)`,
  xxl: `(min-width: ${e.screenXXL}px)`
}), Wse = (e) => {
  const t = e, r = [].concat(kR).reverse();
  return r.forEach((n, i) => {
    const o = n.toUpperCase(), a = `screen${o}Min`, s = `screen${o}`;
    if (!(t[a] <= t[s]))
      throw new Error(`${a}<=${s} fails : !(${t[a]}<=${t[s]})`);
    if (i < r.length - 1) {
      const l = `screen${o}Max`;
      if (!(t[s] <= t[l]))
        throw new Error(`${s}<=${l} fails : !(${t[s]}<=${t[l]})`);
      const c = `screen${r[i + 1].toUpperCase()}Min`;
      if (!(t[l] <= t[c]))
        throw new Error(`${l}<=${c} fails : !(${t[l]}<=${t[c]})`);
    }
  }), e;
};
function jse() {
  const [, e] = Qi(), t = zse(Wse(e));
  return H.useMemo(() => {
    const r = /* @__PURE__ */ new Map();
    let n = -1, i = {};
    return {
      matchHandlers: {},
      dispatch(o) {
        return i = o, r.forEach((a) => a(i)), r.size >= 1;
      },
      subscribe(o) {
        return r.size || this.register(), n += 1, r.set(n, o), o(i), n;
      },
      unsubscribe(o) {
        r.delete(o), r.size || this.unregister();
      },
      unregister() {
        Object.keys(t).forEach((o) => {
          const a = t[o], s = this.matchHandlers[a];
          s == null || s.mql.removeListener(s == null ? void 0 : s.listener);
        }), r.clear();
      },
      register() {
        Object.keys(t).forEach((o) => {
          const a = t[o], s = (u) => {
            let {
              matches: c
            } = u;
            this.dispatch(Object.assign(Object.assign({}, i), {
              [o]: c
            }));
          }, l = window.matchMedia(a);
          l.addListener(s), this.matchHandlers[a] = {
            mql: l,
            listener: s
          }, s(l);
        });
      },
      responsiveMap: t
    };
  }, [e]);
}
const h8 = (e, t) => {
  if (t && typeof t == "object")
    for (let r = 0; r < kR.length; r++) {
      const n = kR[r];
      if (e[n] && t[n] !== void 0)
        return t[n];
    }
};
function Use() {
  const [, e] = E.useReducer((t) => t + 1, 0);
  return e;
}
function Kse() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
  const t = se({}), r = Use(), n = jse();
  return kr(() => {
    const i = n.subscribe((o) => {
      t.current = o, e && r();
    });
    return () => n.unsubscribe(i);
  }, []), t.current;
}
const Gh = (e) => e ? typeof e == "function" ? e() : e : null;
function eM(e) {
  var t = e.children, r = e.prefixCls, n = e.id, i = e.overlayInnerStyle, o = e.className, a = e.style;
  return /* @__PURE__ */ E.createElement("div", {
    className: ue("".concat(r, "-content"), o),
    style: a
  }, /* @__PURE__ */ E.createElement("div", {
    className: "".concat(r, "-inner"),
    id: n,
    role: "tooltip",
    style: i
  }, typeof t == "function" ? t() : t));
}
var Ed = {
  shiftX: 64,
  adjustY: 1
}, Rd = {
  adjustX: 1,
  shiftY: !0
}, To = [0, 0], Yse = {
  left: {
    points: ["cr", "cl"],
    overflow: Rd,
    offset: [-4, 0],
    targetOffset: To
  },
  right: {
    points: ["cl", "cr"],
    overflow: Rd,
    offset: [4, 0],
    targetOffset: To
  },
  top: {
    points: ["bc", "tc"],
    overflow: Ed,
    offset: [0, -4],
    targetOffset: To
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: Ed,
    offset: [0, 4],
    targetOffset: To
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: Ed,
    offset: [0, -4],
    targetOffset: To
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: Rd,
    offset: [-4, 0],
    targetOffset: To
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Ed,
    offset: [0, -4],
    targetOffset: To
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: Rd,
    offset: [4, 0],
    targetOffset: To
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Ed,
    offset: [0, 4],
    targetOffset: To
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: Rd,
    offset: [4, 0],
    targetOffset: To
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Ed,
    offset: [0, 4],
    targetOffset: To
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: Rd,
    offset: [-4, 0],
    targetOffset: To
  }
}, qse = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"], Xse = function(t, r) {
  var n = t.overlayClassName, i = t.trigger, o = i === void 0 ? ["hover"] : i, a = t.mouseEnterDelay, s = a === void 0 ? 0 : a, l = t.mouseLeaveDelay, u = l === void 0 ? 0.1 : l, c = t.overlayStyle, d = t.prefixCls, h = d === void 0 ? "rc-tooltip" : d, f = t.children, p = t.onVisibleChange, g = t.afterVisibleChange, v = t.transitionName, m = t.animation, y = t.motion, C = t.placement, S = C === void 0 ? "right" : C, b = t.align, w = b === void 0 ? {} : b, x = t.destroyTooltipOnHide, R = x === void 0 ? !1 : x, _ = t.defaultVisible, T = t.getTooltipContainer, P = t.overlayInnerStyle;
  t.arrowContent;
  var D = t.overlay, O = t.id, A = t.showArrow, F = A === void 0 ? !0 : A, L = $t(t, qse), N = se(null);
  Zc(r, function() {
    return N.current;
  });
  var I = ee({}, L);
  "visible" in t && (I.popupVisible = t.visible);
  var B = function() {
    return /* @__PURE__ */ E.createElement(eM, {
      key: "content",
      prefixCls: h,
      id: O,
      overlayInnerStyle: P
    }, D);
  };
  return /* @__PURE__ */ E.createElement(RS, $e({
    popupClassName: n,
    prefixCls: h,
    popup: B,
    action: o,
    builtinPlacements: Yse,
    popupPlacement: S,
    ref: N,
    popupAlign: w,
    getPopupContainer: T,
    onPopupVisibleChange: p,
    afterPopupVisibleChange: g,
    popupTransitionName: v,
    popupAnimation: m,
    popupMotion: y,
    defaultPopupVisible: _,
    autoDestroy: R,
    mouseLeaveDelay: u,
    popupStyle: c,
    mouseEnterDelay: s,
    arrow: F
  }, I), f);
};
const Zse = /* @__PURE__ */ yn(Xse);
function f8(e) {
  const {
    sizePopupArrow: t,
    borderRadiusXS: r,
    borderRadiusOuter: n
  } = e, i = t / 2, o = 0, a = i, s = n * 1 / Math.sqrt(2), l = i - n * (1 - 1 / Math.sqrt(2)), u = i - r * (1 / Math.sqrt(2)), c = n * (Math.sqrt(2) - 1) + r * (1 / Math.sqrt(2)), d = 2 * i - u, h = c, f = 2 * i - s, p = l, g = 2 * i - o, v = a, m = i * Math.sqrt(2) + n * (Math.sqrt(2) - 2), y = n * (Math.sqrt(2) - 1), C = `polygon(${y}px 100%, 50% ${y}px, ${2 * i - y}px 100%, ${y}px 100%)`, S = `path('M ${o} ${a} A ${n} ${n} 0 0 0 ${s} ${l} L ${u} ${c} A ${r} ${r} 0 0 1 ${d} ${h} L ${f} ${p} A ${n} ${n} 0 0 0 ${g} ${v} Z')`;
  return {
    arrowShadowWidth: m,
    arrowPath: S,
    arrowPolygon: C
  };
}
const Qse = (e, t, r) => {
  const {
    sizePopupArrow: n,
    arrowPolygon: i,
    arrowPath: o,
    arrowShadowWidth: a,
    borderRadiusXS: s,
    calc: l
  } = e;
  return {
    pointerEvents: "none",
    width: n,
    height: n,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: n,
      height: l(n).div(2).equal(),
      background: t,
      clipPath: {
        _multi_value_: !0,
        value: [i, o]
      },
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: a,
      height: a,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: !0,
        value: `0 0 ${de(s)} 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow: r,
      zIndex: 0,
      background: "transparent"
    }
  };
}, p8 = 8;
function tM(e) {
  const {
    contentRadius: t,
    limitVerticalRadius: r
  } = e, n = t > 12 ? t + 2 : 12;
  return {
    arrowOffsetHorizontal: n,
    arrowOffsetVertical: r ? p8 : n
  };
}
function Sm(e, t) {
  return e ? t : {};
}
function g8(e, t, r) {
  const {
    componentCls: n,
    boxShadowPopoverArrow: i,
    arrowOffsetVertical: o,
    arrowOffsetHorizontal: a
  } = e, {
    arrowDistance: s = 0,
    arrowPlacement: l = {
      left: !0,
      right: !0,
      top: !0,
      bottom: !0
    }
  } = {};
  return {
    [n]: Object.assign(Object.assign(Object.assign(Object.assign({
      // ============================ Basic ============================
      [`${n}-arrow`]: [Object.assign(Object.assign({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, Qse(e, t, i)), {
        "&:before": {
          background: t
        }
      })]
    }, Sm(!!l.top, {
      [[`&-placement-top > ${n}-arrow`, `&-placement-topLeft > ${n}-arrow`, `&-placement-topRight > ${n}-arrow`].join(",")]: {
        bottom: s,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top > ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft > ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: a
        }
      },
      [`&-placement-topRight > ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: a
        }
      }
    })), Sm(!!l.bottom, {
      [[`&-placement-bottom > ${n}-arrow`, `&-placement-bottomLeft > ${n}-arrow`, `&-placement-bottomRight > ${n}-arrow`].join(",")]: {
        top: s,
        transform: "translateY(-100%)"
      },
      [`&-placement-bottom > ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(-100%)"
      },
      [`&-placement-bottomLeft > ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: a
        }
      },
      [`&-placement-bottomRight > ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: a
        }
      }
    })), Sm(!!l.left, {
      [[`&-placement-left > ${n}-arrow`, `&-placement-leftTop > ${n}-arrow`, `&-placement-leftBottom > ${n}-arrow`].join(",")]: {
        right: {
          _skip_check_: !0,
          value: s
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left > ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop > ${n}-arrow`]: {
        top: o
      },
      [`&-placement-leftBottom > ${n}-arrow`]: {
        bottom: o
      }
    })), Sm(!!l.right, {
      [[`&-placement-right > ${n}-arrow`, `&-placement-rightTop > ${n}-arrow`, `&-placement-rightBottom > ${n}-arrow`].join(",")]: {
        left: {
          _skip_check_: !0,
          value: s
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right > ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop > ${n}-arrow`]: {
        top: o
      },
      [`&-placement-rightBottom > ${n}-arrow`]: {
        bottom: o
      }
    }))
  };
}
function Jse(e, t, r, n) {
  if (n === !1)
    return {
      adjustX: !1,
      adjustY: !1
    };
  const i = n && typeof n == "object" ? n : {}, o = {};
  switch (e) {
    case "top":
    case "bottom":
      o.shiftX = t.arrowOffsetHorizontal * 2 + r, o.shiftY = !0, o.adjustY = !0;
      break;
    case "left":
    case "right":
      o.shiftY = t.arrowOffsetVertical * 2 + r, o.shiftX = !0, o.adjustX = !0;
      break;
  }
  const a = Object.assign(Object.assign({}, o), i);
  return a.shiftX || (a.adjustX = !0), a.shiftY || (a.adjustY = !0), a;
}
const QO = {
  left: {
    points: ["cr", "cl"]
  },
  right: {
    points: ["cl", "cr"]
  },
  top: {
    points: ["bc", "tc"]
  },
  bottom: {
    points: ["tc", "bc"]
  },
  topLeft: {
    points: ["bl", "tl"]
  },
  leftTop: {
    points: ["tr", "tl"]
  },
  topRight: {
    points: ["br", "tr"]
  },
  rightTop: {
    points: ["tl", "tr"]
  },
  bottomRight: {
    points: ["tr", "br"]
  },
  rightBottom: {
    points: ["bl", "br"]
  },
  bottomLeft: {
    points: ["tl", "bl"]
  },
  leftBottom: {
    points: ["br", "bl"]
  }
}, ele = {
  topLeft: {
    points: ["bl", "tc"]
  },
  leftTop: {
    points: ["tr", "cl"]
  },
  topRight: {
    points: ["br", "tc"]
  },
  rightTop: {
    points: ["tl", "cr"]
  },
  bottomRight: {
    points: ["tr", "bc"]
  },
  rightBottom: {
    points: ["bl", "cr"]
  },
  bottomLeft: {
    points: ["tl", "bc"]
  },
  leftBottom: {
    points: ["br", "cl"]
  }
}, tle = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function rle(e) {
  const {
    arrowWidth: t,
    autoAdjustOverflow: r,
    arrowPointAtCenter: n,
    offset: i,
    borderRadius: o,
    visibleFirst: a
  } = e, s = t / 2, l = {};
  return Object.keys(QO).forEach((u) => {
    const c = n && ele[u] || QO[u], d = Object.assign(Object.assign({}, c), {
      offset: [0, 0],
      dynamicInset: !0
    });
    switch (l[u] = d, tle.has(u) && (d.autoArrow = !1), u) {
      case "top":
      case "topLeft":
      case "topRight":
        d.offset[1] = -s - i;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        d.offset[1] = s + i;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        d.offset[0] = -s - i;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        d.offset[0] = s + i;
        break;
    }
    const h = tM({
      contentRadius: o,
      limitVerticalRadius: !0
    });
    if (n)
      switch (u) {
        case "topLeft":
        case "bottomLeft":
          d.offset[0] = -h.arrowOffsetHorizontal - s;
          break;
        case "topRight":
        case "bottomRight":
          d.offset[0] = h.arrowOffsetHorizontal + s;
          break;
        case "leftTop":
        case "rightTop":
          d.offset[1] = -h.arrowOffsetHorizontal - s;
          break;
        case "leftBottom":
        case "rightBottom":
          d.offset[1] = h.arrowOffsetHorizontal + s;
          break;
      }
    d.overflow = Jse(u, h, t, r), a && (d.htmlRegion = "visibleFirst");
  }), l;
}
const nle = (e) => {
  const {
    componentCls: t,
    // ant-tooltip
    tooltipMaxWidth: r,
    tooltipColor: n,
    tooltipBg: i,
    tooltipBorderRadius: o,
    zIndexPopup: a,
    controlHeight: s,
    boxShadowSecondary: l,
    paddingSM: u,
    paddingXS: c
  } = e;
  return [
    {
      [t]: Object.assign(Object.assign(Object.assign(Object.assign({}, Fi(e)), {
        position: "absolute",
        zIndex: a,
        display: "block",
        width: "max-content",
        maxWidth: r,
        visibility: "visible",
        transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": i,
        // Wrapper for the tooltip content
        [`${t}-inner`]: {
          minWidth: "1em",
          minHeight: s,
          padding: `${de(e.calc(u).div(2).equal())} ${de(c)}`,
          color: n,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: i,
          borderRadius: o,
          boxShadow: l,
          boxSizing: "border-box"
        },
        // Limit left and right placement radius
        [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
          [`${t}-inner`]: {
            borderRadius: e.min(o, p8)
          }
        },
        [`${t}-content`]: {
          position: "relative"
        }
      }), Hz(e, (d, h) => {
        let {
          darkColor: f
        } = h;
        return {
          [`&${t}-${d}`]: {
            [`${t}-inner`]: {
              backgroundColor: f
            },
            [`${t}-arrow`]: {
              "--antd-arrow-background-color": f
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    g8(e, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: e.sizePopupArrow
      }
    }
  ];
}, ile = (e) => Object.assign(Object.assign({
  zIndexPopup: e.zIndexPopupBase + 70
}, tM({
  contentRadius: e.borderRadius,
  limitVerticalRadius: !0
})), f8(Br(e, {
  borderRadiusOuter: Math.min(e.borderRadiusOuter, 4)
}))), v8 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return Gn("Tooltip", (n) => {
    const {
      borderRadius: i,
      colorTextLightSolid: o,
      colorBgSpotlight: a
    } = n, s = Br(n, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: o,
      tooltipBorderRadius: i,
      tooltipBg: a
    });
    return [nle(s), xS(n, "zoom-big-fast")];
  }, ile, {
    resetStyle: !1,
    // Popover use Tooltip as internal component. We do not need to handle this.
    injectStyle: t
  })(e);
}, ole = Ag.map((e) => `${e}-inverse`), ale = ["success", "processing", "error", "default", "warning"];
function m8(e) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [].concat(it(ole), it(Ag)).includes(e) : Ag.includes(e);
}
function sle(e) {
  return ale.includes(e);
}
function y8(e, t) {
  const r = m8(t), n = ue({
    [`${e}-${t}`]: t && r
  }), i = {}, o = {};
  return t && !r && (i.background = t, o["--antd-arrow-background-color"] = t), {
    className: n,
    overlayStyle: i,
    arrowStyle: o
  };
}
const lle = (e) => {
  const {
    prefixCls: t,
    className: r,
    placement: n = "top",
    title: i,
    color: o,
    overlayInnerStyle: a
  } = e, {
    getPrefixCls: s
  } = E.useContext(Yt), l = s("tooltip", t), [u, c, d] = v8(l), h = y8(l, o), f = h.arrowStyle, p = Object.assign(Object.assign({}, a), h.overlayStyle), g = ue(c, d, l, `${l}-pure`, `${l}-placement-${n}`, r, h.className);
  return u(/* @__PURE__ */ E.createElement("div", {
    className: g,
    style: f
  }, /* @__PURE__ */ E.createElement("div", {
    className: `${l}-arrow`
  }), /* @__PURE__ */ E.createElement(eM, Object.assign({}, e, {
    className: c,
    prefixCls: l,
    overlayInnerStyle: p
  }), i)));
};
var ule = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const cle = /* @__PURE__ */ E.forwardRef((e, t) => {
  var r, n;
  const {
    prefixCls: i,
    openClassName: o,
    getTooltipContainer: a,
    overlayClassName: s,
    color: l,
    overlayInnerStyle: u,
    children: c,
    afterOpenChange: d,
    afterVisibleChange: h,
    destroyTooltipOnHide: f,
    arrow: p = !0,
    title: g,
    overlay: v,
    builtinPlacements: m,
    arrowPointAtCenter: y = !1,
    autoAdjustOverflow: C = !0
  } = e, S = !!p, [, b] = Qi(), {
    getPopupContainer: w,
    getPrefixCls: x,
    direction: R
  } = E.useContext(Yt), _ = en("Tooltip"), T = E.useRef(null), P = () => {
    var Fe;
    (Fe = T.current) === null || Fe === void 0 || Fe.forceAlign();
  };
  E.useImperativeHandle(t, () => {
    var Fe;
    return {
      forceAlign: P,
      forcePopupAlign: () => {
        _.deprecated(!1, "forcePopupAlign", "forceAlign"), P();
      },
      nativeElement: (Fe = T.current) === null || Fe === void 0 ? void 0 : Fe.nativeElement
    };
  }), process.env.NODE_ENV !== "production" && ([["visible", "open"], ["defaultVisible", "defaultOpen"], ["onVisibleChange", "onOpenChange"], ["afterVisibleChange", "afterOpenChange"], ["arrowPointAtCenter", "arrow={{ pointAtCenter: true }}"]].forEach((Fe) => {
    let [Ne, Je] = Fe;
    _.deprecated(!(Ne in e), Ne, Je);
  }), process.env.NODE_ENV !== "production" && _(!f || typeof f == "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly."), process.env.NODE_ENV !== "production" && _(!p || typeof p == "boolean" || !("arrowPointAtCenter" in p), "deprecated", "`arrowPointAtCenter` in `arrow` is deprecated. Please use `pointAtCenter` instead."));
  const [D, O] = xn(!1, {
    value: (r = e.open) !== null && r !== void 0 ? r : e.visible,
    defaultValue: (n = e.defaultOpen) !== null && n !== void 0 ? n : e.defaultVisible
  }), A = !g && !v && g !== 0, F = (Fe) => {
    var Ne, Je;
    O(A ? !1 : Fe), A || ((Ne = e.onOpenChange) === null || Ne === void 0 || Ne.call(e, Fe), (Je = e.onVisibleChange) === null || Je === void 0 || Je.call(e, Fe));
  }, L = E.useMemo(() => {
    var Fe, Ne;
    let Je = y;
    return typeof p == "object" && (Je = (Ne = (Fe = p.pointAtCenter) !== null && Fe !== void 0 ? Fe : p.arrowPointAtCenter) !== null && Ne !== void 0 ? Ne : y), m || rle({
      arrowPointAtCenter: Je,
      autoAdjustOverflow: C,
      arrowWidth: S ? b.sizePopupArrow : 0,
      borderRadius: b.borderRadius,
      offset: b.marginXXS,
      visibleFirst: !0
    });
  }, [y, p, m, b]), N = E.useMemo(() => g === 0 ? g : v || g || "", [v, g]), I = /* @__PURE__ */ E.createElement(IR, {
    space: !0
  }, typeof N == "function" ? N() : N), {
    getPopupContainer: B,
    placement: M = "top",
    mouseEnterDelay: V = 0.1,
    mouseLeaveDelay: G = 0.1,
    overlayStyle: k,
    rootClassName: z
  } = e, j = ule(e, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]), q = x("tooltip", i), K = x(), Z = e["data-popover-inject"];
  let re = D;
  !("open" in e) && !("visible" in e) && A && (re = !1);
  const X = /* @__PURE__ */ E.isValidElement(c) && !a5(c) ? c : /* @__PURE__ */ E.createElement("span", null, c), Y = X.props, U = !Y.className || typeof Y.className == "string" ? ue(Y.className, o || `${q}-open`) : Y.className, [oe, W, ne] = v8(q, !Z), ce = y8(q, l), we = ce.arrowStyle, Re = Object.assign(Object.assign({}, u), ce.overlayStyle), ve = ue(s, {
    [`${q}-rtl`]: R === "rtl"
  }, ce.className, z, W, ne), [xe, _e] = mS("Tooltip", j.zIndex), Ve = /* @__PURE__ */ E.createElement(Zse, Object.assign({}, j, {
    zIndex: xe,
    showArrow: S,
    placement: M,
    mouseEnterDelay: V,
    mouseLeaveDelay: G,
    prefixCls: q,
    overlayClassName: ve,
    overlayStyle: Object.assign(Object.assign({}, we), k),
    getTooltipContainer: B || a || w,
    ref: T,
    builtinPlacements: L,
    overlay: I,
    visible: re,
    onVisibleChange: F,
    afterVisibleChange: d ?? h,
    overlayInnerStyle: Re,
    arrowContent: /* @__PURE__ */ E.createElement("span", {
      className: `${q}-arrow-content`
    }),
    motion: {
      motionName: Ql(K, "zoom-big-fast", e.transitionName),
      motionDeadline: 1e3
    },
    destroyTooltipOnHide: !!f
  }), re ? Hc(X, {
    className: U
  }) : X);
  return oe(/* @__PURE__ */ E.createElement(kP.Provider, {
    value: _e
  }, Ve));
}), vu = cle;
process.env.NODE_ENV !== "production" && (vu.displayName = "Tooltip");
vu._InternalPanelDoNotUseOrYouWillBeFired = lle;
const dle = (e) => {
  const {
    componentCls: t,
    popoverColor: r,
    titleMinWidth: n,
    fontWeightStrong: i,
    innerPadding: o,
    boxShadowSecondary: a,
    colorTextHeading: s,
    borderRadiusLG: l,
    zIndexPopup: u,
    titleMarginBottom: c,
    colorBgElevated: d,
    popoverBg: h,
    titleBorderBottom: f,
    innerContentPadding: p,
    titlePadding: g
  } = e;
  return [
    {
      [t]: Object.assign(Object.assign({}, Fi(e)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: !0,
          value: 0
        },
        zIndex: u,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
        "--antd-arrow-background-color": d,
        width: "max-content",
        maxWidth: "100vw",
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${t}-content`]: {
          position: "relative"
        },
        [`${t}-inner`]: {
          backgroundColor: h,
          backgroundClip: "padding-box",
          borderRadius: l,
          boxShadow: a,
          padding: o
        },
        [`${t}-title`]: {
          minWidth: n,
          marginBottom: c,
          color: s,
          fontWeight: i,
          borderBottom: f,
          padding: g
        },
        [`${t}-inner-content`]: {
          color: r,
          padding: p
        }
      })
    },
    // Arrow Style
    g8(e, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: e.sizePopupArrow,
        display: "inline-block",
        [`${t}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
}, hle = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: Ag.map((r) => {
      const n = e[`${r}6`];
      return {
        [`&${t}-${r}`]: {
          "--antd-arrow-background-color": n,
          [`${t}-inner`]: {
            backgroundColor: n
          },
          [`${t}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
}, fle = (e) => {
  const {
    lineWidth: t,
    controlHeight: r,
    fontHeight: n,
    padding: i,
    wireframe: o,
    zIndexPopupBase: a,
    borderRadiusLG: s,
    marginXS: l,
    lineType: u,
    colorSplit: c,
    paddingSM: d
  } = e, h = r - n, f = h / 2, p = h / 2 - t, g = i;
  return Object.assign(Object.assign(Object.assign({
    titleMinWidth: 177,
    zIndexPopup: a + 30
  }, f8(e)), tM({
    contentRadius: s,
    limitVerticalRadius: !0
  })), {
    // internal
    innerPadding: o ? 0 : 12,
    titleMarginBottom: o ? 0 : l,
    titlePadding: o ? `${f}px ${g}px ${p}px` : 0,
    titleBorderBottom: o ? `${t}px ${u} ${c}` : "none",
    innerContentPadding: o ? `${d}px ${g}px` : 0
  });
}, C8 = Gn("Popover", (e) => {
  const {
    colorBgElevated: t,
    colorText: r
  } = e, n = Br(e, {
    popoverBg: t,
    popoverColor: r
  });
  return [dle(n), hle(n), xS(n, "zoom-big")];
}, fle, {
  resetStyle: !1,
  deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
});
var ple = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const gle = (e, t, r) => !t && !r ? null : /* @__PURE__ */ E.createElement(E.Fragment, null, t && /* @__PURE__ */ E.createElement("div", {
  className: `${e}-title`
}, Gh(t)), /* @__PURE__ */ E.createElement("div", {
  className: `${e}-inner-content`
}, Gh(r))), vle = (e) => {
  const {
    hashId: t,
    prefixCls: r,
    className: n,
    style: i,
    placement: o = "top",
    title: a,
    content: s,
    children: l
  } = e;
  return /* @__PURE__ */ E.createElement("div", {
    className: ue(t, r, `${r}-pure`, `${r}-placement-${o}`, n),
    style: i
  }, /* @__PURE__ */ E.createElement("div", {
    className: `${r}-arrow`
  }), /* @__PURE__ */ E.createElement(eM, Object.assign({}, e, {
    className: t,
    prefixCls: r
  }), l || gle(r, a, s)));
}, S8 = (e) => {
  const {
    prefixCls: t,
    className: r
  } = e, n = ple(e, ["prefixCls", "className"]), {
    getPrefixCls: i
  } = E.useContext(Yt), o = i("popover", t), [a, s, l] = C8(o);
  return a(/* @__PURE__ */ E.createElement(vle, Object.assign({}, n, {
    prefixCls: o,
    hashId: s,
    className: ue(r, l)
  })));
};
var mle = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const yle = (e) => {
  let {
    title: t,
    content: r,
    prefixCls: n
  } = e;
  return /* @__PURE__ */ E.createElement(E.Fragment, null, t && /* @__PURE__ */ E.createElement("div", {
    className: `${n}-title`
  }, Gh(t)), /* @__PURE__ */ E.createElement("div", {
    className: `${n}-inner-content`
  }, Gh(r)));
}, Cle = /* @__PURE__ */ E.forwardRef((e, t) => {
  var r, n;
  const {
    prefixCls: i,
    title: o,
    content: a,
    overlayClassName: s,
    placement: l = "top",
    trigger: u = "hover",
    children: c,
    mouseEnterDelay: d = 0.1,
    mouseLeaveDelay: h = 0.1,
    onOpenChange: f,
    overlayStyle: p = {}
  } = e, g = mle(e, ["prefixCls", "title", "content", "overlayClassName", "placement", "trigger", "children", "mouseEnterDelay", "mouseLeaveDelay", "onOpenChange", "overlayStyle"]), {
    getPrefixCls: v
  } = E.useContext(Yt), m = v("popover", i), [y, C, S] = C8(m), b = v(), w = ue(s, C, S), [x, R] = xn(!1, {
    value: (r = e.open) !== null && r !== void 0 ? r : e.visible,
    defaultValue: (n = e.defaultOpen) !== null && n !== void 0 ? n : e.defaultVisible
  }), _ = (D, O) => {
    R(D, !0), f == null || f(D, O);
  }, T = (D) => {
    D.keyCode === Ae.ESC && _(!1, D);
  }, P = (D) => {
    _(D);
  };
  return y(/* @__PURE__ */ E.createElement(vu, Object.assign({
    placement: l,
    trigger: u,
    mouseEnterDelay: d,
    mouseLeaveDelay: h,
    overlayStyle: p
  }, g, {
    prefixCls: m,
    overlayClassName: w,
    ref: t,
    open: x,
    onOpenChange: P,
    overlay: o || a ? /* @__PURE__ */ E.createElement(yle, {
      prefixCls: m,
      title: o,
      content: a
    }) : null,
    transitionName: Ql(b, "zoom-big", g.transitionName),
    "data-popover-inject": !0
  }), Hc(c, {
    onKeyDown: (D) => {
      var O, A;
      /* @__PURE__ */ E.isValidElement(c) && ((A = c == null ? void 0 : (O = c.props).onKeyDown) === null || A === void 0 || A.call(O, D)), T(D);
    }
  })));
}), rM = Cle;
rM._InternalPanelDoNotUseOrYouWillBeFired = S8;
process.env.NODE_ENV !== "production" && (rM.displayName = "Popover");
var Sle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, name: "right", theme: "outlined" }, wle = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: Sle
  }));
}, w8 = /* @__PURE__ */ E.forwardRef(wle);
process.env.NODE_ENV !== "production" && (w8.displayName = "RightOutlined");
var ble = Ae.ESC, xle = Ae.TAB;
function Ele(e) {
  var t = e.visible, r = e.triggerRef, n = e.onVisibleChange, i = e.autoFocus, o = e.overlayRef, a = E.useRef(!1), s = function() {
    if (t) {
      var d, h;
      (d = r.current) === null || d === void 0 || (h = d.focus) === null || h === void 0 || h.call(d), n == null || n(!1);
    }
  }, l = function() {
    var d;
    return (d = o.current) !== null && d !== void 0 && d.focus ? (o.current.focus(), a.current = !0, !0) : !1;
  }, u = function(d) {
    switch (d.keyCode) {
      case ble:
        s();
        break;
      case xle: {
        var h = !1;
        a.current || (h = l()), h ? d.preventDefault() : s();
        break;
      }
    }
  };
  E.useEffect(function() {
    return t ? (window.addEventListener("keydown", u), i && Ar(l, 3), function() {
      window.removeEventListener("keydown", u), a.current = !1;
    }) : function() {
      a.current = !1;
    };
  }, [t]);
}
var Rle = /* @__PURE__ */ yn(function(e, t) {
  var r = e.overlay, n = e.arrow, i = e.prefixCls, o = Et(function() {
    var s;
    return typeof r == "function" ? s = r() : s = r, s;
  }, [r]), a = Eo(t, o == null ? void 0 : o.ref);
  return /* @__PURE__ */ H.createElement(H.Fragment, null, n && /* @__PURE__ */ H.createElement("div", {
    className: "".concat(i, "-arrow")
  }), /* @__PURE__ */ H.cloneElement(o, {
    ref: Jc(o) ? a : void 0
  }));
}), _d = {
  adjustX: 1,
  adjustY: 1
}, Td = [0, 0], _le = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: _d,
    offset: [0, -4],
    targetOffset: Td
  },
  top: {
    points: ["bc", "tc"],
    overflow: _d,
    offset: [0, -4],
    targetOffset: Td
  },
  topRight: {
    points: ["br", "tr"],
    overflow: _d,
    offset: [0, -4],
    targetOffset: Td
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: _d,
    offset: [0, 4],
    targetOffset: Td
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: _d,
    offset: [0, 4],
    targetOffset: Td
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: _d,
    offset: [0, 4],
    targetOffset: Td
  }
}, Tle = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus", "overlay", "children", "onVisibleChange"];
function Ple(e, t) {
  var r, n = e.arrow, i = n === void 0 ? !1 : n, o = e.prefixCls, a = o === void 0 ? "rc-dropdown" : o, s = e.transitionName, l = e.animation, u = e.align, c = e.placement, d = c === void 0 ? "bottomLeft" : c, h = e.placements, f = h === void 0 ? _le : h, p = e.getPopupContainer, g = e.showAction, v = e.hideAction, m = e.overlayClassName, y = e.overlayStyle, C = e.visible, S = e.trigger, b = S === void 0 ? ["hover"] : S, w = e.autoFocus, x = e.overlay, R = e.children, _ = e.onVisibleChange, T = $t(e, Tle), P = H.useState(), D = ae(P, 2), O = D[0], A = D[1], F = "visible" in e ? C : O, L = H.useRef(null), N = H.useRef(null), I = H.useRef(null);
  H.useImperativeHandle(t, function() {
    return L.current;
  });
  var B = function(Z) {
    A(Z), _ == null || _(Z);
  };
  Ele({
    visible: F,
    triggerRef: I,
    onVisibleChange: B,
    autoFocus: w,
    overlayRef: N
  });
  var M = function(Z) {
    var re = e.onOverlayClick;
    A(!1), re && re(Z);
  }, V = function() {
    return /* @__PURE__ */ H.createElement(Rle, {
      ref: N,
      overlay: x,
      prefixCls: a,
      arrow: i
    });
  }, G = function() {
    return typeof x == "function" ? V : V();
  }, k = function() {
    var Z = e.minOverlayWidthMatchTrigger, re = e.alignPoint;
    return "minOverlayWidthMatchTrigger" in e ? Z : !re;
  }, z = function() {
    var Z = e.openClassName;
    return Z !== void 0 ? Z : "".concat(a, "-open");
  }, j = /* @__PURE__ */ H.cloneElement(R, {
    className: ue((r = R.props) === null || r === void 0 ? void 0 : r.className, F && z()),
    ref: Jc(R) ? Eo(I, R.ref) : void 0
  }), q = v;
  return !q && b.indexOf("contextMenu") !== -1 && (q = ["click"]), /* @__PURE__ */ H.createElement(RS, $e({
    builtinPlacements: f
  }, T, {
    prefixCls: a,
    ref: L,
    popupClassName: ue(m, te({}, "".concat(a, "-show-arrow"), i)),
    popupStyle: y,
    action: b,
    showAction: g,
    hideAction: q,
    popupPlacement: d,
    popupAlign: u,
    popupTransitionName: s,
    popupAnimation: l,
    popupVisible: F,
    stretch: k() ? "minWidth" : "",
    popup: G(),
    onPopupVisibleChange: B,
    onPopupClick: M,
    getPopupContainer: p
  }), j);
}
const Mle = /* @__PURE__ */ H.forwardRef(Ple);
var b8 = /* @__PURE__ */ E.createContext(null);
function x8(e, t) {
  return e === void 0 ? null : "".concat(e, "-").concat(t);
}
function E8(e) {
  var t = E.useContext(b8);
  return x8(t, e);
}
var Dle = ["children", "locked"], Aa = /* @__PURE__ */ E.createContext(null);
function Ale(e, t) {
  var r = ee({}, e);
  return Object.keys(t).forEach(function(n) {
    var i = t[n];
    i !== void 0 && (r[n] = i);
  }), r;
}
function Lg(e) {
  var t = e.children, r = e.locked, n = $t(e, Dle), i = E.useContext(Aa), o = vv(function() {
    return Ale(i, n);
  }, [i, n], function(a, s) {
    return !r && (a[0] !== s[0] || !Nh(a[1], s[1], !0));
  });
  return /* @__PURE__ */ E.createElement(Aa.Provider, {
    value: o
  }, t);
}
var Ile = [], R8 = /* @__PURE__ */ E.createContext(null);
function PS() {
  return E.useContext(R8);
}
var _8 = /* @__PURE__ */ E.createContext(Ile);
function xv(e) {
  var t = E.useContext(_8);
  return E.useMemo(function() {
    return e !== void 0 ? [].concat(it(t), [e]) : t;
  }, [t, e]);
}
var T8 = /* @__PURE__ */ E.createContext(null), nM = /* @__PURE__ */ E.createContext({});
function JO(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (VP(e)) {
    var r = e.nodeName.toLowerCase(), n = (
      // Focusable element
      ["input", "select", "textarea", "button"].includes(r) || // Editable element
      e.isContentEditable || // Anchor with href element
      r === "a" && !!e.getAttribute("href")
    ), i = e.getAttribute("tabindex"), o = Number(i), a = null;
    return i && !Number.isNaN(o) ? a = o : n && a === null && (a = 0), n && e.disabled && (a = null), a !== null && (a >= 0 || t && a < 0);
  }
  return !1;
}
function Ole(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = it(e.querySelectorAll("*")).filter(function(n) {
    return JO(n, t);
  });
  return JO(e, t) && r.unshift(e), r;
}
var VR = Ae.LEFT, BR = Ae.RIGHT, $R = Ae.UP, Qy = Ae.DOWN, Jy = Ae.ENTER, P8 = Ae.ESC, jf = Ae.HOME, Uf = Ae.END, eL = [$R, Qy, VR, BR];
function Lle(e, t, r, n) {
  var i, o, a, s, l = "prev", u = "next", c = "children", d = "parent";
  if (e === "inline" && n === Jy)
    return {
      inlineTrigger: !0
    };
  var h = (i = {}, te(i, $R, l), te(i, Qy, u), i), f = (o = {}, te(o, VR, r ? u : l), te(o, BR, r ? l : u), te(o, Qy, c), te(o, Jy, c), o), p = (a = {}, te(a, $R, l), te(a, Qy, u), te(a, Jy, c), te(a, P8, d), te(a, VR, r ? c : d), te(a, BR, r ? d : c), a), g = {
    inline: h,
    horizontal: f,
    vertical: p,
    inlineSub: h,
    horizontalSub: p,
    verticalSub: p
  }, v = (s = g["".concat(e).concat(t ? "" : "Sub")]) === null || s === void 0 ? void 0 : s[n];
  switch (v) {
    case l:
      return {
        offset: -1,
        sibling: !0
      };
    case u:
      return {
        offset: 1,
        sibling: !0
      };
    case d:
      return {
        offset: -1,
        sibling: !1
      };
    case c:
      return {
        offset: 1,
        sibling: !1
      };
    default:
      return null;
  }
}
function Fle(e) {
  for (var t = e; t; ) {
    if (t.getAttribute("data-menu-list"))
      return t;
    t = t.parentElement;
  }
  return null;
}
function Nle(e, t) {
  for (var r = e || document.activeElement; r; ) {
    if (t.has(r))
      return r;
    r = r.parentElement;
  }
  return null;
}
function iM(e, t) {
  var r = Ole(e, !0);
  return r.filter(function(n) {
    return t.has(n);
  });
}
function tL(e, t, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!e)
    return null;
  var i = iM(e, t), o = i.length, a = i.findIndex(function(s) {
    return r === s;
  });
  return n < 0 ? a === -1 ? a = o - 1 : a -= 1 : n > 0 && (a += 1), a = (a + o) % o, i[a];
}
var HR = function(t, r) {
  var n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  return t.forEach(function(a) {
    var s = document.querySelector("[data-menu-id='".concat(x8(r, a), "']"));
    s && (n.add(s), o.set(s, a), i.set(a, s));
  }), {
    elements: n,
    key2element: i,
    element2key: o
  };
};
function kle(e, t, r, n, i, o, a, s, l, u) {
  var c = E.useRef(), d = E.useRef();
  d.current = t;
  var h = function() {
    Ar.cancel(c.current);
  };
  return E.useEffect(function() {
    return function() {
      h();
    };
  }, []), function(f) {
    var p = f.which;
    if ([].concat(eL, [Jy, P8, jf, Uf]).includes(p)) {
      var g = o(), v = HR(g, n), m = v, y = m.elements, C = m.key2element, S = m.element2key, b = C.get(t), w = Nle(b, y), x = S.get(w), R = Lle(e, a(x, !0).length === 1, r, p);
      if (!R && p !== jf && p !== Uf)
        return;
      (eL.includes(p) || [jf, Uf].includes(p)) && f.preventDefault();
      var _ = function(N) {
        if (N) {
          var I = N, B = N.querySelector("a");
          B != null && B.getAttribute("href") && (I = B);
          var M = S.get(N);
          s(M), h(), c.current = Ar(function() {
            d.current === M && I.focus();
          });
        }
      };
      if ([jf, Uf].includes(p) || R.sibling || !w) {
        var T;
        !w || e === "inline" ? T = i.current : T = Fle(w);
        var P, D = iM(T, y);
        p === jf ? P = D[0] : p === Uf ? P = D[D.length - 1] : P = tL(T, y, w, R.offset), _(P);
      } else if (R.inlineTrigger)
        l(x);
      else if (R.offset > 0)
        l(x, !0), h(), c.current = Ar(function() {
          v = HR(g, n);
          var L = w.getAttribute("aria-controls"), N = document.getElementById(L), I = tL(N, v.elements);
          _(I);
        }, 5);
      else if (R.offset < 0) {
        var O = a(x, !0), A = O[O.length - 2], F = C.get(A);
        l(A, !1), _(F);
      }
    }
    u == null || u(f);
  };
}
function Vle(e) {
  Promise.resolve().then(e);
}
var oM = "__RC_UTIL_PATH_SPLIT__", rL = function(t) {
  return t.join(oM);
}, Ble = function(t) {
  return t.split(oM);
}, GR = "rc-menu-more";
function $le() {
  var e = E.useState({}), t = ae(e, 2), r = t[1], n = se(/* @__PURE__ */ new Map()), i = se(/* @__PURE__ */ new Map()), o = E.useState([]), a = ae(o, 2), s = a[0], l = a[1], u = se(0), c = se(!1), d = function() {
    c.current || r({});
  }, h = lr(function(C, S) {
    process.env.NODE_ENV !== "production" && Qt(!n.current.has(C), "Duplicated key '".concat(C, "' used in Menu by path [").concat(S.join(" > "), "]"));
    var b = rL(S);
    i.current.set(b, C), n.current.set(C, b), u.current += 1;
    var w = u.current;
    Vle(function() {
      w === u.current && d();
    });
  }, []), f = lr(function(C, S) {
    var b = rL(S);
    i.current.delete(b), n.current.delete(C);
  }, []), p = lr(function(C) {
    l(C);
  }, []), g = lr(function(C, S) {
    var b = n.current.get(C) || "", w = Ble(b);
    return S && s.includes(w[0]) && w.unshift(GR), w;
  }, [s]), v = lr(function(C, S) {
    return C.filter(function(b) {
      return b !== void 0;
    }).some(function(b) {
      var w = g(b, !0);
      return w.includes(S);
    });
  }, [g]), m = function() {
    var S = it(n.current.keys());
    return s.length && S.push(GR), S;
  }, y = lr(function(C) {
    var S = "".concat(n.current.get(C)).concat(oM), b = /* @__PURE__ */ new Set();
    return it(i.current.keys()).forEach(function(w) {
      w.startsWith(S) && b.add(i.current.get(w));
    }), b;
  }, []);
  return E.useEffect(function() {
    return function() {
      c.current = !0;
    };
  }, []), {
    // Register
    registerPath: h,
    unregisterPath: f,
    refreshOverflowKeys: p,
    // Util
    isSubPathKey: v,
    getKeyPath: g,
    getKeys: m,
    getSubPathKeys: y
  };
}
function Pp(e) {
  var t = E.useRef(e);
  t.current = e;
  var r = E.useCallback(function() {
    for (var n, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return (n = t.current) === null || n === void 0 ? void 0 : n.call.apply(n, [t].concat(o));
  }, []);
  return e ? r : void 0;
}
var Hle = Math.random().toFixed(5).toString().slice(2), nL = 0;
function Gle(e) {
  var t = xn(e, {
    value: e
  }), r = ae(t, 2), n = r[0], i = r[1];
  return E.useEffect(function() {
    nL += 1;
    var o = process.env.NODE_ENV === "test" ? "test" : "".concat(Hle, "-").concat(nL);
    i("rc-menu-uuid-".concat(o));
  }, []), n;
}
function M8(e, t, r, n) {
  var i = E.useContext(Aa), o = i.activeKey, a = i.onActive, s = i.onInactive, l = {
    active: o === e
  };
  return t || (l.onMouseEnter = function(u) {
    r == null || r({
      key: e,
      domEvent: u
    }), a(e);
  }, l.onMouseLeave = function(u) {
    n == null || n({
      key: e,
      domEvent: u
    }), s(e);
  }), l;
}
function D8(e) {
  var t = E.useContext(Aa), r = t.mode, n = t.rtl, i = t.inlineIndent;
  if (r !== "inline")
    return null;
  var o = e;
  return n ? {
    paddingRight: o * i
  } : {
    paddingLeft: o * i
  };
}
function A8(e) {
  var t = e.icon, r = e.props, n = e.children, i;
  return t === null || t === !1 ? null : (typeof t == "function" ? i = /* @__PURE__ */ E.createElement(t, ee({}, r)) : typeof t != "boolean" && (i = t), i || n || null);
}
var zle = ["item"];
function $0(e) {
  var t = e.item, r = $t(e, zle);
  return Object.defineProperty(r, "item", {
    get: function() {
      return Qt(!1, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future."), t;
    }
  }), r;
}
var Wle = ["title", "attribute", "elementRef"], jle = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], Ule = ["active"], Kle = /* @__PURE__ */ function(e) {
  hu(r, e);
  var t = fu(r);
  function r() {
    return Kn(this, r), t.apply(this, arguments);
  }
  return Yn(r, [{
    key: "render",
    value: function() {
      var i = this.props, o = i.title, a = i.attribute, s = i.elementRef, l = $t(i, Wle), u = ni(l, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
      return Qt(!a, "`attribute` of Menu.Item is deprecated. Please pass attribute directly."), /* @__PURE__ */ E.createElement(ss.Item, $e({}, a, {
        title: typeof o == "string" ? o : void 0
      }, u, {
        ref: s
      }));
    }
  }]), r;
}(E.Component), Yle = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r, n = e.style, i = e.className, o = e.eventKey, a = e.warnKey, s = e.disabled, l = e.itemIcon, u = e.children, c = e.role, d = e.onMouseEnter, h = e.onMouseLeave, f = e.onClick, p = e.onKeyDown, g = e.onFocus, v = $t(e, jle), m = E8(o), y = E.useContext(Aa), C = y.prefixCls, S = y.onItemClick, b = y.disabled, w = y.overflowDisabled, x = y.itemIcon, R = y.selectedKeys, _ = y.onActive, T = E.useContext(nM), P = T._internalRenderMenuItem, D = "".concat(C, "-item"), O = E.useRef(), A = E.useRef(), F = b || s, L = Qc(t, A), N = xv(o);
  process.env.NODE_ENV !== "production" && a && Qt(!1, "MenuItem should not leave undefined `key`.");
  var I = function(Y) {
    return {
      key: o,
      // Note: For legacy code is reversed which not like other antd component
      keyPath: it(N).reverse(),
      item: O.current,
      domEvent: Y
    };
  }, B = l || x, M = M8(o, F, d, h), V = M.active, G = $t(M, Ule), k = R.includes(o), z = D8(N.length), j = function(Y) {
    if (!F) {
      var U = I(Y);
      f == null || f($0(U)), S(U);
    }
  }, q = function(Y) {
    if (p == null || p(Y), Y.which === Ae.ENTER) {
      var U = I(Y);
      f == null || f($0(U)), S(U);
    }
  }, K = function(Y) {
    _(o), g == null || g(Y);
  }, Z = {};
  e.role === "option" && (Z["aria-selected"] = k);
  var re = /* @__PURE__ */ E.createElement(Kle, $e({
    ref: O,
    elementRef: L,
    role: c === null ? "none" : c || "menuitem",
    tabIndex: s ? null : -1,
    "data-menu-id": w && m ? null : m
  }, v, G, Z, {
    component: "li",
    "aria-disabled": s,
    style: ee(ee({}, z), n),
    className: ue(D, (r = {}, te(r, "".concat(D, "-active"), V), te(r, "".concat(D, "-selected"), k), te(r, "".concat(D, "-disabled"), F), r), i),
    onClick: j,
    onKeyDown: q,
    onFocus: K
  }), u, /* @__PURE__ */ E.createElement(A8, {
    props: ee(ee({}, e), {}, {
      isSelected: k
    }),
    icon: B
  }));
  return P && (re = P(re, e, {
    selected: k
  })), re;
});
function qle(e, t) {
  var r = e.eventKey, n = PS(), i = xv(r);
  return E.useEffect(function() {
    if (n)
      return n.registerPath(r, i), function() {
        n.unregisterPath(r, i);
      };
  }, [i]), n ? null : /* @__PURE__ */ E.createElement(Yle, $e({}, e, {
    ref: t
  }));
}
const MS = /* @__PURE__ */ E.forwardRef(qle);
var Xle = ["className", "children"], Zle = function(t, r) {
  var n = t.className, i = t.children, o = $t(t, Xle), a = E.useContext(Aa), s = a.prefixCls, l = a.mode, u = a.rtl;
  return /* @__PURE__ */ E.createElement("ul", $e({
    className: ue(s, u && "".concat(s, "-rtl"), "".concat(s, "-sub"), "".concat(s, "-").concat(l === "inline" ? "inline" : "vertical"), n),
    role: "menu"
  }, o, {
    "data-menu-list": !0,
    ref: r
  }), i);
}, aM = /* @__PURE__ */ E.forwardRef(Zle);
aM.displayName = "SubMenuList";
function sM(e, t) {
  return Zo(e).map(function(r, n) {
    if (/* @__PURE__ */ E.isValidElement(r)) {
      var i, o, a = r.key, s = (i = (o = r.props) === null || o === void 0 ? void 0 : o.eventKey) !== null && i !== void 0 ? i : a, l = s == null;
      l && (s = "tmp_key-".concat([].concat(it(t), [n]).join("-")));
      var u = {
        key: s,
        eventKey: s
      };
      return process.env.NODE_ENV !== "production" && l && (u.warnKey = !0), /* @__PURE__ */ E.cloneElement(r, u);
    }
    return r;
  });
}
var si = {
  adjustX: 1,
  adjustY: 1
}, Qle = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: si
  },
  topRight: {
    points: ["br", "tr"],
    overflow: si
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: si
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: si
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: si
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: si
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: si
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: si
  }
}, Jle = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: si
  },
  topRight: {
    points: ["br", "tr"],
    overflow: si
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: si
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: si
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: si
  },
  rightBottom: {
    points: ["br", "bl"],
    overflow: si
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: si
  },
  leftBottom: {
    points: ["bl", "br"],
    overflow: si
  }
};
function I8(e, t, r) {
  if (t)
    return t;
  if (r)
    return r[e] || r.other;
}
var eue = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function tue(e) {
  var t = e.prefixCls, r = e.visible, n = e.children, i = e.popup, o = e.popupStyle, a = e.popupClassName, s = e.popupOffset, l = e.disabled, u = e.mode, c = e.onVisibleChange, d = E.useContext(Aa), h = d.getPopupContainer, f = d.rtl, p = d.subMenuOpenDelay, g = d.subMenuCloseDelay, v = d.builtinPlacements, m = d.triggerSubMenuAction, y = d.forceSubMenuRender, C = d.rootClassName, S = d.motion, b = d.defaultMotions, w = E.useState(!1), x = ae(w, 2), R = x[0], _ = x[1], T = ee(f ? ee({}, Jle) : ee({}, Qle), v), P = eue[u], D = I8(u, S, b), O = E.useRef(D);
  u !== "inline" && (O.current = D);
  var A = ee(ee({}, O.current), {}, {
    leavedClassName: "".concat(t, "-hidden"),
    removeOnLeave: !1,
    motionAppear: !0
  }), F = E.useRef();
  return E.useEffect(function() {
    return F.current = Ar(function() {
      _(r);
    }), function() {
      Ar.cancel(F.current);
    };
  }, [r]), /* @__PURE__ */ E.createElement(RS, {
    prefixCls: t,
    popupClassName: ue("".concat(t, "-popup"), te({}, "".concat(t, "-rtl"), f), a, C),
    stretch: u === "horizontal" ? "minWidth" : null,
    getPopupContainer: h,
    builtinPlacements: T,
    popupPlacement: P,
    popupVisible: R,
    popup: i,
    popupStyle: o,
    popupAlign: s && {
      offset: s
    },
    action: l ? [] : [m],
    mouseEnterDelay: p,
    mouseLeaveDelay: g,
    onPopupVisibleChange: c,
    forceRender: y,
    popupMotion: A,
    fresh: !0
  }, n);
}
function rue(e) {
  var t = e.id, r = e.open, n = e.keyPath, i = e.children, o = "inline", a = E.useContext(Aa), s = a.prefixCls, l = a.forceSubMenuRender, u = a.motion, c = a.defaultMotions, d = a.mode, h = E.useRef(!1);
  h.current = d === o;
  var f = E.useState(!h.current), p = ae(f, 2), g = p[0], v = p[1], m = h.current ? r : !1;
  E.useEffect(function() {
    h.current && v(!1);
  }, [d]);
  var y = ee({}, I8(o, u, c));
  n.length > 1 && (y.motionAppear = !1);
  var C = y.onVisibleChanged;
  return y.onVisibleChanged = function(S) {
    return !h.current && !S && v(!0), C == null ? void 0 : C(S);
  }, g ? null : /* @__PURE__ */ E.createElement(Lg, {
    mode: o,
    locked: !h.current
  }, /* @__PURE__ */ E.createElement(Cs, $e({
    visible: m
  }, y, {
    forceRender: l,
    removeOnLeave: !1,
    leavedClassName: "".concat(s, "-hidden")
  }), function(S) {
    var b = S.className, w = S.style;
    return /* @__PURE__ */ E.createElement(aM, {
      id: t,
      className: b,
      style: w
    }, i);
  }));
}
var nue = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], iue = ["active"], oue = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r, n = e.style, i = e.className, o = e.title, a = e.eventKey, s = e.warnKey, l = e.disabled, u = e.internalPopupClose, c = e.children, d = e.itemIcon, h = e.expandIcon, f = e.popupClassName, p = e.popupOffset, g = e.popupStyle, v = e.onClick, m = e.onMouseEnter, y = e.onMouseLeave, C = e.onTitleClick, S = e.onTitleMouseEnter, b = e.onTitleMouseLeave, w = $t(e, nue), x = E8(a), R = E.useContext(Aa), _ = R.prefixCls, T = R.mode, P = R.openKeys, D = R.disabled, O = R.overflowDisabled, A = R.activeKey, F = R.selectedKeys, L = R.itemIcon, N = R.expandIcon, I = R.onItemClick, B = R.onOpenChange, M = R.onActive, V = E.useContext(nM), G = V._internalRenderSubMenuItem, k = E.useContext(T8), z = k.isSubPathKey, j = xv(), q = "".concat(_, "-submenu"), K = D || l, Z = E.useRef(), re = E.useRef();
  process.env.NODE_ENV !== "production" && s && Qt(!1, "SubMenu should not leave undefined `key`.");
  var X = d ?? L, Y = h ?? N, U = P.includes(a), oe = !O && U, W = z(F, a), ne = M8(a, K, S, b), ce = ne.active, we = $t(ne, iue), Re = E.useState(!1), ve = ae(Re, 2), xe = ve[0], _e = ve[1], Ve = function(Xe) {
    K || _e(Xe);
  }, Fe = function(Xe) {
    Ve(!0), m == null || m({
      key: a,
      domEvent: Xe
    });
  }, Ne = function(Xe) {
    Ve(!1), y == null || y({
      key: a,
      domEvent: Xe
    });
  }, Je = E.useMemo(function() {
    return ce || (T !== "inline" ? xe || z([A], a) : !1);
  }, [T, ce, A, xe, a, z]), J = D8(j.length), he = function(Xe) {
    K || (C == null || C({
      key: a,
      domEvent: Xe
    }), T === "inline" && B(a, !U));
  }, Le = Pp(function(ot) {
    v == null || v($0(ot)), I(ot);
  }), Pe = function(Xe) {
    T !== "inline" && B(a, Xe);
  }, Ie = function() {
    M(a);
  }, Ce = x && "".concat(x, "-popup"), De = /* @__PURE__ */ E.createElement("div", $e({
    role: "menuitem",
    style: J,
    className: "".concat(q, "-title"),
    tabIndex: K ? null : -1,
    ref: Z,
    title: typeof o == "string" ? o : null,
    "data-menu-id": O && x ? null : x,
    "aria-expanded": oe,
    "aria-haspopup": !0,
    "aria-controls": Ce,
    "aria-disabled": K,
    onClick: he,
    onFocus: Ie
  }, we), o, /* @__PURE__ */ E.createElement(A8, {
    icon: T !== "horizontal" ? Y : void 0,
    props: ee(ee({}, e), {}, {
      isOpen: oe,
      // [Legacy] Not sure why need this mark
      isSubMenu: !0
    })
  }, /* @__PURE__ */ E.createElement("i", {
    className: "".concat(q, "-arrow")
  }))), ze = E.useRef(T);
  if (T !== "inline" && j.length > 1 ? ze.current = "vertical" : ze.current = T, !O) {
    var st = ze.current;
    De = /* @__PURE__ */ E.createElement(tue, {
      mode: st,
      prefixCls: q,
      visible: !u && oe && T !== "inline",
      popupClassName: f,
      popupOffset: p,
      popupStyle: g,
      popup: /* @__PURE__ */ E.createElement(
        Lg,
        {
          mode: st === "horizontal" ? "vertical" : st
        },
        /* @__PURE__ */ E.createElement(aM, {
          id: Ce,
          ref: re
        }, c)
      ),
      disabled: K,
      onVisibleChange: Pe
    }, De);
  }
  var Tt = /* @__PURE__ */ E.createElement(ss.Item, $e({
    ref: t,
    role: "none"
  }, w, {
    component: "li",
    style: n,
    className: ue(q, "".concat(q, "-").concat(T), i, (r = {}, te(r, "".concat(q, "-open"), oe), te(r, "".concat(q, "-active"), Je), te(r, "".concat(q, "-selected"), W), te(r, "".concat(q, "-disabled"), K), r)),
    onMouseEnter: Fe,
    onMouseLeave: Ne
  }), De, !O && /* @__PURE__ */ E.createElement(rue, {
    id: Ce,
    open: oe,
    keyPath: j
  }, c));
  return G && (Tt = G(Tt, e, {
    selected: W,
    active: Je,
    open: oe,
    disabled: K
  })), /* @__PURE__ */ E.createElement(Lg, {
    onItemClick: Le,
    mode: T === "horizontal" ? "vertical" : T,
    itemIcon: X,
    expandIcon: Y
  }, Tt);
}), DS = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.eventKey, n = e.children, i = xv(r), o = sM(n, i), a = PS();
  E.useEffect(function() {
    if (a)
      return a.registerPath(r, i), function() {
        a.unregisterPath(r, i);
      };
  }, [i]);
  var s;
  return a ? s = o : s = /* @__PURE__ */ E.createElement(oue, $e({
    ref: t
  }, e), o), /* @__PURE__ */ E.createElement(_8.Provider, {
    value: i
  }, s);
});
process.env.NODE_ENV !== "production" && (DS.displayName = "SubMenu");
function O8(e) {
  var t = e.className, r = e.style, n = E.useContext(Aa), i = n.prefixCls, o = PS();
  return o ? null : /* @__PURE__ */ E.createElement("li", {
    role: "separator",
    className: ue("".concat(i, "-item-divider"), t),
    style: r
  });
}
var aue = ["className", "title", "eventKey", "children"], sue = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.className, n = e.title;
  e.eventKey;
  var i = e.children, o = $t(e, aue), a = E.useContext(Aa), s = a.prefixCls, l = "".concat(s, "-item-group");
  return /* @__PURE__ */ E.createElement("li", $e({
    ref: t,
    role: "presentation"
  }, o, {
    onClick: function(c) {
      return c.stopPropagation();
    },
    className: ue(l, r)
  }), /* @__PURE__ */ E.createElement("div", {
    role: "presentation",
    className: "".concat(l, "-title"),
    title: typeof n == "string" ? n : void 0
  }, n), /* @__PURE__ */ E.createElement("ul", {
    role: "group",
    className: "".concat(l, "-list")
  }, i));
}), lM = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.eventKey, n = e.children, i = xv(r), o = sM(n, i), a = PS();
  return a ? o : /* @__PURE__ */ E.createElement(sue, $e({
    ref: t
  }, ni(e, ["warnKey"])), o);
});
process.env.NODE_ENV !== "production" && (lM.displayName = "MenuItemGroup");
var lue = ["label", "children", "key", "type"];
function zR(e, t) {
  var r = t.item, n = t.group, i = t.submenu, o = t.divider;
  return (e || []).map(function(a, s) {
    if (a && vt(a) === "object") {
      var l = a, u = l.label, c = l.children, d = l.key, h = l.type, f = $t(l, lue), p = d ?? "tmp-".concat(s);
      return c || h === "group" ? h === "group" ? /* @__PURE__ */ E.createElement(n, $e({
        key: p
      }, f, {
        title: u
      }), zR(c, t)) : /* @__PURE__ */ E.createElement(i, $e({
        key: p
      }, f, {
        title: u
      }), zR(c, t)) : h === "divider" ? /* @__PURE__ */ E.createElement(o, $e({
        key: p
      }, f)) : /* @__PURE__ */ E.createElement(r, $e({
        key: p
      }, f), u);
    }
    return null;
  }).filter(function(a) {
    return a;
  });
}
function iL(e, t, r, n) {
  var i = e, o = ee({
    divider: O8,
    item: MS,
    group: lM,
    submenu: DS
  }, n);
  return t && (i = zR(t, o)), sM(i, r);
}
var uue = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem", "_internalComponents"], Ru = [], cue = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r, n, i = e, o = i.prefixCls, a = o === void 0 ? "rc-menu" : o, s = i.rootClassName, l = i.style, u = i.className, c = i.tabIndex, d = c === void 0 ? 0 : c, h = i.items, f = i.children, p = i.direction, g = i.id, v = i.mode, m = v === void 0 ? "vertical" : v, y = i.inlineCollapsed, C = i.disabled, S = i.disabledOverflow, b = i.subMenuOpenDelay, w = b === void 0 ? 0.1 : b, x = i.subMenuCloseDelay, R = x === void 0 ? 0.1 : x, _ = i.forceSubMenuRender, T = i.defaultOpenKeys, P = i.openKeys, D = i.activeKey, O = i.defaultActiveFirst, A = i.selectable, F = A === void 0 ? !0 : A, L = i.multiple, N = L === void 0 ? !1 : L, I = i.defaultSelectedKeys, B = i.selectedKeys, M = i.onSelect, V = i.onDeselect, G = i.inlineIndent, k = G === void 0 ? 24 : G, z = i.motion, j = i.defaultMotions, q = i.triggerSubMenuAction, K = q === void 0 ? "hover" : q, Z = i.builtinPlacements, re = i.itemIcon, X = i.expandIcon, Y = i.overflowedIndicator, U = Y === void 0 ? "..." : Y, oe = i.overflowedIndicatorPopupClassName, W = i.getPopupContainer, ne = i.onClick, ce = i.onOpenChange, we = i.onKeyDown, Re = i.openAnimation, ve = i.openTransitionName, xe = i._internalRenderMenuItem, _e = i._internalRenderSubMenuItem, Ve = i._internalComponents, Fe = $t(i, uue), Ne = E.useMemo(function() {
    return [iL(f, h, Ru, Ve), iL(f, h, Ru, {})];
  }, [f, h, Ve]), Je = ae(Ne, 2), J = Je[0], he = Je[1], Le = E.useState(!1), Pe = ae(Le, 2), Ie = Pe[0], Ce = Pe[1], De = E.useRef(), ze = Gle(g), st = p === "rtl";
  process.env.NODE_ENV !== "production" && Qt(!Re && !ve, "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.");
  var Tt = xn(T, {
    value: P,
    postState: function(Jt) {
      return Jt || Ru;
    }
  }), ot = ae(Tt, 2), Xe = ot[0], Oe = ot[1], Qe = function(Jt) {
    var pr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    function Yr() {
      Oe(Jt), ce == null || ce(Jt);
    }
    pr ? BE(Yr) : Yr();
  }, ft = E.useState(Xe), xt = ae(ft, 2), $r = xt[0], hr = xt[1], Gt = E.useRef(!1), Ot = E.useMemo(function() {
    return (m === "inline" || m === "vertical") && y ? ["vertical", y] : [m, !1];
  }, [m, y]), Lt = ae(Ot, 2), mt = Lt[0], qe = Lt[1], zt = mt === "inline", fr = E.useState(mt), Ge = ae(fr, 2), Ze = Ge[0], tt = Ge[1], ht = E.useState(qe), It = ae(ht, 2), qt = It[0], Hr = It[1];
  E.useEffect(function() {
    tt(mt), Hr(qe), Gt.current && (zt ? Oe($r) : Qe(Ru));
  }, [mt, qe]);
  var Q = E.useState(0), ye = ae(Q, 2), me = ye[0], Ue = ye[1], pt = me >= J.length - 1 || Ze !== "horizontal" || S;
  E.useEffect(function() {
    zt && hr(Xe);
  }, [Xe]), E.useEffect(function() {
    return Gt.current = !0, function() {
      Gt.current = !1;
    };
  }, []);
  var gt = $le(), yt = gt.registerPath, Rt = gt.unregisterPath, et = gt.refreshOverflowKeys, Ke = gt.isSubPathKey, rt = gt.getKeyPath, er = gt.getKeys, Xr = gt.getSubPathKeys, Rn = E.useMemo(function() {
    return {
      registerPath: yt,
      unregisterPath: Rt
    };
  }, [yt, Rt]), wr = E.useMemo(function() {
    return {
      isSubPathKey: Ke
    };
  }, [Ke]);
  E.useEffect(function() {
    et(pt ? Ru : J.slice(me + 1).map(function(tr) {
      return tr.key;
    }));
  }, [me, pt]);
  var Vi = xn(D || O && ((r = J[0]) === null || r === void 0 ? void 0 : r.key), {
    value: D
  }), to = ae(Vi, 2), _n = to[0], gi = to[1], hl = Pp(function(tr) {
    gi(tr);
  }), Bi = Pp(function() {
    gi(void 0);
  });
  Zc(t, function() {
    return {
      list: De.current,
      focus: function(Jt) {
        var pr, Yr = er(), on = HR(Yr, ze), On = on.elements, vi = on.key2element, Nf = on.element2key, mi = iM(De.current, On), Eu = _n ?? (mi[0] ? Nf.get(mi[0]) : (pr = J.find(function(fl) {
          return !fl.props.disabled;
        })) === null || pr === void 0 ? void 0 : pr.key), yi = vi.get(Eu);
        if (Eu && yi) {
          var ca;
          yi == null || (ca = yi.focus) === null || ca === void 0 || ca.call(yi, Jt);
        }
      }
    };
  });
  var $i = xn(I || [], {
    value: B,
    // Legacy convert key to array
    postState: function(Jt) {
      return Array.isArray(Jt) ? Jt : Jt == null ? Ru : [Jt];
    }
  }), Ba = ae($i, 2), la = Ba[0], Ro = Ba[1], ua = function(Jt) {
    if (F) {
      var pr = Jt.key, Yr = la.includes(pr), on;
      N ? Yr ? on = la.filter(function(vi) {
        return vi !== pr;
      }) : on = [].concat(it(la), [pr]) : on = [pr], Ro(on);
      var On = ee(ee({}, Jt), {}, {
        selectedKeys: on
      });
      Yr ? V == null || V(On) : M == null || M(On);
    }
    !N && Xe.length && Ze !== "inline" && Qe(Ru);
  }, $a = Pp(function(tr) {
    ne == null || ne($0(tr)), ua(tr);
  }), ro = Pp(function(tr, Jt) {
    var pr = Xe.filter(function(on) {
      return on !== tr;
    });
    if (Jt)
      pr.push(tr);
    else if (Ze !== "inline") {
      var Yr = Xr(tr);
      pr = pr.filter(function(on) {
        return !Yr.has(on);
      });
    }
    Nh(Xe, pr, !0) || Qe(pr, !0);
  }), Xt = function(Jt, pr) {
    var Yr = pr ?? !Xe.includes(Jt);
    ro(Jt, Yr);
  }, Ut = kle(Ze, _n, st, ze, De, er, rt, gi, Xt, we);
  E.useEffect(function() {
    Ce(!0);
  }, []);
  var Tn = E.useMemo(function() {
    return {
      _internalRenderMenuItem: xe,
      _internalRenderSubMenuItem: _e
    };
  }, [xe, _e]), Pn = Ze !== "horizontal" || S ? J : (
    // Need wrap for overflow dropdown that do not response for open
    J.map(function(tr, Jt) {
      return (
        // Always wrap provider to avoid sub node re-mount
        /* @__PURE__ */ E.createElement(Lg, {
          key: tr.key,
          overflowDisabled: Jt > me
        }, tr)
      );
    })
  ), Kr = /* @__PURE__ */ E.createElement(ss, $e({
    id: g,
    ref: De,
    prefixCls: "".concat(a, "-overflow"),
    component: "ul",
    itemComponent: MS,
    className: ue(a, "".concat(a, "-root"), "".concat(a, "-").concat(Ze), u, (n = {}, te(n, "".concat(a, "-inline-collapsed"), qt), te(n, "".concat(a, "-rtl"), st), n), s),
    dir: p,
    style: l,
    role: "menu",
    tabIndex: d,
    data: Pn,
    renderRawItem: function(Jt) {
      return Jt;
    },
    renderRawRest: function(Jt) {
      var pr = Jt.length, Yr = pr ? J.slice(-pr) : null;
      return /* @__PURE__ */ E.createElement(DS, {
        eventKey: GR,
        title: U,
        disabled: pt,
        internalPopupClose: pr === 0,
        popupClassName: oe
      }, Yr);
    },
    maxCount: Ze !== "horizontal" || S ? ss.INVALIDATE : ss.RESPONSIVE,
    ssr: "full",
    "data-menu-list": !0,
    onVisibleChange: function(Jt) {
      Ue(Jt);
    },
    onKeyDown: Ut
  }, Fe));
  return /* @__PURE__ */ E.createElement(nM.Provider, {
    value: Tn
  }, /* @__PURE__ */ E.createElement(b8.Provider, {
    value: ze
  }, /* @__PURE__ */ E.createElement(Lg, {
    prefixCls: a,
    rootClassName: s,
    mode: Ze,
    openKeys: Xe,
    rtl: st,
    disabled: C,
    motion: Ie ? z : null,
    defaultMotions: Ie ? j : null,
    activeKey: _n,
    onActive: hl,
    onInactive: Bi,
    selectedKeys: la,
    inlineIndent: k,
    subMenuOpenDelay: w,
    subMenuCloseDelay: R,
    forceSubMenuRender: _,
    builtinPlacements: Z,
    triggerSubMenuAction: K,
    getPopupContainer: W,
    itemIcon: re,
    expandIcon: X,
    onItemClick: $a,
    onOpenChange: ro
  }, /* @__PURE__ */ E.createElement(T8.Provider, {
    value: wr
  }, Kr), /* @__PURE__ */ E.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": !0
  }, /* @__PURE__ */ E.createElement(R8.Provider, {
    value: Rn
  }, he)))));
}), Ev = cue;
Ev.Item = MS;
Ev.SubMenu = DS;
Ev.ItemGroup = lM;
Ev.Divider = O8;
var due = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, name: "left", theme: "outlined" }, hue = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: due
  }));
}, L8 = /* @__PURE__ */ E.forwardRef(hue);
process.env.NODE_ENV !== "production" && (L8.displayName = "LeftOutlined");
var fue = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "ellipsis", theme: "outlined" }, pue = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: fue
  }));
}, F8 = /* @__PURE__ */ E.forwardRef(pue);
process.env.NODE_ENV !== "production" && (F8.displayName = "EllipsisOutlined");
var N8 = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(T0, function() {
    var r = 1e3, n = 6e4, i = 36e5, o = "millisecond", a = "second", s = "minute", l = "hour", u = "day", c = "week", d = "month", h = "quarter", f = "year", p = "date", g = "Invalid Date", v = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, y = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(A) {
      var F = ["th", "st", "nd", "rd"], L = A % 100;
      return "[" + A + (F[(L - 20) % 10] || F[L] || F[0]) + "]";
    } }, C = function(A, F, L) {
      var N = String(A);
      return !N || N.length >= F ? A : "" + Array(F + 1 - N.length).join(L) + A;
    }, S = { s: C, z: function(A) {
      var F = -A.utcOffset(), L = Math.abs(F), N = Math.floor(L / 60), I = L % 60;
      return (F <= 0 ? "+" : "-") + C(N, 2, "0") + ":" + C(I, 2, "0");
    }, m: function A(F, L) {
      if (F.date() < L.date()) return -A(L, F);
      var N = 12 * (L.year() - F.year()) + (L.month() - F.month()), I = F.clone().add(N, d), B = L - I < 0, M = F.clone().add(N + (B ? -1 : 1), d);
      return +(-(N + (L - I) / (B ? I - M : M - I)) || 0);
    }, a: function(A) {
      return A < 0 ? Math.ceil(A) || 0 : Math.floor(A);
    }, p: function(A) {
      return { M: d, y: f, w: c, d: u, D: p, h: l, m: s, s: a, ms: o, Q: h }[A] || String(A || "").toLowerCase().replace(/s$/, "");
    }, u: function(A) {
      return A === void 0;
    } }, b = "en", w = {};
    w[b] = y;
    var x = "$isDayjsObject", R = function(A) {
      return A instanceof D || !(!A || !A[x]);
    }, _ = function A(F, L, N) {
      var I;
      if (!F) return b;
      if (typeof F == "string") {
        var B = F.toLowerCase();
        w[B] && (I = B), L && (w[B] = L, I = B);
        var M = F.split("-");
        if (!I && M.length > 1) return A(M[0]);
      } else {
        var V = F.name;
        w[V] = F, I = V;
      }
      return !N && I && (b = I), I || !N && b;
    }, T = function(A, F) {
      if (R(A)) return A.clone();
      var L = typeof F == "object" ? F : {};
      return L.date = A, L.args = arguments, new D(L);
    }, P = S;
    P.l = _, P.i = R, P.w = function(A, F) {
      return T(A, { locale: F.$L, utc: F.$u, x: F.$x, $offset: F.$offset });
    };
    var D = function() {
      function A(L) {
        this.$L = _(L.locale, null, !0), this.parse(L), this.$x = this.$x || L.x || {}, this[x] = !0;
      }
      var F = A.prototype;
      return F.parse = function(L) {
        this.$d = function(N) {
          var I = N.date, B = N.utc;
          if (I === null) return /* @__PURE__ */ new Date(NaN);
          if (P.u(I)) return /* @__PURE__ */ new Date();
          if (I instanceof Date) return new Date(I);
          if (typeof I == "string" && !/Z$/i.test(I)) {
            var M = I.match(v);
            if (M) {
              var V = M[2] - 1 || 0, G = (M[7] || "0").substring(0, 3);
              return B ? new Date(Date.UTC(M[1], V, M[3] || 1, M[4] || 0, M[5] || 0, M[6] || 0, G)) : new Date(M[1], V, M[3] || 1, M[4] || 0, M[5] || 0, M[6] || 0, G);
            }
          }
          return new Date(I);
        }(L), this.init();
      }, F.init = function() {
        var L = this.$d;
        this.$y = L.getFullYear(), this.$M = L.getMonth(), this.$D = L.getDate(), this.$W = L.getDay(), this.$H = L.getHours(), this.$m = L.getMinutes(), this.$s = L.getSeconds(), this.$ms = L.getMilliseconds();
      }, F.$utils = function() {
        return P;
      }, F.isValid = function() {
        return this.$d.toString() !== g;
      }, F.isSame = function(L, N) {
        var I = T(L);
        return this.startOf(N) <= I && I <= this.endOf(N);
      }, F.isAfter = function(L, N) {
        return T(L) < this.startOf(N);
      }, F.isBefore = function(L, N) {
        return this.endOf(N) < T(L);
      }, F.$g = function(L, N, I) {
        return P.u(L) ? this[N] : this.set(I, L);
      }, F.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, F.valueOf = function() {
        return this.$d.getTime();
      }, F.startOf = function(L, N) {
        var I = this, B = !!P.u(N) || N, M = P.p(L), V = function(re, X) {
          var Y = P.w(I.$u ? Date.UTC(I.$y, X, re) : new Date(I.$y, X, re), I);
          return B ? Y : Y.endOf(u);
        }, G = function(re, X) {
          return P.w(I.toDate()[re].apply(I.toDate("s"), (B ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(X)), I);
        }, k = this.$W, z = this.$M, j = this.$D, q = "set" + (this.$u ? "UTC" : "");
        switch (M) {
          case f:
            return B ? V(1, 0) : V(31, 11);
          case d:
            return B ? V(1, z) : V(0, z + 1);
          case c:
            var K = this.$locale().weekStart || 0, Z = (k < K ? k + 7 : k) - K;
            return V(B ? j - Z : j + (6 - Z), z);
          case u:
          case p:
            return G(q + "Hours", 0);
          case l:
            return G(q + "Minutes", 1);
          case s:
            return G(q + "Seconds", 2);
          case a:
            return G(q + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, F.endOf = function(L) {
        return this.startOf(L, !1);
      }, F.$set = function(L, N) {
        var I, B = P.p(L), M = "set" + (this.$u ? "UTC" : ""), V = (I = {}, I[u] = M + "Date", I[p] = M + "Date", I[d] = M + "Month", I[f] = M + "FullYear", I[l] = M + "Hours", I[s] = M + "Minutes", I[a] = M + "Seconds", I[o] = M + "Milliseconds", I)[B], G = B === u ? this.$D + (N - this.$W) : N;
        if (B === d || B === f) {
          var k = this.clone().set(p, 1);
          k.$d[V](G), k.init(), this.$d = k.set(p, Math.min(this.$D, k.daysInMonth())).$d;
        } else V && this.$d[V](G);
        return this.init(), this;
      }, F.set = function(L, N) {
        return this.clone().$set(L, N);
      }, F.get = function(L) {
        return this[P.p(L)]();
      }, F.add = function(L, N) {
        var I, B = this;
        L = Number(L);
        var M = P.p(N), V = function(z) {
          var j = T(B);
          return P.w(j.date(j.date() + Math.round(z * L)), B);
        };
        if (M === d) return this.set(d, this.$M + L);
        if (M === f) return this.set(f, this.$y + L);
        if (M === u) return V(1);
        if (M === c) return V(7);
        var G = (I = {}, I[s] = n, I[l] = i, I[a] = r, I)[M] || 1, k = this.$d.getTime() + L * G;
        return P.w(k, this);
      }, F.subtract = function(L, N) {
        return this.add(-1 * L, N);
      }, F.format = function(L) {
        var N = this, I = this.$locale();
        if (!this.isValid()) return I.invalidDate || g;
        var B = L || "YYYY-MM-DDTHH:mm:ssZ", M = P.z(this), V = this.$H, G = this.$m, k = this.$M, z = I.weekdays, j = I.months, q = I.meridiem, K = function(X, Y, U, oe) {
          return X && (X[Y] || X(N, B)) || U[Y].slice(0, oe);
        }, Z = function(X) {
          return P.s(V % 12 || 12, X, "0");
        }, re = q || function(X, Y, U) {
          var oe = X < 12 ? "AM" : "PM";
          return U ? oe.toLowerCase() : oe;
        };
        return B.replace(m, function(X, Y) {
          return Y || function(U) {
            switch (U) {
              case "YY":
                return String(N.$y).slice(-2);
              case "YYYY":
                return P.s(N.$y, 4, "0");
              case "M":
                return k + 1;
              case "MM":
                return P.s(k + 1, 2, "0");
              case "MMM":
                return K(I.monthsShort, k, j, 3);
              case "MMMM":
                return K(j, k);
              case "D":
                return N.$D;
              case "DD":
                return P.s(N.$D, 2, "0");
              case "d":
                return String(N.$W);
              case "dd":
                return K(I.weekdaysMin, N.$W, z, 2);
              case "ddd":
                return K(I.weekdaysShort, N.$W, z, 3);
              case "dddd":
                return z[N.$W];
              case "H":
                return String(V);
              case "HH":
                return P.s(V, 2, "0");
              case "h":
                return Z(1);
              case "hh":
                return Z(2);
              case "a":
                return re(V, G, !0);
              case "A":
                return re(V, G, !1);
              case "m":
                return String(G);
              case "mm":
                return P.s(G, 2, "0");
              case "s":
                return String(N.$s);
              case "ss":
                return P.s(N.$s, 2, "0");
              case "SSS":
                return P.s(N.$ms, 3, "0");
              case "Z":
                return M;
            }
            return null;
          }(X) || M.replace(":", "");
        });
      }, F.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, F.diff = function(L, N, I) {
        var B, M = this, V = P.p(N), G = T(L), k = (G.utcOffset() - this.utcOffset()) * n, z = this - G, j = function() {
          return P.m(M, G);
        };
        switch (V) {
          case f:
            B = j() / 12;
            break;
          case d:
            B = j();
            break;
          case h:
            B = j() / 3;
            break;
          case c:
            B = (z - k) / 6048e5;
            break;
          case u:
            B = (z - k) / 864e5;
            break;
          case l:
            B = z / i;
            break;
          case s:
            B = z / n;
            break;
          case a:
            B = z / r;
            break;
          default:
            B = z;
        }
        return I ? B : P.a(B);
      }, F.daysInMonth = function() {
        return this.endOf(d).$D;
      }, F.$locale = function() {
        return w[this.$L];
      }, F.locale = function(L, N) {
        if (!L) return this.$L;
        var I = this.clone(), B = _(L, N, !0);
        return B && (I.$L = B), I;
      }, F.clone = function() {
        return P.w(this.$d, this);
      }, F.toDate = function() {
        return new Date(this.valueOf());
      }, F.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, F.toISOString = function() {
        return this.$d.toISOString();
      }, F.toString = function() {
        return this.$d.toUTCString();
      }, A;
    }(), O = D.prototype;
    return T.prototype = O, [["$ms", o], ["$s", a], ["$m", s], ["$H", l], ["$W", u], ["$M", d], ["$y", f], ["$D", p]].forEach(function(A) {
      O[A[1]] = function(F) {
        return this.$g(F, A[0], A[1]);
      };
    }), T.extend = function(A, F) {
      return A.$i || (A(F, D, T), A.$i = !0), T;
    }, T.locale = _, T.isDayjs = R, T.unix = function(A) {
      return T(1e3 * A);
    }, T.en = w[b], T.Ls = w, T.p = {}, T;
  });
})(N8);
var gue = N8.exports;
const Yi = /* @__PURE__ */ of(gue);
var k8 = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(T0, function() {
    return function(r, n) {
      var i = n.prototype, o = i.format;
      i.format = function(a) {
        var s = this, l = this.$locale();
        if (!this.isValid()) return o.bind(this)(a);
        var u = this.$utils(), c = (a || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(d) {
          switch (d) {
            case "Q":
              return Math.ceil((s.$M + 1) / 3);
            case "Do":
              return l.ordinal(s.$D);
            case "gggg":
              return s.weekYear();
            case "GGGG":
              return s.isoWeekYear();
            case "wo":
              return l.ordinal(s.week(), "W");
            case "w":
            case "ww":
              return u.s(s.week(), d === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return u.s(s.isoWeek(), d === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return u.s(String(s.$H === 0 ? 24 : s.$H), d === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(s.$d.getTime() / 1e3);
            case "x":
              return s.$d.getTime();
            case "z":
              return "[" + s.offsetName() + "]";
            case "zzz":
              return "[" + s.offsetName("long") + "]";
            default:
              return d;
          }
        });
        return o.bind(this)(c);
      };
    };
  });
})(k8);
var vue = k8.exports;
const V8 = /* @__PURE__ */ of(vue);
function B8(e) {
  return Br(e, {
    inputAffixPadding: e.paddingXXS
  });
}
const $8 = (e) => {
  const {
    controlHeight: t,
    fontSize: r,
    lineHeight: n,
    lineWidth: i,
    controlHeightSM: o,
    controlHeightLG: a,
    fontSizeLG: s,
    lineHeightLG: l,
    paddingSM: u,
    controlPaddingHorizontalSM: c,
    controlPaddingHorizontal: d,
    colorFillAlter: h,
    colorPrimaryHover: f,
    colorPrimary: p,
    controlOutlineWidth: g,
    controlOutline: v,
    colorErrorOutline: m,
    colorWarningOutline: y,
    colorBgContainer: C
  } = e;
  return {
    paddingBlock: Math.max(Math.round((t - r * n) / 2 * 10) / 10 - i, 0),
    paddingBlockSM: Math.max(Math.round((o - r * n) / 2 * 10) / 10 - i, 0),
    paddingBlockLG: Math.ceil((a - s * l) / 2 * 10) / 10 - i,
    paddingInline: u - i,
    paddingInlineSM: c - i,
    paddingInlineLG: d - i,
    addonBg: h,
    activeBorderColor: p,
    hoverBorderColor: f,
    activeShadow: `0 0 0 ${g}px ${v}`,
    errorActiveShadow: `0 0 0 ${g}px ${m}`,
    warningActiveShadow: `0 0 0 ${g}px ${y}`,
    hoverBg: C,
    activeBg: C,
    inputFontSize: r,
    inputFontSizeLG: s,
    inputFontSizeSM: r
  };
}, mue = (e) => ({
  borderColor: e.hoverBorderColor,
  backgroundColor: e.hoverBg
}), uM = (e) => ({
  color: e.colorTextDisabled,
  backgroundColor: e.colorBgContainerDisabled,
  borderColor: e.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "input[disabled], textarea[disabled]": {
    cursor: "not-allowed"
  },
  "&:hover:not([disabled])": Object.assign({}, mue(Br(e, {
    hoverBorderColor: e.colorBorder,
    hoverBg: e.colorBgContainerDisabled
  })))
}), H8 = (e, t) => ({
  background: e.colorBgContainer,
  borderWidth: e.lineWidth,
  borderStyle: e.lineType,
  borderColor: t.borderColor,
  "&:hover": {
    borderColor: t.hoverBorderColor,
    backgroundColor: e.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: t.activeBorderColor,
    boxShadow: t.activeShadow,
    outline: 0,
    backgroundColor: e.activeBg
  }
}), oL = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}:not(${e.componentCls}-disabled)`]: Object.assign(Object.assign({}, H8(e, t)), {
    [`${e.componentCls}-prefix, ${e.componentCls}-suffix`]: {
      color: t.affixColor
    }
  }),
  [`&${e.componentCls}-status-${t.status}${e.componentCls}-disabled`]: {
    borderColor: t.borderColor
  }
}), yue = (e, t) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, H8(e, {
    borderColor: e.colorBorder,
    hoverBorderColor: e.hoverBorderColor,
    activeBorderColor: e.activeBorderColor,
    activeShadow: e.activeShadow
  })), {
    [`&${e.componentCls}-disabled, &[disabled]`]: Object.assign({}, uM(e))
  }), oL(e, {
    status: "error",
    borderColor: e.colorError,
    hoverBorderColor: e.colorErrorBorderHover,
    activeBorderColor: e.colorError,
    activeShadow: e.errorActiveShadow,
    affixColor: e.colorError
  })), oL(e, {
    status: "warning",
    borderColor: e.colorWarning,
    hoverBorderColor: e.colorWarningBorderHover,
    activeBorderColor: e.colorWarning,
    activeShadow: e.warningActiveShadow,
    affixColor: e.colorWarning
  })), t)
}), aL = (e, t) => ({
  [`&${e.componentCls}-group-wrapper-status-${t.status}`]: {
    [`${e.componentCls}-group-addon`]: {
      borderColor: t.addonBorderColor,
      color: t.addonColor
    }
  }
}), Cue = (e) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign({
    [`${e.componentCls}-group`]: {
      "&-addon": {
        background: e.addonBg,
        border: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    }
  }, aL(e, {
    status: "error",
    addonBorderColor: e.colorError,
    addonColor: e.colorErrorText
  })), aL(e, {
    status: "warning",
    addonBorderColor: e.colorWarning,
    addonColor: e.colorWarningText
  })), {
    [`&${e.componentCls}-group-wrapper-disabled`]: {
      [`${e.componentCls}-group-addon`]: Object.assign({}, uM(e))
    }
  })
}), Sue = (e, t) => {
  const {
    componentCls: r
  } = e;
  return {
    "&-borderless": Object.assign({
      background: "transparent",
      border: "none",
      "&:focus, &:focus-within": {
        outline: "none"
      },
      // >>>>> Disabled
      [`&${r}-disabled, &[disabled]`]: {
        color: e.colorTextDisabled
      },
      // >>>>> Status
      [`&${r}-status-error`]: {
        "&, & input, & textarea": {
          color: e.colorError
        }
      },
      [`&${r}-status-warning`]: {
        "&, & input, & textarea": {
          color: e.colorWarning
        }
      }
    }, t)
  };
}, G8 = (e, t) => ({
  background: t.bg,
  borderWidth: e.lineWidth,
  borderStyle: e.lineType,
  borderColor: "transparent",
  "input&, & input, textarea&, & textarea": {
    color: t == null ? void 0 : t.inputColor
  },
  "&:hover": {
    background: t.hoverBg
  },
  "&:focus, &:focus-within": {
    outline: 0,
    borderColor: t.activeBorderColor,
    backgroundColor: e.activeBg
  }
}), sL = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}:not(${e.componentCls}-disabled)`]: Object.assign(Object.assign({}, G8(e, t)), {
    [`${e.componentCls}-prefix, ${e.componentCls}-suffix`]: {
      color: t.affixColor
    }
  })
}), wue = (e, t) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, G8(e, {
    bg: e.colorFillTertiary,
    hoverBg: e.colorFillSecondary,
    activeBorderColor: e.colorPrimary
  })), {
    [`&${e.componentCls}-disabled, &[disabled]`]: Object.assign({}, uM(e))
  }), sL(e, {
    status: "error",
    bg: e.colorErrorBg,
    hoverBg: e.colorErrorBgHover,
    activeBorderColor: e.colorError,
    inputColor: e.colorErrorText,
    affixColor: e.colorError
  })), sL(e, {
    status: "warning",
    bg: e.colorWarningBg,
    hoverBg: e.colorWarningBgHover,
    activeBorderColor: e.colorWarning,
    inputColor: e.colorWarningText,
    affixColor: e.colorWarning
  })), t)
}), lL = (e, t) => ({
  [`&${e.componentCls}-group-wrapper-status-${t.status}`]: {
    [`${e.componentCls}-group-addon`]: {
      background: t.addonBg,
      color: t.addonColor
    }
  }
}), bue = (e) => ({
  "&-filled": Object.assign(Object.assign(Object.assign({
    [`${e.componentCls}-group`]: {
      "&-addon": {
        background: e.colorFillTertiary
      },
      [`${e.componentCls}-filled:not(:focus):not(:focus-within)`]: {
        "&:not(:first-child)": {
          borderInlineStart: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`
        },
        "&:not(:last-child)": {
          borderInlineEnd: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`
        }
      }
    }
  }, lL(e, {
    status: "error",
    addonBg: e.colorErrorBg,
    addonColor: e.colorErrorText
  })), lL(e, {
    status: "warning",
    addonBg: e.colorWarningBg,
    addonColor: e.colorWarningText
  })), {
    [`&${e.componentCls}-group-wrapper-disabled`]: {
      [`${e.componentCls}-group`]: {
        "&-addon": {
          background: e.colorFillTertiary,
          color: e.colorTextDisabled
        },
        "&-addon:first-child": {
          borderInlineStart: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderTop: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderBottom: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        },
        "&-addon:last-child": {
          borderInlineEnd: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderTop: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderBottom: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        }
      }
    }
  })
}), xue = (e) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: e,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), z8 = (e) => {
  const {
    paddingBlockLG: t,
    lineHeightLG: r,
    borderRadiusLG: n,
    paddingInlineLG: i
  } = e;
  return {
    padding: `${de(t)} ${de(i)}`,
    fontSize: e.inputFontSizeLG,
    lineHeight: r,
    borderRadius: n
  };
}, W8 = (e) => ({
  padding: `${de(e.paddingBlockSM)} ${de(e.paddingInlineSM)}`,
  fontSize: e.inputFontSizeSM,
  borderRadius: e.borderRadiusSM
}), j8 = (e) => Object.assign(Object.assign({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${de(e.paddingBlock)} ${de(e.paddingInline)}`,
  color: e.colorText,
  fontSize: e.inputFontSize,
  lineHeight: e.lineHeight,
  borderRadius: e.borderRadius,
  transition: `all ${e.motionDurationMid}`
}, xue(e.colorTextPlaceholder)), {
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    // prevent textarea resize from coming out of its container
    height: "auto",
    minHeight: e.controlHeight,
    lineHeight: e.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${e.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": Object.assign({}, z8(e)),
  "&-sm": Object.assign({}, W8(e)),
  // RTL
  "&-rtl, &-textarea-rtl": {
    direction: "rtl"
  }
}), Eue = (e) => {
  const {
    componentCls: t,
    antCls: r
  } = e;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: e.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${t}, &-lg > ${t}-group-addon`]: Object.assign({}, z8(e)),
    [`&-sm ${t}, &-sm > ${t}-group-addon`]: Object.assign({}, W8(e)),
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${r}-select-single ${r}-select-selector`]: {
      height: e.controlHeightLG
    },
    [`&-sm ${r}-select-single ${r}-select-selector`]: {
      height: e.controlHeightSM
    },
    [`> ${t}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${t}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${de(e.paddingInline)}`,
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.inputFontSize,
        textAlign: "center",
        borderRadius: e.borderRadius,
        transition: `all ${e.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${r}-select`]: {
          margin: `${de(e.calc(e.paddingBlock).add(1).mul(-1).equal())} ${de(e.calc(e.paddingInline).mul(-1).equal())}`,
          [`&${r}-select-single:not(${r}-select-customize-input):not(${r}-pagination-size-changer)`]: {
            [`${r}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${de(e.lineWidth)} ${e.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${r}-select-selector`]: {
              color: e.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${r}-cascader-picker`]: {
          margin: `-9px ${de(e.calc(e.paddingInline).mul(-1).equal())}`,
          backgroundColor: "transparent",
          [`${r}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      }
    },
    [`${t}`]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${t}:first-child, ${t}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${r}-select ${r}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}-affix-wrapper`]: {
      [`&:not(:first-child) ${t}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${t}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}:last-child, ${t}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${r}-select ${r}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${t}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${t}-search &`]: {
          borderStartStartRadius: e.borderRadius,
          borderEndStartRadius: e.borderRadius
        }
      },
      [`&:not(:first-child), ${t}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${t}-group-compact`]: Object.assign(Object.assign({
      display: "block"
    }, mv()), {
      [`${t}-group-addon, ${t}-group-wrap, > ${t}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: e.lineWidth,
          "&:hover, &:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-flex",
        float: "none",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${t}-affix-wrapper,
        & > ${t}-number-affix-wrapper,
        & > ${r}-picker-range
      `]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: e.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${t}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${r}-select > ${r}-select-selector,
      & > ${r}-select-auto-complete ${t},
      & > ${r}-cascader-picker ${t},
      & > ${t}-group-wrapper ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderRadius: 0,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`& > ${r}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${r}-select > ${r}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${r}-select:first-child > ${r}-select-selector,
      & > ${r}-select-auto-complete:first-child ${t},
      & > ${r}-cascader-picker:first-child ${t}`]: {
        borderStartStartRadius: e.borderRadius,
        borderEndStartRadius: e.borderRadius
      },
      [`& > *:last-child,
      & > ${r}-select:last-child > ${r}-select-selector,
      & > ${r}-cascader-picker:last-child ${t},
      & > ${r}-cascader-picker-focused:last-child ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderStartEndRadius: e.borderRadius,
        borderEndEndRadius: e.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${r}-select-auto-complete ${t}`]: {
        verticalAlign: "top"
      },
      [`${t}-group-wrapper + ${t}-group-wrapper`]: {
        marginInlineStart: e.calc(e.lineWidth).mul(-1).equal(),
        [`${t}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${t}-group-wrapper:not(:last-child)`]: {
        [`&${t}-search > ${t}-group`]: {
          [`& > ${t}-group-addon > ${t}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${t}`]: {
            borderStartStartRadius: e.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: e.borderRadius
          }
        }
      }
    })
  };
}, Rue = (e) => {
  const {
    componentCls: t,
    controlHeightSM: r,
    lineWidth: n,
    calc: i
  } = e, a = i(r).sub(i(n).mul(2)).sub(16).div(2).equal();
  return {
    [t]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Fi(e)), j8(e)), yue(e)), wue(e)), Sue(e)), {
      '&[type="color"]': {
        height: e.controlHeight,
        [`&${t}-lg`]: {
          height: e.controlHeightLG
        },
        [`&${t}-sm`]: {
          height: r,
          paddingTop: a,
          paddingBottom: a
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        "-webkit-appearance": "none"
      }
    })
  };
}, _ue = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ========================= Input =========================
    [`${t}-clear-icon`]: {
      margin: 0,
      color: e.colorTextQuaternary,
      fontSize: e.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${e.motionDurationSlow}`,
      "&:hover": {
        color: e.colorTextTertiary
      },
      "&:active": {
        color: e.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${de(e.inputAffixPadding)}`
      }
    }
  };
}, Tue = (e) => {
  const {
    componentCls: t,
    inputAffixPadding: r,
    colorTextDescription: n,
    motionDurationSlow: i,
    colorIcon: o,
    colorIconHover: a,
    iconCls: s
  } = e;
  return {
    [`${t}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign({}, j8(e)), {
      display: "inline-flex",
      [`&:not(${t}-disabled):hover`]: {
        zIndex: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`> input${t}`]: {
        padding: 0
      },
      [`> input${t}, > textarea${t}`]: {
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        background: "transparent",
        color: "inherit",
        "&::-ms-reveal": {
          display: "none"
        },
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: e.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: n
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: e.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: r
        },
        "&-suffix": {
          marginInlineStart: r
        }
      }
    }), _ue(e)), {
      // password
      [`${s}${t}-password-icon`]: {
        color: o,
        cursor: "pointer",
        transition: `all ${i}`,
        "&:hover": {
          color: a
        }
      }
    })
  };
}, Pue = (e) => {
  const {
    componentCls: t,
    borderRadiusLG: r,
    borderRadiusSM: n
  } = e;
  return {
    [`${t}-group`]: Object.assign(Object.assign(Object.assign({}, Fi(e)), Eue(e)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": Object.assign(Object.assign(Object.assign({
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${t}-group-addon`]: {
            borderRadius: r,
            fontSize: e.inputFontSizeLG
          }
        },
        "&-sm": {
          [`${t}-group-addon`]: {
            borderRadius: n
          }
        }
      }, Cue(e)), bue(e)), {
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${t}-compact-first-item):not(${t}-compact-last-item)${t}-compact-item`]: {
          [`${t}, ${t}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${t}-compact-last-item)${t}-compact-first-item`]: {
          [`${t}, ${t}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${t}-compact-first-item)${t}-compact-last-item`]: {
          [`${t}, ${t}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${t}-compact-last-item)${t}-compact-item`]: {
          [`${t}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      })
    })
  };
}, Mue = (e) => {
  const {
    componentCls: t,
    antCls: r
  } = e, n = `${t}-search`;
  return {
    [n]: {
      [`${t}`]: {
        "&:hover, &:focus": {
          borderColor: e.colorPrimaryHover,
          [`+ ${t}-group-addon ${n}-button:not(${r}-btn-primary)`]: {
            borderInlineStartColor: e.colorPrimaryHover
          }
        }
      },
      [`${t}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${t}-lg`]: {
        lineHeight: e.calc(e.lineHeightLG).sub(2e-4).equal()
      },
      [`> ${t}-group`]: {
        [`> ${t}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${n}-button`]: {
            // Fix https://github.com/ant-design/ant-design/issues/47150
            marginInlineEnd: -1,
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: e.borderRadius,
            borderEndEndRadius: e.borderRadius,
            borderEndStartRadius: 0,
            boxShadow: "none"
          },
          [`${n}-button:not(${r}-btn-primary)`]: {
            color: e.colorTextDescription,
            "&:hover": {
              color: e.colorPrimaryHover
            },
            "&:active": {
              color: e.colorPrimaryActive
            },
            [`&${r}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${n}-button`]: {
        height: e.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${n}-button`]: {
        height: e.controlHeightLG
      },
      [`&-small ${n}-button`]: {
        height: e.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${t}-compact-item`]: {
        [`&:not(${t}-compact-last-item)`]: {
          [`${t}-group-addon`]: {
            [`${t}-search-button`]: {
              marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal(),
              borderRadius: 0
            }
          }
        },
        [`&:not(${t}-compact-first-item)`]: {
          [`${t},${t}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${t}-group-addon ${t}-search-button,
        > ${t},
        ${t}-affix-wrapper`]: {
          "&:hover, &:focus, &:active": {
            zIndex: 2
          }
        },
        [`> ${t}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
}, Due = (e) => {
  const {
    componentCls: t,
    paddingLG: r
  } = e, n = `${t}-textarea`;
  return {
    [n]: {
      position: "relative",
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${t}`]: {
          height: "100%"
        },
        [`${t}-data-count`]: {
          position: "absolute",
          bottom: e.calc(e.fontSize).mul(e.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: e.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      [`
        &-allow-clear > ${t},
        &-affix-wrapper${n}-has-feedback ${t}
      `]: {
        paddingInlineEnd: r
      },
      [`&-affix-wrapper${t}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${t}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          background: "transparent",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${t}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          // Clear Icon
          [`${t}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: e.paddingXS,
            insetBlockStart: e.paddingXS
          },
          // Feedback Icon
          [`${n}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: e.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      }
    }
  };
}, Aue = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-out-of-range`]: {
      [`&, & input, & textarea, ${t}-show-count-suffix, ${t}-data-count`]: {
        color: e.colorError
      }
    }
  };
}, cM = Gn("Input", (e) => {
  const t = Br(e, B8(e));
  return [
    Rue(t),
    Due(t),
    Tue(t),
    Pue(t),
    Mue(t),
    Aue(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    GP(t)
  ];
}, $8, {
  resetFont: !1
});
var Iue = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { tag: "path", attrs: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, name: "plus", theme: "outlined" }, Oue = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: Iue
  }));
}, U8 = /* @__PURE__ */ E.forwardRef(Oue);
process.env.NODE_ENV !== "production" && (U8.displayName = "PlusOutlined");
const AS = /* @__PURE__ */ du(null);
var Lue = function(t) {
  var r = t.activeTabOffset, n = t.horizontal, i = t.rtl, o = t.indicator, a = o === void 0 ? {} : o, s = a.size, l = a.align, u = l === void 0 ? "center" : l, c = Me(), d = ae(c, 2), h = d[0], f = d[1], p = se(), g = H.useCallback(function(m) {
    return typeof s == "function" ? s(m) : typeof s == "number" ? s : m;
  }, [s]);
  function v() {
    Ar.cancel(p.current);
  }
  return Nt(function() {
    var m = {};
    if (r)
      if (n) {
        m.width = g(r.width);
        var y = i ? "right" : "left";
        u === "start" && (m[y] = r[y]), u === "center" && (m[y] = r[y] + r.width / 2, m.transform = i ? "translateX(50%)" : "translateX(-50%)"), u === "end" && (m[y] = r[y] + r.width, m.transform = "translateX(-100%)");
      } else
        m.height = g(r.height), u === "start" && (m.top = r.top), u === "center" && (m.top = r.top + r.height / 2, m.transform = "translateY(-50%)"), u === "end" && (m.top = r.top + r.height, m.transform = "translateY(-100%)");
    return v(), p.current = Ar(function() {
      f(m);
    }), v;
  }, [r, n, i, u, g]), {
    style: h
  };
}, uL = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function Fue(e, t, r) {
  return Et(function() {
    for (var n, i = /* @__PURE__ */ new Map(), o = t.get((n = e[0]) === null || n === void 0 ? void 0 : n.key) || uL, a = o.left + o.width, s = 0; s < e.length; s += 1) {
      var l = e[s].key, u = t.get(l);
      if (!u) {
        var c;
        u = t.get((c = e[s - 1]) === null || c === void 0 ? void 0 : c.key) || uL;
      }
      var d = i.get(l) || ee({}, u);
      d.right = a - d.left - d.width, i.set(l, d);
    }
    return i;
  }, [e.map(function(n) {
    return n.key;
  }).join("_"), t, r]);
}
function cL(e, t) {
  var r = E.useRef(e), n = E.useState({}), i = ae(n, 2), o = i[1];
  function a(s) {
    var l = typeof s == "function" ? s(r.current) : s;
    l !== r.current && t(l, r.current), r.current = l, o({});
  }
  return [r.current, a];
}
var Nue = 0.1, dL = 0.01, e0 = 20, hL = Math.pow(0.995, e0);
function kue(e, t) {
  var r = Me(), n = ae(r, 2), i = n[0], o = n[1], a = Me(0), s = ae(a, 2), l = s[0], u = s[1], c = Me(0), d = ae(c, 2), h = d[0], f = d[1], p = Me(), g = ae(p, 2), v = g[0], m = g[1], y = se();
  function C(_) {
    var T = _.touches[0], P = T.screenX, D = T.screenY;
    o({
      x: P,
      y: D
    }), window.clearInterval(y.current);
  }
  function S(_) {
    if (i) {
      _.preventDefault();
      var T = _.touches[0], P = T.screenX, D = T.screenY;
      o({
        x: P,
        y: D
      });
      var O = P - i.x, A = D - i.y;
      t(O, A);
      var F = Date.now();
      u(F), f(F - l), m({
        x: O,
        y: A
      });
    }
  }
  function b() {
    if (i && (o(null), m(null), v)) {
      var _ = v.x / h, T = v.y / h, P = Math.abs(_), D = Math.abs(T);
      if (Math.max(P, D) < Nue) return;
      var O = _, A = T;
      y.current = window.setInterval(function() {
        if (Math.abs(O) < dL && Math.abs(A) < dL) {
          window.clearInterval(y.current);
          return;
        }
        O *= hL, A *= hL, t(O * e0, A * e0);
      }, e0);
    }
  }
  var w = se();
  function x(_) {
    var T = _.deltaX, P = _.deltaY, D = 0, O = Math.abs(T), A = Math.abs(P);
    O === A ? D = w.current === "x" ? T : P : O > A ? (D = T, w.current = "x") : (D = P, w.current = "y"), t(-D, -D) && _.preventDefault();
  }
  var R = se(null);
  R.current = {
    onTouchStart: C,
    onTouchMove: S,
    onTouchEnd: b,
    onWheel: x
  }, E.useEffect(function() {
    function _(O) {
      R.current.onTouchStart(O);
    }
    function T(O) {
      R.current.onTouchMove(O);
    }
    function P(O) {
      R.current.onTouchEnd(O);
    }
    function D(O) {
      R.current.onWheel(O);
    }
    return document.addEventListener("touchmove", T, {
      passive: !1
    }), document.addEventListener("touchend", P, {
      passive: !0
    }), e.current.addEventListener("touchstart", _, {
      passive: !0
    }), e.current.addEventListener("wheel", D, {
      passive: !1
    }), function() {
      document.removeEventListener("touchmove", T), document.removeEventListener("touchend", P);
    };
  }, []);
}
function K8(e) {
  var t = Me(0), r = ae(t, 2), n = r[0], i = r[1], o = se(0), a = se();
  return a.current = e, JE(function() {
    var s;
    (s = a.current) === null || s === void 0 || s.call(a);
  }, [n]), function() {
    o.current === n && (o.current += 1, i(o.current));
  };
}
function Vue(e) {
  var t = se([]), r = Me({}), n = ae(r, 2), i = n[1], o = se(typeof e == "function" ? e() : e), a = K8(function() {
    var l = o.current;
    t.current.forEach(function(u) {
      l = u(l);
    }), t.current = [], o.current = l, i({});
  });
  function s(l) {
    t.current.push(l), a();
  }
  return [o.current, s];
}
var fL = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function Bue(e, t, r, n, i, o, a) {
  var s = a.tabs, l = a.tabPosition, u = a.rtl, c, d, h;
  return ["top", "bottom"].includes(l) ? (c = "width", d = u ? "right" : "left", h = Math.abs(r)) : (c = "height", d = "top", h = -r), Et(function() {
    if (!s.length)
      return [0, 0];
    for (var f = s.length, p = f, g = 0; g < f; g += 1) {
      var v = e.get(s[g].key) || fL;
      if (v[d] + v[c] > h + t) {
        p = g - 1;
        break;
      }
    }
    for (var m = 0, y = f - 1; y >= 0; y -= 1) {
      var C = e.get(s[y].key) || fL;
      if (C[d] < h) {
        m = y + 1;
        break;
      }
    }
    return m >= p ? [0, 0] : [m, p];
  }, [e, t, n, i, o, h, l, s.map(function(f) {
    return f.key;
  }).join("_"), u]);
}
function pL(e) {
  var t;
  return e instanceof Map ? (t = {}, e.forEach(function(r, n) {
    t[n] = r;
  })) : t = e, JSON.stringify(t);
}
var $ue = "TABS_DQ";
function Y8(e) {
  return String(e).replace(/"/g, $ue);
}
function q8(e, t, r, n) {
  return (
    // Only editable tabs can be removed
    !(!r || // Tabs cannot be removed when disabled
    n || // closable is false
    e === !1 || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
    e === void 0 && (t === !1 || t === null))
  );
}
var X8 = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.editable, i = e.locale, o = e.style;
  return !n || n.showAdd === !1 ? null : /* @__PURE__ */ E.createElement("button", {
    ref: t,
    type: "button",
    className: "".concat(r, "-nav-add"),
    style: o,
    "aria-label": (i == null ? void 0 : i.addAriaLabel) || "Add tab",
    onClick: function(s) {
      n.onEdit("add", {
        event: s
      });
    }
  }, n.addIcon || "+");
}), WR = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.position, n = e.prefixCls, i = e.extra;
  if (!i)
    return null;
  var o, a = {};
  return vt(i) === "object" && !/* @__PURE__ */ E.isValidElement(i) ? a = i : a.right = i, r === "right" && (o = a.right), r === "left" && (o = a.left), o ? /* @__PURE__ */ E.createElement("div", {
    className: "".concat(n, "-extra-content"),
    ref: t
  }, o) : null;
});
process.env.NODE_ENV !== "production" && (WR.displayName = "ExtraContent");
var Hue = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.id, i = e.tabs, o = e.locale, a = e.mobile, s = e.more, l = s === void 0 ? {} : s, u = e.style, c = e.className, d = e.editable, h = e.tabBarGutter, f = e.rtl, p = e.removeAriaLabel, g = e.onTabClick, v = e.getPopupContainer, m = e.popupClassName, y = Me(!1), C = ae(y, 2), S = C[0], b = C[1], w = Me(null), x = ae(w, 2), R = x[0], _ = x[1], T = l.icon, P = T === void 0 ? "More" : T, D = "".concat(n, "-more-popup"), O = "".concat(r, "-dropdown"), A = R !== null ? "".concat(D, "-").concat(R) : null, F = o == null ? void 0 : o.dropdownAriaLabel;
  function L(k, z) {
    k.preventDefault(), k.stopPropagation(), d.onEdit("remove", {
      key: z,
      event: k
    });
  }
  var N = /* @__PURE__ */ E.createElement(Ev, {
    onClick: function(z) {
      var j = z.key, q = z.domEvent;
      g(j, q), b(!1);
    },
    prefixCls: "".concat(O, "-menu"),
    id: D,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": A,
    selectedKeys: [R],
    "aria-label": F !== void 0 ? F : "expanded dropdown"
  }, i.map(function(k) {
    var z = k.closable, j = k.disabled, q = k.closeIcon, K = k.key, Z = k.label, re = q8(z, q, d, j);
    return /* @__PURE__ */ E.createElement(MS, {
      key: K,
      id: "".concat(D, "-").concat(K),
      role: "option",
      "aria-controls": n && "".concat(n, "-panel-").concat(K),
      disabled: j
    }, /* @__PURE__ */ E.createElement("span", null, Z), re && /* @__PURE__ */ E.createElement("button", {
      type: "button",
      "aria-label": p || "remove",
      tabIndex: 0,
      className: "".concat(O, "-menu-item-remove"),
      onClick: function(Y) {
        Y.stopPropagation(), L(Y, K);
      }
    }, q || d.removeIcon || ""));
  }));
  function I(k) {
    for (var z = i.filter(function(re) {
      return !re.disabled;
    }), j = z.findIndex(function(re) {
      return re.key === R;
    }) || 0, q = z.length, K = 0; K < q; K += 1) {
      j = (j + k + q) % q;
      var Z = z[j];
      if (!Z.disabled) {
        _(Z.key);
        return;
      }
    }
  }
  function B(k) {
    var z = k.which;
    if (!S) {
      [Ae.DOWN, Ae.SPACE, Ae.ENTER].includes(z) && (b(!0), k.preventDefault());
      return;
    }
    switch (z) {
      case Ae.UP:
        I(-1), k.preventDefault();
        break;
      case Ae.DOWN:
        I(1), k.preventDefault();
        break;
      case Ae.ESC:
        b(!1);
        break;
      case Ae.SPACE:
      case Ae.ENTER:
        R !== null && g(R, k);
        break;
    }
  }
  Nt(function() {
    var k = document.getElementById(A);
    k && k.scrollIntoView && k.scrollIntoView(!1);
  }, [R]), Nt(function() {
    S || _(null);
  }, [S]);
  var M = te({}, f ? "marginRight" : "marginLeft", h);
  i.length || (M.visibility = "hidden", M.order = 1);
  var V = ue(te({}, "".concat(O, "-rtl"), f)), G = a ? null : /* @__PURE__ */ E.createElement(Mle, $e({
    prefixCls: O,
    overlay: N,
    visible: i.length ? S : !1,
    onVisibleChange: b,
    overlayClassName: ue(V, m),
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer: v
  }, l), /* @__PURE__ */ E.createElement("button", {
    type: "button",
    className: "".concat(r, "-nav-more"),
    style: M,
    tabIndex: -1,
    "aria-hidden": "true",
    "aria-haspopup": "listbox",
    "aria-controls": D,
    id: "".concat(n, "-more"),
    "aria-expanded": S,
    onKeyDown: B
  }, P));
  return /* @__PURE__ */ E.createElement("div", {
    className: ue("".concat(r, "-nav-operations"), c),
    style: u,
    ref: t
  }, G, /* @__PURE__ */ E.createElement(X8, {
    prefixCls: r,
    locale: o,
    editable: d
  }));
});
const Gue = /* @__PURE__ */ E.memo(Hue, function(e, t) {
  return (
    // https://github.com/ant-design/ant-design/issues/32544
    // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
    t.tabMoving
  );
});
var zue = function(t) {
  var r = t.prefixCls, n = t.id, i = t.active, o = t.tab, a = o.key, s = o.label, l = o.disabled, u = o.closeIcon, c = o.icon, d = t.closable, h = t.renderWrapper, f = t.removeAriaLabel, p = t.editable, g = t.onClick, v = t.onFocus, m = t.style, y = "".concat(r, "-tab"), C = q8(d, u, p, l);
  function S(R) {
    l || g(R);
  }
  function b(R) {
    R.preventDefault(), R.stopPropagation(), p.onEdit("remove", {
      key: a,
      event: R
    });
  }
  var w = E.useMemo(function() {
    return c && typeof s == "string" ? /* @__PURE__ */ E.createElement("span", null, s) : s;
  }, [s, c]), x = /* @__PURE__ */ E.createElement("div", {
    key: a,
    "data-node-key": Y8(a),
    className: ue(y, te(te(te({}, "".concat(y, "-with-remove"), C), "".concat(y, "-active"), i), "".concat(y, "-disabled"), l)),
    style: m,
    onClick: S
  }, /* @__PURE__ */ E.createElement("div", {
    role: "tab",
    "aria-selected": i,
    id: n && "".concat(n, "-tab-").concat(a),
    className: "".concat(y, "-btn"),
    "aria-controls": n && "".concat(n, "-panel-").concat(a),
    "aria-disabled": l,
    tabIndex: l ? null : 0,
    onClick: function(_) {
      _.stopPropagation(), S(_);
    },
    onKeyDown: function(_) {
      [Ae.SPACE, Ae.ENTER].includes(_.which) && (_.preventDefault(), S(_));
    },
    onFocus: v
  }, c && /* @__PURE__ */ E.createElement("span", {
    className: "".concat(y, "-icon")
  }, c), s && w), C && /* @__PURE__ */ E.createElement("button", {
    type: "button",
    "aria-label": f || "remove",
    tabIndex: 0,
    className: "".concat(y, "-remove"),
    onClick: function(_) {
      _.stopPropagation(), b(_);
    }
  }, u || p.removeIcon || ""));
  return h ? h(x) : x;
}, Wue = function(t, r) {
  var n = t.offsetWidth, i = t.offsetHeight, o = t.offsetTop, a = t.offsetLeft, s = t.getBoundingClientRect(), l = s.width, u = s.height, c = s.x, d = s.y;
  return Math.abs(l - n) < 1 ? [l, u, c - r.x, d - r.y] : [n, i, a, o];
}, Pd = function(t) {
  var r = t.current || {}, n = r.offsetWidth, i = n === void 0 ? 0 : n, o = r.offsetHeight, a = o === void 0 ? 0 : o;
  if (t.current) {
    var s = t.current.getBoundingClientRect(), l = s.width, u = s.height;
    if (Math.abs(l - i) < 1)
      return [l, u];
  }
  return [i, a];
}, wm = function(t, r) {
  return t[r ? 0 : 1];
}, gL = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.className, n = e.style, i = e.id, o = e.animated, a = e.activeKey, s = e.rtl, l = e.extra, u = e.editable, c = e.locale, d = e.tabPosition, h = e.tabBarGutter, f = e.children, p = e.onTabClick, g = e.onTabScroll, v = e.indicator, m = E.useContext(AS), y = m.prefixCls, C = m.tabs, S = se(null), b = se(null), w = se(null), x = se(null), R = se(null), _ = se(null), T = se(null), P = d === "top" || d === "bottom", D = cL(0, function(ye, me) {
    P && g && g({
      direction: ye > me ? "left" : "right"
    });
  }), O = ae(D, 2), A = O[0], F = O[1], L = cL(0, function(ye, me) {
    !P && g && g({
      direction: ye > me ? "top" : "bottom"
    });
  }), N = ae(L, 2), I = N[0], B = N[1], M = Me([0, 0]), V = ae(M, 2), G = V[0], k = V[1], z = Me([0, 0]), j = ae(z, 2), q = j[0], K = j[1], Z = Me([0, 0]), re = ae(Z, 2), X = re[0], Y = re[1], U = Me([0, 0]), oe = ae(U, 2), W = oe[0], ne = oe[1], ce = Vue(/* @__PURE__ */ new Map()), we = ae(ce, 2), Re = we[0], ve = we[1], xe = Fue(C, Re, q[0]), _e = wm(G, P), Ve = wm(q, P), Fe = wm(X, P), Ne = wm(W, P), Je = _e < Ve + Fe, J = Je ? _e - Ne : _e - Fe, he = "".concat(y, "-nav-operations-hidden"), Le = 0, Pe = 0;
  P && s ? (Le = 0, Pe = Math.max(0, Ve - J)) : (Le = Math.min(0, J - Ve), Pe = 0);
  function Ie(ye) {
    return ye < Le ? Le : ye > Pe ? Pe : ye;
  }
  var Ce = se(null), De = Me(), ze = ae(De, 2), st = ze[0], Tt = ze[1];
  function ot() {
    Tt(Date.now());
  }
  function Xe() {
    Ce.current && clearTimeout(Ce.current);
  }
  kue(x, function(ye, me) {
    function Ue(pt, gt) {
      pt(function(yt) {
        var Rt = Ie(yt + gt);
        return Rt;
      });
    }
    return Je ? (P ? Ue(F, ye) : Ue(B, me), Xe(), ot(), !0) : !1;
  }), Nt(function() {
    return Xe(), st && (Ce.current = setTimeout(function() {
      Tt(0);
    }, 100)), Xe;
  }, [st]);
  var Oe = Bue(
    xe,
    // Container
    J,
    // Transform
    P ? A : I,
    // Tabs
    Ve,
    // Add
    Fe,
    // Operation
    Ne,
    ee(ee({}, e), {}, {
      tabs: C
    })
  ), Qe = ae(Oe, 2), ft = Qe[0], xt = Qe[1], $r = An(function() {
    var ye = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : a, me = xe.get(ye) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (P) {
      var Ue = A;
      s ? me.right < A ? Ue = me.right : me.right + me.width > A + J && (Ue = me.right + me.width - J) : me.left < -A ? Ue = -me.left : me.left + me.width > -A + J && (Ue = -(me.left + me.width - J)), B(0), F(Ie(Ue));
    } else {
      var pt = I;
      me.top < -I ? pt = -me.top : me.top + me.height > -I + J && (pt = -(me.top + me.height - J)), F(0), B(Ie(pt));
    }
  }), hr = {};
  d === "top" || d === "bottom" ? hr[s ? "marginRight" : "marginLeft"] = h : hr.marginTop = h;
  var Gt = C.map(function(ye, me) {
    var Ue = ye.key;
    return /* @__PURE__ */ E.createElement(zue, {
      id: i,
      prefixCls: y,
      key: Ue,
      tab: ye,
      style: me === 0 ? void 0 : hr,
      closable: ye.closable,
      editable: u,
      active: Ue === a,
      renderWrapper: f,
      removeAriaLabel: c == null ? void 0 : c.removeAriaLabel,
      onClick: function(gt) {
        p(Ue, gt);
      },
      onFocus: function() {
        $r(Ue), ot(), x.current && (s || (x.current.scrollLeft = 0), x.current.scrollTop = 0);
      }
    });
  }), Ot = function() {
    return ve(function() {
      var me, Ue = /* @__PURE__ */ new Map(), pt = (me = R.current) === null || me === void 0 ? void 0 : me.getBoundingClientRect();
      return C.forEach(function(gt) {
        var yt, Rt = gt.key, et = (yt = R.current) === null || yt === void 0 ? void 0 : yt.querySelector('[data-node-key="'.concat(Y8(Rt), '"]'));
        if (et) {
          var Ke = Wue(et, pt), rt = ae(Ke, 4), er = rt[0], Xr = rt[1], Rn = rt[2], wr = rt[3];
          Ue.set(Rt, {
            width: er,
            height: Xr,
            left: Rn,
            top: wr
          });
        }
      }), Ue;
    });
  };
  Nt(function() {
    Ot();
  }, [C.map(function(ye) {
    return ye.key;
  }).join("_")]);
  var Lt = K8(function() {
    var ye = Pd(S), me = Pd(b), Ue = Pd(w);
    k([ye[0] - me[0] - Ue[0], ye[1] - me[1] - Ue[1]]);
    var pt = Pd(T);
    Y(pt);
    var gt = Pd(_);
    ne(gt);
    var yt = Pd(R);
    K([yt[0] - pt[0], yt[1] - pt[1]]), Ot();
  }), mt = C.slice(0, ft), qe = C.slice(xt + 1), zt = [].concat(it(mt), it(qe)), fr = xe.get(a), Ge = Lue({
    activeTabOffset: fr,
    horizontal: P,
    indicator: v,
    rtl: s
  }), Ze = Ge.style;
  Nt(function() {
    $r();
  }, [a, Le, Pe, pL(fr), pL(xe), P]), Nt(function() {
    Lt();
  }, [s]);
  var tt = !!zt.length, ht = "".concat(y, "-nav-wrap"), It, qt, Hr, Q;
  return P ? s ? (qt = A > 0, It = A !== Pe) : (It = A < 0, qt = A !== Le) : (Hr = I < 0, Q = I !== Le), /* @__PURE__ */ E.createElement(Co, {
    onResize: Lt
  }, /* @__PURE__ */ E.createElement("div", {
    ref: Qc(t, S),
    role: "tablist",
    className: ue("".concat(y, "-nav"), r),
    style: n,
    onKeyDown: function() {
      ot();
    }
  }, /* @__PURE__ */ E.createElement(WR, {
    ref: b,
    position: "left",
    extra: l,
    prefixCls: y
  }), /* @__PURE__ */ E.createElement(Co, {
    onResize: Lt
  }, /* @__PURE__ */ E.createElement("div", {
    className: ue(ht, te(te(te(te({}, "".concat(ht, "-ping-left"), It), "".concat(ht, "-ping-right"), qt), "".concat(ht, "-ping-top"), Hr), "".concat(ht, "-ping-bottom"), Q)),
    ref: x
  }, /* @__PURE__ */ E.createElement(Co, {
    onResize: Lt
  }, /* @__PURE__ */ E.createElement("div", {
    ref: R,
    className: "".concat(y, "-nav-list"),
    style: {
      transform: "translate(".concat(A, "px, ").concat(I, "px)"),
      transition: st ? "none" : void 0
    }
  }, Gt, /* @__PURE__ */ E.createElement(X8, {
    ref: T,
    prefixCls: y,
    locale: c,
    editable: u,
    style: ee(ee({}, Gt.length === 0 ? void 0 : hr), {}, {
      visibility: tt ? "hidden" : null
    })
  }), /* @__PURE__ */ E.createElement("div", {
    className: ue("".concat(y, "-ink-bar"), te({}, "".concat(y, "-ink-bar-animated"), o.inkBar)),
    style: Ze
  }))))), /* @__PURE__ */ E.createElement(Gue, $e({}, e, {
    removeAriaLabel: c == null ? void 0 : c.removeAriaLabel,
    ref: _,
    prefixCls: y,
    tabs: zt,
    className: !tt && he,
    tabMoving: !!st
  })), /* @__PURE__ */ E.createElement(WR, {
    ref: w,
    position: "right",
    extra: l,
    prefixCls: y
  })));
}), dM = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.className, i = e.style, o = e.id, a = e.active, s = e.tabKey, l = e.children;
  return /* @__PURE__ */ E.createElement("div", {
    id: o && "".concat(o, "-panel-").concat(s),
    role: "tabpanel",
    tabIndex: a ? 0 : -1,
    "aria-labelledby": o && "".concat(o, "-tab-").concat(s),
    "aria-hidden": !a,
    style: i,
    className: ue(r, a && "".concat(r, "-active"), n),
    ref: t
  }, l);
});
process.env.NODE_ENV !== "production" && (dM.displayName = "TabPane");
var jue = ["renderTabBar"], Uue = ["label", "key"], Z8 = function(t) {
  var r = t.renderTabBar, n = $t(t, jue), i = E.useContext(AS), o = i.tabs;
  if (r) {
    var a = ee(ee({}, n), {}, {
      // Legacy support. We do not use this actually
      panes: o.map(function(s) {
        var l = s.label, u = s.key, c = $t(s, Uue);
        return /* @__PURE__ */ E.createElement(dM, $e({
          tab: l,
          key: u,
          tabKey: u
        }, c));
      })
    });
    return r(a, gL);
  }
  return /* @__PURE__ */ E.createElement(gL, n);
};
process.env.NODE_ENV !== "production" && (Z8.displayName = "TabNavListWrapper");
var Kue = ["key", "forceRender", "style", "className", "destroyInactiveTabPane"], Yue = function(t) {
  var r = t.id, n = t.activeKey, i = t.animated, o = t.tabPosition, a = t.destroyInactiveTabPane, s = E.useContext(AS), l = s.prefixCls, u = s.tabs, c = i.tabPane, d = "".concat(l, "-tabpane");
  return /* @__PURE__ */ E.createElement("div", {
    className: ue("".concat(l, "-content-holder"))
  }, /* @__PURE__ */ E.createElement("div", {
    className: ue("".concat(l, "-content"), "".concat(l, "-content-").concat(o), te({}, "".concat(l, "-content-animated"), c))
  }, u.map(function(h) {
    var f = h.key, p = h.forceRender, g = h.style, v = h.className, m = h.destroyInactiveTabPane, y = $t(h, Kue), C = f === n;
    return /* @__PURE__ */ E.createElement(Cs, $e({
      key: f,
      visible: C,
      forceRender: p,
      removeOnLeave: !!(a || m),
      leavedClassName: "".concat(d, "-hidden")
    }, i.tabPaneMotion), function(S, b) {
      var w = S.style, x = S.className;
      return /* @__PURE__ */ E.createElement(dM, $e({}, y, {
        prefixCls: d,
        id: r,
        tabKey: f,
        animated: c,
        active: C,
        style: ee(ee({}, g), w),
        className: ue(v, x),
        ref: b
      }));
    });
  })));
};
function que() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    inkBar: !0,
    tabPane: !1
  }, t;
  return e === !1 ? t = {
    inkBar: !1,
    tabPane: !1
  } : e === !0 ? t = {
    inkBar: !0,
    tabPane: !1
  } : t = ee({
    inkBar: !0
  }, vt(e) === "object" ? e : {}), t.tabPaneMotion && t.tabPane === void 0 && (t.tabPane = !0), !t.tabPaneMotion && t.tabPane && (process.env.NODE_ENV !== "production" && Qt(!1, "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work."), t.tabPane = !1), t;
}
var Xue = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "more", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName", "indicator"], vL = 0, Q8 = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.id, n = e.prefixCls, i = n === void 0 ? "rc-tabs" : n, o = e.className, a = e.items, s = e.direction, l = e.activeKey, u = e.defaultActiveKey, c = e.editable, d = e.animated, h = e.tabPosition, f = h === void 0 ? "top" : h, p = e.tabBarGutter, g = e.tabBarStyle, v = e.tabBarExtraContent, m = e.locale, y = e.more, C = e.destroyInactiveTabPane, S = e.renderTabBar, b = e.onChange, w = e.onTabClick, x = e.onTabScroll, R = e.getPopupContainer, _ = e.popupClassName, T = e.indicator, P = $t(e, Xue), D = E.useMemo(function() {
    return (a || []).filter(function(W) {
      return W && vt(W) === "object" && "key" in W;
    });
  }, [a]), O = s === "rtl", A = que(d), F = Me(!1), L = ae(F, 2), N = L[0], I = L[1];
  Nt(function() {
    I(WP());
  }, []);
  var B = xn(function() {
    var W;
    return (W = D[0]) === null || W === void 0 ? void 0 : W.key;
  }, {
    value: l,
    defaultValue: u
  }), M = ae(B, 2), V = M[0], G = M[1], k = Me(function() {
    return D.findIndex(function(W) {
      return W.key === V;
    });
  }), z = ae(k, 2), j = z[0], q = z[1];
  Nt(function() {
    var W = D.findIndex(function(ce) {
      return ce.key === V;
    });
    if (W === -1) {
      var ne;
      W = Math.max(0, Math.min(j, D.length - 1)), G((ne = D[W]) === null || ne === void 0 ? void 0 : ne.key);
    }
    q(W);
  }, [D.map(function(W) {
    return W.key;
  }).join("_"), V, j]);
  var K = xn(null, {
    value: r
  }), Z = ae(K, 2), re = Z[0], X = Z[1];
  Nt(function() {
    r || (X("rc-tabs-".concat(process.env.NODE_ENV === "test" ? "test" : vL)), vL += 1);
  }, []);
  function Y(W, ne) {
    w == null || w(W, ne);
    var ce = W !== V;
    G(W), ce && (b == null || b(W));
  }
  var U = {
    id: re,
    activeKey: V,
    animated: A,
    tabPosition: f,
    rtl: O,
    mobile: N
  }, oe = ee(ee({}, U), {}, {
    editable: c,
    locale: m,
    more: y,
    tabBarGutter: p,
    onTabClick: Y,
    onTabScroll: x,
    extra: v,
    style: g,
    panes: null,
    getPopupContainer: R,
    popupClassName: _,
    indicator: T
  });
  return /* @__PURE__ */ E.createElement(AS.Provider, {
    value: {
      tabs: D,
      prefixCls: i
    }
  }, /* @__PURE__ */ E.createElement("div", $e({
    ref: t,
    id: r,
    className: ue(i, "".concat(i, "-").concat(f), te(te(te({}, "".concat(i, "-mobile"), N), "".concat(i, "-editable"), c), "".concat(i, "-rtl"), O), o)
  }, P), /* @__PURE__ */ E.createElement(Z8, $e({}, oe, {
    renderTabBar: S
  })), /* @__PURE__ */ E.createElement(Yue, $e({
    destroyInactiveTabPane: C
  }, U, {
    animated: A
  }))));
});
process.env.NODE_ENV !== "production" && (Q8.displayName = "Tabs");
const Zue = {
  motionAppear: !1,
  motionEnter: !0,
  motionLeave: !0
};
function Que(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inkBar: !0,
    tabPane: !1
  }, r;
  return t === !1 ? r = {
    inkBar: !1,
    tabPane: !1
  } : t === !0 ? r = {
    inkBar: !0,
    tabPane: !0
  } : r = Object.assign({
    inkBar: !0
  }, typeof t == "object" ? t : {}), r.tabPane && (r.tabPaneMotion = Object.assign(Object.assign({}, Zue), {
    motionName: Ql(e, "switch")
  })), r;
}
var Jue = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function ece(e) {
  return e.filter((t) => t);
}
function tce(e, t) {
  if (process.env.NODE_ENV !== "production" && en("Tabs").deprecated(!t, "Tabs.TabPane", "items"), e)
    return e;
  const r = Zo(t).map((n) => {
    if (/* @__PURE__ */ E.isValidElement(n)) {
      const {
        key: i,
        props: o
      } = n, a = o || {}, {
        tab: s
      } = a, l = Jue(a, ["tab"]);
      return Object.assign(Object.assign({
        key: String(i)
      }, l), {
        label: s
      });
    }
    return null;
  });
  return ece(r);
}
const rce = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: r
  } = e;
  return [
    {
      [t]: {
        [`${t}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${r}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${r}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [N0(e, "slide-up"), N0(e, "slide-down")]
  ];
}, nce = (e) => {
  const {
    componentCls: t,
    tabsCardPadding: r,
    cardBg: n,
    cardGutter: i,
    colorBorderSecondary: o,
    itemSelectedColor: a
  } = e;
  return {
    [`${t}-card`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-tab`]: {
          margin: 0,
          padding: r,
          background: n,
          border: `${de(e.lineWidth)} ${e.lineType} ${o}`,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`
        },
        [`${t}-tab-active`]: {
          color: a,
          background: e.colorBgContainer
        },
        [`${t}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${t}-top, &${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginLeft: {
              _skip_check_: !0,
              value: de(i)
            }
          }
        }
      },
      [`&${t}-top`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)} 0 0`
          },
          [`${t}-tab-active`]: {
            borderBottomColor: e.colorBgContainer
          }
        }
      },
      [`&${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `0 0 ${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)}`
          },
          [`${t}-tab-active`]: {
            borderTopColor: e.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${t}-left, &${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginTop: de(i)
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${de(e.borderRadiusLG)} 0 0 ${de(e.borderRadiusLG)}`
            }
          },
          [`${t}-tab-active`]: {
            borderRightColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)} 0`
            }
          },
          [`${t}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      }
    }
  };
}, ice = (e) => {
  const {
    componentCls: t,
    itemHoverColor: r,
    dropdownEdgeChildVerticalPadding: n
  } = e;
  return {
    [`${t}-dropdown`]: Object.assign(Object.assign({}, Fi(e)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: !0,
        value: -9999
      },
      zIndex: e.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${t}-dropdown-menu`]: {
        maxHeight: e.tabsDropdownHeight,
        margin: 0,
        padding: `${de(n)} 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: !0,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: e.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        "&-item": Object.assign(Object.assign({}, Xl), {
          display: "flex",
          alignItems: "center",
          minWidth: e.tabsDropdownWidth,
          margin: 0,
          padding: `${de(e.paddingXXS)} ${de(e.paddingSM)}`,
          color: e.colorText,
          fontWeight: "normal",
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          cursor: "pointer",
          transition: `all ${e.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: !0,
              value: e.marginSM
            },
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: r
            }
          },
          "&:hover": {
            background: e.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: e.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
}, oce = (e) => {
  const {
    componentCls: t,
    margin: r,
    colorBorderSecondary: n,
    horizontalMargin: i,
    verticalItemPadding: o,
    verticalItemMargin: a,
    calc: s
  } = e;
  return {
    // ========================== Top & Bottom ==========================
    [`${t}-top, ${t}-bottom`]: {
      flexDirection: "column",
      [`> ${t}-nav, > div > ${t}-nav`]: {
        margin: i,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: !0,
            value: 0
          },
          left: {
            _skip_check_: !0,
            value: 0
          },
          borderBottom: `${de(e.lineWidth)} ${e.lineType} ${n}`,
          content: "''"
        },
        [`${t}-ink-bar`]: {
          height: e.lineWidthBold,
          "&-animated": {
            transition: `width ${e.motionDurationSlow}, left ${e.motionDurationSlow},
            right ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: e.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowRight
          },
          [`&${t}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${t}-top`]: {
      [`> ${t}-nav,
        > div > ${t}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${t}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${t}-bottom`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        marginTop: r,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${t}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${t}-left, ${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        flexDirection: "column",
        minWidth: s(e.controlHeight).mul(1.25).equal(),
        // >>>>>>>>>>> Tab
        [`${t}-tab`]: {
          padding: o,
          textAlign: "center"
        },
        [`${t}-tab + ${t}-tab`]: {
          margin: a
        },
        // >>>>>>>>>>> Nav
        [`${t}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: e.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: e.boxShadowTabsOverflowBottom
          },
          [`&${t}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${t}-ink-bar`]: {
          width: e.lineWidthBold,
          "&-animated": {
            transition: `height ${e.motionDurationSlow}, top ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-list, ${t}-nav-operations`]: {
          flex: "1 0 auto",
          // fix safari scroll problem
          flexDirection: "column"
        }
      }
    },
    [`${t}-left`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-ink-bar`]: {
          right: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        marginLeft: {
          _skip_check_: !0,
          value: de(s(e.lineWidth).mul(-1).equal())
        },
        borderLeft: {
          _skip_check_: !0,
          value: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingLeft: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    },
    [`${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        [`${t}-ink-bar`]: {
          left: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: !0,
          value: s(e.lineWidth).mul(-1).equal()
        },
        borderRight: {
          _skip_check_: !0,
          value: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingRight: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    }
  };
}, ace = (e) => {
  const {
    componentCls: t,
    cardPaddingSM: r,
    cardPaddingLG: n,
    horizontalItemPaddingSM: i,
    horizontalItemPaddingLG: o
  } = e;
  return {
    [t]: {
      "&-small": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: i,
            fontSize: e.titleFontSizeSM
          }
        }
      },
      "&-large": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: o,
            fontSize: e.titleFontSizeLG
          }
        }
      }
    },
    [`${t}-card`]: {
      [`&${t}-small`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: r
          }
        },
        [`&${t}-bottom`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `0 0 ${de(e.borderRadius)} ${de(e.borderRadius)}`
          }
        },
        [`&${t}-top`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `${de(e.borderRadius)} ${de(e.borderRadius)} 0 0`
          }
        },
        [`&${t}-right`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${de(e.borderRadius)} ${de(e.borderRadius)} 0`
            }
          }
        },
        [`&${t}-left`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${de(e.borderRadius)} 0 0 ${de(e.borderRadius)}`
            }
          }
        }
      },
      [`&${t}-large`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: n
          }
        }
      }
    }
  };
}, sce = (e) => {
  const {
    componentCls: t,
    itemActiveColor: r,
    itemHoverColor: n,
    iconCls: i,
    tabsHorizontalItemMargin: o,
    horizontalItemPadding: a,
    itemSelectedColor: s,
    itemColor: l
  } = e, u = `${t}-tab`;
  return {
    [u]: {
      position: "relative",
      WebkitTouchCallout: "none",
      WebkitTapHighlightColor: "transparent",
      display: "inline-flex",
      alignItems: "center",
      padding: a,
      fontSize: e.titleFontSize,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      color: l,
      "&-btn, &-remove": Object.assign({
        "&:focus:not(:focus-visible), &:active": {
          color: r
        }
      }, pS(e)),
      "&-btn": {
        outline: "none",
        transition: `all ${e.motionDurationSlow}`,
        [`${u}-icon:not(:last-child)`]: {
          marginInlineEnd: e.marginSM
        }
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: !0,
          value: e.calc(e.marginXXS).mul(-1).equal()
        },
        marginLeft: {
          _skip_check_: !0,
          value: e.marginXS
        },
        color: e.colorTextDescription,
        fontSize: e.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      "&:hover": {
        color: n
      },
      [`&${u}-active ${u}-btn`]: {
        color: s,
        textShadow: e.tabsActiveTextShadow
      },
      [`&${u}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${u}-disabled ${u}-btn, &${u}-disabled ${t}-remove`]: {
        "&:focus, &:active": {
          color: e.colorTextDisabled
        }
      },
      [`& ${u}-remove ${i}`]: {
        margin: 0
      },
      [`${i}:not(:last-child)`]: {
        marginRight: {
          _skip_check_: !0,
          value: e.marginSM
        }
      }
    },
    [`${u} + ${u}`]: {
      margin: {
        _skip_check_: !0,
        value: o
      }
    }
  };
}, lce = (e) => {
  const {
    componentCls: t,
    tabsHorizontalItemMarginRTL: r,
    iconCls: n,
    cardGutter: i,
    calc: o
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl",
      [`${t}-nav`]: {
        [`${t}-tab`]: {
          margin: {
            _skip_check_: !0,
            value: r
          },
          [`${t}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          },
          [n]: {
            marginRight: {
              _skip_check_: !0,
              value: 0
            },
            marginLeft: {
              _skip_check_: !0,
              value: de(e.marginSM)
            }
          },
          [`${t}-tab-remove`]: {
            marginRight: {
              _skip_check_: !0,
              value: de(e.marginXS)
            },
            marginLeft: {
              _skip_check_: !0,
              value: de(o(e.marginXXS).mul(-1).equal())
            },
            [n]: {
              margin: 0
            }
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav`]: {
          order: 1
        },
        [`> ${t}-content-holder`]: {
          order: 0
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav`]: {
          order: 0
        },
        [`> ${t}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${t}-card${t}-top, &${t}-card${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginRight: {
              _skip_check_: !0,
              value: i
            },
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          }
        }
      }
    },
    [`${t}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${t}-menu-item`]: {
      [`${t}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: !0,
          value: "right"
        }
      }
    }
  };
}, uce = (e) => {
  const {
    componentCls: t,
    tabsCardPadding: r,
    cardHeight: n,
    cardGutter: i,
    itemHoverColor: o,
    itemActiveColor: a,
    colorBorderSecondary: s
  } = e;
  return {
    [t]: Object.assign(Object.assign(Object.assign(Object.assign({}, Fi(e)), {
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${t}-nav, > div > ${t}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${t}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // Fix chrome render bug
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${e.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${t}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${e.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${t}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${t}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${t}-nav-more`]: {
          position: "relative",
          padding: r,
          background: "transparent",
          border: 0,
          color: e.colorText,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: !0,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.calc(e.controlHeightLG).div(8).equal(),
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${t}-nav-add`]: Object.assign({
          minWidth: n,
          minHeight: n,
          marginLeft: {
            _skip_check_: !0,
            value: i
          },
          padding: `0 ${de(e.paddingXS)}`,
          background: "transparent",
          border: `${de(e.lineWidth)} ${e.lineType} ${s}`,
          borderRadius: `${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)} 0 0`,
          outline: "none",
          cursor: "pointer",
          color: e.colorText,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`,
          "&:hover": {
            color: o
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: a
          }
        }, pS(e))
      },
      [`${t}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${t}-ink-bar`]: {
        position: "absolute",
        background: e.inkBarColor,
        pointerEvents: "none"
      }
    }), sce(e)), {
      // =========================== TabPanes ===========================
      [`${t}-content`]: {
        position: "relative",
        width: "100%"
      },
      [`${t}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${t}-tabpane`]: {
        outline: "none",
        "&-hidden": {
          display: "none"
        }
      }
    }),
    [`${t}-centered`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-nav-wrap`]: {
          [`&:not([class*='${t}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
}, cce = (e) => {
  const t = e.controlHeightLG;
  return {
    zIndexPopup: e.zIndexPopupBase + 50,
    cardBg: e.colorFillAlter,
    cardHeight: t,
    // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
    cardPadding: `${(t - Math.round(e.fontSize * e.lineHeight)) / 2 - e.lineWidth}px ${e.padding}px`,
    cardPaddingSM: `${e.paddingXXS * 1.5}px ${e.padding}px`,
    cardPaddingLG: `${e.paddingXS}px ${e.padding}px ${e.paddingXXS * 1.5}px`,
    titleFontSize: e.fontSize,
    titleFontSizeLG: e.fontSizeLG,
    titleFontSizeSM: e.fontSize,
    inkBarColor: e.colorPrimary,
    horizontalMargin: `0 0 ${e.margin}px 0`,
    horizontalItemGutter: 32,
    // Fixed Value
    // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
    horizontalItemMargin: "",
    horizontalItemMarginRTL: "",
    horizontalItemPadding: `${e.paddingSM}px 0`,
    horizontalItemPaddingSM: `${e.paddingXS}px 0`,
    horizontalItemPaddingLG: `${e.padding}px 0`,
    verticalItemPadding: `${e.paddingXS}px ${e.paddingLG}px`,
    verticalItemMargin: `${e.margin}px 0 0 0`,
    itemColor: e.colorText,
    itemSelectedColor: e.colorPrimary,
    itemHoverColor: e.colorPrimaryHover,
    itemActiveColor: e.colorPrimaryActive,
    cardGutter: e.marginXXS / 2
  };
}, dce = Gn("Tabs", (e) => {
  const t = Br(e, {
    // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
    tabsCardPadding: e.cardPadding,
    dropdownEdgeChildVerticalPadding: e.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120,
    tabsHorizontalItemMargin: `0 0 0 ${de(e.horizontalItemGutter)}`,
    tabsHorizontalItemMarginRTL: `0 0 0 ${de(e.horizontalItemGutter)}`
  });
  return [ace(t), lce(t), oce(t), ice(t), nce(t), uce(t), rce(t)];
}, cce), J8 = () => null;
process.env.NODE_ENV !== "production" && (J8.displayName = "DeprecatedTabPane");
var hce = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const hM = (e) => {
  var t, r, n, i, o, a, s, l, u, c, d;
  const {
    type: h,
    className: f,
    rootClassName: p,
    size: g,
    onEdit: v,
    hideAdd: m,
    centered: y,
    addIcon: C,
    removeIcon: S,
    moreIcon: b,
    more: w,
    popupClassName: x,
    children: R,
    items: _,
    animated: T,
    style: P,
    indicatorSize: D,
    indicator: O
  } = e, A = hce(e, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "removeIcon", "moreIcon", "more", "popupClassName", "children", "items", "animated", "style", "indicatorSize", "indicator"]), {
    prefixCls: F
  } = A, {
    direction: L,
    tabs: N,
    getPrefixCls: I,
    getPopupContainer: B
  } = E.useContext(Yt), M = I("tabs", F), V = ed(M), [G, k, z] = dce(M, V);
  let j;
  h === "editable-card" && (j = {
    onEdit: (U, oe) => {
      let {
        key: W,
        event: ne
      } = oe;
      v == null || v(U === "add" ? ne : W, U);
    },
    removeIcon: (t = S ?? (N == null ? void 0 : N.removeIcon)) !== null && t !== void 0 ? t : /* @__PURE__ */ E.createElement(uf, null),
    addIcon: (C ?? (N == null ? void 0 : N.addIcon)) || /* @__PURE__ */ E.createElement(U8, null),
    showAdd: m !== !0
  });
  const q = I();
  if (process.env.NODE_ENV !== "production") {
    const U = en("Tabs");
    process.env.NODE_ENV !== "production" && U(!("onPrevClick" in e) && !("onNextClick" in e), "breaking", "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead."), process.env.NODE_ENV !== "production" && U(!(D || N != null && N.indicatorSize), "deprecated", "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead.");
  }
  const K = sl(g), Z = tce(_, R), re = Que(M, T), X = Object.assign(Object.assign({}, N == null ? void 0 : N.style), P), Y = {
    align: (r = O == null ? void 0 : O.align) !== null && r !== void 0 ? r : (n = N == null ? void 0 : N.indicator) === null || n === void 0 ? void 0 : n.align,
    size: (s = (o = (i = O == null ? void 0 : O.size) !== null && i !== void 0 ? i : D) !== null && o !== void 0 ? o : (a = N == null ? void 0 : N.indicator) === null || a === void 0 ? void 0 : a.size) !== null && s !== void 0 ? s : N == null ? void 0 : N.indicatorSize
  };
  return G(/* @__PURE__ */ E.createElement(Q8, Object.assign({
    direction: L,
    getPopupContainer: B
  }, A, {
    items: Z,
    className: ue({
      [`${M}-${K}`]: K,
      [`${M}-card`]: ["card", "editable-card"].includes(h),
      [`${M}-editable-card`]: h === "editable-card",
      [`${M}-centered`]: y
    }, N == null ? void 0 : N.className, f, p, k, z, V),
    popupClassName: ue(x, k, z, V),
    style: X,
    editable: j,
    more: Object.assign({
      icon: (d = (c = (u = (l = N == null ? void 0 : N.more) === null || l === void 0 ? void 0 : l.icon) !== null && u !== void 0 ? u : N == null ? void 0 : N.moreIcon) !== null && c !== void 0 ? c : b) !== null && d !== void 0 ? d : /* @__PURE__ */ E.createElement(F8, null),
      transitionName: `${q}-slide-up`
    }, w),
    prefixCls: M,
    animated: re,
    indicator: Y
  })));
};
hM.TabPane = J8;
process.env.NODE_ENV !== "production" && (hM.displayName = "Tabs");
var fce = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const e3 = (e) => {
  var {
    prefixCls: t,
    className: r,
    hoverable: n = !0
  } = e, i = fce(e, ["prefixCls", "className", "hoverable"]);
  const {
    getPrefixCls: o
  } = E.useContext(Yt), a = o("card", t), s = ue(`${a}-grid`, r, {
    [`${a}-grid-hoverable`]: n
  });
  return /* @__PURE__ */ E.createElement("div", Object.assign({}, i, {
    className: s
  }));
}, pce = (e) => {
  const {
    antCls: t,
    componentCls: r,
    headerHeight: n,
    cardPaddingBase: i,
    tabsMarginBottom: o
  } = e;
  return Object.assign(Object.assign({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: n,
    marginBottom: -1,
    padding: `0 ${de(i)}`,
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.headerFontSize,
    background: e.headerBg,
    borderBottom: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorderSecondary}`,
    borderRadius: `${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)} 0 0`
  }, mv()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": Object.assign(Object.assign({
      display: "inline-block",
      flex: 1
    }, Xl), {
      [`
          > ${r}-typography,
          > ${r}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${t}-tabs-top`]: {
      clear: "both",
      marginBottom: o,
      color: e.colorText,
      fontWeight: "normal",
      fontSize: e.fontSize,
      "&-bar": {
        borderBottom: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorderSecondary}`
      }
    }
  });
}, gce = (e) => {
  const {
    cardPaddingBase: t,
    colorBorderSecondary: r,
    cardShadow: n,
    lineWidth: i
  } = e;
  return {
    width: "33.33%",
    padding: t,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${de(i)} 0 0 0 ${r},
      0 ${de(i)} 0 0 ${r},
      ${de(i)} ${de(i)} 0 0 ${r},
      ${de(i)} 0 0 0 ${r} inset,
      0 ${de(i)} 0 0 ${r} inset;
    `,
    transition: `all ${e.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: n
    }
  };
}, vce = (e) => {
  const {
    componentCls: t,
    iconCls: r,
    actionsLiMargin: n,
    cardActionsIconSize: i,
    colorBorderSecondary: o,
    actionsBg: a
  } = e;
  return Object.assign(Object.assign({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: a,
    borderTop: `${de(e.lineWidth)} ${e.lineType} ${o}`,
    display: "flex",
    borderRadius: `0 0 ${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)}`
  }, mv()), {
    "& > li": {
      margin: n,
      color: e.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: e.calc(e.cardActionsIconSize).mul(2).equal(),
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: e.colorPrimary,
          transition: `color ${e.motionDurationMid}`
        },
        [`a:not(${t}-btn), > ${r}`]: {
          display: "inline-block",
          width: "100%",
          color: e.colorTextDescription,
          lineHeight: de(e.fontHeight),
          transition: `color ${e.motionDurationMid}`,
          "&:hover": {
            color: e.colorPrimary
          }
        },
        [`> ${r}`]: {
          fontSize: i,
          lineHeight: de(e.calc(i).mul(e.lineHeight).equal())
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${de(e.lineWidth)} ${e.lineType} ${o}`
      }
    }
  });
}, mce = (e) => Object.assign(Object.assign({
  margin: `${de(e.calc(e.marginXXS).mul(-1).equal())} 0`,
  display: "flex"
}, mv()), {
  "&-avatar": {
    paddingInlineEnd: e.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: e.marginXS
    }
  },
  "&-title": Object.assign({
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.fontSizeLG
  }, Xl),
  "&-description": {
    color: e.colorTextDescription
  }
}), yce = (e) => {
  const {
    componentCls: t,
    cardPaddingBase: r,
    colorFillAlter: n
  } = e;
  return {
    [`${t}-head`]: {
      padding: `0 ${de(r)}`,
      background: n,
      "&-title": {
        fontSize: e.fontSize
      }
    },
    [`${t}-body`]: {
      padding: `${de(e.padding)} ${de(r)}`
    }
  };
}, Cce = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    overflow: "hidden",
    [`${t}-body`]: {
      userSelect: "none"
    }
  };
}, Sce = (e) => {
  const {
    antCls: t,
    componentCls: r,
    cardShadow: n,
    cardHeadPadding: i,
    colorBorderSecondary: o,
    boxShadowTertiary: a,
    cardPaddingBase: s,
    extraColor: l
  } = e;
  return {
    [r]: Object.assign(Object.assign({}, Fi(e)), {
      position: "relative",
      background: e.colorBgContainer,
      borderRadius: e.borderRadiusLG,
      [`&:not(${r}-bordered)`]: {
        boxShadow: a
      },
      [`${r}-head`]: pce(e),
      [`${r}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: l,
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`${r}-body`]: Object.assign({
        padding: s,
        borderRadius: `0 0 ${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)}`
      }, mv()),
      [`${r}-grid`]: gce(e),
      [`${r}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        [`img, img + ${t}-image-mask`]: {
          borderRadius: `${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)} 0 0`
        }
      },
      [`${r}-actions`]: vce(e),
      [`${r}-meta`]: mce(e)
    }),
    [`${r}-bordered`]: {
      border: `${de(e.lineWidth)} ${e.lineType} ${o}`,
      [`${r}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${r}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${e.motionDurationMid}, border-color ${e.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: n
      }
    },
    [`${r}-contain-grid`]: {
      borderRadius: `${de(e.borderRadiusLG)} ${de(e.borderRadiusLG)} 0 0 `,
      [`${r}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${r}-loading) ${r}-body`]: {
        marginBlockStart: e.calc(e.lineWidth).mul(-1).equal(),
        marginInlineStart: e.calc(e.lineWidth).mul(-1).equal(),
        padding: 0
      }
    },
    [`${r}-contain-tabs`]: {
      [`> div${r}-head`]: {
        minHeight: 0,
        [`${r}-head-title, ${r}-extra`]: {
          paddingTop: i
        }
      }
    },
    [`${r}-type-inner`]: yce(e),
    [`${r}-loading`]: Cce(e),
    [`${r}-rtl`]: {
      direction: "rtl"
    }
  };
}, wce = (e) => {
  const {
    componentCls: t,
    cardPaddingSM: r,
    headerHeightSM: n,
    headerFontSizeSM: i
  } = e;
  return {
    [`${t}-small`]: {
      [`> ${t}-head`]: {
        minHeight: n,
        padding: `0 ${de(r)}`,
        fontSize: i,
        [`> ${t}-head-wrapper`]: {
          [`> ${t}-extra`]: {
            fontSize: e.fontSize
          }
        }
      },
      [`> ${t}-body`]: {
        padding: r
      }
    },
    [`${t}-small${t}-contain-tabs`]: {
      [`> ${t}-head`]: {
        [`${t}-head-title, ${t}-extra`]: {
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
}, bce = (e) => ({
  headerBg: "transparent",
  headerFontSize: e.fontSizeLG,
  headerFontSizeSM: e.fontSize,
  headerHeight: e.fontSizeLG * e.lineHeightLG + e.padding * 2,
  headerHeightSM: e.fontSize * e.lineHeight + e.paddingXS * 2,
  actionsBg: e.colorBgContainer,
  actionsLiMargin: `${e.paddingSM}px 0`,
  tabsMarginBottom: -e.padding - e.lineWidth,
  extraColor: e.colorText
}), xce = Gn("Card", (e) => {
  const t = Br(e, {
    cardShadow: e.boxShadowCard,
    cardHeadPadding: e.padding,
    cardPaddingBase: e.paddingLG,
    cardActionsIconSize: e.fontSize,
    cardPaddingSM: 12
    // Fixed padding.
  });
  return [
    // Style
    Sce(t),
    // Size
    wce(t)
  ];
}, bce);
var mL = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Ece = (e) => {
  const {
    actionClasses: t,
    actions: r = [],
    actionStyle: n
  } = e;
  return /* @__PURE__ */ E.createElement("ul", {
    className: t,
    style: n
  }, r.map((i, o) => {
    const a = `action-${o}`;
    return /* @__PURE__ */ E.createElement("li", {
      style: {
        width: `${100 / r.length}%`
      },
      key: a
    }, /* @__PURE__ */ E.createElement("span", null, i));
  }));
}, Rce = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    prefixCls: r,
    className: n,
    rootClassName: i,
    style: o,
    extra: a,
    headStyle: s = {},
    bodyStyle: l = {},
    title: u,
    loading: c,
    bordered: d = !0,
    size: h,
    type: f,
    cover: p,
    actions: g,
    tabList: v,
    children: m,
    activeTabKey: y,
    defaultActiveTabKey: C,
    tabBarExtraContent: S,
    hoverable: b,
    tabProps: w = {},
    classNames: x,
    styles: R
  } = e, _ = mL(e, ["prefixCls", "className", "rootClassName", "style", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps", "classNames", "styles"]), {
    getPrefixCls: T,
    direction: P,
    card: D
  } = E.useContext(Yt);
  if (process.env.NODE_ENV !== "production") {
    const Re = en("Card");
    [["headStyle", "styles.header"], ["bodyStyle", "styles.body"]].forEach((ve) => {
      let [xe, _e] = ve;
      Re.deprecated(!(xe in e), xe, _e);
    });
  }
  const O = (Re) => {
    var ve;
    (ve = e.onTabChange) === null || ve === void 0 || ve.call(e, Re);
  }, A = (Re) => {
    var ve;
    return ue((ve = D == null ? void 0 : D.classNames) === null || ve === void 0 ? void 0 : ve[Re], x == null ? void 0 : x[Re]);
  }, F = (Re) => {
    var ve;
    return Object.assign(Object.assign({}, (ve = D == null ? void 0 : D.styles) === null || ve === void 0 ? void 0 : ve[Re]), R == null ? void 0 : R[Re]);
  }, L = E.useMemo(() => {
    let Re = !1;
    return E.Children.forEach(m, (ve) => {
      (ve == null ? void 0 : ve.type) === e3 && (Re = !0);
    }), Re;
  }, [m]), N = T("card", r), [I, B, M] = xce(N), V = /* @__PURE__ */ E.createElement(gu, {
    loading: !0,
    active: !0,
    paragraph: {
      rows: 4
    },
    title: !1
  }, m), G = y !== void 0, k = Object.assign(Object.assign({}, w), {
    [G ? "activeKey" : "defaultActiveKey"]: G ? y : C,
    tabBarExtraContent: S
  });
  let z;
  const j = sl(h), q = !j || j === "default" ? "large" : j, K = v ? /* @__PURE__ */ E.createElement(hM, Object.assign({
    size: q
  }, k, {
    className: `${N}-head-tabs`,
    onChange: O,
    items: v.map((Re) => {
      var {
        tab: ve
      } = Re, xe = mL(Re, ["tab"]);
      return Object.assign({
        label: ve
      }, xe);
    })
  })) : null;
  if (u || a || K) {
    const Re = ue(`${N}-head`, A("header")), ve = ue(`${N}-head-title`, A("title")), xe = ue(`${N}-extra`, A("extra")), _e = Object.assign(Object.assign({}, s), F("header"));
    z = /* @__PURE__ */ E.createElement("div", {
      className: Re,
      style: _e
    }, /* @__PURE__ */ E.createElement("div", {
      className: `${N}-head-wrapper`
    }, u && /* @__PURE__ */ E.createElement("div", {
      className: ve,
      style: F("title")
    }, u), a && /* @__PURE__ */ E.createElement("div", {
      className: xe,
      style: F("extra")
    }, a)), K);
  }
  const Z = ue(`${N}-cover`, A("cover")), re = p ? /* @__PURE__ */ E.createElement("div", {
    className: Z,
    style: F("cover")
  }, p) : null, X = ue(`${N}-body`, A("body")), Y = Object.assign(Object.assign({}, l), F("body")), U = /* @__PURE__ */ E.createElement("div", {
    className: X,
    style: Y
  }, c ? V : m), oe = ue(`${N}-actions`, A("actions")), W = g != null && g.length ? /* @__PURE__ */ E.createElement(Ece, {
    actionClasses: oe,
    actionStyle: F("actions"),
    actions: g
  }) : null, ne = ni(_, ["onTabChange"]), ce = ue(N, D == null ? void 0 : D.className, {
    [`${N}-loading`]: c,
    [`${N}-bordered`]: d,
    [`${N}-hoverable`]: b,
    [`${N}-contain-grid`]: L,
    [`${N}-contain-tabs`]: v == null ? void 0 : v.length,
    [`${N}-${j}`]: j,
    [`${N}-type-${f}`]: !!f,
    [`${N}-rtl`]: P === "rtl"
  }, n, i, B, M), we = Object.assign(Object.assign({}, D == null ? void 0 : D.style), o);
  return I(/* @__PURE__ */ E.createElement("div", Object.assign({
    ref: t
  }, ne, {
    className: ce,
    style: we
  }), z, re, U, W));
});
var _ce = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Tce = (e) => {
  const {
    prefixCls: t,
    className: r,
    avatar: n,
    title: i,
    description: o
  } = e, a = _ce(e, ["prefixCls", "className", "avatar", "title", "description"]), {
    getPrefixCls: s
  } = E.useContext(Yt), l = s("card", t), u = ue(`${l}-meta`, r), c = n ? /* @__PURE__ */ E.createElement("div", {
    className: `${l}-meta-avatar`
  }, n) : null, d = i ? /* @__PURE__ */ E.createElement("div", {
    className: `${l}-meta-title`
  }, i) : null, h = o ? /* @__PURE__ */ E.createElement("div", {
    className: `${l}-meta-description`
  }, o) : null, f = d || h ? /* @__PURE__ */ E.createElement("div", {
    className: `${l}-meta-detail`
  }, d, h) : null;
  return /* @__PURE__ */ E.createElement("div", Object.assign({}, a, {
    className: u
  }), c, f);
}, Ji = Rce;
Ji.Grid = e3;
Ji.Meta = Tce;
process.env.NODE_ENV !== "production" && (Ji.displayName = "Card");
const Pce = (e) => {
  const {
    componentCls: t,
    sizePaddingEdgeHorizontal: r,
    colorSplit: n,
    lineWidth: i,
    textPaddingInline: o,
    orientationMargin: a,
    verticalMarginInline: s
  } = e;
  return {
    [t]: Object.assign(Object.assign({}, Fi(e)), {
      borderBlockStart: `${de(i)} solid ${n}`,
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        marginInline: s,
        marginBlock: 0,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${de(i)} solid ${n}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        // Fix https://github.com/ant-design/ant-design/issues/10914
        margin: `${de(e.dividerHorizontalGutterMargin)} 0`
      },
      [`&-horizontal${t}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${de(e.dividerHorizontalWithTextGutterMargin)} 0`,
        color: e.colorTextHeading,
        fontWeight: 500,
        fontSize: e.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${n}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${de(i)} solid transparent`,
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${t}-with-text-left`]: {
        "&::before": {
          width: `calc(${a} * 100%)`
        },
        "&::after": {
          width: `calc(100% - ${a} * 100%)`
        }
      },
      [`&-horizontal${t}-with-text-right`]: {
        "&::before": {
          width: `calc(100% - ${a} * 100%)`
        },
        "&::after": {
          width: `calc(${a} * 100%)`
        }
      },
      [`${t}-inner-text`]: {
        display: "inline-block",
        paddingBlock: 0,
        paddingInline: o
      },
      "&-dashed": {
        background: "none",
        borderColor: n,
        borderStyle: "dashed",
        borderWidth: `${de(i)} 0 0`
      },
      [`&-horizontal${t}-with-text${t}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${t}-dashed`]: {
        borderInlineStartWidth: i,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${t}-with-text`]: {
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`&-horizontal${t}-with-text-left${t}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${t}-inner-text`]: {
          paddingInlineStart: r
        }
      },
      [`&-horizontal${t}-with-text-right${t}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${t}-inner-text`]: {
          paddingInlineEnd: r
        }
      }
    })
  };
}, Mce = (e) => ({
  textPaddingInline: "1em",
  orientationMargin: 0.05,
  verticalMarginInline: e.marginXS
}), Dce = Gn("Divider", (e) => {
  const t = Br(e, {
    dividerHorizontalWithTextGutterMargin: e.margin,
    dividerHorizontalGutterMargin: e.marginLG,
    sizePaddingEdgeHorizontal: 0
  });
  return [Pce(t)];
}, Mce, {
  unitless: {
    orientationMargin: !0
  }
});
var Ace = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const t3 = (e) => {
  const {
    getPrefixCls: t,
    direction: r,
    divider: n
  } = E.useContext(Yt), {
    prefixCls: i,
    type: o = "horizontal",
    orientation: a = "center",
    orientationMargin: s,
    className: l,
    rootClassName: u,
    children: c,
    dashed: d,
    plain: h,
    style: f
  } = e, p = Ace(e, ["prefixCls", "type", "orientation", "orientationMargin", "className", "rootClassName", "children", "dashed", "plain", "style"]), g = t("divider", i), [v, m, y] = Dce(g), C = !!c, S = a === "left" && s != null, b = a === "right" && s != null, w = ue(g, n == null ? void 0 : n.className, m, y, `${g}-${o}`, {
    [`${g}-with-text`]: C,
    [`${g}-with-text-${a}`]: C,
    [`${g}-dashed`]: !!d,
    [`${g}-plain`]: !!h,
    [`${g}-rtl`]: r === "rtl",
    [`${g}-no-default-orientation-margin-left`]: S,
    [`${g}-no-default-orientation-margin-right`]: b
  }, l, u), x = E.useMemo(() => typeof s == "number" ? s : /^\d+$/.test(s) ? Number(s) : s, [s]), R = Object.assign(Object.assign({}, S && {
    marginLeft: x
  }), b && {
    marginRight: x
  });
  if (process.env.NODE_ENV !== "production") {
    const _ = en("Divider");
    process.env.NODE_ENV !== "production" && _(!c || o !== "vertical", "usage", "`children` not working in `vertical` mode.");
  }
  return v(/* @__PURE__ */ E.createElement("div", Object.assign({
    className: w,
    style: Object.assign(Object.assign({}, n == null ? void 0 : n.style), f)
  }, p, {
    // biome-ignore lint/a11y/useAriaPropsForRole: divider do not need aria-value
    role: "separator"
  }), c && o !== "vertical" && /* @__PURE__ */ E.createElement("span", {
    className: `${g}-inner-text`,
    style: R
  }, c)));
};
process.env.NODE_ENV !== "production" && (t3.displayName = "Divider");
function Ice(e) {
  return !!(e.addonBefore || e.addonAfter);
}
function Oce(e) {
  return !!(e.prefix || e.suffix || e.allowClear);
}
function yL(e, t, r) {
  var n = t.cloneNode(!0), i = Object.create(e, {
    target: {
      value: n
    },
    currentTarget: {
      value: n
    }
  });
  return n.value = r, typeof t.selectionStart == "number" && typeof t.selectionEnd == "number" && (n.selectionStart = t.selectionStart, n.selectionEnd = t.selectionEnd), n.setSelectionRange = function() {
    t.setSelectionRange.apply(t, arguments);
  }, i;
}
function H0(e, t, r, n) {
  if (r) {
    var i = t;
    if (t.type === "click") {
      i = yL(t, e, ""), r(i);
      return;
    }
    if (e.type !== "file" && n !== void 0) {
      i = yL(t, e, n), r(i);
      return;
    }
    r(i);
  }
}
function Lce(e, t) {
  if (e) {
    e.focus(t);
    var r = t || {}, n = r.cursor;
    if (n) {
      var i = e.value.length;
      switch (n) {
        case "start":
          e.setSelectionRange(0, 0);
          break;
        case "end":
          e.setSelectionRange(i, i);
          break;
        default:
          e.setSelectionRange(0, i);
      }
    }
  }
}
var r3 = /* @__PURE__ */ H.forwardRef(function(e, t) {
  var r, n, i = e.inputElement, o = e.children, a = e.prefixCls, s = e.prefix, l = e.suffix, u = e.addonBefore, c = e.addonAfter, d = e.className, h = e.style, f = e.disabled, p = e.readOnly, g = e.focused, v = e.triggerFocus, m = e.allowClear, y = e.value, C = e.handleReset, S = e.hidden, b = e.classes, w = e.classNames, x = e.dataAttrs, R = e.styles, _ = e.components, T = o ?? i, P = (_ == null ? void 0 : _.affixWrapper) || "span", D = (_ == null ? void 0 : _.groupWrapper) || "span", O = (_ == null ? void 0 : _.wrapper) || "span", A = (_ == null ? void 0 : _.groupAddon) || "span", F = se(null), L = function(ne) {
    var ce;
    (ce = F.current) !== null && ce !== void 0 && ce.contains(ne.target) && (v == null || v());
  }, N = Oce(e), I = /* @__PURE__ */ VX(T, {
    value: y,
    className: ue(T.props.className, !N && (w == null ? void 0 : w.variant)) || null
  }), B = se(null);
  if (H.useImperativeHandle(t, function() {
    return {
      nativeElement: B.current || F.current
    };
  }), N) {
    var M, V = null;
    if (m) {
      var G, k = !f && !p && y, z = "".concat(a, "-clear-icon"), j = vt(m) === "object" && m !== null && m !== void 0 && m.clearIcon ? m.clearIcon : "";
      V = /* @__PURE__ */ H.createElement("span", {
        onClick: C,
        onMouseDown: function(ne) {
          return ne.preventDefault();
        },
        className: ue(z, (G = {}, te(G, "".concat(z, "-hidden"), !k), te(G, "".concat(z, "-has-suffix"), !!l), G)),
        role: "button",
        tabIndex: -1
      }, j);
    }
    var q = "".concat(a, "-affix-wrapper"), K = ue(q, (M = {}, te(M, "".concat(a, "-disabled"), f), te(M, "".concat(q, "-disabled"), f), te(M, "".concat(q, "-focused"), g), te(M, "".concat(q, "-readonly"), p), te(M, "".concat(q, "-input-with-clear-btn"), l && m && y), M), b == null ? void 0 : b.affixWrapper, w == null ? void 0 : w.affixWrapper, w == null ? void 0 : w.variant), Z = (l || m) && /* @__PURE__ */ H.createElement("span", {
      className: ue("".concat(a, "-suffix"), w == null ? void 0 : w.suffix),
      style: R == null ? void 0 : R.suffix
    }, V, l);
    I = /* @__PURE__ */ H.createElement(P, $e({
      className: K,
      style: R == null ? void 0 : R.affixWrapper,
      onClick: L
    }, x == null ? void 0 : x.affixWrapper, {
      ref: F
    }), s && /* @__PURE__ */ H.createElement("span", {
      className: ue("".concat(a, "-prefix"), w == null ? void 0 : w.prefix),
      style: R == null ? void 0 : R.prefix
    }, s), I, Z);
  }
  if (Ice(e)) {
    var re = "".concat(a, "-group"), X = "".concat(re, "-addon"), Y = "".concat(re, "-wrapper"), U = ue("".concat(a, "-wrapper"), re, b == null ? void 0 : b.wrapper, w == null ? void 0 : w.wrapper), oe = ue(Y, te({}, "".concat(Y, "-disabled"), f), b == null ? void 0 : b.group, w == null ? void 0 : w.groupWrapper);
    I = /* @__PURE__ */ H.createElement(D, {
      className: oe,
      ref: B
    }, /* @__PURE__ */ H.createElement(O, {
      className: U
    }, u && /* @__PURE__ */ H.createElement(A, {
      className: X
    }, u), I, c && /* @__PURE__ */ H.createElement(A, {
      className: X
    }, c)));
  }
  return /* @__PURE__ */ H.cloneElement(I, {
    className: ue((r = I.props) === null || r === void 0 ? void 0 : r.className, d) || null,
    style: ee(ee({}, (n = I.props) === null || n === void 0 ? void 0 : n.style), h),
    hidden: S
  });
}), Fce = ["show"];
function n3(e, t) {
  return E.useMemo(function() {
    var r = {};
    t && (r.show = vt(t) === "object" && t.formatter ? t.formatter : !!t), r = ee(ee({}, r), e);
    var n = r, i = n.show, o = $t(n, Fce);
    return ee(ee({}, o), {}, {
      show: !!i,
      showFormatter: typeof i == "function" ? i : void 0,
      strategy: o.strategy || function(a) {
        return a.length;
      }
    });
  }, [e, t]);
}
var Nce = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"], kce = /* @__PURE__ */ yn(function(e, t) {
  var r = e.autoComplete, n = e.onChange, i = e.onFocus, o = e.onBlur, a = e.onPressEnter, s = e.onKeyDown, l = e.prefixCls, u = l === void 0 ? "rc-input" : l, c = e.disabled, d = e.htmlSize, h = e.className, f = e.maxLength, p = e.suffix, g = e.showCount, v = e.count, m = e.type, y = m === void 0 ? "text" : m, C = e.classes, S = e.classNames, b = e.styles, w = e.onCompositionStart, x = e.onCompositionEnd, R = $t(e, Nce), _ = Me(!1), T = ae(_, 2), P = T[0], D = T[1], O = se(!1), A = se(null), F = se(null), L = function(_e) {
    A.current && Lce(A.current, _e);
  }, N = xn(e.defaultValue, {
    value: e.value
  }), I = ae(N, 2), B = I[0], M = I[1], V = B == null ? "" : String(B), G = Me(null), k = ae(G, 2), z = k[0], j = k[1], q = n3(v, g), K = q.max || f, Z = q.strategy(V), re = !!K && Z > K;
  Zc(t, function() {
    var xe;
    return {
      focus: L,
      blur: function() {
        var Ve;
        (Ve = A.current) === null || Ve === void 0 || Ve.blur();
      },
      setSelectionRange: function(Ve, Fe, Ne) {
        var Je;
        (Je = A.current) === null || Je === void 0 || Je.setSelectionRange(Ve, Fe, Ne);
      },
      select: function() {
        var Ve;
        (Ve = A.current) === null || Ve === void 0 || Ve.select();
      },
      input: A.current,
      nativeElement: ((xe = F.current) === null || xe === void 0 ? void 0 : xe.nativeElement) || A.current
    };
  }), Nt(function() {
    D(function(xe) {
      return xe && c ? !1 : xe;
    });
  }, [c]);
  var X = function(_e, Ve, Fe) {
    var Ne = Ve;
    if (!O.current && q.exceedFormatter && q.max && q.strategy(Ve) > q.max) {
      if (Ne = q.exceedFormatter(Ve, {
        max: q.max
      }), Ve !== Ne) {
        var Je, J;
        j([((Je = A.current) === null || Je === void 0 ? void 0 : Je.selectionStart) || 0, ((J = A.current) === null || J === void 0 ? void 0 : J.selectionEnd) || 0]);
      }
    } else if (Fe.source === "compositionEnd")
      return;
    M(Ne), A.current && H0(A.current, _e, n, Ne);
  };
  Nt(function() {
    if (z) {
      var xe;
      (xe = A.current) === null || xe === void 0 || xe.setSelectionRange.apply(xe, it(z));
    }
  }, [z]);
  var Y = function(_e) {
    X(_e, _e.target.value, {
      source: "change"
    });
  }, U = function(_e) {
    O.current = !1, X(_e, _e.currentTarget.value, {
      source: "compositionEnd"
    }), x == null || x(_e);
  }, oe = function(_e) {
    a && _e.key === "Enter" && a(_e), s == null || s(_e);
  }, W = function(_e) {
    D(!0), i == null || i(_e);
  }, ne = function(_e) {
    D(!1), o == null || o(_e);
  }, ce = function(_e) {
    M(""), L(), A.current && H0(A.current, _e, n);
  }, we = re && "".concat(u, "-out-of-range"), Re = function() {
    var _e = ni(e, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "showCount",
      "count",
      "classes",
      "htmlSize",
      "styles",
      "classNames"
    ]);
    return /* @__PURE__ */ H.createElement("input", $e({
      autoComplete: r
    }, _e, {
      onChange: Y,
      onFocus: W,
      onBlur: ne,
      onKeyDown: oe,
      className: ue(u, te({}, "".concat(u, "-disabled"), c), S == null ? void 0 : S.input),
      style: b == null ? void 0 : b.input,
      ref: A,
      size: d,
      type: y,
      onCompositionStart: function(Fe) {
        O.current = !0, w == null || w(Fe);
      },
      onCompositionEnd: U
    }));
  }, ve = function() {
    var _e = Number(K) > 0;
    if (p || q.show) {
      var Ve = q.showFormatter ? q.showFormatter({
        value: V,
        count: Z,
        maxLength: K
      }) : "".concat(Z).concat(_e ? " / ".concat(K) : "");
      return /* @__PURE__ */ H.createElement(H.Fragment, null, q.show && /* @__PURE__ */ H.createElement("span", {
        className: ue("".concat(u, "-show-count-suffix"), te({}, "".concat(u, "-show-count-has-suffix"), !!p), S == null ? void 0 : S.count),
        style: ee({}, b == null ? void 0 : b.count)
      }, Ve), p);
    }
    return null;
  };
  return /* @__PURE__ */ H.createElement(r3, $e({}, R, {
    prefixCls: u,
    className: ue(h, we),
    handleReset: ce,
    value: V,
    focused: P,
    triggerFocus: L,
    suffix: ve(),
    disabled: c,
    classes: C,
    classNames: S,
    styles: b
  }), Re());
});
const Vce = (e) => {
  const {
    getPrefixCls: t,
    direction: r
  } = vr(Yt), {
    prefixCls: n,
    className: i
  } = e, o = t("input-group", n), a = t("input"), [s, l] = cM(a), u = ue(o, {
    [`${o}-lg`]: e.size === "large",
    [`${o}-sm`]: e.size === "small",
    [`${o}-compact`]: e.compact,
    [`${o}-rtl`]: r === "rtl"
  }, l, i), c = vr(ps), d = Et(() => Object.assign(Object.assign({}, c), {
    isFormItemInput: !1
  }), [c]);
  return process.env.NODE_ENV !== "production" && en("Input.Group").deprecated(!1, "Input.Group", "Space.Compact"), s(/* @__PURE__ */ E.createElement("span", {
    className: u,
    style: e.style,
    onMouseEnter: e.onMouseEnter,
    onMouseLeave: e.onMouseLeave,
    onFocus: e.onFocus,
    onBlur: e.onBlur
  }, /* @__PURE__ */ E.createElement(ps.Provider, {
    value: d
  }, e.children)));
}, i3 = (e) => {
  let t;
  return typeof e == "object" && (e != null && e.clearIcon) ? t = e : e && (t = {
    clearIcon: /* @__PURE__ */ H.createElement(gS, null)
  }), t;
};
function o3(e, t) {
  const r = se([]), n = () => {
    r.current.push(setTimeout(() => {
      var i, o, a, s;
      !((i = e.current) === null || i === void 0) && i.input && ((o = e.current) === null || o === void 0 ? void 0 : o.input.getAttribute("type")) === "password" && (!((a = e.current) === null || a === void 0) && a.input.hasAttribute("value")) && ((s = e.current) === null || s === void 0 || s.input.removeAttribute("value"));
    }));
  };
  return Nt(() => (t && n(), () => r.current.forEach((i) => {
    i && clearTimeout(i);
  })), []), n;
}
function Bce(e) {
  return !!(e.prefix || e.suffix || e.allowClear || e.showCount);
}
var $ce = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function Hce(e, t) {
  if (!e)
    return;
  e.focus(t);
  const {
    cursor: r
  } = t || {};
  if (r) {
    const n = e.value.length;
    switch (r) {
      case "start":
        e.setSelectionRange(0, 0);
        break;
      case "end":
        e.setSelectionRange(n, n);
        break;
      default:
        e.setSelectionRange(0, n);
    }
  }
}
const a3 = /* @__PURE__ */ yn((e, t) => {
  var r;
  const {
    prefixCls: n,
    bordered: i = !0,
    status: o,
    size: a,
    disabled: s,
    onBlur: l,
    onFocus: u,
    suffix: c,
    allowClear: d,
    addonAfter: h,
    addonBefore: f,
    className: p,
    style: g,
    styles: v,
    rootClassName: m,
    onChange: y,
    classNames: C,
    variant: S
  } = e, b = $ce(e, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated: W
    } = en("Input");
    W(!("bordered" in e), "bordered", "variant");
  }
  const {
    getPrefixCls: w,
    direction: x,
    input: R
  } = H.useContext(Yt), _ = w("input", n), T = se(null), P = ed(_), [D, O, A] = cM(_, P), {
    compactSize: F,
    compactItemClassnames: L
  } = CS(_, x), N = sl((W) => {
    var ne;
    return (ne = a ?? F) !== null && ne !== void 0 ? ne : W;
  }), I = H.useContext($c), B = s ?? I, {
    status: M,
    hasFeedback: V,
    feedbackIcon: G
  } = vr(ps), k = _S(M, o), z = Bce(e) || !!V, j = se(z);
  if (process.env.NODE_ENV !== "production") {
    const W = en("Input");
    Nt(() => {
      var ne;
      z && !j.current && process.env.NODE_ENV !== "production" && W(document.activeElement === ((ne = T.current) === null || ne === void 0 ? void 0 : ne.input), "usage", "When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ"), j.current = z;
    }, [z]);
  }
  const q = o3(T, !0), K = (W) => {
    q(), l == null || l(W);
  }, Z = (W) => {
    q(), u == null || u(W);
  }, re = (W) => {
    q(), y == null || y(W);
  }, X = (V || c) && /* @__PURE__ */ H.createElement(H.Fragment, null, c, V && G), Y = i3(d ?? (R == null ? void 0 : R.allowClear)), [U, oe] = QP("input", S, i);
  return D(/* @__PURE__ */ H.createElement(kce, Object.assign({
    ref: Eo(t, T),
    prefixCls: _,
    autoComplete: R == null ? void 0 : R.autoComplete
  }, b, {
    disabled: B,
    onBlur: K,
    onFocus: Z,
    style: Object.assign(Object.assign({}, R == null ? void 0 : R.style), g),
    styles: Object.assign(Object.assign({}, R == null ? void 0 : R.styles), v),
    suffix: X,
    allowClear: Y,
    className: ue(p, m, A, P, L, R == null ? void 0 : R.className),
    onChange: re,
    addonBefore: f && /* @__PURE__ */ H.createElement(IR, {
      form: !0,
      space: !0
    }, f),
    addonAfter: h && /* @__PURE__ */ H.createElement(IR, {
      form: !0,
      space: !0
    }, h),
    classNames: Object.assign(Object.assign(Object.assign({}, C), R == null ? void 0 : R.classNames), {
      input: ue({
        [`${_}-sm`]: N === "small",
        [`${_}-lg`]: N === "large",
        [`${_}-rtl`]: x === "rtl"
      }, C == null ? void 0 : C.input, (r = R == null ? void 0 : R.classNames) === null || r === void 0 ? void 0 : r.input, O),
      variant: ue({
        [`${_}-${U}`]: oe
      }, B0(_, k)),
      affixWrapper: ue({
        [`${_}-affix-wrapper-sm`]: N === "small",
        [`${_}-affix-wrapper-lg`]: N === "large",
        [`${_}-affix-wrapper-rtl`]: x === "rtl"
      }, O),
      wrapper: ue({
        [`${_}-group-rtl`]: x === "rtl"
      }, O),
      groupWrapper: ue({
        [`${_}-group-wrapper-sm`]: N === "small",
        [`${_}-group-wrapper-lg`]: N === "large",
        [`${_}-group-wrapper-rtl`]: x === "rtl",
        [`${_}-group-wrapper-${U}`]: oe
      }, B0(`${_}-group-wrapper`, k, V), O)
    })
  })));
});
process.env.NODE_ENV !== "production" && (a3.displayName = "Input");
const IS = a3, Gce = (e) => {
  const {
    componentCls: t,
    paddingXS: r
  } = e;
  return {
    [`${t}`]: {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "nowrap",
      columnGap: r,
      "&-rtl": {
        direction: "rtl"
      },
      [`${t}-input`]: {
        textAlign: "center",
        paddingInline: e.paddingXXS
      },
      // ================= Size =================
      [`&${t}-sm ${t}-input`]: {
        paddingInline: e.calc(e.paddingXXS).div(2).equal()
      },
      [`&${t}-lg ${t}-input`]: {
        paddingInline: e.paddingXS
      }
    }
  };
}, zce = Gn(["Input", "OTP"], (e) => {
  const t = Br(e, B8(e));
  return [Gce(t)];
}, $8);
var Wce = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const jce = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    value: r,
    onChange: n,
    onActiveChange: i,
    index: o,
    mask: a
  } = e, s = Wce(e, ["value", "onChange", "onActiveChange", "index", "mask"]), l = r && typeof a == "string" ? a : r, u = (p) => {
    n(o, p.target.value);
  }, c = E.useRef(null);
  E.useImperativeHandle(t, () => c.current);
  const d = () => {
    Ar(() => {
      var p;
      const g = (p = c.current) === null || p === void 0 ? void 0 : p.input;
      document.activeElement === g && g && g.select();
    });
  }, h = (p) => {
    let {
      key: g
    } = p;
    g === "ArrowLeft" ? i(o - 1) : g === "ArrowRight" && i(o + 1), d();
  }, f = (p) => {
    p.key === "Backspace" && !r && i(o - 1), d();
  };
  return /* @__PURE__ */ E.createElement(IS, Object.assign({}, s, {
    ref: c,
    value: l,
    onInput: u,
    onFocus: d,
    onKeyDown: h,
    onKeyUp: f,
    onMouseDown: d,
    onMouseUp: d,
    type: a === !0 ? "password" : "text"
  }));
});
var Uce = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function bm(e) {
  return (e || "").split("");
}
const Kce = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    prefixCls: r,
    length: n = 6,
    size: i,
    defaultValue: o,
    value: a,
    onChange: s,
    formatter: l,
    variant: u,
    disabled: c,
    status: d,
    autoFocus: h,
    mask: f
  } = e, p = Uce(e, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "variant", "disabled", "status", "autoFocus", "mask"]);
  if (process.env.NODE_ENV !== "production") {
    const V = en("Input.OTP");
    process.env.NODE_ENV !== "production" && V(!(typeof f == "string" && f.length > 1), "usage", "`mask` prop should be a single character.");
  }
  const {
    getPrefixCls: g,
    direction: v
  } = E.useContext(Yt), m = g("otp", r), y = Zl(p, {
    aria: !0,
    data: !0,
    attr: !0
  }), C = ed(m), [S, b, w] = zce(m, C), x = sl((V) => i ?? V), R = E.useContext(ps), _ = _S(R.status, d), T = E.useMemo(() => Object.assign(Object.assign({}, R), {
    status: _,
    hasFeedback: !1,
    feedbackIcon: null
  }), [R, _]), P = E.useRef(null), D = E.useRef({});
  E.useImperativeHandle(t, () => ({
    focus: () => {
      var V;
      (V = D.current[0]) === null || V === void 0 || V.focus();
    },
    blur: () => {
      var V;
      for (let G = 0; G < n; G += 1)
        (V = D.current[G]) === null || V === void 0 || V.blur();
    },
    nativeElement: P.current
  }));
  const O = (V) => l ? l(V) : V, [A, F] = E.useState(bm(O(o || "")));
  E.useEffect(() => {
    a !== void 0 && F(bm(a));
  }, [a]);
  const L = An((V) => {
    F(V), s && V.length === n && V.every((G) => G) && V.some((G, k) => A[k] !== G) && s(V.join(""));
  }), N = An((V, G) => {
    let k = it(A);
    for (let j = 0; j < V; j += 1)
      k[j] || (k[j] = "");
    G.length <= 1 ? k[V] = G : k = k.slice(0, V).concat(bm(G)), k = k.slice(0, n);
    for (let j = k.length - 1; j >= 0 && !k[j]; j -= 1)
      k.pop();
    const z = O(k.map((j) => j || " ").join(""));
    return k = bm(z).map((j, q) => j === " " && !k[q] ? k[q] : j), k;
  }), I = (V, G) => {
    var k;
    const z = N(V, G), j = Math.min(V + G.length, n - 1);
    j !== V && ((k = D.current[j]) === null || k === void 0 || k.focus()), L(z);
  }, B = (V) => {
    var G;
    (G = D.current[V]) === null || G === void 0 || G.focus();
  }, M = {
    variant: u,
    disabled: c,
    status: _,
    mask: f
  };
  return S(/* @__PURE__ */ E.createElement("div", Object.assign({}, y, {
    ref: P,
    className: ue(m, {
      [`${m}-sm`]: x === "small",
      [`${m}-lg`]: x === "large",
      [`${m}-rtl`]: v === "rtl"
    }, w, b)
  }), /* @__PURE__ */ E.createElement(ps.Provider, {
    value: T
  }, Array.from({
    length: n
  }).map((V, G) => {
    const k = `otp-${G}`, z = A[G] || "";
    return /* @__PURE__ */ E.createElement(jce, Object.assign({
      ref: (j) => {
        D.current[G] = j;
      },
      key: k,
      index: G,
      size: x,
      htmlSize: 1,
      className: `${m}-input`,
      onChange: I,
      value: z,
      onActiveChange: B,
      autoFocus: G === 0 && h
    }, M));
  }))));
});
var Yce = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" }, qce = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: Yce
  }));
}, s3 = /* @__PURE__ */ E.forwardRef(qce);
process.env.NODE_ENV !== "production" && (s3.displayName = "EyeInvisibleOutlined");
var Xce = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" }, Zce = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: Xce
  }));
}, fM = /* @__PURE__ */ E.forwardRef(Zce);
process.env.NODE_ENV !== "production" && (fM.displayName = "EyeOutlined");
var Qce = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Jce = (e) => e ? /* @__PURE__ */ E.createElement(fM, null) : /* @__PURE__ */ E.createElement(s3, null), ede = {
  click: "onClick",
  hover: "onMouseOver"
}, l3 = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    disabled: r,
    action: n = "click",
    visibilityToggle: i = !0,
    iconRender: o = Jce
  } = e, a = typeof i == "object" && i.visible !== void 0, [s, l] = Me(() => a ? i.visible : !1), u = se(null);
  E.useEffect(() => {
    a && l(i.visible);
  }, [a, i]);
  const c = o3(u), d = () => {
    r || (s && c(), l((R) => {
      var _;
      const T = !R;
      return typeof i == "object" && ((_ = i.onVisibleChange) === null || _ === void 0 || _.call(i, T)), T;
    }));
  }, h = (R) => {
    const _ = ede[n] || "", T = o(s), P = {
      [_]: d,
      className: `${R}-icon`,
      key: "passwordIcon",
      onMouseDown: (D) => {
        D.preventDefault();
      },
      onMouseUp: (D) => {
        D.preventDefault();
      }
    };
    return /* @__PURE__ */ E.cloneElement(/* @__PURE__ */ E.isValidElement(T) ? T : /* @__PURE__ */ E.createElement("span", null, T), P);
  }, {
    className: f,
    prefixCls: p,
    inputPrefixCls: g,
    size: v
  } = e, m = Qce(e, ["className", "prefixCls", "inputPrefixCls", "size"]), {
    getPrefixCls: y
  } = E.useContext(Yt), C = y("input", g), S = y("input-password", p), b = i && h(S), w = ue(S, f, {
    [`${S}-${v}`]: !!v
  }), x = Object.assign(Object.assign({}, ni(m, ["suffix", "iconRender", "visibilityToggle"])), {
    type: s ? "text" : "password",
    className: w,
    prefixCls: C,
    suffix: b
  });
  return v && (x.size = v), /* @__PURE__ */ E.createElement(IS, Object.assign({
    ref: Eo(t, u)
  }, x));
});
process.env.NODE_ENV !== "production" && (l3.displayName = "Input.Password");
var tde = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const u3 = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    prefixCls: r,
    inputPrefixCls: n,
    className: i,
    size: o,
    suffix: a,
    enterButton: s = !1,
    addonAfter: l,
    loading: u,
    disabled: c,
    onSearch: d,
    onChange: h,
    onCompositionStart: f,
    onCompositionEnd: p
  } = e, g = tde(e, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]), {
    getPrefixCls: v,
    direction: m
  } = E.useContext(Yt), y = E.useRef(!1), C = v("input-search", r), S = v("input", n), {
    compactSize: b
  } = CS(C, m), w = sl((M) => {
    var V;
    return (V = o ?? b) !== null && V !== void 0 ? V : M;
  }), x = E.useRef(null), R = (M) => {
    M != null && M.target && M.type === "click" && d && d(M.target.value, M, {
      source: "clear"
    }), h == null || h(M);
  }, _ = (M) => {
    var V;
    document.activeElement === ((V = x.current) === null || V === void 0 ? void 0 : V.input) && M.preventDefault();
  }, T = (M) => {
    var V, G;
    d && d((G = (V = x.current) === null || V === void 0 ? void 0 : V.input) === null || G === void 0 ? void 0 : G.value, M, {
      source: "input"
    });
  }, P = (M) => {
    y.current || u || T(M);
  }, D = typeof s == "boolean" ? /* @__PURE__ */ E.createElement(JP, null) : null, O = `${C}-button`;
  let A;
  const F = s || {}, L = F.type && F.type.__ANT_BUTTON === !0;
  L || F.type === "button" ? A = Hc(F, Object.assign({
    onMouseDown: _,
    onClick: (M) => {
      var V, G;
      (G = (V = F == null ? void 0 : F.props) === null || V === void 0 ? void 0 : V.onClick) === null || G === void 0 || G.call(V, M), T(M);
    },
    key: "enterButton"
  }, L ? {
    className: O,
    size: w
  } : {})) : A = /* @__PURE__ */ E.createElement(jn, {
    className: O,
    type: s ? "primary" : void 0,
    size: w,
    disabled: c,
    key: "enterButton",
    onMouseDown: _,
    onClick: T,
    loading: u,
    icon: D
  }, s), l && (A = [A, Hc(l, {
    key: "addonAfter"
  })]);
  const N = ue(C, {
    [`${C}-rtl`]: m === "rtl",
    [`${C}-${w}`]: !!w,
    [`${C}-with-button`]: !!s
  }, i), I = (M) => {
    y.current = !0, f == null || f(M);
  }, B = (M) => {
    y.current = !1, p == null || p(M);
  };
  return /* @__PURE__ */ E.createElement(IS, Object.assign({
    ref: Eo(x, t),
    onPressEnter: P
  }, g, {
    size: w,
    onCompositionStart: I,
    onCompositionEnd: B,
    prefixCls: S,
    addonAfter: A,
    suffix: a,
    onChange: R,
    className: N,
    disabled: c
  }));
});
process.env.NODE_ENV !== "production" && (u3.displayName = "Search");
var rde = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, nde = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], yb = {}, Po;
function ide(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = e.getAttribute("id") || e.getAttribute("data-reactid") || e.getAttribute("name");
  if (t && yb[r])
    return yb[r];
  var n = window.getComputedStyle(e), i = n.getPropertyValue("box-sizing") || n.getPropertyValue("-moz-box-sizing") || n.getPropertyValue("-webkit-box-sizing"), o = parseFloat(n.getPropertyValue("padding-bottom")) + parseFloat(n.getPropertyValue("padding-top")), a = parseFloat(n.getPropertyValue("border-bottom-width")) + parseFloat(n.getPropertyValue("border-top-width")), s = nde.map(function(u) {
    return "".concat(u, ":").concat(n.getPropertyValue(u));
  }).join(";"), l = {
    sizingStyle: s,
    paddingSize: o,
    borderSize: a,
    boxSizing: i
  };
  return t && r && (yb[r] = l), l;
}
function ode(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  Po || (Po = document.createElement("textarea"), Po.setAttribute("tab-index", "-1"), Po.setAttribute("aria-hidden", "true"), document.body.appendChild(Po)), e.getAttribute("wrap") ? Po.setAttribute("wrap", e.getAttribute("wrap")) : Po.removeAttribute("wrap");
  var i = ide(e, t), o = i.paddingSize, a = i.borderSize, s = i.boxSizing, l = i.sizingStyle;
  Po.setAttribute("style", "".concat(l, ";").concat(rde)), Po.value = e.value || e.placeholder || "";
  var u = void 0, c = void 0, d, h = Po.scrollHeight;
  if (s === "border-box" ? h += a : s === "content-box" && (h -= o), r !== null || n !== null) {
    Po.value = " ";
    var f = Po.scrollHeight - o;
    r !== null && (u = f * r, s === "border-box" && (u = u + o + a), h = Math.max(u, h)), n !== null && (c = f * n, s === "border-box" && (c = c + o + a), d = h > c ? "" : "hidden", h = Math.min(c, h));
  }
  var p = {
    height: h,
    overflowY: d,
    resize: "none"
  };
  return u && (p.minHeight = u), c && (p.maxHeight = c), p;
}
var ade = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"], Cb = 0, Sb = 1, wb = 2, sde = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e, n = r.prefixCls;
  r.onPressEnter;
  var i = r.defaultValue, o = r.value, a = r.autoSize, s = r.onResize, l = r.className, u = r.style, c = r.disabled, d = r.onChange, h = r.onInternalAutoSize, f = $t(r, ade), p = xn(i, {
    value: o,
    postState: function(j) {
      return j ?? "";
    }
  }), g = ae(p, 2), v = g[0], m = g[1], y = function(j) {
    m(j.target.value), d == null || d(j);
  }, C = E.useRef();
  E.useImperativeHandle(t, function() {
    return {
      textArea: C.current
    };
  });
  var S = E.useMemo(function() {
    return a && vt(a) === "object" ? [a.minRows, a.maxRows] : [];
  }, [a]), b = ae(S, 2), w = b[0], x = b[1], R = !!a, _ = function() {
    try {
      if (document.activeElement === C.current) {
        var j = C.current, q = j.selectionStart, K = j.selectionEnd, Z = j.scrollTop;
        C.current.setSelectionRange(q, K), C.current.scrollTop = Z;
      }
    } catch {
    }
  }, T = E.useState(wb), P = ae(T, 2), D = P[0], O = P[1], A = E.useState(), F = ae(A, 2), L = F[0], N = F[1], I = function() {
    O(Cb), process.env.NODE_ENV === "test" && (h == null || h());
  };
  kr(function() {
    R && I();
  }, [o, w, x, R]), kr(function() {
    if (D === Cb)
      O(Sb);
    else if (D === Sb) {
      var z = ode(C.current, !1, w, x);
      O(wb), N(z);
    } else
      _();
  }, [D]);
  var B = E.useRef(), M = function() {
    Ar.cancel(B.current);
  }, V = function(j) {
    D === wb && (s == null || s(j), a && (M(), B.current = Ar(function() {
      I();
    })));
  };
  E.useEffect(function() {
    return M;
  }, []);
  var G = R ? L : null, k = ee(ee({}, u), G);
  return (D === Cb || D === Sb) && (k.overflowY = "hidden", k.overflowX = "hidden"), /* @__PURE__ */ E.createElement(Co, {
    onResize: V,
    disabled: !(a || s)
  }, /* @__PURE__ */ E.createElement("textarea", $e({}, f, {
    ref: C,
    style: k,
    className: ue(n, l, te({}, "".concat(n, "-disabled"), c)),
    disabled: c,
    value: v,
    onChange: y
  })));
}), lde = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize", "readOnly"], ude = /* @__PURE__ */ H.forwardRef(function(e, t) {
  var r, n = e.defaultValue, i = e.value, o = e.onFocus, a = e.onBlur, s = e.onChange, l = e.allowClear, u = e.maxLength, c = e.onCompositionStart, d = e.onCompositionEnd, h = e.suffix, f = e.prefixCls, p = f === void 0 ? "rc-textarea" : f, g = e.showCount, v = e.count, m = e.className, y = e.style, C = e.disabled, S = e.hidden, b = e.classNames, w = e.styles, x = e.onResize, R = e.readOnly, _ = $t(e, lde), T = xn(n, {
    value: i,
    defaultValue: n
  }), P = ae(T, 2), D = P[0], O = P[1], A = D == null ? "" : String(D), F = H.useState(!1), L = ae(F, 2), N = L[0], I = L[1], B = H.useRef(!1), M = H.useState(null), V = ae(M, 2), G = V[0], k = V[1], z = se(null), j = se(null), q = function() {
    var Ie;
    return (Ie = j.current) === null || Ie === void 0 ? void 0 : Ie.textArea;
  }, K = function() {
    q().focus();
  };
  Zc(t, function() {
    var Pe;
    return {
      resizableTextArea: j.current,
      focus: K,
      blur: function() {
        q().blur();
      },
      nativeElement: ((Pe = z.current) === null || Pe === void 0 ? void 0 : Pe.nativeElement) || q()
    };
  }), Nt(function() {
    I(function(Pe) {
      return !C && Pe;
    });
  }, [C]);
  var Z = H.useState(null), re = ae(Z, 2), X = re[0], Y = re[1];
  H.useEffect(function() {
    if (X) {
      var Pe;
      (Pe = q()).setSelectionRange.apply(Pe, it(X));
    }
  }, [X]);
  var U = n3(v, g), oe = (r = U.max) !== null && r !== void 0 ? r : u, W = Number(oe) > 0, ne = U.strategy(A), ce = !!oe && ne > oe, we = function(Ie, Ce) {
    var De = Ce;
    !B.current && U.exceedFormatter && U.max && U.strategy(Ce) > U.max && (De = U.exceedFormatter(Ce, {
      max: U.max
    }), Ce !== De && Y([q().selectionStart || 0, q().selectionEnd || 0])), O(De), H0(Ie.currentTarget, Ie, s, De);
  }, Re = function(Ie) {
    B.current = !0, c == null || c(Ie);
  }, ve = function(Ie) {
    B.current = !1, we(Ie, Ie.currentTarget.value), d == null || d(Ie);
  }, xe = function(Ie) {
    we(Ie, Ie.target.value);
  }, _e = function(Ie) {
    var Ce = _.onPressEnter, De = _.onKeyDown;
    Ie.key === "Enter" && Ce && Ce(Ie), De == null || De(Ie);
  }, Ve = function(Ie) {
    I(!0), o == null || o(Ie);
  }, Fe = function(Ie) {
    I(!1), a == null || a(Ie);
  }, Ne = function(Ie) {
    O(""), K(), H0(q(), Ie, s);
  }, Je = h, J;
  U.show && (U.showFormatter ? J = U.showFormatter({
    value: A,
    count: ne,
    maxLength: oe
  }) : J = "".concat(ne).concat(W ? " / ".concat(oe) : ""), Je = /* @__PURE__ */ H.createElement(H.Fragment, null, Je, /* @__PURE__ */ H.createElement("span", {
    className: ue("".concat(p, "-data-count"), b == null ? void 0 : b.count),
    style: w == null ? void 0 : w.count
  }, J)));
  var he = function(Ie) {
    var Ce;
    x == null || x(Ie), (Ce = q()) !== null && Ce !== void 0 && Ce.style.height && k(!0);
  }, Le = !_.autoSize && !g && !l;
  return /* @__PURE__ */ H.createElement(r3, {
    ref: z,
    value: A,
    allowClear: l,
    handleReset: Ne,
    suffix: Je,
    prefixCls: p,
    classNames: ee(ee({}, b), {}, {
      affixWrapper: ue(b == null ? void 0 : b.affixWrapper, te(te({}, "".concat(p, "-show-count"), g), "".concat(p, "-textarea-allow-clear"), l))
    }),
    disabled: C,
    focused: N,
    className: ue(m, ce && "".concat(p, "-out-of-range")),
    style: ee(ee({}, y), G && !Le ? {
      height: "auto"
    } : {}),
    dataAttrs: {
      affixWrapper: {
        "data-count": typeof J == "string" ? J : void 0
      }
    },
    hidden: S,
    readOnly: R
  }, /* @__PURE__ */ H.createElement(sde, $e({}, _, {
    maxLength: u,
    onKeyDown: _e,
    onChange: xe,
    onFocus: Ve,
    onBlur: Fe,
    onCompositionStart: Re,
    onCompositionEnd: ve,
    className: ue(b == null ? void 0 : b.textarea),
    style: ee(ee({}, w == null ? void 0 : w.textarea), {}, {
      resize: y == null ? void 0 : y.resize
    }),
    disabled: C,
    prefixCls: p,
    onResize: he,
    ref: j,
    readOnly: R
  })));
}), cde = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const pM = /* @__PURE__ */ yn((e, t) => {
  var r, n;
  const {
    prefixCls: i,
    bordered: o = !0,
    size: a,
    disabled: s,
    status: l,
    allowClear: u,
    classNames: c,
    rootClassName: d,
    className: h,
    style: f,
    styles: p,
    variant: g
  } = e, v = cde(e, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated: M
    } = en("TextArea");
    M(!("bordered" in e), "bordered", "variant");
  }
  const {
    getPrefixCls: m,
    direction: y,
    textArea: C
  } = E.useContext(Yt), S = sl(a), b = E.useContext($c), w = s ?? b, {
    status: x,
    hasFeedback: R,
    feedbackIcon: _
  } = E.useContext(ps), T = _S(x, l), P = E.useRef(null);
  E.useImperativeHandle(t, () => {
    var M;
    return {
      resizableTextArea: (M = P.current) === null || M === void 0 ? void 0 : M.resizableTextArea,
      focus: (V) => {
        var G, k;
        Hce((k = (G = P.current) === null || G === void 0 ? void 0 : G.resizableTextArea) === null || k === void 0 ? void 0 : k.textArea, V);
      },
      blur: () => {
        var V;
        return (V = P.current) === null || V === void 0 ? void 0 : V.blur();
      }
    };
  });
  const D = m("input", i), O = ed(D), [A, F, L] = cM(D, O), [N, I] = QP("textArea", g, o), B = i3(u ?? (C == null ? void 0 : C.allowClear));
  return A(/* @__PURE__ */ E.createElement(ude, Object.assign({
    autoComplete: C == null ? void 0 : C.autoComplete
  }, v, {
    style: Object.assign(Object.assign({}, C == null ? void 0 : C.style), f),
    styles: Object.assign(Object.assign({}, C == null ? void 0 : C.styles), p),
    disabled: w,
    allowClear: B,
    className: ue(L, O, h, d, C == null ? void 0 : C.className),
    classNames: Object.assign(Object.assign(Object.assign({}, c), C == null ? void 0 : C.classNames), {
      textarea: ue({
        [`${D}-sm`]: S === "small",
        [`${D}-lg`]: S === "large"
      }, F, c == null ? void 0 : c.textarea, (r = C == null ? void 0 : C.classNames) === null || r === void 0 ? void 0 : r.textarea),
      variant: ue({
        [`${D}-${N}`]: I
      }, B0(D, T)),
      affixWrapper: ue(`${D}-textarea-affix-wrapper`, {
        [`${D}-affix-wrapper-rtl`]: y === "rtl",
        [`${D}-affix-wrapper-sm`]: S === "small",
        [`${D}-affix-wrapper-lg`]: S === "large",
        [`${D}-textarea-show-count`]: e.showCount || ((n = e.count) === null || n === void 0 ? void 0 : n.show)
      }, F)
    }),
    prefixCls: D,
    suffix: R && /* @__PURE__ */ E.createElement("span", {
      className: `${D}-textarea-suffix`
    }, _),
    ref: P
  })));
}), eu = IS;
eu.Group = Vce;
eu.Search = u3;
eu.TextArea = pM;
eu.Password = l3;
eu.OTP = Kce;
const dde = {
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
}, c3 = /* @__PURE__ */ H.createContext({});
var hde = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const fde = (e) => Zo(e).map((t) => Object.assign(Object.assign({}, t == null ? void 0 : t.props), {
  key: t.key
}));
function pde(e, t, r) {
  const n = E.useMemo(() => (
    // Take `items` first or convert `children` into items
    t || fde(r)
  ), [t, r]);
  return E.useMemo(() => n.map((o) => {
    var {
      span: a
    } = o, s = hde(o, ["span"]);
    return Object.assign(Object.assign({}, s), {
      span: typeof a == "number" ? a : h8(e, a)
    });
  }), [n, e]);
}
function CL(e, t, r) {
  let n = e, i = !1;
  return (r === void 0 || r > t) && (n = Object.assign(Object.assign({}, e), {
    span: t
  }), i = r !== void 0), [n, i];
}
function gde(e, t) {
  const r = [];
  let n = [], i = t, o = !1;
  return e.filter((a) => a).forEach((a, s) => {
    const l = a == null ? void 0 : a.span, u = l || 1;
    if (s === e.length - 1) {
      const [c, d] = CL(a, i, l);
      o = o || d, n.push(c), r.push(n);
      return;
    }
    if (u < i)
      i -= u, n.push(a);
    else {
      const [c, d] = CL(a, i, u);
      o = o || d, n.push(c), r.push(n), i = t, n = [];
    }
  }), [r, o];
}
const vde = (e, t) => {
  const [r, n] = Et(() => gde(t, e), [t, e]);
  if (process.env.NODE_ENV !== "production") {
    const i = en("Descriptions");
    process.env.NODE_ENV !== "production" && i(!n, "usage", "Sum of column `span` in a line not match `column` of Descriptions.");
  }
  return r;
}, mde = (e) => {
  let {
    children: t
  } = e;
  return t;
};
function SL(e) {
  return e != null;
}
const bb = (e) => {
  const {
    itemPrefixCls: t,
    component: r,
    span: n,
    className: i,
    style: o,
    labelStyle: a,
    contentStyle: s,
    bordered: l,
    label: u,
    content: c,
    colon: d,
    type: h
  } = e, f = r;
  return l ? /* @__PURE__ */ E.createElement(f, {
    className: ue({
      [`${t}-item-label`]: h === "label",
      [`${t}-item-content`]: h === "content"
    }, i),
    style: o,
    colSpan: n
  }, SL(u) && /* @__PURE__ */ E.createElement("span", {
    style: a
  }, u), SL(c) && /* @__PURE__ */ E.createElement("span", {
    style: s
  }, c)) : /* @__PURE__ */ E.createElement(f, {
    className: ue(`${t}-item`, i),
    style: o,
    colSpan: n
  }, /* @__PURE__ */ E.createElement("div", {
    className: `${t}-item-container`
  }, (u || u === 0) && /* @__PURE__ */ E.createElement("span", {
    className: ue(`${t}-item-label`, {
      [`${t}-item-no-colon`]: !d
    }),
    style: a
  }, u), (c || c === 0) && /* @__PURE__ */ E.createElement("span", {
    className: ue(`${t}-item-content`),
    style: s
  }, c)));
};
function xb(e, t, r) {
  let {
    colon: n,
    prefixCls: i,
    bordered: o
  } = t, {
    component: a,
    type: s,
    showLabel: l,
    showContent: u,
    labelStyle: c,
    contentStyle: d
  } = r;
  return e.map((h, f) => {
    let {
      label: p,
      children: g,
      prefixCls: v = i,
      className: m,
      style: y,
      labelStyle: C,
      contentStyle: S,
      span: b = 1,
      key: w
    } = h;
    return typeof a == "string" ? /* @__PURE__ */ E.createElement(bb, {
      key: `${s}-${w || f}`,
      className: m,
      style: y,
      labelStyle: Object.assign(Object.assign({}, c), C),
      contentStyle: Object.assign(Object.assign({}, d), S),
      span: b,
      colon: n,
      component: a,
      itemPrefixCls: v,
      bordered: o,
      label: l ? p : null,
      content: u ? g : null,
      type: s
    }) : [/* @__PURE__ */ E.createElement(bb, {
      key: `label-${w || f}`,
      className: m,
      style: Object.assign(Object.assign(Object.assign({}, c), y), C),
      span: 1,
      colon: n,
      component: a[0],
      itemPrefixCls: v,
      bordered: o,
      label: p,
      type: "label"
    }), /* @__PURE__ */ E.createElement(bb, {
      key: `content-${w || f}`,
      className: m,
      style: Object.assign(Object.assign(Object.assign({}, d), y), S),
      span: b * 2 - 1,
      component: a[1],
      itemPrefixCls: v,
      bordered: o,
      content: g,
      type: "content"
    })];
  });
}
const yde = (e) => {
  const t = E.useContext(c3), {
    prefixCls: r,
    vertical: n,
    row: i,
    index: o,
    bordered: a
  } = e;
  return n ? /* @__PURE__ */ E.createElement(E.Fragment, null, /* @__PURE__ */ E.createElement("tr", {
    key: `label-${o}`,
    className: `${r}-row`
  }, xb(i, e, Object.assign({
    component: "th",
    type: "label",
    showLabel: !0
  }, t))), /* @__PURE__ */ E.createElement("tr", {
    key: `content-${o}`,
    className: `${r}-row`
  }, xb(i, e, Object.assign({
    component: "td",
    type: "content",
    showContent: !0
  }, t)))) : /* @__PURE__ */ E.createElement("tr", {
    key: o,
    className: `${r}-row`
  }, xb(i, e, Object.assign({
    component: a ? ["th", "td"] : "td",
    type: "item",
    showLabel: !0,
    showContent: !0
  }, t)));
}, Cde = (e) => {
  const {
    componentCls: t,
    labelBg: r
  } = e;
  return {
    [`&${t}-bordered`]: {
      [`> ${t}-view`]: {
        border: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`,
        "> table": {
          tableLayout: "auto"
        },
        [`${t}-row`]: {
          borderBottom: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`,
          "&:last-child": {
            borderBottom: "none"
          },
          [`> ${t}-item-label, > ${t}-item-content`]: {
            padding: `${de(e.padding)} ${de(e.paddingLG)}`,
            borderInlineEnd: `${de(e.lineWidth)} ${e.lineType} ${e.colorSplit}`,
            "&:last-child": {
              borderInlineEnd: "none"
            }
          },
          [`> ${t}-item-label`]: {
            color: e.colorTextSecondary,
            backgroundColor: r,
            "&::after": {
              display: "none"
            }
          }
        }
      },
      [`&${t}-middle`]: {
        [`${t}-row`]: {
          [`> ${t}-item-label, > ${t}-item-content`]: {
            padding: `${de(e.paddingSM)} ${de(e.paddingLG)}`
          }
        }
      },
      [`&${t}-small`]: {
        [`${t}-row`]: {
          [`> ${t}-item-label, > ${t}-item-content`]: {
            padding: `${de(e.paddingXS)} ${de(e.padding)}`
          }
        }
      }
    }
  };
}, Sde = (e) => {
  const {
    componentCls: t,
    extraColor: r,
    itemPaddingBottom: n,
    colonMarginRight: i,
    colonMarginLeft: o,
    titleMarginBottom: a
  } = e;
  return {
    [t]: Object.assign(Object.assign(Object.assign({}, Fi(e)), Cde(e)), {
      "&-rtl": {
        direction: "rtl"
      },
      [`${t}-header`]: {
        display: "flex",
        alignItems: "center",
        marginBottom: a
      },
      [`${t}-title`]: Object.assign(Object.assign({}, Xl), {
        flex: "auto",
        color: e.titleColor,
        fontWeight: e.fontWeightStrong,
        fontSize: e.fontSizeLG,
        lineHeight: e.lineHeightLG
      }),
      [`${t}-extra`]: {
        marginInlineStart: "auto",
        color: r,
        fontSize: e.fontSize
      },
      [`${t}-view`]: {
        width: "100%",
        borderRadius: e.borderRadiusLG,
        table: {
          width: "100%",
          tableLayout: "fixed",
          borderCollapse: "collapse"
        }
      },
      [`${t}-row`]: {
        "> th, > td": {
          paddingBottom: n
        },
        "&:last-child": {
          borderBottom: "none"
        }
      },
      [`${t}-item-label`]: {
        color: e.colorTextTertiary,
        fontWeight: "normal",
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        textAlign: "start",
        "&::after": {
          content: '":"',
          position: "relative",
          top: -0.5,
          // magic for position
          marginInline: `${de(o)} ${de(i)}`
        },
        [`&${t}-item-no-colon::after`]: {
          content: '""'
        }
      },
      [`${t}-item-no-label`]: {
        "&::after": {
          margin: 0,
          content: '""'
        }
      },
      [`${t}-item-content`]: {
        display: "table-cell",
        flex: 1,
        color: e.contentColor,
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        wordBreak: "break-word",
        overflowWrap: "break-word"
      },
      [`${t}-item`]: {
        paddingBottom: 0,
        verticalAlign: "top",
        "&-container": {
          display: "flex",
          [`${t}-item-label`]: {
            display: "inline-flex",
            alignItems: "baseline"
          },
          [`${t}-item-content`]: {
            display: "inline-flex",
            alignItems: "baseline"
          }
        }
      },
      "&-middle": {
        [`${t}-row`]: {
          "> th, > td": {
            paddingBottom: e.paddingSM
          }
        }
      },
      "&-small": {
        [`${t}-row`]: {
          "> th, > td": {
            paddingBottom: e.paddingXS
          }
        }
      }
    })
  };
}, wde = (e) => ({
  labelBg: e.colorFillAlter,
  titleColor: e.colorText,
  titleMarginBottom: e.fontSizeSM * e.lineHeightSM,
  itemPaddingBottom: e.padding,
  colonMarginRight: e.marginXS,
  colonMarginLeft: e.marginXXS / 2,
  contentColor: e.colorText,
  extraColor: e.colorText
}), bde = Gn("Descriptions", (e) => {
  const t = Br(e, {});
  return Sde(t);
}, wde);
var xde = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const G0 = (e) => {
  const {
    prefixCls: t,
    title: r,
    extra: n,
    column: i,
    colon: o = !0,
    bordered: a,
    layout: s,
    children: l,
    className: u,
    rootClassName: c,
    style: d,
    size: h,
    labelStyle: f,
    contentStyle: p,
    items: g
  } = e, v = xde(e, ["prefixCls", "title", "extra", "column", "colon", "bordered", "layout", "children", "className", "rootClassName", "style", "size", "labelStyle", "contentStyle", "items"]), {
    getPrefixCls: m,
    direction: y,
    descriptions: C
  } = E.useContext(Yt), S = m("descriptions", t), b = Kse(), w = E.useMemo(() => {
    var A;
    return typeof i == "number" ? i : (A = h8(b, Object.assign(Object.assign({}, dde), i))) !== null && A !== void 0 ? A : 3;
  }, [b, i]), x = pde(b, g, l), R = sl(h), _ = vde(w, x), [T, P, D] = bde(S), O = E.useMemo(() => ({
    labelStyle: f,
    contentStyle: p
  }), [f, p]);
  return T(/* @__PURE__ */ E.createElement(c3.Provider, {
    value: O
  }, /* @__PURE__ */ E.createElement("div", Object.assign({
    className: ue(S, C == null ? void 0 : C.className, {
      [`${S}-${R}`]: R && R !== "default",
      [`${S}-bordered`]: !!a,
      [`${S}-rtl`]: y === "rtl"
    }, u, c, P, D),
    style: Object.assign(Object.assign({}, C == null ? void 0 : C.style), d)
  }, v), (r || n) && /* @__PURE__ */ E.createElement("div", {
    className: `${S}-header`
  }, r && /* @__PURE__ */ E.createElement("div", {
    className: `${S}-title`
  }, r), n && /* @__PURE__ */ E.createElement("div", {
    className: `${S}-extra`
  }, n)), /* @__PURE__ */ E.createElement("div", {
    className: `${S}-view`
  }, /* @__PURE__ */ E.createElement("table", null, /* @__PURE__ */ E.createElement("tbody", null, _.map((A, F) => /* @__PURE__ */ E.createElement(yde, {
    key: F,
    index: F,
    colon: o,
    prefixCls: S,
    vertical: s === "vertical",
    bordered: a,
    row: A
  }))))))));
};
process.env.NODE_ENV !== "production" && (G0.displayName = "Descriptions");
G0.Item = mde;
function wL(e) {
  return ["small", "middle", "large"].includes(e);
}
const d3 = ["wrap", "nowrap", "wrap-reverse"], h3 = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"], f3 = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"], Ede = (e, t) => {
  const r = t.wrap === !0 ? "wrap" : t.wrap;
  return {
    [`${e}-wrap-${r}`]: r && d3.includes(r)
  };
}, Rde = (e, t) => {
  const r = {};
  return f3.forEach((n) => {
    r[`${e}-align-${n}`] = t.align === n;
  }), r[`${e}-align-stretch`] = !t.align && !!t.vertical, r;
}, _de = (e, t) => {
  const r = {};
  return h3.forEach((n) => {
    r[`${e}-justify-${n}`] = t.justify === n;
  }), r;
};
function Tde(e, t) {
  return ue(Object.assign(Object.assign(Object.assign({}, Ede(e, t)), Rde(e, t)), _de(e, t)));
}
const Pde = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "flex",
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      },
      "&:empty": {
        display: "none"
      }
    }
  };
}, Mde = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      "&-gap-small": {
        gap: e.flexGapSM
      },
      "&-gap-middle": {
        gap: e.flexGap
      },
      "&-gap-large": {
        gap: e.flexGapLG
      }
    }
  };
}, Dde = (e) => {
  const {
    componentCls: t
  } = e, r = {};
  return d3.forEach((n) => {
    r[`${t}-wrap-${n}`] = {
      flexWrap: n
    };
  }), r;
}, Ade = (e) => {
  const {
    componentCls: t
  } = e, r = {};
  return f3.forEach((n) => {
    r[`${t}-align-${n}`] = {
      alignItems: n
    };
  }), r;
}, Ide = (e) => {
  const {
    componentCls: t
  } = e, r = {};
  return h3.forEach((n) => {
    r[`${t}-justify-${n}`] = {
      justifyContent: n
    };
  }), r;
}, Ode = () => ({}), Lde = Gn("Flex", (e) => {
  const {
    paddingXS: t,
    padding: r,
    paddingLG: n
  } = e, i = Br(e, {
    flexGapSM: t,
    flexGap: r,
    flexGapLG: n
  });
  return [Pde(i), Mde(i), Dde(i), Ade(i), Ide(i)];
}, Ode, {
  // Flex component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/46403
  resetStyle: !1
});
var Fde = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Zt = /* @__PURE__ */ H.forwardRef((e, t) => {
  const {
    prefixCls: r,
    rootClassName: n,
    className: i,
    style: o,
    flex: a,
    gap: s,
    children: l,
    vertical: u = !1,
    component: c = "div"
  } = e, d = Fde(e, ["prefixCls", "rootClassName", "className", "style", "flex", "gap", "children", "vertical", "component"]), {
    flex: h,
    direction: f,
    getPrefixCls: p
  } = H.useContext(Yt), g = p("flex", r), [v, m, y] = Lde(g), C = u ?? (h == null ? void 0 : h.vertical), S = ue(i, n, h == null ? void 0 : h.className, g, m, y, Tde(g, e), {
    [`${g}-rtl`]: f === "rtl",
    [`${g}-gap-${s}`]: wL(s),
    [`${g}-vertical`]: C
  }), b = Object.assign(Object.assign({}, h == null ? void 0 : h.style), o);
  return a && (b.flex = a), s && !wL(s) && (b.gap = s), v(/* @__PURE__ */ H.createElement(c, Object.assign({
    ref: t,
    className: S,
    style: b
  }, ni(d, ["justify", "wrap", "align"])), l));
});
process.env.NODE_ENV !== "production" && (Zt.displayName = "Flex");
function p3() {
  var e = document.documentElement.clientWidth, t = window.innerHeight || document.documentElement.clientHeight;
  return {
    width: e,
    height: t
  };
}
function Nde(e) {
  var t = e.getBoundingClientRect(), r = document.documentElement;
  return {
    left: t.left + (window.pageXOffset || r.scrollLeft) - (r.clientLeft || document.body.clientLeft || 0),
    top: t.top + (window.pageYOffset || r.scrollTop) - (r.clientTop || document.body.clientTop || 0)
  };
}
function hh(e, t, r, n) {
  var i = Bc.unstable_batchedUpdates ? function(a) {
    Bc.unstable_batchedUpdates(r, a);
  } : r;
  return e != null && e.addEventListener && e.addEventListener(t, i, n), {
    remove: function() {
      e != null && e.removeEventListener && e.removeEventListener(t, i, n);
    }
  };
}
var Rv = /* @__PURE__ */ E.createContext(null), kde = function(t) {
  var r = t.visible, n = t.maskTransitionName, i = t.getContainer, o = t.prefixCls, a = t.rootClassName, s = t.icons, l = t.countRender, u = t.showSwitch, c = t.showProgress, d = t.current, h = t.transform, f = t.count, p = t.scale, g = t.minScale, v = t.maxScale, m = t.closeIcon, y = t.onSwitchLeft, C = t.onSwitchRight, S = t.onClose, b = t.onZoomIn, w = t.onZoomOut, x = t.onRotateRight, R = t.onRotateLeft, _ = t.onFlipX, T = t.onFlipY, P = t.onReset, D = t.toolbarRender, O = t.zIndex, A = t.image, F = vr(Rv), L = s.rotateLeft, N = s.rotateRight, I = s.zoomIn, B = s.zoomOut, M = s.close, V = s.left, G = s.right, k = s.flipX, z = s.flipY, j = "".concat(o, "-operations-operation");
  E.useEffect(function() {
    var re = function(Y) {
      Y.keyCode === Ae.ESC && S();
    };
    return r && window.addEventListener("keydown", re), function() {
      window.removeEventListener("keydown", re);
    };
  }, [r]);
  var q = [{
    icon: z,
    onClick: T,
    type: "flipY"
  }, {
    icon: k,
    onClick: _,
    type: "flipX"
  }, {
    icon: L,
    onClick: R,
    type: "rotateLeft"
  }, {
    icon: N,
    onClick: x,
    type: "rotateRight"
  }, {
    icon: B,
    onClick: w,
    type: "zoomOut",
    disabled: p <= g
  }, {
    icon: I,
    onClick: b,
    type: "zoomIn",
    disabled: p === v
  }], K = q.map(function(re) {
    var X, Y = re.icon, U = re.onClick, oe = re.type, W = re.disabled;
    return /* @__PURE__ */ E.createElement("div", {
      className: ue(j, (X = {}, te(X, "".concat(o, "-operations-operation-").concat(oe), !0), te(X, "".concat(o, "-operations-operation-disabled"), !!W), X)),
      onClick: U,
      key: oe
    }, Y);
  }), Z = /* @__PURE__ */ E.createElement("div", {
    className: "".concat(o, "-operations")
  }, K);
  return /* @__PURE__ */ E.createElement(Cs, {
    visible: r,
    motionName: n
  }, function(re) {
    var X = re.className, Y = re.style;
    return /* @__PURE__ */ E.createElement(Cv, {
      open: !0,
      getContainer: i ?? document.body
    }, /* @__PURE__ */ E.createElement("div", {
      className: ue("".concat(o, "-operations-wrapper"), X, a),
      style: ee(ee({}, Y), {}, {
        zIndex: O
      })
    }, m === null ? null : /* @__PURE__ */ E.createElement("button", {
      className: "".concat(o, "-close"),
      onClick: S
    }, m || M), u && /* @__PURE__ */ E.createElement(E.Fragment, null, /* @__PURE__ */ E.createElement("div", {
      className: ue("".concat(o, "-switch-left"), te({}, "".concat(o, "-switch-left-disabled"), d === 0)),
      onClick: y
    }, V), /* @__PURE__ */ E.createElement("div", {
      className: ue("".concat(o, "-switch-right"), te({}, "".concat(o, "-switch-right-disabled"), d === f - 1)),
      onClick: C
    }, G)), /* @__PURE__ */ E.createElement("div", {
      className: "".concat(o, "-footer")
    }, c && /* @__PURE__ */ E.createElement("div", {
      className: "".concat(o, "-progress")
    }, l ? l(d + 1, f) : "".concat(d + 1, " / ").concat(f)), D ? D(Z, ee(ee({
      icons: {
        flipYIcon: K[0],
        flipXIcon: K[1],
        rotateLeftIcon: K[2],
        rotateRightIcon: K[3],
        zoomOutIcon: K[4],
        zoomInIcon: K[5]
      },
      actions: {
        onFlipY: T,
        onFlipX: _,
        onRotateLeft: R,
        onRotateRight: x,
        onZoomOut: w,
        onZoomIn: b,
        onReset: P,
        onClose: S
      },
      transform: h
    }, F ? {
      current: d,
      total: f
    } : {}), {}, {
      image: A
    })) : Z)));
  });
}, xm = {
  x: 0,
  y: 0,
  rotate: 0,
  scale: 1,
  flipX: !1,
  flipY: !1
};
function Vde(e, t, r, n) {
  var i = se(null), o = se([]), a = Me(xm), s = ae(a, 2), l = s[0], u = s[1], c = function(p) {
    u(xm), Nh(xm, l) || n == null || n({
      transform: xm,
      action: p
    });
  }, d = function(p, g) {
    i.current === null && (o.current = [], i.current = Ar(function() {
      u(function(v) {
        var m = v;
        return o.current.forEach(function(y) {
          m = ee(ee({}, m), y);
        }), i.current = null, n == null || n({
          transform: m,
          action: g
        }), m;
      });
    })), o.current.push(ee(ee({}, l), p));
  }, h = function(p, g, v, m, y) {
    var C = e.current, S = C.width, b = C.height, w = C.offsetWidth, x = C.offsetHeight, R = C.offsetLeft, _ = C.offsetTop, T = p, P = l.scale * p;
    P > r ? (P = r, T = r / l.scale) : P < t && (P = y ? P : t, T = P / l.scale);
    var D = v ?? innerWidth / 2, O = m ?? innerHeight / 2, A = T - 1, F = A * S * 0.5, L = A * b * 0.5, N = A * (D - l.x - R), I = A * (O - l.y - _), B = l.x - (N - F), M = l.y - (I - L);
    if (p < 1 && P === 1) {
      var V = w * P, G = x * P, k = p3(), z = k.width, j = k.height;
      V <= z && G <= j && (B = 0, M = 0);
    }
    d({
      x: B,
      y: M,
      scale: P
    }, g);
  };
  return {
    transform: l,
    resetTransform: c,
    updateTransform: d,
    dispatchZoomChange: h
  };
}
function bL(e, t, r, n) {
  var i = t + r, o = (r - n) / 2;
  if (r > n) {
    if (t > 0)
      return te({}, e, o);
    if (t < 0 && i < n)
      return te({}, e, -o);
  } else if (t < 0 || i > n)
    return te({}, e, t < 0 ? o : -o);
  return {};
}
function g3(e, t, r, n) {
  var i = p3(), o = i.width, a = i.height, s = null;
  return e <= o && t <= a ? s = {
    x: 0,
    y: 0
  } : (e > o || t > a) && (s = ee(ee({}, bL("x", r, e, o)), bL("y", n, t, a))), s;
}
var fh = 1, Bde = 1;
function $de(e, t, r, n, i, o, a) {
  var s = i.rotate, l = i.scale, u = i.x, c = i.y, d = Me(!1), h = ae(d, 2), f = h[0], p = h[1], g = se({
    diffX: 0,
    diffY: 0,
    transformX: 0,
    transformY: 0
  }), v = function(b) {
    !t || b.button !== 0 || (b.preventDefault(), b.stopPropagation(), g.current = {
      diffX: b.pageX - u,
      diffY: b.pageY - c,
      transformX: u,
      transformY: c
    }, p(!0));
  }, m = function(b) {
    r && f && o({
      x: b.pageX - g.current.diffX,
      y: b.pageY - g.current.diffY
    }, "move");
  }, y = function() {
    if (r && f) {
      p(!1);
      var b = g.current, w = b.transformX, x = b.transformY, R = u !== w && c !== x;
      if (!R) return;
      var _ = e.current.offsetWidth * l, T = e.current.offsetHeight * l, P = e.current.getBoundingClientRect(), D = P.left, O = P.top, A = s % 180 !== 0, F = g3(A ? T : _, A ? _ : T, D, O);
      F && o(ee({}, F), "dragRebound");
    }
  }, C = function(b) {
    if (!(!r || b.deltaY == 0)) {
      var w = Math.abs(b.deltaY / 100), x = Math.min(w, Bde), R = fh + x * n;
      b.deltaY > 0 && (R = fh / R), a(R, "wheel", b.clientX, b.clientY);
    }
  };
  return Nt(function() {
    var S, b, w, x;
    if (t) {
      w = hh(window, "mouseup", y, !1), x = hh(window, "mousemove", m, !1);
      try {
        window.top !== window.self && (S = hh(window.top, "mouseup", y, !1), b = hh(window.top, "mousemove", m, !1));
      } catch (R) {
        fs(!1, "[rc-image] ".concat(R));
      }
    }
    return function() {
      var R, _, T, P;
      (R = w) === null || R === void 0 || R.remove(), (_ = x) === null || _ === void 0 || _.remove(), (T = S) === null || T === void 0 || T.remove(), (P = b) === null || P === void 0 || P.remove();
    };
  }, [r, f, u, c, s, t]), {
    isMoving: f,
    onMouseDown: v,
    onMouseMove: m,
    onMouseUp: y,
    onWheel: C
  };
}
function Hde(e) {
  return new Promise(function(t) {
    var r = document.createElement("img");
    r.onerror = function() {
      return t(!1);
    }, r.onload = function() {
      return t(!0);
    }, r.src = e;
  });
}
function v3(e) {
  var t = e.src, r = e.isCustomPlaceholder, n = e.fallback, i = Me(r ? "loading" : "normal"), o = ae(i, 2), a = o[0], s = o[1], l = se(!1), u = a === "error";
  Nt(function() {
    var f = !0;
    return Hde(t).then(function(p) {
      !p && f && s("error");
    }), function() {
      f = !1;
    };
  }, [t]), Nt(function() {
    r && !l.current ? s("loading") : u && s("normal");
  }, [t]);
  var c = function() {
    s("normal");
  }, d = function(p) {
    l.current = !1, a === "loading" && p !== null && p !== void 0 && p.complete && (p.naturalWidth || p.naturalHeight) && (l.current = !0, c());
  }, h = u && n ? {
    src: n
  } : {
    onLoad: c,
    src: t
  };
  return [d, h, a];
}
function z0(e, t) {
  var r = e.x - t.x, n = e.y - t.y;
  return Math.hypot(r, n);
}
function Gde(e, t, r, n) {
  var i = z0(e, r), o = z0(t, n);
  if (i === 0 && o === 0)
    return [e.x, e.y];
  var a = i / (i + o), s = e.x + a * (t.x - e.x), l = e.y + a * (t.y - e.y);
  return [s, l];
}
function zde(e, t, r, n, i, o, a) {
  var s = i.rotate, l = i.scale, u = i.x, c = i.y, d = Me(!1), h = ae(d, 2), f = h[0], p = h[1], g = se({
    point1: {
      x: 0,
      y: 0
    },
    point2: {
      x: 0,
      y: 0
    },
    eventType: "none"
  }), v = function(b) {
    g.current = ee(ee({}, g.current), b);
  }, m = function(b) {
    if (t) {
      b.stopPropagation(), p(!0);
      var w = b.touches, x = w === void 0 ? [] : w;
      x.length > 1 ? v({
        point1: {
          x: x[0].clientX,
          y: x[0].clientY
        },
        point2: {
          x: x[1].clientX,
          y: x[1].clientY
        },
        eventType: "touchZoom"
      }) : v({
        point1: {
          x: x[0].clientX - u,
          y: x[0].clientY - c
        },
        eventType: "move"
      });
    }
  }, y = function(b) {
    var w = b.touches, x = w === void 0 ? [] : w, R = g.current, _ = R.point1, T = R.point2, P = R.eventType;
    if (x.length > 1 && P === "touchZoom") {
      var D = {
        x: x[0].clientX,
        y: x[0].clientY
      }, O = {
        x: x[1].clientX,
        y: x[1].clientY
      }, A = Gde(_, T, D, O), F = ae(A, 2), L = F[0], N = F[1], I = z0(D, O) / z0(_, T);
      a(I, "touchZoom", L, N, !0), v({
        point1: D,
        point2: O,
        eventType: "touchZoom"
      });
    } else P === "move" && (o({
      x: x[0].clientX - _.x,
      y: x[0].clientY - _.y
    }, "move"), v({
      eventType: "move"
    }));
  }, C = function() {
    if (r) {
      if (f && p(!1), v({
        eventType: "none"
      }), n > l)
        return o({
          x: 0,
          y: 0,
          scale: n
        }, "touchZoom");
      var b = e.current.offsetWidth * l, w = e.current.offsetHeight * l, x = e.current.getBoundingClientRect(), R = x.left, _ = x.top, T = s % 180 !== 0, P = g3(T ? w : b, T ? b : w, R, _);
      P && o(ee({}, P), "dragRebound");
    }
  };
  return Nt(function() {
    var S;
    return r && t && (S = hh(window, "touchmove", function(b) {
      return b.preventDefault();
    }, {
      passive: !1
    })), function() {
      var b;
      (b = S) === null || b === void 0 || b.remove();
    };
  }, [r, t]), {
    isTouching: f,
    onTouchStart: m,
    onTouchMove: y,
    onTouchEnd: C
  };
}
var Wde = ["fallback", "src", "imgRef"], jde = ["prefixCls", "src", "alt", "imageInfo", "fallback", "movable", "onClose", "visible", "icons", "rootClassName", "closeIcon", "getContainer", "current", "count", "countRender", "scaleStep", "minScale", "maxScale", "transitionName", "maskTransitionName", "imageRender", "imgCommonProps", "toolbarRender", "onTransform", "onChange"], Ude = function(t) {
  var r = t.fallback, n = t.src, i = t.imgRef, o = $t(t, Wde), a = v3({
    src: n,
    fallback: r
  }), s = ae(a, 2), l = s[0], u = s[1];
  return /* @__PURE__ */ H.createElement("img", $e({
    ref: function(d) {
      i.current = d, l(d);
    }
  }, o, u));
}, m3 = function(t) {
  var r = t.prefixCls, n = t.src, i = t.alt, o = t.imageInfo, a = t.fallback, s = t.movable, l = s === void 0 ? !0 : s, u = t.onClose, c = t.visible, d = t.icons, h = d === void 0 ? {} : d, f = t.rootClassName, p = t.closeIcon, g = t.getContainer, v = t.current, m = v === void 0 ? 0 : v, y = t.count, C = y === void 0 ? 1 : y, S = t.countRender, b = t.scaleStep, w = b === void 0 ? 0.5 : b, x = t.minScale, R = x === void 0 ? 1 : x, _ = t.maxScale, T = _ === void 0 ? 50 : _, P = t.transitionName, D = P === void 0 ? "zoom" : P, O = t.maskTransitionName, A = O === void 0 ? "fade" : O, F = t.imageRender, L = t.imgCommonProps, N = t.toolbarRender, I = t.onTransform, B = t.onChange, M = $t(t, jde), V = se(), G = vr(Rv), k = G && C > 1, z = G && C >= 1, j = Me(!0), q = ae(j, 2), K = q[0], Z = q[1], re = Vde(V, R, T, I), X = re.transform, Y = re.resetTransform, U = re.updateTransform, oe = re.dispatchZoomChange, W = $de(V, l, c, w, X, U, oe), ne = W.isMoving, ce = W.onMouseDown, we = W.onWheel, Re = zde(V, l, c, R, X, U, oe), ve = Re.isTouching, xe = Re.onTouchStart, _e = Re.onTouchMove, Ve = Re.onTouchEnd, Fe = X.rotate, Ne = X.scale, Je = ue(te({}, "".concat(r, "-moving"), ne));
  Nt(function() {
    K || Z(!0);
  }, [K]);
  var J = function() {
    Y("close");
  }, he = function() {
    oe(fh + w, "zoomIn");
  }, Le = function() {
    oe(fh / (fh + w), "zoomOut");
  }, Pe = function() {
    U({
      rotate: Fe + 90
    }, "rotateRight");
  }, Ie = function() {
    U({
      rotate: Fe - 90
    }, "rotateLeft");
  }, Ce = function() {
    U({
      flipX: !X.flipX
    }, "flipX");
  }, De = function() {
    U({
      flipY: !X.flipY
    }, "flipY");
  }, ze = function() {
    Y("reset");
  }, st = function(xt) {
    xt == null || xt.preventDefault(), xt == null || xt.stopPropagation(), m > 0 && (Z(!1), Y("prev"), B == null || B(m - 1, m));
  }, Tt = function(xt) {
    xt == null || xt.preventDefault(), xt == null || xt.stopPropagation(), m < C - 1 && (Z(!1), Y("next"), B == null || B(m + 1, m));
  }, ot = function(xt) {
    !c || !k || (xt.keyCode === Ae.LEFT ? st() : xt.keyCode === Ae.RIGHT && Tt());
  }, Xe = function(xt) {
    c && (Ne !== 1 ? U({
      x: 0,
      y: 0,
      scale: 1
    }, "doubleClick") : oe(fh + w, "doubleClick", xt.clientX, xt.clientY));
  };
  Nt(function() {
    var ft = hh(window, "keydown", ot, !1);
    return function() {
      ft.remove();
    };
  }, [c, k, m]);
  var Oe = /* @__PURE__ */ H.createElement(Ude, $e({}, L, {
    width: t.width,
    height: t.height,
    imgRef: V,
    className: "".concat(r, "-img"),
    alt: i,
    style: {
      transform: "translate3d(".concat(X.x, "px, ").concat(X.y, "px, 0) scale3d(").concat(X.flipX ? "-" : "").concat(Ne, ", ").concat(X.flipY ? "-" : "").concat(Ne, ", 1) rotate(").concat(Fe, "deg)"),
      transitionDuration: (!K || ve) && "0s"
    },
    fallback: a,
    src: n,
    onWheel: we,
    onMouseDown: ce,
    onDoubleClick: Xe,
    onTouchStart: xe,
    onTouchMove: _e,
    onTouchEnd: Ve,
    onTouchCancel: Ve
  })), Qe = ee({
    url: n,
    alt: i
  }, o);
  return /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(x5, $e({
    transitionName: D,
    maskTransitionName: A,
    closable: !1,
    keyboard: !0,
    prefixCls: r,
    onClose: u,
    visible: c,
    classNames: {
      wrapper: Je
    },
    rootClassName: f,
    getContainer: g
  }, M, {
    afterClose: J
  }), /* @__PURE__ */ H.createElement("div", {
    className: "".concat(r, "-img-wrapper")
  }, F ? F(Oe, ee({
    transform: X,
    image: Qe
  }, G ? {
    current: m
  } : {})) : Oe)), /* @__PURE__ */ H.createElement(kde, {
    visible: c,
    transform: X,
    maskTransitionName: A,
    closeIcon: p,
    getContainer: g,
    prefixCls: r,
    rootClassName: f,
    icons: h,
    countRender: S,
    showSwitch: k,
    showProgress: z,
    current: m,
    count: C,
    scale: Ne,
    minScale: R,
    maxScale: T,
    toolbarRender: N,
    onSwitchLeft: st,
    onSwitchRight: Tt,
    onZoomIn: he,
    onZoomOut: Le,
    onRotateRight: Pe,
    onRotateLeft: Ie,
    onFlipX: Ce,
    onFlipY: De,
    onClose: u,
    onReset: ze,
    zIndex: M.zIndex !== void 0 ? M.zIndex + 1 : void 0,
    image: Qe
  }));
}, jR = ["crossOrigin", "decoding", "draggable", "loading", "referrerPolicy", "sizes", "srcSet", "useMap", "alt"];
function Kde(e) {
  var t = E.useState({}), r = ae(t, 2), n = r[0], i = r[1], o = E.useCallback(function(s, l) {
    return i(function(u) {
      return ee(ee({}, u), {}, te({}, s, l));
    }), function() {
      i(function(u) {
        var c = ee({}, u);
        return delete c[s], c;
      });
    };
  }, []), a = E.useMemo(function() {
    return e ? e.map(function(s) {
      if (typeof s == "string")
        return {
          data: {
            src: s
          }
        };
      var l = {};
      return Object.keys(s).forEach(function(u) {
        ["src"].concat(it(jR)).includes(u) && (l[u] = s[u]);
      }), {
        data: l
      };
    }) : Object.keys(n).reduce(function(s, l) {
      var u = n[l], c = u.canPreview, d = u.data;
      return c && s.push({
        data: d,
        id: l
      }), s;
    }, []);
  }, [e, n]);
  return [a, o, !!e];
}
var Yde = ["visible", "onVisibleChange", "getContainer", "current", "movable", "minScale", "maxScale", "countRender", "closeIcon", "onChange", "onTransform", "toolbarRender", "imageRender"], qde = ["src"], Xde = function(t) {
  var r, n = t.previewPrefixCls, i = n === void 0 ? "rc-image-preview" : n, o = t.children, a = t.icons, s = a === void 0 ? {} : a, l = t.items, u = t.preview, c = t.fallback, d = vt(u) === "object" ? u : {}, h = d.visible, f = d.onVisibleChange, p = d.getContainer, g = d.current, v = d.movable, m = d.minScale, y = d.maxScale, C = d.countRender, S = d.closeIcon, b = d.onChange, w = d.onTransform, x = d.toolbarRender, R = d.imageRender, _ = $t(d, Yde), T = Kde(l), P = ae(T, 3), D = P[0], O = P[1], A = P[2], F = xn(0, {
    value: g
  }), L = ae(F, 2), N = L[0], I = L[1], B = Me(!1), M = ae(B, 2), V = M[0], G = M[1], k = ((r = D[N]) === null || r === void 0 ? void 0 : r.data) || {}, z = k.src, j = $t(k, qde), q = xn(!!h, {
    value: h,
    onChange: function(ve, xe) {
      f == null || f(ve, xe, N);
    }
  }), K = ae(q, 2), Z = K[0], re = K[1], X = Me(null), Y = ae(X, 2), U = Y[0], oe = Y[1], W = E.useCallback(function(Re, ve, xe, _e) {
    var Ve = A ? D.findIndex(function(Fe) {
      return Fe.data.src === ve;
    }) : D.findIndex(function(Fe) {
      return Fe.id === Re;
    });
    I(Ve < 0 ? 0 : Ve), re(!0), oe({
      x: xe,
      y: _e
    }), G(!0);
  }, [D, A]);
  E.useEffect(function() {
    Z ? V || I(0) : G(!1);
  }, [Z]);
  var ne = function(ve, xe) {
    I(ve), b == null || b(ve, xe);
  }, ce = function() {
    re(!1), oe(null);
  }, we = E.useMemo(function() {
    return {
      register: O,
      onPreview: W
    };
  }, [O, W]);
  return /* @__PURE__ */ E.createElement(Rv.Provider, {
    value: we
  }, o, /* @__PURE__ */ E.createElement(m3, $e({
    "aria-hidden": !Z,
    movable: v,
    visible: Z,
    prefixCls: i,
    closeIcon: S,
    onClose: ce,
    mousePosition: U,
    imgCommonProps: j,
    src: z,
    fallback: c,
    icons: s,
    minScale: m,
    maxScale: y,
    getContainer: p,
    current: N,
    count: D.length,
    countRender: C,
    onTransform: w,
    toolbarRender: x,
    imageRender: R,
    onChange: ne
  }, _)));
}, xL = 0;
function Zde(e, t) {
  var r = E.useState(function() {
    return xL += 1, String(xL);
  }), n = ae(r, 1), i = n[0], o = E.useContext(Rv), a = {
    data: t,
    canPreview: e
  };
  return E.useEffect(function() {
    if (o)
      return o.register(i, a);
  }, []), E.useEffect(function() {
    o && o.register(i, a);
  }, [e, t]), i;
}
var Qde = ["src", "alt", "onPreviewClose", "prefixCls", "previewPrefixCls", "placeholder", "fallback", "width", "height", "style", "preview", "className", "onClick", "onError", "wrapperClassName", "wrapperStyle", "rootClassName"], Jde = ["src", "visible", "onVisibleChange", "getContainer", "mask", "maskClassName", "movable", "icons", "scaleStep", "minScale", "maxScale", "imageRender", "toolbarRender"], OS = function(t) {
  var r = t.src, n = t.alt, i = t.onPreviewClose, o = t.prefixCls, a = o === void 0 ? "rc-image" : o, s = t.previewPrefixCls, l = s === void 0 ? "".concat(a, "-preview") : s, u = t.placeholder, c = t.fallback, d = t.width, h = t.height, f = t.style, p = t.preview, g = p === void 0 ? !0 : p, v = t.className, m = t.onClick, y = t.onError, C = t.wrapperClassName, S = t.wrapperStyle, b = t.rootClassName, w = $t(t, Qde), x = u && u !== !0, R = vt(g) === "object" ? g : {}, _ = R.src, T = R.visible, P = T === void 0 ? void 0 : T, D = R.onVisibleChange, O = D === void 0 ? i : D, A = R.getContainer, F = A === void 0 ? void 0 : A, L = R.mask, N = R.maskClassName, I = R.movable, B = R.icons, M = R.scaleStep, V = R.minScale, G = R.maxScale, k = R.imageRender, z = R.toolbarRender, j = $t(R, Jde), q = _ ?? r, K = xn(!!P, {
    value: P,
    onChange: O
  }), Z = ae(K, 2), re = Z[0], X = Z[1], Y = v3({
    src: r,
    isCustomPlaceholder: x,
    fallback: c
  }), U = ae(Y, 3), oe = U[0], W = U[1], ne = U[2], ce = Me(null), we = ae(ce, 2), Re = we[0], ve = we[1], xe = vr(Rv), _e = !!g, Ve = function() {
    X(!1), ve(null);
  }, Fe = ue(a, C, b, te({}, "".concat(a, "-error"), ne === "error")), Ne = Et(function() {
    var Le = {};
    return jR.forEach(function(Pe) {
      t[Pe] !== void 0 && (Le[Pe] = t[Pe]);
    }), Le;
  }, jR.map(function(Le) {
    return t[Le];
  })), Je = Et(function() {
    return ee(ee({}, Ne), {}, {
      src: q
    });
  }, [q, Ne]), J = Zde(_e, Je), he = function(Pe) {
    var Ie = Nde(Pe.target), Ce = Ie.left, De = Ie.top;
    xe ? xe.onPreview(J, q, Ce, De) : (ve({
      x: Ce,
      y: De
    }), X(!0)), m == null || m(Pe);
  };
  return /* @__PURE__ */ E.createElement(E.Fragment, null, /* @__PURE__ */ E.createElement("div", $e({}, w, {
    className: Fe,
    onClick: _e ? he : m,
    style: ee({
      width: d,
      height: h
    }, S)
  }), /* @__PURE__ */ E.createElement("img", $e({}, Ne, {
    className: ue("".concat(a, "-img"), te({}, "".concat(a, "-img-placeholder"), u === !0), v),
    style: ee({
      height: h
    }, f),
    ref: oe
  }, W, {
    width: d,
    height: h,
    onError: y
  })), ne === "loading" && /* @__PURE__ */ E.createElement("div", {
    "aria-hidden": "true",
    className: "".concat(a, "-placeholder")
  }, u), L && _e && /* @__PURE__ */ E.createElement("div", {
    className: ue("".concat(a, "-mask"), N),
    style: {
      display: (f == null ? void 0 : f.display) === "none" ? "none" : void 0
    }
  }, L)), !xe && _e && /* @__PURE__ */ E.createElement(m3, $e({
    "aria-hidden": !re,
    visible: re,
    prefixCls: l,
    onClose: Ve,
    mousePosition: Re,
    src: q,
    alt: n,
    imageInfo: {
      width: d,
      height: h
    },
    fallback: c,
    getContainer: F,
    icons: B,
    movable: I,
    scaleStep: M,
    minScale: V,
    maxScale: G,
    rootClassName: b,
    imageRender: k,
    imgCommonProps: Ne,
    toolbarRender: z
  }, j)));
};
OS.PreviewGroup = Xde;
process.env.NODE_ENV !== "production" && (OS.displayName = "Image");
var ehe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { tag: "path", attrs: { d: "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, name: "rotate-left", theme: "outlined" }, the = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: ehe
  }));
}, y3 = /* @__PURE__ */ E.forwardRef(the);
process.env.NODE_ENV !== "production" && (y3.displayName = "RotateLeftOutlined");
var rhe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { tag: "path", attrs: { d: "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, name: "rotate-right", theme: "outlined" }, nhe = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: rhe
  }));
}, C3 = /* @__PURE__ */ E.forwardRef(nhe);
process.env.NODE_ENV !== "production" && (C3.displayName = "RotateRightOutlined");
var ihe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, name: "swap", theme: "outlined" }, ohe = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: ihe
  }));
}, UR = /* @__PURE__ */ E.forwardRef(ohe);
process.env.NODE_ENV !== "production" && (UR.displayName = "SwapOutlined");
var ahe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-in", theme: "outlined" }, she = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: ahe
  }));
}, S3 = /* @__PURE__ */ E.forwardRef(she);
process.env.NODE_ENV !== "production" && (S3.displayName = "ZoomInOutlined");
var lhe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-out", theme: "outlined" }, uhe = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: lhe
  }));
}, w3 = /* @__PURE__ */ E.forwardRef(uhe);
process.env.NODE_ENV !== "production" && (w3.displayName = "ZoomOutOutlined");
const KR = (e) => ({
  position: e || "absolute",
  inset: 0
}), che = (e) => {
  const {
    iconCls: t,
    motionDurationSlow: r,
    paddingXXS: n,
    marginXXS: i,
    prefixCls: o,
    colorTextLightSolid: a
  } = e;
  return {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: a,
    background: new Jr("#000").setAlpha(0.5).toRgbString(),
    cursor: "pointer",
    opacity: 0,
    transition: `opacity ${r}`,
    [`.${o}-mask-info`]: Object.assign(Object.assign({}, Xl), {
      padding: `0 ${de(n)}`,
      [t]: {
        marginInlineEnd: i,
        svg: {
          verticalAlign: "baseline"
        }
      }
    })
  };
}, dhe = (e) => {
  const {
    previewCls: t,
    modalMaskBg: r,
    paddingSM: n,
    marginXL: i,
    margin: o,
    paddingLG: a,
    previewOperationColorDisabled: s,
    previewOperationHoverColor: l,
    motionDurationSlow: u,
    iconCls: c,
    colorTextLightSolid: d
  } = e, h = new Jr(r).setAlpha(0.1), f = h.clone().setAlpha(0.2);
  return {
    [`${t}-footer`]: {
      position: "fixed",
      bottom: i,
      left: {
        _skip_check_: !0,
        value: 0
      },
      width: "100%",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      color: e.previewOperationColor
    },
    [`${t}-progress`]: {
      marginBottom: o
    },
    [`${t}-close`]: {
      position: "fixed",
      top: i,
      right: {
        _skip_check_: !0,
        value: i
      },
      display: "flex",
      color: d,
      backgroundColor: h.toRgbString(),
      borderRadius: "50%",
      padding: n,
      outline: 0,
      border: 0,
      cursor: "pointer",
      transition: `all ${u}`,
      "&:hover": {
        backgroundColor: f.toRgbString()
      },
      [`& > ${c}`]: {
        fontSize: e.previewOperationSize
      }
    },
    [`${t}-operations`]: {
      display: "flex",
      alignItems: "center",
      padding: `0 ${de(a)}`,
      backgroundColor: h.toRgbString(),
      borderRadius: 100,
      "&-operation": {
        marginInlineStart: n,
        padding: n,
        cursor: "pointer",
        transition: `all ${u}`,
        userSelect: "none",
        [`&:not(${t}-operations-operation-disabled):hover > ${c}`]: {
          color: l
        },
        "&-disabled": {
          color: s,
          cursor: "not-allowed"
        },
        "&:first-of-type": {
          marginInlineStart: 0
        },
        [`& > ${c}`]: {
          fontSize: e.previewOperationSize
        }
      }
    }
  };
}, hhe = (e) => {
  const {
    modalMaskBg: t,
    iconCls: r,
    previewOperationColorDisabled: n,
    previewCls: i,
    zIndexPopup: o,
    motionDurationSlow: a
  } = e, s = new Jr(t).setAlpha(0.1), l = s.clone().setAlpha(0.2);
  return {
    [`${i}-switch-left, ${i}-switch-right`]: {
      position: "fixed",
      insetBlockStart: "50%",
      zIndex: e.calc(o).add(1).equal(),
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: e.imagePreviewSwitchSize,
      height: e.imagePreviewSwitchSize,
      marginTop: e.calc(e.imagePreviewSwitchSize).mul(-1).div(2).equal(),
      color: e.previewOperationColor,
      background: s.toRgbString(),
      borderRadius: "50%",
      transform: "translateY(-50%)",
      cursor: "pointer",
      transition: `all ${a}`,
      userSelect: "none",
      "&:hover": {
        background: l.toRgbString()
      },
      "&-disabled": {
        "&, &:hover": {
          color: n,
          background: "transparent",
          cursor: "not-allowed",
          [`> ${r}`]: {
            cursor: "not-allowed"
          }
        }
      },
      [`> ${r}`]: {
        fontSize: e.previewOperationSize
      }
    },
    [`${i}-switch-left`]: {
      insetInlineStart: e.marginSM
    },
    [`${i}-switch-right`]: {
      insetInlineEnd: e.marginSM
    }
  };
}, fhe = (e) => {
  const {
    motionEaseOut: t,
    previewCls: r,
    motionDurationSlow: n,
    componentCls: i
  } = e;
  return [
    {
      [`${i}-preview-root`]: {
        [r]: {
          height: "100%",
          textAlign: "center",
          pointerEvents: "none"
        },
        [`${r}-body`]: Object.assign(Object.assign({}, KR()), {
          overflow: "hidden"
        }),
        [`${r}-img`]: {
          maxWidth: "100%",
          maxHeight: "70%",
          verticalAlign: "middle",
          transform: "scale3d(1, 1, 1)",
          cursor: "grab",
          transition: `transform ${n} ${t} 0s`,
          userSelect: "none",
          "&-wrapper": Object.assign(Object.assign({}, KR()), {
            transition: `transform ${n} ${t} 0s`,
            // https://github.com/ant-design/ant-design/issues/39913
            // TailwindCSS will reset img default style.
            // Let's set back.
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "& > *": {
              pointerEvents: "auto"
            },
            "&::before": {
              display: "inline-block",
              width: 1,
              height: "50%",
              marginInlineEnd: -1,
              content: '""'
            }
          })
        },
        [`${r}-moving`]: {
          [`${r}-preview-img`]: {
            cursor: "grabbing",
            "&-wrapper": {
              transitionDuration: "0s"
            }
          }
        }
      }
    },
    // Override
    {
      [`${i}-preview-root`]: {
        [`${r}-wrap`]: {
          zIndex: e.zIndexPopup
        }
      }
    },
    // Preview operations & switch
    {
      [`${i}-preview-operations-wrapper`]: {
        position: "fixed",
        zIndex: e.calc(e.zIndexPopup).add(1).equal()
      },
      "&": [dhe(e), hhe(e)]
    }
  ];
}, phe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ============================== image ==============================
    [t]: {
      position: "relative",
      display: "inline-block",
      [`${t}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${t}-img-placeholder`]: {
        backgroundColor: e.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${t}-mask`]: Object.assign({}, che(e)),
      [`${t}-mask:hover`]: {
        opacity: 1
      },
      [`${t}-placeholder`]: Object.assign({}, KR())
    }
  };
}, ghe = (e) => {
  const {
    previewCls: t
  } = e;
  return {
    [`${t}-root`]: xS(e, "zoom"),
    "&": O5(e, !0)
  };
}, vhe = (e) => ({
  zIndexPopup: e.zIndexPopupBase + 80,
  previewOperationColor: new Jr(e.colorTextLightSolid).setAlpha(0.65).toRgbString(),
  previewOperationHoverColor: new Jr(e.colorTextLightSolid).setAlpha(0.85).toRgbString(),
  previewOperationColorDisabled: new Jr(e.colorTextLightSolid).setAlpha(0.25).toRgbString(),
  previewOperationSize: e.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
}), b3 = Gn("Image", (e) => {
  const t = `${e.componentCls}-preview`, r = Br(e, {
    previewCls: t,
    modalMaskBg: new Jr("#000").setAlpha(0.45).toRgbString(),
    // FIXME: Shared Token
    imagePreviewSwitchSize: e.controlHeightLG
  });
  return [phe(r), fhe(r), V5(Br(r, {
    componentCls: t
  })), ghe(r)];
}, vhe);
var mhe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const x3 = {
  rotateLeft: /* @__PURE__ */ E.createElement(y3, null),
  rotateRight: /* @__PURE__ */ E.createElement(C3, null),
  zoomIn: /* @__PURE__ */ E.createElement(S3, null),
  zoomOut: /* @__PURE__ */ E.createElement(w3, null),
  close: /* @__PURE__ */ E.createElement(uf, null),
  left: /* @__PURE__ */ E.createElement(L8, null),
  right: /* @__PURE__ */ E.createElement(w8, null),
  flipX: /* @__PURE__ */ E.createElement(UR, null),
  flipY: /* @__PURE__ */ E.createElement(UR, {
    rotate: 90
  })
}, yhe = (e) => {
  var {
    previewPrefixCls: t,
    preview: r
  } = e, n = mhe(e, ["previewPrefixCls", "preview"]);
  const {
    getPrefixCls: i
  } = E.useContext(Yt), o = i("image", t), a = `${o}-preview`, s = i(), l = ed(o), [u, c, d] = b3(o, l), [h] = mS("ImagePreview", typeof r == "object" ? r.zIndex : void 0), f = E.useMemo(() => {
    var p;
    if (r === !1)
      return r;
    const g = typeof r == "object" ? r : {}, v = ue(c, d, l, (p = g.rootClassName) !== null && p !== void 0 ? p : "");
    return Object.assign(Object.assign({}, g), {
      transitionName: Ql(s, "zoom", g.transitionName),
      maskTransitionName: Ql(s, "fade", g.maskTransitionName),
      rootClassName: v,
      zIndex: h
    });
  }, [r]);
  return u(/* @__PURE__ */ E.createElement(OS.PreviewGroup, Object.assign({
    preview: f,
    previewPrefixCls: a,
    icons: x3
  }, n)));
}, Che = yhe;
var EL = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const _v = (e) => {
  var t;
  const {
    prefixCls: r,
    preview: n,
    className: i,
    rootClassName: o,
    style: a
  } = e, s = EL(e, ["prefixCls", "preview", "className", "rootClassName", "style"]), {
    getPrefixCls: l,
    locale: u = Ys,
    getPopupContainer: c,
    image: d
  } = E.useContext(Yt), h = l("image", r), f = l(), p = u.Image || Ys.Image, g = ed(h), [v, m, y] = b3(h, g), C = ue(o, m, y, g), S = ue(i, m, d == null ? void 0 : d.className), [b] = mS("ImagePreview", typeof n == "object" ? n.zIndex : void 0), w = E.useMemo(() => {
    var R;
    if (n === !1)
      return n;
    const _ = typeof n == "object" ? n : {}, {
      getContainer: T,
      closeIcon: P
    } = _, D = EL(_, ["getContainer", "closeIcon"]);
    return Object.assign(Object.assign({
      mask: /* @__PURE__ */ E.createElement("div", {
        className: `${h}-mask-info`
      }, /* @__PURE__ */ E.createElement(fM, null), p == null ? void 0 : p.preview),
      icons: x3
    }, D), {
      getContainer: T ?? c,
      transitionName: Ql(f, "zoom", _.transitionName),
      maskTransitionName: Ql(f, "fade", _.maskTransitionName),
      zIndex: b,
      closeIcon: P ?? ((R = d == null ? void 0 : d.preview) === null || R === void 0 ? void 0 : R.closeIcon)
    });
  }, [n, p, (t = d == null ? void 0 : d.preview) === null || t === void 0 ? void 0 : t.closeIcon]), x = Object.assign(Object.assign({}, d == null ? void 0 : d.style), a);
  return v(/* @__PURE__ */ E.createElement(OS, Object.assign({
    prefixCls: h,
    preview: w,
    rootClassName: C,
    className: S,
    style: x
  }, s)));
};
_v.PreviewGroup = Che;
process.env.NODE_ENV !== "production" && (_v.displayName = "Image");
const She = (e) => {
  const {
    componentCls: t,
    iconCls: r,
    antCls: n,
    zIndexPopup: i,
    colorText: o,
    colorWarning: a,
    marginXXS: s,
    marginXS: l,
    fontSize: u,
    fontWeightStrong: c,
    colorTextHeading: d
  } = e;
  return {
    [t]: {
      zIndex: i,
      [`&${n}-popover`]: {
        fontSize: u
      },
      [`${t}-message`]: {
        marginBottom: l,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${t}-message-icon ${r}`]: {
          color: a,
          fontSize: u,
          lineHeight: 1,
          marginInlineEnd: l
        },
        [`${t}-title`]: {
          fontWeight: c,
          color: d,
          "&:only-child": {
            fontWeight: "normal"
          }
        },
        [`${t}-description`]: {
          marginTop: s,
          color: o
        }
      },
      [`${t}-buttons`]: {
        textAlign: "end",
        whiteSpace: "nowrap",
        button: {
          marginInlineStart: l
        }
      }
    }
  };
}, whe = (e) => {
  const {
    zIndexPopupBase: t
  } = e;
  return {
    zIndexPopup: t + 60
  };
}, E3 = Gn("Popconfirm", (e) => She(e), whe, {
  resetStyle: !1
});
var bhe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const R3 = (e) => {
  const {
    prefixCls: t,
    okButtonProps: r,
    cancelButtonProps: n,
    title: i,
    description: o,
    cancelText: a,
    okText: s,
    okType: l = "primary",
    icon: u = /* @__PURE__ */ E.createElement(NP, null),
    showCancel: c = !0,
    close: d,
    onConfirm: h,
    onCancel: f,
    onPopupClick: p
  } = e, {
    getPrefixCls: g
  } = E.useContext(Yt), [v] = AP("Popconfirm", Ys.Popconfirm), m = Gh(i), y = Gh(o);
  return /* @__PURE__ */ E.createElement("div", {
    className: `${t}-inner-content`,
    onClick: p
  }, /* @__PURE__ */ E.createElement("div", {
    className: `${t}-message`
  }, u && /* @__PURE__ */ E.createElement("span", {
    className: `${t}-message-icon`
  }, u), /* @__PURE__ */ E.createElement("div", {
    className: `${t}-message-text`
  }, m && /* @__PURE__ */ E.createElement("div", {
    className: ue(`${t}-title`)
  }, m), y && /* @__PURE__ */ E.createElement("div", {
    className: `${t}-description`
  }, y))), /* @__PURE__ */ E.createElement("div", {
    className: `${t}-buttons`
  }, c && /* @__PURE__ */ E.createElement(jn, Object.assign({
    onClick: f,
    size: "small"
  }, n), a || (v == null ? void 0 : v.cancelText)), /* @__PURE__ */ E.createElement(Rne, {
    buttonProps: Object.assign(Object.assign({
      size: "small"
    }, h5(l)), r),
    actionFn: h,
    close: d,
    prefixCls: g("btn"),
    quitOnNullishReturnValue: !0,
    emitEvent: !0
  }, s || (v == null ? void 0 : v.okText))));
}, xhe = (e) => {
  const {
    prefixCls: t,
    placement: r,
    className: n,
    style: i
  } = e, o = bhe(e, ["prefixCls", "placement", "className", "style"]), {
    getPrefixCls: a
  } = E.useContext(Yt), s = a("popconfirm", t), [l] = E3(s);
  return l(/* @__PURE__ */ E.createElement(S8, {
    placement: r,
    className: ue(s, n),
    style: i,
    content: /* @__PURE__ */ E.createElement(R3, Object.assign({
      prefixCls: s
    }, o))
  }));
};
var Ehe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Rhe = /* @__PURE__ */ E.forwardRef((e, t) => {
  var r, n;
  const {
    prefixCls: i,
    placement: o = "top",
    trigger: a = "click",
    okType: s = "primary",
    icon: l = /* @__PURE__ */ E.createElement(NP, null),
    children: u,
    overlayClassName: c,
    onOpenChange: d,
    onVisibleChange: h
  } = e, f = Ehe(e, ["prefixCls", "placement", "trigger", "okType", "icon", "children", "overlayClassName", "onOpenChange", "onVisibleChange"]), {
    getPrefixCls: p
  } = E.useContext(Yt), [g, v] = xn(!1, {
    value: (r = e.open) !== null && r !== void 0 ? r : e.visible,
    defaultValue: (n = e.defaultOpen) !== null && n !== void 0 ? n : e.defaultVisible
  }), m = (_, T) => {
    v(_, !0), h == null || h(_), d == null || d(_, T);
  }, y = (_) => {
    m(!1, _);
  }, C = (_) => {
    var T;
    return (T = e.onConfirm) === null || T === void 0 ? void 0 : T.call(void 0, _);
  }, S = (_) => {
    var T;
    m(!1, _), (T = e.onCancel) === null || T === void 0 || T.call(void 0, _);
  }, b = (_, T) => {
    const {
      disabled: P = !1
    } = e;
    P || m(_, T);
  }, w = p("popconfirm", i), x = ue(w, c), [R] = E3(w);
  return R(/* @__PURE__ */ E.createElement(rM, Object.assign({}, ni(f, ["title"]), {
    trigger: a,
    placement: o,
    onOpenChange: b,
    open: g,
    ref: t,
    overlayClassName: x,
    content: /* @__PURE__ */ E.createElement(R3, Object.assign({
      okType: s,
      icon: l
    }, e, {
      prefixCls: w,
      close: y,
      onConfirm: C,
      onCancel: S
    })),
    "data-popover-inject": !0
  }), u));
}), LS = Rhe;
LS._InternalPanelDoNotUseOrYouWillBeFired = xhe;
process.env.NODE_ENV !== "production" && (LS.displayName = "Popconfirm");
var _he = {
  percent: 0,
  prefixCls: "rc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1,
  gapPosition: "bottom"
}, The = function() {
  var t = se([]), r = se(null);
  return Nt(function() {
    var n = Date.now(), i = !1;
    t.current.forEach(function(o) {
      if (o) {
        i = !0;
        var a = o.style;
        a.transitionDuration = ".3s, .3s, .3s, .06s", r.current && n - r.current < 100 && (a.transitionDuration = "0s, 0s");
      }
    }), i && (r.current = Date.now());
  }), t.current;
};
process.env.NODE_ENV;
var RL = 0, Phe = process.env.NODE_ENV !== "test" && Zn();
function Mhe() {
  var e;
  return Phe ? (e = RL, RL += 1) : e = "TEST_OR_SSR", e;
}
const Dhe = function(e) {
  var t = E.useState(), r = ae(t, 2), n = r[0], i = r[1];
  return E.useEffect(function() {
    i("rc_progress_".concat(Mhe()));
  }, []), e || n;
};
var _L = function(t) {
  var r = t.bg, n = t.children;
  return /* @__PURE__ */ E.createElement("div", {
    style: {
      width: "100%",
      height: "100%",
      background: r
    }
  }, n);
};
function TL(e, t) {
  return Object.keys(e).map(function(r) {
    var n = parseFloat(r), i = "".concat(Math.floor(n * t), "%");
    return "".concat(e[r], " ").concat(i);
  });
}
var _3 = /* @__PURE__ */ E.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.color, i = e.gradientId, o = e.radius, a = e.style, s = e.ptg, l = e.strokeLinecap, u = e.strokeWidth, c = e.size, d = e.gapDegree, h = n && vt(n) === "object", f = h ? "#FFF" : void 0, p = c / 2, g = /* @__PURE__ */ E.createElement("circle", {
    className: "".concat(r, "-circle-path"),
    r: o,
    cx: p,
    cy: p,
    stroke: f,
    strokeLinecap: l,
    strokeWidth: u,
    opacity: s === 0 ? 0 : 1,
    style: a,
    ref: t
  });
  if (!h)
    return g;
  var v = "".concat(i, "-conic"), m = d ? "".concat(180 + d / 2, "deg") : "0deg", y = TL(n, (360 - d) / 360), C = TL(n, 1), S = "conic-gradient(from ".concat(m, ", ").concat(y.join(", "), ")"), b = "linear-gradient(to ".concat(d ? "bottom" : "top", ", ").concat(C.join(", "), ")");
  return /* @__PURE__ */ E.createElement(E.Fragment, null, /* @__PURE__ */ E.createElement("mask", {
    id: v
  }, g), /* @__PURE__ */ E.createElement("foreignObject", {
    x: 0,
    y: 0,
    width: c,
    height: c,
    mask: "url(#".concat(v, ")")
  }, /* @__PURE__ */ E.createElement(_L, {
    bg: b
  }, /* @__PURE__ */ E.createElement(_L, {
    bg: S
  }))));
});
process.env.NODE_ENV !== "production" && (_3.displayName = "PtgCircle");
var Mp = 100, Eb = function(t, r, n, i, o, a, s, l, u, c) {
  var d = arguments.length > 10 && arguments[10] !== void 0 ? arguments[10] : 0, h = n / 100 * 360 * ((360 - a) / 360), f = a === 0 ? 0 : {
    bottom: 0,
    top: 180,
    left: 90,
    right: -90
  }[s], p = (100 - i) / 100 * r;
  u === "round" && i !== 100 && (p += c / 2, p >= r && (p = r - 0.01));
  var g = Mp / 2;
  return {
    stroke: typeof l == "string" ? l : void 0,
    strokeDasharray: "".concat(r, "px ").concat(t),
    strokeDashoffset: p + d,
    transform: "rotate(".concat(o + h + f, "deg)"),
    transformOrigin: "".concat(g, "px ").concat(g, "px"),
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s",
    fillOpacity: 0
  };
}, Ahe = ["id", "prefixCls", "steps", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "style", "className", "strokeColor", "percent"];
function PL(e) {
  var t = e ?? [];
  return Array.isArray(t) ? t : [t];
}
var T3 = function(t) {
  var r = ee(ee({}, _he), t), n = r.id, i = r.prefixCls, o = r.steps, a = r.strokeWidth, s = r.trailWidth, l = r.gapDegree, u = l === void 0 ? 0 : l, c = r.gapPosition, d = r.trailColor, h = r.strokeLinecap, f = r.style, p = r.className, g = r.strokeColor, v = r.percent, m = $t(r, Ahe), y = Mp / 2, C = Dhe(n), S = "".concat(C, "-gradient"), b = y - a / 2, w = Math.PI * 2 * b, x = u > 0 ? 90 + u / 2 : -90, R = w * ((360 - u) / 360), _ = vt(o) === "object" ? o : {
    count: o,
    gap: 2
  }, T = _.count, P = _.gap, D = PL(v), O = PL(g), A = O.find(function(V) {
    return V && vt(V) === "object";
  }), F = A && vt(A) === "object", L = F ? "butt" : h, N = Eb(w, R, 0, 100, x, u, c, d, L, a), I = The(), B = function() {
    var G = 0;
    return D.map(function(k, z) {
      var j = O[z] || O[O.length - 1], q = Eb(w, R, G, k, x, u, c, j, L, a);
      return G += k, /* @__PURE__ */ E.createElement(_3, {
        key: z,
        color: j,
        ptg: k,
        radius: b,
        prefixCls: i,
        gradientId: S,
        style: q,
        strokeLinecap: L,
        strokeWidth: a,
        gapDegree: u,
        ref: function(Z) {
          I[z] = Z;
        },
        size: Mp
      });
    }).reverse();
  }, M = function() {
    var G = Math.round(T * (D[0] / 100)), k = 100 / T, z = 0;
    return new Array(T).fill(null).map(function(j, q) {
      var K = q <= G - 1 ? O[0] : d, Z = K && vt(K) === "object" ? "url(#".concat(S, ")") : void 0, re = Eb(w, R, z, k, x, u, c, K, "butt", a, P);
      return z += (R - re.strokeDashoffset + P) * 100 / R, /* @__PURE__ */ E.createElement("circle", {
        key: q,
        className: "".concat(i, "-circle-path"),
        r: b,
        cx: y,
        cy: y,
        stroke: Z,
        strokeWidth: a,
        opacity: 1,
        style: re,
        ref: function(Y) {
          I[q] = Y;
        }
      });
    });
  };
  return /* @__PURE__ */ E.createElement("svg", $e({
    className: ue("".concat(i, "-circle"), p),
    viewBox: "0 0 ".concat(Mp, " ").concat(Mp),
    style: f,
    id: n,
    role: "presentation"
  }, m), !T && /* @__PURE__ */ E.createElement("circle", {
    className: "".concat(i, "-circle-trail"),
    r: b,
    cx: y,
    cy: y,
    stroke: d,
    strokeLinecap: L,
    strokeWidth: s || a,
    style: N
  }), T ? M() : B());
};
process.env.NODE_ENV !== "production" && (T3.displayName = "Circle");
function $l(e) {
  return !e || e < 0 ? 0 : e > 100 ? 100 : e;
}
function W0(e) {
  let {
    success: t,
    successPercent: r
  } = e, n = r;
  return t && "progress" in t && (n = t.progress), t && "percent" in t && (n = t.percent), n;
}
const Ihe = (e) => {
  let {
    percent: t,
    success: r,
    successPercent: n
  } = e;
  const i = $l(W0({
    success: r,
    successPercent: n
  }));
  return [i, $l($l(t) - i)];
}, Ohe = (e) => {
  let {
    success: t = {},
    strokeColor: r
  } = e;
  const {
    strokeColor: n
  } = t;
  return [n || lR.green, r || null];
}, FS = (e, t, r) => {
  var n, i, o, a;
  let s = -1, l = -1;
  if (t === "step") {
    const u = r.steps, c = r.strokeWidth;
    typeof e == "string" || typeof e > "u" ? (s = e === "small" ? 2 : 14, l = c ?? 8) : typeof e == "number" ? [s, l] = [e, e] : [s = 14, l = 8] = Array.isArray(e) ? e : [e.width, e.height], s *= u;
  } else if (t === "line") {
    const u = r == null ? void 0 : r.strokeWidth;
    typeof e == "string" || typeof e > "u" ? l = u || (e === "small" ? 6 : 8) : typeof e == "number" ? [s, l] = [e, e] : [s = -1, l = 8] = Array.isArray(e) ? e : [e.width, e.height];
  } else (t === "circle" || t === "dashboard") && (typeof e == "string" || typeof e > "u" ? [s, l] = e === "small" ? [60, 60] : [120, 120] : typeof e == "number" ? [s, l] = [e, e] : Array.isArray(e) && (s = (i = (n = e[0]) !== null && n !== void 0 ? n : e[1]) !== null && i !== void 0 ? i : 120, l = (a = (o = e[0]) !== null && o !== void 0 ? o : e[1]) !== null && a !== void 0 ? a : 120));
  return [s, l];
}, Lhe = 3, Fhe = (e) => Lhe / e * 100, Nhe = (e) => {
  const {
    prefixCls: t,
    trailColor: r = null,
    strokeLinecap: n = "round",
    gapPosition: i,
    gapDegree: o,
    width: a = 120,
    type: s,
    children: l,
    success: u,
    size: c = a,
    steps: d
  } = e, [h, f] = FS(c, "circle");
  let {
    strokeWidth: p
  } = e;
  p === void 0 && (p = Math.max(Fhe(h), 6));
  const g = {
    width: h,
    height: f,
    fontSize: h * 0.15 + 6
  }, v = E.useMemo(() => {
    if (o || o === 0)
      return o;
    if (s === "dashboard")
      return 75;
  }, [o, s]), m = Ihe(e), y = i || s === "dashboard" && "bottom" || void 0, C = Object.prototype.toString.call(e.strokeColor) === "[object Object]", S = Ohe({
    success: u,
    strokeColor: e.strokeColor
  }), b = ue(`${t}-inner`, {
    [`${t}-circle-gradient`]: C
  }), w = /* @__PURE__ */ E.createElement(T3, {
    steps: d,
    percent: d ? m[1] : m,
    strokeWidth: p,
    trailWidth: p,
    strokeColor: d ? S[1] : S,
    strokeLinecap: n,
    trailColor: r,
    prefixCls: t,
    gapDegree: v,
    gapPosition: y
  }), x = h <= 20, R = /* @__PURE__ */ E.createElement("div", {
    className: b,
    style: g
  }, w, !x && l);
  return x ? /* @__PURE__ */ E.createElement(vu, {
    title: l
  }, R) : R;
}, j0 = "--progress-line-stroke-color", P3 = "--progress-percent", ML = (e) => {
  const t = e ? "100%" : "-100%";
  return new Mr(`antProgress${e ? "RTL" : "LTR"}Active`, {
    "0%": {
      transform: `translateX(${t}) scaleX(0)`,
      opacity: 0.1
    },
    "20%": {
      transform: `translateX(${t}) scaleX(0)`,
      opacity: 0.5
    },
    to: {
      transform: "translateX(0) scaleX(1)",
      opacity: 0
    }
  });
}, khe = (e) => {
  const {
    componentCls: t,
    iconCls: r
  } = e;
  return {
    [t]: Object.assign(Object.assign({}, Fi(e)), {
      display: "inline-block",
      "&-rtl": {
        direction: "rtl"
      },
      "&-line": {
        position: "relative",
        width: "100%",
        fontSize: e.fontSize
      },
      [`${t}-outer`]: {
        display: "inline-flex",
        alignItems: "center",
        width: "100%"
      },
      [`${t}-inner`]: {
        position: "relative",
        display: "inline-block",
        width: "100%",
        flex: 1,
        overflow: "hidden",
        verticalAlign: "middle",
        backgroundColor: e.remainingColor,
        borderRadius: e.lineBorderRadius
      },
      [`${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.defaultColor
        }
      },
      [`${t}-success-bg, ${t}-bg`]: {
        position: "relative",
        background: e.defaultColor,
        borderRadius: e.lineBorderRadius,
        transition: `all ${e.motionDurationSlow} ${e.motionEaseInOutCirc}`
      },
      [`${t}-layout-bottom`]: {
        display: "flex",
        flexDirection: "column",
        alignItems: "center",
        justifyContent: "center",
        [`${t}-text`]: {
          width: "max-content",
          marginInlineStart: 0,
          marginTop: e.marginXXS
        }
      },
      [`${t}-bg`]: {
        overflow: "hidden",
        "&::after": {
          content: '""',
          background: {
            _multi_value_: !0,
            value: ["inherit", `var(${j0})`]
          },
          height: "100%",
          width: `calc(1 / var(${P3}) * 100%)`,
          display: "block"
        },
        [`&${t}-bg-inner`]: {
          minWidth: "max-content",
          "&::after": {
            content: "none"
          },
          [`${t}-text-inner`]: {
            color: e.colorWhite,
            [`&${t}-text-bright`]: {
              color: "rgba(0, 0, 0, 0.45)"
            }
          }
        }
      },
      [`${t}-success-bg`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        backgroundColor: e.colorSuccess
      },
      [`${t}-text`]: {
        display: "inline-block",
        marginInlineStart: e.marginXS,
        color: e.colorText,
        lineHeight: 1,
        width: "2em",
        whiteSpace: "nowrap",
        textAlign: "start",
        verticalAlign: "middle",
        wordBreak: "normal",
        [r]: {
          fontSize: e.fontSize
        },
        [`&${t}-text-outer`]: {
          width: "max-content"
        },
        [`&${t}-text-outer${t}-text-start`]: {
          width: "max-content",
          marginInlineStart: 0,
          marginInlineEnd: e.marginXS
        }
      },
      [`${t}-text-inner`]: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%",
        marginInlineStart: 0,
        padding: `0 ${de(e.paddingXXS)}`,
        [`&${t}-text-start`]: {
          justifyContent: "start"
        },
        [`&${t}-text-end`]: {
          justifyContent: "end"
        }
      },
      [`&${t}-status-active`]: {
        [`${t}-bg::before`]: {
          position: "absolute",
          inset: 0,
          backgroundColor: e.colorBgContainer,
          borderRadius: e.lineBorderRadius,
          opacity: 0,
          animationName: ML(),
          animationDuration: e.progressActiveMotionDuration,
          animationTimingFunction: e.motionEaseOutQuint,
          animationIterationCount: "infinite",
          content: '""'
        }
      },
      [`&${t}-rtl${t}-status-active`]: {
        [`${t}-bg::before`]: {
          animationName: ML(!0)
        }
      },
      [`&${t}-status-exception`]: {
        [`${t}-bg`]: {
          backgroundColor: e.colorError
        },
        [`${t}-text`]: {
          color: e.colorError
        }
      },
      [`&${t}-status-exception ${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorError
        }
      },
      [`&${t}-status-success`]: {
        [`${t}-bg`]: {
          backgroundColor: e.colorSuccess
        },
        [`${t}-text`]: {
          color: e.colorSuccess
        }
      },
      [`&${t}-status-success ${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorSuccess
        }
      }
    })
  };
}, Vhe = (e) => {
  const {
    componentCls: t,
    iconCls: r
  } = e;
  return {
    [t]: {
      [`${t}-circle-trail`]: {
        stroke: e.remainingColor
      },
      [`&${t}-circle ${t}-inner`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`&${t}-circle ${t}-text`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: e.circleTextColor,
        fontSize: e.circleTextFontSize,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [r]: {
          fontSize: e.circleIconFontSize
        }
      },
      [`${t}-circle&-status-exception`]: {
        [`${t}-text`]: {
          color: e.colorError
        }
      },
      [`${t}-circle&-status-success`]: {
        [`${t}-text`]: {
          color: e.colorSuccess
        }
      }
    },
    [`${t}-inline-circle`]: {
      lineHeight: 1,
      [`${t}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
}, Bhe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`${t}-steps`]: {
        display: "inline-block",
        "&-outer": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center"
        },
        "&-item": {
          flexShrink: 0,
          minWidth: e.progressStepMinWidth,
          marginInlineEnd: e.progressStepMarginInlineEnd,
          backgroundColor: e.remainingColor,
          transition: `all ${e.motionDurationSlow}`,
          "&-active": {
            backgroundColor: e.defaultColor
          }
        }
      }
    }
  };
}, $he = (e) => {
  const {
    componentCls: t,
    iconCls: r
  } = e;
  return {
    [t]: {
      [`${t}-small&-line, ${t}-small&-line ${t}-text ${r}`]: {
        fontSize: e.fontSizeSM
      }
    }
  };
}, Hhe = (e) => ({
  circleTextColor: e.colorText,
  defaultColor: e.colorInfo,
  remainingColor: e.colorFillSecondary,
  lineBorderRadius: 100,
  // magic for capsule shape, should be a very large number
  circleTextFontSize: "1em",
  circleIconFontSize: `${e.fontSize / e.fontSizeSM}em`
}), Ghe = Gn("Progress", (e) => {
  const t = e.calc(e.marginXXS).div(2).equal(), r = Br(e, {
    progressStepMarginInlineEnd: t,
    progressStepMinWidth: t,
    progressActiveMotionDuration: "2.4s"
  });
  return [khe(r), Vhe(r), Bhe(r), $he(r)];
}, Hhe);
var zhe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Whe = (e) => {
  let t = [];
  return Object.keys(e).forEach((r) => {
    const n = parseFloat(r.replace(/%/g, ""));
    isNaN(n) || t.push({
      key: n,
      value: e[r]
    });
  }), t = t.sort((r, n) => r.key - n.key), t.map((r) => {
    let {
      key: n,
      value: i
    } = r;
    return `${i} ${n}%`;
  }).join(", ");
}, jhe = (e, t) => {
  const {
    from: r = lR.blue,
    to: n = lR.blue,
    direction: i = t === "rtl" ? "to left" : "to right"
  } = e, o = zhe(e, ["from", "to", "direction"]);
  if (Object.keys(o).length !== 0) {
    const s = Whe(o), l = `linear-gradient(${i}, ${s})`;
    return {
      background: l,
      [j0]: l
    };
  }
  const a = `linear-gradient(${i}, ${r}, ${n})`;
  return {
    background: a,
    [j0]: a
  };
}, Uhe = (e) => {
  const {
    prefixCls: t,
    direction: r,
    percent: n,
    size: i,
    strokeWidth: o,
    strokeColor: a,
    strokeLinecap: s = "round",
    children: l,
    trailColor: u = null,
    percentPosition: c,
    success: d
  } = e, {
    align: h,
    type: f
  } = c, p = a && typeof a != "string" ? jhe(a, r) : {
    [j0]: a,
    background: a
  }, g = s === "square" || s === "butt" ? 0 : void 0, v = i ?? [-1, o || (i === "small" ? 6 : 8)], [m, y] = FS(v, "line", {
    strokeWidth: o
  });
  process.env.NODE_ENV !== "production" && en("Progress").deprecated(!("strokeWidth" in e), "strokeWidth", "size");
  const C = {
    backgroundColor: u || void 0,
    borderRadius: g
  }, S = Object.assign(Object.assign({
    width: `${$l(n)}%`,
    height: y,
    borderRadius: g
  }, p), {
    [P3]: $l(n) / 100
  }), b = W0(e), w = {
    width: `${$l(b)}%`,
    height: y,
    borderRadius: g,
    backgroundColor: d == null ? void 0 : d.strokeColor
  }, x = {
    width: m < 0 ? "100%" : m
  }, R = /* @__PURE__ */ E.createElement("div", {
    className: `${t}-inner`,
    style: C
  }, /* @__PURE__ */ E.createElement("div", {
    className: ue(`${t}-bg`, `${t}-bg-${f}`),
    style: S
  }, f === "inner" && l), b !== void 0 && /* @__PURE__ */ E.createElement("div", {
    className: `${t}-success-bg`,
    style: w
  })), _ = f === "outer" && h === "start", T = f === "outer" && h === "end";
  return f === "outer" && h === "center" ? /* @__PURE__ */ E.createElement("div", {
    className: `${t}-layout-bottom`
  }, R, l) : /* @__PURE__ */ E.createElement("div", {
    className: `${t}-outer`,
    style: x
  }, _ && l, R, T && l);
}, Khe = (e) => {
  const {
    size: t,
    steps: r,
    percent: n = 0,
    strokeWidth: i = 8,
    strokeColor: o,
    trailColor: a = null,
    prefixCls: s,
    children: l
  } = e, u = Math.round(r * (n / 100)), d = t ?? [t === "small" ? 2 : 14, i], [h, f] = FS(d, "step", {
    steps: r,
    strokeWidth: i
  }), p = h / r, g = new Array(r);
  for (let v = 0; v < r; v++) {
    const m = Array.isArray(o) ? o[v] : o;
    g[v] = /* @__PURE__ */ E.createElement("div", {
      key: v,
      className: ue(`${s}-steps-item`, {
        [`${s}-steps-item-active`]: v <= u - 1
      }),
      style: {
        backgroundColor: v <= u - 1 ? m : a,
        width: p,
        height: f
      }
    });
  }
  return /* @__PURE__ */ E.createElement("div", {
    className: `${s}-steps-outer`
  }, g, l);
};
var Yhe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const qhe = ["normal", "exception", "active", "success"], M3 = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    prefixCls: r,
    className: n,
    rootClassName: i,
    steps: o,
    strokeColor: a,
    percent: s = 0,
    size: l = "default",
    showInfo: u = !0,
    type: c = "line",
    status: d,
    format: h,
    style: f,
    percentPosition: p = {}
  } = e, g = Yhe(e, ["prefixCls", "className", "rootClassName", "steps", "strokeColor", "percent", "size", "showInfo", "type", "status", "format", "style", "percentPosition"]), {
    align: v = "end",
    type: m = "outer"
  } = p, y = Array.isArray(a) ? a[0] : a, C = typeof a == "string" || Array.isArray(a) ? a : void 0, S = E.useMemo(() => {
    if (y) {
      const B = typeof y == "string" ? y : Object.values(y)[0];
      return new Jr(B).isLight();
    }
    return !1;
  }, [a]), b = E.useMemo(() => {
    var B, M;
    const V = W0(e);
    return parseInt(V !== void 0 ? (B = V ?? 0) === null || B === void 0 ? void 0 : B.toString() : (M = s ?? 0) === null || M === void 0 ? void 0 : M.toString(), 10);
  }, [s, e.success, e.successPercent]), w = E.useMemo(() => !qhe.includes(d) && b >= 100 ? "success" : d || "normal", [d, b]), {
    getPrefixCls: x,
    direction: R,
    progress: _
  } = E.useContext(Yt), T = x("progress", r), [P, D, O] = Ghe(T), A = c === "line", F = A && !o, L = E.useMemo(() => {
    if (!u)
      return null;
    const B = W0(e);
    let M;
    const V = h || ((k) => `${k}%`), G = A && S && m === "inner";
    return m === "inner" || h || w !== "exception" && w !== "success" ? M = V($l(s), $l(B)) : w === "exception" ? M = A ? /* @__PURE__ */ E.createElement(gS, null) : /* @__PURE__ */ E.createElement(uf, null) : w === "success" && (M = A ? /* @__PURE__ */ E.createElement(o5, null) : /* @__PURE__ */ E.createElement(TS, null)), /* @__PURE__ */ E.createElement("span", {
      className: ue(`${T}-text`, {
        [`${T}-text-bright`]: G,
        [`${T}-text-${v}`]: F,
        [`${T}-text-${m}`]: F
      }),
      title: typeof M == "string" ? M : void 0
    }, M);
  }, [u, s, b, w, c, T, h]);
  if (process.env.NODE_ENV !== "production") {
    const B = en("Progress");
    B.deprecated(!("successPercent" in e), "successPercent", "success.percent"), B.deprecated(!("width" in e), "width", "size"), (c === "circle" || c === "dashboard") && (Array.isArray(l) ? process.env.NODE_ENV !== "production" && B(!1, "usage", 'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.') : typeof l == "object" && process.env.NODE_ENV !== "production" && B(!1, "usage", 'Type "circle" and "dashboard" do not accept object as `size`, please use number or preset size instead.')), e.success && "progress" in e.success && B.deprecated(!1, "success.progress", "success.percent");
  }
  let N;
  c === "line" ? N = o ? /* @__PURE__ */ E.createElement(Khe, Object.assign({}, e, {
    strokeColor: C,
    prefixCls: T,
    steps: typeof o == "object" ? o.count : o
  }), L) : /* @__PURE__ */ E.createElement(Uhe, Object.assign({}, e, {
    strokeColor: y,
    prefixCls: T,
    direction: R,
    percentPosition: {
      align: v,
      type: m
    }
  }), L) : (c === "circle" || c === "dashboard") && (N = /* @__PURE__ */ E.createElement(Nhe, Object.assign({}, e, {
    strokeColor: y,
    prefixCls: T,
    progressStatus: w
  }), L));
  const I = ue(T, `${T}-status-${w}`, {
    [`${T}-${c === "dashboard" && "circle" || c}`]: c !== "line",
    [`${T}-inline-circle`]: c === "circle" && FS(l, "circle")[0] <= 20,
    [`${T}-line`]: F,
    [`${T}-line-align-${v}`]: F,
    [`${T}-line-position-${m}`]: F,
    [`${T}-steps`]: o,
    [`${T}-show-info`]: u,
    [`${T}-${l}`]: typeof l == "string",
    [`${T}-rtl`]: R === "rtl"
  }, _ == null ? void 0 : _.className, n, i, D, O);
  return P(/* @__PURE__ */ E.createElement("div", Object.assign({
    ref: t,
    style: Object.assign(Object.assign({}, _ == null ? void 0 : _.style), f),
    className: I,
    role: "progressbar",
    "aria-valuenow": b,
    "aria-valuemin": 0,
    "aria-valuemax": 100
  }, ni(g, ["trailColor", "strokeWidth", "width", "gapDegree", "gapPosition", "strokeLinecap", "success", "successPercent"])), N));
});
process.env.NODE_ENV !== "production" && (M3.displayName = "Progress");
const Xhe = (e) => {
  const {
    paddingXXS: t,
    lineWidth: r,
    tagPaddingHorizontal: n,
    componentCls: i,
    calc: o
  } = e, a = o(n).sub(r).equal(), s = o(t).sub(r).equal();
  return {
    // Result
    [i]: Object.assign(Object.assign({}, Fi(e)), {
      display: "inline-block",
      height: "auto",
      // https://github.com/ant-design/ant-design/pull/47504
      marginInlineEnd: e.marginXS,
      paddingInline: a,
      fontSize: e.tagFontSize,
      lineHeight: e.tagLineHeight,
      whiteSpace: "nowrap",
      background: e.defaultBg,
      border: `${de(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
      borderRadius: e.borderRadiusSM,
      opacity: 1,
      transition: `all ${e.motionDurationMid}`,
      textAlign: "start",
      position: "relative",
      // RTL
      [`&${i}-rtl`]: {
        direction: "rtl"
      },
      "&, a, a:hover": {
        color: e.defaultColor
      },
      [`${i}-close-icon`]: {
        marginInlineStart: s,
        fontSize: e.tagIconSize,
        color: e.colorTextDescription,
        cursor: "pointer",
        transition: `all ${e.motionDurationMid}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      [`&${i}-has-color`]: {
        borderColor: "transparent",
        [`&, a, a:hover, ${e.iconCls}-close, ${e.iconCls}-close:hover`]: {
          color: e.colorTextLightSolid
        }
      },
      "&-checkable": {
        backgroundColor: "transparent",
        borderColor: "transparent",
        cursor: "pointer",
        [`&:not(${i}-checkable-checked):hover`]: {
          color: e.colorPrimary,
          backgroundColor: e.colorFillSecondary
        },
        "&:active, &-checked": {
          color: e.colorTextLightSolid
        },
        "&-checked": {
          backgroundColor: e.colorPrimary,
          "&:hover": {
            backgroundColor: e.colorPrimaryHover
          }
        },
        "&:active": {
          backgroundColor: e.colorPrimaryActive
        }
      },
      "&-hidden": {
        display: "none"
      },
      // To ensure that a space will be placed between character and `Icon`.
      [`> ${e.iconCls} + span, > span + ${e.iconCls}`]: {
        marginInlineStart: a
      }
    }),
    [`${i}-borderless`]: {
      borderColor: "transparent",
      background: e.tagBorderlessBg
    }
  };
}, gM = (e) => {
  const {
    lineWidth: t,
    fontSizeIcon: r,
    calc: n
  } = e, i = e.fontSizeSM;
  return Br(e, {
    tagFontSize: i,
    tagLineHeight: de(n(e.lineHeightSM).mul(i).equal()),
    tagIconSize: n(r).sub(n(t).mul(2)).equal(),
    // Tag icon is much smaller
    tagPaddingHorizontal: 8,
    // Fixed padding.
    tagBorderlessBg: e.defaultBg
  });
}, vM = (e) => ({
  defaultBg: new Jr(e.colorFillQuaternary).onBackground(e.colorBgContainer).toHexString(),
  defaultColor: e.colorText
}), D3 = Gn("Tag", (e) => {
  const t = gM(e);
  return Xhe(t);
}, vM);
var Zhe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Qhe = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    prefixCls: r,
    style: n,
    className: i,
    checked: o,
    onChange: a,
    onClick: s
  } = e, l = Zhe(e, ["prefixCls", "style", "className", "checked", "onChange", "onClick"]), {
    getPrefixCls: u,
    tag: c
  } = E.useContext(Yt), d = (m) => {
    a == null || a(!o), s == null || s(m);
  }, h = u("tag", r), [f, p, g] = D3(h), v = ue(h, `${h}-checkable`, {
    [`${h}-checkable-checked`]: o
  }, c == null ? void 0 : c.className, i, p, g);
  return f(/* @__PURE__ */ E.createElement("span", Object.assign({}, l, {
    ref: t,
    style: Object.assign(Object.assign({}, n), c == null ? void 0 : c.style),
    className: v,
    onClick: d
  })));
}), Jhe = (e) => Hz(e, (t, r) => {
  let {
    textColor: n,
    lightBorderColor: i,
    lightColor: o,
    darkColor: a
  } = r;
  return {
    [`${e.componentCls}${e.componentCls}-${t}`]: {
      color: n,
      background: o,
      borderColor: i,
      // Inverse color
      "&-inverse": {
        color: e.colorTextLightSolid,
        background: a,
        borderColor: a
      },
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}), efe = LP(["Tag", "preset"], (e) => {
  const t = gM(e);
  return Jhe(t);
}, vM);
function tfe(e) {
  return typeof e != "string" ? e : e.charAt(0).toUpperCase() + e.slice(1);
}
const Em = (e, t, r) => {
  const n = tfe(r);
  return {
    [`${e.componentCls}${e.componentCls}-${t}`]: {
      color: e[`color${r}`],
      background: e[`color${n}Bg`],
      borderColor: e[`color${n}Border`],
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}, rfe = LP(["Tag", "status"], (e) => {
  const t = gM(e);
  return [Em(t, "success", "Success"), Em(t, "processing", "Info"), Em(t, "error", "Error"), Em(t, "warning", "Warning")];
}, vM);
var nfe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const ife = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    prefixCls: r,
    className: n,
    rootClassName: i,
    style: o,
    children: a,
    icon: s,
    color: l,
    onClose: u,
    bordered: c = !0,
    visible: d
  } = e, h = nfe(e, ["prefixCls", "className", "rootClassName", "style", "children", "icon", "color", "onClose", "bordered", "visible"]), {
    getPrefixCls: f,
    direction: p,
    tag: g
  } = E.useContext(Yt), [v, m] = E.useState(!0), y = ni(h, ["closeIcon", "closable"]);
  process.env.NODE_ENV !== "production" && en("Tag").deprecated(!("visible" in e), "visible", "visible && <Tag />"), E.useEffect(() => {
    d !== void 0 && m(d);
  }, [d]);
  const C = m8(l), S = sle(l), b = C || S, w = Object.assign(Object.assign({
    backgroundColor: l && !b ? l : void 0
  }, g == null ? void 0 : g.style), o), x = f("tag", r), [R, _, T] = D3(x), P = ue(x, g == null ? void 0 : g.className, {
    [`${x}-${l}`]: b,
    [`${x}-has-color`]: l && !b,
    [`${x}-hidden`]: !v,
    [`${x}-rtl`]: p === "rtl",
    [`${x}-borderless`]: !c
  }, n, i, _, T), D = (I) => {
    I.stopPropagation(), u == null || u(I), !I.defaultPrevented && m(!1);
  }, [, O] = kie(bO(e), bO(g), {
    closable: !1,
    closeIconRender: (I) => {
      const B = /* @__PURE__ */ E.createElement("span", {
        className: `${x}-close-icon`,
        onClick: D
      }, I);
      return s5(I, B, (M) => ({
        onClick: (V) => {
          var G;
          (G = M == null ? void 0 : M.onClick) === null || G === void 0 || G.call(M, V), D(V);
        },
        className: ue(M == null ? void 0 : M.className, `${x}-close-icon`)
      }));
    }
  }), A = typeof h.onClick == "function" || a && a.type === "a", F = s || null, L = F ? /* @__PURE__ */ E.createElement(E.Fragment, null, F, a && /* @__PURE__ */ E.createElement("span", null, a)) : a, N = /* @__PURE__ */ E.createElement("span", Object.assign({}, y, {
    ref: t,
    className: P,
    style: w
  }), L, O, C && /* @__PURE__ */ E.createElement(efe, {
    key: "preset",
    prefixCls: x
  }), S && /* @__PURE__ */ E.createElement(rfe, {
    key: "status",
    prefixCls: x
  }));
  return R(A ? /* @__PURE__ */ E.createElement(BP, {
    component: "Tag"
  }, N) : N);
}), NS = ife;
process.env.NODE_ENV !== "production" && (NS.displayName = "Tag");
NS.CheckableTag = Qhe;
var ofe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const afe = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-flex"
}, YR = /* @__PURE__ */ E.forwardRef((e, t) => {
  const r = (c) => {
    const {
      keyCode: d
    } = c;
    d === Ae.ENTER && c.preventDefault();
  }, n = (c) => {
    const {
      keyCode: d
    } = c, {
      onClick: h
    } = e;
    d === Ae.ENTER && h && h();
  }, {
    style: i,
    noStyle: o,
    disabled: a,
    tabIndex: s = 0
  } = e, l = ofe(e, ["style", "noStyle", "disabled", "tabIndex"]);
  let u = {};
  return o || (u = Object.assign({}, afe)), a && (u.pointerEvents = "none"), u = Object.assign(Object.assign({}, u), i), /* @__PURE__ */ E.createElement("div", Object.assign({
    role: "button",
    tabIndex: s,
    ref: t
  }, l, {
    onKeyDown: r,
    onKeyUp: n,
    style: u
  }));
});
var sfe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, name: "edit", theme: "outlined" }, lfe = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: sfe
  }));
}, A3 = /* @__PURE__ */ E.forwardRef(lfe);
process.env.NODE_ENV !== "production" && (A3.displayName = "EditOutlined");
var ufe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, name: "enter", theme: "outlined" }, cfe = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: ufe
  }));
}, I3 = /* @__PURE__ */ E.forwardRef(cfe);
process.env.NODE_ENV !== "production" && (I3.displayName = "EnterOutlined");
const dfe = (e, t, r, n) => {
  const {
    titleMarginBottom: i,
    fontWeightStrong: o
  } = n;
  return {
    marginBottom: i,
    color: r,
    fontWeight: o,
    fontSize: e,
    lineHeight: t
  };
}, hfe = (e) => {
  const t = [1, 2, 3, 4, 5], r = {};
  return t.forEach((n) => {
    r[`
      h${n}&,
      div&-h${n},
      div&-h${n} > textarea,
      h${n}
    `] = dfe(e[`fontSizeHeading${n}`], e[`lineHeightHeading${n}`], e.colorTextHeading, e);
  }), r;
}, ffe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    "a&, a": Object.assign(Object.assign({}, Nz(e)), {
      textDecoration: e.linkDecoration,
      "&:active, &:hover": {
        textDecoration: e.linkHoverDecoration
      },
      [`&[disabled], &${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: e.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    })
  };
}, pfe = (e) => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    fontFamily: e.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    fontFamily: e.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: uR[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    fontFamily: e.fontFamilyCode,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
}), gfe = (e) => {
  const {
    componentCls: t,
    paddingSM: r
  } = e, n = r;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: e.calc(e.paddingSM).mul(-1).equal(),
        marginTop: e.calc(n).mul(-1).equal(),
        marginBottom: `calc(1em - ${de(n)})`
      },
      [`${t}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: e.calc(e.marginXS).add(2).equal(),
        insetBlockEnd: e.marginXS,
        color: e.colorTextDescription,
        // default style
        fontWeight: "normal",
        fontSize: e.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
}, vfe = (e) => ({
  [`${e.componentCls}-copy-success`]: {
    "\n    &,\n    &:hover,\n    &:focus": {
      color: e.colorSuccess
    }
  },
  [`${e.componentCls}-copy-icon-only`]: {
    marginInlineStart: 0
  }
}), mfe = () => ({
  "\n  a&-ellipsis,\n  span&-ellipsis\n  ": {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-ellipsis-single-line": {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    },
    "> code": {
      paddingBlock: 0,
      maxWidth: "calc(100% - 1.2em)",
      display: "inline-block",
      overflow: "hidden",
      textOverflow: "ellipsis",
      verticalAlign: "bottom",
      // https://github.com/ant-design/ant-design/issues/45953
      boxSizing: "content-box"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
}), yfe = (e) => {
  const {
    componentCls: t,
    titleMarginTop: r
  } = e;
  return {
    [t]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: e.colorText,
      wordBreak: "break-word",
      lineHeight: e.lineHeight,
      [`&${t}-secondary`]: {
        color: e.colorTextDescription
      },
      [`&${t}-success`]: {
        color: e.colorSuccess
      },
      [`&${t}-warning`]: {
        color: e.colorWarning
      },
      [`&${t}-danger`]: {
        color: e.colorError,
        "a&:active, a&:focus": {
          color: e.colorErrorActive
        },
        "a&:hover": {
          color: e.colorErrorHover
        }
      },
      [`&${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      "\n        div&,\n        p\n      ": {
        marginBottom: "1em"
      }
    }, hfe(e)), {
      [`
      & + h1${t},
      & + h2${t},
      & + h3${t},
      & + h4${t},
      & + h5${t}
      `]: {
        marginTop: r
      },
      "\n      div,\n      ul,\n      li,\n      p,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5": {
        "\n        + h1,\n        + h2,\n        + h3,\n        + h4,\n        + h5\n        ": {
          marginTop: r
        }
      }
    }), pfe(e)), ffe(e)), {
      // Operation
      [`
        ${t}-expand,
        ${t}-collapse,
        ${t}-edit,
        ${t}-copy
      `]: Object.assign(Object.assign({}, Nz(e)), {
        marginInlineStart: e.marginXXS
      })
    }), gfe(e)), vfe(e)), mfe()), {
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, Cfe = () => ({
  titleMarginTop: "1.2em",
  titleMarginBottom: "0.5em"
}), O3 = Gn("Typography", (e) => [yfe(e)], Cfe), Sfe = (e) => {
  const {
    prefixCls: t,
    "aria-label": r,
    className: n,
    style: i,
    direction: o,
    maxLength: a,
    autoSize: s = !0,
    value: l,
    onSave: u,
    onCancel: c,
    onEnd: d,
    component: h,
    enterIcon: f = /* @__PURE__ */ E.createElement(I3, null)
  } = e, p = E.useRef(null), g = E.useRef(!1), v = E.useRef(), [m, y] = E.useState(l);
  E.useEffect(() => {
    y(l);
  }, [l]), E.useEffect(() => {
    var F;
    if (!((F = p.current) === null || F === void 0) && F.resizableTextArea) {
      const {
        textArea: L
      } = p.current.resizableTextArea;
      L.focus();
      const {
        length: N
      } = L.value;
      L.setSelectionRange(N, N);
    }
  }, []);
  const C = (F) => {
    let {
      target: L
    } = F;
    y(L.value.replace(/[\n\r]/g, ""));
  }, S = () => {
    g.current = !0;
  }, b = () => {
    g.current = !1;
  }, w = (F) => {
    let {
      keyCode: L
    } = F;
    g.current || (v.current = L);
  }, x = () => {
    u(m.trim());
  }, R = (F) => {
    let {
      keyCode: L,
      ctrlKey: N,
      altKey: I,
      metaKey: B,
      shiftKey: M
    } = F;
    v.current === L && !g.current && !N && !I && !B && !M && (L === Ae.ENTER ? (x(), d == null || d()) : L === Ae.ESC && c());
  }, _ = () => {
    x();
  }, T = h ? `${t}-${h}` : "", [P, D, O] = O3(t), A = ue(t, `${t}-edit-content`, {
    [`${t}-rtl`]: o === "rtl"
  }, n, T, D, O);
  return P(/* @__PURE__ */ E.createElement("div", {
    className: A,
    style: i
  }, /* @__PURE__ */ E.createElement(pM, {
    ref: p,
    maxLength: a,
    value: m,
    onChange: C,
    onKeyDown: w,
    onKeyUp: R,
    onCompositionStart: S,
    onCompositionEnd: b,
    onBlur: _,
    "aria-label": r,
    rows: 1,
    autoSize: s
  }), f !== null ? Hc(f, {
    className: `${t}-edit-content-confirm`
  }) : null));
};
var wfe = function() {
  var e = document.getSelection();
  if (!e.rangeCount)
    return function() {
    };
  for (var t = document.activeElement, r = [], n = 0; n < e.rangeCount; n++)
    r.push(e.getRangeAt(n));
  switch (t.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      t.blur();
      break;
    default:
      t = null;
      break;
  }
  return e.removeAllRanges(), function() {
    e.type === "Caret" && e.removeAllRanges(), e.rangeCount || r.forEach(function(i) {
      e.addRange(i);
    }), t && t.focus();
  };
}, bfe = wfe, DL = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, xfe = "Copy to clipboard: #{key}, Enter";
function Efe(e) {
  var t = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
  return e.replace(/#{\s*key\s*}/g, t);
}
function Rfe(e, t) {
  var r, n, i, o, a, s, l = !1;
  t || (t = {}), r = t.debug || !1;
  try {
    i = bfe(), o = document.createRange(), a = document.getSelection(), s = document.createElement("span"), s.textContent = e, s.ariaHidden = "true", s.style.all = "unset", s.style.position = "fixed", s.style.top = 0, s.style.clip = "rect(0, 0, 0, 0)", s.style.whiteSpace = "pre", s.style.webkitUserSelect = "text", s.style.MozUserSelect = "text", s.style.msUserSelect = "text", s.style.userSelect = "text", s.addEventListener("copy", function(c) {
      if (c.stopPropagation(), t.format)
        if (c.preventDefault(), typeof c.clipboardData > "u") {
          r && console.warn("unable to use e.clipboardData"), r && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var d = DL[t.format] || DL.default;
          window.clipboardData.setData(d, e);
        } else
          c.clipboardData.clearData(), c.clipboardData.setData(t.format, e);
      t.onCopy && (c.preventDefault(), t.onCopy(c.clipboardData));
    }), document.body.appendChild(s), o.selectNodeContents(s), a.addRange(o);
    var u = document.execCommand("copy");
    if (!u)
      throw new Error("copy command was unsuccessful");
    l = !0;
  } catch (c) {
    r && console.error("unable to copy using execCommand: ", c), r && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(t.format || "text", e), t.onCopy && t.onCopy(window.clipboardData), l = !0;
    } catch (d) {
      r && console.error("unable to copy using clipboardData: ", d), r && console.error("falling back to prompt"), n = Efe("message" in t ? t.message : xfe), window.prompt(n, e);
    }
  } finally {
    a && (typeof a.removeRange == "function" ? a.removeRange(o) : a.removeAllRanges()), s && document.body.removeChild(s), i();
  }
  return l;
}
var _fe = Rfe;
const Tfe = /* @__PURE__ */ of(_fe);
var Pfe = function(e, t, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(a) {
      a(o);
    });
  }
  return new (r || (r = Promise))(function(o, a) {
    function s(c) {
      try {
        u(n.next(c));
      } catch (d) {
        a(d);
      }
    }
    function l(c) {
      try {
        u(n.throw(c));
      } catch (d) {
        a(d);
      }
    }
    function u(c) {
      c.done ? o(c.value) : i(c.value).then(s, l);
    }
    u((n = n.apply(e, t || [])).next());
  });
};
const Mfe = (e) => {
  let {
    copyConfig: t,
    children: r
  } = e;
  const [n, i] = E.useState(!1), [o, a] = E.useState(!1), s = E.useRef(null), l = () => {
    s.current && clearTimeout(s.current);
  }, u = {};
  t.format && (u.format = t.format), E.useEffect(() => l, []);
  const c = An((d) => Pfe(void 0, void 0, void 0, function* () {
    var h;
    d == null || d.preventDefault(), d == null || d.stopPropagation(), a(!0);
    try {
      const f = typeof t.text == "function" ? yield t.text() : t.text;
      Tfe(f || String(r) || "", u), a(!1), i(!0), l(), s.current = setTimeout(() => {
        i(!1);
      }, 3e3), (h = t.onCopy) === null || h === void 0 || h.call(t, d);
    } catch (f) {
      throw a(!1), f;
    }
  }));
  return {
    copied: n,
    copyLoading: o,
    onClick: c
  };
};
function Rb(e, t) {
  return E.useMemo(() => {
    const r = !!e;
    return [r, Object.assign(Object.assign({}, t), r && typeof e == "object" ? e : null)];
  }, [e]);
}
const Dfe = (e) => {
  const t = se();
  return Nt(() => {
    t.current = e;
  }), t.current;
}, Afe = (e, t) => {
  const r = E.useRef(!1);
  E.useEffect(() => {
    r.current ? e() : r.current = !0;
  }, t);
};
var Ife = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const mM = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    prefixCls: r,
    component: n = "article",
    className: i,
    rootClassName: o,
    setContentRef: a,
    children: s,
    direction: l,
    style: u
  } = e, c = Ife(e, ["prefixCls", "component", "className", "rootClassName", "setContentRef", "children", "direction", "style"]), {
    getPrefixCls: d,
    direction: h,
    typography: f
  } = E.useContext(Yt), p = l ?? h;
  let g = t;
  a && (g = Eo(t, a)), process.env.NODE_ENV !== "production" && en("Typography").deprecated(!a, "setContentRef", "ref");
  const v = d("typography", r), [m, y, C] = O3(v), S = ue(v, f == null ? void 0 : f.className, {
    [`${v}-rtl`]: p === "rtl"
  }, i, o, y, C), b = Object.assign(Object.assign({}, f == null ? void 0 : f.style), u);
  return m(
    // @ts-expect-error: Expression produces a union type that is too complex to represent.
    /* @__PURE__ */ E.createElement(n, Object.assign({
      className: S,
      style: b,
      ref: g
    }, c), s)
  );
});
process.env.NODE_ENV !== "production" && (mM.displayName = "Typography");
var Ofe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, name: "copy", theme: "outlined" }, Lfe = function(t, r) {
  return /* @__PURE__ */ E.createElement(rn, $e({}, t, {
    ref: r,
    icon: Ofe
  }));
}, L3 = /* @__PURE__ */ E.forwardRef(Lfe);
process.env.NODE_ENV !== "production" && (L3.displayName = "CopyOutlined");
function AL(e) {
  return e === !1 ? [!1, !1] : Array.isArray(e) ? e : [e];
}
function Rm(e, t, r) {
  return e === !0 || e === void 0 ? t : e || r && t;
}
const Ffe = (e) => {
  const {
    prefixCls: t,
    copied: r,
    locale: n,
    iconOnly: i,
    tooltips: o,
    icon: a,
    loading: s,
    tabIndex: l,
    onCopy: u
  } = e, c = AL(o), d = AL(a), {
    copied: h,
    copy: f
  } = n ?? {}, p = r ? Rm(c[1], h) : Rm(c[0], f), v = typeof p == "string" ? p : r ? h : f;
  return /* @__PURE__ */ E.createElement(vu, {
    key: "copy",
    title: p
  }, /* @__PURE__ */ E.createElement(YR, {
    className: ue(`${t}-copy`, {
      [`${t}-copy-success`]: r,
      [`${t}-copy-icon-only`]: i
    }),
    onClick: u,
    "aria-label": v,
    tabIndex: l
  }, r ? Rm(d[1], /* @__PURE__ */ E.createElement(TS, null), !0) : Rm(d[0], s ? /* @__PURE__ */ E.createElement(vS, null) : /* @__PURE__ */ E.createElement(L3, null), !0)));
}, _m = /* @__PURE__ */ E.forwardRef((e, t) => {
  let {
    style: r,
    children: n
  } = e;
  const i = E.useRef(null);
  return E.useImperativeHandle(t, () => ({
    isExceed: () => {
      const o = i.current;
      return o.scrollHeight > o.clientHeight;
    },
    getHeight: () => i.current.clientHeight
  })), /* @__PURE__ */ E.createElement("span", {
    "aria-hidden": !0,
    ref: i,
    style: Object.assign({
      position: "fixed",
      display: "block",
      left: 0,
      top: 0,
      pointerEvents: "none",
      backgroundColor: "rgba(255, 0, 0, 0.65)"
    }, r)
  }, n);
});
function F3(e) {
  const t = typeof e;
  return t === "string" || t === "number";
}
function Nfe(e) {
  let t = 0;
  return e.forEach((r) => {
    F3(r) ? t += String(r).length : t += 1;
  }), t;
}
function IL(e, t) {
  let r = 0;
  const n = [];
  for (let i = 0; i < e.length; i += 1) {
    if (r === t)
      return n;
    const o = e[i], s = F3(o) ? String(o).length : 1, l = r + s;
    if (l > t) {
      const u = t - r;
      return n.push(String(o).slice(0, u)), n;
    }
    n.push(o), r = l;
  }
  return e;
}
const _b = 0, Tb = 1, Pb = 2, Mb = 3, OL = 4, Tm = {
  display: "-webkit-box",
  overflow: "hidden",
  WebkitBoxOrient: "vertical"
};
function kfe(e) {
  const {
    enableMeasure: t,
    width: r,
    text: n,
    children: i,
    rows: o,
    expanded: a,
    miscDeps: s,
    onEllipsis: l
  } = e, u = E.useMemo(() => Zo(n), [n]), c = E.useMemo(() => Nfe(u), [n]), d = E.useMemo(() => i(u, !1), [n]), [h, f] = E.useState(null), p = E.useRef(null), g = E.useRef(null), v = E.useRef(null), m = E.useRef(null), y = E.useRef(null), [C, S] = E.useState(!1), [b, w] = E.useState(_b), [x, R] = E.useState(0), [_, T] = E.useState(null);
  kr(() => {
    w(t && r && c ? Tb : _b);
  }, [r, n, o, t, u]), kr(() => {
    var A, F, L, N;
    if (b === Tb) {
      w(Pb);
      const I = g.current && getComputedStyle(g.current).whiteSpace;
      T(I);
    } else if (b === Pb) {
      const I = !!(!((A = v.current) === null || A === void 0) && A.isExceed());
      w(I ? Mb : OL), f(I ? [0, c] : null), S(I);
      const B = ((F = v.current) === null || F === void 0 ? void 0 : F.getHeight()) || 0, M = o === 1 ? 0 : ((L = m.current) === null || L === void 0 ? void 0 : L.getHeight()) || 0, V = ((N = y.current) === null || N === void 0 ? void 0 : N.getHeight()) || 0, G = M + V, k = Math.max(B, G);
      R(k + 1), l(I);
    }
  }, [b]);
  const P = h ? Math.ceil((h[0] + h[1]) / 2) : 0;
  kr(() => {
    var A;
    const [F, L] = h || [0, 0];
    if (F !== L) {
      const I = (((A = p.current) === null || A === void 0 ? void 0 : A.getHeight()) || 0) > x;
      let B = P;
      L - F === 1 && (B = I ? F : L), f(I ? [F, B] : [B, L]);
    }
  }, [h, P]);
  const D = E.useMemo(() => {
    if (b !== Mb || !h || h[0] !== h[1]) {
      const A = i(u, !1);
      return b !== OL && b !== _b ? /* @__PURE__ */ E.createElement("span", {
        style: Object.assign(Object.assign({}, Tm), {
          WebkitLineClamp: o
        })
      }, A) : A;
    }
    return i(a ? u : IL(u, h[0]), C);
  }, [a, b, h, u].concat(it(s))), O = {
    width: r,
    margin: 0,
    padding: 0,
    whiteSpace: _ === "nowrap" ? "normal" : "inherit"
  };
  return /* @__PURE__ */ E.createElement(E.Fragment, null, D, b === Pb && /* @__PURE__ */ E.createElement(E.Fragment, null, /* @__PURE__ */ E.createElement(_m, {
    style: Object.assign(Object.assign(Object.assign({}, O), Tm), {
      WebkitLineClamp: o
    }),
    ref: v
  }, d), /* @__PURE__ */ E.createElement(_m, {
    style: Object.assign(Object.assign(Object.assign({}, O), Tm), {
      WebkitLineClamp: o - 1
    }),
    ref: m
  }, d), /* @__PURE__ */ E.createElement(_m, {
    style: Object.assign(Object.assign(Object.assign({}, O), Tm), {
      WebkitLineClamp: 1
    }),
    ref: y
  }, i([], !0))), b === Mb && h && h[0] !== h[1] && /* @__PURE__ */ E.createElement(_m, {
    style: Object.assign(Object.assign({}, O), {
      top: 400
    }),
    ref: p
  }, i(IL(u, P), !0)), b === Tb && /* @__PURE__ */ E.createElement("span", {
    style: {
      whiteSpace: "inherit"
    },
    ref: g
  }));
}
const N3 = (e) => {
  let {
    enableEllipsis: t,
    isEllipsis: r,
    children: n,
    tooltipProps: i
  } = e;
  return !(i != null && i.title) || !t ? n : /* @__PURE__ */ E.createElement(vu, Object.assign({
    open: r ? void 0 : !1
  }, i), n);
};
process.env.NODE_ENV !== "production" && (N3.displayName = "EllipsisTooltip");
var Vfe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function Bfe(e, t) {
  let {
    mark: r,
    code: n,
    underline: i,
    delete: o,
    strong: a,
    keyboard: s,
    italic: l
  } = e, u = t;
  function c(d, h) {
    h && (u = /* @__PURE__ */ E.createElement(d, {}, u));
  }
  return c("strong", a), c("u", i), c("del", o), c("code", n), c("mark", r), c("kbd", s), c("i", l), u;
}
const $fe = "...", kS = /* @__PURE__ */ E.forwardRef((e, t) => {
  var r, n, i;
  const {
    prefixCls: o,
    className: a,
    style: s,
    type: l,
    disabled: u,
    children: c,
    ellipsis: d,
    editable: h,
    copyable: f,
    component: p,
    title: g
  } = e, v = Vfe(e, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]), {
    getPrefixCls: m,
    direction: y
  } = E.useContext(Yt), [C] = AP("Text"), S = E.useRef(null), b = E.useRef(null), w = m("typography", o), x = ni(v, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]), [R, _] = Rb(h), [T, P] = xn(!1, {
    value: _.editing
  }), {
    triggerType: D = ["icon"]
  } = _, O = (Oe) => {
    var Qe;
    Oe && ((Qe = _.onStart) === null || Qe === void 0 || Qe.call(_)), P(Oe);
  }, A = Dfe(T);
  Afe(() => {
    var Oe;
    !T && A && ((Oe = b.current) === null || Oe === void 0 || Oe.focus());
  }, [T]);
  const F = (Oe) => {
    Oe == null || Oe.preventDefault(), O(!0);
  }, L = (Oe) => {
    var Qe;
    (Qe = _.onChange) === null || Qe === void 0 || Qe.call(_, Oe), O(!1);
  }, N = () => {
    var Oe;
    (Oe = _.onCancel) === null || Oe === void 0 || Oe.call(_), O(!1);
  }, [I, B] = Rb(f), {
    copied: M,
    copyLoading: V,
    onClick: G
  } = Mfe({
    copyConfig: B,
    children: c
  }), [k, z] = E.useState(!1), [j, q] = E.useState(!1), [K, Z] = E.useState(!1), [re, X] = E.useState(!1), [Y, U] = E.useState(!0), [oe, W] = Rb(d, {
    expandable: !1,
    symbol: (Oe) => Oe ? C == null ? void 0 : C.collapse : C == null ? void 0 : C.expand
  }), [ne, ce] = xn(W.defaultExpanded || !1, {
    value: W.expanded
  }), we = oe && (!ne || W.expandable === "collapsible"), {
    rows: Re = 1
  } = W, ve = E.useMemo(() => (
    // Disable ellipsis
    we && // Provide suffix
    (W.suffix !== void 0 || W.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
    W.expandable || R || I)
  ), [we, W, R, I]);
  kr(() => {
    oe && !ve && (z(RO("webkitLineClamp")), q(RO("textOverflow")));
  }, [ve, oe]);
  const [xe, _e] = E.useState(we), Ve = E.useMemo(() => ve ? !1 : Re === 1 ? j : k, [ve, j, k]);
  kr(() => {
    _e(Ve && we);
  }, [Ve, we]);
  const Fe = we && (xe ? re : K), Ne = we && Re === 1 && xe, Je = we && Re > 1 && xe, J = (Oe, Qe) => {
    var ft;
    ce(Qe.expanded), (ft = W.onExpand) === null || ft === void 0 || ft.call(W, Oe, Qe);
  }, [he, Le] = E.useState(0), Pe = (Oe) => {
    let {
      offsetWidth: Qe
    } = Oe;
    Le(Qe);
  }, Ie = (Oe) => {
    var Qe;
    Z(Oe), K !== Oe && ((Qe = W.onEllipsis) === null || Qe === void 0 || Qe.call(W, Oe));
  };
  E.useEffect(() => {
    const Oe = S.current;
    if (oe && xe && Oe) {
      const Qe = Je ? Oe.offsetHeight < Oe.scrollHeight : Oe.offsetWidth < Oe.scrollWidth;
      re !== Qe && X(Qe);
    }
  }, [oe, xe, c, Je, Y, he]), E.useEffect(() => {
    const Oe = S.current;
    if (typeof IntersectionObserver > "u" || !Oe || !xe || !we)
      return;
    const Qe = new IntersectionObserver(() => {
      U(!!Oe.offsetParent);
    });
    return Qe.observe(Oe), () => {
      Qe.disconnect();
    };
  }, [xe, we]);
  let Ce = {};
  W.tooltip === !0 ? Ce = {
    title: (r = _.text) !== null && r !== void 0 ? r : c
  } : /* @__PURE__ */ E.isValidElement(W.tooltip) ? Ce = {
    title: W.tooltip
  } : typeof W.tooltip == "object" ? Ce = Object.assign({
    title: (n = _.text) !== null && n !== void 0 ? n : c
  }, W.tooltip) : Ce = {
    title: W.tooltip
  };
  const De = E.useMemo(() => {
    const Oe = (Qe) => ["string", "number"].includes(typeof Qe);
    if (!(!oe || xe)) {
      if (Oe(_.text))
        return _.text;
      if (Oe(c))
        return c;
      if (Oe(g))
        return g;
      if (Oe(Ce.title))
        return Ce.title;
    }
  }, [oe, xe, g, Ce.title, Fe]);
  if (T)
    return /* @__PURE__ */ E.createElement(Sfe, {
      value: (i = _.text) !== null && i !== void 0 ? i : typeof c == "string" ? c : "",
      onSave: L,
      onCancel: N,
      onEnd: _.onEnd,
      prefixCls: w,
      className: a,
      style: s,
      direction: y,
      component: p,
      maxLength: _.maxLength,
      autoSize: _.autoSize,
      enterIcon: _.enterIcon
    });
  const ze = () => {
    const {
      expandable: Oe,
      symbol: Qe
    } = W;
    return !Oe || ne && Oe !== "collapsible" ? null : /* @__PURE__ */ E.createElement(YR, {
      key: "expand",
      className: `${w}-${ne ? "collapse" : "expand"}`,
      onClick: (ft) => J(ft, {
        expanded: !ne
      }),
      "aria-label": ne ? C.collapse : C == null ? void 0 : C.expand
    }, typeof Qe == "function" ? Qe(ne) : Qe);
  }, st = () => {
    if (!R)
      return;
    const {
      icon: Oe,
      tooltip: Qe,
      tabIndex: ft
    } = _, xt = Zo(Qe)[0] || (C == null ? void 0 : C.edit), $r = typeof xt == "string" ? xt : "";
    return D.includes("icon") ? /* @__PURE__ */ E.createElement(vu, {
      key: "edit",
      title: Qe === !1 ? "" : xt
    }, /* @__PURE__ */ E.createElement(YR, {
      ref: b,
      className: `${w}-edit`,
      onClick: F,
      "aria-label": $r,
      tabIndex: ft
    }, Oe || /* @__PURE__ */ E.createElement(A3, {
      role: "button"
    }))) : null;
  }, Tt = () => I ? /* @__PURE__ */ E.createElement(Ffe, Object.assign({
    key: "copy"
  }, B, {
    prefixCls: w,
    copied: M,
    locale: C,
    onCopy: G,
    loading: V,
    iconOnly: c == null
  })) : null, ot = (Oe) => [
    // (renderExpanded || ellipsisConfig.collapsible) && renderExpand(),
    Oe && ze(),
    st(),
    Tt()
  ], Xe = (Oe) => [Oe && !ne && /* @__PURE__ */ E.createElement("span", {
    "aria-hidden": !0,
    key: "ellipsis"
  }, $fe), W.suffix, ot(Oe)];
  return /* @__PURE__ */ E.createElement(Co, {
    onResize: Pe,
    disabled: !we
  }, (Oe) => /* @__PURE__ */ E.createElement(N3, {
    tooltipProps: Ce,
    enableEllipsis: we,
    isEllipsis: Fe
  }, /* @__PURE__ */ E.createElement(mM, Object.assign({
    className: ue({
      [`${w}-${l}`]: l,
      [`${w}-disabled`]: u,
      [`${w}-ellipsis`]: oe,
      [`${w}-ellipsis-single-line`]: Ne,
      [`${w}-ellipsis-multiple-line`]: Je
    }, a),
    prefixCls: o,
    style: Object.assign(Object.assign({}, s), {
      WebkitLineClamp: Je ? Re : void 0
    }),
    component: p,
    ref: Eo(Oe, S, t),
    direction: y,
    onClick: D.includes("text") ? F : void 0,
    "aria-label": De == null ? void 0 : De.toString(),
    title: g
  }, x), /* @__PURE__ */ E.createElement(kfe, {
    enableMeasure: we && !xe,
    text: c,
    rows: Re,
    width: he,
    onEllipsis: Ie,
    expanded: ne,
    miscDeps: [M, ne, V, R, I]
  }, (Qe, ft) => Bfe(e, /* @__PURE__ */ E.createElement(E.Fragment, null, Qe.length > 0 && ft && !ne && De ? /* @__PURE__ */ E.createElement("span", {
    key: "show-content",
    "aria-hidden": !0
  }, Qe) : Qe, Xe(ft)))))));
});
var Hfe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Gfe = /* @__PURE__ */ E.forwardRef((e, t) => {
  var {
    ellipsis: r,
    rel: n
  } = e, i = Hfe(e, ["ellipsis", "rel"]);
  if (process.env.NODE_ENV !== "production") {
    const a = en("Typography.Link");
    process.env.NODE_ENV !== "production" && a(typeof r != "object", "usage", "`ellipsis` only supports boolean value.");
  }
  const o = Object.assign(Object.assign({}, i), {
    rel: n === void 0 && i.target === "_blank" ? "noopener noreferrer" : n
  });
  return delete o.navigate, /* @__PURE__ */ E.createElement(kS, Object.assign({}, o, {
    ref: t,
    ellipsis: !!r,
    component: "a"
  }));
}), zfe = /* @__PURE__ */ E.forwardRef((e, t) => /* @__PURE__ */ E.createElement(kS, Object.assign({
  ref: t
}, e, {
  component: "div"
})));
var Wfe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const jfe = (e, t) => {
  var {
    ellipsis: r
  } = e, n = Wfe(e, ["ellipsis"]);
  const i = E.useMemo(() => r && typeof r == "object" ? ni(r, ["expandable", "rows"]) : r, [r]);
  if (process.env.NODE_ENV !== "production") {
    const o = en("Typography.Text");
    process.env.NODE_ENV !== "production" && o(typeof r != "object" || !r || !("expandable" in r) && !("rows" in r), "usage", "`ellipsis` do not support `expandable` or `rows` props.");
  }
  return /* @__PURE__ */ E.createElement(kS, Object.assign({
    ref: t
  }, n, {
    ellipsis: i,
    component: "span"
  }));
}, Ufe = /* @__PURE__ */ E.forwardRef(jfe);
var Kfe = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const LL = [1, 2, 3, 4, 5], Yfe = /* @__PURE__ */ E.forwardRef((e, t) => {
  const {
    level: r = 1
  } = e, n = Kfe(e, ["level"]);
  let i;
  if (process.env.NODE_ENV !== "production") {
    const o = en("Typography.Title");
    process.env.NODE_ENV !== "production" && o(LL.includes(r), "usage", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value. And `5` need 4.6.0+ version.");
  }
  return LL.includes(r) ? i = `h${r}` : i = "h1", /* @__PURE__ */ E.createElement(kS, Object.assign({
    ref: t
  }, n, {
    component: i
  }));
}), xr = mM;
xr.Text = Ufe;
xr.Link = Gfe;
xr.Title = Yfe;
xr.Paragraph = zfe;
const k3 = ({
  inputRef: e,
  placeholder: t = "Ask me anything about your product data",
  userQuery: r,
  setUserQuery: n,
  handleSendMessage: i,
  width: o = "60vw",
  isFollowupDisabled: a = !1
}) => {
  const s = r.trim().length === 0 || a, l = (u) => {
    u.key === "Enter" && !u.shiftKey && (u.stopPropagation(), u.preventDefault(), s || i());
  };
  return /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      vertical: !0,
      style: {
        position: "absolute",
        bottom: 0,
        left: 0,
        right: 0,
        marginLeft: "auto",
        marginRight: "auto",
        width: o
      },
      children: [
        /* @__PURE__ */ ie.jsx(
          "div",
          {
            style: {
              backgroundImage: "linear-gradient(180deg, transparent 23%, var(--background) 97%)",
              height: "6vh"
            }
          }
        ),
        /* @__PURE__ */ ie.jsx(
          Ji,
          {
            size: "small",
            bordered: !0,
            style: {
              width: "100%",
              borderBottomLeftRadius: 0,
              borderBottomRightRadius: 0
            },
            styles: {
              body: {
                padding: 16
              }
            },
            children: /* @__PURE__ */ ie.jsxs(Zt, { vertical: !0, gap: 16, children: [
              /* @__PURE__ */ ie.jsxs(Zt, { align: "flex-start", gap: 12, children: [
                /* @__PURE__ */ ie.jsx(
                  pM,
                  {
                    ref: e,
                    value: r,
                    onChange: (u) => n(u.target.value),
                    autoSize: { minRows: 1, maxRows: 8 },
                    size: "large",
                    variant: "borderless",
                    placeholder: t,
                    onKeyDown: l
                  }
                ),
                /* @__PURE__ */ ie.jsx(
                  jn,
                  {
                    disabled: s,
                    size: "large",
                    type: "primary",
                    shape: "circle",
                    onClick: i,
                    icon: /* @__PURE__ */ ie.jsx(CP, { weight: "bold" })
                  }
                )
              ] }),
              /* @__PURE__ */ ie.jsx(Zt, { align: "flex-end", justify: "flex-end", children: /* @__PURE__ */ ie.jsxs(
                xr.Text,
                {
                  type: "secondary",
                  style: {
                    fontWeight: 500,
                    fontSize: "0.75rem",
                    visibility: r.trim().length > 0 ? "visible" : "hidden"
                  },
                  children: [
                    "Use",
                    " ",
                    /* @__PURE__ */ ie.jsx(
                      xr.Text,
                      {
                        type: "secondary",
                        style: {
                          backgroundColor: "var(--background)",
                          fontWeight: 500,
                          fontSize: "0.75rem",
                          padding: "3px 6px",
                          borderRadius: 4
                        },
                        children: "shift + enter"
                      }
                    ),
                    " ",
                    "for new line"
                  ]
                }
              ) })
            ] })
          }
        )
      ]
    }
  );
};
var qR = { exports: {} }, Db = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var FL;
function qfe() {
  return FL || (FL = 1, function(e) {
    function t(I, B) {
      var M = I.length;
      I.push(B);
      e: for (; 0 < M; ) {
        var V = M - 1 >>> 1, G = I[V];
        if (0 < i(G, B)) I[V] = B, I[M] = G, M = V;
        else break e;
      }
    }
    function r(I) {
      return I.length === 0 ? null : I[0];
    }
    function n(I) {
      if (I.length === 0) return null;
      var B = I[0], M = I.pop();
      if (M !== B) {
        I[0] = M;
        e: for (var V = 0, G = I.length, k = G >>> 1; V < k; ) {
          var z = 2 * (V + 1) - 1, j = I[z], q = z + 1, K = I[q];
          if (0 > i(j, M)) q < G && 0 > i(K, j) ? (I[V] = K, I[q] = M, V = q) : (I[V] = j, I[z] = M, V = z);
          else if (q < G && 0 > i(K, M)) I[V] = K, I[q] = M, V = q;
          else break e;
        }
      }
      return B;
    }
    function i(I, B) {
      var M = I.sortIndex - B.sortIndex;
      return M !== 0 ? M : I.id - B.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      e.unstable_now = function() {
        return o.now();
      };
    } else {
      var a = Date, s = a.now();
      e.unstable_now = function() {
        return a.now() - s;
      };
    }
    var l = [], u = [], c = 1, d = null, h = 3, f = !1, p = !1, g = !1, v = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, y = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function C(I) {
      for (var B = r(u); B !== null; ) {
        if (B.callback === null) n(u);
        else if (B.startTime <= I) n(u), B.sortIndex = B.expirationTime, t(l, B);
        else break;
        B = r(u);
      }
    }
    function S(I) {
      if (g = !1, C(I), !p) if (r(l) !== null) p = !0, L(b);
      else {
        var B = r(u);
        B !== null && N(S, B.startTime - I);
      }
    }
    function b(I, B) {
      p = !1, g && (g = !1, m(R), R = -1), f = !0;
      var M = h;
      try {
        for (C(B), d = r(l); d !== null && (!(d.expirationTime > B) || I && !P()); ) {
          var V = d.callback;
          if (typeof V == "function") {
            d.callback = null, h = d.priorityLevel;
            var G = V(d.expirationTime <= B);
            B = e.unstable_now(), typeof G == "function" ? d.callback = G : d === r(l) && n(l), C(B);
          } else n(l);
          d = r(l);
        }
        if (d !== null) var k = !0;
        else {
          var z = r(u);
          z !== null && N(S, z.startTime - B), k = !1;
        }
        return k;
      } finally {
        d = null, h = M, f = !1;
      }
    }
    var w = !1, x = null, R = -1, _ = 5, T = -1;
    function P() {
      return !(e.unstable_now() - T < _);
    }
    function D() {
      if (x !== null) {
        var I = e.unstable_now();
        T = I;
        var B = !0;
        try {
          B = x(!0, I);
        } finally {
          B ? O() : (w = !1, x = null);
        }
      } else w = !1;
    }
    var O;
    if (typeof y == "function") O = function() {
      y(D);
    };
    else if (typeof MessageChannel < "u") {
      var A = new MessageChannel(), F = A.port2;
      A.port1.onmessage = D, O = function() {
        F.postMessage(null);
      };
    } else O = function() {
      v(D, 0);
    };
    function L(I) {
      x = I, w || (w = !0, O());
    }
    function N(I, B) {
      R = v(function() {
        I(e.unstable_now());
      }, B);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(I) {
      I.callback = null;
    }, e.unstable_continueExecution = function() {
      p || f || (p = !0, L(b));
    }, e.unstable_forceFrameRate = function(I) {
      0 > I || 125 < I ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : _ = 0 < I ? Math.floor(1e3 / I) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return h;
    }, e.unstable_getFirstCallbackNode = function() {
      return r(l);
    }, e.unstable_next = function(I) {
      switch (h) {
        case 1:
        case 2:
        case 3:
          var B = 3;
          break;
        default:
          B = h;
      }
      var M = h;
      h = B;
      try {
        return I();
      } finally {
        h = M;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(I, B) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var M = h;
      h = I;
      try {
        return B();
      } finally {
        h = M;
      }
    }, e.unstable_scheduleCallback = function(I, B, M) {
      var V = e.unstable_now();
      switch (typeof M == "object" && M !== null ? (M = M.delay, M = typeof M == "number" && 0 < M ? V + M : V) : M = V, I) {
        case 1:
          var G = -1;
          break;
        case 2:
          G = 250;
          break;
        case 5:
          G = 1073741823;
          break;
        case 4:
          G = 1e4;
          break;
        default:
          G = 5e3;
      }
      return G = M + G, I = { id: c++, callback: B, priorityLevel: I, startTime: M, expirationTime: G, sortIndex: -1 }, M > V ? (I.sortIndex = M, t(u, I), r(l) === null && I === r(u) && (g ? (m(R), R = -1) : g = !0, N(S, M - V))) : (I.sortIndex = G, t(l, I), p || f || (p = !0, L(b))), I;
    }, e.unstable_shouldYield = P, e.unstable_wrapCallback = function(I) {
      var B = h;
      return function() {
        var M = h;
        h = B;
        try {
          return I.apply(this, arguments);
        } finally {
          h = M;
        }
      };
    };
  }(Db)), Db;
}
var Ab = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var NL;
function Xfe() {
  return NL || (NL = 1, function(e) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, r = !1, n = 5;
      function i(Ce, De) {
        var ze = Ce.length;
        Ce.push(De), s(Ce, De, ze);
      }
      function o(Ce) {
        return Ce.length === 0 ? null : Ce[0];
      }
      function a(Ce) {
        if (Ce.length === 0)
          return null;
        var De = Ce[0], ze = Ce.pop();
        return ze !== De && (Ce[0] = ze, l(Ce, ze, 0)), De;
      }
      function s(Ce, De, ze) {
        for (var st = ze; st > 0; ) {
          var Tt = st - 1 >>> 1, ot = Ce[Tt];
          if (u(ot, De) > 0)
            Ce[Tt] = De, Ce[st] = ot, st = Tt;
          else
            return;
        }
      }
      function l(Ce, De, ze) {
        for (var st = ze, Tt = Ce.length, ot = Tt >>> 1; st < ot; ) {
          var Xe = (st + 1) * 2 - 1, Oe = Ce[Xe], Qe = Xe + 1, ft = Ce[Qe];
          if (u(Oe, De) < 0)
            Qe < Tt && u(ft, Oe) < 0 ? (Ce[st] = ft, Ce[Qe] = De, st = Qe) : (Ce[st] = Oe, Ce[Xe] = De, st = Xe);
          else if (Qe < Tt && u(ft, De) < 0)
            Ce[st] = ft, Ce[Qe] = De, st = Qe;
          else
            return;
        }
      }
      function u(Ce, De) {
        var ze = Ce.sortIndex - De.sortIndex;
        return ze !== 0 ? ze : Ce.id - De.id;
      }
      var c = 1, d = 2, h = 3, f = 4, p = 5;
      function g(Ce, De) {
      }
      var v = typeof performance == "object" && typeof performance.now == "function";
      if (v) {
        var m = performance;
        e.unstable_now = function() {
          return m.now();
        };
      } else {
        var y = Date, C = y.now();
        e.unstable_now = function() {
          return y.now() - C;
        };
      }
      var S = 1073741823, b = -1, w = 250, x = 5e3, R = 1e4, _ = S, T = [], P = [], D = 1, O = null, A = h, F = !1, L = !1, N = !1, I = typeof setTimeout == "function" ? setTimeout : null, B = typeof clearTimeout == "function" ? clearTimeout : null, M = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function V(Ce) {
        for (var De = o(P); De !== null; ) {
          if (De.callback === null)
            a(P);
          else if (De.startTime <= Ce)
            a(P), De.sortIndex = De.expirationTime, i(T, De);
          else
            return;
          De = o(P);
        }
      }
      function G(Ce) {
        if (N = !1, V(Ce), !L)
          if (o(T) !== null)
            L = !0, J(k);
          else {
            var De = o(P);
            De !== null && he(G, De.startTime - Ce);
          }
      }
      function k(Ce, De) {
        L = !1, N && (N = !1, Le()), F = !0;
        var ze = A;
        try {
          var st;
          if (!r) return z(Ce, De);
        } finally {
          O = null, A = ze, F = !1;
        }
      }
      function z(Ce, De) {
        var ze = De;
        for (V(ze), O = o(T); O !== null && !t && !(O.expirationTime > ze && (!Ce || ve())); ) {
          var st = O.callback;
          if (typeof st == "function") {
            O.callback = null, A = O.priorityLevel;
            var Tt = O.expirationTime <= ze, ot = st(Tt);
            ze = e.unstable_now(), typeof ot == "function" ? O.callback = ot : O === o(T) && a(T), V(ze);
          } else
            a(T);
          O = o(T);
        }
        if (O !== null)
          return !0;
        var Xe = o(P);
        return Xe !== null && he(G, Xe.startTime - ze), !1;
      }
      function j(Ce, De) {
        switch (Ce) {
          case c:
          case d:
          case h:
          case f:
          case p:
            break;
          default:
            Ce = h;
        }
        var ze = A;
        A = Ce;
        try {
          return De();
        } finally {
          A = ze;
        }
      }
      function q(Ce) {
        var De;
        switch (A) {
          case c:
          case d:
          case h:
            De = h;
            break;
          default:
            De = A;
            break;
        }
        var ze = A;
        A = De;
        try {
          return Ce();
        } finally {
          A = ze;
        }
      }
      function K(Ce) {
        var De = A;
        return function() {
          var ze = A;
          A = De;
          try {
            return Ce.apply(this, arguments);
          } finally {
            A = ze;
          }
        };
      }
      function Z(Ce, De, ze) {
        var st = e.unstable_now(), Tt;
        if (typeof ze == "object" && ze !== null) {
          var ot = ze.delay;
          typeof ot == "number" && ot > 0 ? Tt = st + ot : Tt = st;
        } else
          Tt = st;
        var Xe;
        switch (Ce) {
          case c:
            Xe = b;
            break;
          case d:
            Xe = w;
            break;
          case p:
            Xe = _;
            break;
          case f:
            Xe = R;
            break;
          case h:
          default:
            Xe = x;
            break;
        }
        var Oe = Tt + Xe, Qe = {
          id: D++,
          callback: De,
          priorityLevel: Ce,
          startTime: Tt,
          expirationTime: Oe,
          sortIndex: -1
        };
        return Tt > st ? (Qe.sortIndex = Tt, i(P, Qe), o(T) === null && Qe === o(P) && (N ? Le() : N = !0, he(G, Tt - st))) : (Qe.sortIndex = Oe, i(T, Qe), !L && !F && (L = !0, J(k))), Qe;
      }
      function re() {
      }
      function X() {
        !L && !F && (L = !0, J(k));
      }
      function Y() {
        return o(T);
      }
      function U(Ce) {
        Ce.callback = null;
      }
      function oe() {
        return A;
      }
      var W = !1, ne = null, ce = -1, we = n, Re = -1;
      function ve() {
        var Ce = e.unstable_now() - Re;
        return !(Ce < we);
      }
      function xe() {
      }
      function _e(Ce) {
        if (Ce < 0 || Ce > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        Ce > 0 ? we = Math.floor(1e3 / Ce) : we = n;
      }
      var Ve = function() {
        if (ne !== null) {
          var Ce = e.unstable_now();
          Re = Ce;
          var De = !0, ze = !0;
          try {
            ze = ne(De, Ce);
          } finally {
            ze ? Fe() : (W = !1, ne = null);
          }
        } else
          W = !1;
      }, Fe;
      if (typeof M == "function")
        Fe = function() {
          M(Ve);
        };
      else if (typeof MessageChannel < "u") {
        var Ne = new MessageChannel(), Je = Ne.port2;
        Ne.port1.onmessage = Ve, Fe = function() {
          Je.postMessage(null);
        };
      } else
        Fe = function() {
          I(Ve, 0);
        };
      function J(Ce) {
        ne = Ce, W || (W = !0, Fe());
      }
      function he(Ce, De) {
        ce = I(function() {
          Ce(e.unstable_now());
        }, De);
      }
      function Le() {
        B(ce), ce = -1;
      }
      var Pe = xe, Ie = null;
      e.unstable_IdlePriority = p, e.unstable_ImmediatePriority = c, e.unstable_LowPriority = f, e.unstable_NormalPriority = h, e.unstable_Profiling = Ie, e.unstable_UserBlockingPriority = d, e.unstable_cancelCallback = U, e.unstable_continueExecution = X, e.unstable_forceFrameRate = _e, e.unstable_getCurrentPriorityLevel = oe, e.unstable_getFirstCallbackNode = Y, e.unstable_next = q, e.unstable_pauseExecution = re, e.unstable_requestPaint = Pe, e.unstable_runWithPriority = j, e.unstable_scheduleCallback = Z, e.unstable_shouldYield = ve, e.unstable_wrapCallback = K, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(Ab)), Ab;
}
process.env.NODE_ENV === "production" ? qR.exports = qfe() : qR.exports = Xfe();
var Ib = qR.exports;
const U0 = Symbol(), Zfe = Symbol(), Qfe = typeof window > "u" || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent), V3 = Qfe ? Nt : as, Jfe = Ib.unstable_runWithPriority ? (e) => {
  try {
    Ib.unstable_runWithPriority(Ib.unstable_NormalPriority, e);
  } catch (t) {
    if (t.message === "Not implemented.")
      e();
    else
      throw t;
  }
} : (e) => e(), epe = (e) => ({ value: r, children: n }) => {
  const i = se(r), o = se(0), [a, s] = Me(null);
  a && (a(r), s(null));
  const l = se();
  if (!l.current) {
    const u = /* @__PURE__ */ new Set(), c = (d, h) => {
      o.current += 1;
      const f = {
        n: o.current
      };
      h != null && h.suspense && (f.n *= -1, f.p = new Promise((p) => {
        s(() => (g) => {
          f.v = g, delete f.p, p(g);
        });
      })), u.forEach((p) => p(f)), d();
    };
    l.current = {
      [U0]: {
        /* "v"alue     */
        v: i,
        /* versio"n"   */
        n: o,
        /* "l"isteners */
        l: u,
        /* "u"pdate    */
        u: c
      }
    };
  }
  return V3(() => {
    i.current = r, o.current += 1, Jfe(() => {
      l.current[U0].l.forEach((u) => {
        u({ n: o.current, v: r });
      });
    });
  }, [r]), CG(e, { value: l.current }, n);
}, tpe = (e) => e;
function rpe(e) {
  const t = du({
    [U0]: {
      /* "v"alue     */
      v: { current: e },
      /* versio"n"   */
      n: { current: -1 },
      /* "l"isteners */
      l: /* @__PURE__ */ new Set(),
      /* "u"pdate    */
      u: (r) => r()
    }
  });
  return t[Zfe] = t.Provider, t.Provider = epe(t.Provider), delete t.Consumer, t;
}
function npe(e, t) {
  const r = vr(e)[U0];
  if (typeof process == "object" && process.env.NODE_ENV !== "production" && !r)
    throw new Error("useContextSelector requires special context");
  const {
    /* "v"alue     */
    v: { current: n },
    /* versio"n"   */
    n: { current: i },
    /* "l"isteners */
    l: o
  } = r, a = t(n), [s, l] = BX((u, c) => {
    if (!c)
      return [n, a];
    if ("p" in c)
      throw c.p;
    if (c.n === i)
      return Object.is(u[1], a) ? u : [n, a];
    try {
      if ("v" in c) {
        if (Object.is(u[0], c.v))
          return u;
        const d = t(c.v);
        return Object.is(u[1], d) ? u : [c.v, d];
      }
    } catch {
    }
    return [...u];
  }, [n, a]);
  return Object.is(s[1], a) || l(), V3(() => (o.add(l), () => {
    o.delete(l);
  }), [o]), s[1];
}
function ipe(e) {
  return npe(e, tpe);
}
const ope = {
  light: {
    "--primary-color": "#49a5aa",
    // Always keep this in hex format
    "--cta-text": "white",
    "--background": "#FEFBF3",
    "--primary-text": "#3c3838",
    "--border": "#e9e0d6",
    "--secondary-text": "#9D9D9D",
    "--foreground": "#f9f4e8",
    "--chart-colors": [
      "rgb(136, 204, 238)",
      "rgb(204, 102, 119)",
      "rgb(221, 204, 119)",
      "rgb(17, 119, 51)",
      "rgb(51, 34, 136)",
      "rgb(170, 68, 153)",
      "rgb(68, 170, 153)",
      "rgb(153, 153, 51)",
      "rgb(136, 34, 85)",
      "rgb(102, 17, 0)",
      "rgb(136, 136, 136)"
    ]
  },
  dark: {
    "--primary-color": "#76ABAE",
    // Always keep this in hex format
    "--cta-text": "#222831",
    "--background": "#222831",
    "--primary-text": "#f7f7f7",
    "--border": "#484848",
    "--secondary-text": "#bfbfbf",
    "--foreground": "#31363F",
    "--chart-colors": [
      "rgb(102, 197, 204)",
      "rgb(246, 207, 113)",
      "rgb(248, 156, 116)",
      "rgb(220, 176, 242)",
      "rgb(135, 197, 95)",
      "rgb(158, 185, 243)",
      "rgb(254, 136, 177)",
      "rgb(201, 219, 116)",
      "rgb(139, 224, 164)",
      "rgb(180, 151, 231)",
      "rgb(179, 179, 179)"
    ]
  }
}, B3 = rpe(
  void 0
);
function $7e({
  children: e,
  appTheme: t = ope
}) {
  const r = (localStorage == null ? void 0 : localStorage.getItem("appThemeMode")) || "light", [n, i] = Me(r), o = t[n];
  return Nt(() => {
    Object.entries(o).forEach(([a, s]) => {
      typeof s == "string" && document.documentElement.style.setProperty(`${a}`, s);
    });
  }, [o]), /* @__PURE__ */ ie.jsx(
    B3.Provider,
    {
      value: {
        appThemeMode: n,
        setAppThemeMode: i,
        themeColors: o
      },
      children: /* @__PURE__ */ ie.jsx(
        pu,
        {
          theme: {
            token: {
              colorPrimary: o["--primary-color"],
              colorBgBase: o["--background"],
              colorText: o["--primary-text"],
              colorTextDescription: o["--secondary-text"],
              colorTextHeading: o["--primary-text"],
              colorTextSecondary: o["--secondary-text"],
              fontFamily: "HousewareFont",
              colorLink: o["--primary-color"],
              colorBorder: o["--border"],
              colorBorderSecondary: o["--border"],
              colorSplit: o["--border"]
            },
            components: {
              Card: {
                colorBgContainer: o["--foreground"],
                colorBorder: o["--border"]
              },
              Input: {
                colorTextPlaceholder: o["--secondary-text"]
              },
              Button: {
                primaryColor: o["--cta-text"],
                primaryShadow: "none",
                defaultHoverColor: o["--cta-text"]
              },
              Layout: {
                bodyBg: o["--background"]
              }
            }
          },
          children: e
        }
      )
    }
  );
}
const ape = () => {
  const e = ipe(B3);
  if (!e)
    throw new Error("useTheme must be used within a ThemeProvider");
  return e;
}, Tv = () => {
  const { appThemeMode: e, setAppThemeMode: t, themeColors: r } = ape();
  return {
    currentTheme: e,
    themeColors: r,
    setTheme: t,
    toggleTheme: () => {
      t(e === "light" ? "dark" : "light");
    }
  };
}, $3 = () => {
  const [e, t] = Me({ x: 0, y: 0 }), r = se(null), { themeColors: n } = Tv(), o = ((a) => {
    const s = parseInt(a.slice(1, 3), 16), l = parseInt(a.slice(3, 5), 16), u = parseInt(a.slice(5, 7), 16);
    return { r: s, g: l, b: u };
  })(n["--primary-color"]);
  return Nt(() => {
    const a = r.current;
    if (!a) return;
    const s = a.getContext("2d");
    if (!s) return;
    const l = 20, u = 70, c = () => {
      if (!(!a || !s)) {
        a.width = window.innerWidth, a.height = window.innerHeight, s.strokeStyle = `rgba(${o.r}, ${o.g}, ${o.b}, 0.05)`, s.lineWidth = 1;
        for (let f = 0; f <= a.width; f += l)
          s.beginPath(), s.moveTo(f, 0), s.lineTo(f, a.height), s.stroke();
        for (let f = 0; f <= a.height; f += l)
          s.beginPath(), s.moveTo(0, f), s.lineTo(a.width, f), s.stroke();
        for (let f = 0; f <= a.width; f += l)
          for (let p = 0; p <= a.height; p += l) {
            const g = Math.sqrt(
              Math.pow(f - e.x, 2) + Math.pow(p - e.y, 2)
            );
            if (g <= u) {
              const v = Math.cos(
                g / u * (Math.PI / 2)
              );
              s.strokeStyle = `rgba(${o.r}, ${o.g}, ${o.b}, ${v * 0.5})`, f % l === 0 && (s.beginPath(), s.moveTo(f, Math.max(0, p - l)), s.lineTo(f, Math.min(a.height, p + l)), s.stroke()), p % l === 0 && (s.beginPath(), s.moveTo(Math.max(0, f - l), p), s.lineTo(Math.min(a.width, f + l), p), s.stroke());
            }
          }
      }
    }, d = (f) => {
      t({ x: f.clientX, y: f.clientY });
    }, h = () => {
      c();
    };
    return window.addEventListener("mousemove", d), window.addEventListener("resize", h), c(), () => {
      window.removeEventListener("mousemove", d), window.removeEventListener("resize", h);
    };
  }, [e, o]), /* @__PURE__ */ ie.jsx("div", { style: { position: "absolute", top: 0, left: 0 }, children: /* @__PURE__ */ ie.jsx("canvas", { ref: r, className: "absolute inset-0" }) });
}, H7e = ({
  suggestions: e,
  handleSendMessage: t,
  heading: r,
  subHeading: n
}) => {
  const [i, o] = Me(""), { themeColors: a } = Tv(), s = se(null);
  return /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      justify: "space-evenly",
      align: "center",
      vertical: !0,
      style: { height: "90vh" },
      children: [
        /* @__PURE__ */ ie.jsx($3, {}),
        /* @__PURE__ */ ie.jsxs(
          Zt,
          {
            vertical: !0,
            align: "center",
            gap: 12,
            style: {
              zIndex: 1
            },
            children: [
              /* @__PURE__ */ ie.jsx(
                xr.Title,
                {
                  level: 2,
                  style: {
                    width: "30vw",
                    textAlign: "center",
                    fontFamily: "Sedan"
                  },
                  children: r
                }
              ),
              /* @__PURE__ */ ie.jsx(
                xr.Text,
                {
                  style: {
                    width: "40vw",
                    textAlign: "center"
                  },
                  children: n
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ ie.jsxs(
          Ji,
          {
            style: {
              position: "relative",
              maxWidth: "40vw"
            },
            children: [
              /* @__PURE__ */ ie.jsx(
                NS,
                {
                  style: {
                    position: "absolute",
                    top: "-0.7rem",
                    left: 0,
                    right: 0,
                    marginLeft: "auto",
                    marginRight: "auto",
                    width: "max-content",
                    borderColor: a["--primary-color"],
                    backgroundColor: a["--background"],
                    color: a["--primary-color"]
                  },
                  children: "Suggestions"
                }
              ),
              /* @__PURE__ */ ie.jsxs(Zt, { vertical: !0, align: "center", gap: 18, children: [
                /* @__PURE__ */ ie.jsx(
                  xr.Text,
                  {
                    style: {
                      marginTop: 0
                    },
                    type: "secondary",
                    children: "Get started with an example below"
                  }
                ),
                /* @__PURE__ */ ie.jsx(
                  Zt,
                  {
                    gap: 12,
                    style: {
                      width: "100%"
                    },
                    children: e.map((l) => /* @__PURE__ */ ie.jsx(
                      Ji,
                      {
                        style: {
                          width: `calc(100% / ${e.length})`,
                          overflow: "hidden",
                          cursor: "pointer"
                        },
                        onClick: () => {
                          var u;
                          o(l.content), (u = s == null ? void 0 : s.current) == null || u.focus();
                        },
                        rootClassName: "hoverable-card",
                        styles: {
                          body: {
                            padding: 12
                          }
                        },
                        children: /* @__PURE__ */ ie.jsxs(
                          xr.Text,
                          {
                            rootClassName: "three-line-ellipsis",
                            style: {
                              textAlign: "center"
                            },
                            children: [
                              " ",
                              l.title
                            ]
                          }
                        )
                      },
                      l.title
                    ))
                  }
                )
              ] })
            ]
          }
        ),
        /* @__PURE__ */ ie.jsx(
          k3,
          {
            inputRef: s,
            userQuery: i,
            setUserQuery: o,
            handleSendMessage: () => {
              t(i), o("");
            }
          }
        )
      ]
    }
  );
}, spe = ({
  inputRef: e,
  placeholder: t = "Keywords related to your products separated by commas...",
  userQuery: r,
  setUserQuery: n,
  handleSendMessage: i,
  isFollowupDisabled: o = !1
}) => {
  const a = r.trim().length === 0 || o;
  return /* @__PURE__ */ ie.jsx(
    Zt,
    {
      vertical: !0,
      style: {
        width: "40vw"
      },
      children: /* @__PURE__ */ ie.jsx(
        Ji,
        {
          size: "small",
          bordered: !0,
          style: {
            width: "100%"
          },
          styles: {
            body: {
              padding: 16
            }
          },
          children: /* @__PURE__ */ ie.jsx(Zt, { justify: "space-between", gap: 12, children: /* @__PURE__ */ ie.jsxs(Zt, { vertical: !0, style: { width: "100%" }, gap: 24, children: [
            /* @__PURE__ */ ie.jsxs(
              Zt,
              {
                vertical: !0,
                gap: 4,
                style: {
                  width: "100%"
                },
                children: [
                  /* @__PURE__ */ ie.jsx(
                    xr.Text,
                    {
                      type: "secondary",
                      style: {
                        fontSize: "0.8rem"
                      },
                      children: "I want to run my campaign for"
                    }
                  ),
                  /* @__PURE__ */ ie.jsx(
                    eu,
                    {
                      style: { width: "100%" },
                      ref: e,
                      onChange: (s) => n(s.target.value),
                      value: r,
                      size: "large",
                      variant: "outlined",
                      placeholder: t
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ ie.jsxs(Zt, { align: "center", justify: "space-between", children: [
              /* @__PURE__ */ ie.jsxs(Zt, { gap: 4, align: "center", children: [
                /* @__PURE__ */ ie.jsx(
                  xr.Text,
                  {
                    type: "secondary",
                    style: {
                      fontSize: "0.8rem"
                    },
                    children: "Targetting users in"
                  }
                ),
                /* @__PURE__ */ ie.jsx(
                  jn,
                  {
                    type: "text",
                    style: {
                      fontSize: "0.8rem"
                    },
                    size: "small",
                    icon: /* @__PURE__ */ ie.jsx(TG, {}),
                    children: "India"
                  }
                ),
                /* @__PURE__ */ ie.jsx(
                  xr.Text,
                  {
                    type: "secondary",
                    style: {
                      fontSize: "0.8rem"
                    },
                    children: "speaking"
                  }
                ),
                /* @__PURE__ */ ie.jsx(
                  jn,
                  {
                    type: "text",
                    style: {
                      fontSize: "0.8rem"
                    },
                    size: "small",
                    icon: /* @__PURE__ */ ie.jsx(MG, {}),
                    children: "English"
                  }
                )
              ] }),
              /* @__PURE__ */ ie.jsx(
                jn,
                {
                  disabled: a,
                  size: "middle",
                  type: "primary",
                  onClick: i,
                  icon: /* @__PURE__ */ ie.jsx(CP, { weight: "bold" }),
                  children: "Search"
                }
              )
            ] })
          ] }) })
        }
      )
    }
  );
}, G7e = ({
  handleSendMessage: e,
  heading: t,
  subHeading: r
}) => {
  const [n, i] = Me(""), o = se(null);
  return /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      justify: "space-evenly",
      align: "center",
      vertical: !0,
      style: { height: "100vh" },
      children: [
        /* @__PURE__ */ ie.jsx($3, {}),
        /* @__PURE__ */ ie.jsxs(
          Zt,
          {
            vertical: !0,
            align: "center",
            gap: 12,
            style: {
              zIndex: 1
            },
            children: [
              /* @__PURE__ */ ie.jsx(
                xr.Title,
                {
                  level: 2,
                  style: {
                    width: "30vw",
                    textAlign: "center",
                    fontFamily: "Sedan"
                  },
                  children: t
                }
              ),
              /* @__PURE__ */ ie.jsx(
                xr.Text,
                {
                  style: {
                    width: "40vw",
                    textAlign: "center"
                  },
                  children: r
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ ie.jsx(
          spe,
          {
            inputRef: o,
            userQuery: n,
            setUserQuery: i,
            handleSendMessage: () => {
              e(n), i("");
            }
          }
        )
      ]
    }
  );
};
function lpe() {
  return /* @__PURE__ */ ie.jsxs(Zt, { style: { width: "90%" }, align: "flex-start", gap: 8, children: [
    /* @__PURE__ */ ie.jsx(
      _v,
      {
        className: "ai-icon-rotate",
        src: "/ai-icon.svg",
        height: 40,
        width: 40,
        style: {
          height: "2rem",
          width: "2rem"
        }
      }
    ),
    /* @__PURE__ */ ie.jsx(gu, { active: !0 })
  ] });
}
function upe(e, t) {
  const r = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (r.padRight ? " " : "") + "," + (r.padLeft === !1 ? "" : " ")
  ).trim();
}
const cpe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, dpe = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, hpe = {};
function kL(e, t) {
  return (hpe.jsx ? dpe : cpe).test(e);
}
const fpe = /[ \t\n\f\r]/g;
function ppe(e) {
  return typeof e == "object" ? e.type === "text" ? VL(e.value) : !1 : VL(e);
}
function VL(e) {
  return e.replace(fpe, "") === "";
}
class Pv {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, r, n) {
    this.property = t, this.normal = r, n && (this.space = n);
  }
}
Pv.prototype.property = {};
Pv.prototype.normal = {};
Pv.prototype.space = null;
function H3(e, t) {
  const r = {}, n = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(r, e[i].property), Object.assign(n, e[i].normal);
  return new Pv(r, n, t);
}
function XR(e) {
  return e.toLowerCase();
}
class ra {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, r) {
    this.property = t, this.attribute = r;
  }
}
ra.prototype.space = null;
ra.prototype.boolean = !1;
ra.prototype.booleanish = !1;
ra.prototype.overloadedBoolean = !1;
ra.prototype.number = !1;
ra.prototype.commaSeparated = !1;
ra.prototype.spaceSeparated = !1;
ra.prototype.commaOrSpaceSeparated = !1;
ra.prototype.mustUseProperty = !1;
ra.prototype.defined = !1;
let gpe = 0;
const rr = rd(), Mn = rd(), G3 = rd(), We = rd(), Zr = rd(), xh = rd(), lo = rd();
function rd() {
  return 2 ** ++gpe;
}
const ZR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: rr,
  booleanish: Mn,
  commaOrSpaceSeparated: lo,
  commaSeparated: xh,
  number: We,
  overloadedBoolean: G3,
  spaceSeparated: Zr
}, Symbol.toStringTag, { value: "Module" })), Ob = Object.keys(ZR);
class yM extends ra {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, r, n, i) {
    let o = -1;
    if (super(t, r), BL(this, "space", i), typeof n == "number")
      for (; ++o < Ob.length; ) {
        const a = Ob[o];
        BL(this, Ob[o], (n & ZR[a]) === ZR[a]);
      }
  }
}
yM.prototype.defined = !0;
function BL(e, t, r) {
  r && (e[t] = r);
}
const vpe = {}.hasOwnProperty;
function df(e) {
  const t = {}, r = {};
  let n;
  for (n in e.properties)
    if (vpe.call(e.properties, n)) {
      const i = e.properties[n], o = new yM(
        n,
        e.transform(e.attributes || {}, n),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(n) && (o.mustUseProperty = !0), t[n] = o, r[XR(n)] = n, r[XR(o.attribute)] = n;
    }
  return new Pv(t, r, e.space);
}
const z3 = df({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), W3 = df({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function j3(e, t) {
  return t in e ? e[t] : t;
}
function U3(e, t) {
  return j3(e, t.toLowerCase());
}
const K3 = df({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: U3,
  properties: { xmlns: null, xmlnsXLink: null }
}), Y3 = df({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: Mn,
    ariaAutoComplete: null,
    ariaBusy: Mn,
    ariaChecked: Mn,
    ariaColCount: We,
    ariaColIndex: We,
    ariaColSpan: We,
    ariaControls: Zr,
    ariaCurrent: null,
    ariaDescribedBy: Zr,
    ariaDetails: null,
    ariaDisabled: Mn,
    ariaDropEffect: Zr,
    ariaErrorMessage: null,
    ariaExpanded: Mn,
    ariaFlowTo: Zr,
    ariaGrabbed: Mn,
    ariaHasPopup: null,
    ariaHidden: Mn,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Zr,
    ariaLevel: We,
    ariaLive: null,
    ariaModal: Mn,
    ariaMultiLine: Mn,
    ariaMultiSelectable: Mn,
    ariaOrientation: null,
    ariaOwns: Zr,
    ariaPlaceholder: null,
    ariaPosInSet: We,
    ariaPressed: Mn,
    ariaReadOnly: Mn,
    ariaRelevant: null,
    ariaRequired: Mn,
    ariaRoleDescription: Zr,
    ariaRowCount: We,
    ariaRowIndex: We,
    ariaRowSpan: We,
    ariaSelected: Mn,
    ariaSetSize: We,
    ariaSort: null,
    ariaValueMax: We,
    ariaValueMin: We,
    ariaValueNow: We,
    ariaValueText: null,
    role: null
  }
}), mpe = df({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: U3,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: xh,
    acceptCharset: Zr,
    accessKey: Zr,
    action: null,
    allow: null,
    allowFullScreen: rr,
    allowPaymentRequest: rr,
    allowUserMedia: rr,
    alt: null,
    as: null,
    async: rr,
    autoCapitalize: null,
    autoComplete: Zr,
    autoFocus: rr,
    autoPlay: rr,
    blocking: Zr,
    capture: null,
    charSet: null,
    checked: rr,
    cite: null,
    className: Zr,
    cols: We,
    colSpan: null,
    content: null,
    contentEditable: Mn,
    controls: rr,
    controlsList: Zr,
    coords: We | xh,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: rr,
    defer: rr,
    dir: null,
    dirName: null,
    disabled: rr,
    download: G3,
    draggable: Mn,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: rr,
    formTarget: null,
    headers: Zr,
    height: We,
    hidden: rr,
    high: We,
    href: null,
    hrefLang: null,
    htmlFor: Zr,
    httpEquiv: Zr,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: rr,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: rr,
    itemId: null,
    itemProp: Zr,
    itemRef: Zr,
    itemScope: rr,
    itemType: Zr,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: rr,
    low: We,
    manifest: null,
    max: null,
    maxLength: We,
    media: null,
    method: null,
    min: null,
    minLength: We,
    multiple: rr,
    muted: rr,
    name: null,
    nonce: null,
    noModule: rr,
    noValidate: rr,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: rr,
    optimum: We,
    pattern: null,
    ping: Zr,
    placeholder: null,
    playsInline: rr,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: rr,
    referrerPolicy: null,
    rel: Zr,
    required: rr,
    reversed: rr,
    rows: We,
    rowSpan: We,
    sandbox: Zr,
    scope: null,
    scoped: rr,
    seamless: rr,
    selected: rr,
    shadowRootClonable: rr,
    shadowRootDelegatesFocus: rr,
    shadowRootMode: null,
    shape: null,
    size: We,
    sizes: null,
    slot: null,
    span: We,
    spellCheck: Mn,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: We,
    step: null,
    style: null,
    tabIndex: We,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: rr,
    useMap: null,
    value: Mn,
    width: We,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Zr,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: We,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: We,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: rr,
    // Lists. Use CSS to reduce space between items instead
    declare: rr,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: We,
    // `<img>` and `<object>`
    leftMargin: We,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: We,
    // `<body>`
    marginWidth: We,
    // `<body>`
    noResize: rr,
    // `<frame>`
    noHref: rr,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: rr,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: rr,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: We,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: Mn,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: We,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: We,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: rr,
    disableRemotePlayback: rr,
    prefix: null,
    property: null,
    results: We,
    security: null,
    unselectable: null
  }
}), ype = df({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: j3,
  properties: {
    about: lo,
    accentHeight: We,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: We,
    amplitude: We,
    arabicForm: null,
    ascent: We,
    attributeName: null,
    attributeType: null,
    azimuth: We,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: We,
    by: null,
    calcMode: null,
    capHeight: We,
    className: Zr,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: We,
    diffuseConstant: We,
    direction: null,
    display: null,
    dur: null,
    divisor: We,
    dominantBaseline: null,
    download: rr,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: We,
    enableBackground: null,
    end: null,
    event: null,
    exponent: We,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: We,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: xh,
    g2: xh,
    glyphName: xh,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: We,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: We,
    horizOriginX: We,
    horizOriginY: We,
    id: null,
    ideographic: We,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: We,
    k: We,
    k1: We,
    k2: We,
    k3: We,
    k4: We,
    kernelMatrix: lo,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: We,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: We,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: We,
    overlineThickness: We,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: We,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Zr,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: We,
    pointsAtY: We,
    pointsAtZ: We,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: lo,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: lo,
    rev: lo,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: lo,
    requiredFeatures: lo,
    requiredFonts: lo,
    requiredFormats: lo,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: We,
    specularExponent: We,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: We,
    strikethroughThickness: We,
    string: null,
    stroke: null,
    strokeDashArray: lo,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: We,
    strokeOpacity: We,
    strokeWidth: null,
    style: null,
    surfaceScale: We,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: lo,
    tabIndex: We,
    tableValues: null,
    target: null,
    targetX: We,
    targetY: We,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: lo,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: We,
    underlineThickness: We,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: We,
    values: null,
    vAlphabetic: We,
    vMathematical: We,
    vectorEffect: null,
    vHanging: We,
    vIdeographic: We,
    version: null,
    vertAdvY: We,
    vertOriginX: We,
    vertOriginY: We,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: We,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), Cpe = /^data[-\w.:]+$/i, $L = /-[a-z]/g, Spe = /[A-Z]/g;
function wpe(e, t) {
  const r = XR(t);
  let n = t, i = ra;
  if (r in e.normal)
    return e.property[e.normal[r]];
  if (r.length > 4 && r.slice(0, 4) === "data" && Cpe.test(t)) {
    if (t.charAt(4) === "-") {
      const o = t.slice(5).replace($L, xpe);
      n = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = t.slice(4);
      if (!$L.test(o)) {
        let a = o.replace(Spe, bpe);
        a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
      }
    }
    i = yM;
  }
  return new i(n, t);
}
function bpe(e) {
  return "-" + e.toLowerCase();
}
function xpe(e) {
  return e.charAt(1).toUpperCase();
}
const Epe = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, Rpe = H3([W3, z3, K3, Y3, mpe], "html"), CM = H3([W3, z3, K3, Y3, ype], "svg");
function _pe(e) {
  return e.join(" ").trim();
}
var q3 = {}, HL = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Tpe = /\n/g, Ppe = /^\s*/, Mpe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Dpe = /^:\s*/, Ape = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Ipe = /^[;\s]*/, Ope = /^\s+|\s+$/g, Lpe = `
`, GL = "/", zL = "*", ac = "", Fpe = "comment", Npe = "declaration", kpe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var r = 1, n = 1;
  function i(p) {
    var g = p.match(Tpe);
    g && (r += g.length);
    var v = p.lastIndexOf(Lpe);
    n = ~v ? p.length - v : n + p.length;
  }
  function o() {
    var p = { line: r, column: n };
    return function(g) {
      return g.position = new a(p), u(), g;
    };
  }
  function a(p) {
    this.start = p, this.end = { line: r, column: n }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(p) {
    var g = new Error(
      t.source + ":" + r + ":" + n + ": " + p
    );
    if (g.reason = p, g.filename = t.source, g.line = r, g.column = n, g.source = e, !t.silent) throw g;
  }
  function l(p) {
    var g = p.exec(e);
    if (g) {
      var v = g[0];
      return i(v), e = e.slice(v.length), g;
    }
  }
  function u() {
    l(Ppe);
  }
  function c(p) {
    var g;
    for (p = p || []; g = d(); )
      g !== !1 && p.push(g);
    return p;
  }
  function d() {
    var p = o();
    if (!(GL != e.charAt(0) || zL != e.charAt(1))) {
      for (var g = 2; ac != e.charAt(g) && (zL != e.charAt(g) || GL != e.charAt(g + 1)); )
        ++g;
      if (g += 2, ac === e.charAt(g - 1))
        return s("End of comment missing");
      var v = e.slice(2, g - 2);
      return n += 2, i(v), e = e.slice(g), n += 2, p({
        type: Fpe,
        comment: v
      });
    }
  }
  function h() {
    var p = o(), g = l(Mpe);
    if (g) {
      if (d(), !l(Dpe)) return s("property missing ':'");
      var v = l(Ape), m = p({
        type: Npe,
        property: WL(g[0].replace(HL, ac)),
        value: v ? WL(v[0].replace(HL, ac)) : ac
      });
      return l(Ipe), m;
    }
  }
  function f() {
    var p = [];
    c(p);
    for (var g; g = h(); )
      g !== !1 && (p.push(g), c(p));
    return p;
  }
  return u(), f();
};
function WL(e) {
  return e ? e.replace(Ope, ac) : ac;
}
var Vpe = T0 && T0.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(q3, "__esModule", { value: !0 });
var Bpe = Vpe(kpe);
function $pe(e, t) {
  var r = null;
  if (!e || typeof e != "string")
    return r;
  var n = (0, Bpe.default)(e), i = typeof t == "function";
  return n.forEach(function(o) {
    if (o.type === "declaration") {
      var a = o.property, s = o.value;
      i ? t(a, s, o) : s && (r = r || {}, r[a] = s);
    }
  }), r;
}
var jL = q3.default = $pe;
const Hpe = jL.default || jL, X3 = Z3("end"), SM = Z3("start");
function Z3(e) {
  return t;
  function t(r) {
    const n = r && r.position && r.position[e] || {};
    if (typeof n.line == "number" && n.line > 0 && typeof n.column == "number" && n.column > 0)
      return {
        line: n.line,
        column: n.column,
        offset: typeof n.offset == "number" && n.offset > -1 ? n.offset : void 0
      };
  }
}
function Gpe(e) {
  const t = SM(e), r = X3(e);
  if (t && r)
    return { start: t, end: r };
}
function Qp(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? UL(e.position) : "start" in e || "end" in e ? UL(e) : "line" in e || "column" in e ? QR(e) : "";
}
function QR(e) {
  return KL(e && e.line) + ":" + KL(e && e.column);
}
function UL(e) {
  return QR(e && e.start) + "-" + QR(e && e.end);
}
function KL(e) {
  return e && typeof e == "number" ? e : 1;
}
class pi extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, r, n) {
    super(), typeof r == "string" && (n = r, r = void 0);
    let i = "", o = {}, a = !1;
    if (r && ("line" in r && "column" in r ? o = { place: r } : "start" in r && "end" in r ? o = { place: r } : "type" in r ? o = {
      ancestors: [r],
      place: r.position
    } : o = { ...r }), typeof t == "string" ? i = t : !o.cause && t && (a = !0, i = t.message, o.cause = t), !o.ruleId && !o.source && typeof n == "string") {
      const l = n.indexOf(":");
      l === -1 ? o.ruleId = n : (o.source = n.slice(0, l), o.ruleId = n.slice(l + 1));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const l = o.ancestors[o.ancestors.length - 1];
      l && (o.place = l.position);
    }
    const s = o.place && "start" in o.place ? o.place.start : o.place;
    this.ancestors = o.ancestors || void 0, this.cause = o.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = s ? s.line : void 0, this.name = Qp(o.place) || "1:1", this.place = o.place || void 0, this.reason = this.message, this.ruleId = o.ruleId || void 0, this.source = o.source || void 0, this.stack = a && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
pi.prototype.file = "";
pi.prototype.name = "";
pi.prototype.reason = "";
pi.prototype.message = "";
pi.prototype.stack = "";
pi.prototype.column = void 0;
pi.prototype.line = void 0;
pi.prototype.ancestors = void 0;
pi.prototype.cause = void 0;
pi.prototype.fatal = void 0;
pi.prototype.place = void 0;
pi.prototype.ruleId = void 0;
pi.prototype.source = void 0;
const wM = {}.hasOwnProperty, zpe = /* @__PURE__ */ new Map(), Wpe = /[A-Z]/g, jpe = /-([a-z])/g, Upe = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), Kpe = /* @__PURE__ */ new Set(["td", "th"]), Q3 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function Ype(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const r = t.filePath || void 0;
  let n;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    n = rge(r, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    n = tge(r, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: n,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: r,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? CM : Rpe,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, o = J3(i, e, void 0);
  return o && typeof o != "string" ? o : i.create(
    e,
    i.Fragment,
    { children: o || void 0 },
    void 0
  );
}
function J3(e, t, r) {
  if (t.type === "element")
    return qpe(e, t, r);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return Xpe(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return Qpe(e, t, r);
  if (t.type === "mdxjsEsm")
    return Zpe(e, t);
  if (t.type === "root")
    return Jpe(e, t, r);
  if (t.type === "text")
    return ege(e, t);
}
function qpe(e, t, r) {
  const n = e.schema;
  let i = n;
  t.tagName.toLowerCase() === "svg" && n.space === "html" && (i = CM, e.schema = i), e.ancestors.push(t);
  const o = t6(e, t.tagName, !1), a = nge(e, t);
  let s = xM(e, t);
  return Upe.has(t.tagName) && (s = s.filter(function(l) {
    return typeof l == "string" ? !ppe(l) : !0;
  })), e6(e, a, o, t), bM(a, s), e.ancestors.pop(), e.schema = n, e.create(t, o, a, r);
}
function Xpe(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const n = t.data.estree.body[0];
    return n.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(n.expression);
  }
  Fg(e, t.position);
}
function Zpe(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Fg(e, t.position);
}
function Qpe(e, t, r) {
  const n = e.schema;
  let i = n;
  t.name === "svg" && n.space === "html" && (i = CM, e.schema = i), e.ancestors.push(t);
  const o = t.name === null ? e.Fragment : t6(e, t.name, !0), a = ige(e, t), s = xM(e, t);
  return e6(e, a, o, t), bM(a, s), e.ancestors.pop(), e.schema = n, e.create(t, o, a, r);
}
function Jpe(e, t, r) {
  const n = {};
  return bM(n, xM(e, t)), e.create(t, e.Fragment, n, r);
}
function ege(e, t) {
  return t.value;
}
function e6(e, t, r, n) {
  typeof r != "string" && r !== e.Fragment && e.passNode && (t.node = n);
}
function bM(e, t) {
  if (t.length > 0) {
    const r = t.length > 1 ? t : t[0];
    r && (e.children = r);
  }
}
function tge(e, t, r) {
  return n;
  function n(i, o, a, s) {
    const u = Array.isArray(a.children) ? r : t;
    return s ? u(o, a, s) : u(o, a);
  }
}
function rge(e, t) {
  return r;
  function r(n, i, o, a) {
    const s = Array.isArray(o.children), l = SM(n);
    return t(
      i,
      o,
      a,
      s,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function nge(e, t) {
  const r = {};
  let n, i;
  for (i in t.properties)
    if (i !== "children" && wM.call(t.properties, i)) {
      const o = oge(e, i, t.properties[i]);
      if (o) {
        const [a, s] = o;
        e.tableCellAlignToStyle && a === "align" && typeof s == "string" && Kpe.has(t.tagName) ? n = s : r[a] = s;
      }
    }
  if (n) {
    const o = (
      /** @type {Style} */
      r.style || (r.style = {})
    );
    o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = n;
  }
  return r;
}
function ige(e, t) {
  const r = {};
  for (const n of t.attributes)
    if (n.type === "mdxJsxExpressionAttribute")
      if (n.data && n.data.estree && e.evaluater) {
        const o = n.data.estree.body[0];
        o.type;
        const a = o.expression;
        a.type;
        const s = a.properties[0];
        s.type, Object.assign(
          r,
          e.evaluater.evaluateExpression(s.argument)
        );
      } else
        Fg(e, t.position);
    else {
      const i = n.name;
      let o;
      if (n.value && typeof n.value == "object")
        if (n.value.data && n.value.data.estree && e.evaluater) {
          const s = n.value.data.estree.body[0];
          s.type, o = e.evaluater.evaluateExpression(s.expression);
        } else
          Fg(e, t.position);
      else
        o = n.value === null ? !0 : n.value;
      r[i] = /** @type {Props[keyof Props]} */
      o;
    }
  return r;
}
function xM(e, t) {
  const r = [];
  let n = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : zpe;
  for (; ++n < t.children.length; ) {
    const o = t.children[n];
    let a;
    if (e.passKeys) {
      const l = o.type === "element" ? o.tagName : o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement" ? o.name : void 0;
      if (l) {
        const u = i.get(l) || 0;
        a = l + "-" + u, i.set(l, u + 1);
      }
    }
    const s = J3(e, o, a);
    s !== void 0 && r.push(s);
  }
  return r;
}
function oge(e, t, r) {
  const n = wpe(e.schema, t);
  if (!(r == null || typeof r == "number" && Number.isNaN(r))) {
    if (Array.isArray(r) && (r = n.commaSeparated ? upe(r) : _pe(r)), n.property === "style") {
      let i = typeof r == "object" ? r : age(e, String(r));
      return e.stylePropertyNameCase === "css" && (i = sge(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && n.space ? Epe[n.property] || n.property : n.attribute,
      r
    ];
  }
}
function age(e, t) {
  const r = {};
  try {
    Hpe(t, n);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const o = (
        /** @type {Error} */
        i
      ), a = new pi("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: o,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw a.file = e.filePath || void 0, a.url = Q3 + "#cannot-parse-style-attribute", a;
    }
  }
  return r;
  function n(i, o) {
    let a = i;
    a.slice(0, 2) !== "--" && (a.slice(0, 4) === "-ms-" && (a = "ms-" + a.slice(4)), a = a.replace(jpe, uge)), r[a] = o;
  }
}
function t6(e, t, r) {
  let n;
  if (!r)
    n = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let o = -1, a;
    for (; ++o < i.length; ) {
      const s = kL(i[o]) ? { type: "Identifier", name: i[o] } : { type: "Literal", value: i[o] };
      a = a ? {
        type: "MemberExpression",
        object: a,
        property: s,
        computed: !!(o && s.type === "Literal"),
        optional: !1
      } : s;
    }
    n = a;
  } else
    n = kL(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (n.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      n.value
    );
    return wM.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(n);
  Fg(e);
}
function Fg(e, t) {
  const r = new pi(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw r.file = e.filePath || void 0, r.url = Q3 + "#cannot-handle-mdx-estrees-without-createevaluater", r;
}
function sge(e) {
  const t = {};
  let r;
  for (r in e)
    wM.call(e, r) && (t[lge(r)] = e[r]);
  return t;
}
function lge(e) {
  let t = e.replace(Wpe, cge);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function uge(e, t) {
  return t.toUpperCase();
}
function cge(e) {
  return "-" + e.toLowerCase();
}
const Lb = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, dge = {};
function hge(e, t) {
  const r = dge, n = typeof r.includeImageAlt == "boolean" ? r.includeImageAlt : !0, i = typeof r.includeHtml == "boolean" ? r.includeHtml : !0;
  return r6(e, n, i);
}
function r6(e, t, r) {
  if (fge(e)) {
    if ("value" in e)
      return e.type === "html" && !r ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return YL(e.children, t, r);
  }
  return Array.isArray(e) ? YL(e, t, r) : "";
}
function YL(e, t, r) {
  const n = [];
  let i = -1;
  for (; ++i < e.length; )
    n[i] = r6(e[i], t, r);
  return n.join("");
}
function fge(e) {
  return !!(e && typeof e == "object");
}
const qL = document.createElement("i");
function EM(e) {
  const t = "&" + e + ";";
  qL.innerHTML = t;
  const r = qL.textContent;
  return r.charCodeAt(r.length - 1) === 59 && e !== "semi" || r === t ? !1 : r;
}
function Xs(e, t, r, n) {
  const i = e.length;
  let o = 0, a;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, r = r > 0 ? r : 0, n.length < 1e4)
    a = Array.from(n), a.unshift(t, r), e.splice(...a);
  else
    for (r && e.splice(t, r); o < n.length; )
      a = n.slice(o, o + 1e4), a.unshift(t, 0), e.splice(...a), o += 1e4, t += 1e4;
}
function $o(e, t) {
  return e.length > 0 ? (Xs(e, e.length, 0, t), e) : t;
}
const XL = {}.hasOwnProperty;
function pge(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    gge(t, e[r]);
  return t;
}
function gge(e, t) {
  let r;
  for (r in t) {
    const i = (XL.call(e, r) ? e[r] : void 0) || (e[r] = {}), o = t[r];
    let a;
    if (o)
      for (a in o) {
        XL.call(i, a) || (i[a] = []);
        const s = o[a];
        vge(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(s) ? s : s ? [s] : []
        );
      }
  }
}
function vge(e, t) {
  let r = -1;
  const n = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : n).push(t[r]);
  Xs(e, 0, 0, n);
}
function n6(e, t) {
  const r = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    r < 9 || r === 11 || r > 13 && r < 32 || // Control character (DEL) of C0, and C1 controls.
    r > 126 && r < 160 || // Lone high surrogates and low surrogates.
    r > 55295 && r < 57344 || // Noncharacters.
    r > 64975 && r < 65008 || /* eslint-disable no-bitwise */
    (r & 65535) === 65535 || (r & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    r > 1114111 ? "" : String.fromCodePoint(r)
  );
}
function Eh(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Ja = mu(/[A-Za-z]/), go = mu(/[\dA-Za-z]/), mge = mu(/[#-'*+\--9=?A-Z^-~]/);
function JR(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const e_ = mu(/\d/), yge = mu(/[\dA-Fa-f]/), Cge = mu(/[!-/:-@[-`{-~]/);
function Wt(e) {
  return e !== null && e < -2;
}
function Xi(e) {
  return e !== null && (e < 0 || e === 32);
}
function Dr(e) {
  return e === -2 || e === -1 || e === 32;
}
const Sge = mu(new RegExp("\\p{P}|\\p{S}", "u")), wge = mu(/\s/);
function mu(e) {
  return t;
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r));
  }
}
function hf(e) {
  const t = [];
  let r = -1, n = 0, i = 0;
  for (; ++r < e.length; ) {
    const o = e.charCodeAt(r);
    let a = "";
    if (o === 37 && go(e.charCodeAt(r + 1)) && go(e.charCodeAt(r + 2)))
      i = 2;
    else if (o < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (a = String.fromCharCode(o));
    else if (o > 55295 && o < 57344) {
      const s = e.charCodeAt(r + 1);
      o < 56320 && s > 56319 && s < 57344 ? (a = String.fromCharCode(o, s), i = 1) : a = "";
    } else
      a = String.fromCharCode(o);
    a && (t.push(e.slice(n, r), encodeURIComponent(a)), n = r + i + 1, a = ""), i && (r += i, i = 0);
  }
  return t.join("") + e.slice(n);
}
function Qr(e, t, r, n) {
  const i = n ? n - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return a;
  function a(l) {
    return Dr(l) ? (e.enter(r), s(l)) : t(l);
  }
  function s(l) {
    return Dr(l) && o++ < i ? (e.consume(l), s) : (e.exit(r), t(l));
  }
}
const bge = {
  tokenize: xge
};
function xge(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    n,
    i
  );
  let r;
  return t;
  function n(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Qr(e, t, "linePrefix");
  }
  function i(s) {
    return e.enter("paragraph"), o(s);
  }
  function o(s) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: r
    });
    return r && (r.next = l), r = l, a(s);
  }
  function a(s) {
    if (s === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
      return;
    }
    return Wt(s) ? (e.consume(s), e.exit("chunkText"), o) : (e.consume(s), a);
  }
}
const Ege = {
  tokenize: Rge
}, ZL = {
  tokenize: _ge
};
function Rge(e) {
  const t = this, r = [];
  let n = 0, i, o, a;
  return s;
  function s(C) {
    if (n < r.length) {
      const S = r[n];
      return t.containerState = S[1], e.attempt(
        S[0].continuation,
        l,
        u
      )(C);
    }
    return u(C);
  }
  function l(C) {
    if (n++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && y();
      const S = t.events.length;
      let b = S, w;
      for (; b--; )
        if (t.events[b][0] === "exit" && t.events[b][1].type === "chunkFlow") {
          w = t.events[b][1].end;
          break;
        }
      m(n);
      let x = S;
      for (; x < t.events.length; )
        t.events[x][1].end = Object.assign({}, w), x++;
      return Xs(
        t.events,
        b + 1,
        0,
        t.events.slice(S)
      ), t.events.length = x, u(C);
    }
    return s(C);
  }
  function u(C) {
    if (n === r.length) {
      if (!i)
        return h(C);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return p(C);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      ZL,
      c,
      d
    )(C);
  }
  function c(C) {
    return i && y(), m(n), h(C);
  }
  function d(C) {
    return t.parser.lazy[t.now().line] = n !== r.length, a = t.now().offset, p(C);
  }
  function h(C) {
    return t.containerState = {}, e.attempt(
      ZL,
      f,
      p
    )(C);
  }
  function f(C) {
    return n++, r.push([t.currentConstruct, t.containerState]), h(C);
  }
  function p(C) {
    if (C === null) {
      i && y(), m(0), e.consume(C);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: o,
      _tokenizer: i
    }), g(C);
  }
  function g(C) {
    if (C === null) {
      v(e.exit("chunkFlow"), !0), m(0), e.consume(C);
      return;
    }
    return Wt(C) ? (e.consume(C), v(e.exit("chunkFlow")), n = 0, t.interrupt = void 0, s) : (e.consume(C), g);
  }
  function v(C, S) {
    const b = t.sliceStream(C);
    if (S && b.push(null), C.previous = o, o && (o.next = C), o = C, i.defineSkip(C.start), i.write(b), t.parser.lazy[C.start.line]) {
      let w = i.events.length;
      for (; w--; )
        if (
          // The token starts before the line ending
          i.events[w][1].start.offset < a && // and either is not ended yet
          (!i.events[w][1].end || // or ends after it.
          i.events[w][1].end.offset > a)
        )
          return;
      const x = t.events.length;
      let R = x, _, T;
      for (; R--; )
        if (t.events[R][0] === "exit" && t.events[R][1].type === "chunkFlow") {
          if (_) {
            T = t.events[R][1].end;
            break;
          }
          _ = !0;
        }
      for (m(n), w = x; w < t.events.length; )
        t.events[w][1].end = Object.assign({}, T), w++;
      Xs(
        t.events,
        R + 1,
        0,
        t.events.slice(x)
      ), t.events.length = w;
    }
  }
  function m(C) {
    let S = r.length;
    for (; S-- > C; ) {
      const b = r[S];
      t.containerState = b[1], b[0].exit.call(t, e);
    }
    r.length = C;
  }
  function y() {
    i.write([null]), o = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function _ge(e, t, r) {
  return Qr(
    e,
    e.attempt(this.parser.constructs.document, t, r),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function QL(e) {
  if (e === null || Xi(e) || wge(e))
    return 1;
  if (Sge(e))
    return 2;
}
function RM(e, t, r) {
  const n = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i].resolveAll;
    o && !n.includes(o) && (t = o(t, r), n.push(o));
  }
  return t;
}
const t_ = {
  name: "attention",
  tokenize: Pge,
  resolveAll: Tge
};
function Tge(e, t) {
  let r = -1, n, i, o, a, s, l, u, c;
  for (; ++r < e.length; )
    if (e[r][0] === "enter" && e[r][1].type === "attentionSequence" && e[r][1]._close) {
      for (n = r; n--; )
        if (e[n][0] === "exit" && e[n][1].type === "attentionSequence" && e[n][1]._open && // If the markers are the same:
        t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[r][1]).charCodeAt(0)) {
          if ((e[n][1]._close || e[r][1]._open) && (e[r][1].end.offset - e[r][1].start.offset) % 3 && !((e[n][1].end.offset - e[n][1].start.offset + e[r][1].end.offset - e[r][1].start.offset) % 3))
            continue;
          l = e[n][1].end.offset - e[n][1].start.offset > 1 && e[r][1].end.offset - e[r][1].start.offset > 1 ? 2 : 1;
          const d = Object.assign({}, e[n][1].end), h = Object.assign({}, e[r][1].start);
          JL(d, -l), JL(h, l), a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: Object.assign({}, e[n][1].end)
          }, s = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[r][1].start),
            end: h
          }, o = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[n][1].end),
            end: Object.assign({}, e[r][1].start)
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, a.start),
            end: Object.assign({}, s.end)
          }, e[n][1].end = Object.assign({}, a.start), e[r][1].start = Object.assign({}, s.end), u = [], e[n][1].end.offset - e[n][1].start.offset && (u = $o(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])), u = $o(u, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["enter", o, t]]), u = $o(u, RM(t.parser.constructs.insideSpan.null, e.slice(n + 1, r), t)), u = $o(u, [["exit", o, t], ["enter", s, t], ["exit", s, t], ["exit", i, t]]), e[r][1].end.offset - e[r][1].start.offset ? (c = 2, u = $o(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])) : c = 0, Xs(e, n - 1, r - n + 3, u), r = n + u.length - c - 2;
          break;
        }
    }
  for (r = -1; ++r < e.length; )
    e[r][1].type === "attentionSequence" && (e[r][1].type = "data");
  return e;
}
function Pge(e, t) {
  const r = this.parser.constructs.attentionMarkers.null, n = this.previous, i = QL(n);
  let o;
  return a;
  function a(l) {
    return o = l, e.enter("attentionSequence"), s(l);
  }
  function s(l) {
    if (l === o)
      return e.consume(l), s;
    const u = e.exit("attentionSequence"), c = QL(l), d = !c || c === 2 && i || r.includes(l), h = !i || i === 2 && c || r.includes(n);
    return u._open = !!(o === 42 ? d : d && (i || !h)), u._close = !!(o === 42 ? h : h && (c || !d)), t(l);
  }
}
function JL(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const Mge = {
  name: "autolink",
  tokenize: Dge
};
function Dge(e, t, r) {
  let n = 0;
  return i;
  function i(f) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), o;
  }
  function o(f) {
    return Ja(f) ? (e.consume(f), a) : f === 64 ? r(f) : u(f);
  }
  function a(f) {
    return f === 43 || f === 45 || f === 46 || go(f) ? (n = 1, s(f)) : u(f);
  }
  function s(f) {
    return f === 58 ? (e.consume(f), n = 0, l) : (f === 43 || f === 45 || f === 46 || go(f)) && n++ < 32 ? (e.consume(f), s) : (n = 0, u(f));
  }
  function l(f) {
    return f === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : f === null || f === 32 || f === 60 || JR(f) ? r(f) : (e.consume(f), l);
  }
  function u(f) {
    return f === 64 ? (e.consume(f), c) : mge(f) ? (e.consume(f), u) : r(f);
  }
  function c(f) {
    return go(f) ? d(f) : r(f);
  }
  function d(f) {
    return f === 46 ? (e.consume(f), n = 0, c) : f === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : h(f);
  }
  function h(f) {
    if ((f === 45 || go(f)) && n++ < 63) {
      const p = f === 45 ? h : d;
      return e.consume(f), p;
    }
    return r(f);
  }
}
const VS = {
  tokenize: Age,
  partial: !0
};
function Age(e, t, r) {
  return n;
  function n(o) {
    return Dr(o) ? Qr(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || Wt(o) ? t(o) : r(o);
  }
}
const i6 = {
  name: "blockQuote",
  tokenize: Ige,
  continuation: {
    tokenize: Oge
  },
  exit: Lge
};
function Ige(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    if (a === 62) {
      const s = n.containerState;
      return s.open || (e.enter("blockQuote", {
        _container: !0
      }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(a), e.exit("blockQuoteMarker"), o;
    }
    return r(a);
  }
  function o(a) {
    return Dr(a) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(a), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(a));
  }
}
function Oge(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return Dr(a) ? Qr(e, o, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : o(a);
  }
  function o(a) {
    return e.attempt(i6, t, r)(a);
  }
}
function Lge(e) {
  e.exit("blockQuote");
}
const o6 = {
  name: "characterEscape",
  tokenize: Fge
};
function Fge(e, t, r) {
  return n;
  function n(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return Cge(o) ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : r(o);
  }
}
const a6 = {
  name: "characterReference",
  tokenize: Nge
};
function Nge(e, t, r) {
  const n = this;
  let i = 0, o, a;
  return s;
  function s(d) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), l;
  }
  function l(d) {
    return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), o = 31, a = go, c(d));
  }
  function u(d) {
    return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), o = 6, a = yge, c) : (e.enter("characterReferenceValue"), o = 7, a = e_, c(d));
  }
  function c(d) {
    if (d === 59 && i) {
      const h = e.exit("characterReferenceValue");
      return a === go && !EM(n.sliceSerialize(h)) ? r(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return a(d) && i++ < o ? (e.consume(d), c) : r(d);
  }
}
const eF = {
  tokenize: Vge,
  partial: !0
}, tF = {
  name: "codeFenced",
  tokenize: kge,
  concrete: !0
};
function kge(e, t, r) {
  const n = this, i = {
    tokenize: b,
    partial: !0
  };
  let o = 0, a = 0, s;
  return l;
  function l(w) {
    return u(w);
  }
  function u(w) {
    const x = n.events[n.events.length - 1];
    return o = x && x[1].type === "linePrefix" ? x[2].sliceSerialize(x[1], !0).length : 0, s = w, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c(w);
  }
  function c(w) {
    return w === s ? (a++, e.consume(w), c) : a < 3 ? r(w) : (e.exit("codeFencedFenceSequence"), Dr(w) ? Qr(e, d, "whitespace")(w) : d(w));
  }
  function d(w) {
    return w === null || Wt(w) ? (e.exit("codeFencedFence"), n.interrupt ? t(w) : e.check(eF, g, S)(w)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), h(w));
  }
  function h(w) {
    return w === null || Wt(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(w)) : Dr(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Qr(e, f, "whitespace")(w)) : w === 96 && w === s ? r(w) : (e.consume(w), h);
  }
  function f(w) {
    return w === null || Wt(w) ? d(w) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), p(w));
  }
  function p(w) {
    return w === null || Wt(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(w)) : w === 96 && w === s ? r(w) : (e.consume(w), p);
  }
  function g(w) {
    return e.attempt(i, S, v)(w);
  }
  function v(w) {
    return e.enter("lineEnding"), e.consume(w), e.exit("lineEnding"), m;
  }
  function m(w) {
    return o > 0 && Dr(w) ? Qr(e, y, "linePrefix", o + 1)(w) : y(w);
  }
  function y(w) {
    return w === null || Wt(w) ? e.check(eF, g, S)(w) : (e.enter("codeFlowValue"), C(w));
  }
  function C(w) {
    return w === null || Wt(w) ? (e.exit("codeFlowValue"), y(w)) : (e.consume(w), C);
  }
  function S(w) {
    return e.exit("codeFenced"), t(w);
  }
  function b(w, x, R) {
    let _ = 0;
    return T;
    function T(F) {
      return w.enter("lineEnding"), w.consume(F), w.exit("lineEnding"), P;
    }
    function P(F) {
      return w.enter("codeFencedFence"), Dr(F) ? Qr(w, D, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(F) : D(F);
    }
    function D(F) {
      return F === s ? (w.enter("codeFencedFenceSequence"), O(F)) : R(F);
    }
    function O(F) {
      return F === s ? (_++, w.consume(F), O) : _ >= a ? (w.exit("codeFencedFenceSequence"), Dr(F) ? Qr(w, A, "whitespace")(F) : A(F)) : R(F);
    }
    function A(F) {
      return F === null || Wt(F) ? (w.exit("codeFencedFence"), x(F)) : R(F);
    }
  }
}
function Vge(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return a === null ? r(a) : (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o);
  }
  function o(a) {
    return n.parser.lazy[n.now().line] ? r(a) : t(a);
  }
}
const Fb = {
  name: "codeIndented",
  tokenize: $ge
}, Bge = {
  tokenize: Hge,
  partial: !0
};
function $ge(e, t, r) {
  const n = this;
  return i;
  function i(u) {
    return e.enter("codeIndented"), Qr(e, o, "linePrefix", 5)(u);
  }
  function o(u) {
    const c = n.events[n.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? a(u) : r(u);
  }
  function a(u) {
    return u === null ? l(u) : Wt(u) ? e.attempt(Bge, a, l)(u) : (e.enter("codeFlowValue"), s(u));
  }
  function s(u) {
    return u === null || Wt(u) ? (e.exit("codeFlowValue"), a(u)) : (e.consume(u), s);
  }
  function l(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function Hge(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return n.parser.lazy[n.now().line] ? r(a) : Wt(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i) : Qr(e, o, "linePrefix", 5)(a);
  }
  function o(a) {
    const s = n.events[n.events.length - 1];
    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : Wt(a) ? i(a) : r(a);
  }
}
const Gge = {
  name: "codeText",
  tokenize: jge,
  resolve: zge,
  previous: Wge
};
function zge(e) {
  let t = e.length - 4, r = 3, n, i;
  if ((e[r][1].type === "lineEnding" || e[r][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (n = r; ++n < t; )
      if (e[n][1].type === "codeTextData") {
        e[r][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", r += 2, t -= 2;
        break;
      }
  }
  for (n = r - 1, t++; ++n <= t; )
    i === void 0 ? n !== t && e[n][1].type !== "lineEnding" && (i = n) : (n === t || e[n][1].type === "lineEnding") && (e[i][1].type = "codeTextData", n !== i + 2 && (e[i][1].end = e[n - 1][1].end, e.splice(i + 2, n - i - 2), t -= n - i - 2, n = i + 2), i = void 0);
  return e;
}
function Wge(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function jge(e, t, r) {
  let n = 0, i, o;
  return a;
  function a(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), s(d);
  }
  function s(d) {
    return d === 96 ? (e.consume(d), n++, s) : (e.exit("codeTextSequence"), l(d));
  }
  function l(d) {
    return d === null ? r(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), l) : d === 96 ? (o = e.enter("codeTextSequence"), i = 0, c(d)) : Wt(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), l) : (e.enter("codeTextData"), u(d));
  }
  function u(d) {
    return d === null || d === 32 || d === 96 || Wt(d) ? (e.exit("codeTextData"), l(d)) : (e.consume(d), u);
  }
  function c(d) {
    return d === 96 ? (e.consume(d), i++, c) : i === n ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (o.type = "codeTextData", u(d));
  }
}
class Uge {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, r) {
    const n = r ?? Number.POSITIVE_INFINITY;
    return n < this.left.length ? this.left.slice(t, n) : t > this.left.length ? this.right.slice(this.right.length - n + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - n + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, r, n) {
    const i = r || 0;
    this.setCursor(Math.trunc(t));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return n && Kf(this.left, n), o.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Kf(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Kf(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const r = this.left.splice(t, Number.POSITIVE_INFINITY);
        Kf(this.right, r.reverse());
      } else {
        const r = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Kf(this.left, r.reverse());
      }
  }
}
function Kf(e, t) {
  let r = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; r < t.length; )
      e.push(...t.slice(r, r + 1e4)), r += 1e4;
}
function s6(e) {
  const t = {};
  let r = -1, n, i, o, a, s, l, u;
  const c = new Uge(e);
  for (; ++r < c.length; ) {
    for (; r in t; )
      r = t[r];
    if (n = c.get(r), r && n[1].type === "chunkFlow" && c.get(r - 1)[1].type === "listItemPrefix" && (l = n[1]._tokenizer.events, o = 0, o < l.length && l[o][1].type === "lineEndingBlank" && (o += 2), o < l.length && l[o][1].type === "content"))
      for (; ++o < l.length && l[o][1].type !== "content"; )
        l[o][1].type === "chunkText" && (l[o][1]._isInFirstContentOfListItem = !0, o++);
    if (n[0] === "enter")
      n[1].contentType && (Object.assign(t, Kge(c, r)), r = t[r], u = !0);
    else if (n[1]._container) {
      for (o = r, i = void 0; o-- && (a = c.get(o), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank"); )
        a[0] === "enter" && (i && (c.get(i)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = o);
      i && (n[1].end = Object.assign({}, c.get(i)[1].start), s = c.slice(i, r), s.unshift(n), c.splice(i, r - i + 1, s));
    }
  }
  return Xs(e, 0, Number.POSITIVE_INFINITY, c.slice(0)), !u;
}
function Kge(e, t) {
  const r = e.get(t)[1], n = e.get(t)[2];
  let i = t - 1;
  const o = [], a = r._tokenizer || n.parser[r.contentType](r.start), s = a.events, l = [], u = {};
  let c, d, h = -1, f = r, p = 0, g = 0;
  const v = [g];
  for (; f; ) {
    for (; e.get(++i)[1] !== f; )
      ;
    o.push(i), f._tokenizer || (c = n.sliceStream(f), f.next || c.push(null), d && a.defineSkip(f.start), f._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(c), f._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), d = f, f = f.next;
  }
  for (f = r; ++h < s.length; )
    // Find a void token that includes a break.
    s[h][0] === "exit" && s[h - 1][0] === "enter" && s[h][1].type === s[h - 1][1].type && s[h][1].start.line !== s[h][1].end.line && (g = h + 1, v.push(g), f._tokenizer = void 0, f.previous = void 0, f = f.next);
  for (a.events = [], f ? (f._tokenizer = void 0, f.previous = void 0) : v.pop(), h = v.length; h--; ) {
    const m = s.slice(v[h], v[h + 1]), y = o.pop();
    l.push([y, y + m.length - 1]), e.splice(y, 2, m);
  }
  for (l.reverse(), h = -1; ++h < l.length; )
    u[p + l[h][0]] = p + l[h][1], p += l[h][1] - l[h][0] - 1;
  return u;
}
const Yge = {
  tokenize: Zge,
  resolve: Xge
}, qge = {
  tokenize: Qge,
  partial: !0
};
function Xge(e) {
  return s6(e), e;
}
function Zge(e, t) {
  let r;
  return n;
  function n(s) {
    return e.enter("content"), r = e.enter("chunkContent", {
      contentType: "content"
    }), i(s);
  }
  function i(s) {
    return s === null ? o(s) : Wt(s) ? e.check(qge, a, o)(s) : (e.consume(s), i);
  }
  function o(s) {
    return e.exit("chunkContent"), e.exit("content"), t(s);
  }
  function a(s) {
    return e.consume(s), e.exit("chunkContent"), r.next = e.enter("chunkContent", {
      contentType: "content",
      previous: r
    }), r = r.next, i;
  }
}
function Qge(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), Qr(e, o, "linePrefix");
  }
  function o(a) {
    if (a === null || Wt(a))
      return r(a);
    const s = n.events[n.events.length - 1];
    return !n.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : e.interrupt(n.parser.constructs.flow, r, t)(a);
  }
}
function l6(e, t, r, n, i, o, a, s, l) {
  const u = l || Number.POSITIVE_INFINITY;
  let c = 0;
  return d;
  function d(m) {
    return m === 60 ? (e.enter(n), e.enter(i), e.enter(o), e.consume(m), e.exit(o), h) : m === null || m === 32 || m === 41 || JR(m) ? r(m) : (e.enter(n), e.enter(a), e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), g(m));
  }
  function h(m) {
    return m === 62 ? (e.enter(o), e.consume(m), e.exit(o), e.exit(i), e.exit(n), t) : (e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), f(m));
  }
  function f(m) {
    return m === 62 ? (e.exit("chunkString"), e.exit(s), h(m)) : m === null || m === 60 || Wt(m) ? r(m) : (e.consume(m), m === 92 ? p : f);
  }
  function p(m) {
    return m === 60 || m === 62 || m === 92 ? (e.consume(m), f) : f(m);
  }
  function g(m) {
    return !c && (m === null || m === 41 || Xi(m)) ? (e.exit("chunkString"), e.exit(s), e.exit(a), e.exit(n), t(m)) : c < u && m === 40 ? (e.consume(m), c++, g) : m === 41 ? (e.consume(m), c--, g) : m === null || m === 32 || m === 40 || JR(m) ? r(m) : (e.consume(m), m === 92 ? v : g);
  }
  function v(m) {
    return m === 40 || m === 41 || m === 92 ? (e.consume(m), g) : g(m);
  }
}
function u6(e, t, r, n, i, o) {
  const a = this;
  let s = 0, l;
  return u;
  function u(f) {
    return e.enter(n), e.enter(i), e.consume(f), e.exit(i), e.enter(o), c;
  }
  function c(f) {
    return s > 999 || f === null || f === 91 || f === 93 && !l || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    f === 94 && !s && "_hiddenFootnoteSupport" in a.parser.constructs ? r(f) : f === 93 ? (e.exit(o), e.enter(i), e.consume(f), e.exit(i), e.exit(n), t) : Wt(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), c) : (e.enter("chunkString", {
      contentType: "string"
    }), d(f));
  }
  function d(f) {
    return f === null || f === 91 || f === 93 || Wt(f) || s++ > 999 ? (e.exit("chunkString"), c(f)) : (e.consume(f), l || (l = !Dr(f)), f === 92 ? h : d);
  }
  function h(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), s++, d) : d(f);
  }
}
function c6(e, t, r, n, i, o) {
  let a;
  return s;
  function s(h) {
    return h === 34 || h === 39 || h === 40 ? (e.enter(n), e.enter(i), e.consume(h), e.exit(i), a = h === 40 ? 41 : h, l) : r(h);
  }
  function l(h) {
    return h === a ? (e.enter(i), e.consume(h), e.exit(i), e.exit(n), t) : (e.enter(o), u(h));
  }
  function u(h) {
    return h === a ? (e.exit(o), l(a)) : h === null ? r(h) : Wt(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), Qr(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), c(h));
  }
  function c(h) {
    return h === a || h === null || Wt(h) ? (e.exit("chunkString"), u(h)) : (e.consume(h), h === 92 ? d : c);
  }
  function d(h) {
    return h === a || h === 92 ? (e.consume(h), c) : c(h);
  }
}
function Jp(e, t) {
  let r;
  return n;
  function n(i) {
    return Wt(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), r = !0, n) : Dr(i) ? Qr(
      e,
      n,
      r ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
const Jge = {
  name: "definition",
  tokenize: tve
}, eve = {
  tokenize: rve,
  partial: !0
};
function tve(e, t, r) {
  const n = this;
  let i;
  return o;
  function o(f) {
    return e.enter("definition"), a(f);
  }
  function a(f) {
    return u6.call(
      n,
      e,
      s,
      // Note: we dont need to reset the way `markdown-rs` does.
      r,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(f);
  }
  function s(f) {
    return i = Eh(n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1)), f === 58 ? (e.enter("definitionMarker"), e.consume(f), e.exit("definitionMarker"), l) : r(f);
  }
  function l(f) {
    return Xi(f) ? Jp(e, u)(f) : u(f);
  }
  function u(f) {
    return l6(
      e,
      c,
      // Note: we dont need to reset the way `markdown-rs` does.
      r,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(f);
  }
  function c(f) {
    return e.attempt(eve, d, d)(f);
  }
  function d(f) {
    return Dr(f) ? Qr(e, h, "whitespace")(f) : h(f);
  }
  function h(f) {
    return f === null || Wt(f) ? (e.exit("definition"), n.parser.defined.push(i), t(f)) : r(f);
  }
}
function rve(e, t, r) {
  return n;
  function n(s) {
    return Xi(s) ? Jp(e, i)(s) : r(s);
  }
  function i(s) {
    return c6(e, o, r, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s);
  }
  function o(s) {
    return Dr(s) ? Qr(e, a, "whitespace")(s) : a(s);
  }
  function a(s) {
    return s === null || Wt(s) ? t(s) : r(s);
  }
}
const nve = {
  name: "hardBreakEscape",
  tokenize: ive
};
function ive(e, t, r) {
  return n;
  function n(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return Wt(o) ? (e.exit("hardBreakEscape"), t(o)) : r(o);
  }
}
const ove = {
  name: "headingAtx",
  tokenize: sve,
  resolve: ave
};
function ave(e, t) {
  let r = e.length - 2, n = 3, i, o;
  return e[n][1].type === "whitespace" && (n += 2), r - 2 > n && e[r][1].type === "whitespace" && (r -= 2), e[r][1].type === "atxHeadingSequence" && (n === r - 1 || r - 4 > n && e[r - 2][1].type === "whitespace") && (r -= n + 1 === r ? 2 : 4), r > n && (i = {
    type: "atxHeadingText",
    start: e[n][1].start,
    end: e[r][1].end
  }, o = {
    type: "chunkText",
    start: e[n][1].start,
    end: e[r][1].end,
    contentType: "text"
  }, Xs(e, n, r - n + 1, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]])), e;
}
function sve(e, t, r) {
  let n = 0;
  return i;
  function i(c) {
    return e.enter("atxHeading"), o(c);
  }
  function o(c) {
    return e.enter("atxHeadingSequence"), a(c);
  }
  function a(c) {
    return c === 35 && n++ < 6 ? (e.consume(c), a) : c === null || Xi(c) ? (e.exit("atxHeadingSequence"), s(c)) : r(c);
  }
  function s(c) {
    return c === 35 ? (e.enter("atxHeadingSequence"), l(c)) : c === null || Wt(c) ? (e.exit("atxHeading"), t(c)) : Dr(c) ? Qr(e, s, "whitespace")(c) : (e.enter("atxHeadingText"), u(c));
  }
  function l(c) {
    return c === 35 ? (e.consume(c), l) : (e.exit("atxHeadingSequence"), s(c));
  }
  function u(c) {
    return c === null || c === 35 || Xi(c) ? (e.exit("atxHeadingText"), s(c)) : (e.consume(c), u);
  }
}
const lve = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], rF = ["pre", "script", "style", "textarea"], uve = {
  name: "htmlFlow",
  tokenize: fve,
  resolveTo: hve,
  concrete: !0
}, cve = {
  tokenize: gve,
  partial: !0
}, dve = {
  tokenize: pve,
  partial: !0
};
function hve(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function fve(e, t, r) {
  const n = this;
  let i, o, a, s, l;
  return u;
  function u(k) {
    return c(k);
  }
  function c(k) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(k), d;
  }
  function d(k) {
    return k === 33 ? (e.consume(k), h) : k === 47 ? (e.consume(k), o = !0, g) : k === 63 ? (e.consume(k), i = 3, n.interrupt ? t : M) : Ja(k) ? (e.consume(k), a = String.fromCharCode(k), v) : r(k);
  }
  function h(k) {
    return k === 45 ? (e.consume(k), i = 2, f) : k === 91 ? (e.consume(k), i = 5, s = 0, p) : Ja(k) ? (e.consume(k), i = 4, n.interrupt ? t : M) : r(k);
  }
  function f(k) {
    return k === 45 ? (e.consume(k), n.interrupt ? t : M) : r(k);
  }
  function p(k) {
    const z = "CDATA[";
    return k === z.charCodeAt(s++) ? (e.consume(k), s === z.length ? n.interrupt ? t : D : p) : r(k);
  }
  function g(k) {
    return Ja(k) ? (e.consume(k), a = String.fromCharCode(k), v) : r(k);
  }
  function v(k) {
    if (k === null || k === 47 || k === 62 || Xi(k)) {
      const z = k === 47, j = a.toLowerCase();
      return !z && !o && rF.includes(j) ? (i = 1, n.interrupt ? t(k) : D(k)) : lve.includes(a.toLowerCase()) ? (i = 6, z ? (e.consume(k), m) : n.interrupt ? t(k) : D(k)) : (i = 7, n.interrupt && !n.parser.lazy[n.now().line] ? r(k) : o ? y(k) : C(k));
    }
    return k === 45 || go(k) ? (e.consume(k), a += String.fromCharCode(k), v) : r(k);
  }
  function m(k) {
    return k === 62 ? (e.consume(k), n.interrupt ? t : D) : r(k);
  }
  function y(k) {
    return Dr(k) ? (e.consume(k), y) : T(k);
  }
  function C(k) {
    return k === 47 ? (e.consume(k), T) : k === 58 || k === 95 || Ja(k) ? (e.consume(k), S) : Dr(k) ? (e.consume(k), C) : T(k);
  }
  function S(k) {
    return k === 45 || k === 46 || k === 58 || k === 95 || go(k) ? (e.consume(k), S) : b(k);
  }
  function b(k) {
    return k === 61 ? (e.consume(k), w) : Dr(k) ? (e.consume(k), b) : C(k);
  }
  function w(k) {
    return k === null || k === 60 || k === 61 || k === 62 || k === 96 ? r(k) : k === 34 || k === 39 ? (e.consume(k), l = k, x) : Dr(k) ? (e.consume(k), w) : R(k);
  }
  function x(k) {
    return k === l ? (e.consume(k), l = null, _) : k === null || Wt(k) ? r(k) : (e.consume(k), x);
  }
  function R(k) {
    return k === null || k === 34 || k === 39 || k === 47 || k === 60 || k === 61 || k === 62 || k === 96 || Xi(k) ? b(k) : (e.consume(k), R);
  }
  function _(k) {
    return k === 47 || k === 62 || Dr(k) ? C(k) : r(k);
  }
  function T(k) {
    return k === 62 ? (e.consume(k), P) : r(k);
  }
  function P(k) {
    return k === null || Wt(k) ? D(k) : Dr(k) ? (e.consume(k), P) : r(k);
  }
  function D(k) {
    return k === 45 && i === 2 ? (e.consume(k), L) : k === 60 && i === 1 ? (e.consume(k), N) : k === 62 && i === 4 ? (e.consume(k), V) : k === 63 && i === 3 ? (e.consume(k), M) : k === 93 && i === 5 ? (e.consume(k), B) : Wt(k) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(cve, G, O)(k)) : k === null || Wt(k) ? (e.exit("htmlFlowData"), O(k)) : (e.consume(k), D);
  }
  function O(k) {
    return e.check(dve, A, G)(k);
  }
  function A(k) {
    return e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), F;
  }
  function F(k) {
    return k === null || Wt(k) ? O(k) : (e.enter("htmlFlowData"), D(k));
  }
  function L(k) {
    return k === 45 ? (e.consume(k), M) : D(k);
  }
  function N(k) {
    return k === 47 ? (e.consume(k), a = "", I) : D(k);
  }
  function I(k) {
    if (k === 62) {
      const z = a.toLowerCase();
      return rF.includes(z) ? (e.consume(k), V) : D(k);
    }
    return Ja(k) && a.length < 8 ? (e.consume(k), a += String.fromCharCode(k), I) : D(k);
  }
  function B(k) {
    return k === 93 ? (e.consume(k), M) : D(k);
  }
  function M(k) {
    return k === 62 ? (e.consume(k), V) : k === 45 && i === 2 ? (e.consume(k), M) : D(k);
  }
  function V(k) {
    return k === null || Wt(k) ? (e.exit("htmlFlowData"), G(k)) : (e.consume(k), V);
  }
  function G(k) {
    return e.exit("htmlFlow"), t(k);
  }
}
function pve(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return Wt(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o) : r(a);
  }
  function o(a) {
    return n.parser.lazy[n.now().line] ? r(a) : t(a);
  }
}
function gve(e, t, r) {
  return n;
  function n(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(VS, t, r);
  }
}
const vve = {
  name: "htmlText",
  tokenize: mve
};
function mve(e, t, r) {
  const n = this;
  let i, o, a;
  return s;
  function s(M) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(M), l;
  }
  function l(M) {
    return M === 33 ? (e.consume(M), u) : M === 47 ? (e.consume(M), b) : M === 63 ? (e.consume(M), C) : Ja(M) ? (e.consume(M), R) : r(M);
  }
  function u(M) {
    return M === 45 ? (e.consume(M), c) : M === 91 ? (e.consume(M), o = 0, p) : Ja(M) ? (e.consume(M), y) : r(M);
  }
  function c(M) {
    return M === 45 ? (e.consume(M), f) : r(M);
  }
  function d(M) {
    return M === null ? r(M) : M === 45 ? (e.consume(M), h) : Wt(M) ? (a = d, N(M)) : (e.consume(M), d);
  }
  function h(M) {
    return M === 45 ? (e.consume(M), f) : d(M);
  }
  function f(M) {
    return M === 62 ? L(M) : M === 45 ? h(M) : d(M);
  }
  function p(M) {
    const V = "CDATA[";
    return M === V.charCodeAt(o++) ? (e.consume(M), o === V.length ? g : p) : r(M);
  }
  function g(M) {
    return M === null ? r(M) : M === 93 ? (e.consume(M), v) : Wt(M) ? (a = g, N(M)) : (e.consume(M), g);
  }
  function v(M) {
    return M === 93 ? (e.consume(M), m) : g(M);
  }
  function m(M) {
    return M === 62 ? L(M) : M === 93 ? (e.consume(M), m) : g(M);
  }
  function y(M) {
    return M === null || M === 62 ? L(M) : Wt(M) ? (a = y, N(M)) : (e.consume(M), y);
  }
  function C(M) {
    return M === null ? r(M) : M === 63 ? (e.consume(M), S) : Wt(M) ? (a = C, N(M)) : (e.consume(M), C);
  }
  function S(M) {
    return M === 62 ? L(M) : C(M);
  }
  function b(M) {
    return Ja(M) ? (e.consume(M), w) : r(M);
  }
  function w(M) {
    return M === 45 || go(M) ? (e.consume(M), w) : x(M);
  }
  function x(M) {
    return Wt(M) ? (a = x, N(M)) : Dr(M) ? (e.consume(M), x) : L(M);
  }
  function R(M) {
    return M === 45 || go(M) ? (e.consume(M), R) : M === 47 || M === 62 || Xi(M) ? _(M) : r(M);
  }
  function _(M) {
    return M === 47 ? (e.consume(M), L) : M === 58 || M === 95 || Ja(M) ? (e.consume(M), T) : Wt(M) ? (a = _, N(M)) : Dr(M) ? (e.consume(M), _) : L(M);
  }
  function T(M) {
    return M === 45 || M === 46 || M === 58 || M === 95 || go(M) ? (e.consume(M), T) : P(M);
  }
  function P(M) {
    return M === 61 ? (e.consume(M), D) : Wt(M) ? (a = P, N(M)) : Dr(M) ? (e.consume(M), P) : _(M);
  }
  function D(M) {
    return M === null || M === 60 || M === 61 || M === 62 || M === 96 ? r(M) : M === 34 || M === 39 ? (e.consume(M), i = M, O) : Wt(M) ? (a = D, N(M)) : Dr(M) ? (e.consume(M), D) : (e.consume(M), A);
  }
  function O(M) {
    return M === i ? (e.consume(M), i = void 0, F) : M === null ? r(M) : Wt(M) ? (a = O, N(M)) : (e.consume(M), O);
  }
  function A(M) {
    return M === null || M === 34 || M === 39 || M === 60 || M === 61 || M === 96 ? r(M) : M === 47 || M === 62 || Xi(M) ? _(M) : (e.consume(M), A);
  }
  function F(M) {
    return M === 47 || M === 62 || Xi(M) ? _(M) : r(M);
  }
  function L(M) {
    return M === 62 ? (e.consume(M), e.exit("htmlTextData"), e.exit("htmlText"), t) : r(M);
  }
  function N(M) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(M), e.exit("lineEnding"), I;
  }
  function I(M) {
    return Dr(M) ? Qr(e, B, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(M) : B(M);
  }
  function B(M) {
    return e.enter("htmlTextData"), a(M);
  }
}
const _M = {
  name: "labelEnd",
  tokenize: xve,
  resolveTo: bve,
  resolveAll: wve
}, yve = {
  tokenize: Eve
}, Cve = {
  tokenize: Rve
}, Sve = {
  tokenize: _ve
};
function wve(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const r = e[t][1];
    (r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") && (e.splice(t + 1, r.type === "labelImage" ? 4 : 2), r.type = "data", t++);
  }
  return e;
}
function bve(e, t) {
  let r = e.length, n = 0, i, o, a, s;
  for (; r--; )
    if (i = e[r][1], o) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[r][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (a) {
      if (e[r][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = r, i.type !== "labelLink")) {
        n = 2;
        break;
      }
    } else i.type === "labelEnd" && (a = r);
  const l = {
    type: e[o][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, u = {
    type: "label",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[a][1].end)
  }, c = {
    type: "labelText",
    start: Object.assign({}, e[o + n + 2][1].end),
    end: Object.assign({}, e[a - 2][1].start)
  };
  return s = [["enter", l, t], ["enter", u, t]], s = $o(s, e.slice(o + 1, o + n + 3)), s = $o(s, [["enter", c, t]]), s = $o(s, RM(t.parser.constructs.insideSpan.null, e.slice(o + n + 4, a - 3), t)), s = $o(s, [["exit", c, t], e[a - 2], e[a - 1], ["exit", u, t]]), s = $o(s, e.slice(a + 1)), s = $o(s, [["exit", l, t]]), Xs(e, o, e.length, s), e;
}
function xve(e, t, r) {
  const n = this;
  let i = n.events.length, o, a;
  for (; i--; )
    if ((n.events[i][1].type === "labelImage" || n.events[i][1].type === "labelLink") && !n.events[i][1]._balanced) {
      o = n.events[i][1];
      break;
    }
  return s;
  function s(h) {
    return o ? o._inactive ? d(h) : (a = n.parser.defined.includes(Eh(n.sliceSerialize({
      start: o.end,
      end: n.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(h), e.exit("labelMarker"), e.exit("labelEnd"), l) : r(h);
  }
  function l(h) {
    return h === 40 ? e.attempt(yve, c, a ? c : d)(h) : h === 91 ? e.attempt(Cve, c, a ? u : d)(h) : a ? c(h) : d(h);
  }
  function u(h) {
    return e.attempt(Sve, c, d)(h);
  }
  function c(h) {
    return t(h);
  }
  function d(h) {
    return o._balanced = !0, r(h);
  }
}
function Eve(e, t, r) {
  return n;
  function n(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), i;
  }
  function i(d) {
    return Xi(d) ? Jp(e, o)(d) : o(d);
  }
  function o(d) {
    return d === 41 ? c(d) : l6(e, a, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d);
  }
  function a(d) {
    return Xi(d) ? Jp(e, l)(d) : c(d);
  }
  function s(d) {
    return r(d);
  }
  function l(d) {
    return d === 34 || d === 39 || d === 40 ? c6(e, u, r, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : c(d);
  }
  function u(d) {
    return Xi(d) ? Jp(e, c)(d) : c(d);
  }
  function c(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : r(d);
  }
}
function Rve(e, t, r) {
  const n = this;
  return i;
  function i(s) {
    return u6.call(n, e, o, a, "reference", "referenceMarker", "referenceString")(s);
  }
  function o(s) {
    return n.parser.defined.includes(Eh(n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1))) ? t(s) : r(s);
  }
  function a(s) {
    return r(s);
  }
}
function _ve(e, t, r) {
  return n;
  function n(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t) : r(o);
  }
}
const Tve = {
  name: "labelStartImage",
  tokenize: Pve,
  resolveAll: _M.resolveAll
};
function Pve(e, t, r) {
  const n = this;
  return i;
  function i(s) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), o;
  }
  function o(s) {
    return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), a) : r(s);
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? r(s) : t(s);
  }
}
const Mve = {
  name: "labelStartLink",
  tokenize: Dve,
  resolveAll: _M.resolveAll
};
function Dve(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? r(a) : t(a);
  }
}
const Nb = {
  name: "lineEnding",
  tokenize: Ave
};
function Ave(e, t) {
  return r;
  function r(n) {
    return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), Qr(e, t, "linePrefix");
  }
}
const t0 = {
  name: "thematicBreak",
  tokenize: Ive
};
function Ive(e, t, r) {
  let n = 0, i;
  return o;
  function o(u) {
    return e.enter("thematicBreak"), a(u);
  }
  function a(u) {
    return i = u, s(u);
  }
  function s(u) {
    return u === i ? (e.enter("thematicBreakSequence"), l(u)) : n >= 3 && (u === null || Wt(u)) ? (e.exit("thematicBreak"), t(u)) : r(u);
  }
  function l(u) {
    return u === i ? (e.consume(u), n++, l) : (e.exit("thematicBreakSequence"), Dr(u) ? Qr(e, s, "whitespace")(u) : s(u));
  }
}
const Wi = {
  name: "list",
  tokenize: Fve,
  continuation: {
    tokenize: Nve
  },
  exit: Vve
}, Ove = {
  tokenize: Bve,
  partial: !0
}, Lve = {
  tokenize: kve,
  partial: !0
};
function Fve(e, t, r) {
  const n = this, i = n.events[n.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0;
  return s;
  function s(f) {
    const p = n.containerState.type || (f === 42 || f === 43 || f === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !n.containerState.marker || f === n.containerState.marker : e_(f)) {
      if (n.containerState.type || (n.containerState.type = p, e.enter(p, {
        _container: !0
      })), p === "listUnordered")
        return e.enter("listItemPrefix"), f === 42 || f === 45 ? e.check(t0, r, u)(f) : u(f);
      if (!n.interrupt || f === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(f);
    }
    return r(f);
  }
  function l(f) {
    return e_(f) && ++a < 10 ? (e.consume(f), l) : (!n.interrupt || a < 2) && (n.containerState.marker ? f === n.containerState.marker : f === 41 || f === 46) ? (e.exit("listItemValue"), u(f)) : r(f);
  }
  function u(f) {
    return e.enter("listItemMarker"), e.consume(f), e.exit("listItemMarker"), n.containerState.marker = n.containerState.marker || f, e.check(
      VS,
      // Cant be empty when interrupting.
      n.interrupt ? r : c,
      e.attempt(Ove, h, d)
    );
  }
  function c(f) {
    return n.containerState.initialBlankLine = !0, o++, h(f);
  }
  function d(f) {
    return Dr(f) ? (e.enter("listItemPrefixWhitespace"), e.consume(f), e.exit("listItemPrefixWhitespace"), h) : r(f);
  }
  function h(f) {
    return n.containerState.size = o + n.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(f);
  }
}
function Nve(e, t, r) {
  const n = this;
  return n.containerState._closeFlow = void 0, e.check(VS, i, o);
  function i(s) {
    return n.containerState.furtherBlankLines = n.containerState.furtherBlankLines || n.containerState.initialBlankLine, Qr(e, t, "listItemIndent", n.containerState.size + 1)(s);
  }
  function o(s) {
    return n.containerState.furtherBlankLines || !Dr(s) ? (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0, a(s)) : (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0, e.attempt(Lve, t, a)(s));
  }
  function a(s) {
    return n.containerState._closeFlow = !0, n.interrupt = void 0, Qr(e, e.attempt(Wi, t, r), "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s);
  }
}
function kve(e, t, r) {
  const n = this;
  return Qr(e, i, "listItemIndent", n.containerState.size + 1);
  function i(o) {
    const a = n.events[n.events.length - 1];
    return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === n.containerState.size ? t(o) : r(o);
  }
}
function Vve(e) {
  e.exit(this.containerState.type);
}
function Bve(e, t, r) {
  const n = this;
  return Qr(e, i, "listItemPrefixWhitespace", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(o) {
    const a = n.events[n.events.length - 1];
    return !Dr(o) && a && a[1].type === "listItemPrefixWhitespace" ? t(o) : r(o);
  }
}
const nF = {
  name: "setextUnderline",
  tokenize: Hve,
  resolveTo: $ve
};
function $ve(e, t) {
  let r = e.length, n, i, o;
  for (; r--; )
    if (e[r][0] === "enter") {
      if (e[r][1].type === "content") {
        n = r;
        break;
      }
      e[r][1].type === "paragraph" && (i = r);
    } else
      e[r][1].type === "content" && e.splice(r, 1), !o && e[r][1].type === "definition" && (o = r);
  const a = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", o ? (e.splice(i, 0, ["enter", a, t]), e.splice(o + 1, 0, ["exit", e[n][1], t]), e[n][1].end = Object.assign({}, e[o][1].end)) : e[n][1] = a, e.push(["exit", a, t]), e;
}
function Hve(e, t, r) {
  const n = this;
  let i;
  return o;
  function o(u) {
    let c = n.events.length, d;
    for (; c--; )
      if (n.events[c][1].type !== "lineEnding" && n.events[c][1].type !== "linePrefix" && n.events[c][1].type !== "content") {
        d = n.events[c][1].type === "paragraph";
        break;
      }
    return !n.parser.lazy[n.now().line] && (n.interrupt || d) ? (e.enter("setextHeadingLine"), i = u, a(u)) : r(u);
  }
  function a(u) {
    return e.enter("setextHeadingLineSequence"), s(u);
  }
  function s(u) {
    return u === i ? (e.consume(u), s) : (e.exit("setextHeadingLineSequence"), Dr(u) ? Qr(e, l, "lineSuffix")(u) : l(u));
  }
  function l(u) {
    return u === null || Wt(u) ? (e.exit("setextHeadingLine"), t(u)) : r(u);
  }
}
const Gve = {
  tokenize: zve
};
function zve(e) {
  const t = this, r = e.attempt(
    // Try to parse a blank line.
    VS,
    n,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      Qr(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(Yge, i)
        ),
        "linePrefix"
      )
    )
  );
  return r;
  function n(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), t.currentConstruct = void 0, r;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), t.currentConstruct = void 0, r;
  }
}
const Wve = {
  resolveAll: h6()
}, jve = d6("string"), Uve = d6("text");
function d6(e) {
  return {
    tokenize: t,
    resolveAll: h6(
      e === "text" ? Kve : void 0
    )
  };
  function t(r) {
    const n = this, i = this.parser.constructs[e], o = r.attempt(i, a, s);
    return a;
    function a(c) {
      return u(c) ? o(c) : s(c);
    }
    function s(c) {
      if (c === null) {
        r.consume(c);
        return;
      }
      return r.enter("data"), r.consume(c), l;
    }
    function l(c) {
      return u(c) ? (r.exit("data"), o(c)) : (r.consume(c), l);
    }
    function u(c) {
      if (c === null)
        return !0;
      const d = i[c];
      let h = -1;
      if (d)
        for (; ++h < d.length; ) {
          const f = d[h];
          if (!f.previous || f.previous.call(n, n.previous))
            return !0;
        }
      return !1;
    }
  }
}
function h6(e) {
  return t;
  function t(r, n) {
    let i = -1, o;
    for (; ++i <= r.length; )
      o === void 0 ? r[i] && r[i][1].type === "data" && (o = i, i++) : (!r[i] || r[i][1].type !== "data") && (i !== o + 2 && (r[o][1].end = r[i - 1][1].end, r.splice(o + 2, i - o - 2), i = o + 2), o = void 0);
    return e ? e(r, n) : r;
  }
}
function Kve(e, t) {
  let r = 0;
  for (; ++r <= e.length; )
    if ((r === e.length || e[r][1].type === "lineEnding") && e[r - 1][1].type === "data") {
      const n = e[r - 1][1], i = t.sliceStream(n);
      let o = i.length, a = -1, s = 0, l;
      for (; o--; ) {
        const u = i[o];
        if (typeof u == "string") {
          for (a = u.length; u.charCodeAt(a - 1) === 32; )
            s++, a--;
          if (a) break;
          a = -1;
        } else if (u === -2)
          l = !0, s++;
        else if (u !== -1) {
          o++;
          break;
        }
      }
      if (s) {
        const u = {
          type: r === e.length || l || s < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: n.end.line,
            column: n.end.column - s,
            offset: n.end.offset - s,
            _index: n.start._index + o,
            _bufferIndex: o ? a : n.start._bufferIndex + a
          },
          end: Object.assign({}, n.end)
        };
        n.end = Object.assign({}, u.start), n.start.offset === n.end.offset ? Object.assign(n, u) : (e.splice(
          r,
          0,
          ["enter", u, t],
          ["exit", u, t]
        ), r += 2);
      }
      r++;
    }
  return e;
}
function Yve(e, t, r) {
  let n = Object.assign(
    r ? Object.assign({}, r) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, o = [];
  let a = [], s = [];
  const l = {
    consume: y,
    enter: C,
    exit: S,
    attempt: x(b),
    check: x(w),
    interrupt: x(w, {
      interrupt: !0
    })
  }, u = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: f,
    sliceSerialize: h,
    now: p,
    defineSkip: g,
    write: d
  };
  let c = t.tokenize.call(u, l);
  return t.resolveAll && o.push(t), u;
  function d(P) {
    return a = $o(a, P), v(), a[a.length - 1] !== null ? [] : (R(t, 0), u.events = RM(o, u.events, u), u.events);
  }
  function h(P, D) {
    return Xve(f(P), D);
  }
  function f(P) {
    return qve(a, P);
  }
  function p() {
    const { line: P, column: D, offset: O, _index: A, _bufferIndex: F } = n;
    return {
      line: P,
      column: D,
      offset: O,
      _index: A,
      _bufferIndex: F
    };
  }
  function g(P) {
    i[P.line] = P.column, T();
  }
  function v() {
    let P;
    for (; n._index < a.length; ) {
      const D = a[n._index];
      if (typeof D == "string")
        for (P = n._index, n._bufferIndex < 0 && (n._bufferIndex = 0); n._index === P && n._bufferIndex < D.length; )
          m(D.charCodeAt(n._bufferIndex));
      else
        m(D);
    }
  }
  function m(P) {
    c = c(P);
  }
  function y(P) {
    Wt(P) ? (n.line++, n.column = 1, n.offset += P === -3 ? 2 : 1, T()) : P !== -1 && (n.column++, n.offset++), n._bufferIndex < 0 ? n._index++ : (n._bufferIndex++, n._bufferIndex === a[n._index].length && (n._bufferIndex = -1, n._index++)), u.previous = P;
  }
  function C(P, D) {
    const O = D || {};
    return O.type = P, O.start = p(), u.events.push(["enter", O, u]), s.push(O), O;
  }
  function S(P) {
    const D = s.pop();
    return D.end = p(), u.events.push(["exit", D, u]), D;
  }
  function b(P, D) {
    R(P, D.from);
  }
  function w(P, D) {
    D.restore();
  }
  function x(P, D) {
    return O;
    function O(A, F, L) {
      let N, I, B, M;
      return Array.isArray(A) ? G(A) : "tokenize" in A ? (
        // @ts-expect-error Looks like a construct.
        G([A])
      ) : V(A);
      function V(q) {
        return K;
        function K(Z) {
          const re = Z !== null && q[Z], X = Z !== null && q.null, Y = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(re) ? re : re ? [re] : [],
            ...Array.isArray(X) ? X : X ? [X] : []
          ];
          return G(Y)(Z);
        }
      }
      function G(q) {
        return N = q, I = 0, q.length === 0 ? L : k(q[I]);
      }
      function k(q) {
        return K;
        function K(Z) {
          return M = _(), B = q, q.partial || (u.currentConstruct = q), q.name && u.parser.constructs.disable.null.includes(q.name) ? j() : q.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            D ? Object.assign(Object.create(u), D) : u,
            l,
            z,
            j
          )(Z);
        }
      }
      function z(q) {
        return P(B, M), F;
      }
      function j(q) {
        return M.restore(), ++I < N.length ? k(N[I]) : L;
      }
    }
  }
  function R(P, D) {
    P.resolveAll && !o.includes(P) && o.push(P), P.resolve && Xs(
      u.events,
      D,
      u.events.length - D,
      P.resolve(u.events.slice(D), u)
    ), P.resolveTo && (u.events = P.resolveTo(u.events, u));
  }
  function _() {
    const P = p(), D = u.previous, O = u.currentConstruct, A = u.events.length, F = Array.from(s);
    return {
      restore: L,
      from: A
    };
    function L() {
      n = P, u.previous = D, u.currentConstruct = O, u.events.length = A, s = F, T();
    }
  }
  function T() {
    n.line in i && n.column < 2 && (n.column = i[n.line], n.offset += i[n.line] - 1);
  }
}
function qve(e, t) {
  const r = t.start._index, n = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex;
  let a;
  if (r === i)
    a = [e[r].slice(n, o)];
  else {
    if (a = e.slice(r, i), n > -1) {
      const s = a[0];
      typeof s == "string" ? a[0] = s.slice(n) : a.shift();
    }
    o > 0 && a.push(e[i].slice(0, o));
  }
  return a;
}
function Xve(e, t) {
  let r = -1;
  const n = [];
  let i;
  for (; ++r < e.length; ) {
    const o = e[r];
    let a;
    if (typeof o == "string")
      a = o;
    else
      switch (o) {
        case -5: {
          a = "\r";
          break;
        }
        case -4: {
          a = `
`;
          break;
        }
        case -3: {
          a = `\r
`;
          break;
        }
        case -2: {
          a = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i) continue;
          a = " ";
          break;
        }
        default:
          a = String.fromCharCode(o);
      }
    i = o === -2, n.push(a);
  }
  return n.join("");
}
const Zve = {
  42: Wi,
  43: Wi,
  45: Wi,
  48: Wi,
  49: Wi,
  50: Wi,
  51: Wi,
  52: Wi,
  53: Wi,
  54: Wi,
  55: Wi,
  56: Wi,
  57: Wi,
  62: i6
}, Qve = {
  91: Jge
}, Jve = {
  [-2]: Fb,
  [-1]: Fb,
  32: Fb
}, eme = {
  35: ove,
  42: t0,
  45: [nF, t0],
  60: uve,
  61: nF,
  95: t0,
  96: tF,
  126: tF
}, tme = {
  38: a6,
  92: o6
}, rme = {
  [-5]: Nb,
  [-4]: Nb,
  [-3]: Nb,
  33: Tve,
  38: a6,
  42: t_,
  60: [Mge, vve],
  91: Mve,
  92: [nve, o6],
  93: _M,
  95: t_,
  96: Gge
}, nme = {
  null: [t_, Wve]
}, ime = {
  null: [42, 95]
}, ome = {
  null: []
}, ame = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: ime,
  contentInitial: Qve,
  disable: ome,
  document: Zve,
  flow: eme,
  flowInitial: Jve,
  insideSpan: nme,
  string: tme,
  text: rme
}, Symbol.toStringTag, { value: "Module" }));
function sme(e) {
  const r = (
    /** @type {FullNormalizedExtension} */
    pge([ame, ...(e || {}).extensions || []])
  ), n = {
    defined: [],
    lazy: {},
    constructs: r,
    content: i(bge),
    document: i(Ege),
    flow: i(Gve),
    string: i(jve),
    text: i(Uve)
  };
  return n;
  function i(o) {
    return a;
    function a(s) {
      return Yve(n, o, s);
    }
  }
}
function lme(e) {
  for (; !s6(e); )
    ;
  return e;
}
const iF = /[\0\t\n\r]/g;
function ume() {
  let e = 1, t = "", r = !0, n;
  return i;
  function i(o, a, s) {
    const l = [];
    let u, c, d, h, f;
    for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(a || void 0).decode(o)), d = 0, t = "", r && (o.charCodeAt(0) === 65279 && d++, r = void 0); d < o.length; ) {
      if (iF.lastIndex = d, u = iF.exec(o), h = u && u.index !== void 0 ? u.index : o.length, f = o.charCodeAt(h), !u) {
        t = o.slice(d);
        break;
      }
      if (f === 10 && d === h && n)
        l.push(-3), n = void 0;
      else
        switch (n && (l.push(-5), n = void 0), d < h && (l.push(o.slice(d, h)), e += h - d), f) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (c = Math.ceil(e / 4) * 4, l.push(-2); e++ < c; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            n = !0, e = 1;
        }
      d = h + 1;
    }
    return s && (n && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const cme = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function dme(e) {
  return e.replace(cme, hme);
}
function hme(e, t, r) {
  if (t)
    return t;
  if (r.charCodeAt(0) === 35) {
    const i = r.charCodeAt(1), o = i === 120 || i === 88;
    return n6(r.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return EM(r) || e;
}
const f6 = {}.hasOwnProperty;
function fme(e, t, r) {
  return typeof t != "string" && (r = t, t = void 0), pme(r)(lme(sme(r).document().write(ume()(e, t, !0))));
}
function pme(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(ve),
      autolinkProtocol: _,
      autolinkEmail: _,
      atxHeading: o(ne),
      blockQuote: o(X),
      characterEscape: _,
      characterReference: _,
      codeFenced: o(Y),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: o(Y, a),
      codeText: o(U, a),
      codeTextData: _,
      data: _,
      codeFlowValue: _,
      definition: o(oe),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: o(W),
      hardBreakEscape: o(ce),
      hardBreakTrailing: o(ce),
      htmlFlow: o(we, a),
      htmlFlowData: _,
      htmlText: o(we, a),
      htmlTextData: _,
      image: o(Re),
      label: a,
      link: o(ve),
      listItem: o(_e),
      listItemValue: h,
      listOrdered: o(xe, d),
      listUnordered: o(xe),
      paragraph: o(Ve),
      reference: k,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: o(ne),
      strong: o(Fe),
      thematicBreak: o(Je)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: b,
      autolink: l(),
      autolinkEmail: re,
      autolinkProtocol: Z,
      blockQuote: l(),
      characterEscapeValue: T,
      characterReferenceMarkerHexadecimal: j,
      characterReferenceMarkerNumeric: j,
      characterReferenceValue: q,
      characterReference: K,
      codeFenced: l(v),
      codeFencedFence: g,
      codeFencedFenceInfo: f,
      codeFencedFenceMeta: p,
      codeFlowValue: T,
      codeIndented: l(m),
      codeText: l(F),
      codeTextData: T,
      data: T,
      definition: l(),
      definitionDestinationString: S,
      definitionLabelString: y,
      definitionTitleString: C,
      emphasis: l(),
      hardBreakEscape: l(D),
      hardBreakTrailing: l(D),
      htmlFlow: l(O),
      htmlFlowData: T,
      htmlText: l(A),
      htmlTextData: T,
      image: l(N),
      label: B,
      labelText: I,
      lineEnding: P,
      link: l(L),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: z,
      resourceDestinationString: M,
      resourceTitleString: V,
      resource: G,
      setextHeading: l(R),
      setextHeadingLineSequence: x,
      setextHeadingText: w,
      strong: l(),
      thematicBreak: l()
    }
  };
  p6(t, (e || {}).mdastExtensions || []);
  const r = {};
  return n;
  function n(J) {
    let he = {
      type: "root",
      children: []
    };
    const Le = {
      stack: [he],
      tokenStack: [],
      config: t,
      enter: s,
      exit: u,
      buffer: a,
      resume: c,
      data: r
    }, Pe = [];
    let Ie = -1;
    for (; ++Ie < J.length; )
      if (J[Ie][1].type === "listOrdered" || J[Ie][1].type === "listUnordered")
        if (J[Ie][0] === "enter")
          Pe.push(Ie);
        else {
          const Ce = Pe.pop();
          Ie = i(J, Ce, Ie);
        }
    for (Ie = -1; ++Ie < J.length; ) {
      const Ce = t[J[Ie][0]];
      f6.call(Ce, J[Ie][1].type) && Ce[J[Ie][1].type].call(Object.assign({
        sliceSerialize: J[Ie][2].sliceSerialize
      }, Le), J[Ie][1]);
    }
    if (Le.tokenStack.length > 0) {
      const Ce = Le.tokenStack[Le.tokenStack.length - 1];
      (Ce[1] || oF).call(Le, void 0, Ce[0]);
    }
    for (he.position = {
      start: gl(J.length > 0 ? J[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: gl(J.length > 0 ? J[J.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Ie = -1; ++Ie < t.transforms.length; )
      he = t.transforms[Ie](he) || he;
    return he;
  }
  function i(J, he, Le) {
    let Pe = he - 1, Ie = -1, Ce = !1, De, ze, st, Tt;
    for (; ++Pe <= Le; ) {
      const ot = J[Pe];
      switch (ot[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          ot[0] === "enter" ? Ie++ : Ie--, Tt = void 0;
          break;
        }
        case "lineEndingBlank": {
          ot[0] === "enter" && (De && !Tt && !Ie && !st && (st = Pe), Tt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Tt = void 0;
      }
      if (!Ie && ot[0] === "enter" && ot[1].type === "listItemPrefix" || Ie === -1 && ot[0] === "exit" && (ot[1].type === "listUnordered" || ot[1].type === "listOrdered")) {
        if (De) {
          let Xe = Pe;
          for (ze = void 0; Xe--; ) {
            const Oe = J[Xe];
            if (Oe[1].type === "lineEnding" || Oe[1].type === "lineEndingBlank") {
              if (Oe[0] === "exit") continue;
              ze && (J[ze][1].type = "lineEndingBlank", Ce = !0), Oe[1].type = "lineEnding", ze = Xe;
            } else if (!(Oe[1].type === "linePrefix" || Oe[1].type === "blockQuotePrefix" || Oe[1].type === "blockQuotePrefixWhitespace" || Oe[1].type === "blockQuoteMarker" || Oe[1].type === "listItemIndent")) break;
          }
          st && (!ze || st < ze) && (De._spread = !0), De.end = Object.assign({}, ze ? J[ze][1].start : ot[1].end), J.splice(ze || Pe, 0, ["exit", De, ot[2]]), Pe++, Le++;
        }
        if (ot[1].type === "listItemPrefix") {
          const Xe = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, ot[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          De = Xe, J.splice(Pe, 0, ["enter", Xe, ot[2]]), Pe++, Le++, st = void 0, Tt = !0;
        }
      }
    }
    return J[he][1]._spread = Ce, Le;
  }
  function o(J, he) {
    return Le;
    function Le(Pe) {
      s.call(this, J(Pe), Pe), he && he.call(this, Pe);
    }
  }
  function a() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function s(J, he, Le) {
    this.stack[this.stack.length - 1].children.push(J), this.stack.push(J), this.tokenStack.push([he, Le]), J.position = {
      start: gl(he.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(J) {
    return he;
    function he(Le) {
      J && J.call(this, Le), u.call(this, Le);
    }
  }
  function u(J, he) {
    const Le = this.stack.pop(), Pe = this.tokenStack.pop();
    if (Pe)
      Pe[0].type !== J.type && (he ? he.call(this, J, Pe[0]) : (Pe[1] || oF).call(this, J, Pe[0]));
    else throw new Error("Cannot close `" + J.type + "` (" + Qp({
      start: J.start,
      end: J.end
    }) + "): its not open");
    Le.position.end = gl(J.end);
  }
  function c() {
    return hge(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function h(J) {
    if (this.data.expectingFirstListItemValue) {
      const he = this.stack[this.stack.length - 2];
      he.start = Number.parseInt(this.sliceSerialize(J), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function f() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.lang = J;
  }
  function p() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.meta = J;
  }
  function g() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function v() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.value = J.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function m() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.value = J.replace(/(\r?\n|\r)$/g, "");
  }
  function y(J) {
    const he = this.resume(), Le = this.stack[this.stack.length - 1];
    Le.label = he, Le.identifier = Eh(this.sliceSerialize(J)).toLowerCase();
  }
  function C() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.title = J;
  }
  function S() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.url = J;
  }
  function b(J) {
    const he = this.stack[this.stack.length - 1];
    if (!he.depth) {
      const Le = this.sliceSerialize(J).length;
      he.depth = Le;
    }
  }
  function w() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function x(J) {
    const he = this.stack[this.stack.length - 1];
    he.depth = this.sliceSerialize(J).codePointAt(0) === 61 ? 1 : 2;
  }
  function R() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function _(J) {
    const Le = this.stack[this.stack.length - 1].children;
    let Pe = Le[Le.length - 1];
    (!Pe || Pe.type !== "text") && (Pe = Ne(), Pe.position = {
      start: gl(J.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, Le.push(Pe)), this.stack.push(Pe);
  }
  function T(J) {
    const he = this.stack.pop();
    he.value += this.sliceSerialize(J), he.position.end = gl(J.end);
  }
  function P(J) {
    const he = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Le = he.children[he.children.length - 1];
      Le.position.end = gl(J.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(he.type) && (_.call(this, J), T.call(this, J));
  }
  function D() {
    this.data.atHardBreak = !0;
  }
  function O() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.value = J;
  }
  function A() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.value = J;
  }
  function F() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.value = J;
  }
  function L() {
    const J = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const he = this.data.referenceType || "shortcut";
      J.type += "Reference", J.referenceType = he, delete J.url, delete J.title;
    } else
      delete J.identifier, delete J.label;
    this.data.referenceType = void 0;
  }
  function N() {
    const J = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const he = this.data.referenceType || "shortcut";
      J.type += "Reference", J.referenceType = he, delete J.url, delete J.title;
    } else
      delete J.identifier, delete J.label;
    this.data.referenceType = void 0;
  }
  function I(J) {
    const he = this.sliceSerialize(J), Le = this.stack[this.stack.length - 2];
    Le.label = dme(he), Le.identifier = Eh(he).toLowerCase();
  }
  function B() {
    const J = this.stack[this.stack.length - 1], he = this.resume(), Le = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Le.type === "link") {
      const Pe = J.children;
      Le.children = Pe;
    } else
      Le.alt = he;
  }
  function M() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.url = J;
  }
  function V() {
    const J = this.resume(), he = this.stack[this.stack.length - 1];
    he.title = J;
  }
  function G() {
    this.data.inReference = void 0;
  }
  function k() {
    this.data.referenceType = "collapsed";
  }
  function z(J) {
    const he = this.resume(), Le = this.stack[this.stack.length - 1];
    Le.label = he, Le.identifier = Eh(this.sliceSerialize(J)).toLowerCase(), this.data.referenceType = "full";
  }
  function j(J) {
    this.data.characterReferenceType = J.type;
  }
  function q(J) {
    const he = this.sliceSerialize(J), Le = this.data.characterReferenceType;
    let Pe;
    Le ? (Pe = n6(he, Le === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Pe = EM(he);
    const Ie = this.stack[this.stack.length - 1];
    Ie.value += Pe;
  }
  function K(J) {
    const he = this.stack.pop();
    he.position.end = gl(J.end);
  }
  function Z(J) {
    T.call(this, J);
    const he = this.stack[this.stack.length - 1];
    he.url = this.sliceSerialize(J);
  }
  function re(J) {
    T.call(this, J);
    const he = this.stack[this.stack.length - 1];
    he.url = "mailto:" + this.sliceSerialize(J);
  }
  function X() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Y() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function U() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function oe() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function W() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function ne() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function ce() {
    return {
      type: "break"
    };
  }
  function we() {
    return {
      type: "html",
      value: ""
    };
  }
  function Re() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function ve() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function xe(J) {
    return {
      type: "list",
      ordered: J.type === "listOrdered",
      start: null,
      spread: J._spread,
      children: []
    };
  }
  function _e(J) {
    return {
      type: "listItem",
      spread: J._spread,
      checked: null,
      children: []
    };
  }
  function Ve() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Fe() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ne() {
    return {
      type: "text",
      value: ""
    };
  }
  function Je() {
    return {
      type: "thematicBreak"
    };
  }
}
function gl(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function p6(e, t) {
  let r = -1;
  for (; ++r < t.length; ) {
    const n = t[r];
    Array.isArray(n) ? p6(e, n) : gme(e, n);
  }
}
function gme(e, t) {
  let r;
  for (r in t)
    if (f6.call(t, r))
      switch (r) {
        case "canContainEols": {
          const n = t[r];
          n && e[r].push(...n);
          break;
        }
        case "transforms": {
          const n = t[r];
          n && e[r].push(...n);
          break;
        }
        case "enter":
        case "exit": {
          const n = t[r];
          n && Object.assign(e[r], n);
          break;
        }
      }
}
function oF(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Qp({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Qp({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Qp({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function vme(e) {
  const t = this;
  t.parser = r;
  function r(n) {
    return fme(n, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function mme(e, t) {
  const r = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function yme(e, t) {
  const r = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, r), [e.applyData(t, r), { type: "text", value: `
` }];
}
function Cme(e, t) {
  const r = t.value ? t.value + `
` : "", n = {};
  t.lang && (n.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: n,
    children: [{ type: "text", value: r }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function Sme(e, t) {
  const r = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function wme(e, t) {
  const r = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function bme(e, t) {
  const r = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = String(t.identifier).toUpperCase(), i = hf(n.toLowerCase()), o = e.footnoteOrder.indexOf(n);
  let a, s = e.footnoteCounts.get(n);
  s === void 0 ? (s = 0, e.footnoteOrder.push(n), a = e.footnoteOrder.length) : a = o + 1, s += 1, e.footnoteCounts.set(n, s);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + r + "fn-" + i,
      id: r + "fnref-" + i + (s > 1 ? "-" + s : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(a) }]
  };
  e.patch(t, l);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function xme(e, t) {
  const r = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Eme(e, t) {
  if (e.options.allowDangerousHtml) {
    const r = { type: "raw", value: t.value };
    return e.patch(t, r), e.applyData(t, r);
  }
}
function g6(e, t) {
  const r = t.referenceType;
  let n = "]";
  if (r === "collapsed" ? n += "[]" : r === "full" && (n += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + n }];
  const i = e.all(t), o = i[0];
  o && o.type === "text" ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" });
  const a = i[i.length - 1];
  return a && a.type === "text" ? a.value += n : i.push({ type: "text", value: n }), i;
}
function Rme(e, t) {
  const r = String(t.identifier).toUpperCase(), n = e.definitionById.get(r);
  if (!n)
    return g6(e, t);
  const i = { src: hf(n.url || ""), alt: t.alt };
  n.title !== null && n.title !== void 0 && (i.title = n.title);
  const o = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function _me(e, t) {
  const r = { src: hf(t.url) };
  t.alt !== null && t.alt !== void 0 && (r.alt = t.alt), t.title !== null && t.title !== void 0 && (r.title = t.title);
  const n = { type: "element", tagName: "img", properties: r, children: [] };
  return e.patch(t, n), e.applyData(t, n);
}
function Tme(e, t) {
  const r = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, r);
  const n = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [r]
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Pme(e, t) {
  const r = String(t.identifier).toUpperCase(), n = e.definitionById.get(r);
  if (!n)
    return g6(e, t);
  const i = { href: hf(n.url || "") };
  n.title !== null && n.title !== void 0 && (i.title = n.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function Mme(e, t) {
  const r = { href: hf(t.url) };
  t.title !== null && t.title !== void 0 && (r.title = t.title);
  const n = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Dme(e, t, r) {
  const n = e.all(t), i = r ? Ame(r) : v6(t), o = {}, a = [];
  if (typeof t.checked == "boolean") {
    const c = n[0];
    let d;
    c && c.type === "element" && c.tagName === "p" ? d = c : (d = { type: "element", tagName: "p", properties: {}, children: [] }, n.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), o.className = ["task-list-item"];
  }
  let s = -1;
  for (; ++s < n.length; ) {
    const c = n[s];
    (i || s !== 0 || c.type !== "element" || c.tagName !== "p") && a.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? a.push(...c.children) : a.push(c);
  }
  const l = n[n.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && a.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: o, children: a };
  return e.patch(t, u), e.applyData(t, u);
}
function Ame(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const r = e.children;
    let n = -1;
    for (; !t && ++n < r.length; )
      t = v6(r[n]);
  }
  return t;
}
function v6(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function Ime(e, t) {
  const r = {}, n = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (r.start = t.start); ++i < n.length; ) {
    const a = n[i];
    if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
      r.className = ["contains-task-list"];
      break;
    }
  }
  const o = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: r,
    children: e.wrap(n, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function Ome(e, t) {
  const r = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Lme(e, t) {
  const r = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, r), e.applyData(t, r);
}
function Fme(e, t) {
  const r = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Nme(e, t) {
  const r = e.all(t), n = r.shift(), i = [];
  if (n) {
    const a = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([n], !0)
    };
    e.patch(t.children[0], a), i.push(a);
  }
  if (r.length > 0) {
    const a = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(r, !0)
    }, s = SM(t.children[1]), l = X3(t.children[t.children.length - 1]);
    s && l && (a.position = { start: s, end: l }), i.push(a);
  }
  const o = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function kme(e, t, r) {
  const n = r ? r.children : void 0, o = (n ? n.indexOf(t) : 1) === 0 ? "th" : "td", a = r && r.type === "table" ? r.align : void 0, s = a ? a.length : t.children.length;
  let l = -1;
  const u = [];
  for (; ++l < s; ) {
    const d = t.children[l], h = {}, f = a ? a[l] : void 0;
    f && (h.align = f);
    let p = { type: "element", tagName: o, properties: h, children: [] };
    d && (p.children = e.all(d), e.patch(d, p), p = e.applyData(d, p)), u.push(p);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, c), e.applyData(t, c);
}
function Vme(e, t) {
  const r = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
const aF = 9, sF = 32;
function Bme(e) {
  const t = String(e), r = /\r?\n|\r/g;
  let n = r.exec(t), i = 0;
  const o = [];
  for (; n; )
    o.push(
      lF(t.slice(i, n.index), i > 0, !0),
      n[0]
    ), i = n.index + n[0].length, n = r.exec(t);
  return o.push(lF(t.slice(i), i > 0, !1)), o.join("");
}
function lF(e, t, r) {
  let n = 0, i = e.length;
  if (t) {
    let o = e.codePointAt(n);
    for (; o === aF || o === sF; )
      n++, o = e.codePointAt(n);
  }
  if (r) {
    let o = e.codePointAt(i - 1);
    for (; o === aF || o === sF; )
      i--, o = e.codePointAt(i - 1);
  }
  return i > n ? e.slice(n, i) : "";
}
function $me(e, t) {
  const r = { type: "text", value: Bme(String(t.value)) };
  return e.patch(t, r), e.applyData(t, r);
}
function Hme(e, t) {
  const r = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, r), e.applyData(t, r);
}
const Gme = {
  blockquote: mme,
  break: yme,
  code: Cme,
  delete: Sme,
  emphasis: wme,
  footnoteReference: bme,
  heading: xme,
  html: Eme,
  imageReference: Rme,
  image: _me,
  inlineCode: Tme,
  linkReference: Pme,
  link: Mme,
  listItem: Dme,
  list: Ime,
  paragraph: Ome,
  // @ts-expect-error: root is different, but hard to type.
  root: Lme,
  strong: Fme,
  table: Nme,
  tableCell: Vme,
  tableRow: kme,
  text: $me,
  thematicBreak: Hme,
  toml: Pm,
  yaml: Pm,
  definition: Pm,
  footnoteDefinition: Pm
};
function Pm() {
}
const m6 = -1, BS = 0, K0 = 1, Y0 = 2, TM = 3, PM = 4, MM = 5, DM = 6, y6 = 7, C6 = 8, uF = typeof self == "object" ? self : globalThis, zme = (e, t) => {
  const r = (i, o) => (e.set(o, i), i), n = (i) => {
    if (e.has(i))
      return e.get(i);
    const [o, a] = t[i];
    switch (o) {
      case BS:
      case m6:
        return r(a, i);
      case K0: {
        const s = r([], i);
        for (const l of a)
          s.push(n(l));
        return s;
      }
      case Y0: {
        const s = r({}, i);
        for (const [l, u] of a)
          s[n(l)] = n(u);
        return s;
      }
      case TM:
        return r(new Date(a), i);
      case PM: {
        const { source: s, flags: l } = a;
        return r(new RegExp(s, l), i);
      }
      case MM: {
        const s = r(/* @__PURE__ */ new Map(), i);
        for (const [l, u] of a)
          s.set(n(l), n(u));
        return s;
      }
      case DM: {
        const s = r(/* @__PURE__ */ new Set(), i);
        for (const l of a)
          s.add(n(l));
        return s;
      }
      case y6: {
        const { name: s, message: l } = a;
        return r(new uF[s](l), i);
      }
      case C6:
        return r(BigInt(a), i);
      case "BigInt":
        return r(Object(BigInt(a)), i);
    }
    return r(new uF[o](a), i);
  };
  return n;
}, cF = (e) => zme(/* @__PURE__ */ new Map(), e)(0), Md = "", { toString: Wme } = {}, { keys: jme } = Object, Yf = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [BS, t];
  const r = Wme.call(e).slice(8, -1);
  switch (r) {
    case "Array":
      return [K0, Md];
    case "Object":
      return [Y0, Md];
    case "Date":
      return [TM, Md];
    case "RegExp":
      return [PM, Md];
    case "Map":
      return [MM, Md];
    case "Set":
      return [DM, Md];
  }
  return r.includes("Array") ? [K0, r] : r.includes("Error") ? [y6, r] : [Y0, r];
}, Mm = ([e, t]) => e === BS && (t === "function" || t === "symbol"), Ume = (e, t, r, n) => {
  const i = (a, s) => {
    const l = n.push(a) - 1;
    return r.set(s, l), l;
  }, o = (a) => {
    if (r.has(a))
      return r.get(a);
    let [s, l] = Yf(a);
    switch (s) {
      case BS: {
        let c = a;
        switch (l) {
          case "bigint":
            s = C6, c = a.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            c = null;
            break;
          case "undefined":
            return i([m6], a);
        }
        return i([s, c], a);
      }
      case K0: {
        if (l)
          return i([l, [...a]], a);
        const c = [], d = i([s, c], a);
        for (const h of a)
          c.push(o(h));
        return d;
      }
      case Y0: {
        if (l)
          switch (l) {
            case "BigInt":
              return i([l, a.toString()], a);
            case "Boolean":
            case "Number":
            case "String":
              return i([l, a.valueOf()], a);
          }
        if (t && "toJSON" in a)
          return o(a.toJSON());
        const c = [], d = i([s, c], a);
        for (const h of jme(a))
          (e || !Mm(Yf(a[h]))) && c.push([o(h), o(a[h])]);
        return d;
      }
      case TM:
        return i([s, a.toISOString()], a);
      case PM: {
        const { source: c, flags: d } = a;
        return i([s, { source: c, flags: d }], a);
      }
      case MM: {
        const c = [], d = i([s, c], a);
        for (const [h, f] of a)
          (e || !(Mm(Yf(h)) || Mm(Yf(f)))) && c.push([o(h), o(f)]);
        return d;
      }
      case DM: {
        const c = [], d = i([s, c], a);
        for (const h of a)
          (e || !Mm(Yf(h))) && c.push(o(h));
        return d;
      }
    }
    const { message: u } = a;
    return i([s, { name: l, message: u }], a);
  };
  return o;
}, dF = (e, { json: t, lossy: r } = {}) => {
  const n = [];
  return Ume(!(t || r), !!t, /* @__PURE__ */ new Map(), n)(e), n;
}, q0 = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? cF(dF(e, t)) : structuredClone(e)
) : (e, t) => cF(dF(e, t));
function Kme(e, t) {
  const r = [{ type: "text", value: "" }];
  return t > 1 && r.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), r;
}
function Yme(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function qme(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = e.options.footnoteBackContent || Kme, n = e.options.footnoteBackLabel || Yme, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", a = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, s = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!u)
      continue;
    const c = e.all(u), d = String(u.identifier).toUpperCase(), h = hf(d.toLowerCase());
    let f = 0;
    const p = [], g = e.footnoteCounts.get(d);
    for (; g !== void 0 && ++f <= g; ) {
      p.length > 0 && p.push({ type: "text", value: " " });
      let y = typeof r == "string" ? r : r(l, f);
      typeof y == "string" && (y = { type: "text", value: y }), p.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + h + (f > 1 ? "-" + f : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof n == "string" ? n : n(l, f),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(y) ? y : [y]
      });
    }
    const v = c[c.length - 1];
    if (v && v.type === "element" && v.tagName === "p") {
      const y = v.children[v.children.length - 1];
      y && y.type === "text" ? y.value += " " : v.children.push({ type: "text", value: " " }), v.children.push(...p);
    } else
      c.push(...p);
    const m = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + h },
      children: e.wrap(c, !0)
    };
    e.patch(u, m), s.push(m);
  }
  if (s.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: o,
          properties: {
            ...q0(a),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(s, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const S6 = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return Jme;
    if (typeof e == "function")
      return $S(e);
    if (typeof e == "object")
      return Array.isArray(e) ? Xme(e) : Zme(e);
    if (typeof e == "string")
      return Qme(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function Xme(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = S6(e[r]);
  return $S(n);
  function n(...i) {
    let o = -1;
    for (; ++o < t.length; )
      if (t[o].apply(this, i)) return !0;
    return !1;
  }
}
function Zme(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return $S(r);
  function r(n) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      n
    );
    let o;
    for (o in e)
      if (i[o] !== t[o]) return !1;
    return !0;
  }
}
function Qme(e) {
  return $S(t);
  function t(r) {
    return r && r.type === e;
  }
}
function $S(e) {
  return t;
  function t(r, n, i) {
    return !!(eye(r) && e.call(
      this,
      r,
      typeof n == "number" ? n : void 0,
      i || void 0
    ));
  }
}
function Jme() {
  return !0;
}
function eye(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const w6 = [], tye = !0, hF = !1, rye = "skip";
function nye(e, t, r, n) {
  let i;
  typeof t == "function" && typeof r != "function" ? (n = r, r = t) : i = t;
  const o = S6(i), a = n ? -1 : 1;
  s(e, void 0, [])();
  function s(l, u, c) {
    const d = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof d.type == "string") {
      const f = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(h, "name", {
        value: "node (" + (l.type + (f ? "<" + f + ">" : "")) + ")"
      });
    }
    return h;
    function h() {
      let f = w6, p, g, v;
      if ((!t || o(l, u, c[c.length - 1] || void 0)) && (f = iye(r(l, c)), f[0] === hF))
        return f;
      if ("children" in l && l.children) {
        const m = (
          /** @type {UnistParent} */
          l
        );
        if (m.children && f[0] !== rye)
          for (g = (n ? m.children.length : -1) + a, v = c.concat(m); g > -1 && g < m.children.length; ) {
            const y = m.children[g];
            if (p = s(y, g, v)(), p[0] === hF)
              return p;
            g = typeof p[1] == "number" ? p[1] : g + a;
          }
      }
      return f;
    }
  }
}
function iye(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [tye, e] : e == null ? w6 : [e];
}
function b6(e, t, r, n) {
  let i, o, a;
  typeof t == "function" && typeof r != "function" ? (o = void 0, a = t, i = r) : (o = t, a = r, i = n), nye(e, o, s, i);
  function s(l, u) {
    const c = u[u.length - 1], d = c ? c.children.indexOf(l) : void 0;
    return a(l, d, c);
  }
}
const r_ = {}.hasOwnProperty, oye = {};
function aye(e, t) {
  const r = t || oye, n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = { ...Gme, ...r.handlers }, s = {
    all: u,
    applyData: lye,
    definitionById: n,
    footnoteById: i,
    footnoteCounts: o,
    footnoteOrder: [],
    handlers: a,
    one: l,
    options: r,
    patch: sye,
    wrap: cye
  };
  return b6(e, function(c) {
    if (c.type === "definition" || c.type === "footnoteDefinition") {
      const d = c.type === "definition" ? n : i, h = String(c.identifier).toUpperCase();
      d.has(h) || d.set(h, c);
    }
  }), s;
  function l(c, d) {
    const h = c.type, f = s.handlers[h];
    if (r_.call(s.handlers, h) && f)
      return f(s, c, d);
    if (s.options.passThrough && s.options.passThrough.includes(h)) {
      if ("children" in c) {
        const { children: g, ...v } = c, m = q0(v);
        return m.children = s.all(c), m;
      }
      return q0(c);
    }
    return (s.options.unknownHandler || uye)(s, c, d);
  }
  function u(c) {
    const d = [];
    if ("children" in c) {
      const h = c.children;
      let f = -1;
      for (; ++f < h.length; ) {
        const p = s.one(h[f], c);
        if (p) {
          if (f && h[f - 1].type === "break" && (!Array.isArray(p) && p.type === "text" && (p.value = fF(p.value)), !Array.isArray(p) && p.type === "element")) {
            const g = p.children[0];
            g && g.type === "text" && (g.value = fF(g.value));
          }
          Array.isArray(p) ? d.push(...p) : d.push(p);
        }
      }
    }
    return d;
  }
}
function sye(e, t) {
  e.position && (t.position = Gpe(e));
}
function lye(e, t) {
  let r = t;
  if (e && e.data) {
    const n = e.data.hName, i = e.data.hChildren, o = e.data.hProperties;
    if (typeof n == "string")
      if (r.type === "element")
        r.tagName = n;
      else {
        const a = "children" in r ? r.children : [r];
        r = { type: "element", tagName: n, properties: {}, children: a };
      }
    r.type === "element" && o && Object.assign(r.properties, q0(o)), "children" in r && r.children && i !== null && i !== void 0 && (r.children = i);
  }
  return r;
}
function uye(e, t) {
  const r = t.data || {}, n = "value" in t && !(r_.call(r, "hProperties") || r_.call(r, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function cye(e, t) {
  const r = [];
  let n = -1;
  for (t && r.push({ type: "text", value: `
` }); ++n < e.length; )
    n && r.push({ type: "text", value: `
` }), r.push(e[n]);
  return t && e.length > 0 && r.push({ type: "text", value: `
` }), r;
}
function fF(e) {
  let t = 0, r = e.charCodeAt(t);
  for (; r === 9 || r === 32; )
    t++, r = e.charCodeAt(t);
  return e.slice(t);
}
function pF(e, t) {
  const r = aye(e, t), n = r.one(e, void 0), i = qme(r), o = Array.isArray(n) ? { type: "root", children: n } : n || { type: "root", children: [] };
  return i && o.children.push({ type: "text", value: `
` }, i), o;
}
function dye(e, t) {
  return e && "run" in e ? async function(r, n) {
    const i = (
      /** @type {HastRoot} */
      pF(r, { file: n, ...t })
    );
    await e.run(i, n);
  } : function(r, n) {
    return (
      /** @type {HastRoot} */
      pF(r, { file: n, ...t || e })
    );
  };
}
function gF(e) {
  if (e)
    throw e;
}
var r0 = Object.prototype.hasOwnProperty, x6 = Object.prototype.toString, vF = Object.defineProperty, mF = Object.getOwnPropertyDescriptor, yF = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : x6.call(t) === "[object Array]";
}, CF = function(t) {
  if (!t || x6.call(t) !== "[object Object]")
    return !1;
  var r = r0.call(t, "constructor"), n = t.constructor && t.constructor.prototype && r0.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !r && !n)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || r0.call(t, i);
}, SF = function(t, r) {
  vF && r.name === "__proto__" ? vF(t, r.name, {
    enumerable: !0,
    configurable: !0,
    value: r.newValue,
    writable: !0
  }) : t[r.name] = r.newValue;
}, wF = function(t, r) {
  if (r === "__proto__")
    if (r0.call(t, r)) {
      if (mF)
        return mF(t, r).value;
    } else return;
  return t[r];
}, hye = function e() {
  var t, r, n, i, o, a, s = arguments[0], l = 1, u = arguments.length, c = !1;
  for (typeof s == "boolean" && (c = s, s = arguments[1] || {}, l = 2), (s == null || typeof s != "object" && typeof s != "function") && (s = {}); l < u; ++l)
    if (t = arguments[l], t != null)
      for (r in t)
        n = wF(s, r), i = wF(t, r), s !== i && (c && i && (CF(i) || (o = yF(i))) ? (o ? (o = !1, a = n && yF(n) ? n : []) : a = n && CF(n) ? n : {}, SF(s, { name: r, newValue: e(c, a, i) })) : typeof i < "u" && SF(s, { name: r, newValue: i }));
  return s;
};
const kb = /* @__PURE__ */ of(hye);
function n_(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function fye() {
  const e = [], t = { run: r, use: n };
  return t;
  function r(...i) {
    let o = -1;
    const a = i.pop();
    if (typeof a != "function")
      throw new TypeError("Expected function as last argument, not " + a);
    s(null, ...i);
    function s(l, ...u) {
      const c = e[++o];
      let d = -1;
      if (l) {
        a(l);
        return;
      }
      for (; ++d < i.length; )
        (u[d] === null || u[d] === void 0) && (u[d] = i[d]);
      i = u, c ? pye(c, s)(...u) : a(null, ...u);
    }
  }
  function n(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function pye(e, t) {
  let r;
  return n;
  function n(...a) {
    const s = e.length > a.length;
    let l;
    s && a.push(i);
    try {
      l = e.apply(this, a);
    } catch (u) {
      const c = (
        /** @type {Error} */
        u
      );
      if (s && r)
        throw c;
      return i(c);
    }
    s || (l && l.then && typeof l.then == "function" ? l.then(o, i) : l instanceof Error ? i(l) : o(l));
  }
  function i(a, ...s) {
    r || (r = !0, t(a, ...s));
  }
  function o(a) {
    i(null, a);
  }
}
const Za = { basename: gye, dirname: vye, extname: mye, join: yye, sep: "/" };
function gye(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Mv(e);
  let r = 0, n = -1, i = e.length, o;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (o) {
          r = i + 1;
          break;
        }
      } else n < 0 && (o = !0, n = i + 1);
    return n < 0 ? "" : e.slice(r, n);
  }
  if (t === e)
    return "";
  let a = -1, s = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (o) {
        r = i + 1;
        break;
      }
    } else
      a < 0 && (o = !0, a = i + 1), s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (n = i) : (s = -1, n = a));
  return r === n ? n = a : n < 0 && (n = e.length), e.slice(r, n);
}
function vye(e) {
  if (Mv(e), e.length === 0)
    return ".";
  let t = -1, r = e.length, n;
  for (; --r; )
    if (e.codePointAt(r) === 47) {
      if (n) {
        t = r;
        break;
      }
    } else n || (n = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function mye(e) {
  Mv(e);
  let t = e.length, r = -1, n = 0, i = -1, o = 0, a;
  for (; t--; ) {
    const s = e.codePointAt(t);
    if (s === 47) {
      if (a) {
        n = t + 1;
        break;
      }
      continue;
    }
    r < 0 && (a = !0, r = t + 1), s === 46 ? i < 0 ? i = t : o !== 1 && (o = 1) : i > -1 && (o = -1);
  }
  return i < 0 || r < 0 || // We saw a non-dot character immediately before the dot.
  o === 0 || // The (right-most) trimmed path component is exactly `..`.
  o === 1 && i === r - 1 && i === n + 1 ? "" : e.slice(i, r);
}
function yye(...e) {
  let t = -1, r;
  for (; ++t < e.length; )
    Mv(e[t]), e[t] && (r = r === void 0 ? e[t] : r + "/" + e[t]);
  return r === void 0 ? "." : Cye(r);
}
function Cye(e) {
  Mv(e);
  const t = e.codePointAt(0) === 47;
  let r = Sye(e, !t);
  return r.length === 0 && !t && (r = "."), r.length > 0 && e.codePointAt(e.length - 1) === 47 && (r += "/"), t ? "/" + r : r;
}
function Sye(e, t) {
  let r = "", n = 0, i = -1, o = 0, a = -1, s, l;
  for (; ++a <= e.length; ) {
    if (a < e.length)
      s = e.codePointAt(a);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(i === a - 1 || o === 1)) if (i !== a - 1 && o === 2) {
        if (r.length < 2 || n !== 2 || r.codePointAt(r.length - 1) !== 46 || r.codePointAt(r.length - 2) !== 46) {
          if (r.length > 2) {
            if (l = r.lastIndexOf("/"), l !== r.length - 1) {
              l < 0 ? (r = "", n = 0) : (r = r.slice(0, l), n = r.length - 1 - r.lastIndexOf("/")), i = a, o = 0;
              continue;
            }
          } else if (r.length > 0) {
            r = "", n = 0, i = a, o = 0;
            continue;
          }
        }
        t && (r = r.length > 0 ? r + "/.." : "..", n = 2);
      } else
        r.length > 0 ? r += "/" + e.slice(i + 1, a) : r = e.slice(i + 1, a), n = a - i - 1;
      i = a, o = 0;
    } else s === 46 && o > -1 ? o++ : o = -1;
  }
  return r;
}
function Mv(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const wye = { cwd: bye };
function bye() {
  return "/";
}
function i_(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function xye(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!i_(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return Eye(e);
}
function Eye(e) {
  if (e.hostname !== "") {
    const n = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw n.code = "ERR_INVALID_FILE_URL_HOST", n;
  }
  const t = e.pathname;
  let r = -1;
  for (; ++r < t.length; )
    if (t.codePointAt(r) === 37 && t.codePointAt(r + 1) === 50) {
      const n = t.codePointAt(r + 2);
      if (n === 70 || n === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const Vb = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class E6 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let r;
    t ? i_(t) ? r = { path: t } : typeof t == "string" || Rye(t) ? r = { value: t } : r = t : r = {}, this.cwd = wye.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let n = -1;
    for (; ++n < Vb.length; ) {
      const o = Vb[n];
      o in r && r[o] !== void 0 && r[o] !== null && (this[o] = o === "history" ? [...r[o]] : r[o]);
    }
    let i;
    for (i in r)
      Vb.includes(i) || (this[i] = r[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Za.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    $b(t, "basename"), Bb(t, "basename"), this.path = Za.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Za.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    bF(this.basename, "dirname"), this.path = Za.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Za.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (Bb(t, "extname"), bF(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Za.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    i_(t) && (t = xye(t)), $b(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Za.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    $b(t, "stem"), Bb(t, "stem"), this.path = Za.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, r, n) {
    const i = this.message(t, r, n);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, r, n) {
    const i = this.message(t, r, n);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, r, n) {
    const i = new pi(
      // @ts-expect-error: the overloads are fine.
      t,
      r,
      n
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function Bb(e, t) {
  if (e && e.includes(Za.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Za.sep + "`"
    );
}
function $b(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function bF(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function Rye(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const _ye = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const n = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = n[e], o = function() {
      return i.apply(o, arguments);
    };
    return Object.setPrototypeOf(o, n), o;
  }
), Tye = {}.hasOwnProperty;
class AM extends _ye {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = fye();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new AM()
    );
    let r = -1;
    for (; ++r < this.attachers.length; ) {
      const n = this.attachers[r];
      t.use(...n);
    }
    return t.data(kb(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, r) {
    return typeof t == "string" ? arguments.length === 2 ? (zb("data", this.frozen), this.namespace[t] = r, this) : Tye.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (zb("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [r, ...n] = this.attachers[this.freezeIndex];
      if (n[0] === !1)
        continue;
      n[0] === !0 && (n[0] = void 0);
      const i = r.call(t, ...n);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const r = Dm(t), n = this.parser || this.Parser;
    return Hb("parse", n), n(String(r), r);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, r) {
    const n = this;
    return this.freeze(), Hb("process", this.parser || this.Parser), Gb("process", this.compiler || this.Compiler), r ? i(void 0, r) : new Promise(i);
    function i(o, a) {
      const s = Dm(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        n.parse(s)
      );
      n.run(l, s, function(c, d, h) {
        if (c || !d || !h)
          return u(c);
        const f = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), p = n.stringify(f, h);
        Dye(p) ? h.value = p : h.result = p, u(
          c,
          /** @type {VFileWithOutput<CompileResult>} */
          h
        );
      });
      function u(c, d) {
        c || !d ? a(c) : o ? o(d) : r(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let r = !1, n;
    return this.freeze(), Hb("processSync", this.parser || this.Parser), Gb("processSync", this.compiler || this.Compiler), this.process(t, i), EF("processSync", "process", r), n;
    function i(o, a) {
      r = !0, gF(o), n = a;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, r, n) {
    xF(t), this.freeze();
    const i = this.transformers;
    return !n && typeof r == "function" && (n = r, r = void 0), n ? o(void 0, n) : new Promise(o);
    function o(a, s) {
      const l = Dm(r);
      i.run(t, l, u);
      function u(c, d, h) {
        const f = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || t
        );
        c ? s(c) : a ? a(f) : n(void 0, f, h);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, r) {
    let n = !1, i;
    return this.run(t, r, o), EF("runSync", "run", n), i;
    function o(a, s) {
      gF(a), i = s, n = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, r) {
    this.freeze();
    const n = Dm(r), i = this.compiler || this.Compiler;
    return Gb("stringify", i), xF(t), i(t, n);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...r) {
    const n = this.attachers, i = this.namespace;
    if (zb("use", this.frozen), t != null) if (typeof t == "function")
      l(t, r);
    else if (typeof t == "object")
      Array.isArray(t) ? s(t) : a(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function o(u) {
      if (typeof u == "function")
        l(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [c, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          l(c, d);
        } else
          a(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function a(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      s(u.plugins), u.settings && (i.settings = kb(!0, i.settings, u.settings));
    }
    function s(u) {
      let c = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++c < u.length; ) {
          const d = u[c];
          o(d);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function l(u, c) {
      let d = -1, h = -1;
      for (; ++d < n.length; )
        if (n[d][0] === u) {
          h = d;
          break;
        }
      if (h === -1)
        n.push([u, ...c]);
      else if (c.length > 0) {
        let [f, ...p] = c;
        const g = n[h][1];
        n_(g) && n_(f) && (f = kb(!0, g, f)), n[h] = [u, f, ...p];
      }
    }
  }
}
const Pye = new AM().freeze();
function Hb(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function Gb(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function zb(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function xF(e) {
  if (!n_(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function EF(e, t, r) {
  if (!r)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function Dm(e) {
  return Mye(e) ? e : new E6(e);
}
function Mye(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function Dye(e) {
  return typeof e == "string" || Aye(e);
}
function Aye(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const Iye = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", RF = [], _F = { allowDangerousHtml: !0 }, Oye = /^(https?|ircs?|mailto|xmpp)$/i, Lye = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function HS(e) {
  const t = e.allowedElements, r = e.allowElement, n = e.children || "", i = e.className, o = e.components, a = e.disallowedElements, s = e.rehypePlugins || RF, l = e.remarkPlugins || RF, u = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ..._F } : _F, c = e.skipHtml, d = e.unwrapDisallowed, h = e.urlTransform || Fye, f = Pye().use(vme).use(l).use(dye, u).use(s), p = new E6();
  typeof n == "string" && (p.value = n);
  for (const y of Lye)
    Object.hasOwn(e, y.from) && ("" + y.from + (y.to ? "use `" + y.to + "` instead" : "remove it") + Iye + y.id, void 0);
  const g = f.parse(p);
  let v = f.runSync(g, p);
  return i && (v = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      v.type === "root" ? v.children : [v]
    )
  }), b6(v, m), Ype(v, {
    Fragment: ie.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: ie.jsx,
    jsxs: ie.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function m(y, C, S) {
    if (y.type === "raw" && S && typeof C == "number")
      return c ? S.children.splice(C, 1) : S.children[C] = { type: "text", value: y.value }, C;
    if (y.type === "element") {
      let b;
      for (b in Lb)
        if (Object.hasOwn(Lb, b) && Object.hasOwn(y.properties, b)) {
          const w = y.properties[b], x = Lb[b];
          (x === null || x.includes(y.tagName)) && (y.properties[b] = h(String(w || ""), b, y));
        }
    }
    if (y.type === "element") {
      let b = t ? !t.includes(y.tagName) : a ? a.includes(y.tagName) : !1;
      if (!b && r && typeof C == "number" && (b = !r(y, C, S)), b && S && typeof C == "number")
        return d && y.children ? S.children.splice(C, 1, ...y.children) : S.children.splice(C, 1), C;
    }
  }
}
function Fye(e) {
  const t = e.indexOf(":"), r = e.indexOf("?"), n = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    i > -1 && t > i || r > -1 && t > r || n > -1 && t > n || // It is a protocol, it should be allowed.
    Oye.test(e.slice(0, t)) ? e : ""
  );
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var o_ = function(e, t) {
  return o_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i]);
  }, o_(e, t);
};
function R6(e, t) {
  o_(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var a_ = function() {
  return a_ = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o]);
    }
    return t;
  }, a_.apply(this, arguments);
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var s_ = function(e, t) {
  return s_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i]);
  }, s_(e, t);
};
function le(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  s_(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var Nye = /* @__PURE__ */ function() {
  function e() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return e;
}(), kye = /* @__PURE__ */ function() {
  function e() {
    this.browser = new Nye(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return e;
}(), Zu = new kye();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (Zu.wxa = !0, Zu.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? Zu.worker = !0 : typeof navigator > "u" || navigator.userAgent.indexOf("Node.js") === 0 ? (Zu.node = !0, Zu.svgSupported = !0) : Vye(navigator.userAgent, Zu);
function Vye(e, t) {
  var r = t.browser, n = e.match(/Firefox\/([\d.]+)/), i = e.match(/MSIE\s([\d.]+)/) || e.match(/Trident\/.+?rv:(([\d.]+))/), o = e.match(/Edge?\/([\d.]+)/), a = /micromessenger/i.test(e);
  n && (r.firefox = !0, r.version = n[1]), i && (r.ie = !0, r.version = i[1]), o && (r.edge = !0, r.version = o[1], r.newEdge = +o[1].split(".")[0] > 18), a && (r.weChat = !0), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !r.ie && !r.edge, t.pointerEventsSupported = "onpointerdown" in window && (r.edge || r.ie && +r.version >= 11), t.domSupported = typeof document < "u";
  var s = document.documentElement.style;
  t.transform3dSupported = (r.ie && "transition" in s || r.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), t.transformSupported = t.transform3dSupported || r.ie && +r.version >= 9;
}
const nr = Zu;
var IM = 12, _6 = "sans-serif", tu = IM + "px " + _6, Bye = 20, $ye = 100, Hye = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function Gye(e) {
  var t = {};
  if (typeof JSON > "u")
    return t;
  for (var r = 0; r < e.length; r++) {
    var n = String.fromCharCode(r + 32), i = (e.charCodeAt(r) - Bye) / $ye;
    t[n] = i;
  }
  return t;
}
var zye = Gye(Hye), Ia = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ function() {
    var e, t;
    return function(r, n) {
      if (!e) {
        var i = Ia.createCanvas();
        e = i && i.getContext("2d");
      }
      if (e)
        return t !== n && (t = e.font = n || tu), e.measureText(r);
      r = r || "", n = n || tu;
      var o = /((?:\d+)?\.?\d*)px/.exec(n), a = o && +o[1] || IM, s = 0;
      if (n.indexOf("mono") >= 0)
        s = a * r.length;
      else
        for (var l = 0; l < r.length; l++) {
          var u = zye[r[l]];
          s += u == null ? a : u * a;
        }
      return { width: s };
    };
  }(),
  loadImage: function(e, t, r) {
    var n = new Image();
    return n.onload = t, n.onerror = r, n.src = e, n;
  }
};
function T6(e) {
  for (var t in Ia)
    e[t] && (Ia[t] = e[t]);
}
var P6 = Jo([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(e, t) {
  return e["[object " + t + "]"] = !0, e;
}, {}), M6 = Jo([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(e, t) {
  return e["[object " + t + "Array]"] = !0, e;
}, {}), ff = Object.prototype.toString, GS = Array.prototype, Wye = GS.forEach, jye = GS.filter, OM = GS.slice, Uye = GS.map, TF = (function() {
}).constructor, Am = TF ? TF.prototype : null, LM = "__proto__", Kye = 2311;
function FM() {
  return Kye++;
}
function Ko() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  typeof console < "u" && console.error.apply(console, e);
}
function dt(e) {
  if (e == null || typeof e != "object")
    return e;
  var t = e, r = ff.call(e);
  if (r === "[object Array]") {
    if (!Rh(e)) {
      t = [];
      for (var n = 0, i = e.length; n < i; n++)
        t[n] = dt(e[n]);
    }
  } else if (M6[r]) {
    if (!Rh(e)) {
      var o = e.constructor;
      if (o.from)
        t = o.from(e);
      else {
        t = new o(e.length);
        for (var n = 0, i = e.length; n < i; n++)
          t[n] = e[n];
      }
    }
  } else if (!P6[r] && !Rh(e) && !ru(e)) {
    t = {};
    for (var a in e)
      e.hasOwnProperty(a) && a !== LM && (t[a] = dt(e[a]));
  }
  return t;
}
function Mt(e, t, r) {
  if (!lt(t) || !lt(e))
    return r ? dt(t) : e;
  for (var n in t)
    if (t.hasOwnProperty(n) && n !== LM) {
      var i = e[n], o = t[n];
      lt(o) && lt(i) && !be(o) && !be(i) && !ru(o) && !ru(i) && !l_(o) && !l_(i) && !Rh(o) && !Rh(i) ? Mt(i, o, r) : (r || !(n in e)) && (e[n] = dt(t[n]));
    }
  return e;
}
function zS(e, t) {
  for (var r = e[0], n = 1, i = e.length; n < i; n++)
    r = Mt(r, e[n], t);
  return r;
}
function ge(e, t) {
  if (Object.assign)
    Object.assign(e, t);
  else
    for (var r in t)
      t.hasOwnProperty(r) && r !== LM && (e[r] = t[r]);
  return e;
}
function ut(e, t, r) {
  for (var n = jt(t), i = 0; i < n.length; i++) {
    var o = n[i];
    (r ? t[o] != null : e[o] == null) && (e[o] = t[o]);
  }
  return e;
}
var Yye = Ia.createCanvas;
function Ft(e, t) {
  if (e) {
    if (e.indexOf)
      return e.indexOf(t);
    for (var r = 0, n = e.length; r < n; r++)
      if (e[r] === t)
        return r;
  }
  return -1;
}
function NM(e, t) {
  var r = e.prototype;
  function n() {
  }
  n.prototype = t.prototype, e.prototype = new n();
  for (var i in r)
    r.hasOwnProperty(i) && (e.prototype[i] = r[i]);
  e.prototype.constructor = e, e.superClass = t;
}
function cn(e, t, r) {
  if (e = "prototype" in e ? e.prototype : e, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames)
    for (var n = Object.getOwnPropertyNames(t), i = 0; i < n.length; i++) {
      var o = n[i];
      o !== "constructor" && (r ? t[o] != null : e[o] == null) && (e[o] = t[o]);
    }
  else
    ut(e, t, r);
}
function Jn(e) {
  return !e || typeof e == "string" ? !1 : typeof e.length == "number";
}
function $(e, t, r) {
  if (e && t)
    if (e.forEach && e.forEach === Wye)
      e.forEach(t, r);
    else if (e.length === +e.length)
      for (var n = 0, i = e.length; n < i; n++)
        t.call(r, e[n], n, e);
    else
      for (var o in e)
        e.hasOwnProperty(o) && t.call(r, e[o], o, e);
}
function Ee(e, t, r) {
  if (!e)
    return [];
  if (!t)
    return WS(e);
  if (e.map && e.map === Uye)
    return e.map(t, r);
  for (var n = [], i = 0, o = e.length; i < o; i++)
    n.push(t.call(r, e[i], i, e));
  return n;
}
function Jo(e, t, r, n) {
  if (e && t) {
    for (var i = 0, o = e.length; i < o; i++)
      r = t.call(n, r, e[i], i, e);
    return r;
  }
}
function Sr(e, t, r) {
  if (!e)
    return [];
  if (!t)
    return WS(e);
  if (e.filter && e.filter === jye)
    return e.filter(t, r);
  for (var n = [], i = 0, o = e.length; i < o; i++)
    t.call(r, e[i], i, e) && n.push(e[i]);
  return n;
}
function D6(e, t, r) {
  if (e && t) {
    for (var n = 0, i = e.length; n < i; n++)
      if (t.call(r, e[n], n, e))
        return e[n];
  }
}
function jt(e) {
  if (!e)
    return [];
  if (Object.keys)
    return Object.keys(e);
  var t = [];
  for (var r in e)
    e.hasOwnProperty(r) && t.push(r);
  return t;
}
function qye(e, t) {
  for (var r = [], n = 2; n < arguments.length; n++)
    r[n - 2] = arguments[n];
  return function() {
    return e.apply(t, r.concat(OM.call(arguments)));
  };
}
var je = Am && at(Am.bind) ? Am.call.bind(Am.bind) : qye;
function _t(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  return function() {
    return e.apply(this, t.concat(OM.call(arguments)));
  };
}
function be(e) {
  return Array.isArray ? Array.isArray(e) : ff.call(e) === "[object Array]";
}
function at(e) {
  return typeof e == "function";
}
function He(e) {
  return typeof e == "string";
}
function Ng(e) {
  return ff.call(e) === "[object String]";
}
function sr(e) {
  return typeof e == "number";
}
function lt(e) {
  var t = typeof e;
  return t === "function" || !!e && t === "object";
}
function l_(e) {
  return !!P6[ff.call(e)];
}
function hi(e) {
  return !!M6[ff.call(e)];
}
function ru(e) {
  return typeof e == "object" && typeof e.nodeType == "number" && typeof e.ownerDocument == "object";
}
function Dv(e) {
  return e.colorStops != null;
}
function A6(e) {
  return e.image != null;
}
function kM(e) {
  return ff.call(e) === "[object RegExp]";
}
function nu(e) {
  return e !== e;
}
function vn() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  for (var r = 0, n = e.length; r < n; r++)
    if (e[r] != null)
      return e[r];
}
function bt(e, t) {
  return e ?? t;
}
function So(e, t, r) {
  return e ?? t ?? r;
}
function WS(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  return OM.apply(e, t);
}
function jS(e) {
  if (typeof e == "number")
    return [e, e, e, e];
  var t = e.length;
  return t === 2 ? [e[0], e[1], e[0], e[1]] : t === 3 ? [e[0], e[1], e[2], e[1]] : e;
}
function ct(e, t) {
  if (!e)
    throw new Error(t);
}
function Wo(e) {
  return e == null ? null : typeof e.trim == "function" ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var I6 = "__ec_primitive__";
function kg(e) {
  e[I6] = !0;
}
function Rh(e) {
  return e[I6];
}
var Xye = function() {
  function e() {
    this.data = {};
  }
  return e.prototype.delete = function(t) {
    var r = this.has(t);
    return r && delete this.data[t], r;
  }, e.prototype.has = function(t) {
    return this.data.hasOwnProperty(t);
  }, e.prototype.get = function(t) {
    return this.data[t];
  }, e.prototype.set = function(t, r) {
    return this.data[t] = r, this;
  }, e.prototype.keys = function() {
    return jt(this.data);
  }, e.prototype.forEach = function(t) {
    var r = this.data;
    for (var n in r)
      r.hasOwnProperty(n) && t(r[n], n);
  }, e;
}(), O6 = typeof Map == "function";
function Zye() {
  return O6 ? /* @__PURE__ */ new Map() : new Xye();
}
var L6 = function() {
  function e(t) {
    var r = be(t);
    this.data = Zye();
    var n = this;
    t instanceof e ? t.each(i) : t && $(t, i);
    function i(o, a) {
      r ? n.set(o, a) : n.set(a, o);
    }
  }
  return e.prototype.hasKey = function(t) {
    return this.data.has(t);
  }, e.prototype.get = function(t) {
    return this.data.get(t);
  }, e.prototype.set = function(t, r) {
    return this.data.set(t, r), r;
  }, e.prototype.each = function(t, r) {
    this.data.forEach(function(n, i) {
      t.call(r, n, i);
    });
  }, e.prototype.keys = function() {
    var t = this.data.keys();
    return O6 ? Array.from(t) : t;
  }, e.prototype.removeKey = function(t) {
    this.data.delete(t);
  }, e;
}();
function nt(e) {
  return new L6(e);
}
function Vg(e, t) {
  for (var r = new e.constructor(e.length + t.length), n = 0; n < e.length; n++)
    r[n] = e[n];
  for (var i = e.length, n = 0; n < t.length; n++)
    r[n + i] = t[n];
  return r;
}
function Av(e, t) {
  var r;
  if (Object.create)
    r = Object.create(e);
  else {
    var n = function() {
    };
    n.prototype = e, r = new n();
  }
  return t && ge(r, t), r;
}
function VM(e) {
  var t = e.style;
  t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
}
function Ye(e, t) {
  return e.hasOwnProperty(t);
}
function un() {
}
var eg = 180 / Math.PI;
const Qye = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HashMap: L6,
  RADIAN_TO_DEGREE: eg,
  assert: ct,
  bind: je,
  clone: dt,
  concatArray: Vg,
  createCanvas: Yye,
  createHashMap: nt,
  createObject: Av,
  curry: _t,
  defaults: ut,
  disableUserSelect: VM,
  each: $,
  eqNaN: nu,
  extend: ge,
  filter: Sr,
  find: D6,
  guid: FM,
  hasOwn: Ye,
  indexOf: Ft,
  inherits: NM,
  isArray: be,
  isArrayLike: Jn,
  isBuiltInObject: l_,
  isDom: ru,
  isFunction: at,
  isGradientObject: Dv,
  isImagePatternObject: A6,
  isNumber: sr,
  isObject: lt,
  isPrimitive: Rh,
  isRegExp: kM,
  isString: He,
  isStringSafe: Ng,
  isTypedArray: hi,
  keys: jt,
  logError: Ko,
  map: Ee,
  merge: Mt,
  mergeAll: zS,
  mixin: cn,
  noop: un,
  normalizeCssArray: jS,
  reduce: Jo,
  retrieve: vn,
  retrieve2: bt,
  retrieve3: So,
  setAsPrimitive: kg,
  slice: WS,
  trim: Wo
}, Symbol.toStringTag, { value: "Module" }));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var u_ = function(e, t) {
  return u_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i]);
  }, u_(e, t);
};
function Ur(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  u_(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
function yu(e, t) {
  return e == null && (e = 0), t == null && (t = 0), [e, t];
}
function ai(e, t) {
  return e[0] = t[0], e[1] = t[1], e;
}
function ls(e) {
  return [e[0], e[1]];
}
function F6(e, t, r) {
  return e[0] = t, e[1] = r, e;
}
function c_(e, t, r) {
  return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e;
}
function X0(e, t, r, n) {
  return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e;
}
function Ol(e, t, r) {
  return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e;
}
function Bg(e) {
  return Math.sqrt(BM(e));
}
var Jye = Bg;
function BM(e) {
  return e[0] * e[0] + e[1] * e[1];
}
var e0e = BM;
function t0e(e, t, r) {
  return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e;
}
function r0e(e, t, r) {
  return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e;
}
function n0e(e, t) {
  return e[0] * t[0] + e[1] * t[1];
}
function tg(e, t, r) {
  return e[0] = t[0] * r, e[1] = t[1] * r, e;
}
function nd(e, t) {
  var r = Bg(t);
  return r === 0 ? (e[0] = 0, e[1] = 0) : (e[0] = t[0] / r, e[1] = t[1] / r), e;
}
function Z0(e, t) {
  return Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]));
}
var ks = Z0;
function N6(e, t) {
  return (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]);
}
var Hl = N6;
function i0e(e, t) {
  return e[0] = -t[0], e[1] = -t[1], e;
}
function rg(e, t, r, n) {
  return e[0] = t[0] + n * (r[0] - t[0]), e[1] = t[1] + n * (r[1] - t[1]), e;
}
function Un(e, t, r) {
  var n = t[0], i = t[1];
  return e[0] = r[0] * n + r[2] * i + r[4], e[1] = r[1] * n + r[3] * i + r[5], e;
}
function Vs(e, t, r) {
  return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e;
}
function Bs(e, t, r) {
  return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e;
}
const o0e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: c_,
  applyTransform: Un,
  clone: ls,
  copy: ai,
  create: yu,
  dist: ks,
  distSquare: Hl,
  distance: Z0,
  distanceSquare: N6,
  div: r0e,
  dot: n0e,
  len: Bg,
  lenSquare: BM,
  length: Jye,
  lengthSquare: e0e,
  lerp: rg,
  max: Bs,
  min: Vs,
  mul: t0e,
  negate: i0e,
  normalize: nd,
  scale: tg,
  scaleAndAdd: X0,
  set: F6,
  sub: Ol
}, Symbol.toStringTag, { value: "Module" }));
var Dd = /* @__PURE__ */ function() {
  function e(t, r) {
    this.target = t, this.topTarget = r && r.topTarget;
  }
  return e;
}(), a0e = function() {
  function e(t) {
    this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
  }
  return e.prototype._dragStart = function(t) {
    for (var r = t.target; r && !r.draggable; )
      r = r.parent || r.__hostTarget;
    r && (this._draggingTarget = r, r.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new Dd(r, t), "dragstart", t.event));
  }, e.prototype._drag = function(t) {
    var r = this._draggingTarget;
    if (r) {
      var n = t.offsetX, i = t.offsetY, o = n - this._x, a = i - this._y;
      this._x = n, this._y = i, r.drift(o, a, t), this.handler.dispatchToElement(new Dd(r, t), "drag", t.event);
      var s = this.handler.findHover(n, i, r).target, l = this._dropTarget;
      this._dropTarget = s, r !== s && (l && s !== l && this.handler.dispatchToElement(new Dd(l, t), "dragleave", t.event), s && s !== l && this.handler.dispatchToElement(new Dd(s, t), "dragenter", t.event));
    }
  }, e.prototype._dragEnd = function(t) {
    var r = this._draggingTarget;
    r && (r.dragging = !1), this.handler.dispatchToElement(new Dd(r, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new Dd(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
  }, e;
}(), na = function() {
  function e(t) {
    t && (this._$eventProcessor = t);
  }
  return e.prototype.on = function(t, r, n, i) {
    this._$handlers || (this._$handlers = {});
    var o = this._$handlers;
    if (typeof r == "function" && (i = n, n = r, r = null), !n || !t)
      return this;
    var a = this._$eventProcessor;
    r != null && a && a.normalizeQuery && (r = a.normalizeQuery(r)), o[t] || (o[t] = []);
    for (var s = 0; s < o[t].length; s++)
      if (o[t][s].h === n)
        return this;
    var l = {
      h: n,
      query: r,
      ctx: i || this,
      callAtLast: n.zrEventfulCallAtLast
    }, u = o[t].length - 1, c = o[t][u];
    return c && c.callAtLast ? o[t].splice(u, 0, l) : o[t].push(l), this;
  }, e.prototype.isSilent = function(t) {
    var r = this._$handlers;
    return !r || !r[t] || !r[t].length;
  }, e.prototype.off = function(t, r) {
    var n = this._$handlers;
    if (!n)
      return this;
    if (!t)
      return this._$handlers = {}, this;
    if (r) {
      if (n[t]) {
        for (var i = [], o = 0, a = n[t].length; o < a; o++)
          n[t][o].h !== r && i.push(n[t][o]);
        n[t] = i;
      }
      n[t] && n[t].length === 0 && delete n[t];
    } else
      delete n[t];
    return this;
  }, e.prototype.trigger = function(t) {
    for (var r = [], n = 1; n < arguments.length; n++)
      r[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[t], o = this._$eventProcessor;
    if (i)
      for (var a = r.length, s = i.length, l = 0; l < s; l++) {
        var u = i[l];
        if (!(o && o.filter && u.query != null && !o.filter(t, u.query)))
          switch (a) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, r[0]);
              break;
            case 2:
              u.h.call(u.ctx, r[0], r[1]);
              break;
            default:
              u.h.apply(u.ctx, r);
              break;
          }
      }
    return o && o.afterTrigger && o.afterTrigger(t), this;
  }, e.prototype.triggerWithContext = function(t) {
    for (var r = [], n = 1; n < arguments.length; n++)
      r[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[t], o = this._$eventProcessor;
    if (i)
      for (var a = r.length, s = r[a - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(o && o.filter && c.query != null && !o.filter(t, c.query)))
          switch (a) {
            case 0:
              c.h.call(s);
              break;
            case 1:
              c.h.call(s, r[0]);
              break;
            case 2:
              c.h.call(s, r[0], r[1]);
              break;
            default:
              c.h.apply(s, r.slice(1, a - 1));
              break;
          }
      }
    return o && o.afterTrigger && o.afterTrigger(t), this;
  }, e;
}(), s0e = Math.log(2);
function d_(e, t, r, n, i, o) {
  var a = n + "-" + i, s = e.length;
  if (o.hasOwnProperty(a))
    return o[a];
  if (t === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~i) / s0e);
    return e[r][l];
  }
  for (var u = n | 1 << r, c = r + 1; n & 1 << c; )
    c++;
  for (var d = 0, h = 0, f = 0; h < s; h++) {
    var p = 1 << h;
    p & i || (d += (f % 2 ? -1 : 1) * e[r][h] * d_(e, t - 1, c, u, i | p, o), f++);
  }
  return o[a] = d, d;
}
function PF(e, t) {
  var r = [
    [e[0], e[1], 1, 0, 0, 0, -t[0] * e[0], -t[0] * e[1]],
    [0, 0, 0, e[0], e[1], 1, -t[1] * e[0], -t[1] * e[1]],
    [e[2], e[3], 1, 0, 0, 0, -t[2] * e[2], -t[2] * e[3]],
    [0, 0, 0, e[2], e[3], 1, -t[3] * e[2], -t[3] * e[3]],
    [e[4], e[5], 1, 0, 0, 0, -t[4] * e[4], -t[4] * e[5]],
    [0, 0, 0, e[4], e[5], 1, -t[5] * e[4], -t[5] * e[5]],
    [e[6], e[7], 1, 0, 0, 0, -t[6] * e[6], -t[6] * e[7]],
    [0, 0, 0, e[6], e[7], 1, -t[7] * e[6], -t[7] * e[7]]
  ], n = {}, i = d_(r, 8, 0, 0, 0, n);
  if (i !== 0) {
    for (var o = [], a = 0; a < 8; a++)
      for (var s = 0; s < 8; s++)
        o[s] == null && (o[s] = 0), o[s] += ((a + s) % 2 ? -1 : 1) * d_(r, 7, a === 0 ? 1 : 0, 1 << a, 1 << s, n) / i * t[a];
    return function(l, u, c) {
      var d = u * o[6] + c * o[7] + 1;
      l[0] = (u * o[0] + c * o[1] + o[2]) / d, l[1] = (u * o[3] + c * o[4] + o[5]) / d;
    };
  }
}
var MF = "___zrEVENTSAVED", Wb = [];
function l0e(e, t, r, n, i) {
  return h_(Wb, t, n, i, !0) && h_(e, r, Wb[0], Wb[1]);
}
function h_(e, t, r, n, i) {
  if (t.getBoundingClientRect && nr.domSupported && !k6(t)) {
    var o = t[MF] || (t[MF] = {}), a = u0e(t, o), s = c0e(a, o, i);
    if (s)
      return s(e, r, n), !0;
  }
  return !1;
}
function u0e(e, t) {
  var r = t.markers;
  if (r)
    return r;
  r = t.markers = [];
  for (var n = ["left", "right"], i = ["top", "bottom"], o = 0; o < 4; o++) {
    var a = document.createElement("div"), s = a.style, l = o % 2, u = (o >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      n[l] + ":0",
      i[u] + ":0",
      n[1 - l] + ":auto",
      i[1 - u] + ":auto",
      ""
    ].join("!important;"), e.appendChild(a), r.push(a);
  }
  return r;
}
function c0e(e, t, r) {
  for (var n = r ? "invTrans" : "trans", i = t[n], o = t.srcCoords, a = [], s = [], l = !0, u = 0; u < 4; u++) {
    var c = e[u].getBoundingClientRect(), d = 2 * u, h = c.left, f = c.top;
    a.push(h, f), l = l && o && h === o[d] && f === o[d + 1], s.push(e[u].offsetLeft, e[u].offsetTop);
  }
  return l && i ? i : (t.srcCoords = a, t[n] = r ? PF(s, a) : PF(a, s));
}
function k6(e) {
  return e.nodeName.toUpperCase() === "CANVAS";
}
var d0e = /([&<>"'])/g, h0e = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Ei(e) {
  return e == null ? "" : (e + "").replace(d0e, function(t, r) {
    return h0e[r];
  });
}
var f0e = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, jb = [], p0e = nr.browser.firefox && +nr.browser.version.split(".")[0] < 39;
function f_(e, t, r, n) {
  return r = r || {}, n ? DF(e, t, r) : p0e && t.layerX != null && t.layerX !== t.offsetX ? (r.zrX = t.layerX, r.zrY = t.layerY) : t.offsetX != null ? (r.zrX = t.offsetX, r.zrY = t.offsetY) : DF(e, t, r), r;
}
function DF(e, t, r) {
  if (nr.domSupported && e.getBoundingClientRect) {
    var n = t.clientX, i = t.clientY;
    if (k6(e)) {
      var o = e.getBoundingClientRect();
      r.zrX = n - o.left, r.zrY = i - o.top;
      return;
    } else if (h_(jb, e, n, i)) {
      r.zrX = jb[0], r.zrY = jb[1];
      return;
    }
  }
  r.zrX = r.zrY = 0;
}
function $M(e) {
  return e || window.event;
}
function No(e, t, r) {
  if (t = $M(t), t.zrX != null)
    return t;
  var n = t.type, i = n && n.indexOf("touch") >= 0;
  if (i) {
    var a = n !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
    a && f_(e, a, t, r);
  } else {
    f_(e, t, t, r);
    var o = g0e(t);
    t.zrDelta = o ? o / 120 : -(t.detail || 0) / 3;
  }
  var s = t.button;
  return t.which == null && s !== void 0 && f0e.test(t.type) && (t.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), t;
}
function g0e(e) {
  var t = e.wheelDelta;
  if (t)
    return t;
  var r = e.deltaX, n = e.deltaY;
  if (r == null || n == null)
    return t;
  var i = Math.abs(n !== 0 ? n : r), o = n > 0 ? -1 : n < 0 ? 1 : r > 0 ? -1 : 1;
  return 3 * i * o;
}
function p_(e, t, r, n) {
  e.addEventListener(t, r, n);
}
function v0e(e, t, r, n) {
  e.removeEventListener(t, r, n);
}
var Zs = function(e) {
  e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0;
};
function AF(e) {
  return e.which === 2 || e.which === 3;
}
var m0e = function() {
  function e() {
    this._track = [];
  }
  return e.prototype.recognize = function(t, r, n) {
    return this._doTrack(t, r, n), this._recognize(t);
  }, e.prototype.clear = function() {
    return this._track.length = 0, this;
  }, e.prototype._doTrack = function(t, r, n) {
    var i = t.touches;
    if (i) {
      for (var o = {
        points: [],
        touches: [],
        target: r,
        event: t
      }, a = 0, s = i.length; a < s; a++) {
        var l = i[a], u = f_(n, l, {});
        o.points.push([u.zrX, u.zrY]), o.touches.push(l);
      }
      this._track.push(o);
    }
  }, e.prototype._recognize = function(t) {
    for (var r in Ub)
      if (Ub.hasOwnProperty(r)) {
        var n = Ub[r](this._track, t);
        if (n)
          return n;
      }
  }, e;
}();
function IF(e) {
  var t = e[1][0] - e[0][0], r = e[1][1] - e[0][1];
  return Math.sqrt(t * t + r * r);
}
function y0e(e) {
  return [
    (e[0][0] + e[1][0]) / 2,
    (e[0][1] + e[1][1]) / 2
  ];
}
var Ub = {
  pinch: function(e, t) {
    var r = e.length;
    if (r) {
      var n = (e[r - 1] || {}).points, i = (e[r - 2] || {}).points || n;
      if (i && i.length > 1 && n && n.length > 1) {
        var o = IF(n) / IF(i);
        !isFinite(o) && (o = 1), t.pinchScale = o;
        var a = y0e(n);
        return t.pinchX = a[0], t.pinchY = a[1], {
          type: "pinch",
          target: e[0].target,
          event: t
        };
      }
    }
  }
};
function Zi() {
  return [1, 0, 0, 1, 0, 0];
}
function Iv(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
}
function US(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function us(e, t, r) {
  var n = t[0] * r[0] + t[2] * r[1], i = t[1] * r[0] + t[3] * r[1], o = t[0] * r[2] + t[2] * r[3], a = t[1] * r[2] + t[3] * r[3], s = t[0] * r[4] + t[2] * r[5] + t[4], l = t[1] * r[4] + t[3] * r[5] + t[5];
  return e[0] = n, e[1] = i, e[2] = o, e[3] = a, e[4] = s, e[5] = l, e;
}
function Oa(e, t, r) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4] + r[0], e[5] = t[5] + r[1], e;
}
function Cu(e, t, r, n) {
  n === void 0 && (n = [0, 0]);
  var i = t[0], o = t[2], a = t[4], s = t[1], l = t[3], u = t[5], c = Math.sin(r), d = Math.cos(r);
  return e[0] = i * d + s * c, e[1] = -i * c + s * d, e[2] = o * d + l * c, e[3] = -o * c + d * l, e[4] = d * (a - n[0]) + c * (u - n[1]) + n[0], e[5] = d * (u - n[1]) - c * (a - n[0]) + n[1], e;
}
function KS(e, t, r) {
  var n = r[0], i = r[1];
  return e[0] = t[0] * n, e[1] = t[1] * i, e[2] = t[2] * n, e[3] = t[3] * i, e[4] = t[4] * n, e[5] = t[5] * i, e;
}
function id(e, t) {
  var r = t[0], n = t[2], i = t[4], o = t[1], a = t[3], s = t[5], l = r * a - o * n;
  return l ? (l = 1 / l, e[0] = a * l, e[1] = -o * l, e[2] = -n * l, e[3] = r * l, e[4] = (n * s - a * i) * l, e[5] = (o * i - r * s) * l, e) : null;
}
function V6(e) {
  var t = Zi();
  return US(t, e), t;
}
const C0e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clone: V6,
  copy: US,
  create: Zi,
  identity: Iv,
  invert: id,
  mul: us,
  rotate: Cu,
  scale: KS,
  translate: Oa
}, Symbol.toStringTag, { value: "Module" }));
var Dt = function() {
  function e(t, r) {
    this.x = t || 0, this.y = r || 0;
  }
  return e.prototype.copy = function(t) {
    return this.x = t.x, this.y = t.y, this;
  }, e.prototype.clone = function() {
    return new e(this.x, this.y);
  }, e.prototype.set = function(t, r) {
    return this.x = t, this.y = r, this;
  }, e.prototype.equal = function(t) {
    return t.x === this.x && t.y === this.y;
  }, e.prototype.add = function(t) {
    return this.x += t.x, this.y += t.y, this;
  }, e.prototype.scale = function(t) {
    this.x *= t, this.y *= t;
  }, e.prototype.scaleAndAdd = function(t, r) {
    this.x += t.x * r, this.y += t.y * r;
  }, e.prototype.sub = function(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }, e.prototype.dot = function(t) {
    return this.x * t.x + this.y * t.y;
  }, e.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, e.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, e.prototype.normalize = function() {
    var t = this.len();
    return this.x /= t, this.y /= t, this;
  }, e.prototype.distance = function(t) {
    var r = this.x - t.x, n = this.y - t.y;
    return Math.sqrt(r * r + n * n);
  }, e.prototype.distanceSquare = function(t) {
    var r = this.x - t.x, n = this.y - t.y;
    return r * r + n * n;
  }, e.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, e.prototype.transform = function(t) {
    if (t) {
      var r = this.x, n = this.y;
      return this.x = t[0] * r + t[2] * n + t[4], this.y = t[1] * r + t[3] * n + t[5], this;
    }
  }, e.prototype.toArray = function(t) {
    return t[0] = this.x, t[1] = this.y, t;
  }, e.prototype.fromArray = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.set = function(t, r, n) {
    t.x = r, t.y = n;
  }, e.copy = function(t, r) {
    t.x = r.x, t.y = r.y;
  }, e.len = function(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y);
  }, e.lenSquare = function(t) {
    return t.x * t.x + t.y * t.y;
  }, e.dot = function(t, r) {
    return t.x * r.x + t.y * r.y;
  }, e.add = function(t, r, n) {
    t.x = r.x + n.x, t.y = r.y + n.y;
  }, e.sub = function(t, r, n) {
    t.x = r.x - n.x, t.y = r.y - n.y;
  }, e.scale = function(t, r, n) {
    t.x = r.x * n, t.y = r.y * n;
  }, e.scaleAndAdd = function(t, r, n, i) {
    t.x = r.x + n.x * i, t.y = r.y + n.y * i;
  }, e.lerp = function(t, r, n, i) {
    var o = 1 - i;
    t.x = o * r.x + i * n.x, t.y = o * r.y + i * n.y;
  }, e;
}(), Im = Math.min, Om = Math.max, _u = new Dt(), Tu = new Dt(), Pu = new Dt(), Mu = new Dt(), qf = new Dt(), Xf = new Dt(), S0e = function() {
  function e(t, r, n, i) {
    n < 0 && (t = t + n, n = -n), i < 0 && (r = r + i, i = -i), this.x = t, this.y = r, this.width = n, this.height = i;
  }
  return e.prototype.union = function(t) {
    var r = Im(t.x, this.x), n = Im(t.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Om(t.x + t.width, this.x + this.width) - r : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Om(t.y + t.height, this.y + this.height) - n : this.height = t.height, this.x = r, this.y = n;
  }, e.prototype.applyTransform = function(t) {
    e.applyTransform(this, this, t);
  }, e.prototype.calculateTransform = function(t) {
    var r = this, n = t.width / r.width, i = t.height / r.height, o = Zi();
    return Oa(o, o, [-r.x, -r.y]), KS(o, o, [n, i]), Oa(o, o, [t.x, t.y]), o;
  }, e.prototype.intersect = function(t, r) {
    if (!t)
      return !1;
    t instanceof e || (t = e.create(t));
    var n = this, i = n.x, o = n.x + n.width, a = n.y, s = n.y + n.height, l = t.x, u = t.x + t.width, c = t.y, d = t.y + t.height, h = !(o < l || u < i || s < c || d < a);
    if (r) {
      var f = 1 / 0, p = 0, g = Math.abs(o - l), v = Math.abs(u - i), m = Math.abs(s - c), y = Math.abs(d - a), C = Math.min(g, v), S = Math.min(m, y);
      o < l || u < i ? C > p && (p = C, g < v ? Dt.set(Xf, -g, 0) : Dt.set(Xf, v, 0)) : C < f && (f = C, g < v ? Dt.set(qf, g, 0) : Dt.set(qf, -v, 0)), s < c || d < a ? S > p && (p = S, m < y ? Dt.set(Xf, 0, -m) : Dt.set(Xf, 0, y)) : C < f && (f = C, m < y ? Dt.set(qf, 0, m) : Dt.set(qf, 0, -y));
    }
    return r && Dt.copy(r, h ? qf : Xf), h;
  }, e.prototype.contain = function(t, r) {
    var n = this;
    return t >= n.x && t <= n.x + n.width && r >= n.y && r <= n.y + n.height;
  }, e.prototype.clone = function() {
    return new e(this.x, this.y, this.width, this.height);
  }, e.prototype.copy = function(t) {
    e.copy(this, t);
  }, e.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, e.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, e.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, e.create = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e.copy = function(t, r) {
    t.x = r.x, t.y = r.y, t.width = r.width, t.height = r.height;
  }, e.applyTransform = function(t, r, n) {
    if (!n) {
      t !== r && e.copy(t, r);
      return;
    }
    if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
      var i = n[0], o = n[3], a = n[4], s = n[5];
      t.x = r.x * i + a, t.y = r.y * o + s, t.width = r.width * i, t.height = r.height * o, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
      return;
    }
    _u.x = Pu.x = r.x, _u.y = Mu.y = r.y, Tu.x = Mu.x = r.x + r.width, Tu.y = Pu.y = r.y + r.height, _u.transform(n), Mu.transform(n), Tu.transform(n), Pu.transform(n), t.x = Im(_u.x, Tu.x, Pu.x, Mu.x), t.y = Im(_u.y, Tu.y, Pu.y, Mu.y);
    var l = Om(_u.x, Tu.x, Pu.x, Mu.x), u = Om(_u.y, Tu.y, Pu.y, Mu.y);
    t.width = l - t.x, t.height = u - t.y;
  }, e;
}();
const At = S0e;
var B6 = "silent";
function w0e(e, t, r) {
  return {
    type: e,
    event: r,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: r.zrX,
    offsetY: r.zrY,
    gestureEvent: r.gestureEvent,
    pinchX: r.pinchX,
    pinchY: r.pinchY,
    pinchScale: r.pinchScale,
    wheelDelta: r.zrDelta,
    zrByTouch: r.zrByTouch,
    which: r.which,
    stop: b0e
  };
}
function b0e() {
  Zs(this.event);
}
var x0e = function(e) {
  Ur(t, e);
  function t() {
    var r = e !== null && e.apply(this, arguments) || this;
    return r.handler = null, r;
  }
  return t.prototype.dispose = function() {
  }, t.prototype.setCursor = function() {
  }, t;
}(na), Zf = /* @__PURE__ */ function() {
  function e(t, r) {
    this.x = t, this.y = r;
  }
  return e;
}(), E0e = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], Kb = new At(0, 0, 0, 0), $6 = function(e) {
  Ur(t, e);
  function t(r, n, i, o, a) {
    var s = e.call(this) || this;
    return s._hovered = new Zf(0, 0), s.storage = r, s.painter = n, s.painterRoot = o, s._pointerSize = a, i = i || new x0e(), s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new a0e(s), s;
  }
  return t.prototype.setHandlerProxy = function(r) {
    this.proxy && this.proxy.dispose(), r && ($(E0e, function(n) {
      r.on && r.on(n, this[n], this);
    }, this), r.handler = this), this.proxy = r;
  }, t.prototype.mousemove = function(r) {
    var n = r.zrX, i = r.zrY, o = H6(this, n, i), a = this._hovered, s = a.target;
    s && !s.__zr && (a = this.findHover(a.x, a.y), s = a.target);
    var l = this._hovered = o ? new Zf(n, i) : this.findHover(n, i), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(a, "mouseout", r), this.dispatchToElement(l, "mousemove", r), u && u !== s && this.dispatchToElement(l, "mouseover", r);
  }, t.prototype.mouseout = function(r) {
    var n = r.zrEventControl;
    n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", r), n !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: r });
  }, t.prototype.resize = function() {
    this._hovered = new Zf(0, 0);
  }, t.prototype.dispatch = function(r, n) {
    var i = this[r];
    i && i.call(this, n);
  }, t.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, t.prototype.setCursorStyle = function(r) {
    var n = this.proxy;
    n.setCursor && n.setCursor(r);
  }, t.prototype.dispatchToElement = function(r, n, i) {
    r = r || {};
    var o = r.target;
    if (!(o && o.silent)) {
      for (var a = "on" + n, s = w0e(n, r, i); o && (o[a] && (s.cancelBubble = !!o[a].call(o, s)), o.trigger(n, s), o = o.__hostTarget ? o.__hostTarget : o.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(n, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[a] == "function" && l[a].call(l, s), l.trigger && l.trigger(n, s);
      }));
    }
  }, t.prototype.findHover = function(r, n, i) {
    var o = this.storage.getDisplayList(), a = new Zf(r, n);
    if (OF(o, a, r, n, i), this._pointerSize && !a.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, c = new At(r - u, n - u, l, l), d = o.length - 1; d >= 0; d--) {
        var h = o[d];
        h !== i && !h.ignore && !h.ignoreCoarsePointer && (!h.parent || !h.parent.ignoreCoarsePointer) && (Kb.copy(h.getBoundingRect()), h.transform && Kb.applyTransform(h.transform), Kb.intersect(c) && s.push(h));
      }
      if (s.length)
        for (var f = 4, p = Math.PI / 12, g = Math.PI * 2, v = 0; v < u; v += f)
          for (var m = 0; m < g; m += p) {
            var y = r + v * Math.cos(m), C = n + v * Math.sin(m);
            if (OF(s, a, y, C, i), a.target)
              return a;
          }
    }
    return a;
  }, t.prototype.processGesture = function(r, n) {
    this._gestureMgr || (this._gestureMgr = new m0e());
    var i = this._gestureMgr;
    n === "start" && i.clear();
    var o = i.recognize(r, this.findHover(r.zrX, r.zrY, null).target, this.proxy.dom);
    if (n === "end" && i.clear(), o) {
      var a = o.type;
      r.gestureEvent = a;
      var s = new Zf();
      s.target = o.target, this.dispatchToElement(s, a, o.event);
    }
  }, t;
}(na);
$(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(e) {
  $6.prototype[e] = function(t) {
    var r = t.zrX, n = t.zrY, i = H6(this, r, n), o, a;
    if ((e !== "mouseup" || !i) && (o = this.findHover(r, n), a = o.target), e === "mousedown")
      this._downEl = a, this._downPoint = [t.zrX, t.zrY], this._upEl = a;
    else if (e === "mouseup")
      this._upEl = a;
    else if (e === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || ks(this._downPoint, [t.zrX, t.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(o, e, t);
  };
});
function R0e(e, t, r) {
  if (e[e.rectHover ? "rectContain" : "contain"](t, r)) {
    for (var n = e, i = void 0, o = !1; n; ) {
      if (n.ignoreClip && (o = !0), !o) {
        var a = n.getClipPath();
        if (a && !a.contain(t, r))
          return !1;
      }
      n.silent && (i = !0);
      var s = n.__hostTarget;
      n = s || n.parent;
    }
    return i ? B6 : !0;
  }
  return !1;
}
function OF(e, t, r, n, i) {
  for (var o = e.length - 1; o >= 0; o--) {
    var a = e[o], s = void 0;
    if (a !== i && !a.ignore && (s = R0e(a, r, n)) && (!t.topTarget && (t.topTarget = a), s !== B6)) {
      t.target = a;
      break;
    }
  }
}
function H6(e, t, r) {
  var n = e.painter;
  return t < 0 || t > n.getWidth() || r < 0 || r > n.getHeight();
}
var G6 = 32, Qf = 7;
function _0e(e) {
  for (var t = 0; e >= G6; )
    t |= e & 1, e >>= 1;
  return e + t;
}
function LF(e, t, r, n) {
  var i = t + 1;
  if (i === r)
    return 1;
  if (n(e[i++], e[t]) < 0) {
    for (; i < r && n(e[i], e[i - 1]) < 0; )
      i++;
    T0e(e, t, i);
  } else
    for (; i < r && n(e[i], e[i - 1]) >= 0; )
      i++;
  return i - t;
}
function T0e(e, t, r) {
  for (r--; t < r; ) {
    var n = e[t];
    e[t++] = e[r], e[r--] = n;
  }
}
function FF(e, t, r, n, i) {
  for (n === t && n++; n < r; n++) {
    for (var o = e[n], a = t, s = n, l; a < s; )
      l = a + s >>> 1, i(o, e[l]) < 0 ? s = l : a = l + 1;
    var u = n - a;
    switch (u) {
      case 3:
        e[a + 3] = e[a + 2];
      case 2:
        e[a + 2] = e[a + 1];
      case 1:
        e[a + 1] = e[a];
        break;
      default:
        for (; u > 0; )
          e[a + u] = e[a + u - 1], u--;
    }
    e[a] = o;
  }
}
function Yb(e, t, r, n, i, o) {
  var a = 0, s = 0, l = 1;
  if (o(e, t[r + i]) > 0) {
    for (s = n - i; l < s && o(e, t[r + i + l]) > 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), a += i, l += i;
  } else {
    for (s = i + 1; l < s && o(e, t[r + i - l]) <= 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = a;
    a = i - l, l = i - u;
  }
  for (a++; a < l; ) {
    var c = a + (l - a >>> 1);
    o(e, t[r + c]) > 0 ? a = c + 1 : l = c;
  }
  return l;
}
function qb(e, t, r, n, i, o) {
  var a = 0, s = 0, l = 1;
  if (o(e, t[r + i]) < 0) {
    for (s = i + 1; l < s && o(e, t[r + i - l]) < 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = a;
    a = i - l, l = i - u;
  } else {
    for (s = n - i; l < s && o(e, t[r + i + l]) >= 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), a += i, l += i;
  }
  for (a++; a < l; ) {
    var c = a + (l - a >>> 1);
    o(e, t[r + c]) < 0 ? l = c : a = c + 1;
  }
  return l;
}
function P0e(e, t) {
  var r = Qf, n, i, o = 0, a = [];
  n = [], i = [];
  function s(f, p) {
    n[o] = f, i[o] = p, o += 1;
  }
  function l() {
    for (; o > 1; ) {
      var f = o - 2;
      if (f >= 1 && i[f - 1] <= i[f] + i[f + 1] || f >= 2 && i[f - 2] <= i[f] + i[f - 1])
        i[f - 1] < i[f + 1] && f--;
      else if (i[f] > i[f + 1])
        break;
      c(f);
    }
  }
  function u() {
    for (; o > 1; ) {
      var f = o - 2;
      f > 0 && i[f - 1] < i[f + 1] && f--, c(f);
    }
  }
  function c(f) {
    var p = n[f], g = i[f], v = n[f + 1], m = i[f + 1];
    i[f] = g + m, f === o - 3 && (n[f + 1] = n[f + 2], i[f + 1] = i[f + 2]), o--;
    var y = qb(e[v], e, p, g, 0, t);
    p += y, g -= y, g !== 0 && (m = Yb(e[p + g - 1], e, v, m, m - 1, t), m !== 0 && (g <= m ? d(p, g, v, m) : h(p, g, v, m)));
  }
  function d(f, p, g, v) {
    var m = 0;
    for (m = 0; m < p; m++)
      a[m] = e[f + m];
    var y = 0, C = g, S = f;
    if (e[S++] = e[C++], --v === 0) {
      for (m = 0; m < p; m++)
        e[S + m] = a[y + m];
      return;
    }
    if (p === 1) {
      for (m = 0; m < v; m++)
        e[S + m] = e[C + m];
      e[S + v] = a[y];
      return;
    }
    for (var b = r, w, x, R; ; ) {
      w = 0, x = 0, R = !1;
      do
        if (t(e[C], a[y]) < 0) {
          if (e[S++] = e[C++], x++, w = 0, --v === 0) {
            R = !0;
            break;
          }
        } else if (e[S++] = a[y++], w++, x = 0, --p === 1) {
          R = !0;
          break;
        }
      while ((w | x) < b);
      if (R)
        break;
      do {
        if (w = qb(e[C], a, y, p, 0, t), w !== 0) {
          for (m = 0; m < w; m++)
            e[S + m] = a[y + m];
          if (S += w, y += w, p -= w, p <= 1) {
            R = !0;
            break;
          }
        }
        if (e[S++] = e[C++], --v === 0) {
          R = !0;
          break;
        }
        if (x = Yb(a[y], e, C, v, 0, t), x !== 0) {
          for (m = 0; m < x; m++)
            e[S + m] = e[C + m];
          if (S += x, C += x, v -= x, v === 0) {
            R = !0;
            break;
          }
        }
        if (e[S++] = a[y++], --p === 1) {
          R = !0;
          break;
        }
        b--;
      } while (w >= Qf || x >= Qf);
      if (R)
        break;
      b < 0 && (b = 0), b += 2;
    }
    if (r = b, r < 1 && (r = 1), p === 1) {
      for (m = 0; m < v; m++)
        e[S + m] = e[C + m];
      e[S + v] = a[y];
    } else {
      if (p === 0)
        throw new Error();
      for (m = 0; m < p; m++)
        e[S + m] = a[y + m];
    }
  }
  function h(f, p, g, v) {
    var m = 0;
    for (m = 0; m < v; m++)
      a[m] = e[g + m];
    var y = f + p - 1, C = v - 1, S = g + v - 1, b = 0, w = 0;
    if (e[S--] = e[y--], --p === 0) {
      for (b = S - (v - 1), m = 0; m < v; m++)
        e[b + m] = a[m];
      return;
    }
    if (v === 1) {
      for (S -= p, y -= p, w = S + 1, b = y + 1, m = p - 1; m >= 0; m--)
        e[w + m] = e[b + m];
      e[S] = a[C];
      return;
    }
    for (var x = r; ; ) {
      var R = 0, _ = 0, T = !1;
      do
        if (t(a[C], e[y]) < 0) {
          if (e[S--] = e[y--], R++, _ = 0, --p === 0) {
            T = !0;
            break;
          }
        } else if (e[S--] = a[C--], _++, R = 0, --v === 1) {
          T = !0;
          break;
        }
      while ((R | _) < x);
      if (T)
        break;
      do {
        if (R = p - qb(a[C], e, f, p, p - 1, t), R !== 0) {
          for (S -= R, y -= R, p -= R, w = S + 1, b = y + 1, m = R - 1; m >= 0; m--)
            e[w + m] = e[b + m];
          if (p === 0) {
            T = !0;
            break;
          }
        }
        if (e[S--] = a[C--], --v === 1) {
          T = !0;
          break;
        }
        if (_ = v - Yb(e[y], a, 0, v, v - 1, t), _ !== 0) {
          for (S -= _, C -= _, v -= _, w = S + 1, b = C + 1, m = 0; m < _; m++)
            e[w + m] = a[b + m];
          if (v <= 1) {
            T = !0;
            break;
          }
        }
        if (e[S--] = e[y--], --p === 0) {
          T = !0;
          break;
        }
        x--;
      } while (R >= Qf || _ >= Qf);
      if (T)
        break;
      x < 0 && (x = 0), x += 2;
    }
    if (r = x, r < 1 && (r = 1), v === 1) {
      for (S -= p, y -= p, w = S + 1, b = y + 1, m = p - 1; m >= 0; m--)
        e[w + m] = e[b + m];
      e[S] = a[C];
    } else {
      if (v === 0)
        throw new Error();
      for (b = S - (v - 1), m = 0; m < v; m++)
        e[b + m] = a[m];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function n0(e, t, r, n) {
  r || (r = 0), n || (n = e.length);
  var i = n - r;
  if (!(i < 2)) {
    var o = 0;
    if (i < G6) {
      o = LF(e, r, n, t), FF(e, r, n, r + o, t);
      return;
    }
    var a = P0e(e, t), s = _0e(i);
    do {
      if (o = LF(e, r, n, t), o < s) {
        var l = i;
        l > s && (l = s), FF(e, r, r + l, r + o, t), o = l;
      }
      a.pushRun(r, o), a.mergeRuns(), i -= o, r += o;
    } while (i !== 0);
    a.forceMergeRuns();
  }
}
var ho = 1, Dp = 2, nh = 4, NF = !1;
function Xb() {
  NF || (NF = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function kF(e, t) {
  return e.zlevel === t.zlevel ? e.z === t.z ? e.z2 - t.z2 : e.z - t.z : e.zlevel - t.zlevel;
}
var M0e = function() {
  function e() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = kF;
  }
  return e.prototype.traverse = function(t, r) {
    for (var n = 0; n < this._roots.length; n++)
      this._roots[n].traverse(t, r);
  }, e.prototype.getDisplayList = function(t, r) {
    r = r || !1;
    var n = this._displayList;
    return (t || !n.length) && this.updateDisplayList(r), n;
  }, e.prototype.updateDisplayList = function(t) {
    this._displayListLen = 0;
    for (var r = this._roots, n = this._displayList, i = 0, o = r.length; i < o; i++)
      this._updateAndAddDisplayable(r[i], null, t);
    n.length = this._displayListLen, n0(n, kF);
  }, e.prototype._updateAndAddDisplayable = function(t, r, n) {
    if (!(t.ignore && !n)) {
      t.beforeUpdate(), t.update(), t.afterUpdate();
      var i = t.getClipPath();
      if (t.ignoreClip)
        r = null;
      else if (i) {
        r ? r = r.slice() : r = [];
        for (var o = i, a = t; o; )
          o.parent = a, o.updateTransform(), r.push(o), a = o, o = o.getClipPath();
      }
      if (t.childrenRef) {
        for (var s = t.childrenRef(), l = 0; l < s.length; l++) {
          var u = s[l];
          t.__dirty && (u.__dirty |= ho), this._updateAndAddDisplayable(u, r, n);
        }
        t.__dirty = 0;
      } else {
        var c = t;
        r && r.length ? c.__clipPaths = r : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []), isNaN(c.z) && (Xb(), c.z = 0), isNaN(c.z2) && (Xb(), c.z2 = 0), isNaN(c.zlevel) && (Xb(), c.zlevel = 0), this._displayList[this._displayListLen++] = c;
      }
      var d = t.getDecalElement && t.getDecalElement();
      d && this._updateAndAddDisplayable(d, r, n);
      var h = t.getTextGuideLine();
      h && this._updateAndAddDisplayable(h, r, n);
      var f = t.getTextContent();
      f && this._updateAndAddDisplayable(f, r, n);
    }
  }, e.prototype.addRoot = function(t) {
    t.__zr && t.__zr.storage === this || this._roots.push(t);
  }, e.prototype.delRoot = function(t) {
    if (t instanceof Array) {
      for (var r = 0, n = t.length; r < n; r++)
        this.delRoot(t[r]);
      return;
    }
    var i = Ft(this._roots, t);
    i >= 0 && this._roots.splice(i, 1);
  }, e.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, e.prototype.getRoots = function() {
    return this._roots;
  }, e.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, e;
}(), Q0;
Q0 = nr.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(e) {
  return setTimeout(e, 16);
};
var ng = {
  linear: function(e) {
    return e;
  },
  quadraticIn: function(e) {
    return e * e;
  },
  quadraticOut: function(e) {
    return e * (2 - e);
  },
  quadraticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
  },
  cubicIn: function(e) {
    return e * e * e;
  },
  cubicOut: function(e) {
    return --e * e * e + 1;
  },
  cubicInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
  },
  quarticIn: function(e) {
    return e * e * e * e;
  },
  quarticOut: function(e) {
    return 1 - --e * e * e * e;
  },
  quarticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
  },
  quinticIn: function(e) {
    return e * e * e * e * e;
  },
  quinticOut: function(e) {
    return --e * e * e * e * e + 1;
  },
  quinticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
  },
  sinusoidalIn: function(e) {
    return 1 - Math.cos(e * Math.PI / 2);
  },
  sinusoidalOut: function(e) {
    return Math.sin(e * Math.PI / 2);
  },
  sinusoidalInOut: function(e) {
    return 0.5 * (1 - Math.cos(Math.PI * e));
  },
  exponentialIn: function(e) {
    return e === 0 ? 0 : Math.pow(1024, e - 1);
  },
  exponentialOut: function(e) {
    return e === 1 ? 1 : 1 - Math.pow(2, -10 * e);
  },
  exponentialInOut: function(e) {
    return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? 0.5 * Math.pow(1024, e - 1) : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2);
  },
  circularIn: function(e) {
    return 1 - Math.sqrt(1 - e * e);
  },
  circularOut: function(e) {
    return Math.sqrt(1 - --e * e);
  },
  circularInOut: function(e) {
    return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
  },
  elasticIn: function(e) {
    var t, r = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!r || r < 1 ? (r = 1, t = n / 4) : t = n * Math.asin(1 / r) / (2 * Math.PI), -(r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)));
  },
  elasticOut: function(e) {
    var t, r = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!r || r < 1 ? (r = 1, t = n / 4) : t = n * Math.asin(1 / r) / (2 * Math.PI), r * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / n) + 1);
  },
  elasticInOut: function(e) {
    var t, r = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!r || r < 1 ? (r = 1, t = n / 4) : t = n * Math.asin(1 / r) / (2 * Math.PI), (e *= 2) < 1 ? -0.5 * (r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)) : r * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n) * 0.5 + 1);
  },
  backIn: function(e) {
    var t = 1.70158;
    return e * e * ((t + 1) * e - t);
  },
  backOut: function(e) {
    var t = 1.70158;
    return --e * e * ((t + 1) * e + t) + 1;
  },
  backInOut: function(e) {
    var t = 2.5949095;
    return (e *= 2) < 1 ? 0.5 * (e * e * ((t + 1) * e - t)) : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
  },
  bounceIn: function(e) {
    return 1 - ng.bounceOut(1 - e);
  },
  bounceOut: function(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  bounceInOut: function(e) {
    return e < 0.5 ? ng.bounceIn(e * 2) * 0.5 : ng.bounceOut(e * 2 - 1) * 0.5 + 0.5;
  }
}, Lm = Math.pow, Gl = Math.sqrt, J0 = 1e-8, z6 = 1e-4, VF = Gl(3), Fm = 1 / 3, es = yu(), Ho = yu(), _h = yu();
function Ll(e) {
  return e > -J0 && e < J0;
}
function W6(e) {
  return e > J0 || e < -J0;
}
function Fn(e, t, r, n, i) {
  var o = 1 - i;
  return o * o * (o * e + 3 * i * t) + i * i * (i * n + 3 * o * r);
}
function BF(e, t, r, n, i) {
  var o = 1 - i;
  return 3 * (((t - e) * o + 2 * (r - t) * i) * o + (n - r) * i * i);
}
function eC(e, t, r, n, i, o) {
  var a = n + 3 * (t - r) - e, s = 3 * (r - t * 2 + e), l = 3 * (t - e), u = e - i, c = s * s - 3 * a * l, d = s * l - 9 * a * u, h = l * l - 3 * s * u, f = 0;
  if (Ll(c) && Ll(d))
    if (Ll(s))
      o[0] = 0;
    else {
      var p = -l / s;
      p >= 0 && p <= 1 && (o[f++] = p);
    }
  else {
    var g = d * d - 4 * c * h;
    if (Ll(g)) {
      var v = d / c, p = -s / a + v, m = -v / 2;
      p >= 0 && p <= 1 && (o[f++] = p), m >= 0 && m <= 1 && (o[f++] = m);
    } else if (g > 0) {
      var y = Gl(g), C = c * s + 1.5 * a * (-d + y), S = c * s + 1.5 * a * (-d - y);
      C < 0 ? C = -Lm(-C, Fm) : C = Lm(C, Fm), S < 0 ? S = -Lm(-S, Fm) : S = Lm(S, Fm);
      var p = (-s - (C + S)) / (3 * a);
      p >= 0 && p <= 1 && (o[f++] = p);
    } else {
      var b = (2 * c * s - 3 * a * d) / (2 * Gl(c * c * c)), w = Math.acos(b) / 3, x = Gl(c), R = Math.cos(w), p = (-s - 2 * x * R) / (3 * a), m = (-s + x * (R + VF * Math.sin(w))) / (3 * a), _ = (-s + x * (R - VF * Math.sin(w))) / (3 * a);
      p >= 0 && p <= 1 && (o[f++] = p), m >= 0 && m <= 1 && (o[f++] = m), _ >= 0 && _ <= 1 && (o[f++] = _);
    }
  }
  return f;
}
function j6(e, t, r, n, i) {
  var o = 6 * r - 12 * t + 6 * e, a = 9 * t + 3 * n - 3 * e - 9 * r, s = 3 * t - 3 * e, l = 0;
  if (Ll(a)) {
    if (W6(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = o * o - 4 * a * s;
    if (Ll(c))
      i[0] = -o / (2 * a);
    else if (c > 0) {
      var d = Gl(c), u = (-o + d) / (2 * a), h = (-o - d) / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function iu(e, t, r, n, i, o) {
  var a = (t - e) * i + e, s = (r - t) * i + t, l = (n - r) * i + r, u = (s - a) * i + a, c = (l - s) * i + s, d = (c - u) * i + u;
  o[0] = e, o[1] = a, o[2] = u, o[3] = d, o[4] = d, o[5] = c, o[6] = l, o[7] = n;
}
function U6(e, t, r, n, i, o, a, s, l, u, c) {
  var d, h = 5e-3, f = 1 / 0, p, g, v, m;
  es[0] = l, es[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    Ho[0] = Fn(e, r, i, a, y), Ho[1] = Fn(t, n, o, s, y), v = Hl(es, Ho), v < f && (d = y, f = v);
  f = 1 / 0;
  for (var C = 0; C < 32 && !(h < z6); C++)
    p = d - h, g = d + h, Ho[0] = Fn(e, r, i, a, p), Ho[1] = Fn(t, n, o, s, p), v = Hl(Ho, es), p >= 0 && v < f ? (d = p, f = v) : (_h[0] = Fn(e, r, i, a, g), _h[1] = Fn(t, n, o, s, g), m = Hl(_h, es), g <= 1 && m < f ? (d = g, f = m) : h *= 0.5);
  return c && (c[0] = Fn(e, r, i, a, d), c[1] = Fn(t, n, o, s, d)), Gl(f);
}
function D0e(e, t, r, n, i, o, a, s, l) {
  for (var u = e, c = t, d = 0, h = 1 / l, f = 1; f <= l; f++) {
    var p = f * h, g = Fn(e, r, i, a, p), v = Fn(t, n, o, s, p), m = g - u, y = v - c;
    d += Math.sqrt(m * m + y * y), u = g, c = v;
  }
  return d;
}
function zn(e, t, r, n) {
  var i = 1 - n;
  return i * (i * e + 2 * n * t) + n * n * r;
}
function g_(e, t, r, n) {
  return 2 * ((1 - n) * (t - e) + n * (r - t));
}
function A0e(e, t, r, n, i) {
  var o = e - 2 * t + r, a = 2 * (t - e), s = e - n, l = 0;
  if (Ll(o)) {
    if (W6(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = a * a - 4 * o * s;
    if (Ll(c)) {
      var u = -a / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u);
    } else if (c > 0) {
      var d = Gl(c), u = (-a + d) / (2 * o), h = (-a - d) / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function K6(e, t, r) {
  var n = e + r - 2 * t;
  return n === 0 ? 0.5 : (e - t) / n;
}
function $g(e, t, r, n, i) {
  var o = (t - e) * n + e, a = (r - t) * n + t, s = (a - o) * n + o;
  i[0] = e, i[1] = o, i[2] = s, i[3] = s, i[4] = a, i[5] = r;
}
function Y6(e, t, r, n, i, o, a, s, l) {
  var u, c = 5e-3, d = 1 / 0;
  es[0] = a, es[1] = s;
  for (var h = 0; h < 1; h += 0.05) {
    Ho[0] = zn(e, r, i, h), Ho[1] = zn(t, n, o, h);
    var f = Hl(es, Ho);
    f < d && (u = h, d = f);
  }
  d = 1 / 0;
  for (var p = 0; p < 32 && !(c < z6); p++) {
    var g = u - c, v = u + c;
    Ho[0] = zn(e, r, i, g), Ho[1] = zn(t, n, o, g);
    var f = Hl(Ho, es);
    if (g >= 0 && f < d)
      u = g, d = f;
    else {
      _h[0] = zn(e, r, i, v), _h[1] = zn(t, n, o, v);
      var m = Hl(_h, es);
      v <= 1 && m < d ? (u = v, d = m) : c *= 0.5;
    }
  }
  return l && (l[0] = zn(e, r, i, u), l[1] = zn(t, n, o, u)), Gl(d);
}
function I0e(e, t, r, n, i, o, a) {
  for (var s = e, l = t, u = 0, c = 1 / a, d = 1; d <= a; d++) {
    var h = d * c, f = zn(e, r, i, h), p = zn(t, n, o, h), g = f - s, v = p - l;
    u += Math.sqrt(g * g + v * v), s = f, l = p;
  }
  return u;
}
var O0e = /cubic-bezier\(([0-9,\.e ]+)\)/;
function HM(e) {
  var t = e && O0e.exec(e);
  if (t) {
    var r = t[1].split(","), n = +Wo(r[0]), i = +Wo(r[1]), o = +Wo(r[2]), a = +Wo(r[3]);
    if (isNaN(n + i + o + a))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : eC(0, n, o, 1, l, s) && Fn(0, i, a, 1, s[0]);
    };
  }
}
var L0e = function() {
  function e(t) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || un, this.ondestroy = t.ondestroy || un, this.onrestart = t.onrestart || un, t.easing && this.setEasing(t.easing);
  }
  return e.prototype.step = function(t, r) {
    if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += r;
      return;
    }
    var n = this._life, i = t - this._startTime - this._pausedTime, o = i / n;
    o < 0 && (o = 0), o = Math.min(o, 1);
    var a = this.easingFunc, s = a ? a(o) : o;
    if (this.onframe(s), o === 1)
      if (this.loop) {
        var l = i % n;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, e.prototype.pause = function() {
    this._paused = !0;
  }, e.prototype.resume = function() {
    this._paused = !1;
  }, e.prototype.setEasing = function(t) {
    this.easing = t, this.easingFunc = at(t) ? t : ng[t] || HM(t);
  }, e;
}(), q6 = /* @__PURE__ */ function() {
  function e(t) {
    this.value = t;
  }
  return e;
}(), F0e = function() {
  function e() {
    this._len = 0;
  }
  return e.prototype.insert = function(t) {
    var r = new q6(t);
    return this.insertEntry(r), r;
  }, e.prototype.insertEntry = function(t) {
    this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, e.prototype.remove = function(t) {
    var r = t.prev, n = t.next;
    r ? r.next = n : this.head = n, n ? n.prev = r : this.tail = r, t.next = t.prev = null, this._len--;
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, e;
}(), Ov = function() {
  function e(t) {
    this._list = new F0e(), this._maxSize = 10, this._map = {}, this._maxSize = t;
  }
  return e.prototype.put = function(t, r) {
    var n = this._list, i = this._map, o = null;
    if (i[t] == null) {
      var a = n.len(), s = this._lastRemovedEntry;
      if (a >= this._maxSize && a > 0) {
        var l = n.head;
        n.remove(l), delete i[l.key], o = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = r : s = new q6(r), s.key = t, n.insertEntry(s), i[t] = s;
    }
    return o;
  }, e.prototype.get = function(t) {
    var r = this._map[t], n = this._list;
    if (r != null)
      return r !== n.tail && (n.remove(r), n.insertEntry(r)), r.value;
  }, e.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, e.prototype.len = function() {
    return this._list.len();
  }, e;
}(), $F = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function Ta(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 255 ? 255 : e;
}
function N0e(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 360 ? 360 : e;
}
function Hg(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function Zb(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? Ta(parseFloat(t) / 100 * 255) : Ta(parseInt(t, 10));
}
function _c(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? Hg(parseFloat(t) / 100) : Hg(parseFloat(t));
}
function Qb(e, t, r) {
  return r < 0 ? r += 1 : r > 1 && (r -= 1), r * 6 < 1 ? e + (t - e) * r * 6 : r * 2 < 1 ? t : r * 3 < 2 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function Fl(e, t, r) {
  return e + (t - e) * r;
}
function Fo(e, t, r, n, i) {
  return e[0] = t, e[1] = r, e[2] = n, e[3] = i, e;
}
function v_(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
}
var X6 = new Ov(20), Nm = null;
function Ad(e, t) {
  Nm && v_(Nm, t), Nm = X6.put(e, Nm || t.slice());
}
function Pi(e, t) {
  if (e) {
    t = t || [];
    var r = X6.get(e);
    if (r)
      return v_(t, r);
    e = e + "";
    var n = e.replace(/ /g, "").toLowerCase();
    if (n in $F)
      return v_(t, $F[n]), Ad(e, t), t;
    var i = n.length;
    if (n.charAt(0) === "#") {
      if (i === 4 || i === 5) {
        var o = parseInt(n.slice(1, 4), 16);
        if (!(o >= 0 && o <= 4095)) {
          Fo(t, 0, 0, 0, 1);
          return;
        }
        return Fo(t, (o & 3840) >> 4 | (o & 3840) >> 8, o & 240 | (o & 240) >> 4, o & 15 | (o & 15) << 4, i === 5 ? parseInt(n.slice(4), 16) / 15 : 1), Ad(e, t), t;
      } else if (i === 7 || i === 9) {
        var o = parseInt(n.slice(1, 7), 16);
        if (!(o >= 0 && o <= 16777215)) {
          Fo(t, 0, 0, 0, 1);
          return;
        }
        return Fo(t, (o & 16711680) >> 16, (o & 65280) >> 8, o & 255, i === 9 ? parseInt(n.slice(7), 16) / 255 : 1), Ad(e, t), t;
      }
      return;
    }
    var a = n.indexOf("("), s = n.indexOf(")");
    if (a !== -1 && s + 1 === i) {
      var l = n.substr(0, a), u = n.substr(a + 1, s - (a + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? Fo(t, +u[0], +u[1], +u[2], 1) : Fo(t, 0, 0, 0, 1);
          c = _c(u.pop());
        case "rgb":
          if (u.length >= 3)
            return Fo(t, Zb(u[0]), Zb(u[1]), Zb(u[2]), u.length === 3 ? c : _c(u[3])), Ad(e, t), t;
          Fo(t, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            Fo(t, 0, 0, 0, 1);
            return;
          }
          return u[3] = _c(u[3]), m_(u, t), Ad(e, t), t;
        case "hsl":
          if (u.length !== 3) {
            Fo(t, 0, 0, 0, 1);
            return;
          }
          return m_(u, t), Ad(e, t), t;
        default:
          return;
      }
    }
    Fo(t, 0, 0, 0, 1);
  }
}
function m_(e, t) {
  var r = (parseFloat(e[0]) % 360 + 360) % 360 / 360, n = _c(e[1]), i = _c(e[2]), o = i <= 0.5 ? i * (n + 1) : i + n - i * n, a = i * 2 - o;
  return t = t || [], Fo(t, Ta(Qb(a, o, r + 1 / 3) * 255), Ta(Qb(a, o, r) * 255), Ta(Qb(a, o, r - 1 / 3) * 255), 1), e.length === 4 && (t[3] = e[3]), t;
}
function k0e(e) {
  if (e) {
    var t = e[0] / 255, r = e[1] / 255, n = e[2] / 255, i = Math.min(t, r, n), o = Math.max(t, r, n), a = o - i, s = (o + i) / 2, l, u;
    if (a === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = a / (o + i) : u = a / (2 - o - i);
      var c = ((o - t) / 6 + a / 2) / a, d = ((o - r) / 6 + a / 2) / a, h = ((o - n) / 6 + a / 2) / a;
      t === o ? l = h - d : r === o ? l = 1 / 3 + c - h : n === o && (l = 2 / 3 + d - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var f = [l * 360, u, s];
    return e[3] != null && f.push(e[3]), f;
  }
}
function tC(e, t) {
  var r = Pi(e);
  if (r) {
    for (var n = 0; n < 3; n++)
      t < 0 ? r[n] = r[n] * (1 - t) | 0 : r[n] = (255 - r[n]) * t + r[n] | 0, r[n] > 255 ? r[n] = 255 : r[n] < 0 && (r[n] = 0);
    return Pa(r, r.length === 4 ? "rgba" : "rgb");
  }
}
function V0e(e) {
  var t = Pi(e);
  if (t)
    return ((1 << 24) + (t[0] << 16) + (t[1] << 8) + +t[2]).toString(16).slice(1);
}
function ig(e, t, r) {
  if (!(!(t && t.length) || !(e >= 0 && e <= 1))) {
    r = r || [];
    var n = e * (t.length - 1), i = Math.floor(n), o = Math.ceil(n), a = t[i], s = t[o], l = n - i;
    return r[0] = Ta(Fl(a[0], s[0], l)), r[1] = Ta(Fl(a[1], s[1], l)), r[2] = Ta(Fl(a[2], s[2], l)), r[3] = Hg(Fl(a[3], s[3], l)), r;
  }
}
var B0e = ig;
function GM(e, t, r) {
  if (!(!(t && t.length) || !(e >= 0 && e <= 1))) {
    var n = e * (t.length - 1), i = Math.floor(n), o = Math.ceil(n), a = Pi(t[i]), s = Pi(t[o]), l = n - i, u = Pa([
      Ta(Fl(a[0], s[0], l)),
      Ta(Fl(a[1], s[1], l)),
      Ta(Fl(a[2], s[2], l)),
      Hg(Fl(a[3], s[3], l))
    ], "rgba");
    return r ? {
      color: u,
      leftIndex: i,
      rightIndex: o,
      value: n
    } : u;
  }
}
var $0e = GM;
function Th(e, t, r, n) {
  var i = Pi(e);
  if (e)
    return i = k0e(i), t != null && (i[0] = N0e(t)), r != null && (i[1] = _c(r)), n != null && (i[2] = _c(n)), Pa(m_(i), "rgba");
}
function Gg(e, t) {
  var r = Pi(e);
  if (r && t != null)
    return r[3] = Hg(t), Pa(r, "rgba");
}
function Pa(e, t) {
  if (!(!e || !e.length)) {
    var r = e[0] + "," + e[1] + "," + e[2];
    return (t === "rgba" || t === "hsva" || t === "hsla") && (r += "," + e[3]), t + "(" + r + ")";
  }
}
function zg(e, t) {
  var r = Pi(e);
  return r ? (0.299 * r[0] + 0.587 * r[1] + 0.114 * r[2]) * r[3] / 255 + (1 - r[3]) * t : 0;
}
function H0e() {
  return Pa([
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255)
  ], "rgb");
}
var HF = new Ov(100);
function rC(e) {
  if (He(e)) {
    var t = HF.get(e);
    return t || (t = tC(e, -0.1), HF.put(e, t)), t;
  } else if (Dv(e)) {
    var r = ge({}, e);
    return r.colorStops = Ee(e.colorStops, function(n) {
      return {
        offset: n.offset,
        color: tC(n.color, -0.1)
      };
    }), r;
  }
  return e;
}
const G0e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fastLerp: ig,
  fastMapToColor: B0e,
  lerp: GM,
  lift: tC,
  liftColor: rC,
  lum: zg,
  mapToColor: $0e,
  modifyAlpha: Gg,
  modifyHSL: Th,
  parse: Pi,
  random: H0e,
  stringify: Pa,
  toHex: V0e
}, Symbol.toStringTag, { value: "Module" }));
var nC = Math.round;
function Wg(e) {
  var t;
  if (!e || e === "transparent")
    e = "none";
  else if (typeof e == "string" && e.indexOf("rgba") > -1) {
    var r = Pi(e);
    r && (e = "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")", t = r[3]);
  }
  return {
    color: e,
    opacity: t ?? 1
  };
}
var GF = 1e-4;
function Nl(e) {
  return e < GF && e > -GF;
}
function km(e) {
  return nC(e * 1e3) / 1e3;
}
function y_(e) {
  return nC(e * 1e4) / 1e4;
}
function z0e(e) {
  return "matrix(" + km(e[0]) + "," + km(e[1]) + "," + km(e[2]) + "," + km(e[3]) + "," + y_(e[4]) + "," + y_(e[5]) + ")";
}
var W0e = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function j0e(e, t, r) {
  return r === "top" ? e += t / 2 : r === "bottom" && (e -= t / 2), e;
}
function U0e(e) {
  return e && (e.shadowBlur || e.shadowOffsetX || e.shadowOffsetY);
}
function K0e(e) {
  var t = e.style, r = e.getGlobalScale();
  return [
    t.shadowColor,
    (t.shadowBlur || 0).toFixed(2),
    (t.shadowOffsetX || 0).toFixed(2),
    (t.shadowOffsetY || 0).toFixed(2),
    r[0],
    r[1]
  ].join(",");
}
function Z6(e) {
  return e && !!e.image;
}
function Y0e(e) {
  return e && !!e.svgElement;
}
function zM(e) {
  return Z6(e) || Y0e(e);
}
function Q6(e) {
  return e.type === "linear";
}
function J6(e) {
  return e.type === "radial";
}
function eW(e) {
  return e && (e.type === "linear" || e.type === "radial");
}
function YS(e) {
  return "url(#" + e + ")";
}
function tW(e) {
  var t = e.getGlobalScale(), r = Math.max(t[0], t[1]);
  return Math.max(Math.ceil(Math.log(r) / Math.log(10)), 1);
}
function rW(e) {
  var t = e.x || 0, r = e.y || 0, n = (e.rotation || 0) * eg, i = bt(e.scaleX, 1), o = bt(e.scaleY, 1), a = e.skewX || 0, s = e.skewY || 0, l = [];
  return (t || r) && l.push("translate(" + t + "px," + r + "px)"), n && l.push("rotate(" + n + ")"), (i !== 1 || o !== 1) && l.push("scale(" + i + "," + o + ")"), (a || s) && l.push("skew(" + nC(a * eg) + "deg, " + nC(s * eg) + "deg)"), l.join(" ");
}
var q0e = function() {
  return nr.hasGlobalWindow && at(window.btoa) ? function(e) {
    return window.btoa(unescape(encodeURIComponent(e)));
  } : typeof Buffer < "u" ? function(e) {
    return Buffer.from(e).toString("base64");
  } : function(e) {
    return process.env.NODE_ENV !== "production" && Ko("Base64 isn't natively supported in the current environment."), null;
  };
}(), C_ = Array.prototype.slice;
function Is(e, t, r) {
  return (t - e) * r + e;
}
function Jb(e, t, r, n) {
  for (var i = t.length, o = 0; o < i; o++)
    e[o] = Is(t[o], r[o], n);
  return e;
}
function X0e(e, t, r, n) {
  for (var i = t.length, o = i && t[0].length, a = 0; a < i; a++) {
    e[a] || (e[a] = []);
    for (var s = 0; s < o; s++)
      e[a][s] = Is(t[a][s], r[a][s], n);
  }
  return e;
}
function Vm(e, t, r, n) {
  for (var i = t.length, o = 0; o < i; o++)
    e[o] = t[o] + r[o] * n;
  return e;
}
function zF(e, t, r, n) {
  for (var i = t.length, o = i && t[0].length, a = 0; a < i; a++) {
    e[a] || (e[a] = []);
    for (var s = 0; s < o; s++)
      e[a][s] = t[a][s] + r[a][s] * n;
  }
  return e;
}
function Z0e(e, t) {
  for (var r = e.length, n = t.length, i = r > n ? t : e, o = Math.min(r, n), a = i[o - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = o; s < Math.max(r, n); s++)
    i.push({
      offset: a.offset,
      color: a.color.slice()
    });
}
function Q0e(e, t, r) {
  var n = e, i = t;
  if (!(!n.push || !i.push)) {
    var o = n.length, a = i.length;
    if (o !== a) {
      var s = o > a;
      if (s)
        n.length = a;
      else
        for (var l = o; l < a; l++)
          n.push(r === 1 ? i[l] : C_.call(i[l]));
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (r === 1)
        isNaN(n[l]) && (n[l] = i[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(n[l][c]) && (n[l][c] = i[l][c]);
  }
}
function og(e) {
  if (Jn(e)) {
    var t = e.length;
    if (Jn(e[0])) {
      for (var r = [], n = 0; n < t; n++)
        r.push(C_.call(e[n]));
      return r;
    }
    return C_.call(e);
  }
  return e;
}
function i0(e) {
  return e[0] = Math.floor(e[0]) || 0, e[1] = Math.floor(e[1]) || 0, e[2] = Math.floor(e[2]) || 0, e[3] = e[3] == null ? 1 : e[3], "rgba(" + e.join(",") + ")";
}
function J0e(e) {
  return Jn(e && e[0]) ? 2 : 1;
}
var Bm = 0, o0 = 1, nW = 2, Ap = 3, S_ = 4, w_ = 5, WF = 6;
function jF(e) {
  return e === S_ || e === w_;
}
function $m(e) {
  return e === o0 || e === nW;
}
var Jf = [0, 0, 0, 0], eCe = function() {
  function e(t) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
  }
  return e.prototype.isFinished = function() {
    return this._finished;
  }, e.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, e.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, e.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, e.prototype.addKeyframe = function(t, r, n) {
    this._needsSort = !0;
    var i = this.keyframes, o = i.length, a = !1, s = WF, l = r;
    if (Jn(r)) {
      var u = J0e(r);
      s = u, (u === 1 && !sr(r[0]) || u === 2 && !sr(r[0][0])) && (a = !0);
    } else if (sr(r) && !nu(r))
      s = Bm;
    else if (He(r))
      if (!isNaN(+r))
        s = Bm;
      else {
        var c = Pi(r);
        c && (l = c, s = Ap);
      }
    else if (Dv(r)) {
      var d = ge({}, l);
      d.colorStops = Ee(r.colorStops, function(f) {
        return {
          offset: f.offset,
          color: Pi(f.color)
        };
      }), Q6(r) ? s = S_ : J6(r) && (s = w_), l = d;
    }
    o === 0 ? this.valType = s : (s !== this.valType || s === WF) && (a = !0), this.discrete = this.discrete || a;
    var h = {
      time: t,
      value: l,
      rawValue: r,
      percent: 0
    };
    return n && (h.easing = n, h.easingFunc = at(n) ? n : ng[n] || HM(n)), i.push(h), h;
  }, e.prototype.prepare = function(t, r) {
    var n = this.keyframes;
    this._needsSort && n.sort(function(g, v) {
      return g.time - v.time;
    });
    for (var i = this.valType, o = n.length, a = n[o - 1], s = this.discrete, l = $m(i), u = jF(i), c = 0; c < o; c++) {
      var d = n[c], h = d.value, f = a.value;
      d.percent = d.time / t, s || (l && c !== o - 1 ? Q0e(h, f, i) : u && Z0e(h.colorStops, f.colorStops));
    }
    if (!s && i !== w_ && r && this.needsAnimate() && r.needsAnimate() && i === r.valType && !r._finished) {
      this._additiveTrack = r;
      for (var p = n[0].value, c = 0; c < o; c++)
        i === Bm ? n[c].additiveValue = n[c].value - p : i === Ap ? n[c].additiveValue = Vm([], n[c].value, p, -1) : $m(i) && (n[c].additiveValue = i === o0 ? Vm([], n[c].value, p, -1) : zF([], n[c].value, p, -1));
    }
  }, e.prototype.step = function(t, r) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var n = this._additiveTrack != null, i = n ? "additiveValue" : "value", o = this.valType, a = this.keyframes, s = a.length, l = this.propName, u = o === Ap, c, d = this._lastFr, h = Math.min, f, p;
      if (s === 1)
        f = p = a[0];
      else {
        if (r < 0)
          c = 0;
        else if (r < this._lastFrP) {
          var g = h(d + 1, s - 1);
          for (c = g; c >= 0 && !(a[c].percent <= r); c--)
            ;
          c = h(c, s - 2);
        } else {
          for (c = d; c < s && !(a[c].percent > r); c++)
            ;
          c = h(c - 1, s - 2);
        }
        p = a[c + 1], f = a[c];
      }
      if (f && p) {
        this._lastFr = c, this._lastFrP = r;
        var v = p.percent - f.percent, m = v === 0 ? 1 : h((r - f.percent) / v, 1);
        p.easingFunc && (m = p.easingFunc(m));
        var y = n ? this._additiveValue : u ? Jf : t[l];
        if (($m(o) || u) && !y && (y = this._additiveValue = []), this.discrete)
          t[l] = m < 1 ? f.rawValue : p.rawValue;
        else if ($m(o))
          o === o0 ? Jb(y, f[i], p[i], m) : X0e(y, f[i], p[i], m);
        else if (jF(o)) {
          var C = f[i], S = p[i], b = o === S_;
          t[l] = {
            type: b ? "linear" : "radial",
            x: Is(C.x, S.x, m),
            y: Is(C.y, S.y, m),
            colorStops: Ee(C.colorStops, function(x, R) {
              var _ = S.colorStops[R];
              return {
                offset: Is(x.offset, _.offset, m),
                color: i0(Jb([], x.color, _.color, m))
              };
            }),
            global: S.global
          }, b ? (t[l].x2 = Is(C.x2, S.x2, m), t[l].y2 = Is(C.y2, S.y2, m)) : t[l].r = Is(C.r, S.r, m);
        } else if (u)
          Jb(y, f[i], p[i], m), n || (t[l] = i0(y));
        else {
          var w = Is(f[i], p[i], m);
          n ? this._additiveValue = w : t[l] = w;
        }
        n && this._addToTarget(t);
      }
    }
  }, e.prototype._addToTarget = function(t) {
    var r = this.valType, n = this.propName, i = this._additiveValue;
    r === Bm ? t[n] = t[n] + i : r === Ap ? (Pi(t[n], Jf), Vm(Jf, Jf, i, 1), t[n] = i0(Jf)) : r === o0 ? Vm(t[n], t[n], i, 1) : r === nW && zF(t[n], t[n], i, 1);
  }, e;
}(), WM = function() {
  function e(t, r, n, i) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = r, r && i) {
      Ko("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = i, this._allowDiscrete = n;
  }
  return e.prototype.getMaxTime = function() {
    return this._maxTime;
  }, e.prototype.getDelay = function() {
    return this._delay;
  }, e.prototype.getLoop = function() {
    return this._loop;
  }, e.prototype.getTarget = function() {
    return this._target;
  }, e.prototype.changeTarget = function(t) {
    this._target = t;
  }, e.prototype.when = function(t, r, n) {
    return this.whenWithKeys(t, r, jt(r), n);
  }, e.prototype.whenWithKeys = function(t, r, n, i) {
    for (var o = this._tracks, a = 0; a < n.length; a++) {
      var s = n[a], l = o[s];
      if (!l) {
        l = o[s] = new eCe(s);
        var u = void 0, c = this._getAdditiveTrack(s);
        if (c) {
          var d = c.keyframes, h = d[d.length - 1];
          u = h && h.value, c.valType === Ap && u && (u = i0(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        t > 0 && l.addKeyframe(0, og(u), i), this._trackKeys.push(s);
      }
      l.addKeyframe(t, og(r[s]), i);
    }
    return this._maxTime = Math.max(this._maxTime, t), this;
  }, e.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, e.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, e.prototype.isPaused = function() {
    return !!this._paused;
  }, e.prototype.duration = function(t) {
    return this._maxTime = t, this._force = !0, this;
  }, e.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var t = this._doneCbs;
    if (t)
      for (var r = t.length, n = 0; n < r; n++)
        t[n].call(this);
  }, e.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var t = this.animation, r = this._abortedCbs;
    if (t && t.removeClip(this._clip), this._clip = null, r)
      for (var n = 0; n < r.length; n++)
        r[n].call(this);
  }, e.prototype._setTracksFinished = function() {
    for (var t = this._tracks, r = this._trackKeys, n = 0; n < r.length; n++)
      t[r[n]].setFinished();
  }, e.prototype._getAdditiveTrack = function(t) {
    var r, n = this._additiveAnimators;
    if (n)
      for (var i = 0; i < n.length; i++) {
        var o = n[i].getTrack(t);
        o && (r = o);
      }
    return r;
  }, e.prototype.start = function(t) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var r = this, n = [], i = this._maxTime || 0, o = 0; o < this._trackKeys.length; o++) {
        var a = this._trackKeys[o], s = this._tracks[a], l = this._getAdditiveTrack(a), u = s.keyframes, c = u.length;
        if (s.prepare(i, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var d = u[c - 1];
            d && (r._target[s.propName] = d.rawValue), s.setFinished();
          } else
            n.push(s);
      }
      if (n.length || this._force) {
        var h = new L0e({
          life: i,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(f) {
            r._started = 2;
            var p = r._additiveAnimators;
            if (p) {
              for (var g = !1, v = 0; v < p.length; v++)
                if (p[v]._clip) {
                  g = !0;
                  break;
                }
              g || (r._additiveAnimators = null);
            }
            for (var v = 0; v < n.length; v++)
              n[v].step(r._target, f);
            var m = r._onframeCbs;
            if (m)
              for (var v = 0; v < m.length; v++)
                m[v](r._target, f);
          },
          ondestroy: function() {
            r._doneCallback();
          }
        });
        this._clip = h, this.animation && this.animation.addClip(h), t && h.setEasing(t);
      } else
        this._doneCallback();
      return this;
    }
  }, e.prototype.stop = function(t) {
    if (this._clip) {
      var r = this._clip;
      t && r.onframe(1), this._abortedCallback();
    }
  }, e.prototype.delay = function(t) {
    return this._delay = t, this;
  }, e.prototype.during = function(t) {
    return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
  }, e.prototype.done = function(t) {
    return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
  }, e.prototype.aborted = function(t) {
    return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
  }, e.prototype.getClip = function() {
    return this._clip;
  }, e.prototype.getTrack = function(t) {
    return this._tracks[t];
  }, e.prototype.getTracks = function() {
    var t = this;
    return Ee(this._trackKeys, function(r) {
      return t._tracks[r];
    });
  }, e.prototype.stopTracks = function(t, r) {
    if (!t.length || !this._clip)
      return !0;
    for (var n = this._tracks, i = this._trackKeys, o = 0; o < t.length; o++) {
      var a = n[t[o]];
      a && !a.isFinished() && (r ? a.step(this._target, 1) : this._started === 1 && a.step(this._target, 0), a.setFinished());
    }
    for (var s = !0, o = 0; o < i.length; o++)
      if (!n[i[o]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, e.prototype.saveTo = function(t, r, n) {
    if (t) {
      r = r || this._trackKeys;
      for (var i = 0; i < r.length; i++) {
        var o = r[i], a = this._tracks[o];
        if (!(!a || a.isFinished())) {
          var s = a.keyframes, l = s[n ? 0 : s.length - 1];
          l && (t[o] = og(l.rawValue));
        }
      }
    }
  }, e.prototype.__changeFinalValue = function(t, r) {
    r = r || jt(t);
    for (var n = 0; n < r.length; n++) {
      var i = r[n], o = this._tracks[i];
      if (o) {
        var a = o.keyframes;
        if (a.length > 1) {
          var s = a.pop();
          o.addKeyframe(s.time, t[i]), o.prepare(this._maxTime, o.getAdditiveTrack());
        }
      }
    }
  }, e;
}();
function ph() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var tCe = function(e) {
  Ur(t, e);
  function t(r) {
    var n = e.call(this) || this;
    return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, r = r || {}, n.stage = r.stage || {}, n;
  }
  return t.prototype.addClip = function(r) {
    r.animation && this.removeClip(r), this._head ? (this._tail.next = r, r.prev = this._tail, r.next = null, this._tail = r) : this._head = this._tail = r, r.animation = this;
  }, t.prototype.addAnimator = function(r) {
    r.animation = this;
    var n = r.getClip();
    n && this.addClip(n);
  }, t.prototype.removeClip = function(r) {
    if (r.animation) {
      var n = r.prev, i = r.next;
      n ? n.next = i : this._head = i, i ? i.prev = n : this._tail = n, r.next = r.prev = r.animation = null;
    }
  }, t.prototype.removeAnimator = function(r) {
    var n = r.getClip();
    n && this.removeClip(n), r.animation = null;
  }, t.prototype.update = function(r) {
    for (var n = ph() - this._pausedTime, i = n - this._time, o = this._head; o; ) {
      var a = o.next, s = o.step(n, i);
      s && (o.ondestroy(), this.removeClip(o)), o = a;
    }
    this._time = n, r || (this.trigger("frame", i), this.stage.update && this.stage.update());
  }, t.prototype._startLoop = function() {
    var r = this;
    this._running = !0;
    function n() {
      r._running && (Q0(n), !r._paused && r.update());
    }
    Q0(n);
  }, t.prototype.start = function() {
    this._running || (this._time = ph(), this._pausedTime = 0, this._startLoop());
  }, t.prototype.stop = function() {
    this._running = !1;
  }, t.prototype.pause = function() {
    this._paused || (this._pauseStart = ph(), this._paused = !0);
  }, t.prototype.resume = function() {
    this._paused && (this._pausedTime += ph() - this._pauseStart, this._paused = !1);
  }, t.prototype.clear = function() {
    for (var r = this._head; r; ) {
      var n = r.next;
      r.prev = r.next = r.animation = null, r = n;
    }
    this._head = this._tail = null;
  }, t.prototype.isFinished = function() {
    return this._head == null;
  }, t.prototype.animate = function(r, n) {
    n = n || {}, this.start();
    var i = new WM(r, n.loop);
    return this.addAnimator(i), i;
  }, t;
}(na), rCe = 300, e1 = nr.domSupported, t1 = function() {
  var e = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], t = [
    "touchstart",
    "touchend",
    "touchmove"
  ], r = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, n = Ee(e, function(i) {
    var o = i.replace("mouse", "pointer");
    return r.hasOwnProperty(o) ? o : i;
  });
  return {
    mouse: e,
    touch: t,
    pointer: n
  };
}(), UF = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, KF = !1;
function b_(e) {
  var t = e.pointerType;
  return t === "pen" || t === "touch";
}
function nCe(e) {
  e.touching = !0, e.touchTimer != null && (clearTimeout(e.touchTimer), e.touchTimer = null), e.touchTimer = setTimeout(function() {
    e.touching = !1, e.touchTimer = null;
  }, 700);
}
function r1(e) {
  e && (e.zrByTouch = !0);
}
function iCe(e, t) {
  return No(e.dom, new oCe(e, t), !0);
}
function iW(e, t) {
  for (var r = t, n = !1; r && r.nodeType !== 9 && !(n = r.domBelongToZr || r !== t && r === e.painterRoot); )
    r = r.parentNode;
  return n;
}
var oCe = /* @__PURE__ */ function() {
  function e(t, r) {
    this.stopPropagation = un, this.stopImmediatePropagation = un, this.preventDefault = un, this.type = r.type, this.target = this.currentTarget = t.dom, this.pointerType = r.pointerType, this.clientX = r.clientX, this.clientY = r.clientY;
  }
  return e;
}(), ga = {
  mousedown: function(e) {
    e = No(this.dom, e), this.__mayPointerCapture = [e.zrX, e.zrY], this.trigger("mousedown", e);
  },
  mousemove: function(e) {
    e = No(this.dom, e);
    var t = this.__mayPointerCapture;
    t && (e.zrX !== t[0] || e.zrY !== t[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    e = No(this.dom, e), this.__togglePointerCapture(!1), this.trigger("mouseup", e);
  },
  mouseout: function(e) {
    e = No(this.dom, e);
    var t = e.toElement || e.relatedTarget;
    iW(this, t) || (this.__pointerCapturing && (e.zrEventControl = "no_globalout"), this.trigger("mouseout", e));
  },
  wheel: function(e) {
    KF = !0, e = No(this.dom, e), this.trigger("mousewheel", e);
  },
  mousewheel: function(e) {
    KF || (e = No(this.dom, e), this.trigger("mousewheel", e));
  },
  touchstart: function(e) {
    e = No(this.dom, e), r1(e), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(e, "start"), ga.mousemove.call(this, e), ga.mousedown.call(this, e);
  },
  touchmove: function(e) {
    e = No(this.dom, e), r1(e), this.handler.processGesture(e, "change"), ga.mousemove.call(this, e);
  },
  touchend: function(e) {
    e = No(this.dom, e), r1(e), this.handler.processGesture(e, "end"), ga.mouseup.call(this, e), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < rCe && ga.click.call(this, e);
  },
  pointerdown: function(e) {
    ga.mousedown.call(this, e);
  },
  pointermove: function(e) {
    b_(e) || ga.mousemove.call(this, e);
  },
  pointerup: function(e) {
    ga.mouseup.call(this, e);
  },
  pointerout: function(e) {
    b_(e) || ga.mouseout.call(this, e);
  }
};
$(["click", "dblclick", "contextmenu"], function(e) {
  ga[e] = function(t) {
    t = No(this.dom, t), this.trigger(e, t);
  };
});
var x_ = {
  pointermove: function(e) {
    b_(e) || x_.mousemove.call(this, e);
  },
  pointerup: function(e) {
    x_.mouseup.call(this, e);
  },
  mousemove: function(e) {
    this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    var t = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", e), t && (e.zrEventControl = "only_globalout", this.trigger("mouseout", e));
  }
};
function aCe(e, t) {
  var r = t.domHandlers;
  nr.pointerEventsSupported ? $(t1.pointer, function(n) {
    a0(t, n, function(i) {
      r[n].call(e, i);
    });
  }) : (nr.touchEventsSupported && $(t1.touch, function(n) {
    a0(t, n, function(i) {
      r[n].call(e, i), nCe(t);
    });
  }), $(t1.mouse, function(n) {
    a0(t, n, function(i) {
      i = $M(i), t.touching || r[n].call(e, i);
    });
  }));
}
function sCe(e, t) {
  nr.pointerEventsSupported ? $(UF.pointer, r) : nr.touchEventsSupported || $(UF.mouse, r);
  function r(n) {
    function i(o) {
      o = $M(o), iW(e, o.target) || (o = iCe(e, o), t.domHandlers[n].call(e, o));
    }
    a0(t, n, i, { capture: !0 });
  }
}
function a0(e, t, r, n) {
  e.mounted[t] = r, e.listenerOpts[t] = n, p_(e.domTarget, t, r, n);
}
function n1(e) {
  var t = e.mounted;
  for (var r in t)
    t.hasOwnProperty(r) && v0e(e.domTarget, r, t[r], e.listenerOpts[r]);
  e.mounted = {};
}
var YF = /* @__PURE__ */ function() {
  function e(t, r) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = r;
  }
  return e;
}(), lCe = function(e) {
  Ur(t, e);
  function t(r, n) {
    var i = e.call(this) || this;
    return i.__pointerCapturing = !1, i.dom = r, i.painterRoot = n, i._localHandlerScope = new YF(r, ga), e1 && (i._globalHandlerScope = new YF(document, x_)), aCe(i, i._localHandlerScope), i;
  }
  return t.prototype.dispose = function() {
    n1(this._localHandlerScope), e1 && n1(this._globalHandlerScope);
  }, t.prototype.setCursor = function(r) {
    this.dom.style && (this.dom.style.cursor = r || "default");
  }, t.prototype.__togglePointerCapture = function(r) {
    if (this.__mayPointerCapture = null, e1 && +this.__pointerCapturing ^ +r) {
      this.__pointerCapturing = r;
      var n = this._globalHandlerScope;
      r ? sCe(this, n) : n1(n);
    }
  }, t;
}(na), oW = 1;
nr.hasGlobalWindow && (oW = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var iC = oW, E_ = 0.4, R_ = "#333", __ = "#ccc", uCe = "#eee", qF = Iv, XF = 5e-5;
function Du(e) {
  return e > XF || e < -XF;
}
var Au = [], Id = [], i1 = Zi(), o1 = Math.abs, cCe = function() {
  function e() {
  }
  return e.prototype.getLocalTransform = function(t) {
    return e.getLocalTransform(this, t);
  }, e.prototype.setPosition = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.prototype.setScale = function(t) {
    this.scaleX = t[0], this.scaleY = t[1];
  }, e.prototype.setSkew = function(t) {
    this.skewX = t[0], this.skewY = t[1];
  }, e.prototype.setOrigin = function(t) {
    this.originX = t[0], this.originY = t[1];
  }, e.prototype.needLocalTransform = function() {
    return Du(this.rotation) || Du(this.x) || Du(this.y) || Du(this.scaleX - 1) || Du(this.scaleY - 1) || Du(this.skewX) || Du(this.skewY);
  }, e.prototype.updateTransform = function() {
    var t = this.parent && this.parent.transform, r = this.needLocalTransform(), n = this.transform;
    if (!(r || t)) {
      n && (qF(n), this.invTransform = null);
      return;
    }
    n = n || Zi(), r ? this.getLocalTransform(n) : qF(n), t && (r ? us(n, t, n) : US(n, t)), this.transform = n, this._resolveGlobalScaleRatio(n);
  }, e.prototype._resolveGlobalScaleRatio = function(t) {
    var r = this.globalScaleRatio;
    if (r != null && r !== 1) {
      this.getGlobalScale(Au);
      var n = Au[0] < 0 ? -1 : 1, i = Au[1] < 0 ? -1 : 1, o = ((Au[0] - n) * r + n) / Au[0] || 0, a = ((Au[1] - i) * r + i) / Au[1] || 0;
      t[0] *= o, t[1] *= o, t[2] *= a, t[3] *= a;
    }
    this.invTransform = this.invTransform || Zi(), id(this.invTransform, t);
  }, e.prototype.getComputedTransform = function() {
    for (var t = this, r = []; t; )
      r.push(t), t = t.parent;
    for (; t = r.pop(); )
      t.updateTransform();
    return this.transform;
  }, e.prototype.setLocalTransform = function(t) {
    if (t) {
      var r = t[0] * t[0] + t[1] * t[1], n = t[2] * t[2] + t[3] * t[3], i = Math.atan2(t[1], t[0]), o = Math.PI / 2 + i - Math.atan2(t[3], t[2]);
      n = Math.sqrt(n) * Math.cos(o), r = Math.sqrt(r), this.skewX = o, this.skewY = 0, this.rotation = -i, this.x = +t[4], this.y = +t[5], this.scaleX = r, this.scaleY = n, this.originX = 0, this.originY = 0;
    }
  }, e.prototype.decomposeTransform = function() {
    if (this.transform) {
      var t = this.parent, r = this.transform;
      t && t.transform && (t.invTransform = t.invTransform || Zi(), us(Id, t.invTransform, r), r = Id);
      var n = this.originX, i = this.originY;
      (n || i) && (i1[4] = n, i1[5] = i, us(Id, r, i1), Id[4] -= n, Id[5] -= i, r = Id), this.setLocalTransform(r);
    }
  }, e.prototype.getGlobalScale = function(t) {
    var r = this.transform;
    return t = t || [], r ? (t[0] = Math.sqrt(r[0] * r[0] + r[1] * r[1]), t[1] = Math.sqrt(r[2] * r[2] + r[3] * r[3]), r[0] < 0 && (t[0] = -t[0]), r[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
  }, e.prototype.transformCoordToLocal = function(t, r) {
    var n = [t, r], i = this.invTransform;
    return i && Un(n, n, i), n;
  }, e.prototype.transformCoordToGlobal = function(t, r) {
    var n = [t, r], i = this.transform;
    return i && Un(n, n, i), n;
  }, e.prototype.getLineScale = function() {
    var t = this.transform;
    return t && o1(t[0] - 1) > 1e-10 && o1(t[3] - 1) > 1e-10 ? Math.sqrt(o1(t[0] * t[3] - t[2] * t[1])) : 1;
  }, e.prototype.copyTransform = function(t) {
    aW(this, t);
  }, e.getLocalTransform = function(t, r) {
    r = r || [];
    var n = t.originX || 0, i = t.originY || 0, o = t.scaleX, a = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, d = t.y, h = t.skewX ? Math.tan(t.skewX) : 0, f = t.skewY ? Math.tan(-t.skewY) : 0;
    if (n || i || s || l) {
      var p = n + s, g = i + l;
      r[4] = -p * o - h * g * a, r[5] = -g * a - f * p * o;
    } else
      r[4] = r[5] = 0;
    return r[0] = o, r[3] = a, r[1] = f * o, r[2] = h * a, u && Cu(r, r, u), r[4] += n + c, r[5] += i + d, r;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
  }(), e;
}(), gs = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function aW(e, t) {
  for (var r = 0; r < gs.length; r++) {
    var n = gs[r];
    e[n] = t[n];
  }
}
const $s = cCe;
var ZF = {};
function wo(e, t) {
  t = t || tu;
  var r = ZF[t];
  r || (r = ZF[t] = new Ov(500));
  var n = r.get(e);
  return n == null && (n = Ia.measureText(e, t).width, r.put(e, n)), n;
}
function QF(e, t, r, n) {
  var i = wo(e, t), o = qS(t), a = Ip(0, i, r), s = ih(0, o, n), l = new At(a, s, i, o);
  return l;
}
function Lv(e, t, r, n) {
  var i = ((e || "") + "").split(`
`), o = i.length;
  if (o === 1)
    return QF(i[0], t, r, n);
  for (var a = new At(0, 0, 0, 0), s = 0; s < i.length; s++) {
    var l = QF(i[s], t, r, n);
    s === 0 ? a.copy(l) : a.union(l);
  }
  return a;
}
function Ip(e, t, r) {
  return r === "right" ? e -= t : r === "center" && (e -= t / 2), e;
}
function ih(e, t, r) {
  return r === "middle" ? e -= t / 2 : r === "bottom" && (e -= t), e;
}
function qS(e) {
  return wo("", e);
}
function La(e, t) {
  return typeof e == "string" ? e.lastIndexOf("%") >= 0 ? parseFloat(e) / 100 * t : parseFloat(e) : e;
}
function oC(e, t, r) {
  var n = t.position || "inside", i = t.distance != null ? t.distance : 5, o = r.height, a = r.width, s = o / 2, l = r.x, u = r.y, c = "left", d = "top";
  if (n instanceof Array)
    l += La(n[0], r.width), u += La(n[1], r.height), c = null, d = null;
  else
    switch (n) {
      case "left":
        l -= i, u += s, c = "right", d = "middle";
        break;
      case "right":
        l += i + a, u += s, d = "middle";
        break;
      case "top":
        l += a / 2, u -= i, c = "center", d = "bottom";
        break;
      case "bottom":
        l += a / 2, u += o + i, c = "center";
        break;
      case "inside":
        l += a / 2, u += s, c = "center", d = "middle";
        break;
      case "insideLeft":
        l += i, u += s, d = "middle";
        break;
      case "insideRight":
        l += a - i, u += s, c = "right", d = "middle";
        break;
      case "insideTop":
        l += a / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += a / 2, u += o - i, c = "center", d = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += a - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += o - i, d = "bottom";
        break;
      case "insideBottomRight":
        l += a - i, u += o - i, c = "right", d = "bottom";
        break;
    }
  return e = e || {}, e.x = l, e.y = u, e.align = c, e.verticalAlign = d, e;
}
var a1 = "__zr_normal__", s1 = gs.concat(["ignore"]), dCe = Jo(gs, function(e, t) {
  return e[t] = !0, e;
}, { ignore: !1 }), Od = {}, hCe = new At(0, 0, 0, 0), XS = function() {
  function e(t) {
    this.id = FM(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
  }
  return e.prototype._init = function(t) {
    this.attr(t);
  }, e.prototype.drift = function(t, r, n) {
    switch (this.draggable) {
      case "horizontal":
        r = 0;
        break;
      case "vertical":
        t = 0;
        break;
    }
    var i = this.transform;
    i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += r, this.decomposeTransform(), this.markRedraw();
  }, e.prototype.beforeUpdate = function() {
  }, e.prototype.afterUpdate = function() {
  }, e.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, e.prototype.updateInnerText = function(t) {
    var r = this._textContent;
    if (r && (!r.ignore || t)) {
      this.textConfig || (this.textConfig = {});
      var n = this.textConfig, i = n.local, o = r.innerTransformable, a = void 0, s = void 0, l = !1;
      o.parent = i ? this : null;
      var u = !1;
      if (o.copyTransform(r), n.position != null) {
        var c = hCe;
        n.layoutRect ? c.copy(n.layoutRect) : c.copy(this.getBoundingRect()), i || c.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(Od, n, c) : oC(Od, n, c), o.x = Od.x, o.y = Od.y, a = Od.align, s = Od.verticalAlign;
        var d = n.origin;
        if (d && n.rotation != null) {
          var h = void 0, f = void 0;
          d === "center" ? (h = c.width * 0.5, f = c.height * 0.5) : (h = La(d[0], c.width), f = La(d[1], c.height)), u = !0, o.originX = -o.x + h + (i ? 0 : c.x), o.originY = -o.y + f + (i ? 0 : c.y);
        }
      }
      n.rotation != null && (o.rotation = n.rotation);
      var p = n.offset;
      p && (o.x += p[0], o.y += p[1], u || (o.originX = -p[0], o.originY = -p[1]));
      var g = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, v = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), m = void 0, y = void 0, C = void 0;
      g && this.canBeInsideText() ? (m = n.insideFill, y = n.insideStroke, (m == null || m === "auto") && (m = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(m), C = !0)) : (m = n.outsideFill, y = n.outsideStroke, (m == null || m === "auto") && (m = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(m), C = !0)), m = m || "#000", (m !== v.fill || y !== v.stroke || C !== v.autoStroke || a !== v.align || s !== v.verticalAlign) && (l = !0, v.fill = m, v.stroke = y, v.autoStroke = C, v.align = a, v.verticalAlign = s, r.setDefaultTextStyle(v)), r.__dirty |= ho, l && r.dirtyStyle(!0);
    }
  }, e.prototype.canBeInsideText = function() {
    return !0;
  }, e.prototype.getInsideTextFill = function() {
    return "#fff";
  }, e.prototype.getInsideTextStroke = function(t) {
    return "#000";
  }, e.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? __ : R_;
  }, e.prototype.getOutsideStroke = function(t) {
    var r = this.__zr && this.__zr.getBackgroundColor(), n = typeof r == "string" && Pi(r);
    n || (n = [255, 255, 255, 1]);
    for (var i = n[3], o = this.__zr.isDarkMode(), a = 0; a < 3; a++)
      n[a] = n[a] * i + (o ? 0 : 255) * (1 - i);
    return n[3] = 1, Pa(n, "rgba");
  }, e.prototype.traverse = function(t, r) {
  }, e.prototype.attrKV = function(t, r) {
    t === "textConfig" ? this.setTextConfig(r) : t === "textContent" ? this.setTextContent(r) : t === "clipPath" ? this.setClipPath(r) : t === "extra" ? (this.extra = this.extra || {}, ge(this.extra, r)) : this[t] = r;
  }, e.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, e.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, e.prototype.attr = function(t, r) {
    if (typeof t == "string")
      this.attrKV(t, r);
    else if (lt(t))
      for (var n = t, i = jt(n), o = 0; o < i.length; o++) {
        var a = i[o];
        this.attrKV(a, t[a]);
      }
    return this.markRedraw(), this;
  }, e.prototype.saveCurrentToNormalState = function(t) {
    this._innerSaveToNormal(t);
    for (var r = this._normalState, n = 0; n < this.animators.length; n++) {
      var i = this.animators[n], o = i.__fromStateTransition;
      if (!(i.getLoop() || o && o !== a1)) {
        var a = i.targetName, s = a ? r[a] : r;
        i.saveTo(s);
      }
    }
  }, e.prototype._innerSaveToNormal = function(t) {
    var r = this._normalState;
    r || (r = this._normalState = {}), t.textConfig && !r.textConfig && (r.textConfig = this.textConfig), this._savePrimaryToNormal(t, r, s1);
  }, e.prototype._savePrimaryToNormal = function(t, r, n) {
    for (var i = 0; i < n.length; i++) {
      var o = n[i];
      t[o] != null && !(o in r) && (r[o] = this[o]);
    }
  }, e.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, e.prototype.getState = function(t) {
    return this.states[t];
  }, e.prototype.ensureState = function(t) {
    var r = this.states;
    return r[t] || (r[t] = {}), r[t];
  }, e.prototype.clearStates = function(t) {
    this.useState(a1, !1, t);
  }, e.prototype.useState = function(t, r, n, i) {
    var o = t === a1, a = this.hasState();
    if (!(!a && o)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(Ft(s, t) >= 0 && (r || s.length === 1))) {
        var u;
        if (this.stateProxy && !o && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !o) {
          Ko("State " + t + " not exists.");
          return;
        }
        o || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || i);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, r, !n && !this.__inHover && l && l.duration > 0, l);
        var d = this._textContent, h = this._textGuide;
        return d && d.useState(t, r, n, c), h && h.useState(t, r, n, c), o ? (this.currentStates = [], this._normalState = {}) : r ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~ho), u;
      }
    }
  }, e.prototype.useStates = function(t, r, n) {
    if (!t.length)
      this.clearStates();
    else {
      var i = [], o = this.currentStates, a = t.length, s = a === o.length;
      if (s) {
        for (var l = 0; l < a; l++)
          if (t[l] !== o[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < a; l++) {
        var u = t[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && i.push(c);
      }
      var d = i[a - 1], h = !!(d && d.hoverLayer || n);
      h && this._toggleHoverLayerFlag(!0);
      var f = this._mergeStates(i), p = this.stateTransition;
      this.saveCurrentToNormalState(f), this._applyStateObj(t.join(","), f, this._normalState, !1, !r && !this.__inHover && p && p.duration > 0, p);
      var g = this._textContent, v = this._textGuide;
      g && g.useStates(t, r, h), v && v.useStates(t, r, h), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !h && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~ho);
    }
  }, e.prototype.isSilent = function() {
    for (var t = this.silent, r = this.parent; !t && r; ) {
      if (r.silent) {
        t = !0;
        break;
      }
      r = r.parent;
    }
    return t;
  }, e.prototype._updateAnimationTargets = function() {
    for (var t = 0; t < this.animators.length; t++) {
      var r = this.animators[t];
      r.targetName && r.changeTarget(this[r.targetName]);
    }
  }, e.prototype.removeState = function(t) {
    var r = Ft(this.currentStates, t);
    if (r >= 0) {
      var n = this.currentStates.slice();
      n.splice(r, 1), this.useStates(n);
    }
  }, e.prototype.replaceState = function(t, r, n) {
    var i = this.currentStates.slice(), o = Ft(i, t), a = Ft(i, r) >= 0;
    o >= 0 ? a ? i.splice(o, 1) : i[o] = r : n && !a && i.push(r), this.useStates(i);
  }, e.prototype.toggleState = function(t, r) {
    r ? this.useState(t, !0) : this.removeState(t);
  }, e.prototype._mergeStates = function(t) {
    for (var r = {}, n, i = 0; i < t.length; i++) {
      var o = t[i];
      ge(r, o), o.textConfig && (n = n || {}, ge(n, o.textConfig));
    }
    return n && (r.textConfig = n), r;
  }, e.prototype._applyStateObj = function(t, r, n, i, o, a) {
    var s = !(r && i);
    r && r.textConfig ? (this.textConfig = ge({}, i ? this.textConfig : n.textConfig), ge(this.textConfig, r.textConfig)) : s && n.textConfig && (this.textConfig = n.textConfig);
    for (var l = {}, u = !1, c = 0; c < s1.length; c++) {
      var d = s1[c], h = o && dCe[d];
      r && r[d] != null ? h ? (u = !0, l[d] = r[d]) : this[d] = r[d] : s && n[d] != null && (h ? (u = !0, l[d] = n[d]) : this[d] = n[d]);
    }
    if (!o)
      for (var c = 0; c < this.animators.length; c++) {
        var f = this.animators[c], p = f.targetName;
        f.getLoop() || f.__changeFinalValue(p ? (r || n)[p] : r || n);
      }
    u && this._transitionState(t, l, a);
  }, e.prototype._attachComponent = function(t) {
    if (t.__zr && !t.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (t === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var r = this.__zr;
    r && t.addSelfToZr(r), t.__zr = r, t.__hostTarget = this;
  }, e.prototype._detachComponent = function(t) {
    t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
  }, e.prototype.getClipPath = function() {
    return this._clipPath;
  }, e.prototype.setClipPath = function(t) {
    this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
  }, e.prototype.removeClipPath = function() {
    var t = this._clipPath;
    t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
  }, e.prototype.getTextContent = function() {
    return this._textContent;
  }, e.prototype.setTextContent = function(t) {
    var r = this._textContent;
    if (r !== t) {
      if (r && r !== t && this.removeTextContent(), process.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      t.innerTransformable = new $s(), this._attachComponent(t), this._textContent = t, this.markRedraw();
    }
  }, e.prototype.setTextConfig = function(t) {
    this.textConfig || (this.textConfig = {}), ge(this.textConfig, t), this.markRedraw();
  }, e.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, e.prototype.removeTextContent = function() {
    var t = this._textContent;
    t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, e.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, e.prototype.setTextGuideLine = function(t) {
    this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
  }, e.prototype.removeTextGuideLine = function() {
    var t = this._textGuide;
    t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
  }, e.prototype.markRedraw = function() {
    this.__dirty |= ho;
    var t = this.__zr;
    t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, e.prototype.dirty = function() {
    this.markRedraw();
  }, e.prototype._toggleHoverLayerFlag = function(t) {
    this.__inHover = t;
    var r = this._textContent, n = this._textGuide;
    r && (r.__inHover = t), n && (n.__inHover = t);
  }, e.prototype.addSelfToZr = function(t) {
    if (this.__zr !== t) {
      this.__zr = t;
      var r = this.animators;
      if (r)
        for (var n = 0; n < r.length; n++)
          t.animation.addAnimator(r[n]);
      this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    if (this.__zr) {
      this.__zr = null;
      var r = this.animators;
      if (r)
        for (var n = 0; n < r.length; n++)
          t.animation.removeAnimator(r[n]);
      this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
    }
  }, e.prototype.animate = function(t, r, n) {
    var i = t ? this[t] : this;
    if (process.env.NODE_ENV !== "production" && !i) {
      Ko('Property "' + t + '" is not existed in element ' + this.id);
      return;
    }
    var o = new WM(i, r, n);
    return t && (o.targetName = t), this.addAnimator(o, t), o;
  }, e.prototype.addAnimator = function(t, r) {
    var n = this.__zr, i = this;
    t.during(function() {
      i.updateDuringAnimation(r);
    }).done(function() {
      var o = i.animators, a = Ft(o, t);
      a >= 0 && o.splice(a, 1);
    }), this.animators.push(t), n && n.animation.addAnimator(t), n && n.wakeUp();
  }, e.prototype.updateDuringAnimation = function(t) {
    this.markRedraw();
  }, e.prototype.stopAnimation = function(t, r) {
    for (var n = this.animators, i = n.length, o = [], a = 0; a < i; a++) {
      var s = n[a];
      !t || t === s.scope ? s.stop(r) : o.push(s);
    }
    return this.animators = o, this;
  }, e.prototype.animateTo = function(t, r, n) {
    l1(this, t, r, n);
  }, e.prototype.animateFrom = function(t, r, n) {
    l1(this, t, r, n, !0);
  }, e.prototype._transitionState = function(t, r, n, i) {
    for (var o = l1(this, r, n, i), a = 0; a < o.length; a++)
      o[a].__fromStateTransition = t;
  }, e.prototype.getBoundingRect = function() {
    return null;
  }, e.prototype.getPaintRect = function() {
    return null;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "element", t.name = "", t.ignore = t.silent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = !1, t.__dirty = ho;
    var r = {};
    function n(o, a, s) {
      r[o + a + s] || (console.warn("DEPRECATED: '" + o + "' has been deprecated. use '" + a + "', '" + s + "' instead"), r[o + a + s] = !0);
    }
    function i(o, a, s, l) {
      Object.defineProperty(t, o, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && n(o, s, l), !this[a]) {
            var c = this[a] = [];
            u(this, c);
          }
          return this[a];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && n(o, s, l), this[s] = c[0], this[l] = c[1], this[a] = c, u(this, c);
        }
      });
      function u(c, d) {
        Object.defineProperty(d, 0, {
          get: function() {
            return c[s];
          },
          set: function(h) {
            c[s] = h;
          }
        }), Object.defineProperty(d, 1, {
          get: function() {
            return c[l];
          },
          set: function(h) {
            c[l] = h;
          }
        });
      }
    }
    Object.defineProperty && (i("position", "_legacyPos", "x", "y"), i("scale", "_legacyScale", "scaleX", "scaleY"), i("origin", "_legacyOrigin", "originX", "originY"));
  }(), e;
}();
cn(XS, na);
cn(XS, $s);
function l1(e, t, r, n, i) {
  r = r || {};
  var o = [];
  sW(e, "", e, t, r, n, o, i);
  var a = o.length, s = !1, l = r.done, u = r.aborted, c = function() {
    s = !0, a--, a <= 0 && (s ? l && l() : u && u());
  }, d = function() {
    a--, a <= 0 && (s ? l && l() : u && u());
  };
  a || l && l(), o.length > 0 && r.during && o[0].during(function(p, g) {
    r.during(g);
  });
  for (var h = 0; h < o.length; h++) {
    var f = o[h];
    c && f.done(c), d && f.aborted(d), r.force && f.duration(r.duration), f.start(r.easing);
  }
  return o;
}
function u1(e, t, r) {
  for (var n = 0; n < r; n++)
    e[n] = t[n];
}
function fCe(e) {
  return Jn(e[0]);
}
function pCe(e, t, r) {
  if (Jn(t[r]))
    if (Jn(e[r]) || (e[r] = []), hi(t[r])) {
      var n = t[r].length;
      e[r].length !== n && (e[r] = new t[r].constructor(n), u1(e[r], t[r], n));
    } else {
      var i = t[r], o = e[r], a = i.length;
      if (fCe(i))
        for (var s = i[0].length, l = 0; l < a; l++)
          o[l] ? u1(o[l], i[l], s) : o[l] = Array.prototype.slice.call(i[l]);
      else
        u1(o, i, a);
      o.length = i.length;
    }
  else
    e[r] = t[r];
}
function gCe(e, t) {
  return e === t || Jn(e) && Jn(t) && vCe(e, t);
}
function vCe(e, t) {
  var r = e.length;
  if (r !== t.length)
    return !1;
  for (var n = 0; n < r; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function sW(e, t, r, n, i, o, a, s) {
  for (var l = jt(n), u = i.duration, c = i.delay, d = i.additive, h = i.setToFinal, f = !lt(o), p = e.animators, g = [], v = 0; v < l.length; v++) {
    var m = l[v], y = n[m];
    if (y != null && r[m] != null && (f || o[m]))
      if (lt(y) && !Jn(y) && !Dv(y)) {
        if (t) {
          s || (r[m] = y, e.updateDuringAnimation(t));
          continue;
        }
        sW(e, m, r[m], y, i, o && o[m], a, s);
      } else
        g.push(m);
    else s || (r[m] = y, e.updateDuringAnimation(t), g.push(m));
  }
  var C = g.length;
  if (!d && C)
    for (var S = 0; S < p.length; S++) {
      var b = p[S];
      if (b.targetName === t) {
        var w = b.stopTracks(g);
        if (w) {
          var x = Ft(p, b);
          p.splice(x, 1);
        }
      }
    }
  if (i.force || (g = Sr(g, function(P) {
    return !gCe(n[P], r[P]);
  }), C = g.length), C > 0 || i.force && !a.length) {
    var R = void 0, _ = void 0, T = void 0;
    if (s) {
      _ = {}, h && (R = {});
      for (var S = 0; S < C; S++) {
        var m = g[S];
        _[m] = r[m], h ? R[m] = n[m] : r[m] = n[m];
      }
    } else if (h) {
      T = {};
      for (var S = 0; S < C; S++) {
        var m = g[S];
        T[m] = og(r[m]), pCe(r, n, m);
      }
    }
    var b = new WM(r, !1, !1, d ? Sr(p, function(D) {
      return D.targetName === t;
    }) : null);
    b.targetName = t, i.scope && (b.scope = i.scope), h && R && b.whenWithKeys(0, R, g), T && b.whenWithKeys(0, T, g), b.whenWithKeys(u ?? 500, s ? _ : n, g).delay(c || 0), e.addAnimator(b, t), a.push(b);
  }
}
var lW = function(e) {
  Ur(t, e);
  function t(r) {
    var n = e.call(this) || this;
    return n.isGroup = !0, n._children = [], n.attr(r), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.children = function() {
    return this._children.slice();
  }, t.prototype.childAt = function(r) {
    return this._children[r];
  }, t.prototype.childOfName = function(r) {
    for (var n = this._children, i = 0; i < n.length; i++)
      if (n[i].name === r)
        return n[i];
  }, t.prototype.childCount = function() {
    return this._children.length;
  }, t.prototype.add = function(r) {
    if (r && (r !== this && r.parent !== this && (this._children.push(r), this._doAdd(r)), process.env.NODE_ENV !== "production" && r.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, t.prototype.addBefore = function(r, n) {
    if (r && r !== this && r.parent !== this && n && n.parent === this) {
      var i = this._children, o = i.indexOf(n);
      o >= 0 && (i.splice(o, 0, r), this._doAdd(r));
    }
    return this;
  }, t.prototype.replace = function(r, n) {
    var i = Ft(this._children, r);
    return i >= 0 && this.replaceAt(n, i), this;
  }, t.prototype.replaceAt = function(r, n) {
    var i = this._children, o = i[n];
    if (r && r !== this && r.parent !== this && r !== o) {
      i[n] = r, o.parent = null;
      var a = this.__zr;
      a && o.removeSelfFromZr(a), this._doAdd(r);
    }
    return this;
  }, t.prototype._doAdd = function(r) {
    r.parent && r.parent.remove(r), r.parent = this;
    var n = this.__zr;
    n && n !== r.__zr && r.addSelfToZr(n), n && n.refresh();
  }, t.prototype.remove = function(r) {
    var n = this.__zr, i = this._children, o = Ft(i, r);
    return o < 0 ? this : (i.splice(o, 1), r.parent = null, n && r.removeSelfFromZr(n), n && n.refresh(), this);
  }, t.prototype.removeAll = function() {
    for (var r = this._children, n = this.__zr, i = 0; i < r.length; i++) {
      var o = r[i];
      n && o.removeSelfFromZr(n), o.parent = null;
    }
    return r.length = 0, this;
  }, t.prototype.eachChild = function(r, n) {
    for (var i = this._children, o = 0; o < i.length; o++) {
      var a = i[o];
      r.call(n, a, o);
    }
    return this;
  }, t.prototype.traverse = function(r, n) {
    for (var i = 0; i < this._children.length; i++) {
      var o = this._children[i], a = r.call(n, o);
      o.isGroup && !a && o.traverse(r, n);
    }
    return this;
  }, t.prototype.addSelfToZr = function(r) {
    e.prototype.addSelfToZr.call(this, r);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.addSelfToZr(r);
    }
  }, t.prototype.removeSelfFromZr = function(r) {
    e.prototype.removeSelfFromZr.call(this, r);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.removeSelfFromZr(r);
    }
  }, t.prototype.getBoundingRect = function(r) {
    for (var n = new At(0, 0, 0, 0), i = r || this._children, o = [], a = null, s = 0; s < i.length; s++) {
      var l = i[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(o);
        c ? (At.applyTransform(n, u, c), a = a || n.clone(), a.union(n)) : (a = a || u.clone(), a.union(u));
      }
    }
    return a || n;
  }, t;
}(XS);
lW.prototype.type = "group";
const Ct = lW;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var Op = {}, gc = {};
function mCe(e) {
  delete gc[e];
}
function yCe(e) {
  if (!e)
    return !1;
  if (typeof e == "string")
    return zg(e, 1) < E_;
  if (e.colorStops) {
    for (var t = e.colorStops, r = 0, n = t.length, i = 0; i < n; i++)
      r += zg(t[i].color, 1);
    return r /= n, r < E_;
  }
  return !1;
}
var CCe = function() {
  function e(t, r, n) {
    var i = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = r, this.id = t;
    var o = new M0e(), a = n.renderer || "canvas";
    if (Op[a] || (a = jt(Op)[0]), process.env.NODE_ENV !== "production" && !Op[a])
      throw new Error("Renderer '" + a + "' is not imported. Please import it first.");
    n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect;
    var s = new Op[a](r, o, n, t), l = n.ssr || s.ssrOnly;
    this.storage = o, this.painter = s;
    var u = !nr.node && !nr.worker && !l ? new lCe(s.getViewportRoot(), s.root) : null, c = n.useCoarsePointer, d = c == null || c === "auto" ? nr.touchEventsSupported : !!c, h = 44, f;
    d && (f = bt(n.pointerSize, h)), this.handler = new $6(o, s, u, s.root, f), this.animation = new tCe({
      stage: {
        update: l ? null : function() {
          return i._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return e.prototype.add = function(t) {
    this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
  }, e.prototype.remove = function(t) {
    this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
  }, e.prototype.configLayer = function(t, r) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(t, r), this.refresh());
  }, e.prototype.setBackgroundColor = function(t) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = yCe(t));
  }, e.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, e.prototype.setDarkMode = function(t) {
    this._darkMode = t;
  }, e.prototype.isDarkMode = function() {
    return this._darkMode;
  }, e.prototype.refreshImmediately = function(t) {
    this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, e.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, e.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, e.prototype._flush = function(t) {
    var r, n = ph();
    this._needsRefresh && (r = !0, this.refreshImmediately(t)), this._needsRefreshHover && (r = !0, this.refreshHoverImmediately());
    var i = ph();
    r ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: i - n
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, e.prototype.setSleepAfterStill = function(t) {
    this._sleepAfterStill = t;
  }, e.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, e.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, e.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, e.prototype.resize = function(t) {
    this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
  }, e.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, e.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, e.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, e.prototype.setCursorStyle = function(t) {
    this._disposed || this.handler.setCursorStyle(t);
  }, e.prototype.findHover = function(t, r) {
    if (!this._disposed)
      return this.handler.findHover(t, r);
  }, e.prototype.on = function(t, r, n) {
    return this._disposed || this.handler.on(t, r, n), this;
  }, e.prototype.off = function(t, r) {
    this._disposed || this.handler.off(t, r);
  }, e.prototype.trigger = function(t, r) {
    this._disposed || this.handler.trigger(t, r);
  }, e.prototype.clear = function() {
    if (!this._disposed) {
      for (var t = this.storage.getRoots(), r = 0; r < t.length; r++)
        t[r] instanceof Ct && t[r].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, e.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, mCe(this.id));
  }, e;
}();
function T_(e, t) {
  var r = new CCe(FM(), e, t);
  return gc[r.id] = r, r;
}
function SCe(e) {
  e.dispose();
}
function wCe() {
  for (var e in gc)
    gc.hasOwnProperty(e) && gc[e].dispose();
  gc = {};
}
function bCe(e) {
  return gc[e];
}
function uW(e, t) {
  Op[e] = t;
}
var P_;
function cW(e) {
  if (typeof P_ == "function")
    return P_(e);
}
function dW(e) {
  P_ = e;
}
var xCe = "5.6.0";
const ECe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dispose: SCe,
  disposeAll: wCe,
  getElementSSRData: cW,
  getInstance: bCe,
  init: T_,
  registerPainter: uW,
  registerSSRDataGetter: dW,
  version: xCe
}, Symbol.toStringTag, { value: "Module" }));
var JF = 1e-4, hW = 20;
function RCe(e) {
  return e.replace(/^\s+|\s+$/g, "");
}
function Cr(e, t, r, n) {
  var i = t[0], o = t[1], a = r[0], s = r[1], l = o - i, u = s - a;
  if (l === 0)
    return u === 0 ? a : (a + s) / 2;
  if (n)
    if (l > 0) {
      if (e <= i)
        return a;
      if (e >= o)
        return s;
    } else {
      if (e >= i)
        return a;
      if (e <= o)
        return s;
    }
  else {
    if (e === i)
      return a;
    if (e === o)
      return s;
  }
  return (e - i) / l * u + a;
}
function Be(e, t) {
  switch (e) {
    case "center":
    case "middle":
      e = "50%";
      break;
    case "left":
    case "top":
      e = "0%";
      break;
    case "right":
    case "bottom":
      e = "100%";
      break;
  }
  return He(e) ? RCe(e).match(/%$/) ? parseFloat(e) / 100 * t : parseFloat(e) : e == null ? NaN : +e;
}
function an(e, t, r) {
  return t == null && (t = 10), t = Math.min(Math.max(0, t), hW), e = (+e).toFixed(t), r ? e : +e;
}
function vo(e) {
  return e.sort(function(t, r) {
    return t - r;
  }), e;
}
function ba(e) {
  if (e = +e, isNaN(e))
    return 0;
  if (e > 1e-14) {
    for (var t = 1, r = 0; r < 15; r++, t *= 10)
      if (Math.round(e * t) / t === e)
        return r;
  }
  return aC(e);
}
function aC(e) {
  var t = e.toString().toLowerCase(), r = t.indexOf("e"), n = r > 0 ? +t.slice(r + 1) : 0, i = r > 0 ? r : t.length, o = t.indexOf("."), a = o < 0 ? 0 : i - 1 - o;
  return Math.max(0, a - n);
}
function jM(e, t) {
  var r = Math.log, n = Math.LN10, i = Math.floor(r(e[1] - e[0]) / n), o = Math.round(r(Math.abs(t[1] - t[0])) / n), a = Math.min(Math.max(-i + o, 0), 20);
  return isFinite(a) ? a : 20;
}
function _Ce(e, t, r) {
  if (!e[t])
    return 0;
  var n = fW(e, r);
  return n[t] || 0;
}
function fW(e, t) {
  var r = Jo(e, function(f, p) {
    return f + (isNaN(p) ? 0 : p);
  }, 0);
  if (r === 0)
    return [];
  for (var n = Math.pow(10, t), i = Ee(e, function(f) {
    return (isNaN(f) ? 0 : f) / r * n * 100;
  }), o = n * 100, a = Ee(i, function(f) {
    return Math.floor(f);
  }), s = Jo(a, function(f, p) {
    return f + p;
  }, 0), l = Ee(i, function(f, p) {
    return f - a[p];
  }); s < o; ) {
    for (var u = Number.NEGATIVE_INFINITY, c = null, d = 0, h = l.length; d < h; ++d)
      l[d] > u && (u = l[d], c = d);
    ++a[c], l[c] = 0, ++s;
  }
  return Ee(a, function(f) {
    return f / n;
  });
}
function TCe(e, t) {
  var r = Math.max(ba(e), ba(t)), n = e + t;
  return r > hW ? n : an(n, r);
}
var M_ = 9007199254740991;
function UM(e) {
  var t = Math.PI * 2;
  return (e % t + t) % t;
}
function zh(e) {
  return e > -JF && e < JF;
}
var PCe = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function bo(e) {
  if (e instanceof Date)
    return e;
  if (He(e)) {
    var t = PCe.exec(e);
    if (!t)
      return /* @__PURE__ */ new Date(NaN);
    if (t[8]) {
      var r = +t[4] || 0;
      return t[8].toUpperCase() !== "Z" && (r -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, r, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
    } else
      return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
  } else if (e == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(e));
}
function pW(e) {
  return Math.pow(10, Fv(e));
}
function Fv(e) {
  if (e === 0)
    return 0;
  var t = Math.floor(Math.log(e) / Math.LN10);
  return e / Math.pow(10, t) >= 10 && t++, t;
}
function KM(e, t) {
  var r = Fv(e), n = Math.pow(10, r), i = e / n, o;
  return t ? i < 1.5 ? o = 1 : i < 2.5 ? o = 2 : i < 4 ? o = 3 : i < 7 ? o = 5 : o = 10 : i < 1 ? o = 1 : i < 2 ? o = 2 : i < 3 ? o = 3 : i < 5 ? o = 5 : o = 10, e = o * n, r >= -20 ? +e.toFixed(r < 0 ? -r : 0) : e;
}
function s0(e, t) {
  var r = (e.length - 1) * t + 1, n = Math.floor(r), i = +e[n - 1], o = r - n;
  return o ? i + o * (e[n] - i) : i;
}
function D_(e) {
  e.sort(function(l, u) {
    return s(l, u, 0) ? -1 : 1;
  });
  for (var t = -1 / 0, r = 1, n = 0; n < e.length; ) {
    for (var i = e[n].interval, o = e[n].close, a = 0; a < 2; a++)
      i[a] <= t && (i[a] = t, o[a] = a ? 1 : 1 - r), t = i[a], r = o[a];
    i[0] === i[1] && o[0] * o[1] !== 1 ? e.splice(n, 1) : n++;
  }
  return e;
  function s(l, u, c) {
    return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && s(l, u, 1));
  }
}
function vs(e) {
  var t = parseFloat(e);
  return t == e && (t !== 0 || !He(e) || e.indexOf("x") <= 0) ? t : NaN;
}
function ZS(e) {
  return !isNaN(vs(e));
}
function gW() {
  return Math.round(Math.random() * 9);
}
function vW(e, t) {
  return t === 0 ? e : vW(t, e % t);
}
function eN(e, t) {
  return e == null ? t : t == null ? e : e * t / vW(e, t);
}
var MCe = "[ECharts] ", tN = {}, DCe = typeof console < "u" && console.warn && console.log;
function QS(e, t, r) {
  if (DCe) {
    if (r) {
      if (tN[t])
        return;
      tN[t] = !0;
    }
    console[e](MCe + t);
  }
}
function ACe(e, t) {
  QS("log", e, t);
}
function nn(e, t) {
  QS("warn", e, t);
}
function ei(e, t) {
  QS("error", e, t);
}
function ea(e) {
  process.env.NODE_ENV !== "production" && QS("warn", "DEPRECATED: " + e, !0);
}
function pn(e, t, r) {
  process.env.NODE_ENV !== "production" && ea((r ? "[" + r + "]" : "") + (e + " is deprecated, use " + t + " instead."));
}
function Ai() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var r = "";
  if (process.env.NODE_ENV !== "production") {
    var n = function(i) {
      return i === void 0 ? "undefined" : i === 1 / 0 ? "Infinity" : i === -1 / 0 ? "-Infinity" : nu(i) ? "NaN" : i instanceof Date ? "Date(" + i.toISOString() + ")" : at(i) ? "function () { ... }" : kM(i) ? i + "" : null;
    };
    r = Ee(e, function(i) {
      if (He(i))
        return i;
      var o = n(i);
      if (o != null)
        return o;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(i, function(a, s) {
            var l = n(s);
            return l ?? s;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return r;
}
function mr(e) {
  throw new Error(e);
}
function rN(e, t, r) {
  return (t - e) * r + e;
}
var mW = "series\0", yW = "\0_ec_\0";
function Tr(e) {
  return e instanceof Array ? e : e == null ? [] : [e];
}
function Gc(e, t, r) {
  if (e) {
    e[t] = e[t] || {}, e.emphasis = e.emphasis || {}, e.emphasis[t] = e.emphasis[t] || {};
    for (var n = 0, i = r.length; n < i; n++) {
      var o = r[n];
      !e.emphasis[t].hasOwnProperty(o) && e[t].hasOwnProperty(o) && (e.emphasis[t][o] = e[t][o]);
    }
  }
}
var nN = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function pf(e) {
  return lt(e) && !be(e) && !(e instanceof Date) ? e.value : e;
}
function ICe(e) {
  return lt(e) && !(e instanceof Array);
}
function CW(e, t, r) {
  var n = r === "normalMerge", i = r === "replaceMerge", o = r === "replaceAll";
  e = e || [], t = (t || []).slice();
  var a = nt();
  $(t, function(l, u) {
    if (!lt(l)) {
      t[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !oN(l.id) && iN(l.id), l.name != null && !oN(l.name) && iN(l.name));
  });
  var s = OCe(e, a, r);
  return (n || i) && LCe(s, e, a, t), n && FCe(s, t), n || i ? NCe(s, t, i) : o && kCe(s, t), VCe(s), s;
}
function OCe(e, t, r) {
  var n = [];
  if (r === "replaceAll")
    return n;
  for (var i = 0; i < e.length; i++) {
    var o = e[i];
    o && o.id != null && t.set(o.id, i), n.push({
      existing: r === "replaceMerge" || Wh(o) ? null : o,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return n;
}
function LCe(e, t, r, n) {
  $(n, function(i, o) {
    if (!(!i || i.id == null)) {
      var a = ag(i.id), s = r.get(a);
      if (s != null) {
        var l = e[s];
        ct(!l.newOption, 'Duplicated option on id "' + a + '".'), l.newOption = i, l.existing = t[s], n[o] = null;
      }
    }
  });
}
function FCe(e, t) {
  $(t, function(r, n) {
    if (!(!r || r.name == null))
      for (var i = 0; i < e.length; i++) {
        var o = e[i].existing;
        if (!e[i].newOption && o && (o.id == null || r.id == null) && !Wh(r) && !Wh(o) && SW("name", o, r)) {
          e[i].newOption = r, t[n] = null;
          return;
        }
      }
  });
}
function NCe(e, t, r) {
  $(t, function(n) {
    if (n) {
      for (
        var i, o = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (i = e[o]) && (i.newOption || Wh(i.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        i.existing && n.id != null && !SW("id", n, i.existing));
      )
        o++;
      i ? (i.newOption = n, i.brandNew = r) : e.push({
        newOption: n,
        brandNew: r,
        existing: null,
        keyInfo: null
      }), o++;
    }
  });
}
function kCe(e, t) {
  $(t, function(r) {
    e.push({
      newOption: r,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function VCe(e) {
  var t = nt();
  $(e, function(r) {
    var n = r.existing;
    n && t.set(n.id, r);
  }), $(e, function(r) {
    var n = r.newOption;
    ct(!n || n.id == null || !t.get(n.id) || t.get(n.id) === r, "id duplicates: " + (n && n.id)), n && n.id != null && t.set(n.id, r), !r.keyInfo && (r.keyInfo = {});
  }), $(e, function(r, n) {
    var i = r.existing, o = r.newOption, a = r.keyInfo;
    if (lt(o)) {
      if (a.name = o.name != null ? ag(o.name) : i ? i.name : mW + n, i)
        a.id = ag(i.id);
      else if (o.id != null)
        a.id = ag(o.id);
      else {
        var s = 0;
        do
          a.id = "\0" + a.name + "\0" + s++;
        while (t.get(a.id));
      }
      t.set(a.id, r);
    }
  });
}
function SW(e, t, r) {
  var n = In(t[e], null), i = In(r[e], null);
  return n != null && i != null && n === i;
}
function ag(e) {
  if (process.env.NODE_ENV !== "production" && e == null)
    throw new Error();
  return In(e, "");
}
function In(e, t) {
  return e == null ? t : He(e) ? e : sr(e) || Ng(e) ? e + "" : t;
}
function iN(e) {
  process.env.NODE_ENV !== "production" && nn("`" + e + "` is invalid id or name. Must be a string or number.");
}
function oN(e) {
  return Ng(e) || ZS(e);
}
function YM(e) {
  var t = e.name;
  return !!(t && t.indexOf(mW));
}
function Wh(e) {
  return e && e.id != null && ag(e.id).indexOf(yW) === 0;
}
function BCe(e) {
  return yW + e;
}
function $Ce(e, t, r) {
  $(e, function(n) {
    var i = n.newOption;
    lt(i) && (n.keyInfo.mainType = t, n.keyInfo.subType = HCe(t, i, n.existing, r));
  });
}
function HCe(e, t, r, n) {
  var i = t.type ? t.type : r ? r.subType : n.determineSubType(e, t);
  return i;
}
function GCe(e, t) {
  var r = {}, n = {};
  return i(e || [], r), i(t || [], n, r), [o(r), o(n)];
  function i(a, s, l) {
    for (var u = 0, c = a.length; u < c; u++) {
      var d = In(a[u].seriesId, null);
      if (d == null)
        return;
      for (var h = Tr(a[u].dataIndex), f = l && l[d], p = 0, g = h.length; p < g; p++) {
        var v = h[p];
        f && f[v] ? f[v] = null : (s[d] || (s[d] = {}))[v] = 1;
      }
    }
  }
  function o(a, s) {
    var l = [];
    for (var u in a)
      if (a.hasOwnProperty(u) && a[u] != null)
        if (s)
          l.push(+u);
        else {
          var c = o(a[u], !0);
          c.length && l.push({
            seriesId: u,
            dataIndex: c
          });
        }
    return l;
  }
}
function zc(e, t) {
  if (t.dataIndexInside != null)
    return t.dataIndexInside;
  if (t.dataIndex != null)
    return be(t.dataIndex) ? Ee(t.dataIndex, function(r) {
      return e.indexOfRawIndex(r);
    }) : e.indexOfRawIndex(t.dataIndex);
  if (t.name != null)
    return be(t.name) ? Ee(t.name, function(r) {
      return e.indexOfName(r);
    }) : e.indexOfName(t.name);
}
function ar() {
  var e = "__ec_inner_" + zCe++;
  return function(t) {
    return t[e] || (t[e] = {});
  };
}
var zCe = gW();
function sg(e, t, r) {
  var n = qM(t, r), i = n.mainTypeSpecified, o = n.queryOptionMap, a = n.others, s = a, l = r ? r.defaultMainType : null;
  return !i && l && o.set(l, {}), o.each(function(u, c) {
    var d = Nv(e, c, u, {
      useDefault: l === c,
      enableAll: r && r.enableAll != null ? r.enableAll : !0,
      enableNone: r && r.enableNone != null ? r.enableNone : !0
    });
    s[c + "Models"] = d.models, s[c + "Model"] = d.models[0];
  }), s;
}
function qM(e, t) {
  var r;
  if (He(e)) {
    var n = {};
    n[e + "Index"] = 0, r = n;
  } else
    r = e;
  var i = nt(), o = {}, a = !1;
  return $(r, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      o[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], d = (u[2] || "").toLowerCase();
    if (!(!c || !d || t && t.includeMainTypes && Ft(t.includeMainTypes, c) < 0)) {
      a = a || !!c;
      var h = i.get(c) || i.set(c, {});
      h[d] = s;
    }
  }), {
    mainTypeSpecified: a,
    queryOptionMap: i,
    others: o
  };
}
var bn = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, WCe = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function Nv(e, t, r, n) {
  n = n || bn;
  var i = r.index, o = r.id, a = r.name, s = {
    models: null,
    specified: i != null || o != null || a != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = n.useDefault && (l = e.getComponent(t)) ? [l] : [], s;
  }
  return i === "none" || i === !1 ? (ct(n.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (i === "all" && (ct(n.enableAll, '`"all"` is not a valid value on index option.'), i = o = a = null), s.models = e.queryComponents({
    mainType: t,
    index: i,
    id: o,
    name: a
  }), s);
}
function wW(e, t, r) {
  e.setAttribute ? e.setAttribute(t, r) : e[t] = r;
}
function jCe(e, t) {
  return e.getAttribute ? e.getAttribute(t) : e[t];
}
function UCe(e) {
  return e === "auto" ? nr.domSupported ? "html" : "richText" : e || "html";
}
function A_(e, t) {
  var r = nt(), n = [];
  return $(e, function(i) {
    var o = t(i);
    (r.get(o) || (n.push(o), r.set(o, []))).push(i);
  }), {
    keys: n,
    buckets: r
  };
}
function bW(e, t, r, n, i) {
  var o = t == null || t === "auto";
  if (n == null)
    return n;
  if (sr(n)) {
    var a = rN(r || 0, n, i);
    return an(a, o ? Math.max(ba(r || 0), ba(n)) : t);
  } else {
    if (He(n))
      return i < 1 ? r : n;
    for (var s = [], l = r, u = n, c = Math.max(l ? l.length : 0, u.length), d = 0; d < c; ++d) {
      var h = e.getDimensionInfo(d);
      if (h && h.type === "ordinal")
        s[d] = (i < 1 && l ? l : u)[d];
      else {
        var f = l && l[d] ? l[d] : 0, p = u[d], a = rN(f, p, i);
        s[d] = an(a, o ? Math.max(ba(f), ba(p)) : t);
      }
    }
    return s;
  }
}
var KCe = ".", Iu = "___EC__COMPONENT__CONTAINER___", xW = "___EC__EXTENDED_CLASS___";
function ns(e) {
  var t = {
    main: "",
    sub: ""
  };
  if (e) {
    var r = e.split(KCe);
    t.main = r[0] || "", t.sub = r[1] || "";
  }
  return t;
}
function YCe(e) {
  ct(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e), 'componentType "' + e + '" illegal');
}
function qCe(e) {
  return !!(e && e[xW]);
}
function XM(e, t) {
  e.$constructor = e, e.extend = function(r) {
    process.env.NODE_ENV !== "production" && $(t, function(o) {
      r[o] || console.warn("Method `" + o + "` should be implemented" + (r.type ? " in " + r.type : "") + ".");
    });
    var n = this, i;
    return XCe(n) ? i = /** @class */
    function(o) {
      le(a, o);
      function a() {
        return o.apply(this, arguments) || this;
      }
      return a;
    }(n) : (i = function() {
      (r.$constructor || n).apply(this, arguments);
    }, NM(i, this)), ge(i.prototype, r), i[xW] = !0, i.extend = this.extend, i.superCall = JCe, i.superApply = eSe, i.superClass = n, i;
  };
}
function XCe(e) {
  return at(e) && /^class\s/.test(Function.prototype.toString.call(e));
}
function EW(e, t) {
  e.extend = t.extend;
}
var ZCe = Math.round(Math.random() * 10);
function QCe(e) {
  var t = ["__\0is_clz", ZCe++].join("_");
  e.prototype[t] = !0, process.env.NODE_ENV !== "production" && ct(!e.isInstance, 'The method "is" can not be defined.'), e.isInstance = function(r) {
    return !!(r && r[t]);
  };
}
function JCe(e, t) {
  for (var r = [], n = 2; n < arguments.length; n++)
    r[n - 2] = arguments[n];
  return this.superClass.prototype[t].apply(e, r);
}
function eSe(e, t, r) {
  return this.superClass.prototype[t].apply(e, r);
}
function JS(e) {
  var t = {};
  e.registerClass = function(n) {
    var i = n.type || n.prototype.type;
    if (i) {
      YCe(i), n.prototype.type = i;
      var o = ns(i);
      if (!o.sub)
        process.env.NODE_ENV !== "production" && t[o.main] && console.warn(o.main + " exists."), t[o.main] = n;
      else if (o.sub !== Iu) {
        var a = r(o);
        a[o.sub] = n;
      }
    }
    return n;
  }, e.getClass = function(n, i, o) {
    var a = t[n];
    if (a && a[Iu] && (a = i ? a[i] : null), o && !a)
      throw new Error(i ? "Component " + n + "." + (i || "") + " is used but not imported." : n + ".type should be specified.");
    return a;
  }, e.getClassesByMainType = function(n) {
    var i = ns(n), o = [], a = t[i.main];
    return a && a[Iu] ? $(a, function(s, l) {
      l !== Iu && o.push(s);
    }) : o.push(a), o;
  }, e.hasClass = function(n) {
    var i = ns(n);
    return !!t[i.main];
  }, e.getAllClassMainTypes = function() {
    var n = [];
    return $(t, function(i, o) {
      n.push(o);
    }), n;
  }, e.hasSubTypes = function(n) {
    var i = ns(n), o = t[i.main];
    return o && o[Iu];
  };
  function r(n) {
    var i = t[n.main];
    return (!i || !i[Iu]) && (i = t[n.main] = {}, i[Iu] = !0), i;
  }
}
function Wc(e, t) {
  for (var r = 0; r < e.length; r++)
    e[r][1] || (e[r][1] = e[r][0]);
  return t = t || !1, function(n, i, o) {
    for (var a = {}, s = 0; s < e.length; s++) {
      var l = e[s][1];
      if (!(i && Ft(i, l) >= 0 || o && Ft(o, l) < 0)) {
        var u = n.getShallow(l, t);
        u != null && (a[e[s][0]] = u);
      }
    }
    return a;
  };
}
var tSe = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], rSe = Wc(tSe), nSe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getAreaStyle = function(t, r) {
      return rSe(this, t, r);
    }, e;
  }()
), I_ = new Ov(50);
function iSe(e) {
  if (typeof e == "string") {
    var t = I_.get(e);
    return t && t.image;
  } else
    return e;
}
function ZM(e, t, r, n, i) {
  if (e)
    if (typeof e == "string") {
      if (t && t.__zrImageSrc === e || !r)
        return t;
      var o = I_.get(e), a = { hostEl: r, cb: n, cbPayload: i };
      return o ? (t = o.image, !ew(t) && o.pending.push(a)) : (t = Ia.loadImage(e, aN, aN), t.__zrImageSrc = e, I_.put(e, t.__cachedImgObj = {
        image: t,
        pending: [a]
      })), t;
    } else
      return e;
  else return t;
}
function aN() {
  var e = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var t = 0; t < e.pending.length; t++) {
    var r = e.pending[t], n = r.cb;
    n && n(this, r.cbPayload), r.hostEl.dirty();
  }
  e.pending.length = 0;
}
function ew(e) {
  return e && e.width && e.height;
}
var c1 = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function RW(e, t, r, n, i) {
  if (!t)
    return "";
  var o = (e + "").split(`
`);
  i = _W(t, r, n, i);
  for (var a = 0, s = o.length; a < s; a++)
    o[a] = TW(o[a], i);
  return o.join(`
`);
}
function _W(e, t, r, n) {
  n = n || {};
  var i = ge({}, n);
  i.font = t, r = bt(r, "..."), i.maxIterations = bt(n.maxIterations, 2);
  var o = i.minChar = bt(n.minChar, 0);
  i.cnCharWidth = wo("", t);
  var a = i.ascCharWidth = wo("a", t);
  i.placeholder = bt(n.placeholder, "");
  for (var s = e = Math.max(0, e - 1), l = 0; l < o && s >= a; l++)
    s -= a;
  var u = wo(r, t);
  return u > s && (r = "", u = 0), s = e - u, i.ellipsis = r, i.ellipsisWidth = u, i.contentWidth = s, i.containerWidth = e, i;
}
function TW(e, t) {
  var r = t.containerWidth, n = t.font, i = t.contentWidth;
  if (!r)
    return "";
  var o = wo(e, n);
  if (o <= r)
    return e;
  for (var a = 0; ; a++) {
    if (o <= i || a >= t.maxIterations) {
      e += t.ellipsis;
      break;
    }
    var s = a === 0 ? oSe(e, i, t.ascCharWidth, t.cnCharWidth) : o > 0 ? Math.floor(e.length * i / o) : 0;
    e = e.substr(0, s), o = wo(e, n);
  }
  return e === "" && (e = t.placeholder), e;
}
function oSe(e, t, r, n) {
  for (var i = 0, o = 0, a = e.length; o < a && i < t; o++) {
    var s = e.charCodeAt(o);
    i += 0 <= s && s <= 127 ? r : n;
  }
  return o;
}
function aSe(e, t) {
  e != null && (e += "");
  var r = t.overflow, n = t.padding, i = t.font, o = r === "truncate", a = qS(i), s = bt(t.lineHeight, a), l = !!t.backgroundColor, u = t.lineOverflow === "truncate", c = t.width, d;
  c != null && (r === "break" || r === "breakAll") ? d = e ? PW(e, t.font, c, r === "breakAll", 0).lines : [] : d = e ? e.split(`
`) : [];
  var h = d.length * s, f = bt(t.height, h);
  if (h > f && u) {
    var p = Math.floor(f / s);
    d = d.slice(0, p);
  }
  if (e && o && c != null)
    for (var g = _W(c, i, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), v = 0; v < d.length; v++)
      d[v] = TW(d[v], g);
  for (var m = f, y = 0, v = 0; v < d.length; v++)
    y = Math.max(wo(d[v], i), y);
  c == null && (c = y);
  var C = y;
  return n && (m += n[0] + n[2], C += n[1] + n[3], c += n[1] + n[3]), l && (C = c), {
    lines: d,
    height: f,
    outerWidth: C,
    outerHeight: m,
    lineHeight: s,
    calculatedLineHeight: a,
    contentWidth: y,
    contentHeight: h,
    width: c
  };
}
var sSe = /* @__PURE__ */ function() {
  function e() {
  }
  return e;
}(), sN = /* @__PURE__ */ function() {
  function e(t) {
    this.tokens = [], t && (this.tokens = t);
  }
  return e;
}(), lSe = /* @__PURE__ */ function() {
  function e() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [];
  }
  return e;
}();
function uSe(e, t) {
  var r = new lSe();
  if (e != null && (e += ""), !e)
    return r;
  for (var n = t.width, i = t.height, o = t.overflow, a = (o === "break" || o === "breakAll") && n != null ? { width: n, accumWidth: 0, breakAll: o === "breakAll" } : null, s = c1.lastIndex = 0, l; (l = c1.exec(e)) != null; ) {
    var u = l.index;
    u > s && d1(r, e.substring(s, u), t, a), d1(r, l[2], t, a, l[1]), s = c1.lastIndex;
  }
  s < e.length && d1(r, e.substring(s, e.length), t, a);
  var c = [], d = 0, h = 0, f = t.padding, p = o === "truncate", g = t.lineOverflow === "truncate";
  function v(I, B, M) {
    I.width = B, I.lineHeight = M, d += M, h = Math.max(h, B);
  }
  e: for (var m = 0; m < r.lines.length; m++) {
    for (var y = r.lines[m], C = 0, S = 0, b = 0; b < y.tokens.length; b++) {
      var w = y.tokens[b], x = w.styleName && t.rich[w.styleName] || {}, R = w.textPadding = x.padding, _ = R ? R[1] + R[3] : 0, T = w.font = x.font || t.font;
      w.contentHeight = qS(T);
      var P = bt(x.height, w.contentHeight);
      if (w.innerHeight = P, R && (P += R[0] + R[2]), w.height = P, w.lineHeight = So(x.lineHeight, t.lineHeight, P), w.align = x && x.align || t.align, w.verticalAlign = x && x.verticalAlign || "middle", g && i != null && d + w.lineHeight > i) {
        b > 0 ? (y.tokens = y.tokens.slice(0, b), v(y, S, C), r.lines = r.lines.slice(0, m + 1)) : r.lines = r.lines.slice(0, m);
        break e;
      }
      var D = x.width, O = D == null || D === "auto";
      if (typeof D == "string" && D.charAt(D.length - 1) === "%")
        w.percentWidth = D, c.push(w), w.contentWidth = wo(w.text, T);
      else {
        if (O) {
          var A = x.backgroundColor, F = A && A.image;
          F && (F = iSe(F), ew(F) && (w.width = Math.max(w.width, F.width * P / F.height)));
        }
        var L = p && n != null ? n - S : null;
        L != null && L < w.width ? !O || L < _ ? (w.text = "", w.width = w.contentWidth = 0) : (w.text = RW(w.text, L - _, T, t.ellipsis, { minChar: t.truncateMinChar }), w.width = w.contentWidth = wo(w.text, T)) : w.contentWidth = wo(w.text, T);
      }
      w.width += _, S += w.width, x && (C = Math.max(C, w.lineHeight));
    }
    v(y, S, C);
  }
  r.outerWidth = r.width = bt(n, h), r.outerHeight = r.height = bt(i, d), r.contentHeight = d, r.contentWidth = h, f && (r.outerWidth += f[1] + f[3], r.outerHeight += f[0] + f[2]);
  for (var m = 0; m < c.length; m++) {
    var w = c[m], N = w.percentWidth;
    w.width = parseInt(N, 10) / 100 * r.width;
  }
  return r;
}
function d1(e, t, r, n, i) {
  var o = t === "", a = i && r.rich[i] || {}, s = e.lines, l = a.font || r.font, u = !1, c, d;
  if (n) {
    var h = a.padding, f = h ? h[1] + h[3] : 0;
    if (a.width != null && a.width !== "auto") {
      var p = La(a.width, n.width) + f;
      s.length > 0 && p + n.accumWidth > n.width && (c = t.split(`
`), u = !0), n.accumWidth = p;
    } else {
      var g = PW(t, l, n.width, n.breakAll, n.accumWidth);
      n.accumWidth = g.accumWidth + f, d = g.linesWidths, c = g.lines;
    }
  } else
    c = t.split(`
`);
  for (var v = 0; v < c.length; v++) {
    var m = c[v], y = new sSe();
    if (y.styleName = i, y.text = m, y.isLineHolder = !m && !o, typeof a.width == "number" ? y.width = a.width : y.width = d ? d[v] : wo(m, l), !v && !u) {
      var C = (s[s.length - 1] || (s[0] = new sN())).tokens, S = C.length;
      S === 1 && C[0].isLineHolder ? C[0] = y : (m || !S || o) && C.push(y);
    } else
      s.push(new sN([y]));
  }
}
function cSe(e) {
  var t = e.charCodeAt(0);
  return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
}
var dSe = Jo(",&?/;] ".split(""), function(e, t) {
  return e[t] = !0, e;
}, {});
function hSe(e) {
  return cSe(e) ? !!dSe[e] : !0;
}
function PW(e, t, r, n, i) {
  for (var o = [], a = [], s = "", l = "", u = 0, c = 0, d = 0; d < e.length; d++) {
    var h = e.charAt(d);
    if (h === `
`) {
      l && (s += l, c += u), o.push(s), a.push(c), s = "", l = "", u = 0, c = 0;
      continue;
    }
    var f = wo(h, t), p = n ? !1 : !hSe(h);
    if (o.length ? c + f > r : i + c + f > r) {
      c ? (s || l) && (p ? (s || (s = l, l = "", u = 0, c = u), o.push(s), a.push(c - u), l += h, u += f, s = "", c = u) : (l && (s += l, l = "", u = 0), o.push(s), a.push(c), s = h, c = f)) : p ? (o.push(l), a.push(u), l = h, u = f) : (o.push(h), a.push(f));
      continue;
    }
    c += f, p ? (l += h, u += f) : (l && (s += l, l = "", u = 0), s += h);
  }
  return !o.length && !s && (s = e, l = "", u = 0), l && (s += l), s && (o.push(s), a.push(c)), o.length === 1 && (c += i), {
    accumWidth: c,
    lines: o,
    linesWidths: a
  };
}
var O_ = "__zr_style_" + Math.round(Math.random() * 10), Tc = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, tw = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
Tc[O_] = !0;
var lN = ["z", "z2", "invisible"], fSe = ["invisible"], pSe = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype._init = function(r) {
    for (var n = jt(r), i = 0; i < n.length; i++) {
      var o = n[i];
      o === "style" ? this.useStyle(r[o]) : e.prototype.attrKV.call(this, o, r[o]);
    }
    this.style || this.useStyle({});
  }, t.prototype.beforeBrush = function() {
  }, t.prototype.afterBrush = function() {
  }, t.prototype.innerBeforeBrush = function() {
  }, t.prototype.innerAfterBrush = function() {
  }, t.prototype.shouldBePainted = function(r, n, i, o) {
    var a = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && gSe(this, r, n) || a && !a[0] && !a[3])
      return !1;
    if (i && this.__clipPaths) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (o && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, t.prototype.contain = function(r, n) {
    return this.rectContain(r, n);
  }, t.prototype.traverse = function(r, n) {
    r.call(n, this);
  }, t.prototype.rectContain = function(r, n) {
    var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect();
    return o.contain(i[0], i[1]);
  }, t.prototype.getPaintRect = function() {
    var r = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var n = this.transform, i = this.getBoundingRect(), o = this.style, a = o.shadowBlur || 0, s = o.shadowOffsetX || 0, l = o.shadowOffsetY || 0;
      r = this._paintRect || (this._paintRect = new At(0, 0, 0, 0)), n ? At.applyTransform(r, i, n) : r.copy(i), (a || s || l) && (r.width += a * 2 + Math.abs(s), r.height += a * 2 + Math.abs(l), r.x = Math.min(r.x, r.x + s - a), r.y = Math.min(r.y, r.y + l - a));
      var u = this.dirtyRectTolerance;
      r.isZero() || (r.x = Math.floor(r.x - u), r.y = Math.floor(r.y - u), r.width = Math.ceil(r.width + 1 + u * 2), r.height = Math.ceil(r.height + 1 + u * 2));
    }
    return r;
  }, t.prototype.setPrevPaintRect = function(r) {
    r ? (this._prevPaintRect = this._prevPaintRect || new At(0, 0, 0, 0), this._prevPaintRect.copy(r)) : this._prevPaintRect = null;
  }, t.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, t.prototype.animateStyle = function(r) {
    return this.animate("style", r);
  }, t.prototype.updateDuringAnimation = function(r) {
    r === "style" ? this.dirtyStyle() : this.markRedraw();
  }, t.prototype.attrKV = function(r, n) {
    r !== "style" ? e.prototype.attrKV.call(this, r, n) : this.style ? this.setStyle(n) : this.useStyle(n);
  }, t.prototype.setStyle = function(r, n) {
    return typeof r == "string" ? this.style[r] = n : ge(this.style, r), this.dirtyStyle(), this;
  }, t.prototype.dirtyStyle = function(r) {
    r || this.markRedraw(), this.__dirty |= Dp, this._rect && (this._rect = null);
  }, t.prototype.dirty = function() {
    this.dirtyStyle();
  }, t.prototype.styleChanged = function() {
    return !!(this.__dirty & Dp);
  }, t.prototype.styleUpdated = function() {
    this.__dirty &= ~Dp;
  }, t.prototype.createStyle = function(r) {
    return Av(Tc, r);
  }, t.prototype.useStyle = function(r) {
    r[O_] || (r = this.createStyle(r)), this.__inHover ? this.__hoverStyle = r : this.style = r, this.dirtyStyle();
  }, t.prototype.isStyleObject = function(r) {
    return r[O_];
  }, t.prototype._innerSaveToNormal = function(r) {
    e.prototype._innerSaveToNormal.call(this, r);
    var n = this._normalState;
    r.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(r, n, lN);
  }, t.prototype._applyStateObj = function(r, n, i, o, a, s) {
    e.prototype._applyStateObj.call(this, r, n, i, o, a, s);
    var l = !(n && o), u;
    if (n && n.style ? a ? o ? u = n.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), o ? this.style : i.style), this._mergeStyle(u, n.style)) : l && (u = i.style), u)
      if (a) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var d = jt(c), h = 0; h < d.length; h++) {
            var f = d[h];
            f in u && (u[f] = u[f], this.style[f] = c[f]);
          }
        for (var p = jt(u), h = 0; h < p.length; h++) {
          var f = p[h];
          this.style[f] = this.style[f];
        }
        this._transitionState(r, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? fSe : lN, h = 0; h < g.length; h++) {
      var f = g[h];
      n && n[f] != null ? this[f] = n[f] : l && i[f] != null && (this[f] = i[f]);
    }
  }, t.prototype._mergeStates = function(r) {
    for (var n = e.prototype._mergeStates.call(this, r), i, o = 0; o < r.length; o++) {
      var a = r[o];
      a.style && (i = i || {}, this._mergeStyle(i, a.style));
    }
    return i && (n.style = i), n;
  }, t.prototype._mergeStyle = function(r, n) {
    return ge(r, n), r;
  }, t.prototype.getAnimationStyleProps = function() {
    return tw;
  }, t.initDefaultProps = function() {
    var r = t.prototype;
    r.type = "displayable", r.invisible = !1, r.z = 0, r.z2 = 0, r.zlevel = 0, r.culling = !1, r.cursor = "pointer", r.rectHover = !1, r.incremental = !1, r._rect = null, r.dirtyRectTolerance = 0, r.__dirty = ho | Dp;
  }(), t;
}(XS), h1 = new At(0, 0, 0, 0), f1 = new At(0, 0, 0, 0);
function gSe(e, t, r) {
  return h1.copy(e.getBoundingRect()), e.transform && h1.applyTransform(e.transform), f1.width = t, f1.height = r, !h1.intersect(f1);
}
const ta = pSe;
var ji = Math.min, Ui = Math.max, p1 = Math.sin, g1 = Math.cos, Ou = Math.PI * 2, Hm = yu(), Gm = yu(), zm = yu();
function rw(e, t, r) {
  if (e.length !== 0) {
    for (var n = e[0], i = n[0], o = n[0], a = n[1], s = n[1], l = 1; l < e.length; l++)
      n = e[l], i = ji(i, n[0]), o = Ui(o, n[0]), a = ji(a, n[1]), s = Ui(s, n[1]);
    t[0] = i, t[1] = a, r[0] = o, r[1] = s;
  }
}
function uN(e, t, r, n, i, o) {
  i[0] = ji(e, r), i[1] = ji(t, n), o[0] = Ui(e, r), o[1] = Ui(t, n);
}
var cN = [], dN = [];
function vSe(e, t, r, n, i, o, a, s, l, u) {
  var c = j6, d = Fn, h = c(e, r, i, a, cN);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var f = 0; f < h; f++) {
    var p = d(e, r, i, a, cN[f]);
    l[0] = ji(p, l[0]), u[0] = Ui(p, u[0]);
  }
  h = c(t, n, o, s, dN);
  for (var f = 0; f < h; f++) {
    var g = d(t, n, o, s, dN[f]);
    l[1] = ji(g, l[1]), u[1] = Ui(g, u[1]);
  }
  l[0] = ji(e, l[0]), u[0] = Ui(e, u[0]), l[0] = ji(a, l[0]), u[0] = Ui(a, u[0]), l[1] = ji(t, l[1]), u[1] = Ui(t, u[1]), l[1] = ji(s, l[1]), u[1] = Ui(s, u[1]);
}
function mSe(e, t, r, n, i, o, a, s) {
  var l = K6, u = zn, c = Ui(ji(l(e, r, i), 1), 0), d = Ui(ji(l(t, n, o), 1), 0), h = u(e, r, i, c), f = u(t, n, o, d);
  a[0] = ji(e, i, h), a[1] = ji(t, o, f), s[0] = Ui(e, i, h), s[1] = Ui(t, o, f);
}
function ySe(e, t, r, n, i, o, a, s, l) {
  var u = Vs, c = Bs, d = Math.abs(i - o);
  if (d % Ou < 1e-4 && d > 1e-4) {
    s[0] = e - r, s[1] = t - n, l[0] = e + r, l[1] = t + n;
    return;
  }
  if (Hm[0] = g1(i) * r + e, Hm[1] = p1(i) * n + t, Gm[0] = g1(o) * r + e, Gm[1] = p1(o) * n + t, u(s, Hm, Gm), c(l, Hm, Gm), i = i % Ou, i < 0 && (i = i + Ou), o = o % Ou, o < 0 && (o = o + Ou), i > o && !a ? o += Ou : i < o && a && (i += Ou), a) {
    var h = o;
    o = i, i = h;
  }
  for (var f = 0; f < o; f += Math.PI / 2)
    f > i && (zm[0] = g1(f) * r + e, zm[1] = p1(f) * n + t, u(s, zm, s), c(l, zm, l));
}
var Lr = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, Lu = [], Fu = [], Ha = [], vl = [], Ga = [], za = [], v1 = Math.min, m1 = Math.max, Nu = Math.cos, ku = Math.sin, _s = Math.abs, L_ = Math.PI, _l = L_ * 2, y1 = typeof Float32Array < "u", ep = [];
function C1(e) {
  var t = Math.round(e / L_ * 1e8) / 1e8;
  return t % 2 * L_;
}
function QM(e, t) {
  var r = C1(e[0]);
  r < 0 && (r += _l);
  var n = r - e[0], i = e[1];
  i += n, !t && i - r >= _l ? i = r + _l : t && r - i >= _l ? i = r - _l : !t && r > i ? i = r + (_l - C1(r - i)) : t && r < i && (i = r - (_l - C1(i - r))), e[0] = r, e[1] = i;
}
var ms = function() {
  function e(t) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return e.prototype.increaseVersion = function() {
    this._version++;
  }, e.prototype.getVersion = function() {
    return this._version;
  }, e.prototype.setScale = function(t, r, n) {
    n = n || 0, n > 0 && (this._ux = _s(n / iC / t) || 0, this._uy = _s(n / iC / r) || 0);
  }, e.prototype.setDPR = function(t) {
    this.dpr = t;
  }, e.prototype.setContext = function(t) {
    this._ctx = t;
  }, e.prototype.getContext = function() {
    return this._ctx;
  }, e.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, e.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, e.prototype.moveTo = function(t, r) {
    return this._drawPendingPt(), this.addData(Lr.M, t, r), this._ctx && this._ctx.moveTo(t, r), this._x0 = t, this._y0 = r, this._xi = t, this._yi = r, this;
  }, e.prototype.lineTo = function(t, r) {
    var n = _s(t - this._xi), i = _s(r - this._yi), o = n > this._ux || i > this._uy;
    if (this.addData(Lr.L, t, r), this._ctx && o && this._ctx.lineTo(t, r), o)
      this._xi = t, this._yi = r, this._pendingPtDist = 0;
    else {
      var a = n * n + i * i;
      a > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = r, this._pendingPtDist = a);
    }
    return this;
  }, e.prototype.bezierCurveTo = function(t, r, n, i, o, a) {
    return this._drawPendingPt(), this.addData(Lr.C, t, r, n, i, o, a), this._ctx && this._ctx.bezierCurveTo(t, r, n, i, o, a), this._xi = o, this._yi = a, this;
  }, e.prototype.quadraticCurveTo = function(t, r, n, i) {
    return this._drawPendingPt(), this.addData(Lr.Q, t, r, n, i), this._ctx && this._ctx.quadraticCurveTo(t, r, n, i), this._xi = n, this._yi = i, this;
  }, e.prototype.arc = function(t, r, n, i, o, a) {
    this._drawPendingPt(), ep[0] = i, ep[1] = o, QM(ep, a), i = ep[0], o = ep[1];
    var s = o - i;
    return this.addData(Lr.A, t, r, n, n, i, s, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, r, n, i, o, a), this._xi = Nu(o) * n + t, this._yi = ku(o) * n + r, this;
  }, e.prototype.arcTo = function(t, r, n, i, o) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, r, n, i, o), this;
  }, e.prototype.rect = function(t, r, n, i) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(t, r, n, i), this.addData(Lr.R, t, r, n, i), this;
  }, e.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(Lr.Z);
    var t = this._ctx, r = this._x0, n = this._y0;
    return t && t.closePath(), this._xi = r, this._yi = n, this;
  }, e.prototype.fill = function(t) {
    t && t.fill(), this.toStatic();
  }, e.prototype.stroke = function(t) {
    t && t.stroke(), this.toStatic();
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.setData = function(t) {
    var r = t.length;
    !(this.data && this.data.length === r) && y1 && (this.data = new Float32Array(r));
    for (var n = 0; n < r; n++)
      this.data[n] = t[n];
    this._len = r;
  }, e.prototype.appendPath = function(t) {
    t instanceof Array || (t = [t]);
    for (var r = t.length, n = 0, i = this._len, o = 0; o < r; o++)
      n += t[o].len();
    y1 && this.data instanceof Float32Array && (this.data = new Float32Array(i + n));
    for (var o = 0; o < r; o++)
      for (var a = t[o].data, s = 0; s < a.length; s++)
        this.data[i++] = a[s];
    this._len = i;
  }, e.prototype.addData = function(t, r, n, i, o, a, s, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var d = 0; d < arguments.length; d++)
        c[this._len++] = arguments[d];
    }
  }, e.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, e.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var t = [], r = 0; r < this._len; r++)
        t[r] = this.data[r];
      this.data = t;
    }
  }, e.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var t = this.data;
      t instanceof Array && (t.length = this._len, y1 && this._len > 11 && (this.data = new Float32Array(t)));
    }
  }, e.prototype.getBoundingRect = function() {
    Ha[0] = Ha[1] = Ga[0] = Ga[1] = Number.MAX_VALUE, vl[0] = vl[1] = za[0] = za[1] = -Number.MAX_VALUE;
    var t = this.data, r = 0, n = 0, i = 0, o = 0, a;
    for (a = 0; a < this._len; ) {
      var s = t[a++], l = a === 1;
      switch (l && (r = t[a], n = t[a + 1], i = r, o = n), s) {
        case Lr.M:
          r = i = t[a++], n = o = t[a++], Ga[0] = i, Ga[1] = o, za[0] = i, za[1] = o;
          break;
        case Lr.L:
          uN(r, n, t[a], t[a + 1], Ga, za), r = t[a++], n = t[a++];
          break;
        case Lr.C:
          vSe(r, n, t[a++], t[a++], t[a++], t[a++], t[a], t[a + 1], Ga, za), r = t[a++], n = t[a++];
          break;
        case Lr.Q:
          mSe(r, n, t[a++], t[a++], t[a], t[a + 1], Ga, za), r = t[a++], n = t[a++];
          break;
        case Lr.A:
          var u = t[a++], c = t[a++], d = t[a++], h = t[a++], f = t[a++], p = t[a++] + f;
          a += 1;
          var g = !t[a++];
          l && (i = Nu(f) * d + u, o = ku(f) * h + c), ySe(u, c, d, h, f, p, g, Ga, za), r = Nu(p) * d + u, n = ku(p) * h + c;
          break;
        case Lr.R:
          i = r = t[a++], o = n = t[a++];
          var v = t[a++], m = t[a++];
          uN(i, o, i + v, o + m, Ga, za);
          break;
        case Lr.Z:
          r = i, n = o;
          break;
      }
      Vs(Ha, Ha, Ga), Bs(vl, vl, za);
    }
    return a === 0 && (Ha[0] = Ha[1] = vl[0] = vl[1] = 0), new At(Ha[0], Ha[1], vl[0] - Ha[0], vl[1] - Ha[1]);
  }, e.prototype._calculateLength = function() {
    var t = this.data, r = this._len, n = this._ux, i = this._uy, o = 0, a = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, d = 0, h = 0; h < r; ) {
      var f = t[h++], p = h === 1;
      p && (o = t[h], a = t[h + 1], s = o, l = a);
      var g = -1;
      switch (f) {
        case Lr.M:
          o = s = t[h++], a = l = t[h++];
          break;
        case Lr.L: {
          var v = t[h++], m = t[h++], y = v - o, C = m - a;
          (_s(y) > n || _s(C) > i || h === r - 1) && (g = Math.sqrt(y * y + C * C), o = v, a = m);
          break;
        }
        case Lr.C: {
          var S = t[h++], b = t[h++], v = t[h++], m = t[h++], w = t[h++], x = t[h++];
          g = D0e(o, a, S, b, v, m, w, x, 10), o = w, a = x;
          break;
        }
        case Lr.Q: {
          var S = t[h++], b = t[h++], v = t[h++], m = t[h++];
          g = I0e(o, a, S, b, v, m, 10), o = v, a = m;
          break;
        }
        case Lr.A:
          var R = t[h++], _ = t[h++], T = t[h++], P = t[h++], D = t[h++], O = t[h++], A = O + D;
          h += 1, p && (s = Nu(D) * T + R, l = ku(D) * P + _), g = m1(T, P) * v1(_l, Math.abs(O)), o = Nu(A) * T + R, a = ku(A) * P + _;
          break;
        case Lr.R: {
          s = o = t[h++], l = a = t[h++];
          var F = t[h++], L = t[h++];
          g = F * 2 + L * 2;
          break;
        }
        case Lr.Z: {
          var y = s - o, C = l - a;
          g = Math.sqrt(y * y + C * C), o = s, a = l;
          break;
        }
      }
      g >= 0 && (u[d++] = g, c += g);
    }
    return this._pathLen = c, c;
  }, e.prototype.rebuildPath = function(t, r) {
    var n = this.data, i = this._ux, o = this._uy, a = this._len, s, l, u, c, d, h, f = r < 1, p, g, v = 0, m = 0, y, C = 0, S, b;
    if (!(f && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, g = this._pathLen, y = r * g, !y)))
      e: for (var w = 0; w < a; ) {
        var x = n[w++], R = w === 1;
        switch (R && (u = n[w], c = n[w + 1], s = u, l = c), x !== Lr.L && C > 0 && (t.lineTo(S, b), C = 0), x) {
          case Lr.M:
            s = u = n[w++], l = c = n[w++], t.moveTo(u, c);
            break;
          case Lr.L: {
            d = n[w++], h = n[w++];
            var _ = _s(d - u), T = _s(h - c);
            if (_ > i || T > o) {
              if (f) {
                var P = p[m++];
                if (v + P > y) {
                  var D = (y - v) / P;
                  t.lineTo(u * (1 - D) + d * D, c * (1 - D) + h * D);
                  break e;
                }
                v += P;
              }
              t.lineTo(d, h), u = d, c = h, C = 0;
            } else {
              var O = _ * _ + T * T;
              O > C && (S = d, b = h, C = O);
            }
            break;
          }
          case Lr.C: {
            var A = n[w++], F = n[w++], L = n[w++], N = n[w++], I = n[w++], B = n[w++];
            if (f) {
              var P = p[m++];
              if (v + P > y) {
                var D = (y - v) / P;
                iu(u, A, L, I, D, Lu), iu(c, F, N, B, D, Fu), t.bezierCurveTo(Lu[1], Fu[1], Lu[2], Fu[2], Lu[3], Fu[3]);
                break e;
              }
              v += P;
            }
            t.bezierCurveTo(A, F, L, N, I, B), u = I, c = B;
            break;
          }
          case Lr.Q: {
            var A = n[w++], F = n[w++], L = n[w++], N = n[w++];
            if (f) {
              var P = p[m++];
              if (v + P > y) {
                var D = (y - v) / P;
                $g(u, A, L, D, Lu), $g(c, F, N, D, Fu), t.quadraticCurveTo(Lu[1], Fu[1], Lu[2], Fu[2]);
                break e;
              }
              v += P;
            }
            t.quadraticCurveTo(A, F, L, N), u = L, c = N;
            break;
          }
          case Lr.A:
            var M = n[w++], V = n[w++], G = n[w++], k = n[w++], z = n[w++], j = n[w++], q = n[w++], K = !n[w++], Z = G > k ? G : k, re = _s(G - k) > 1e-3, X = z + j, Y = !1;
            if (f) {
              var P = p[m++];
              v + P > y && (X = z + j * (y - v) / P, Y = !0), v += P;
            }
            if (re && t.ellipse ? t.ellipse(M, V, G, k, q, z, X, K) : t.arc(M, V, Z, z, X, K), Y)
              break e;
            R && (s = Nu(z) * G + M, l = ku(z) * k + V), u = Nu(X) * G + M, c = ku(X) * k + V;
            break;
          case Lr.R:
            s = u = n[w], l = c = n[w + 1], d = n[w++], h = n[w++];
            var U = n[w++], oe = n[w++];
            if (f) {
              var P = p[m++];
              if (v + P > y) {
                var W = y - v;
                t.moveTo(d, h), t.lineTo(d + v1(W, U), h), W -= U, W > 0 && t.lineTo(d + U, h + v1(W, oe)), W -= oe, W > 0 && t.lineTo(d + m1(U - W, 0), h + oe), W -= U, W > 0 && t.lineTo(d, h + m1(oe - W, 0));
                break e;
              }
              v += P;
            }
            t.rect(d, h, U, oe);
            break;
          case Lr.Z:
            if (f) {
              var P = p[m++];
              if (v + P > y) {
                var D = (y - v) / P;
                t.lineTo(u * (1 - D) + s * D, c * (1 - D) + l * D);
                break e;
              }
              v += P;
            }
            t.closePath(), u = s, c = l;
        }
      }
  }, e.prototype.clone = function() {
    var t = new e(), r = this.data;
    return t.data = r.slice ? r.slice() : Array.prototype.slice.call(r), t._len = this._len, t;
  }, e.CMD = Lr, e.initDefaultProps = function() {
    var t = e.prototype;
    t._saveData = !0, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
  }(), e;
}();
function Pl(e, t, r, n, i, o, a) {
  if (i === 0)
    return !1;
  var s = i, l = 0, u = e;
  if (a > t + s && a > n + s || a < t - s && a < n - s || o > e + s && o > r + s || o < e - s && o < r - s)
    return !1;
  if (e !== r)
    l = (t - n) / (e - r), u = (e * n - r * t) / (e - r);
  else
    return Math.abs(o - e) <= s / 2;
  var c = l * o - a + u, d = c * c / (l * l + 1);
  return d <= s / 2 * s / 2;
}
function CSe(e, t, r, n, i, o, a, s, l, u, c) {
  if (l === 0)
    return !1;
  var d = l;
  if (c > t + d && c > n + d && c > o + d && c > s + d || c < t - d && c < n - d && c < o - d && c < s - d || u > e + d && u > r + d && u > i + d && u > a + d || u < e - d && u < r - d && u < i - d && u < a - d)
    return !1;
  var h = U6(e, t, r, n, i, o, a, s, u, c, null);
  return h <= d / 2;
}
function MW(e, t, r, n, i, o, a, s, l) {
  if (a === 0)
    return !1;
  var u = a;
  if (l > t + u && l > n + u && l > o + u || l < t - u && l < n - u && l < o - u || s > e + u && s > r + u && s > i + u || s < e - u && s < r - u && s < i - u)
    return !1;
  var c = Y6(e, t, r, n, i, o, s, l, null);
  return c <= u / 2;
}
var hN = Math.PI * 2;
function mo(e) {
  return e %= hN, e < 0 && (e += hN), e;
}
var tp = Math.PI * 2;
function SSe(e, t, r, n, i, o, a, s, l) {
  if (a === 0)
    return !1;
  var u = a;
  s -= e, l -= t;
  var c = Math.sqrt(s * s + l * l);
  if (c - u > r || c + u < r)
    return !1;
  if (Math.abs(n - i) % tp < 1e-4)
    return !0;
  if (o) {
    var d = n;
    n = mo(i), i = mo(d);
  } else
    n = mo(n), i = mo(i);
  n > i && (i += tp);
  var h = Math.atan2(l, s);
  return h < 0 && (h += tp), h >= n && h <= i || h + tp >= n && h + tp <= i;
}
function Os(e, t, r, n, i, o) {
  if (o > t && o > n || o < t && o < n || n === t)
    return 0;
  var a = (o - t) / (n - t), s = n < t ? 1 : -1;
  (a === 1 || a === 0) && (s = n < t ? 0.5 : -0.5);
  var l = a * (r - e) + e;
  return l === i ? 1 / 0 : l > i ? s : 0;
}
var ml = ms.CMD, Vu = Math.PI * 2, wSe = 1e-4;
function bSe(e, t) {
  return Math.abs(e - t) < wSe;
}
var wi = [-1, -1, -1], Vo = [-1, -1];
function xSe() {
  var e = Vo[0];
  Vo[0] = Vo[1], Vo[1] = e;
}
function ESe(e, t, r, n, i, o, a, s, l, u) {
  if (u > t && u > n && u > o && u > s || u < t && u < n && u < o && u < s)
    return 0;
  var c = eC(t, n, o, s, u, wi);
  if (c === 0)
    return 0;
  for (var d = 0, h = -1, f = void 0, p = void 0, g = 0; g < c; g++) {
    var v = wi[g], m = v === 0 || v === 1 ? 0.5 : 1, y = Fn(e, r, i, a, v);
    y < l || (h < 0 && (h = j6(t, n, o, s, Vo), Vo[1] < Vo[0] && h > 1 && xSe(), f = Fn(t, n, o, s, Vo[0]), h > 1 && (p = Fn(t, n, o, s, Vo[1]))), h === 2 ? v < Vo[0] ? d += f < t ? m : -m : v < Vo[1] ? d += p < f ? m : -m : d += s < p ? m : -m : v < Vo[0] ? d += f < t ? m : -m : d += s < f ? m : -m);
  }
  return d;
}
function RSe(e, t, r, n, i, o, a, s) {
  if (s > t && s > n && s > o || s < t && s < n && s < o)
    return 0;
  var l = A0e(t, n, o, s, wi);
  if (l === 0)
    return 0;
  var u = K6(t, n, o);
  if (u >= 0 && u <= 1) {
    for (var c = 0, d = zn(t, n, o, u), h = 0; h < l; h++) {
      var f = wi[h] === 0 || wi[h] === 1 ? 0.5 : 1, p = zn(e, r, i, wi[h]);
      p < a || (wi[h] < u ? c += d < t ? f : -f : c += o < d ? f : -f);
    }
    return c;
  } else {
    var f = wi[0] === 0 || wi[0] === 1 ? 0.5 : 1, p = zn(e, r, i, wi[0]);
    return p < a ? 0 : o < t ? f : -f;
  }
}
function _Se(e, t, r, n, i, o, a, s) {
  if (s -= t, s > r || s < -r)
    return 0;
  var l = Math.sqrt(r * r - s * s);
  wi[0] = -l, wi[1] = l;
  var u = Math.abs(n - i);
  if (u < 1e-4)
    return 0;
  if (u >= Vu - 1e-4) {
    n = 0, i = Vu;
    var c = o ? 1 : -1;
    return a >= wi[0] + e && a <= wi[1] + e ? c : 0;
  }
  if (n > i) {
    var d = n;
    n = i, i = d;
  }
  n < 0 && (n += Vu, i += Vu);
  for (var h = 0, f = 0; f < 2; f++) {
    var p = wi[f];
    if (p + e > a) {
      var g = Math.atan2(s, p), c = o ? 1 : -1;
      g < 0 && (g = Vu + g), (g >= n && g <= i || g + Vu >= n && g + Vu <= i) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), h += c);
    }
  }
  return h;
}
function DW(e, t, r, n, i) {
  for (var o = e.data, a = e.len(), s = 0, l = 0, u = 0, c = 0, d = 0, h, f, p = 0; p < a; ) {
    var g = o[p++], v = p === 1;
    switch (g === ml.M && p > 1 && (r || (s += Os(l, u, c, d, n, i))), v && (l = o[p], u = o[p + 1], c = l, d = u), g) {
      case ml.M:
        c = o[p++], d = o[p++], l = c, u = d;
        break;
      case ml.L:
        if (r) {
          if (Pl(l, u, o[p], o[p + 1], t, n, i))
            return !0;
        } else
          s += Os(l, u, o[p], o[p + 1], n, i) || 0;
        l = o[p++], u = o[p++];
        break;
      case ml.C:
        if (r) {
          if (CSe(l, u, o[p++], o[p++], o[p++], o[p++], o[p], o[p + 1], t, n, i))
            return !0;
        } else
          s += ESe(l, u, o[p++], o[p++], o[p++], o[p++], o[p], o[p + 1], n, i) || 0;
        l = o[p++], u = o[p++];
        break;
      case ml.Q:
        if (r) {
          if (MW(l, u, o[p++], o[p++], o[p], o[p + 1], t, n, i))
            return !0;
        } else
          s += RSe(l, u, o[p++], o[p++], o[p], o[p + 1], n, i) || 0;
        l = o[p++], u = o[p++];
        break;
      case ml.A:
        var m = o[p++], y = o[p++], C = o[p++], S = o[p++], b = o[p++], w = o[p++];
        p += 1;
        var x = !!(1 - o[p++]);
        h = Math.cos(b) * C + m, f = Math.sin(b) * S + y, v ? (c = h, d = f) : s += Os(l, u, h, f, n, i);
        var R = (n - m) * S / C + m;
        if (r) {
          if (SSe(m, y, S, b, b + w, x, t, R, i))
            return !0;
        } else
          s += _Se(m, y, S, b, b + w, x, R, i);
        l = Math.cos(b + w) * C + m, u = Math.sin(b + w) * S + y;
        break;
      case ml.R:
        c = l = o[p++], d = u = o[p++];
        var _ = o[p++], T = o[p++];
        if (h = c + _, f = d + T, r) {
          if (Pl(c, d, h, d, t, n, i) || Pl(h, d, h, f, t, n, i) || Pl(h, f, c, f, t, n, i) || Pl(c, f, c, d, t, n, i))
            return !0;
        } else
          s += Os(h, d, h, f, n, i), s += Os(c, f, c, d, n, i);
        break;
      case ml.Z:
        if (r) {
          if (Pl(l, u, c, d, t, n, i))
            return !0;
        } else
          s += Os(l, u, c, d, n, i);
        l = c, u = d;
        break;
    }
  }
  return !r && !bSe(u, d) && (s += Os(l, u, c, d, n, i) || 0), s !== 0;
}
function TSe(e, t, r) {
  return DW(e, 0, !1, t, r);
}
function PSe(e, t, r, n) {
  return DW(e, t, !0, r, n);
}
var sC = ut({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, Tc), MSe = {
  style: ut({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, tw.style)
}, S1 = gs.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), Ht = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.update = function() {
    var r = this;
    e.prototype.update.call(this);
    var n = this.style;
    if (n.decal) {
      var i = this._decalEl = this._decalEl || new t();
      i.buildPath === t.prototype.buildPath && (i.buildPath = function(l) {
        r.buildPath(l, r.shape);
      }), i.silent = !0;
      var o = i.style;
      for (var a in n)
        o[a] !== n[a] && (o[a] = n[a]);
      o.fill = n.fill ? n.decal : null, o.decal = null, o.shadowColor = null, n.strokeFirst && (o.stroke = null);
      for (var s = 0; s < S1.length; ++s)
        i[S1[s]] = this[S1[s]];
      i.__dirty |= ho;
    } else this._decalEl && (this._decalEl = null);
  }, t.prototype.getDecalElement = function() {
    return this._decalEl;
  }, t.prototype._init = function(r) {
    var n = jt(r);
    this.shape = this.getDefaultShape();
    var i = this.getDefaultStyle();
    i && this.useStyle(i);
    for (var o = 0; o < n.length; o++) {
      var a = n[o], s = r[a];
      a === "style" ? this.style ? ge(this.style, s) : this.useStyle(s) : a === "shape" ? ge(this.shape, s) : e.prototype.attrKV.call(this, a, s);
    }
    this.style || this.useStyle({});
  }, t.prototype.getDefaultStyle = function() {
    return null;
  }, t.prototype.getDefaultShape = function() {
    return {};
  }, t.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, t.prototype.getInsideTextFill = function() {
    var r = this.style.fill;
    if (r !== "none") {
      if (He(r)) {
        var n = zg(r, 0);
        return n > 0.5 ? R_ : n > 0.2 ? uCe : __;
      } else if (r)
        return __;
    }
    return R_;
  }, t.prototype.getInsideTextStroke = function(r) {
    var n = this.style.fill;
    if (He(n)) {
      var i = this.__zr, o = !!(i && i.isDarkMode()), a = zg(r, 0) < E_;
      if (o === a)
        return n;
    }
  }, t.prototype.buildPath = function(r, n, i) {
  }, t.prototype.pathUpdated = function() {
    this.__dirty &= ~nh;
  }, t.prototype.getUpdatedPathProxy = function(r) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, r), this.path;
  }, t.prototype.createPathProxy = function() {
    this.path = new ms(!1);
  }, t.prototype.hasStroke = function() {
    var r = this.style, n = r.stroke;
    return !(n == null || n === "none" || !(r.lineWidth > 0));
  }, t.prototype.hasFill = function() {
    var r = this.style, n = r.fill;
    return n != null && n !== "none";
  }, t.prototype.getBoundingRect = function() {
    var r = this._rect, n = this.style, i = !r;
    if (i) {
      var o = !1;
      this.path || (o = !0, this.createPathProxy());
      var a = this.path;
      (o || this.__dirty & nh) && (a.beginPath(), this.buildPath(a, this.shape, !1), this.pathUpdated()), r = a.getBoundingRect();
    }
    if (this._rect = r, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = r.clone());
      if (this.__dirty || i) {
        s.copy(r);
        var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return r;
  }, t.prototype.contain = function(r, n) {
    var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect(), a = this.style;
    if (r = i[0], n = i[1], o.contain(r, n)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = a.lineWidth, u = a.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), PSe(s, l / u, r, n)))
          return !0;
      }
      if (this.hasFill())
        return TSe(s, r, n);
    }
    return !1;
  }, t.prototype.dirtyShape = function() {
    this.__dirty |= nh, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, t.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, t.prototype.animateShape = function(r) {
    return this.animate("shape", r);
  }, t.prototype.updateDuringAnimation = function(r) {
    r === "style" ? this.dirtyStyle() : r === "shape" ? this.dirtyShape() : this.markRedraw();
  }, t.prototype.attrKV = function(r, n) {
    r === "shape" ? this.setShape(n) : e.prototype.attrKV.call(this, r, n);
  }, t.prototype.setShape = function(r, n) {
    var i = this.shape;
    return i || (i = this.shape = {}), typeof r == "string" ? i[r] = n : ge(i, r), this.dirtyShape(), this;
  }, t.prototype.shapeChanged = function() {
    return !!(this.__dirty & nh);
  }, t.prototype.createStyle = function(r) {
    return Av(sC, r);
  }, t.prototype._innerSaveToNormal = function(r) {
    e.prototype._innerSaveToNormal.call(this, r);
    var n = this._normalState;
    r.shape && !n.shape && (n.shape = ge({}, this.shape));
  }, t.prototype._applyStateObj = function(r, n, i, o, a, s) {
    e.prototype._applyStateObj.call(this, r, n, i, o, a, s);
    var l = !(n && o), u;
    if (n && n.shape ? a ? o ? u = n.shape : (u = ge({}, i.shape), ge(u, n.shape)) : (u = ge({}, o ? this.shape : i.shape), ge(u, n.shape)) : l && (u = i.shape), u)
      if (a) {
        this.shape = ge({}, this.shape);
        for (var c = {}, d = jt(u), h = 0; h < d.length; h++) {
          var f = d[h];
          typeof u[f] == "object" ? this.shape[f] = u[f] : c[f] = u[f];
        }
        this._transitionState(r, {
          shape: c
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, t.prototype._mergeStates = function(r) {
    for (var n = e.prototype._mergeStates.call(this, r), i, o = 0; o < r.length; o++) {
      var a = r[o];
      a.shape && (i = i || {}, this._mergeStyle(i, a.shape));
    }
    return i && (n.shape = i), n;
  }, t.prototype.getAnimationStyleProps = function() {
    return MSe;
  }, t.prototype.isZeroArea = function() {
    return !1;
  }, t.extend = function(r) {
    var n = function(o) {
      Ur(a, o);
      function a(s) {
        var l = o.call(this, s) || this;
        return r.init && r.init.call(l, s), l;
      }
      return a.prototype.getDefaultStyle = function() {
        return dt(r.style);
      }, a.prototype.getDefaultShape = function() {
        return dt(r.shape);
      }, a;
    }(t);
    for (var i in r)
      typeof r[i] == "function" && (n.prototype[i] = r[i]);
    return n;
  }, t.initDefaultProps = function() {
    var r = t.prototype;
    r.type = "path", r.strokeContainThreshold = 5, r.segmentIgnoreThreshold = 0, r.subPixelOptimize = !1, r.autoBatch = !1, r.__dirty = ho | Dp | nh;
  }(), t;
}(ta), DSe = ut({
  strokeFirst: !0,
  font: tu,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, sC), jh = function(e) {
  Ur(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.hasStroke = function() {
    var r = this.style, n = r.stroke;
    return n != null && n !== "none" && r.lineWidth > 0;
  }, t.prototype.hasFill = function() {
    var r = this.style, n = r.fill;
    return n != null && n !== "none";
  }, t.prototype.createStyle = function(r) {
    return Av(DSe, r);
  }, t.prototype.setBoundingRect = function(r) {
    this._rect = r;
  }, t.prototype.getBoundingRect = function() {
    var r = this.style;
    if (!this._rect) {
      var n = r.text;
      n != null ? n += "" : n = "";
      var i = Lv(n, r.font, r.textAlign, r.textBaseline);
      if (i.x += r.x || 0, i.y += r.y || 0, this.hasStroke()) {
        var o = r.lineWidth;
        i.x -= o / 2, i.y -= o / 2, i.width += o, i.height += o;
      }
      this._rect = i;
    }
    return this._rect;
  }, t.initDefaultProps = function() {
    var r = t.prototype;
    r.dirtyRectTolerance = 10;
  }(), t;
}(ta);
jh.prototype.type = "tspan";
var ASe = ut({
  x: 0,
  y: 0
}, Tc), ISe = {
  style: ut({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, tw.style)
};
function OSe(e) {
  return !!(e && typeof e != "string" && e.width && e.height);
}
var AW = function(e) {
  Ur(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.createStyle = function(r) {
    return Av(ASe, r);
  }, t.prototype._getSize = function(r) {
    var n = this.style, i = n[r];
    if (i != null)
      return i;
    var o = OSe(n.image) ? n.image : this.__image;
    if (!o)
      return 0;
    var a = r === "width" ? "height" : "width", s = n[a];
    return s == null ? o[r] : o[r] / o[a] * s;
  }, t.prototype.getWidth = function() {
    return this._getSize("width");
  }, t.prototype.getHeight = function() {
    return this._getSize("height");
  }, t.prototype.getAnimationStyleProps = function() {
    return ISe;
  }, t.prototype.getBoundingRect = function() {
    var r = this.style;
    return this._rect || (this._rect = new At(r.x || 0, r.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, t;
}(ta);
AW.prototype.type = "image";
const qn = AW;
function LSe(e, t) {
  var r = t.x, n = t.y, i = t.width, o = t.height, a = t.r, s, l, u, c;
  i < 0 && (r = r + i, i = -i), o < 0 && (n = n + o, o = -o), typeof a == "number" ? s = l = u = c = a : a instanceof Array ? a.length === 1 ? s = l = u = c = a[0] : a.length === 2 ? (s = u = a[0], l = c = a[1]) : a.length === 3 ? (s = a[0], l = c = a[1], u = a[2]) : (s = a[0], l = a[1], u = a[2], c = a[3]) : s = l = u = c = 0;
  var d;
  s + l > i && (d = s + l, s *= i / d, l *= i / d), u + c > i && (d = u + c, u *= i / d, c *= i / d), l + u > o && (d = l + u, l *= o / d, u *= o / d), s + c > o && (d = s + c, s *= o / d, c *= o / d), e.moveTo(r + s, n), e.lineTo(r + i - l, n), l !== 0 && e.arc(r + i - l, n + l, l, -Math.PI / 2, 0), e.lineTo(r + i, n + o - u), u !== 0 && e.arc(r + i - u, n + o - u, u, 0, Math.PI / 2), e.lineTo(r + c, n + o), c !== 0 && e.arc(r + c, n + o - c, c, Math.PI / 2, Math.PI), e.lineTo(r, n + s), s !== 0 && e.arc(r + s, n + s, s, Math.PI, Math.PI * 1.5);
}
var gh = Math.round;
function IW(e, t, r) {
  if (t) {
    var n = t.x1, i = t.x2, o = t.y1, a = t.y2;
    e.x1 = n, e.x2 = i, e.y1 = o, e.y2 = a;
    var s = r && r.lineWidth;
    return s && (gh(n * 2) === gh(i * 2) && (e.x1 = e.x2 = vc(n, s, !0)), gh(o * 2) === gh(a * 2) && (e.y1 = e.y2 = vc(o, s, !0))), e;
  }
}
function OW(e, t, r) {
  if (t) {
    var n = t.x, i = t.y, o = t.width, a = t.height;
    e.x = n, e.y = i, e.width = o, e.height = a;
    var s = r && r.lineWidth;
    return s && (e.x = vc(n, s, !0), e.y = vc(i, s, !0), e.width = Math.max(vc(n + o, s, !1) - e.x, o === 0 ? 0 : 1), e.height = Math.max(vc(i + a, s, !1) - e.y, a === 0 ? 0 : 1)), e;
  }
}
function vc(e, t, r) {
  if (!t)
    return e;
  var n = gh(e * 2);
  return (n + gh(t)) % 2 === 0 ? n / 2 : (n + (r ? 1 : -1)) / 2;
}
var FSe = /* @__PURE__ */ function() {
  function e() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return e;
}(), NSe = {}, LW = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new FSe();
  }, t.prototype.buildPath = function(r, n) {
    var i, o, a, s;
    if (this.subPixelOptimize) {
      var l = OW(NSe, n, this.style);
      i = l.x, o = l.y, a = l.width, s = l.height, l.r = n.r, n = l;
    } else
      i = n.x, o = n.y, a = n.width, s = n.height;
    n.r ? LSe(r, n) : r.rect(i, o, a, s);
  }, t.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, t;
}(Ht);
LW.prototype.type = "rect";
const or = LW;
var fN = {
  fill: "#000"
}, pN = 2, kSe = {
  style: ut({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, tw.style)
}, FW = function(e) {
  Ur(t, e);
  function t(r) {
    var n = e.call(this) || this;
    return n.type = "text", n._children = [], n._defaultStyle = fN, n.attr(r), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.update = function() {
    e.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var r = 0; r < this._children.length; r++) {
      var n = this._children[r];
      n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
    }
  }, t.prototype.updateTransform = function() {
    var r = this.innerTransformable;
    r ? (r.updateTransform(), r.transform && (this.transform = r.transform)) : e.prototype.updateTransform.call(this);
  }, t.prototype.getLocalTransform = function(r) {
    var n = this.innerTransformable;
    return n ? n.getLocalTransform(r) : e.prototype.getLocalTransform.call(this, r);
  }, t.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), e.prototype.getComputedTransform.call(this);
  }, t.prototype._updateSubTexts = function() {
    this._childCursor = 0, $Se(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, t.prototype.addSelfToZr = function(r) {
    e.prototype.addSelfToZr.call(this, r);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = r;
  }, t.prototype.removeSelfFromZr = function(r) {
    e.prototype.removeSelfFromZr.call(this, r);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = null;
  }, t.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var r = new At(0, 0, 0, 0), n = this._children, i = [], o = null, a = 0; a < n.length; a++) {
        var s = n[a], l = s.getBoundingRect(), u = s.getLocalTransform(i);
        u ? (r.copy(l), r.applyTransform(u), o = o || r.clone(), o.union(r)) : (o = o || l.clone(), o.union(l));
      }
      this._rect = o || r;
    }
    return this._rect;
  }, t.prototype.setDefaultTextStyle = function(r) {
    this._defaultStyle = r || fN;
  }, t.prototype.setTextContent = function(r) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, t.prototype._mergeStyle = function(r, n) {
    if (!n)
      return r;
    var i = n.rich, o = r.rich || i && {};
    return ge(r, n), i && o ? (this._mergeRich(o, i), r.rich = o) : o && (r.rich = o), r;
  }, t.prototype._mergeRich = function(r, n) {
    for (var i = jt(n), o = 0; o < i.length; o++) {
      var a = i[o];
      r[a] = r[a] || {}, ge(r[a], n[a]);
    }
  }, t.prototype.getAnimationStyleProps = function() {
    return kSe;
  }, t.prototype._getOrCreateChild = function(r) {
    var n = this._children[this._childCursor];
    return (!n || !(n instanceof r)) && (n = new r()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
  }, t.prototype._updatePlainTexts = function() {
    var r = this.style, n = r.font || tu, i = r.padding, o = wN(r), a = aSe(o, r), s = w1(r), l = !!r.backgroundColor, u = a.outerHeight, c = a.outerWidth, d = a.contentWidth, h = a.lines, f = a.lineHeight, p = this._defaultStyle, g = r.x || 0, v = r.y || 0, m = r.align || p.align || "left", y = r.verticalAlign || p.verticalAlign || "top", C = g, S = ih(v, a.contentHeight, y);
    if (s || i) {
      var b = Ip(g, c, m), w = ih(v, u, y);
      s && this._renderBackground(r, r, b, w, c, u);
    }
    S += f / 2, i && (C = SN(g, m, i), y === "top" ? S += i[0] : y === "bottom" && (S -= i[2]));
    for (var x = 0, R = !1, _ = CN("fill" in r ? r.fill : (R = !0, p.fill)), T = yN("stroke" in r ? r.stroke : !l && (!p.autoStroke || R) ? (x = pN, p.stroke) : null), P = r.textShadowBlur > 0, D = r.width != null && (r.overflow === "truncate" || r.overflow === "break" || r.overflow === "breakAll"), O = a.calculatedLineHeight, A = 0; A < h.length; A++) {
      var F = this._getOrCreateChild(jh), L = F.createStyle();
      F.useStyle(L), L.text = h[A], L.x = C, L.y = S, m && (L.textAlign = m), L.textBaseline = "middle", L.opacity = r.opacity, L.strokeFirst = !0, P && (L.shadowBlur = r.textShadowBlur || 0, L.shadowColor = r.textShadowColor || "transparent", L.shadowOffsetX = r.textShadowOffsetX || 0, L.shadowOffsetY = r.textShadowOffsetY || 0), L.stroke = T, L.fill = _, T && (L.lineWidth = r.lineWidth || x, L.lineDash = r.lineDash, L.lineDashOffset = r.lineDashOffset || 0), L.font = n, vN(L, r), S += f, D && F.setBoundingRect(new At(Ip(L.x, r.width, L.textAlign), ih(L.y, O, L.textBaseline), d, O));
    }
  }, t.prototype._updateRichTexts = function() {
    var r = this.style, n = wN(r), i = uSe(n, r), o = i.width, a = i.outerWidth, s = i.outerHeight, l = r.padding, u = r.x || 0, c = r.y || 0, d = this._defaultStyle, h = r.align || d.align, f = r.verticalAlign || d.verticalAlign, p = Ip(u, a, h), g = ih(c, s, f), v = p, m = g;
    l && (v += l[3], m += l[0]);
    var y = v + o;
    w1(r) && this._renderBackground(r, r, p, g, a, s);
    for (var C = !!r.backgroundColor, S = 0; S < i.lines.length; S++) {
      for (var b = i.lines[S], w = b.tokens, x = w.length, R = b.lineHeight, _ = b.width, T = 0, P = v, D = y, O = x - 1, A = void 0; T < x && (A = w[T], !A.align || A.align === "left"); )
        this._placeToken(A, r, R, m, P, "left", C), _ -= A.width, P += A.width, T++;
      for (; O >= 0 && (A = w[O], A.align === "right"); )
        this._placeToken(A, r, R, m, D, "right", C), _ -= A.width, D -= A.width, O--;
      for (P += (o - (P - v) - (y - D) - _) / 2; T <= O; )
        A = w[T], this._placeToken(A, r, R, m, P + A.width / 2, "center", C), P += A.width, T++;
      m += R;
    }
  }, t.prototype._placeToken = function(r, n, i, o, a, s, l) {
    var u = n.rich[r.styleName] || {};
    u.text = r.text;
    var c = r.verticalAlign, d = o + i / 2;
    c === "top" ? d = o + r.height / 2 : c === "bottom" && (d = o + i - r.height / 2);
    var h = !r.isLineHolder && w1(u);
    h && this._renderBackground(u, n, s === "right" ? a - r.width : s === "center" ? a - r.width / 2 : a, d - r.height / 2, r.width, r.height);
    var f = !!u.backgroundColor, p = r.textPadding;
    p && (a = SN(a, s, p), d -= r.height / 2 - p[0] - r.innerHeight / 2);
    var g = this._getOrCreateChild(jh), v = g.createStyle();
    g.useStyle(v);
    var m = this._defaultStyle, y = !1, C = 0, S = CN("fill" in u ? u.fill : "fill" in n ? n.fill : (y = !0, m.fill)), b = yN("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !f && !l && (!m.autoStroke || y) ? (C = pN, m.stroke) : null), w = u.textShadowBlur > 0 || n.textShadowBlur > 0;
    v.text = r.text, v.x = a, v.y = d, w && (v.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, v.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", v.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, v.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), v.textAlign = s, v.textBaseline = "middle", v.font = r.font || tu, v.opacity = So(u.opacity, n.opacity, 1), vN(v, u), b && (v.lineWidth = So(u.lineWidth, n.lineWidth, C), v.lineDash = bt(u.lineDash, n.lineDash), v.lineDashOffset = n.lineDashOffset || 0, v.stroke = b), S && (v.fill = S);
    var x = r.contentWidth, R = r.contentHeight;
    g.setBoundingRect(new At(Ip(v.x, x, v.textAlign), ih(v.y, R, v.textBaseline), x, R));
  }, t.prototype._renderBackground = function(r, n, i, o, a, s) {
    var l = r.backgroundColor, u = r.borderWidth, c = r.borderColor, d = l && l.image, h = l && !d, f = r.borderRadius, p = this, g, v;
    if (h || r.lineHeight || u && c) {
      g = this._getOrCreateChild(or), g.useStyle(g.createStyle()), g.style.fill = null;
      var m = g.shape;
      m.x = i, m.y = o, m.width = a, m.height = s, m.r = f, g.dirtyShape();
    }
    if (h) {
      var y = g.style;
      y.fill = l || null, y.fillOpacity = bt(r.fillOpacity, 1);
    } else if (d) {
      v = this._getOrCreateChild(qn), v.onload = function() {
        p.dirtyStyle();
      };
      var C = v.style;
      C.image = l.image, C.x = i, C.y = o, C.width = a, C.height = s;
    }
    if (u && c) {
      var y = g.style;
      y.lineWidth = u, y.stroke = c, y.strokeOpacity = bt(r.strokeOpacity, 1), y.lineDash = r.borderDash, y.lineDashOffset = r.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var S = (g || v).style;
    S.shadowBlur = r.shadowBlur || 0, S.shadowColor = r.shadowColor || "transparent", S.shadowOffsetX = r.shadowOffsetX || 0, S.shadowOffsetY = r.shadowOffsetY || 0, S.opacity = So(r.opacity, n.opacity, 1);
  }, t.makeFont = function(r) {
    var n = "";
    return kW(r) && (n = [
      r.fontStyle,
      r.fontWeight,
      NW(r.fontSize),
      r.fontFamily || "sans-serif"
    ].join(" ")), n && Wo(n) || r.textFont || r.font;
  }, t;
}(ta), VSe = { left: !0, right: 1, center: 1 }, BSe = { top: 1, bottom: 1, middle: 1 }, gN = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function NW(e) {
  return typeof e == "string" && (e.indexOf("px") !== -1 || e.indexOf("rem") !== -1 || e.indexOf("em") !== -1) ? e : isNaN(+e) ? IM + "px" : e + "px";
}
function vN(e, t) {
  for (var r = 0; r < gN.length; r++) {
    var n = gN[r], i = t[n];
    i != null && (e[n] = i);
  }
}
function kW(e) {
  return e.fontSize != null || e.fontFamily || e.fontWeight;
}
function $Se(e) {
  return mN(e), $(e.rich, mN), e;
}
function mN(e) {
  if (e) {
    e.font = FW.makeFont(e);
    var t = e.align;
    t === "middle" && (t = "center"), e.align = t == null || VSe[t] ? t : "left";
    var r = e.verticalAlign;
    r === "center" && (r = "middle"), e.verticalAlign = r == null || BSe[r] ? r : "top";
    var n = e.padding;
    n && (e.padding = jS(e.padding));
  }
}
function yN(e, t) {
  return e == null || t <= 0 || e === "transparent" || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function CN(e) {
  return e == null || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function SN(e, t, r) {
  return t === "right" ? e - r[1] : t === "center" ? e + r[3] / 2 - r[1] / 2 : e + r[3];
}
function wN(e) {
  var t = e.text;
  return t != null && (t += ""), t;
}
function w1(e) {
  return !!(e.backgroundColor || e.lineHeight || e.borderWidth && e.borderColor);
}
const ir = FW;
var St = ar(), F_ = function(e, t, r, n) {
  if (n) {
    var i = St(n);
    i.dataIndex = r, i.dataType = t, i.seriesIndex = e, i.ssrType = "chart", n.type === "group" && n.traverse(function(o) {
      var a = St(o);
      a.seriesIndex = e, a.dataIndex = r, a.dataType = t, a.ssrType = "chart";
    });
  }
}, bN = 1, xN = {}, VW = ar(), JM = ar(), eD = 0, kv = 1, nw = 2, Ii = ["emphasis", "blur", "select"], jg = ["normal", "emphasis", "blur", "select"], gf = 10, HSe = 9, Pc = "highlight", l0 = "downplay", lg = "select", u0 = "unselect", ug = "toggleSelect";
function Ld(e) {
  return e != null && e !== "none";
}
function iw(e, t, r) {
  e.onHoverStateChange && (e.hoverState || 0) !== r && e.onHoverStateChange(t), e.hoverState = r;
}
function BW(e) {
  iw(e, "emphasis", nw);
}
function $W(e) {
  e.hoverState === nw && iw(e, "normal", eD);
}
function tD(e) {
  iw(e, "blur", kv);
}
function HW(e) {
  e.hoverState === kv && iw(e, "normal", eD);
}
function GSe(e) {
  e.selected = !0;
}
function zSe(e) {
  e.selected = !1;
}
function EN(e, t, r) {
  t(e, r);
}
function ll(e, t, r) {
  EN(e, t, r), e.isGroup && e.traverse(function(n) {
    EN(n, t, r);
  });
}
function lC(e, t) {
  switch (t) {
    case "emphasis":
      e.hoverState = nw;
      break;
    case "normal":
      e.hoverState = eD;
      break;
    case "blur":
      e.hoverState = kv;
      break;
    case "select":
      e.selected = !0;
  }
}
function WSe(e, t, r, n) {
  for (var i = e.style, o = {}, a = 0; a < t.length; a++) {
    var s = t[a], l = i[s];
    o[s] = l ?? (n && n[s]);
  }
  for (var a = 0; a < e.animators.length; a++) {
    var u = e.animators[a];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(r) < 0 && u.targetName === "style" && u.saveTo(o, t);
  }
  return o;
}
function jSe(e, t, r, n) {
  var i = r && Ft(r, "select") >= 0, o = !1;
  if (e instanceof Ht) {
    var a = VW(e), s = i && a.selectFill || a.normalFill, l = i && a.selectStroke || a.normalStroke;
    if (Ld(s) || Ld(l)) {
      n = n || {};
      var u = n.style || {};
      u.fill === "inherit" ? (o = !0, n = ge({}, n), u = ge({}, u), u.fill = s) : !Ld(u.fill) && Ld(s) ? (o = !0, n = ge({}, n), u = ge({}, u), u.fill = rC(s)) : !Ld(u.stroke) && Ld(l) && (o || (n = ge({}, n), u = ge({}, u)), u.stroke = rC(l)), n.style = u;
    }
  }
  if (n && n.z2 == null) {
    o || (n = ge({}, n));
    var c = e.z2EmphasisLift;
    n.z2 = e.z2 + (c ?? gf);
  }
  return n;
}
function USe(e, t, r) {
  if (r && r.z2 == null) {
    r = ge({}, r);
    var n = e.z2SelectLift;
    r.z2 = e.z2 + (n ?? HSe);
  }
  return r;
}
function KSe(e, t, r) {
  var n = Ft(e.currentStates, t) >= 0, i = e.style.opacity, o = n ? null : WSe(e, ["opacity"], t, {
    opacity: 1
  });
  r = r || {};
  var a = r.style || {};
  return a.opacity == null && (r = ge({}, r), a = ge({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: n ? i : o.opacity * 0.1
  }, a), r.style = a), r;
}
function b1(e, t) {
  var r = this.states[e];
  if (this.style) {
    if (e === "emphasis")
      return jSe(this, e, t, r);
    if (e === "blur")
      return KSe(this, e, r);
    if (e === "select")
      return USe(this, e, r);
  }
  return r;
}
function jc(e) {
  e.stateProxy = b1;
  var t = e.getTextContent(), r = e.getTextGuideLine();
  t && (t.stateProxy = b1), r && (r.stateProxy = b1);
}
function RN(e, t) {
  !jW(e, t) && !e.__highByOuter && ll(e, BW);
}
function _N(e, t) {
  !jW(e, t) && !e.__highByOuter && ll(e, $W);
}
function Qs(e, t) {
  e.__highByOuter |= 1 << (t || 0), ll(e, BW);
}
function Js(e, t) {
  !(e.__highByOuter &= ~(1 << (t || 0))) && ll(e, $W);
}
function GW(e) {
  ll(e, tD);
}
function rD(e) {
  ll(e, HW);
}
function zW(e) {
  ll(e, GSe);
}
function WW(e) {
  ll(e, zSe);
}
function jW(e, t) {
  return e.__highDownSilentOnTouch && t.zrByTouch;
}
function UW(e) {
  var t = e.getModel(), r = [], n = [];
  t.eachComponent(function(i, o) {
    var a = JM(o), s = i === "series", l = s ? e.getViewOfSeriesModel(o) : e.getViewOfComponentModel(o);
    !s && n.push(l), a.isBlured && (l.group.traverse(function(u) {
      HW(u);
    }), s && r.push(o)), a.isBlured = !1;
  }), $(n, function(i) {
    i && i.toggleBlurSeries && i.toggleBlurSeries(r, !1, t);
  });
}
function N_(e, t, r, n) {
  var i = n.getModel();
  r = r || "coordinateSystem";
  function o(u, c) {
    for (var d = 0; d < c.length; d++) {
      var h = u.getItemGraphicEl(c[d]);
      h && rD(h);
    }
  }
  if (e != null && !(!t || t === "none")) {
    var a = i.getSeriesByIndex(e), s = a.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    i.eachSeries(function(u) {
      var c = a === u, d = u.coordinateSystem;
      d && d.master && (d = d.master);
      var h = d && s ? d === s : c;
      if (!// Not blur other series if blurScope series
      (r === "series" && !c || r === "coordinateSystem" && !h || t === "series" && c)) {
        var f = n.getViewOfSeriesModel(u);
        if (f.group.traverse(function(v) {
          v.__highByOuter && c && t === "self" || tD(v);
        }), Jn(t))
          o(u.getData(), t);
        else if (lt(t))
          for (var p = jt(t), g = 0; g < p.length; g++)
            o(u.getData(p[g]), t[p[g]]);
        l.push(u), JM(u).isBlured = !0;
      }
    }), i.eachComponent(function(u, c) {
      if (u !== "series") {
        var d = n.getViewOfComponentModel(c);
        d && d.toggleBlurSeries && d.toggleBlurSeries(l, !0, i);
      }
    });
  }
}
function k_(e, t, r) {
  if (!(e == null || t == null)) {
    var n = r.getModel().getComponent(e, t);
    if (n) {
      JM(n).isBlured = !0;
      var i = r.getViewOfComponentModel(n);
      !i || !i.focusBlurEnabled || i.group.traverse(function(o) {
        tD(o);
      });
    }
  }
}
function YSe(e, t, r) {
  var n = e.seriesIndex, i = e.getData(t.dataType);
  if (!i) {
    process.env.NODE_ENV !== "production" && ei("Unknown dataType " + t.dataType);
    return;
  }
  var o = zc(i, t);
  o = (be(o) ? o[0] : o) || 0;
  var a = i.getItemGraphicEl(o);
  if (!a)
    for (var s = i.count(), l = 0; !a && l < s; )
      a = i.getItemGraphicEl(l++);
  if (a) {
    var u = St(a);
    N_(n, u.focus, u.blurScope, r);
  } else {
    var c = e.get(["emphasis", "focus"]), d = e.get(["emphasis", "blurScope"]);
    c != null && N_(n, c, d, r);
  }
}
function nD(e, t, r, n) {
  var i = {
    focusSelf: !1,
    dispatchers: null
  };
  if (e == null || e === "series" || t == null || r == null)
    return i;
  var o = n.getModel().getComponent(e, t);
  if (!o)
    return i;
  var a = n.getViewOfComponentModel(o);
  if (!a || !a.findHighDownDispatchers)
    return i;
  for (var s = a.findHighDownDispatchers(r), l, u = 0; u < s.length; u++)
    if (process.env.NODE_ENV !== "production" && !ou(s[u]) && ei("param should be highDownDispatcher"), St(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function qSe(e, t, r) {
  process.env.NODE_ENV !== "production" && !ou(e) && ei("param should be highDownDispatcher");
  var n = St(e), i = nD(n.componentMainType, n.componentIndex, n.componentHighDownName, r), o = i.dispatchers, a = i.focusSelf;
  o ? (a && k_(n.componentMainType, n.componentIndex, r), $(o, function(s) {
    return RN(s, t);
  })) : (N_(n.seriesIndex, n.focus, n.blurScope, r), n.focus === "self" && k_(n.componentMainType, n.componentIndex, r), RN(e, t));
}
function XSe(e, t, r) {
  process.env.NODE_ENV !== "production" && !ou(e) && ei("param should be highDownDispatcher"), UW(r);
  var n = St(e), i = nD(n.componentMainType, n.componentIndex, n.componentHighDownName, r).dispatchers;
  i ? $(i, function(o) {
    return _N(o, t);
  }) : _N(e, t);
}
function ZSe(e, t, r) {
  if (B_(t)) {
    var n = t.dataType, i = e.getData(n), o = zc(i, t);
    be(o) || (o = [o]), e[t.type === ug ? "toggleSelect" : t.type === lg ? "select" : "unselect"](o, n);
  }
}
function TN(e) {
  var t = e.getAllData();
  $(t, function(r) {
    var n = r.data, i = r.type;
    n.eachItemGraphicEl(function(o, a) {
      e.isSelected(a, i) ? zW(o) : WW(o);
    });
  });
}
function QSe(e) {
  var t = [];
  return e.eachSeries(function(r) {
    var n = r.getAllData();
    $(n, function(i) {
      i.data;
      var o = i.type, a = r.getSelectedDataIndices();
      if (a.length > 0) {
        var s = {
          dataIndex: a,
          seriesIndex: r.seriesIndex
        };
        o != null && (s.dataType = o), t.push(s);
      }
    });
  }), t;
}
function zl(e, t, r) {
  mc(e, !0), ll(e, jc), V_(e, t, r);
}
function JSe(e) {
  mc(e, !1);
}
function sn(e, t, r, n) {
  n ? JSe(e) : zl(e, t, r);
}
function V_(e, t, r) {
  var n = St(e);
  t != null ? (n.focus = t, n.blurScope = r) : n.focus && (n.focus = null);
}
var PN = ["emphasis", "blur", "select"], ewe = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function ti(e, t, r, n) {
  r = r || "itemStyle";
  for (var i = 0; i < PN.length; i++) {
    var o = PN[i], a = t.getModel([o, r]), s = e.ensureState(o);
    s.style = n ? n(a) : a[ewe[r]]();
  }
}
function mc(e, t) {
  var r = t === !1, n = e;
  e.highDownSilentOnTouch && (n.__highDownSilentOnTouch = e.highDownSilentOnTouch), (!r || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !r);
}
function ou(e) {
  return !!(e && e.__highDownDispatcher);
}
function twe(e, t, r) {
  var n = St(e);
  n.componentMainType = t.mainType, n.componentIndex = t.componentIndex, n.componentHighDownName = r;
}
function rwe(e) {
  var t = xN[e];
  return t == null && bN <= 32 && (t = xN[e] = bN++), t;
}
function B_(e) {
  var t = e.type;
  return t === lg || t === u0 || t === ug;
}
function MN(e) {
  var t = e.type;
  return t === Pc || t === l0;
}
function nwe(e) {
  var t = VW(e);
  t.normalFill = e.style.fill, t.normalStroke = e.style.stroke;
  var r = e.states.select || {};
  t.selectFill = r.style && r.style.fill || null, t.selectStroke = r.style && r.style.stroke || null;
}
var Fd = ms.CMD, iwe = [[], [], []], DN = Math.sqrt, owe = Math.atan2;
function KW(e, t) {
  if (t) {
    var r = e.data, n = e.len(), i, o, a, s, l, u, c = Fd.M, d = Fd.C, h = Fd.L, f = Fd.R, p = Fd.A, g = Fd.Q;
    for (a = 0, s = 0; a < n; ) {
      switch (i = r[a++], s = a, o = 0, i) {
        case c:
          o = 1;
          break;
        case h:
          o = 1;
          break;
        case d:
          o = 3;
          break;
        case g:
          o = 2;
          break;
        case p:
          var v = t[4], m = t[5], y = DN(t[0] * t[0] + t[1] * t[1]), C = DN(t[2] * t[2] + t[3] * t[3]), S = owe(-t[1] / C, t[0] / y);
          r[a] *= y, r[a++] += v, r[a] *= C, r[a++] += m, r[a++] *= y, r[a++] *= C, r[a++] += S, r[a++] += S, a += 2, s = a;
          break;
        case f:
          u[0] = r[a++], u[1] = r[a++], Un(u, u, t), r[s++] = u[0], r[s++] = u[1], u[0] += r[a++], u[1] += r[a++], Un(u, u, t), r[s++] = u[0], r[s++] = u[1];
      }
      for (l = 0; l < o; l++) {
        var b = iwe[l];
        b[0] = r[a++], b[1] = r[a++], Un(b, b, t), r[s++] = b[0], r[s++] = b[1];
      }
    }
    e.increaseVersion();
  }
}
var x1 = Math.sqrt, Wm = Math.sin, jm = Math.cos, rp = Math.PI;
function AN(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function $_(e, t) {
  return (e[0] * t[0] + e[1] * t[1]) / (AN(e) * AN(t));
}
function IN(e, t) {
  return (e[0] * t[1] < e[1] * t[0] ? -1 : 1) * Math.acos($_(e, t));
}
function ON(e, t, r, n, i, o, a, s, l, u, c) {
  var d = l * (rp / 180), h = jm(d) * (e - r) / 2 + Wm(d) * (t - n) / 2, f = -1 * Wm(d) * (e - r) / 2 + jm(d) * (t - n) / 2, p = h * h / (a * a) + f * f / (s * s);
  p > 1 && (a *= x1(p), s *= x1(p));
  var g = (i === o ? -1 : 1) * x1((a * a * (s * s) - a * a * (f * f) - s * s * (h * h)) / (a * a * (f * f) + s * s * (h * h))) || 0, v = g * a * f / s, m = g * -s * h / a, y = (e + r) / 2 + jm(d) * v - Wm(d) * m, C = (t + n) / 2 + Wm(d) * v + jm(d) * m, S = IN([1, 0], [(h - v) / a, (f - m) / s]), b = [(h - v) / a, (f - m) / s], w = [(-1 * h - v) / a, (-1 * f - m) / s], x = IN(b, w);
  if ($_(b, w) <= -1 && (x = rp), $_(b, w) >= 1 && (x = 0), x < 0) {
    var R = Math.round(x / rp * 1e6) / 1e6;
    x = rp * 2 + R % 2 * rp;
  }
  c.addData(u, y, C, a, s, S, x, d, o);
}
var awe = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, swe = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function lwe(e) {
  var t = new ms();
  if (!e)
    return t;
  var r = 0, n = 0, i = r, o = n, a, s = ms.CMD, l = e.match(awe);
  if (!l)
    return t;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], d = c.charAt(0), h = void 0, f = c.match(swe) || [], p = f.length, g = 0; g < p; g++)
      f[g] = parseFloat(f[g]);
    for (var v = 0; v < p; ) {
      var m = void 0, y = void 0, C = void 0, S = void 0, b = void 0, w = void 0, x = void 0, R = r, _ = n, T = void 0, P = void 0;
      switch (d) {
        case "l":
          r += f[v++], n += f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "L":
          r = f[v++], n = f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "m":
          r += f[v++], n += f[v++], h = s.M, t.addData(h, r, n), i = r, o = n, d = "l";
          break;
        case "M":
          r = f[v++], n = f[v++], h = s.M, t.addData(h, r, n), i = r, o = n, d = "L";
          break;
        case "h":
          r += f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "H":
          r = f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "v":
          n += f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "V":
          n = f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "C":
          h = s.C, t.addData(h, f[v++], f[v++], f[v++], f[v++], f[v++], f[v++]), r = f[v - 2], n = f[v - 1];
          break;
        case "c":
          h = s.C, t.addData(h, f[v++] + r, f[v++] + n, f[v++] + r, f[v++] + n, f[v++] + r, f[v++] + n), r += f[v - 2], n += f[v - 1];
          break;
        case "S":
          m = r, y = n, T = t.len(), P = t.data, a === s.C && (m += r - P[T - 4], y += n - P[T - 3]), h = s.C, R = f[v++], _ = f[v++], r = f[v++], n = f[v++], t.addData(h, m, y, R, _, r, n);
          break;
        case "s":
          m = r, y = n, T = t.len(), P = t.data, a === s.C && (m += r - P[T - 4], y += n - P[T - 3]), h = s.C, R = r + f[v++], _ = n + f[v++], r += f[v++], n += f[v++], t.addData(h, m, y, R, _, r, n);
          break;
        case "Q":
          R = f[v++], _ = f[v++], r = f[v++], n = f[v++], h = s.Q, t.addData(h, R, _, r, n);
          break;
        case "q":
          R = f[v++] + r, _ = f[v++] + n, r += f[v++], n += f[v++], h = s.Q, t.addData(h, R, _, r, n);
          break;
        case "T":
          m = r, y = n, T = t.len(), P = t.data, a === s.Q && (m += r - P[T - 4], y += n - P[T - 3]), r = f[v++], n = f[v++], h = s.Q, t.addData(h, m, y, r, n);
          break;
        case "t":
          m = r, y = n, T = t.len(), P = t.data, a === s.Q && (m += r - P[T - 4], y += n - P[T - 3]), r += f[v++], n += f[v++], h = s.Q, t.addData(h, m, y, r, n);
          break;
        case "A":
          C = f[v++], S = f[v++], b = f[v++], w = f[v++], x = f[v++], R = r, _ = n, r = f[v++], n = f[v++], h = s.A, ON(R, _, r, n, w, x, C, S, b, h, t);
          break;
        case "a":
          C = f[v++], S = f[v++], b = f[v++], w = f[v++], x = f[v++], R = r, _ = n, r += f[v++], n += f[v++], h = s.A, ON(R, _, r, n, w, x, C, S, b, h, t);
          break;
      }
    }
    (d === "z" || d === "Z") && (h = s.Z, t.addData(h), r = i, n = o), a = h;
  }
  return t.toStatic(), t;
}
var YW = function(e) {
  Ur(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.applyTransform = function(r) {
  }, t;
}(Ht);
function qW(e) {
  return e.setData != null;
}
function XW(e, t) {
  var r = lwe(e), n = ge({}, t);
  return n.buildPath = function(i) {
    if (qW(i)) {
      i.setData(r.data);
      var o = i.getContext();
      o && i.rebuildPath(o, 1);
    } else {
      var o = i;
      r.rebuildPath(o, 1);
    }
  }, n.applyTransform = function(i) {
    KW(r, i), this.dirtyShape();
  }, n;
}
function ZW(e, t) {
  return new YW(XW(e, t));
}
function uwe(e, t) {
  var r = XW(e, t), n = function(i) {
    Ur(o, i);
    function o(a) {
      var s = i.call(this, a) || this;
      return s.applyTransform = r.applyTransform, s.buildPath = r.buildPath, s;
    }
    return o;
  }(YW);
  return n;
}
function cwe(e, t) {
  for (var r = [], n = e.length, i = 0; i < n; i++) {
    var o = e[i];
    r.push(o.getUpdatedPathProxy(!0));
  }
  var a = new Ht(t);
  return a.createPathProxy(), a.buildPath = function(s) {
    if (qW(s)) {
      s.appendPath(r);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, a;
}
function iD(e, t) {
  t = t || {};
  var r = new Ht();
  return e.shape && r.setShape(e.shape), r.setStyle(e.style), t.bakeTransform ? KW(r.path, e.getComputedTransform()) : t.toLocal ? r.setLocalTransform(e.getComputedTransform()) : r.copyTransform(e), r.buildPath = e.buildPath, r.applyTransform = r.applyTransform, r.z = e.z, r.z2 = e.z2, r.zlevel = e.zlevel, r;
}
var dwe = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return e;
}(), QW = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new dwe();
  }, t.prototype.buildPath = function(r, n) {
    r.moveTo(n.cx + n.r, n.cy), r.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
  }, t;
}(Ht);
QW.prototype.type = "circle";
const ul = QW;
var hwe = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return e;
}(), JW = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new hwe();
  }, t.prototype.buildPath = function(r, n) {
    var i = 0.5522848, o = n.cx, a = n.cy, s = n.rx, l = n.ry, u = s * i, c = l * i;
    r.moveTo(o - s, a), r.bezierCurveTo(o - s, a - c, o - u, a - l, o, a - l), r.bezierCurveTo(o + u, a - l, o + s, a - c, o + s, a), r.bezierCurveTo(o + s, a + c, o + u, a + l, o, a + l), r.bezierCurveTo(o - u, a + l, o - s, a + c, o - s, a), r.closePath();
  }, t;
}(Ht);
JW.prototype.type = "ellipse";
const ow = JW;
var e7 = Math.PI, E1 = e7 * 2, Bu = Math.sin, Nd = Math.cos, fwe = Math.acos, ii = Math.atan2, LN = Math.abs, cg = Math.sqrt, Lp = Math.max, Wa = Math.min, pa = 1e-4;
function pwe(e, t, r, n, i, o, a, s) {
  var l = r - e, u = n - t, c = a - i, d = s - o, h = d * l - c * u;
  if (!(h * h < pa))
    return h = (c * (t - o) - d * (e - i)) / h, [e + h * l, t + h * u];
}
function Um(e, t, r, n, i, o, a) {
  var s = e - r, l = t - n, u = (a ? o : -o) / cg(s * s + l * l), c = u * l, d = -u * s, h = e + c, f = t + d, p = r + c, g = n + d, v = (h + p) / 2, m = (f + g) / 2, y = p - h, C = g - f, S = y * y + C * C, b = i - o, w = h * g - p * f, x = (C < 0 ? -1 : 1) * cg(Lp(0, b * b * S - w * w)), R = (w * C - y * x) / S, _ = (-w * y - C * x) / S, T = (w * C + y * x) / S, P = (-w * y + C * x) / S, D = R - v, O = _ - m, A = T - v, F = P - m;
  return D * D + O * O > A * A + F * F && (R = T, _ = P), {
    cx: R,
    cy: _,
    x0: -c,
    y0: -d,
    x1: R * (i / b - 1),
    y1: _ * (i / b - 1)
  };
}
function gwe(e) {
  var t;
  if (be(e)) {
    var r = e.length;
    if (!r)
      return e;
    r === 1 ? t = [e[0], e[0], 0, 0] : r === 2 ? t = [e[0], e[0], e[1], e[1]] : r === 3 ? t = e.concat(e[2]) : t = e;
  } else
    t = [e, e, e, e];
  return t;
}
function vwe(e, t) {
  var r, n = Lp(t.r, 0), i = Lp(t.r0 || 0, 0), o = n > 0, a = i > 0;
  if (!(!o && !a)) {
    if (o || (n = i, i = 0), i > n) {
      var s = n;
      n = i, i = s;
    }
    var l = t.startAngle, u = t.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx, d = t.cy, h = !!t.clockwise, f = LN(u - l), p = f > E1 && f % E1;
      if (p > pa && (f = p), !(n > pa))
        e.moveTo(c, d);
      else if (f > E1 - pa)
        e.moveTo(c + n * Nd(l), d + n * Bu(l)), e.arc(c, d, n, l, u, !h), i > pa && (e.moveTo(c + i * Nd(u), d + i * Bu(u)), e.arc(c, d, i, u, l, h));
      else {
        var g = void 0, v = void 0, m = void 0, y = void 0, C = void 0, S = void 0, b = void 0, w = void 0, x = void 0, R = void 0, _ = void 0, T = void 0, P = void 0, D = void 0, O = void 0, A = void 0, F = n * Nd(l), L = n * Bu(l), N = i * Nd(u), I = i * Bu(u), B = f > pa;
        if (B) {
          var M = t.cornerRadius;
          M && (r = gwe(M), g = r[0], v = r[1], m = r[2], y = r[3]);
          var V = LN(n - i) / 2;
          if (C = Wa(V, m), S = Wa(V, y), b = Wa(V, g), w = Wa(V, v), _ = x = Lp(C, S), T = R = Lp(b, w), (x > pa || R > pa) && (P = n * Nd(u), D = n * Bu(u), O = i * Nd(l), A = i * Bu(l), f < e7)) {
            var G = pwe(F, L, O, A, P, D, N, I);
            if (G) {
              var k = F - G[0], z = L - G[1], j = P - G[0], q = D - G[1], K = 1 / Bu(fwe((k * j + z * q) / (cg(k * k + z * z) * cg(j * j + q * q))) / 2), Z = cg(G[0] * G[0] + G[1] * G[1]);
              _ = Wa(x, (n - Z) / (K + 1)), T = Wa(R, (i - Z) / (K - 1));
            }
          }
        }
        if (!B)
          e.moveTo(c + F, d + L);
        else if (_ > pa) {
          var re = Wa(m, _), X = Wa(y, _), Y = Um(O, A, F, L, n, re, h), U = Um(P, D, N, I, n, X, h);
          e.moveTo(c + Y.cx + Y.x0, d + Y.cy + Y.y0), _ < x && re === X ? e.arc(c + Y.cx, d + Y.cy, _, ii(Y.y0, Y.x0), ii(U.y0, U.x0), !h) : (re > 0 && e.arc(c + Y.cx, d + Y.cy, re, ii(Y.y0, Y.x0), ii(Y.y1, Y.x1), !h), e.arc(c, d, n, ii(Y.cy + Y.y1, Y.cx + Y.x1), ii(U.cy + U.y1, U.cx + U.x1), !h), X > 0 && e.arc(c + U.cx, d + U.cy, X, ii(U.y1, U.x1), ii(U.y0, U.x0), !h));
        } else
          e.moveTo(c + F, d + L), e.arc(c, d, n, l, u, !h);
        if (!(i > pa) || !B)
          e.lineTo(c + N, d + I);
        else if (T > pa) {
          var re = Wa(g, T), X = Wa(v, T), Y = Um(N, I, P, D, i, -X, h), U = Um(F, L, O, A, i, -re, h);
          e.lineTo(c + Y.cx + Y.x0, d + Y.cy + Y.y0), T < R && re === X ? e.arc(c + Y.cx, d + Y.cy, T, ii(Y.y0, Y.x0), ii(U.y0, U.x0), !h) : (X > 0 && e.arc(c + Y.cx, d + Y.cy, X, ii(Y.y0, Y.x0), ii(Y.y1, Y.x1), !h), e.arc(c, d, i, ii(Y.cy + Y.y1, Y.cx + Y.x1), ii(U.cy + U.y1, U.cx + U.x1), h), re > 0 && e.arc(c + U.cx, d + U.cy, re, ii(U.y1, U.x1), ii(U.y0, U.x0), !h));
        } else
          e.lineTo(c + N, d + I), e.arc(c, d, i, u, l, h);
      }
      e.closePath();
    }
  }
}
var mwe = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return e;
}(), t7 = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new mwe();
  }, t.prototype.buildPath = function(r, n) {
    vwe(r, n);
  }, t.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, t;
}(Ht);
t7.prototype.type = "sector";
const Oi = t7;
var ywe = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return e;
}(), r7 = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new ywe();
  }, t.prototype.buildPath = function(r, n) {
    var i = n.cx, o = n.cy, a = Math.PI * 2;
    r.moveTo(i + n.r, o), r.arc(i, o, n.r, 0, a, !1), r.moveTo(i + n.r0, o), r.arc(i, o, n.r0, 0, a, !0);
  }, t;
}(Ht);
r7.prototype.type = "ring";
const Vv = r7;
function Cwe(e, t, r, n) {
  var i = [], o = [], a = [], s = [], l, u, c, d;
  if (n) {
    c = [1 / 0, 1 / 0], d = [-1 / 0, -1 / 0];
    for (var h = 0, f = e.length; h < f; h++)
      Vs(c, c, e[h]), Bs(d, d, e[h]);
    Vs(c, c, n[0]), Bs(d, d, n[1]);
  }
  for (var h = 0, f = e.length; h < f; h++) {
    var p = e[h];
    if (r)
      l = e[h ? h - 1 : f - 1], u = e[(h + 1) % f];
    else if (h === 0 || h === f - 1) {
      i.push(ls(e[h]));
      continue;
    } else
      l = e[h - 1], u = e[h + 1];
    Ol(o, u, l), tg(o, o, t);
    var g = Z0(p, l), v = Z0(p, u), m = g + v;
    m !== 0 && (g /= m, v /= m), tg(a, o, -g), tg(s, o, v);
    var y = c_([], p, a), C = c_([], p, s);
    n && (Bs(y, y, c), Vs(y, y, d), Bs(C, C, c), Vs(C, C, d)), i.push(y), i.push(C);
  }
  return r && i.push(i.shift()), i;
}
function n7(e, t, r) {
  var n = t.smooth, i = t.points;
  if (i && i.length >= 2) {
    if (n) {
      var o = Cwe(i, n, r, t.smoothConstraint);
      e.moveTo(i[0][0], i[0][1]);
      for (var a = i.length, s = 0; s < (r ? a : a - 1); s++) {
        var l = o[s * 2], u = o[s * 2 + 1], c = i[(s + 1) % a];
        e.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      e.moveTo(i[0][0], i[0][1]);
      for (var s = 1, d = i.length; s < d; s++)
        e.lineTo(i[s][0], i[s][1]);
    }
    r && e.closePath();
  }
}
var Swe = /* @__PURE__ */ function() {
  function e() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
}(), i7 = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new Swe();
  }, t.prototype.buildPath = function(r, n) {
    n7(r, n, !0);
  }, t;
}(Ht);
i7.prototype.type = "polygon";
const Li = i7;
var wwe = /* @__PURE__ */ function() {
  function e() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
}(), o7 = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new wwe();
  }, t.prototype.buildPath = function(r, n) {
    n7(r, n, !1);
  }, t;
}(Ht);
o7.prototype.type = "polyline";
const Ni = o7;
var bwe = {}, xwe = /* @__PURE__ */ function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return e;
}(), a7 = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new xwe();
  }, t.prototype.buildPath = function(r, n) {
    var i, o, a, s;
    if (this.subPixelOptimize) {
      var l = IW(bwe, n, this.style);
      i = l.x1, o = l.y1, a = l.x2, s = l.y2;
    } else
      i = n.x1, o = n.y1, a = n.x2, s = n.y2;
    var u = n.percent;
    u !== 0 && (r.moveTo(i, o), u < 1 && (a = i * (1 - u) + a * u, s = o * (1 - u) + s * u), r.lineTo(a, s));
  }, t.prototype.pointAt = function(r) {
    var n = this.shape;
    return [
      n.x1 * (1 - r) + n.x2 * r,
      n.y1 * (1 - r) + n.y2 * r
    ];
  }, t;
}(Ht);
a7.prototype.type = "line";
const Nn = a7;
var Hi = [], Ewe = /* @__PURE__ */ function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return e;
}();
function FN(e, t, r) {
  var n = e.cpx2, i = e.cpy2;
  return n != null || i != null ? [
    (r ? BF : Fn)(e.x1, e.cpx1, e.cpx2, e.x2, t),
    (r ? BF : Fn)(e.y1, e.cpy1, e.cpy2, e.y2, t)
  ] : [
    (r ? g_ : zn)(e.x1, e.cpx1, e.x2, t),
    (r ? g_ : zn)(e.y1, e.cpy1, e.y2, t)
  ];
}
var s7 = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new Ewe();
  }, t.prototype.buildPath = function(r, n) {
    var i = n.x1, o = n.y1, a = n.x2, s = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, d = n.cpy2, h = n.percent;
    h !== 0 && (r.moveTo(i, o), c == null || d == null ? (h < 1 && ($g(i, l, a, h, Hi), l = Hi[1], a = Hi[2], $g(o, u, s, h, Hi), u = Hi[1], s = Hi[2]), r.quadraticCurveTo(l, u, a, s)) : (h < 1 && (iu(i, l, c, a, h, Hi), l = Hi[1], c = Hi[2], a = Hi[3], iu(o, u, d, s, h, Hi), u = Hi[1], d = Hi[2], s = Hi[3]), r.bezierCurveTo(l, u, c, d, a, s)));
  }, t.prototype.pointAt = function(r) {
    return FN(this.shape, r, !1);
  }, t.prototype.tangentAt = function(r) {
    var n = FN(this.shape, r, !0);
    return nd(n, n);
  }, t;
}(Ht);
s7.prototype.type = "bezier-curve";
const Bv = s7;
var Rwe = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return e;
}(), l7 = function(e) {
  Ur(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new Rwe();
  }, t.prototype.buildPath = function(r, n) {
    var i = n.cx, o = n.cy, a = Math.max(n.r, 0), s = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(s), d = Math.sin(s);
    r.moveTo(c * a + i, d * a + o), r.arc(i, o, a, s, l, !u);
  }, t;
}(Ht);
l7.prototype.type = "arc";
const aw = l7;
var _we = function(e) {
  Ur(t, e);
  function t() {
    var r = e !== null && e.apply(this, arguments) || this;
    return r.type = "compound", r;
  }
  return t.prototype._updatePathDirty = function() {
    for (var r = this.shape.paths, n = this.shapeChanged(), i = 0; i < r.length; i++)
      n = n || r[i].shapeChanged();
    n && this.dirtyShape();
  }, t.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var r = this.shape.paths || [], n = this.getGlobalScale(), i = 0; i < r.length; i++)
      r[i].path || r[i].createPathProxy(), r[i].path.setScale(n[0], n[1], r[i].segmentIgnoreThreshold);
  }, t.prototype.buildPath = function(r, n) {
    for (var i = n.paths || [], o = 0; o < i.length; o++)
      i[o].buildPath(r, i[o].shape, !0);
  }, t.prototype.afterBrush = function() {
    for (var r = this.shape.paths || [], n = 0; n < r.length; n++)
      r[n].pathUpdated();
  }, t.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), Ht.prototype.getBoundingRect.call(this);
  }, t;
}(Ht);
const sw = _we;
var u7 = function() {
  function e(t) {
    this.colorStops = t || [];
  }
  return e.prototype.addColorStop = function(t, r) {
    this.colorStops.push({
      offset: t,
      color: r
    });
  }, e;
}(), Twe = function(e) {
  Ur(t, e);
  function t(r, n, i, o, a, s) {
    var l = e.call(this, a) || this;
    return l.x = r ?? 0, l.y = n ?? 0, l.x2 = i ?? 1, l.y2 = o ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return t;
}(u7);
const vf = Twe;
var Pwe = function(e) {
  Ur(t, e);
  function t(r, n, i, o, a) {
    var s = e.call(this, o) || this;
    return s.x = r ?? 0.5, s.y = n ?? 0.5, s.r = i ?? 0.5, s.type = "radial", s.global = a || !1, s;
  }
  return t;
}(u7);
const oD = Pwe;
var $u = [0, 0], Hu = [0, 0], Km = new Dt(), Ym = new Dt(), Mwe = function() {
  function e(t, r) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var n = 0; n < 4; n++)
      this._corners[n] = new Dt();
    for (var n = 0; n < 2; n++)
      this._axes[n] = new Dt();
    t && this.fromBoundingRect(t, r);
  }
  return e.prototype.fromBoundingRect = function(t, r) {
    var n = this._corners, i = this._axes, o = t.x, a = t.y, s = o + t.width, l = a + t.height;
    if (n[0].set(o, a), n[1].set(s, a), n[2].set(s, l), n[3].set(o, l), r)
      for (var u = 0; u < 4; u++)
        n[u].transform(r);
    Dt.sub(i[0], n[1], n[0]), Dt.sub(i[1], n[3], n[0]), i[0].normalize(), i[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = i[u].dot(n[0]);
  }, e.prototype.intersect = function(t, r) {
    var n = !0, i = !r;
    return Km.set(1 / 0, 1 / 0), Ym.set(0, 0), !this._intersectCheckOneSide(this, t, Km, Ym, i, 1) && (n = !1, i) || !this._intersectCheckOneSide(t, this, Km, Ym, i, -1) && (n = !1, i) || i || Dt.copy(r, n ? Km : Ym), n;
  }, e.prototype._intersectCheckOneSide = function(t, r, n, i, o, a) {
    for (var s = !0, l = 0; l < 2; l++) {
      var u = this._axes[l];
      if (this._getProjMinMaxOnAxis(l, t._corners, $u), this._getProjMinMaxOnAxis(l, r._corners, Hu), $u[1] < Hu[0] || $u[0] > Hu[1]) {
        if (s = !1, o)
          return s;
        var c = Math.abs(Hu[0] - $u[1]), d = Math.abs($u[0] - Hu[1]);
        Math.min(c, d) > i.len() && (c < d ? Dt.scale(i, u, -c * a) : Dt.scale(i, u, d * a));
      } else if (n) {
        var c = Math.abs(Hu[0] - $u[1]), d = Math.abs($u[0] - Hu[1]);
        Math.min(c, d) < n.len() && (c < d ? Dt.scale(n, u, c * a) : Dt.scale(n, u, -d * a));
      }
    }
    return s;
  }, e.prototype._getProjMinMaxOnAxis = function(t, r, n) {
    for (var i = this._axes[t], o = this._origin, a = r[0].dot(i) + o[t], s = a, l = a, u = 1; u < r.length; u++) {
      var c = r[u].dot(i) + o[t];
      s = Math.min(c, s), l = Math.max(c, l);
    }
    n[0] = s, n[1] = l;
  }, e;
}();
const uC = Mwe;
var Dwe = [], Awe = function(e) {
  Ur(t, e);
  function t() {
    var r = e !== null && e.apply(this, arguments) || this;
    return r.notClear = !0, r.incremental = !0, r._displayables = [], r._temporaryDisplayables = [], r._cursor = 0, r;
  }
  return t.prototype.traverse = function(r, n) {
    r.call(n, this);
  }, t.prototype.useStyle = function() {
    this.style = {};
  }, t.prototype.getCursor = function() {
    return this._cursor;
  }, t.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, t.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, t.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, t.prototype.addDisplayable = function(r, n) {
    n ? this._temporaryDisplayables.push(r) : this._displayables.push(r), this.markRedraw();
  }, t.prototype.addDisplayables = function(r, n) {
    n = n || !1;
    for (var i = 0; i < r.length; i++)
      this.addDisplayable(r[i], n);
  }, t.prototype.getDisplayables = function() {
    return this._displayables;
  }, t.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, t.prototype.eachPendingDisplayable = function(r) {
    for (var n = this._cursor; n < this._displayables.length; n++)
      r && r(this._displayables[n]);
    for (var n = 0; n < this._temporaryDisplayables.length; n++)
      r && r(this._temporaryDisplayables[n]);
  }, t.prototype.update = function() {
    this.updateTransform();
    for (var r = this._cursor; r < this._displayables.length; r++) {
      var n = this._displayables[r];
      n.parent = this, n.update(), n.parent = null;
    }
    for (var r = 0; r < this._temporaryDisplayables.length; r++) {
      var n = this._temporaryDisplayables[r];
      n.parent = this, n.update(), n.parent = null;
    }
  }, t.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var r = new At(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
        var i = this._displayables[n], o = i.getBoundingRect().clone();
        i.needLocalTransform() && o.applyTransform(i.getLocalTransform(Dwe)), r.union(o);
      }
      this._rect = r;
    }
    return this._rect;
  }, t.prototype.contain = function(r, n) {
    var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect();
    if (o.contain(i[0], i[1]))
      for (var a = 0; a < this._displayables.length; a++) {
        var s = this._displayables[a];
        if (s.contain(r, n))
          return !0;
      }
    return !1;
  }, t;
}(ta);
const c7 = Awe;
var d7 = ar();
function mf(e, t, r, n, i) {
  var o;
  if (t && t.ecModel) {
    var a = t.ecModel.getUpdatePayload();
    o = a && a.animation;
  }
  var s = t && t.isAnimationEnabled(), l = e === "update";
  if (s) {
    var u = void 0, c = void 0, d = void 0;
    n ? (u = bt(n.duration, 200), c = bt(n.easing, "cubicOut"), d = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), d = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), o && (o.duration != null && (u = o.duration), o.easing != null && (c = o.easing), o.delay != null && (d = o.delay)), at(d) && (d = d(r, i)), at(u) && (u = u(r));
    var h = {
      duration: u || 0,
      delay: d,
      easing: c
    };
    return h;
  } else
    return null;
}
function aD(e, t, r, n, i, o, a) {
  var s = !1, l;
  at(i) ? (a = o, o = i, i = null) : lt(i) && (o = i.cb, a = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex);
  var u = e === "leave";
  u || t.stopAnimation("leave");
  var c = mf(e, n, i, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(t, i) : null);
  if (c && c.duration > 0) {
    var d = c.duration, h = c.delay, f = c.easing, p = {
      duration: d,
      delay: h || 0,
      easing: f,
      done: o,
      force: !!o || !!a,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: e,
      during: a
    };
    s ? t.animateFrom(r, p) : t.animateTo(r, p);
  } else
    t.stopAnimation(), !s && t.attr(r), a && a(1), o && o();
}
function ur(e, t, r, n, i, o) {
  aD("update", e, t, r, n, i, o);
}
function jr(e, t, r, n, i, o) {
  aD("enter", e, t, r, n, i, o);
}
function Ph(e) {
  if (!e.__zr)
    return !0;
  for (var t = 0; t < e.animators.length; t++) {
    var r = e.animators[t];
    if (r.scope === "leave")
      return !0;
  }
  return !1;
}
function au(e, t, r, n, i, o) {
  Ph(e) || aD("leave", e, t, r, n, i, o);
}
function NN(e, t, r, n) {
  e.removeTextContent(), e.removeTextGuideLine(), au(e, {
    style: {
      opacity: 0
    }
  }, t, r, n);
}
function Ug(e, t, r) {
  function n() {
    e.parent && e.parent.remove(e);
  }
  e.isGroup ? e.traverse(function(i) {
    i.isGroup || NN(i, t, r, n);
  }) : NN(e, t, r, n);
}
function Fa(e) {
  d7(e).oldStyle = e.style;
}
function Iwe(e) {
  return d7(e).oldStyle;
}
var cC = Math.max, dC = Math.min, H_ = {};
function h7(e) {
  return Ht.extend(e);
}
var Owe = uwe;
function f7(e, t) {
  return Owe(e, t);
}
function ia(e, t) {
  H_[e] = t;
}
function lw(e) {
  if (H_.hasOwnProperty(e))
    return H_[e];
}
function $v(e, t, r, n) {
  var i = ZW(e, t);
  return r && (n === "center" && (r = p7(r, i.getBoundingRect())), lD(i, r)), i;
}
function sD(e, t, r) {
  var n = new qn({
    style: {
      image: e,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    onload: function(i) {
      if (r === "center") {
        var o = {
          width: i.width,
          height: i.height
        };
        n.setStyle(p7(t, o));
      }
    }
  });
  return n;
}
function p7(e, t) {
  var r = t.width / t.height, n = e.height * r, i;
  n <= e.width ? i = e.height : (n = e.width, i = n / r);
  var o = e.x + e.width / 2, a = e.y + e.height / 2;
  return {
    x: o - n / 2,
    y: a - i / 2,
    width: n,
    height: i
  };
}
var fo = cwe;
function lD(e, t) {
  if (e.applyTransform) {
    var r = e.getBoundingRect(), n = r.calculateTransform(t);
    e.applyTransform(n);
  }
}
function Uh(e, t) {
  return IW(e, e, {
    lineWidth: t
  }), e;
}
function Lwe(e) {
  return OW(e.shape, e.shape, e.style), e;
}
var c0 = vc;
function Wl(e, t) {
  for (var r = Iv([]); e && e !== t; )
    us(r, e.getLocalTransform(), r), e = e.parent;
  return r;
}
function Ma(e, t, r) {
  return t && !Jn(t) && (t = $s.getLocalTransform(t)), r && (t = id([], t)), Un([], e, t);
}
function uw(e, t, r) {
  var n = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : Math.abs(2 * t[4] / t[0]), i = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : Math.abs(2 * t[4] / t[2]), o = [e === "left" ? -n : e === "right" ? n : 0, e === "top" ? -i : e === "bottom" ? i : 0];
  return o = Ma(o, t, r), Math.abs(o[0]) > Math.abs(o[1]) ? o[0] > 0 ? "right" : "left" : o[1] > 0 ? "bottom" : "top";
}
function kN(e) {
  return !e.isGroup;
}
function Fwe(e) {
  return e.shape != null;
}
function Hv(e, t, r) {
  if (!e || !t)
    return;
  function n(a) {
    var s = {};
    return a.traverse(function(l) {
      kN(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function i(a) {
    var s = {
      x: a.x,
      y: a.y,
      rotation: a.rotation
    };
    return Fwe(a) && (s.shape = ge({}, a.shape)), s;
  }
  var o = n(e);
  t.traverse(function(a) {
    if (kN(a) && a.anid) {
      var s = o[a.anid];
      if (s) {
        var l = i(a);
        a.attr(i(s)), ur(a, l, r, St(a).dataIndex);
      }
    }
  });
}
function uD(e, t) {
  return Ee(e, function(r) {
    var n = r[0];
    n = cC(n, t.x), n = dC(n, t.x + t.width);
    var i = r[1];
    return i = cC(i, t.y), i = dC(i, t.y + t.height), [n, i];
  });
}
function g7(e, t) {
  var r = cC(e.x, t.x), n = dC(e.x + e.width, t.x + t.width), i = cC(e.y, t.y), o = dC(e.y + e.height, t.y + t.height);
  if (n >= r && o >= i)
    return {
      x: r,
      y: i,
      width: n - r,
      height: o - i
    };
}
function yf(e, t, r) {
  var n = ge({
    rectHover: !0
  }, t), i = n.style = {
    strokeNoScale: !0
  };
  if (r = r || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, e)
    return e.indexOf("image://") === 0 ? (i.image = e.slice(8), ut(i, r), new qn(n)) : $v(e.replace("path://", ""), n, r, "center");
}
function Fp(e, t, r, n, i) {
  for (var o = 0, a = i[i.length - 1]; o < i.length; o++) {
    var s = i[o];
    if (v7(e, t, r, n, s[0], s[1], a[0], a[1]))
      return !0;
    a = s;
  }
}
function v7(e, t, r, n, i, o, a, s) {
  var l = r - e, u = n - t, c = a - i, d = s - o, h = R1(c, d, l, u);
  if (Nwe(h))
    return !1;
  var f = e - i, p = t - o, g = R1(f, p, l, u) / h;
  if (g < 0 || g > 1)
    return !1;
  var v = R1(f, p, c, d) / h;
  return !(v < 0 || v > 1);
}
function R1(e, t, r, n) {
  return e * n - r * t;
}
function Nwe(e) {
  return e <= 1e-6 && e >= -1e-6;
}
function Cf(e) {
  var t = e.itemTooltipOption, r = e.componentModel, n = e.itemName, i = He(t) ? {
    formatter: t
  } : t, o = r.mainType, a = r.componentIndex, s = {
    componentType: o,
    name: n,
    $vars: ["name"]
  };
  s[o + "Index"] = a;
  var l = e.formatterParamsExtra;
  l && $(jt(l), function(c) {
    Ye(s, c) || (s[c] = l[c], s.$vars.push(c));
  });
  var u = St(e.el);
  u.componentMainType = o, u.componentIndex = a, u.tooltipConfig = {
    name: n,
    option: ut({
      content: n,
      encodeHTMLContent: !0,
      formatterParams: s
    }, i)
  };
}
function VN(e, t) {
  var r;
  e.isGroup && (r = t(e)), r || e.traverse(t);
}
function Su(e, t) {
  if (e)
    if (be(e))
      for (var r = 0; r < e.length; r++)
        VN(e[r], t);
    else
      VN(e, t);
}
ia("circle", ul);
ia("ellipse", ow);
ia("sector", Oi);
ia("ring", Vv);
ia("polygon", Li);
ia("polyline", Ni);
ia("rect", or);
ia("line", Nn);
ia("bezierCurve", Bv);
ia("arc", aw);
const od = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: aw,
  BezierCurve: Bv,
  BoundingRect: At,
  Circle: ul,
  CompoundPath: sw,
  Ellipse: ow,
  Group: Ct,
  Image: qn,
  IncrementalDisplayable: c7,
  Line: Nn,
  LinearGradient: vf,
  OrientedBoundingRect: uC,
  Path: Ht,
  Point: Dt,
  Polygon: Li,
  Polyline: Ni,
  RadialGradient: oD,
  Rect: or,
  Ring: Vv,
  Sector: Oi,
  Text: ir,
  applyTransform: Ma,
  clipPointsByRect: uD,
  clipRectByRect: g7,
  createIcon: yf,
  extendPath: f7,
  extendShape: h7,
  getShapeClass: lw,
  getTransform: Wl,
  groupTransition: Hv,
  initProps: jr,
  isElementRemoved: Ph,
  lineLineIntersect: v7,
  linePolygonIntersect: Fp,
  makeImage: sD,
  makePath: $v,
  mergePath: fo,
  registerShape: ia,
  removeElement: au,
  removeElementWithFadeOut: Ug,
  resizePath: lD,
  setTooltipConfig: Cf,
  subPixelOptimize: c0,
  subPixelOptimizeLine: Uh,
  subPixelOptimizeRect: Lwe,
  transformDirection: uw,
  traverseElements: Su,
  updateProps: ur
}, Symbol.toStringTag, { value: "Module" }));
var cw = {};
function m7(e, t) {
  for (var r = 0; r < Ii.length; r++) {
    var n = Ii[r], i = t[n], o = e.ensureState(n);
    o.style = o.style || {}, o.style.text = i;
  }
  var a = e.currentStates.slice();
  e.clearStates(!0), e.setStyle({
    text: t.normal
  }), e.useStates(a, !0);
}
function G_(e, t, r) {
  var n = e.labelFetcher, i = e.labelDataIndex, o = e.labelDimIndex, a = t.normal, s;
  n && (s = n.getFormattedLabel(i, "normal", null, o, a && a.get("formatter"), r != null ? {
    interpolatedValue: r
  } : null)), s == null && (s = at(e.defaultText) ? e.defaultText(i, e, r) : e.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < Ii.length; u++) {
    var c = Ii[u], d = t[c];
    l[c] = bt(n ? n.getFormattedLabel(i, c, null, o, d && d.get("formatter")) : null, s);
  }
  return l;
}
function ri(e, t, r, n) {
  r = r || cw;
  for (var i = e instanceof ir, o = !1, a = 0; a < jg.length; a++) {
    var s = t[jg[a]];
    if (s && s.getShallow("show")) {
      o = !0;
      break;
    }
  }
  var l = i ? e : e.getTextContent();
  if (o) {
    i || (l || (l = new ir(), e.setTextContent(l)), e.stateProxy && (l.stateProxy = e.stateProxy));
    var u = G_(r, t), c = t.normal, d = !!c.getShallow("show"), h = Vr(c, n && n.normal, r, !1, !i);
    h.text = u.normal, i || e.setTextConfig(hC(c, r, !1));
    for (var a = 0; a < Ii.length; a++) {
      var f = Ii[a], s = t[f];
      if (s) {
        var p = l.ensureState(f), g = !!bt(s.getShallow("show"), d);
        if (g !== d && (p.ignore = !g), p.style = Vr(s, n && n[f], r, !0, !i), p.style.text = u[f], !i) {
          var v = e.ensureState(f);
          v.textConfig = hC(s, r, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (h.x = l.style.x), l.style.y != null && (h.y = l.style.y), l.ignore = !d, l.useStyle(h), l.dirty(), r.enableTextSetter && (Sf(l).setLabelText = function(m) {
      var y = G_(r, t, m);
      m7(l, y);
    });
  } else l && (l.ignore = !0);
  e.dirty();
}
function $n(e, t) {
  t = t || "label";
  for (var r = {
    normal: e.getModel(t)
  }, n = 0; n < Ii.length; n++) {
    var i = Ii[n];
    r[i] = e.getModel([i, t]);
  }
  return r;
}
function Vr(e, t, r, n, i) {
  var o = {};
  return kwe(o, e, r, n, i), t && ge(o, t), o;
}
function hC(e, t, r) {
  t = t || {};
  var n = {}, i, o = e.getShallow("rotate"), a = bt(e.getShallow("distance"), r ? null : 5), s = e.getShallow("offset");
  return i = e.getShallow("position") || (r ? null : "inside"), i === "outside" && (i = t.defaultOutsidePosition || "top"), i != null && (n.position = i), s != null && (n.offset = s), o != null && (o *= Math.PI / 180, n.rotation = o), a != null && (n.distance = a), n.outsideFill = e.get("color") === "inherit" ? t.inheritColor || null : "auto", n;
}
function kwe(e, t, r, n, i) {
  r = r || cw;
  var o = t.ecModel, a = o && o.option.textStyle, s = Vwe(t), l;
  if (s) {
    l = {};
    for (var u in s)
      if (s.hasOwnProperty(u)) {
        var c = t.getModel(["rich", u]);
        GN(l[u] = {}, c, a, r, n, i, !1, !0);
      }
  }
  l && (e.rich = l);
  var d = t.get("overflow");
  d && (e.overflow = d);
  var h = t.get("minMargin");
  h != null && (e.margin = h), GN(e, t, a, r, n, i, !0, !1);
}
function Vwe(e) {
  for (var t; e && e !== e.ecModel; ) {
    var r = (e.option || cw).rich;
    if (r) {
      t = t || {};
      for (var n = jt(r), i = 0; i < n.length; i++) {
        var o = n[i];
        t[o] = 1;
      }
    }
    e = e.parentModel;
  }
  return t;
}
var BN = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], $N = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], HN = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function GN(e, t, r, n, i, o, a, s) {
  r = !i && r || cw;
  var l = n && n.inheritColor, u = t.getShallow("color"), c = t.getShallow("textBorderColor"), d = bt(t.getShallow("opacity"), r.opacity);
  (u === "inherit" || u === "auto") && (process.env.NODE_ENV !== "production" && u === "auto" && pn("color: 'auto'", "color: 'inherit'"), l ? u = l : u = null), (c === "inherit" || c === "auto") && (process.env.NODE_ENV !== "production" && c === "auto" && pn("color: 'auto'", "color: 'inherit'"), l ? c = l : c = null), o || (u = u || r.color, c = c || r.textBorderColor), u != null && (e.fill = u), c != null && (e.stroke = c);
  var h = bt(t.getShallow("textBorderWidth"), r.textBorderWidth);
  h != null && (e.lineWidth = h);
  var f = bt(t.getShallow("textBorderType"), r.textBorderType);
  f != null && (e.lineDash = f);
  var p = bt(t.getShallow("textBorderDashOffset"), r.textBorderDashOffset);
  p != null && (e.lineDashOffset = p), !i && d == null && !s && (d = n && n.defaultOpacity), d != null && (e.opacity = d), !i && !o && e.fill == null && n.inheritColor && (e.fill = n.inheritColor);
  for (var g = 0; g < BN.length; g++) {
    var v = BN[g], m = bt(t.getShallow(v), r[v]);
    m != null && (e[v] = m);
  }
  for (var g = 0; g < $N.length; g++) {
    var v = $N[g], m = t.getShallow(v);
    m != null && (e[v] = m);
  }
  if (e.verticalAlign == null) {
    var y = t.getShallow("baseline");
    y != null && (e.verticalAlign = y);
  }
  if (!a || !n.disableBox) {
    for (var g = 0; g < HN.length; g++) {
      var v = HN[g], m = t.getShallow(v);
      m != null && (e[v] = m);
    }
    var C = t.getShallow("borderType");
    C != null && (e.borderDash = C), (e.backgroundColor === "auto" || e.backgroundColor === "inherit") && l && (process.env.NODE_ENV !== "production" && e.backgroundColor === "auto" && pn("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), e.backgroundColor = l), (e.borderColor === "auto" || e.borderColor === "inherit") && l && (process.env.NODE_ENV !== "production" && e.borderColor === "auto" && pn("borderColor: 'auto'", "borderColor: 'inherit'"), e.borderColor = l);
  }
}
function cD(e, t) {
  var r = t && t.getModel("textStyle");
  return Wo([
    // FIXME in node-canvas fontWeight is before fontStyle
    e.fontStyle || r && r.getShallow("fontStyle") || "",
    e.fontWeight || r && r.getShallow("fontWeight") || "",
    (e.fontSize || r && r.getShallow("fontSize") || 12) + "px",
    e.fontFamily || r && r.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var Sf = ar();
function y7(e, t, r, n) {
  if (e) {
    var i = Sf(e);
    i.prevValue = i.value, i.value = r;
    var o = t.normal;
    i.valueAnimation = o.get("valueAnimation"), i.valueAnimation && (i.precision = o.get("precision"), i.defaultInterpolatedText = n, i.statesModels = t);
  }
}
function C7(e, t, r, n, i) {
  var o = Sf(e);
  if (!o.valueAnimation || o.prevValue === o.value)
    return;
  var a = o.defaultInterpolatedText, s = bt(o.interpolatedValue, o.prevValue), l = o.value;
  function u(c) {
    var d = bW(r, o.precision, s, l, c);
    o.interpolatedValue = c === 1 ? null : d;
    var h = G_({
      labelDataIndex: t,
      labelFetcher: i,
      defaultText: a ? a(d) : d + ""
    }, o.statesModels, d);
    m7(e, h);
  }
  e.percent = 0, (o.prevValue == null ? jr : ur)(e, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, n, t, null, u);
}
var Bwe = ["textStyle", "color"], _1 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], T1 = new ir(), $we = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getTextColor = function(t) {
      var r = this.ecModel;
      return this.getShallow("color") || (!t && r ? r.get(Bwe) : null);
    }, e.prototype.getFont = function() {
      return cD({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, e.prototype.getTextRect = function(t) {
      for (var r = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < _1.length; n++)
        r[_1[n]] = this.getShallow(_1[n]);
      return T1.useStyle(r), T1.update(), T1.getBoundingRect();
    }, e;
  }()
), S7 = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], Hwe = Wc(S7), Gwe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getLineStyle = function(t) {
      return Hwe(this, t);
    }, e;
  }()
), w7 = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], zwe = Wc(w7), Wwe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getItemStyle = function(t, r) {
      return zwe(this, t, r);
    }, e;
  }()
), ad = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.parentModel = r, this.ecModel = n, this.option = t;
    }
    return e.prototype.init = function(t, r, n) {
    }, e.prototype.mergeOption = function(t, r) {
      Mt(this.option, t, !0);
    }, e.prototype.get = function(t, r) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !r && this.parentModel);
    }, e.prototype.getShallow = function(t, r) {
      var n = this.option, i = n == null ? n : n[t];
      if (i == null && !r) {
        var o = this.parentModel;
        o && (i = o.getShallow(t));
      }
      return i;
    }, e.prototype.getModel = function(t, r) {
      var n = t != null, i = n ? this.parsePath(t) : null, o = n ? this._doGet(i) : this.option;
      return r = r || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new e(o, r, this.ecModel);
    }, e.prototype.isEmpty = function() {
      return this.option == null;
    }, e.prototype.restoreData = function() {
    }, e.prototype.clone = function() {
      var t = this.constructor;
      return new t(dt(this.option));
    }, e.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, e.prototype.resolveParentPath = function(t) {
      return t;
    }, e.prototype.isAnimationEnabled = function() {
      if (!nr.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, e.prototype._doGet = function(t, r) {
      var n = this.option;
      if (!t)
        return n;
      for (var i = 0; i < t.length && !(t[i] && (n = n && typeof n == "object" ? n[t[i]] : null, n == null)); i++)
        ;
      return n == null && r && (n = r._doGet(this.resolveParentPath(t), r.parentModel)), n;
    }, e;
  }()
);
XM(ad);
QCe(ad);
cn(ad, Gwe);
cn(ad, Wwe);
cn(ad, nSe);
cn(ad, $we);
const _r = ad;
var jwe = Math.round(Math.random() * 10);
function wf(e) {
  return [e || "", jwe++].join("_");
}
function Uwe(e) {
  var t = {};
  e.registerSubTypeDefaulter = function(r, n) {
    var i = ns(r);
    t[i.main] = n;
  }, e.determineSubType = function(r, n) {
    var i = n.type;
    if (!i) {
      var o = ns(r).main;
      e.hasSubTypes(r) && t[o] && (i = t[o](n));
    }
    return i;
  };
}
function Kwe(e, t) {
  e.topologicalTravel = function(o, a, s, l) {
    if (!o.length)
      return;
    var u = r(a), c = u.graph, d = u.noEntryList, h = {};
    for ($(o, function(y) {
      h[y] = !0;
    }); d.length; ) {
      var f = d.pop(), p = c[f], g = !!h[f];
      g && (s.call(l, f, p.originalDeps.slice()), delete h[f]), $(p.successor, g ? m : v);
    }
    $(h, function() {
      var y = "";
      throw process.env.NODE_ENV !== "production" && (y = Ai("Circular dependency may exists: ", h, o, a)), new Error(y);
    });
    function v(y) {
      c[y].entryCount--, c[y].entryCount === 0 && d.push(y);
    }
    function m(y) {
      h[y] = !0, v(y);
    }
  };
  function r(o) {
    var a = {}, s = [];
    return $(o, function(l) {
      var u = n(a, l), c = u.originalDeps = t(l), d = i(c, o);
      u.entryCount = d.length, u.entryCount === 0 && s.push(l), $(d, function(h) {
        Ft(u.predecessor, h) < 0 && u.predecessor.push(h);
        var f = n(a, h);
        Ft(f.successor, h) < 0 && f.successor.push(l);
      });
    }), {
      graph: a,
      noEntryList: s
    };
  }
  function n(o, a) {
    return o[a] || (o[a] = {
      predecessor: [],
      successor: []
    }), o[a];
  }
  function i(o, a) {
    var s = [];
    return $(o, function(l) {
      Ft(a, l) >= 0 && s.push(l);
    }), s;
  }
}
function wu(e, t) {
  return Mt(Mt({}, e, !0), t, !0);
}
const Ywe = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, qwe = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: "",
      custom: "",
      chart: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var fC = "ZH", dD = "EN", Mh = dD, d0 = {}, hD = {}, b7 = nr.domSupported ? function() {
  var e = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || Mh).toUpperCase()
  );
  return e.indexOf(fC) > -1 ? fC : Mh;
}() : Mh;
function fD(e, t) {
  e = e.toUpperCase(), hD[e] = new _r(t), d0[e] = t;
}
function Xwe(e) {
  if (He(e)) {
    var t = d0[e.toUpperCase()] || {};
    return e === fC || e === dD ? dt(t) : Mt(dt(t), dt(d0[Mh]), !1);
  } else
    return Mt(dt(e), dt(d0[Mh]), !1);
}
function z_(e) {
  return hD[e];
}
function Zwe() {
  return hD[Mh];
}
fD(dD, Ywe);
fD(fC, qwe);
var pD = 1e3, gD = pD * 60, dg = gD * 60, zo = dg * 24, zN = zo * 365, Np = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, qm = "{yyyy}-{MM}-{dd}", WN = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: qm,
  hour: qm + " " + Np.hour,
  minute: qm + " " + Np.minute,
  second: qm + " " + Np.second,
  millisecond: Np.none
}, P1 = ["year", "month", "day", "hour", "minute", "second", "millisecond"], x7 = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function bi(e, t) {
  return e += "", "0000".substr(0, t - e.length) + e;
}
function Dh(e) {
  switch (e) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return e;
  }
}
function Qwe(e) {
  return e === Dh(e);
}
function Jwe(e) {
  switch (e) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function Gv(e, t, r, n) {
  var i = bo(e), o = i[vD(r)](), a = i[Ah(r)]() + 1, s = Math.floor((a - 1) / 3) + 1, l = i[dw(r)](), u = i["get" + (r ? "UTC" : "") + "Day"](), c = i[Kg(r)](), d = (c - 1) % 12 + 1, h = i[hw(r)](), f = i[fw(r)](), p = i[pw(r)](), g = c >= 12 ? "pm" : "am", v = g.toUpperCase(), m = n instanceof _r ? n : z_(n || b7) || Zwe(), y = m.getModel("time"), C = y.get("month"), S = y.get("monthAbbr"), b = y.get("dayOfWeek"), w = y.get("dayOfWeekAbbr");
  return (t || "").replace(/{a}/g, g + "").replace(/{A}/g, v + "").replace(/{yyyy}/g, o + "").replace(/{yy}/g, bi(o % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, C[a - 1]).replace(/{MMM}/g, S[a - 1]).replace(/{MM}/g, bi(a, 2)).replace(/{M}/g, a + "").replace(/{dd}/g, bi(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, b[u]).replace(/{ee}/g, w[u]).replace(/{e}/g, u + "").replace(/{HH}/g, bi(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, bi(d + "", 2)).replace(/{h}/g, d + "").replace(/{mm}/g, bi(h, 2)).replace(/{m}/g, h + "").replace(/{ss}/g, bi(f, 2)).replace(/{s}/g, f + "").replace(/{SSS}/g, bi(p, 3)).replace(/{S}/g, p + "");
}
function ebe(e, t, r, n, i) {
  var o = null;
  if (He(r))
    o = r;
  else if (at(r))
    o = r(e.value, t, {
      level: e.level
    });
  else {
    var a = ge({}, Np);
    if (e.level > 0)
      for (var s = 0; s < P1.length; ++s)
        a[P1[s]] = "{primary|" + a[P1[s]] + "}";
    var l = r ? r.inherit === !1 ? r : ut(r, a) : a, u = E7(e.value, i);
    if (l[u])
      o = l[u];
    else if (l.inherit) {
      for (var c = x7.indexOf(u), s = c - 1; s >= 0; --s)
        if (l[u]) {
          o = l[u];
          break;
        }
      o = o || a.none;
    }
    if (be(o)) {
      var d = e.level == null ? 0 : e.level >= 0 ? e.level : o.length + e.level;
      d = Math.min(d, o.length - 1), o = o[d];
    }
  }
  return Gv(new Date(e.value), o, i, n);
}
function E7(e, t) {
  var r = bo(e), n = r[Ah(t)]() + 1, i = r[dw(t)](), o = r[Kg(t)](), a = r[hw(t)](), s = r[fw(t)](), l = r[pw(t)](), u = l === 0, c = u && s === 0, d = c && a === 0, h = d && o === 0, f = h && i === 1, p = f && n === 1;
  return p ? "year" : f ? "month" : h ? "day" : d ? "hour" : c ? "minute" : u ? "second" : "millisecond";
}
function jN(e, t, r) {
  var n = sr(e) ? bo(e) : e;
  switch (t = t || E7(e, r), t) {
    case "year":
      return n[vD(r)]();
    case "half-year":
      return n[Ah(r)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((n[Ah(r)]() + 1) / 4);
    case "month":
      return n[Ah(r)]();
    case "day":
      return n[dw(r)]();
    case "half-day":
      return n[Kg(r)]() / 24;
    case "hour":
      return n[Kg(r)]();
    case "minute":
      return n[hw(r)]();
    case "second":
      return n[fw(r)]();
    case "millisecond":
      return n[pw(r)]();
  }
}
function vD(e) {
  return e ? "getUTCFullYear" : "getFullYear";
}
function Ah(e) {
  return e ? "getUTCMonth" : "getMonth";
}
function dw(e) {
  return e ? "getUTCDate" : "getDate";
}
function Kg(e) {
  return e ? "getUTCHours" : "getHours";
}
function hw(e) {
  return e ? "getUTCMinutes" : "getMinutes";
}
function fw(e) {
  return e ? "getUTCSeconds" : "getSeconds";
}
function pw(e) {
  return e ? "getUTCMilliseconds" : "getMilliseconds";
}
function tbe(e) {
  return e ? "setUTCFullYear" : "setFullYear";
}
function R7(e) {
  return e ? "setUTCMonth" : "setMonth";
}
function _7(e) {
  return e ? "setUTCDate" : "setDate";
}
function T7(e) {
  return e ? "setUTCHours" : "setHours";
}
function P7(e) {
  return e ? "setUTCMinutes" : "setMinutes";
}
function M7(e) {
  return e ? "setUTCSeconds" : "setSeconds";
}
function D7(e) {
  return e ? "setUTCMilliseconds" : "setMilliseconds";
}
function rbe(e, t, r, n, i, o, a, s) {
  var l = new ir({
    style: {
      text: e,
      font: t,
      align: r,
      verticalAlign: n,
      padding: i,
      rich: o,
      overflow: a ? "truncate" : null,
      lineHeight: s
    }
  });
  return l.getBoundingRect();
}
function mD(e) {
  if (!ZS(e))
    return He(e) ? e : "-";
  var t = (e + "").split(".");
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
}
function yD(e, t) {
  return e = (e || "").toLowerCase().replace(/-(.)/g, function(r, n) {
    return n.toUpperCase();
  }), t && e && (e = e.charAt(0).toUpperCase() + e.slice(1)), e;
}
var sd = jS;
function W_(e, t, r) {
  var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function i(c) {
    return c && Wo(c) ? c : "-";
  }
  function o(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var a = t === "time", s = e instanceof Date;
  if (a || s) {
    var l = a ? bo(e) : e;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else return Gv(l, n, r);
  }
  if (t === "ordinal")
    return Ng(e) ? i(e) : sr(e) && o(e) ? e + "" : "-";
  var u = vs(e);
  return o(u) ? mD(u) : Ng(e) ? i(e) : typeof e == "boolean" ? e + "" : "-";
}
var UN = ["a", "b", "c", "d", "e", "f", "g"], M1 = function(e, t) {
  return "{" + e + (t ?? "") + "}";
};
function CD(e, t, r) {
  be(t) || (t = [t]);
  var n = t.length;
  if (!n)
    return "";
  for (var i = t[0].$vars || [], o = 0; o < i.length; o++) {
    var a = UN[o];
    e = e.replace(M1(a), M1(a, 0));
  }
  for (var s = 0; s < n; s++)
    for (var l = 0; l < i.length; l++) {
      var u = t[s][i[l]];
      e = e.replace(M1(UN[l], s), r ? Ei(u) : u);
    }
  return e;
}
function nbe(e, t, r) {
  return $(t, function(n, i) {
    e = e.replace("{" + i + "}", n);
  }), e;
}
function A7(e, t) {
  var r = He(e) ? {
    color: e,
    extraCssText: t
  } : e || {}, n = r.color, i = r.type;
  t = r.extraCssText;
  var o = r.renderMode || "html";
  if (!n)
    return "";
  if (o === "html")
    return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Ei(n) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Ei(n) + ";" + (t || "") + '"></span>';
  var a = r.markerId || "markerX";
  return {
    renderMode: o,
    content: "{" + a + "|}  ",
    style: i === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: n
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: n
    }
  };
}
function ibe(e, t, r) {
  process.env.NODE_ENV !== "production" && pn("echarts.format.formatTime", "echarts.time.format"), (e === "week" || e === "month" || e === "quarter" || e === "half-year" || e === "year") && (e = `MM-dd
yyyy`);
  var n = bo(t), i = r ? "getUTC" : "get", o = n[i + "FullYear"](), a = n[i + "Month"]() + 1, s = n[i + "Date"](), l = n[i + "Hours"](), u = n[i + "Minutes"](), c = n[i + "Seconds"](), d = n[i + "Milliseconds"]();
  return e = e.replace("MM", bi(a, 2)).replace("M", a).replace("yyyy", o).replace("yy", bi(o % 100 + "", 2)).replace("dd", bi(s, 2)).replace("d", s).replace("hh", bi(l, 2)).replace("h", l).replace("mm", bi(u, 2)).replace("m", u).replace("ss", bi(c, 2)).replace("s", c).replace("SSS", bi(d, 3)), e;
}
function obe(e) {
  return e && e.charAt(0).toUpperCase() + e.substr(1);
}
function Uc(e, t) {
  return t = t || "transparent", He(e) ? e : lt(e) && e.colorStops && (e.colorStops[0] || {}).color || t;
}
function pC(e, t) {
  if (t === "_blank" || t === "blank") {
    var r = window.open();
    r.opener = null, r.location.href = e;
  } else
    window.open(e, t);
}
var h0 = $, I7 = ["left", "right", "top", "bottom", "width", "height"], yc = [["width", "left", "right"], ["height", "top", "bottom"]];
function SD(e, t, r, n, i) {
  var o = 0, a = 0;
  n == null && (n = 1 / 0), i == null && (i = 1 / 0);
  var s = 0;
  t.eachChild(function(l, u) {
    var c = l.getBoundingRect(), d = t.childAt(u + 1), h = d && d.getBoundingRect(), f, p;
    if (e === "horizontal") {
      var g = c.width + (h ? -h.x + c.x : 0);
      f = o + g, f > n || l.newline ? (o = 0, f = g, a += s + r, s = c.height) : s = Math.max(s, c.height);
    } else {
      var v = c.height + (h ? -h.y + c.y : 0);
      p = a + v, p > i || l.newline ? (o += s + r, a = 0, p = v, s = c.width) : s = Math.max(s, c.width);
    }
    l.newline || (l.x = o, l.y = a, l.markRedraw(), e === "horizontal" ? o = f + r : a = p + r);
  });
}
var Mc = SD;
_t(SD, "vertical");
_t(SD, "horizontal");
function abe(e, t, r) {
  var n = t.width, i = t.height, o = Be(e.left, n), a = Be(e.top, i), s = Be(e.right, n), l = Be(e.bottom, i);
  return (isNaN(o) || isNaN(parseFloat(e.left))) && (o = 0), (isNaN(s) || isNaN(parseFloat(e.right))) && (s = n), (isNaN(a) || isNaN(parseFloat(e.top))) && (a = 0), (isNaN(l) || isNaN(parseFloat(e.bottom))) && (l = i), r = sd(r || 0), {
    width: Math.max(s - o - r[1] - r[3], 0),
    height: Math.max(l - a - r[0] - r[2], 0)
  };
}
function En(e, t, r) {
  r = sd(r || 0);
  var n = t.width, i = t.height, o = Be(e.left, n), a = Be(e.top, i), s = Be(e.right, n), l = Be(e.bottom, i), u = Be(e.width, n), c = Be(e.height, i), d = r[2] + r[0], h = r[1] + r[3], f = e.aspect;
  switch (isNaN(u) && (u = n - s - h - o), isNaN(c) && (c = i - l - d - a), f != null && (isNaN(u) && isNaN(c) && (f > n / i ? u = n * 0.8 : c = i * 0.8), isNaN(u) && (u = f * c), isNaN(c) && (c = u / f)), isNaN(o) && (o = n - s - u - h), isNaN(a) && (a = i - l - c - d), e.left || e.right) {
    case "center":
      o = n / 2 - u / 2 - r[3];
      break;
    case "right":
      o = n - u - h;
      break;
  }
  switch (e.top || e.bottom) {
    case "middle":
    case "center":
      a = i / 2 - c / 2 - r[0];
      break;
    case "bottom":
      a = i - c - d;
      break;
  }
  o = o || 0, a = a || 0, isNaN(u) && (u = n - h - o - (s || 0)), isNaN(c) && (c = i - d - a - (l || 0));
  var p = new At(o + r[3], a + r[0], u, c);
  return p.margin = r, p;
}
function gw(e, t, r, n, i, o) {
  var a = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
  if (o = o || e, o.x = e.x, o.y = e.y, !a && !s)
    return !1;
  var u;
  if (l === "raw")
    u = e.type === "group" ? new At(0, 0, +t.width || 0, +t.height || 0) : e.getBoundingRect();
  else if (u = e.getBoundingRect(), e.needLocalTransform()) {
    var c = e.getLocalTransform();
    u = u.clone(), u.applyTransform(c);
  }
  var d = En(ut({
    width: u.width,
    height: u.height
  }, t), r, n), h = a ? d.x - u.x : 0, f = s ? d.y - u.y : 0;
  return l === "raw" ? (o.x = h, o.y = f) : (o.x += h, o.y += f), o === e && e.markRedraw(), !0;
}
function sbe(e, t) {
  return e[yc[t][0]] != null || e[yc[t][1]] != null && e[yc[t][2]] != null;
}
function Yg(e) {
  var t = e.layoutMode || e.constructor.layoutMode;
  return lt(t) ? t : t ? {
    type: t
  } : null;
}
function su(e, t, r) {
  var n = r && r.ignoreSize;
  !be(n) && (n = [n, n]);
  var i = a(yc[0], 0), o = a(yc[1], 1);
  u(yc[0], e, i), u(yc[1], e, o);
  function a(c, d) {
    var h = {}, f = 0, p = {}, g = 0, v = 2;
    if (h0(c, function(C) {
      p[C] = e[C];
    }), h0(c, function(C) {
      s(t, C) && (h[C] = p[C] = t[C]), l(h, C) && f++, l(p, C) && g++;
    }), n[d])
      return l(t, c[1]) ? p[c[2]] = null : l(t, c[2]) && (p[c[1]] = null), p;
    if (g === v || !f)
      return p;
    if (f >= v)
      return h;
    for (var m = 0; m < c.length; m++) {
      var y = c[m];
      if (!s(h, y) && s(e, y)) {
        h[y] = e[y];
        break;
      }
    }
    return h;
  }
  function s(c, d) {
    return c.hasOwnProperty(d);
  }
  function l(c, d) {
    return c[d] != null && c[d] !== "auto";
  }
  function u(c, d, h) {
    h0(c, function(f) {
      d[f] = h[f];
    });
  }
}
function bf(e) {
  return O7({}, e);
}
function O7(e, t) {
  return t && e && h0(I7, function(r) {
    t.hasOwnProperty(r) && (e[r] = t[r]);
  }), e;
}
var lbe = ar(), Vt = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i) {
      var o = e.call(this, r, n, i) || this;
      return o.uid = wf("ec_cpt_model"), o;
    }
    return t.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i);
    }, t.prototype.mergeDefaultAndTheme = function(r, n) {
      var i = Yg(this), o = i ? bf(r) : {}, a = n.getTheme();
      Mt(r, a.get(this.mainType)), Mt(r, this.getDefaultOption()), i && su(r, o, i);
    }, t.prototype.mergeOption = function(r, n) {
      Mt(this.option, r, !0);
      var i = Yg(this);
      i && su(this.option, r, i);
    }, t.prototype.optionUpdated = function(r, n) {
    }, t.prototype.getDefaultOption = function() {
      var r = this.constructor;
      if (!qCe(r))
        return r.defaultOption;
      var n = lbe(this);
      if (!n.defaultOption) {
        for (var i = [], o = r; o; ) {
          var a = o.prototype.defaultOption;
          a && i.push(a), o = o.superClass;
        }
        for (var s = {}, l = i.length - 1; l >= 0; l--)
          s = Mt(s, i[l], !0);
        n.defaultOption = s;
      }
      return n.defaultOption;
    }, t.prototype.getReferringComponents = function(r, n) {
      var i = r + "Index", o = r + "Id";
      return Nv(this.ecModel, r, {
        index: this.get(i, !0),
        id: this.get(o, !0)
      }, n);
    }, t.prototype.getBoxLayoutParams = function() {
      var r = this;
      return {
        left: r.get("left"),
        top: r.get("top"),
        right: r.get("right"),
        bottom: r.get("bottom"),
        width: r.get("width"),
        height: r.get("height")
      };
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(r) {
      this.option.zlevel = r;
    }, t.protoInitialize = function() {
      var r = t.prototype;
      r.type = "component", r.id = "", r.name = "", r.mainType = "", r.subType = "", r.componentIndex = 0;
    }(), t;
  }(_r)
);
EW(Vt, _r);
JS(Vt);
Uwe(Vt);
Kwe(Vt, ube);
function ube(e) {
  var t = [];
  return $(Vt.getClassesByMainType(e), function(r) {
    t = t.concat(r.dependencies || r.prototype.dependencies || []);
  }), t = Ee(t, function(r) {
    return ns(r).main;
  }), e !== "dataset" && Ft(t, "dataset") <= 0 && t.unshift("dataset"), t;
}
var L7 = "";
typeof navigator < "u" && (L7 = navigator.platform || "");
var kd = "rgba(0, 0, 0, 0.2)";
const cbe = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: kd,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: kd,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: kd,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: kd,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: kd,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: kd,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: L7.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var j_ = nt(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), oa = "original", fi = "arrayRows", aa = "objectRows", Ss = "keyedColumns", zs = "typedArray", F7 = "unknown", cs = "column", xf = "row", Xn = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, N7 = ar();
function dbe(e) {
  N7(e).datasetMap = nt();
}
function k7(e, t, r) {
  var n = {}, i = bD(t);
  if (!i || !e)
    return n;
  var o = [], a = [], s = t.ecModel, l = N7(s).datasetMap, u = i.uid + "_" + r.seriesLayoutBy, c, d;
  e = e.slice(), $(e, function(g, v) {
    var m = lt(g) ? g : e[v] = {
      name: g
    };
    m.type === "ordinal" && c == null && (c = v, d = p(m)), n[m.name] = [];
  });
  var h = l.get(u) || l.set(u, {
    categoryWayDim: d,
    valueWayDim: 0
  });
  $(e, function(g, v) {
    var m = g.name, y = p(g);
    if (c == null) {
      var C = h.valueWayDim;
      f(n[m], C, y), f(a, C, y), h.valueWayDim += y;
    } else if (c === v)
      f(n[m], 0, y), f(o, 0, y);
    else {
      var C = h.categoryWayDim;
      f(n[m], C, y), f(a, C, y), h.categoryWayDim += y;
    }
  });
  function f(g, v, m) {
    for (var y = 0; y < m; y++)
      g.push(v + y);
  }
  function p(g) {
    var v = g.dimsDef;
    return v ? v.length : 1;
  }
  return o.length && (n.itemName = o), a.length && (n.seriesName = a), n;
}
function wD(e, t, r) {
  var n = {}, i = bD(e);
  if (!i)
    return n;
  var o = t.sourceFormat, a = t.dimensionsDefine, s;
  (o === aa || o === Ss) && $(a, function(c, d) {
    (lt(c) ? c.name : c) === "name" && (s = d);
  });
  var l = function() {
    for (var c = {}, d = {}, h = [], f = 0, p = Math.min(5, r); f < p; f++) {
      var g = B7(t.data, o, t.seriesLayoutBy, a, t.startIndex, f);
      h.push(g);
      var v = g === Xn.Not;
      if (v && c.v == null && f !== s && (c.v = f), (c.n == null || c.n === c.v || !v && h[c.n] === Xn.Not) && (c.n = f), m(c) && h[c.n] !== Xn.Not)
        return c;
      v || (g === Xn.Might && d.v == null && f !== s && (d.v = f), (d.n == null || d.n === d.v) && (d.n = f));
    }
    function m(y) {
      return y.v != null && y.n != null;
    }
    return m(c) ? c : m(d) ? d : null;
  }();
  if (l) {
    n.value = [l.v];
    var u = s ?? l.n;
    n.itemName = [u], n.seriesName = [u];
  }
  return n;
}
function bD(e) {
  var t = e.get("data", !0);
  if (!t)
    return Nv(e.ecModel, "dataset", {
      index: e.get("datasetIndex", !0),
      id: e.get("datasetId", !0)
    }, bn).models[0];
}
function hbe(e) {
  return !e.get("transform", !0) && !e.get("fromTransformResult", !0) ? [] : Nv(e.ecModel, "dataset", {
    index: e.get("fromDatasetIndex", !0),
    id: e.get("fromDatasetId", !0)
  }, bn).models;
}
function V7(e, t) {
  return B7(e.data, e.sourceFormat, e.seriesLayoutBy, e.dimensionsDefine, e.startIndex, t);
}
function B7(e, t, r, n, i, o) {
  var a, s = 5;
  if (hi(e))
    return Xn.Not;
  var l, u;
  if (n) {
    var c = n[o];
    lt(c) ? (l = c.name, u = c.type) : He(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? Xn.Must : Xn.Not;
  if (t === fi) {
    var d = e;
    if (r === xf) {
      for (var h = d[o], f = 0; f < (h || []).length && f < s; f++)
        if ((a = S(h[i + f])) != null)
          return a;
    } else
      for (var f = 0; f < d.length && f < s; f++) {
        var p = d[i + f];
        if (p && (a = S(p[o])) != null)
          return a;
      }
  } else if (t === aa) {
    var g = e;
    if (!l)
      return Xn.Not;
    for (var f = 0; f < g.length && f < s; f++) {
      var v = g[f];
      if (v && (a = S(v[l])) != null)
        return a;
    }
  } else if (t === Ss) {
    var m = e;
    if (!l)
      return Xn.Not;
    var h = m[l];
    if (!h || hi(h))
      return Xn.Not;
    for (var f = 0; f < h.length && f < s; f++)
      if ((a = S(h[f])) != null)
        return a;
  } else if (t === oa)
    for (var y = e, f = 0; f < y.length && f < s; f++) {
      var v = y[f], C = pf(v);
      if (!be(C))
        return Xn.Not;
      if ((a = S(C[o])) != null)
        return a;
    }
  function S(b) {
    var w = He(b);
    if (b != null && Number.isFinite(Number(b)) && b !== "")
      return w ? Xn.Might : Xn.Not;
    if (w && b !== "-")
      return Xn.Must;
  }
  return Xn.Not;
}
var U_ = nt();
function fbe(e, t) {
  ct(U_.get(e) == null && t), U_.set(e, t);
}
function pbe(e, t, r) {
  var n = U_.get(t);
  if (!n)
    return r;
  var i = n(e);
  if (!i)
    return r;
  if (process.env.NODE_ENV !== "production")
    for (var o = 0; o < i.length; o++)
      ct(Wh(i[o]));
  return r.concat(i);
}
var KN = ar(), gbe = ar(), xD = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getColorFromPalette = function(t, r, n) {
      var i = Tr(this.get("color", !0)), o = this.get("colorLayer", !0);
      return $7(this, KN, i, o, t, r, n);
    }, e.prototype.clearColorPalette = function() {
      mbe(this, KN);
    }, e;
  }()
);
function K_(e, t, r, n) {
  var i = Tr(e.get(["aria", "decal", "decals"]));
  return $7(e, gbe, i, null, t, r, n);
}
function vbe(e, t) {
  for (var r = e.length, n = 0; n < r; n++)
    if (e[n].length > t)
      return e[n];
  return e[r - 1];
}
function $7(e, t, r, n, i, o, a) {
  o = o || e;
  var s = t(o), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(i))
    return u[i];
  var c = a == null || !n ? r : vbe(n, a);
  if (c = c || r, !(!c || !c.length)) {
    var d = c[l];
    return i && (u[i] = d), s.paletteIdx = (l + 1) % c.length, d;
  }
}
function mbe(e, t) {
  t(e).paletteIdx = 0, t(e).paletteNameMap = {};
}
var Xm, np, YN, D1 = "\0_ec_inner", qN = 1, ybe = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, Cbe = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, gC = {};
function Sbe(e) {
  $(e, function(t, r) {
    if (!Vt.hasClass(r)) {
      var n = ybe[r];
      n && !gC[n] && (ei("Component " + r + ` is used but not imported.
import { ` + n + ` } from 'echarts/components';
echarts.use([` + n + "]);"), gC[n] = !0);
    }
  });
}
var ED = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function(r, n, i, o, a, s) {
      o = o || {}, this.option = null, this._theme = new _r(o), this._locale = new _r(a), this._optionManager = s;
    }, t.prototype.setOption = function(r, n, i) {
      process.env.NODE_ENV !== "production" && (ct(r != null, "option is null/undefined"), ct(r[D1] !== qN, "please use chart.getOption()"));
      var o = QN(n);
      this._optionManager.setOption(r, i, o), this._resetOption(null, o);
    }, t.prototype.resetOption = function(r, n) {
      return this._resetOption(r, QN(n));
    }, t.prototype._resetOption = function(r, n) {
      var i = !1, o = this._optionManager;
      if (!r || r === "recreate") {
        var a = o.mountOption(r === "recreate");
        process.env.NODE_ENV !== "production" && Sbe(a), !this.option || r === "recreate" ? YN(this, a) : (this.restoreData(), this._mergeOption(a, n)), i = !0;
      }
      if ((r === "timeline" || r === "media") && this.restoreData(), !r || r === "recreate" || r === "timeline") {
        var s = o.getTimelineOption(this);
        s && (i = !0, this._mergeOption(s, n));
      }
      if (!r || r === "recreate" || r === "media") {
        var l = o.getMediaOption(this);
        l.length && $(l, function(u) {
          i = !0, this._mergeOption(u, n);
        }, this);
      }
      return i;
    }, t.prototype.mergeOption = function(r) {
      this._mergeOption(r, null);
    }, t.prototype._mergeOption = function(r, n) {
      var i = this.option, o = this._componentsMap, a = this._componentsCount, s = [], l = nt(), u = n && n.replaceMergeMainTypeMap;
      dbe(this), $(r, function(d, h) {
        d != null && (Vt.hasClass(h) ? h && (s.push(h), l.set(h, !0)) : i[h] = i[h] == null ? dt(d) : Mt(i[h], d, !0));
      }), u && u.each(function(d, h) {
        Vt.hasClass(h) && !l.get(h) && (s.push(h), l.set(h, !0));
      }), Vt.topologicalTravel(s, Vt.getAllClassMainTypes(), c, this);
      function c(d) {
        var h = pbe(this, d, Tr(r[d])), f = o.get(d), p = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          f ? u && u.get(d) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = CW(f, h, p);
        $Ce(g, d, Vt), i[d] = null, o.set(d, null), a.set(d, 0);
        var v = [], m = [], y = 0, C, S;
        $(g, function(b, w) {
          var x = b.existing, R = b.newOption;
          if (!R)
            x && (x.mergeOption({}, this), x.optionUpdated({}, !1));
          else {
            var _ = d === "series", T = Vt.getClass(
              d,
              b.keyInfo.subType,
              !_
              // Give a more detailed warn later if series don't exists
            );
            if (!T) {
              if (process.env.NODE_ENV !== "production") {
                var P = b.keyInfo.subType, D = Cbe[P];
                gC[P] || (gC[P] = !0, ei(D ? "Series " + P + ` is used but not imported.
import { ` + D + ` } from 'echarts/charts';
echarts.use([` + D + "]);" : "Unknown series " + P));
              }
              return;
            }
            if (d === "tooltip") {
              if (C) {
                process.env.NODE_ENV !== "production" && (S || (nn("Currently only one tooltip component is allowed."), S = !0));
                return;
              }
              C = !0;
            }
            if (x && x.constructor === T)
              x.name = b.keyInfo.name, x.mergeOption(R, this), x.optionUpdated(R, !1);
            else {
              var O = ge({
                componentIndex: w
              }, b.keyInfo);
              x = new T(R, this, this, O), ge(x, O), b.brandNew && (x.__requireNewView = !0), x.init(R, this, this), x.optionUpdated(null, !0);
            }
          }
          x ? (v.push(x.option), m.push(x), y++) : (v.push(void 0), m.push(void 0));
        }, this), i[d] = v, o.set(d, m), a.set(d, y), d === "series" && Xm(this);
      }
      this._seriesIndices || Xm(this);
    }, t.prototype.getOption = function() {
      var r = dt(this.option);
      return $(r, function(n, i) {
        if (Vt.hasClass(i)) {
          for (var o = Tr(n), a = o.length, s = !1, l = a - 1; l >= 0; l--)
            o[l] && !Wh(o[l]) ? s = !0 : (o[l] = null, !s && a--);
          o.length = a, r[i] = o;
        }
      }), delete r[D1], r;
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(r) {
      this._payload = r;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(r, n) {
      var i = this._componentsMap.get(r);
      if (i) {
        var o = i[n || 0];
        if (o)
          return o;
        if (n == null) {
          for (var a = 0; a < i.length; a++)
            if (i[a])
              return i[a];
        }
      }
    }, t.prototype.queryComponents = function(r) {
      var n = r.mainType;
      if (!n)
        return [];
      var i = r.index, o = r.id, a = r.name, s = this._componentsMap.get(n);
      if (!s || !s.length)
        return [];
      var l;
      return i != null ? (l = [], $(Tr(i), function(u) {
        s[u] && l.push(s[u]);
      })) : o != null ? l = XN("id", o, s) : a != null ? l = XN("name", a, s) : l = Sr(s, function(u) {
        return !!u;
      }), ZN(l, r);
    }, t.prototype.findComponents = function(r) {
      var n = r.query, i = r.mainType, o = s(n), a = o ? this.queryComponents(o) : Sr(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(ZN(a, r));
      function s(u) {
        var c = i + "Index", d = i + "Id", h = i + "Name";
        return u && (u[c] != null || u[d] != null || u[h] != null) ? {
          mainType: i,
          // subType will be filtered finally.
          index: u[c],
          id: u[d],
          name: u[h]
        } : null;
      }
      function l(u) {
        return r.filter ? Sr(u, r.filter) : u;
      }
    }, t.prototype.eachComponent = function(r, n, i) {
      var o = this._componentsMap;
      if (at(r)) {
        var a = n, s = r;
        o.each(function(d, h) {
          for (var f = 0; d && f < d.length; f++) {
            var p = d[f];
            p && s.call(a, h, p, p.componentIndex);
          }
        });
      } else
        for (var l = He(r) ? o.get(r) : lt(r) ? this.findComponents(r) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && n.call(i, c, c.componentIndex);
        }
    }, t.prototype.getSeriesByName = function(r) {
      var n = In(r, null);
      return Sr(this._componentsMap.get("series"), function(i) {
        return !!i && n != null && i.name === n;
      });
    }, t.prototype.getSeriesByIndex = function(r) {
      return this._componentsMap.get("series")[r];
    }, t.prototype.getSeriesByType = function(r) {
      return Sr(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === r;
      });
    }, t.prototype.getSeries = function() {
      return Sr(this._componentsMap.get("series"), function(r) {
        return !!r;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(r, n) {
      np(this), $(this._seriesIndices, function(i) {
        var o = this._componentsMap.get("series")[i];
        r.call(n, o, i);
      }, this);
    }, t.prototype.eachRawSeries = function(r, n) {
      $(this._componentsMap.get("series"), function(i) {
        i && r.call(n, i, i.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(r, n, i) {
      np(this), $(this._seriesIndices, function(o) {
        var a = this._componentsMap.get("series")[o];
        a.subType === r && n.call(i, a, o);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(r, n, i) {
      return $(this.getSeriesByType(r), n, i);
    }, t.prototype.isSeriesFiltered = function(r) {
      return np(this), this._seriesIndicesMap.get(r.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(r, n) {
      np(this);
      var i = [];
      $(this._seriesIndices, function(o) {
        var a = this._componentsMap.get("series")[o];
        r.call(n, a, o) && i.push(o);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = nt(i);
    }, t.prototype.restoreData = function(r) {
      Xm(this);
      var n = this._componentsMap, i = [];
      n.each(function(o, a) {
        Vt.hasClass(a) && i.push(a);
      }), Vt.topologicalTravel(i, Vt.getAllClassMainTypes(), function(o) {
        $(n.get(o), function(a) {
          a && (o !== "series" || !wbe(a, r)) && a.restoreData();
        });
      });
    }, t.internalField = function() {
      Xm = function(r) {
        var n = r._seriesIndices = [];
        $(r._componentsMap.get("series"), function(i) {
          i && n.push(i.componentIndex);
        }), r._seriesIndicesMap = nt(n);
      }, np = function(r) {
        if (process.env.NODE_ENV !== "production" && !r._seriesIndices)
          throw new Error("Option should contains series.");
      }, YN = function(r, n) {
        r.option = {}, r.option[D1] = qN, r._componentsMap = nt({
          series: []
        }), r._componentsCount = nt();
        var i = n.aria;
        lt(i) && i.enabled == null && (i.enabled = !0), bbe(n, r._theme.option), Mt(n, cbe, !1), r._mergeOption(n, null);
      };
    }(), t;
  }(_r)
);
function wbe(e, t) {
  if (t) {
    var r = t.seriesIndex, n = t.seriesId, i = t.seriesName;
    return r != null && e.componentIndex !== r || n != null && e.id !== n || i != null && e.name !== i;
  }
}
function bbe(e, t) {
  var r = e.color && !e.colorLayer;
  $(t, function(n, i) {
    i === "colorLayer" && r || Vt.hasClass(i) || (typeof n == "object" ? e[i] = e[i] ? Mt(e[i], n, !1) : dt(n) : e[i] == null && (e[i] = n));
  });
}
function XN(e, t, r) {
  if (be(t)) {
    var n = nt();
    return $(t, function(o) {
      if (o != null) {
        var a = In(o, null);
        a != null && n.set(o, !0);
      }
    }), Sr(r, function(o) {
      return o && n.get(o[e]);
    });
  } else {
    var i = In(t, null);
    return Sr(r, function(o) {
      return o && i != null && o[e] === i;
    });
  }
}
function ZN(e, t) {
  return t.hasOwnProperty("subType") ? Sr(e, function(r) {
    return r && r.subType === t.subType;
  }) : e;
}
function QN(e) {
  var t = nt();
  return e && $(Tr(e.replaceMerge), function(r) {
    process.env.NODE_ENV !== "production" && ct(Vt.hasClass(r), '"' + r + '" is not valid component main type in "replaceMerge"'), t.set(r, !0);
  }), {
    replaceMergeMainTypeMap: t
  };
}
cn(ED, xD);
var xbe = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], H7 = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      $(xbe, function(r) {
        this[r] = je(t[r], t);
      }, this);
    }
    return e;
  }()
), A1 = {}, ld = (
  /** @class */
  function() {
    function e() {
      this._coordinateSystems = [];
    }
    return e.prototype.create = function(t, r) {
      var n = [];
      $(A1, function(i, o) {
        var a = i.create(t, r);
        n = n.concat(a || []);
      }), this._coordinateSystems = n;
    }, e.prototype.update = function(t, r) {
      $(this._coordinateSystems, function(n) {
        n.update && n.update(t, r);
      });
    }, e.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, e.register = function(t, r) {
      A1[t] = r;
    }, e.get = function(t) {
      return A1[t];
    }, e;
  }()
), Ebe = /^(min|max)?(.+)$/, Rbe = (
  /** @class */
  function() {
    function e(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return e.prototype.setOption = function(t, r, n) {
      t && ($(Tr(t.series), function(a) {
        a && a.data && hi(a.data) && kg(a.data);
      }), $(Tr(t.dataset), function(a) {
        a && a.source && hi(a.source) && kg(a.source);
      })), t = dt(t);
      var i = this._optionBackup, o = _be(t, r, !i);
      this._newBaseOption = o.baseOption, i ? (o.timelineOptions.length && (i.timelineOptions = o.timelineOptions), o.mediaList.length && (i.mediaList = o.mediaList), o.mediaDefault && (i.mediaDefault = o.mediaDefault)) : this._optionBackup = o;
    }, e.prototype.mountOption = function(t) {
      var r = this._optionBackup;
      return this._timelineOptions = r.timelineOptions, this._mediaList = r.mediaList, this._mediaDefault = r.mediaDefault, this._currentMediaIndices = [], dt(t ? r.baseOption : this._newBaseOption);
    }, e.prototype.getTimelineOption = function(t) {
      var r, n = this._timelineOptions;
      if (n.length) {
        var i = t.getComponent("timeline");
        i && (r = dt(
          // FIXME:TS as TimelineModel or quivlant interface
          n[i.getCurrentIndex()]
        ));
      }
      return r;
    }, e.prototype.getMediaOption = function(t) {
      var r = this._api.getWidth(), n = this._api.getHeight(), i = this._mediaList, o = this._mediaDefault, a = [], s = [];
      if (!i.length && !o)
        return s;
      for (var l = 0, u = i.length; l < u; l++)
        Tbe(i[l].query, r, n) && a.push(l);
      return !a.length && o && (a = [-1]), a.length && !Mbe(a, this._currentMediaIndices) && (s = Ee(a, function(c) {
        return dt(c === -1 ? o.option : i[c].option);
      })), this._currentMediaIndices = a, s;
    }, e;
  }()
);
function _be(e, t, r) {
  var n = [], i, o, a = e.baseOption, s = e.timeline, l = e.options, u = e.media, c = !!e.media, d = !!(l || s || a && a.timeline);
  a ? (o = a, o.timeline || (o.timeline = s)) : ((d || c) && (e.options = e.media = null), o = e), c && (be(u) ? $(u, function(f) {
    process.env.NODE_ENV !== "production" && f && !f.option && lt(f.query) && lt(f.query.option) && ei("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), f && f.option && (f.query ? n.push(f) : i || (i = f));
  }) : process.env.NODE_ENV !== "production" && ei("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), h(o), $(l, function(f) {
    return h(f);
  }), $(n, function(f) {
    return h(f.option);
  });
  function h(f) {
    $(t, function(p) {
      p(f, r);
    });
  }
  return {
    baseOption: o,
    timelineOptions: l || [],
    mediaDefault: i,
    mediaList: n
  };
}
function Tbe(e, t, r) {
  var n = {
    width: t,
    height: r,
    aspectratio: t / r
    // lower case for convenience.
  }, i = !0;
  return $(e, function(o, a) {
    var s = a.match(Ebe);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      Pbe(n[u], o, l) || (i = !1);
    }
  }), i;
}
function Pbe(e, t, r) {
  return r === "min" ? e >= t : r === "max" ? e <= t : e === t;
}
function Mbe(e, t) {
  return e.join(",") === t.join(",");
}
var Mo = $, qg = lt, JN = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function I1(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var r = 0, n = JN.length; r < n; r++) {
      var i = JN[r], o = t.normal, a = t.emphasis;
      o && o[i] && (process.env.NODE_ENV !== "production" && pn("itemStyle.normal." + i, i), e[i] = e[i] || {}, e[i].normal ? Mt(e[i].normal, o[i]) : e[i].normal = o[i], o[i] = null), a && a[i] && (process.env.NODE_ENV !== "production" && pn("itemStyle.emphasis." + i, "emphasis." + i), e[i] = e[i] || {}, e[i].emphasis ? Mt(e[i].emphasis, a[i]) : e[i].emphasis = a[i], a[i] = null);
    }
}
function li(e, t, r) {
  if (e && e[t] && (e[t].normal || e[t].emphasis)) {
    var n = e[t].normal, i = e[t].emphasis;
    n && (process.env.NODE_ENV !== "production" && ea("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), r ? (e[t].normal = e[t].emphasis = null, ut(e[t], n)) : e[t] = n), i && (process.env.NODE_ENV !== "production" && ea(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), e.emphasis = e.emphasis || {}, e.emphasis[t] = i, i.focus && (e.emphasis.focus = i.focus), i.blurScope && (e.emphasis.blurScope = i.blurScope));
  }
}
function kp(e) {
  li(e, "itemStyle"), li(e, "lineStyle"), li(e, "areaStyle"), li(e, "label"), li(e, "labelLine"), li(e, "upperLabel"), li(e, "edgeLabel");
}
function wn(e, t) {
  var r = qg(e) && e[t], n = qg(r) && r.textStyle;
  if (n) {
    process.env.NODE_ENV !== "production" && ea("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
    for (var i = 0, o = nN.length; i < o; i++) {
      var a = nN[i];
      n.hasOwnProperty(a) && (r[a] = n[a]);
    }
  }
}
function ko(e) {
  e && (kp(e), wn(e, "label"), e.emphasis && wn(e.emphasis, "label"));
}
function Dbe(e) {
  if (qg(e)) {
    I1(e), kp(e), wn(e, "label"), wn(e, "upperLabel"), wn(e, "edgeLabel"), e.emphasis && (wn(e.emphasis, "label"), wn(e.emphasis, "upperLabel"), wn(e.emphasis, "edgeLabel"));
    var t = e.markPoint;
    t && (I1(t), ko(t));
    var r = e.markLine;
    r && (I1(r), ko(r));
    var n = e.markArea;
    n && ko(n);
    var i = e.data;
    if (e.type === "graph") {
      i = i || e.nodes;
      var o = e.links || e.edges;
      if (o && !hi(o))
        for (var a = 0; a < o.length; a++)
          ko(o[a]);
      $(e.categories, function(u) {
        kp(u);
      });
    }
    if (i && !hi(i))
      for (var a = 0; a < i.length; a++)
        ko(i[a]);
    if (t = e.markPoint, t && t.data)
      for (var s = t.data, a = 0; a < s.length; a++)
        ko(s[a]);
    if (r = e.markLine, r && r.data)
      for (var l = r.data, a = 0; a < l.length; a++)
        be(l[a]) ? (ko(l[a][0]), ko(l[a][1])) : ko(l[a]);
    e.type === "gauge" ? (wn(e, "axisLabel"), wn(e, "title"), wn(e, "detail")) : e.type === "treemap" ? (li(e.breadcrumb, "itemStyle"), $(e.levels, function(u) {
      kp(u);
    })) : e.type === "tree" && kp(e.leaves);
  }
}
function Ts(e) {
  return be(e) ? e : e ? [e] : [];
}
function ek(e) {
  return (be(e) ? e[0] : e) || {};
}
function Abe(e, t) {
  Mo(Ts(e.series), function(n) {
    qg(n) && Dbe(n);
  });
  var r = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  t && r.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Mo(r, function(n) {
    Mo(Ts(e[n]), function(i) {
      i && (wn(i, "axisLabel"), wn(i.axisPointer, "label"));
    });
  }), Mo(Ts(e.parallel), function(n) {
    var i = n && n.parallelAxisDefault;
    wn(i, "axisLabel"), wn(i && i.axisPointer, "label");
  }), Mo(Ts(e.calendar), function(n) {
    li(n, "itemStyle"), wn(n, "dayLabel"), wn(n, "monthLabel"), wn(n, "yearLabel");
  }), Mo(Ts(e.radar), function(n) {
    wn(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name, process.env.NODE_ENV !== "production" && ea("name property in radar component has been changed to axisName")), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap, process.env.NODE_ENV !== "production" && ea("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && Mo(n.indicator, function(i) {
      i.text && pn("text", "name", "radar.indicator");
    });
  }), Mo(Ts(e.geo), function(n) {
    qg(n) && (ko(n), Mo(Ts(n.regions), function(i) {
      ko(i);
    }));
  }), Mo(Ts(e.timeline), function(n) {
    ko(n), li(n, "label"), li(n, "itemStyle"), li(n, "controlStyle", !0);
    var i = n.data;
    be(i) && $(i, function(o) {
      lt(o) && (li(o, "label"), li(o, "itemStyle"));
    });
  }), Mo(Ts(e.toolbox), function(n) {
    li(n, "iconStyle"), Mo(n.feature, function(i) {
      li(i, "iconStyle");
    });
  }), wn(ek(e.axisPointer), "label"), wn(ek(e.tooltip).axisPointer, "label");
}
function Ibe(e, t) {
  for (var r = t.split(","), n = e, i = 0; i < r.length && (n = n && n[r[i]], n != null); i++)
    ;
  return n;
}
function Obe(e, t, r, n) {
  for (var i = t.split(","), o = e, a, s = 0; s < i.length - 1; s++)
    a = i[s], o[a] == null && (o[a] = {}), o = o[a];
  o[i[s]] == null && (o[i[s]] = r);
}
function tk(e) {
  e && $(Lbe, function(t) {
    t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]]);
  });
}
var Lbe = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], Fbe = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], O1 = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function ip(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var r = 0; r < O1.length; r++) {
      var n = O1[r][1], i = O1[r][0];
      t[n] != null && (t[i] = t[n], process.env.NODE_ENV !== "production" && pn(n, i));
    }
}
function rk(e) {
  e && e.alignTo === "edge" && e.margin != null && e.edgeDistance == null && (process.env.NODE_ENV !== "production" && pn("label.margin", "label.edgeDistance", "pie"), e.edgeDistance = e.margin);
}
function nk(e) {
  e && e.downplay && !e.blur && (e.blur = e.downplay, process.env.NODE_ENV !== "production" && pn("downplay", "blur", "sunburst"));
}
function Nbe(e) {
  e && e.focusNodeAdjacency != null && (e.emphasis = e.emphasis || {}, e.emphasis.focus == null && (process.env.NODE_ENV !== "production" && pn("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), e.emphasis.focus = "adjacency"));
}
function G7(e, t) {
  if (e)
    for (var r = 0; r < e.length; r++)
      t(e[r]), e[r] && G7(e[r].children, t);
}
function z7(e, t) {
  Abe(e, t), e.series = Tr(e.series), $(e.series, function(r) {
    if (lt(r)) {
      var n = r.type;
      if (n === "line")
        r.clipOverflow != null && (r.clip = r.clipOverflow, process.env.NODE_ENV !== "production" && pn("clipOverflow", "clip", "line"));
      else if (n === "pie" || n === "gauge") {
        r.clockWise != null && (r.clockwise = r.clockWise, process.env.NODE_ENV !== "production" && pn("clockWise", "clockwise")), rk(r.label);
        var i = r.data;
        if (i && !hi(i))
          for (var o = 0; o < i.length; o++)
            rk(i[o]);
        r.hoverOffset != null && (r.emphasis = r.emphasis || {}, (r.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && pn("hoverOffset", "emphasis.scaleSize"), r.emphasis.scaleSize = r.hoverOffset));
      } else if (n === "gauge") {
        var a = Ibe(r, "pointer.color");
        a != null && Obe(r, "itemStyle.color", a);
      } else if (n === "bar") {
        ip(r), ip(r.backgroundStyle), ip(r.emphasis);
        var i = r.data;
        if (i && !hi(i))
          for (var o = 0; o < i.length; o++)
            typeof i[o] == "object" && (ip(i[o]), ip(i[o] && i[o].emphasis));
      } else if (n === "sunburst") {
        var s = r.highlightPolicy;
        s && (r.emphasis = r.emphasis || {}, r.emphasis.focus || (r.emphasis.focus = s, process.env.NODE_ENV !== "production" && pn("highlightPolicy", "emphasis.focus", "sunburst"))), nk(r), G7(r.data, nk);
      } else n === "graph" || n === "sankey" ? Nbe(r) : n === "map" && (r.mapType && !r.map && (process.env.NODE_ENV !== "production" && pn("mapType", "map", "map"), r.map = r.mapType), r.mapLocation && (process.env.NODE_ENV !== "production" && ea("`mapLocation` is not used anymore."), ut(r, r.mapLocation)));
      r.hoverAnimation != null && (r.emphasis = r.emphasis || {}, r.emphasis && r.emphasis.scale == null && (process.env.NODE_ENV !== "production" && pn("hoverAnimation", "emphasis.scale"), r.emphasis.scale = r.hoverAnimation)), tk(r);
    }
  }), e.dataRange && (e.visualMap = e.dataRange), $(Fbe, function(r) {
    var n = e[r];
    n && (be(n) || (n = [n]), $(n, function(i) {
      tk(i);
    }));
  });
}
function kbe(e) {
  var t = nt();
  e.eachSeries(function(r) {
    var n = r.get("stack");
    if (n) {
      var i = t.get(n) || t.set(n, []), o = r.getData(), a = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: o.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: o.getCalculationInfo("stackedOverDimension"),
        stackedDimension: o.getCalculationInfo("stackedDimension"),
        stackedByDimension: o.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: o.getCalculationInfo("isStackedByIndex"),
        data: o,
        seriesModel: r
      };
      if (!a.stackedDimension || !(a.isStackedByIndex || a.stackedByDimension))
        return;
      i.length && o.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(a);
    }
  }), t.each(Vbe);
}
function Vbe(e) {
  $(e, function(t, r) {
    var n = [], i = [NaN, NaN], o = [t.stackResultDimension, t.stackedOverDimension], a = t.data, s = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
    a.modify(o, function(u, c, d) {
      var h = a.get(t.stackedDimension, d);
      if (isNaN(h))
        return i;
      var f, p;
      s ? p = a.getRawIndex(d) : f = a.get(t.stackedByDimension, d);
      for (var g = NaN, v = r - 1; v >= 0; v--) {
        var m = e[v];
        if (s || (p = m.data.rawIndexOf(m.stackedByDimension, f)), p >= 0) {
          var y = m.data.getByRawIndex(m.stackResultDimension, p);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && h >= 0 && y > 0 || l === "samesign" && h <= 0 && y < 0) {
            h = TCe(h, y), g = y;
            break;
          }
        }
      }
      return n[0] = h, n[1] = g, n;
    });
  });
}
var vw = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.data = t.data || (t.sourceFormat === Ss ? {} : []), this.sourceFormat = t.sourceFormat || F7, this.seriesLayoutBy = t.seriesLayoutBy || cs, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var r = this.dimensionsDefine = t.dimensionsDefine;
      if (r)
        for (var n = 0; n < r.length; n++) {
          var i = r[n];
          i.type == null && V7(this, n) === Xn.Must && (i.type = "ordinal");
        }
    }
    return e;
  }()
);
function RD(e) {
  return e instanceof vw;
}
function Y_(e, t, r) {
  r = r || W7(e);
  var n = t.seriesLayoutBy, i = $be(e, r, n, t.sourceHeader, t.dimensions), o = new vw({
    data: e,
    sourceFormat: r,
    seriesLayoutBy: n,
    dimensionsDefine: i.dimensionsDefine,
    startIndex: i.startIndex,
    dimensionsDetectedCount: i.dimensionsDetectedCount,
    metaRawOption: dt(t)
  });
  return o;
}
function _D(e) {
  return new vw({
    data: e,
    sourceFormat: hi(e) ? zs : oa
  });
}
function Bbe(e) {
  return new vw({
    data: e.data,
    sourceFormat: e.sourceFormat,
    seriesLayoutBy: e.seriesLayoutBy,
    dimensionsDefine: dt(e.dimensionsDefine),
    startIndex: e.startIndex,
    dimensionsDetectedCount: e.dimensionsDetectedCount
  });
}
function W7(e) {
  var t = F7;
  if (hi(e))
    t = zs;
  else if (be(e)) {
    e.length === 0 && (t = fi);
    for (var r = 0, n = e.length; r < n; r++) {
      var i = e[r];
      if (i != null) {
        if (be(i) || hi(i)) {
          t = fi;
          break;
        } else if (lt(i)) {
          t = aa;
          break;
        }
      }
    }
  } else if (lt(e)) {
    for (var o in e)
      if (Ye(e, o) && Jn(e[o])) {
        t = Ss;
        break;
      }
  }
  return t;
}
function $be(e, t, r, n, i) {
  var o, a;
  if (!e)
    return {
      dimensionsDefine: ik(i),
      startIndex: a,
      dimensionsDetectedCount: o
    };
  if (t === fi) {
    var s = e;
    n === "auto" || n == null ? ok(function(u) {
      u != null && u !== "-" && (He(u) ? a == null && (a = 1) : a = 0);
    }, r, s, 10) : a = sr(n) ? n : n ? 1 : 0, !i && a === 1 && (i = [], ok(function(u, c) {
      i[c] = u != null ? u + "" : "";
    }, r, s, 1 / 0)), o = i ? i.length : r === xf ? s.length : s[0] ? s[0].length : null;
  } else if (t === aa)
    i || (i = Hbe(e));
  else if (t === Ss)
    i || (i = [], $(e, function(u, c) {
      i.push(c);
    }));
  else if (t === oa) {
    var l = pf(e[0]);
    o = be(l) && l.length || 1;
  } else t === zs && process.env.NODE_ENV !== "production" && ct(!!i, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: a,
    dimensionsDefine: ik(i),
    dimensionsDetectedCount: o
  };
}
function Hbe(e) {
  for (var t = 0, r; t < e.length && !(r = e[t++]); )
    ;
  if (r)
    return jt(r);
}
function ik(e) {
  if (e) {
    var t = nt();
    return Ee(e, function(r, n) {
      r = lt(r) ? r : {
        name: r
      };
      var i = {
        name: r.name,
        displayName: r.displayName,
        type: r.type
      };
      if (i.name == null)
        return i;
      i.name += "", i.displayName == null && (i.displayName = i.name);
      var o = t.get(i.name);
      return o ? i.name += "-" + o.count++ : t.set(i.name, {
        count: 1
      }), i;
    });
  }
}
function ok(e, t, r, n) {
  if (t === xf)
    for (var i = 0; i < r.length && i < n; i++)
      e(r[i] ? r[i][0] : null, i);
  else
    for (var o = r[0] || [], i = 0; i < o.length && i < n; i++)
      e(o[i], i);
}
function j7(e) {
  var t = e.sourceFormat;
  return t === aa || t === Ss;
}
var Gu, zu, Wu, ak, sk, U7 = (
  /** @class */
  function() {
    function e(t, r) {
      var n = RD(t) ? t : _D(t);
      this._source = n;
      var i = this._data = n.data;
      if (n.sourceFormat === zs) {
        if (process.env.NODE_ENV !== "production" && r == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = r, this._data = i;
      }
      sk(this, i, n);
    }
    return e.prototype.getSource = function() {
      return this._source;
    }, e.prototype.count = function() {
      return 0;
    }, e.prototype.getItem = function(t, r) {
    }, e.prototype.appendData = function(t) {
    }, e.prototype.clean = function() {
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.pure = !1, t.persistent = !0;
    }(), e.internalField = function() {
      var t;
      sk = function(a, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, d = l.startIndex, h = l.dimensionsDefine, f = ak[TD(u, c)];
        if (process.env.NODE_ENV !== "production" && ct(f, "Invalide sourceFormat: " + u), ge(a, f), u === zs)
          a.getItem = r, a.count = i, a.fillStorage = n;
        else {
          var p = K7(u, c);
          a.getItem = je(p, null, s, d, h);
          var g = Y7(u, c);
          a.count = je(g, null, s, d, h);
        }
      };
      var r = function(a, s) {
        a = a - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * a, d = 0; d < u; d++)
          s[d] = l[c + d];
        return s;
      }, n = function(a, s, l, u) {
        for (var c = this._data, d = this._dimSize, h = 0; h < d; h++) {
          for (var f = u[h], p = f[0] == null ? 1 / 0 : f[0], g = f[1] == null ? -1 / 0 : f[1], v = s - a, m = l[h], y = 0; y < v; y++) {
            var C = c[y * d + h];
            m[a + y] = C, C < p && (p = C), C > g && (g = C);
          }
          f[0] = p, f[1] = g;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      ak = (t = {}, t[fi + "_" + cs] = {
        pure: !0,
        appendData: o
      }, t[fi + "_" + xf] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[aa] = {
        pure: !0,
        appendData: o
      }, t[Ss] = {
        pure: !0,
        appendData: function(a) {
          var s = this._data;
          $(a, function(l, u) {
            for (var c = s[u] || (s[u] = []), d = 0; d < (l || []).length; d++)
              c.push(l[d]);
          });
        }
      }, t[oa] = {
        appendData: o
      }, t[zs] = {
        persistent: !1,
        pure: !0,
        appendData: function(a) {
          process.env.NODE_ENV !== "production" && ct(hi(a), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = a;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function o(a) {
        for (var s = 0; s < a.length; s++)
          this._data.push(a[s]);
      }
    }(), e;
  }()
), lk = function(e, t, r, n) {
  return e[n];
}, Gbe = (Gu = {}, Gu[fi + "_" + cs] = function(e, t, r, n) {
  return e[n + t];
}, Gu[fi + "_" + xf] = function(e, t, r, n, i) {
  n += t;
  for (var o = i || [], a = e, s = 0; s < a.length; s++) {
    var l = a[s];
    o[s] = l ? l[n] : null;
  }
  return o;
}, Gu[aa] = lk, Gu[Ss] = function(e, t, r, n, i) {
  for (var o = i || [], a = 0; a < r.length; a++) {
    var s = r[a].name;
    if (process.env.NODE_ENV !== "production" && s == null)
      throw new Error();
    var l = e[s];
    o[a] = l ? l[n] : null;
  }
  return o;
}, Gu[oa] = lk, Gu);
function K7(e, t) {
  var r = Gbe[TD(e, t)];
  return process.env.NODE_ENV !== "production" && ct(r, 'Do not support get item on "' + e + '", "' + t + '".'), r;
}
var uk = function(e, t, r) {
  return e.length;
}, zbe = (zu = {}, zu[fi + "_" + cs] = function(e, t, r) {
  return Math.max(0, e.length - t);
}, zu[fi + "_" + xf] = function(e, t, r) {
  var n = e[0];
  return n ? Math.max(0, n.length - t) : 0;
}, zu[aa] = uk, zu[Ss] = function(e, t, r) {
  var n = r[0].name;
  if (process.env.NODE_ENV !== "production" && n == null)
    throw new Error();
  var i = e[n];
  return i ? i.length : 0;
}, zu[oa] = uk, zu);
function Y7(e, t) {
  var r = zbe[TD(e, t)];
  return process.env.NODE_ENV !== "production" && ct(r, 'Do not support count on "' + e + '", "' + t + '".'), r;
}
var L1 = function(e, t, r) {
  return e[t];
}, Wbe = (Wu = {}, Wu[fi] = L1, Wu[aa] = function(e, t, r) {
  return e[r];
}, Wu[Ss] = L1, Wu[oa] = function(e, t, r) {
  var n = pf(e);
  return n instanceof Array ? n[t] : n;
}, Wu[zs] = L1, Wu);
function q7(e) {
  var t = Wbe[e];
  return process.env.NODE_ENV !== "production" && ct(t, 'Do not support get value on "' + e + '".'), t;
}
function TD(e, t) {
  return e === fi ? e + "_" + t : e;
}
function Kh(e, t, r) {
  if (e) {
    var n = e.getRawDataItem(t);
    if (n != null) {
      var i = e.getStore(), o = i.getSource().sourceFormat;
      if (r != null) {
        var a = e.getDimensionIndex(r), s = i.getDimensionProperty(a);
        return q7(o)(n, a, s);
      } else {
        var l = n;
        return o === oa && (l = pf(n)), l;
      }
    }
  }
}
var jbe = /\{@(.+?)\}/g, mw = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getDataParams = function(t, r) {
      var n = this.getData(r), i = this.getRawValue(t, r), o = n.getRawIndex(t), a = n.getName(t), s = n.getRawDataItem(t), l = n.getItemVisual(t, "style"), u = l && l[n.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, d = this.mainType, h = d === "series", f = n.userOutput && n.userOutput.get();
      return {
        componentType: d,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: h ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: h ? this.id : null,
        seriesName: h ? this.name : null,
        name: a,
        dataIndex: o,
        data: s,
        dataType: r,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: f ? f.fullDimensions : null,
        encode: f ? f.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, e.prototype.getFormattedLabel = function(t, r, n, i, o, a) {
      r = r || "normal";
      var s = this.getData(n), l = this.getDataParams(t, n);
      if (a && (l.value = a.interpolatedValue), i != null && be(l.value) && (l.value = l.value[i]), !o) {
        var u = s.getItemModel(t);
        o = u.get(r === "normal" ? ["label", "formatter"] : [r, "label", "formatter"]);
      }
      if (at(o))
        return l.status = r, l.dimensionIndex = i, o(l);
      if (He(o)) {
        var c = CD(o, l);
        return c.replace(jbe, function(d, h) {
          var f = h.length, p = h;
          p.charAt(0) === "[" && p.charAt(f - 1) === "]" && (p = +p.slice(1, f - 1), process.env.NODE_ENV !== "production" && isNaN(p) && ei("Invalide label formatter: @" + h + ", only support @[0], @[1], @[2], ..."));
          var g = Kh(s, t, p);
          if (a && be(a.interpolatedValue)) {
            var v = s.getDimensionIndex(p);
            v >= 0 && (g = a.interpolatedValue[v]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, e.prototype.getRawValue = function(t, r) {
      return Kh(this.getData(r), t);
    }, e.prototype.formatTooltip = function(t, r, n) {
    }, e;
  }()
);
function ck(e) {
  var t, r;
  return lt(e) ? e.type ? r = e : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + Ai(e)) : t = e, {
    text: t,
    // markers: markers || markersExisting,
    frag: r
  };
}
function hg(e) {
  return new Ube(e);
}
var Ube = (
  /** @class */
  function() {
    function e(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
    }
    return e.prototype.perform = function(t) {
      var r = this._upstream, n = t && t.skip;
      if (this._dirty && r) {
        var i = this.context;
        i.data = i.outputData = r.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var o;
      this._plan && !n && (o = this._plan(this.context));
      var a = c(this._modBy), s = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (a !== l || s !== u) && (o = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var d;
      (this._dirty || o === "reset") && (this._dirty = !1, d = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var h = t && t.step;
      if (r ? (process.env.NODE_ENV !== "production" && ct(r._outputDueEnd != null), this._dueEnd = r._outputDueEnd) : (process.env.NODE_ENV !== "production" && ct(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var f = this._dueIndex, p = Math.min(h != null ? this._dueIndex + h : 1 / 0, this._dueEnd);
        if (!n && (d || f < p)) {
          var g = this._progress;
          if (be(g))
            for (var v = 0; v < g.length; v++)
              this._doProgress(g[v], f, p, l, u);
          else
            this._doProgress(g, f, p, l, u);
        }
        this._dueIndex = p;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        process.env.NODE_ENV !== "production" && ct(m >= this._outputDueEnd), this._outputDueEnd = m;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, e.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, e.prototype._doProgress = function(t, r, n, i, o) {
      dk.reset(r, n, i, o), this._callingProgress = t, this._callingProgress({
        start: r,
        end: n,
        count: n - r,
        next: dk.next
      }, this.context);
    }, e.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var r, n;
      !t && this._reset && (r = this._reset(this.context), r && r.progress && (n = r.forceFirstProgress, r = r.progress), be(r) && !r.length && (r = null)), this._progress = r, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), n;
    }, e.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, e.prototype.pipe = function(t) {
      process.env.NODE_ENV !== "production" && ct(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, e.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, e.prototype.getUpstream = function() {
      return this._upstream;
    }, e.prototype.getDownstream = function() {
      return this._downstream;
    }, e.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, e;
  }()
), dk = /* @__PURE__ */ function() {
  var e, t, r, n, i, o = {
    reset: function(l, u, c, d) {
      t = l, e = u, r = c, n = d, i = Math.ceil(n / r), o.next = r > 1 && n > 0 ? s : a;
    }
  };
  return o;
  function a() {
    return t < e ? t++ : null;
  }
  function s() {
    var l = t % i * r + Math.ceil(t / i), u = t >= e ? null : l < n ? l : t;
    return t++, u;
  }
}();
function jl(e, t) {
  var r = t && t.type;
  return r === "ordinal" ? e : (r === "time" && !sr(e) && e != null && e !== "-" && (e = +bo(e)), e == null || e === "" ? NaN : Number(e));
}
var Kbe = nt({
  number: function(e) {
    return parseFloat(e);
  },
  time: function(e) {
    return +bo(e);
  },
  trim: function(e) {
    return He(e) ? Wo(e) : e;
  }
});
function X7(e) {
  return Kbe.get(e);
}
var Z7 = {
  lt: function(e, t) {
    return e < t;
  },
  lte: function(e, t) {
    return e <= t;
  },
  gt: function(e, t) {
    return e > t;
  },
  gte: function(e, t) {
    return e >= t;
  }
}, Ybe = (
  /** @class */
  function() {
    function e(t, r) {
      if (!sr(r)) {
        var n = "";
        process.env.NODE_ENV !== "production" && (n = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'), mr(n);
      }
      this._opFn = Z7[t], this._rvalFloat = vs(r);
    }
    return e.prototype.evaluate = function(t) {
      return sr(t) ? this._opFn(t, this._rvalFloat) : this._opFn(vs(t), this._rvalFloat);
    }, e;
  }()
), Q7 = (
  /** @class */
  function() {
    function e(t, r) {
      var n = t === "desc";
      this._resultLT = n ? 1 : -1, r == null && (r = n ? "min" : "max"), this._incomparable = r === "min" ? -1 / 0 : 1 / 0;
    }
    return e.prototype.evaluate = function(t, r) {
      var n = sr(t) ? t : vs(t), i = sr(r) ? r : vs(r), o = isNaN(n), a = isNaN(i);
      if (o && (n = this._incomparable), a && (i = this._incomparable), o && a) {
        var s = He(t), l = He(r);
        s && (n = l ? t : 0), l && (i = s ? r : 0);
      }
      return n < i ? this._resultLT : n > i ? -this._resultLT : 0;
    }, e;
  }()
), qbe = (
  /** @class */
  function() {
    function e(t, r) {
      this._rval = r, this._isEQ = t, this._rvalTypeof = typeof r, this._rvalFloat = vs(r);
    }
    return e.prototype.evaluate = function(t) {
      var r = t === this._rval;
      if (!r) {
        var n = typeof t;
        n !== this._rvalTypeof && (n === "number" || this._rvalTypeof === "number") && (r = vs(t) === this._rvalFloat);
      }
      return this._isEQ ? r : !r;
    }, e;
  }()
);
function Xbe(e, t) {
  return e === "eq" || e === "ne" ? new qbe(e === "eq", t) : Ye(Z7, e) ? new Ybe(e, t) : null;
}
var Zbe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getRawData = function() {
      throw new Error("not supported");
    }, e.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, e.prototype.cloneRawData = function() {
    }, e.prototype.getDimensionInfo = function(t) {
    }, e.prototype.cloneAllDimensionInfo = function() {
    }, e.prototype.count = function() {
    }, e.prototype.retrieveValue = function(t, r) {
    }, e.prototype.retrieveValueFromItem = function(t, r) {
    }, e.prototype.convertValue = function(t, r) {
      return jl(t, r);
    }, e;
  }()
);
function Qbe(e, t) {
  var r = new Zbe(), n = e.data, i = r.sourceFormat = e.sourceFormat, o = e.startIndex, a = "";
  e.seriesLayoutBy !== cs && (process.env.NODE_ENV !== "production" && (a = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), mr(a));
  var s = [], l = {}, u = e.dimensionsDefine;
  if (u)
    $(u, function(g, v) {
      var m = g.name, y = {
        index: v,
        name: m,
        displayName: g.displayName
      };
      if (s.push(y), m != null) {
        var C = "";
        Ye(l, m) && (process.env.NODE_ENV !== "production" && (C = 'dimension name "' + m + '" duplicated.'), mr(C)), l[m] = y;
      }
    });
  else
    for (var c = 0; c < e.dimensionsDetectedCount; c++)
      s.push({
        index: c
      });
  var d = K7(i, cs);
  t.__isBuiltIn && (r.getRawDataItem = function(g) {
    return d(n, o, s, g);
  }, r.getRawData = je(Jbe, null, e)), r.cloneRawData = je(e1e, null, e);
  var h = Y7(i, cs);
  r.count = je(h, null, n, o, s);
  var f = q7(i);
  r.retrieveValue = function(g, v) {
    var m = d(n, o, s, g);
    return p(m, v);
  };
  var p = r.retrieveValueFromItem = function(g, v) {
    if (g != null) {
      var m = s[v];
      if (m)
        return f(g, v, m.name);
    }
  };
  return r.getDimensionInfo = je(t1e, null, s, l), r.cloneAllDimensionInfo = je(r1e, null, s), r;
}
function Jbe(e) {
  var t = e.sourceFormat;
  if (!PD(t)) {
    var r = "";
    process.env.NODE_ENV !== "production" && (r = "`getRawData` is not supported in source format " + t), mr(r);
  }
  return e.data;
}
function e1e(e) {
  var t = e.sourceFormat, r = e.data;
  if (!PD(t)) {
    var n = "";
    process.env.NODE_ENV !== "production" && (n = "`cloneRawData` is not supported in source format " + t), mr(n);
  }
  if (t === fi) {
    for (var i = [], o = 0, a = r.length; o < a; o++)
      i.push(r[o].slice());
    return i;
  } else if (t === aa) {
    for (var i = [], o = 0, a = r.length; o < a; o++)
      i.push(ge({}, r[o]));
    return i;
  }
}
function t1e(e, t, r) {
  if (r != null) {
    if (sr(r) || !isNaN(r) && !Ye(t, r))
      return e[r];
    if (Ye(t, r))
      return t[r];
  }
}
function r1e(e) {
  return dt(e);
}
var J7 = nt();
function n1e(e) {
  e = dt(e);
  var t = e.type, r = "";
  t || (process.env.NODE_ENV !== "production" && (r = "Must have a `type` when `registerTransform`."), mr(r));
  var n = t.split(":");
  n.length !== 2 && (process.env.NODE_ENV !== "production" && (r = 'Name must include namespace like "ns:regression".'), mr(r));
  var i = !1;
  n[0] === "echarts" && (t = n[1], i = !0), e.__isBuiltIn = i, J7.set(t, e);
}
function i1e(e, t, r) {
  var n = Tr(e), i = n.length, o = "";
  i || (process.env.NODE_ENV !== "production" && (o = "If `transform` declared, it should at least contain one transform."), mr(o));
  for (var a = 0, s = i; a < s; a++) {
    var l = n[a];
    t = o1e(l, t, r, i === 1 ? null : a), a !== s - 1 && (t.length = Math.max(t.length, 1));
  }
  return t;
}
function o1e(e, t, r, n) {
  var i = "";
  t.length || (process.env.NODE_ENV !== "production" && (i = "Must have at least one upstream dataset."), mr(i)), lt(e) || (process.env.NODE_ENV !== "production" && (i = "transform declaration must be an object rather than " + typeof e + "."), mr(i));
  var o = e.type, a = J7.get(o);
  a || (process.env.NODE_ENV !== "production" && (i = 'Can not find transform on type "' + o + '".'), mr(i));
  var s = Ee(t, function(c) {
    return Qbe(c, a);
  }), l = Tr(a.transform({
    upstream: s[0],
    upstreamList: s,
    config: dt(e.config)
  }));
  if (process.env.NODE_ENV !== "production" && e.print) {
    var u = Ee(l, function(c) {
      var d = n != null ? " === pipe index: " + n : "";
      return ["=== dataset index: " + r.datasetIndex + d + " ===", "- transform result data:", Ai(c.data), "- transform result dimensions:", Ai(c.dimensions)].join(`
`);
    }).join(`
`);
    ACe(u);
  }
  return Ee(l, function(c, d) {
    var h = "";
    lt(c) || (process.env.NODE_ENV !== "production" && (h = "A transform should not return some empty results."), mr(h)), c.data || (process.env.NODE_ENV !== "production" && (h = "Transform result data should be not be null or undefined"), mr(h));
    var f = W7(c.data);
    PD(f) || (process.env.NODE_ENV !== "production" && (h = "Transform result data should be array rows or object rows."), mr(h));
    var p, g = t[0];
    if (g && d === 0 && !c.dimensions) {
      var v = g.startIndex;
      v && (c.data = g.data.slice(0, v).concat(c.data)), p = {
        seriesLayoutBy: cs,
        sourceHeader: v,
        dimensions: g.metaRawOption.dimensions
      };
    } else
      p = {
        seriesLayoutBy: cs,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return Y_(c.data, p, null);
  });
}
function PD(e) {
  return e === fi || e === aa;
}
var yw = "undefined", a1e = typeof Uint32Array === yw ? Array : Uint32Array, s1e = typeof Uint16Array === yw ? Array : Uint16Array, e9 = typeof Int32Array === yw ? Array : Int32Array, hk = typeof Float64Array === yw ? Array : Float64Array, t9 = {
  float: hk,
  int: e9,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: hk
}, F1;
function op(e) {
  return e > 65535 ? a1e : s1e;
}
function Vd() {
  return [1 / 0, -1 / 0];
}
function l1e(e) {
  var t = e.constructor;
  return t === Array ? e.slice() : new t(e);
}
function fk(e, t, r, n, i) {
  var o = t9[r || "float"];
  if (i) {
    var a = e[t], s = a && a.length;
    if (s !== n) {
      for (var l = new o(n), u = 0; u < s; u++)
        l[u] = a[u];
      e[t] = l;
    }
  } else
    e[t] = new o(n);
}
var q_ = (
  /** @class */
  function() {
    function e() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = nt();
    }
    return e.prototype.initData = function(t, r, n) {
      process.env.NODE_ENV !== "production" && ct(at(t.getItem) && at(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = t.getSource(), o = this.defaultDimValueGetter = F1[i.sourceFormat];
      this._dimValueGetter = n || o, this._rawExtent = [];
      var a = j7(i);
      this._dimensions = Ee(r, function(s) {
        return process.env.NODE_ENV !== "production" && a && ct(s.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, e.prototype.getProvider = function() {
      return this._provider;
    }, e.prototype.getSource = function() {
      return this._provider.getSource();
    }, e.prototype.ensureCalculationDimension = function(t, r) {
      var n = this._calcDimNameToIdx, i = this._dimensions, o = n.get(t);
      if (o != null) {
        if (i[o].type === r)
          return o;
      } else
        o = i.length;
      return i[o] = {
        type: r
      }, n.set(t, o), this._chunks[o] = new t9[r || "float"](this._rawCount), this._rawExtent[o] = Vd(), o;
    }, e.prototype.collectOrdinalMeta = function(t, r) {
      var n = this._chunks[t], i = this._dimensions[t], o = this._rawExtent, a = i.ordinalOffset || 0, s = n.length;
      a === 0 && (o[t] = Vd());
      for (var l = o[t], u = a; u < s; u++) {
        var c = n[u] = r.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = r, i.ordinalOffset = s, i.type = "ordinal";
    }, e.prototype.getOrdinalMeta = function(t) {
      var r = this._dimensions[t], n = r.ordinalMeta;
      return n;
    }, e.prototype.getDimensionProperty = function(t) {
      var r = this._dimensions[t];
      return r && r.property;
    }, e.prototype.appendData = function(t) {
      process.env.NODE_ENV !== "production" && ct(!this._indices, "appendData can only be called on raw data.");
      var r = this._provider, n = this.count();
      r.appendData(t);
      var i = r.count();
      return r.persistent || (i += n), n < i && this._initDataFromProvider(n, i, !0), [n, i];
    }, e.prototype.appendValues = function(t, r) {
      for (var n = this._chunks, i = this._dimensions, o = i.length, a = this._rawExtent, s = this.count(), l = s + Math.max(t.length, r || 0), u = 0; u < o; u++) {
        var c = i[u];
        fk(n, u, c.type, l, !0);
      }
      for (var d = [], h = s; h < l; h++)
        for (var f = h - s, p = 0; p < o; p++) {
          var c = i[p], g = F1.arrayRows.call(this, t[f] || d, c.property, f, p);
          n[p][h] = g;
          var v = a[p];
          g < v[0] && (v[0] = g), g > v[1] && (v[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, e.prototype._initDataFromProvider = function(t, r, n) {
      for (var i = this._provider, o = this._chunks, a = this._dimensions, s = a.length, l = this._rawExtent, u = Ee(a, function(y) {
        return y.property;
      }), c = 0; c < s; c++) {
        var d = a[c];
        l[c] || (l[c] = Vd()), fk(o, c, d.type, r, n);
      }
      if (i.fillStorage)
        i.fillStorage(t, r, o, l);
      else
        for (var h = [], f = t; f < r; f++) {
          h = i.getItem(f, h);
          for (var p = 0; p < s; p++) {
            var g = o[p], v = this._dimValueGetter(h, u[p], f, p);
            g[f] = v;
            var m = l[p];
            v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = r, this._extent = [];
    }, e.prototype.count = function() {
      return this._count;
    }, e.prototype.get = function(t, r) {
      if (!(r >= 0 && r < this._count))
        return NaN;
      var n = this._chunks[t];
      return n ? n[this.getRawIndex(r)] : NaN;
    }, e.prototype.getValues = function(t, r) {
      var n = [], i = [];
      if (r == null) {
        r = t, t = [];
        for (var o = 0; o < this._dimensions.length; o++)
          i.push(o);
      } else
        i = t;
      for (var o = 0, a = i.length; o < a; o++)
        n.push(this.get(i[o], r));
      return n;
    }, e.prototype.getByRawIndex = function(t, r) {
      if (!(r >= 0 && r < this._rawCount))
        return NaN;
      var n = this._chunks[t];
      return n ? n[r] : NaN;
    }, e.prototype.getSum = function(t) {
      var r = this._chunks[t], n = 0;
      if (r)
        for (var i = 0, o = this.count(); i < o; i++) {
          var a = this.get(t, i);
          isNaN(a) || (n += a);
        }
      return n;
    }, e.prototype.getMedian = function(t) {
      var r = [];
      this.each([t], function(o) {
        isNaN(o) || r.push(o);
      });
      var n = r.sort(function(o, a) {
        return o - a;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? n[(i - 1) / 2] : (n[i / 2] + n[i / 2 - 1]) / 2;
    }, e.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0)
        return -1;
      if (!this._indices)
        return t;
      var r = this._indices, n = r[t];
      if (n != null && n < this._count && n === t)
        return t;
      for (var i = 0, o = this._count - 1; i <= o; ) {
        var a = (i + o) / 2 | 0;
        if (r[a] < t)
          i = a + 1;
        else if (r[a] > t)
          o = a - 1;
        else
          return a;
      }
      return -1;
    }, e.prototype.indicesOfNearest = function(t, r, n) {
      var i = this._chunks, o = i[t], a = [];
      if (!o)
        return a;
      n == null && (n = 1 / 0);
      for (var s = 1 / 0, l = -1, u = 0, c = 0, d = this.count(); c < d; c++) {
        var h = this.getRawIndex(c), f = r - o[h], p = Math.abs(f);
        p <= n && ((p < s || p === s && f >= 0 && l < 0) && (s = p, l = f, u = 0), f === l && (a[u++] = c));
      }
      return a.length = u, a;
    }, e.prototype.getIndices = function() {
      var t, r = this._indices;
      if (r) {
        var n = r.constructor, i = this._count;
        if (n === Array) {
          t = new n(i);
          for (var o = 0; o < i; o++)
            t[o] = r[o];
        } else
          t = new n(r.buffer, 0, i);
      } else {
        var n = op(this._rawCount);
        t = new n(this.count());
        for (var o = 0; o < t.length; o++)
          t[o] = o;
      }
      return t;
    }, e.prototype.filter = function(t, r) {
      if (!this._count)
        return this;
      for (var n = this.clone(), i = n.count(), o = op(n._rawCount), a = new o(i), s = [], l = t.length, u = 0, c = t[0], d = n._chunks, h = 0; h < i; h++) {
        var f = void 0, p = n.getRawIndex(h);
        if (l === 0)
          f = r(h);
        else if (l === 1) {
          var g = d[c][p];
          f = r(g, h);
        } else {
          for (var v = 0; v < l; v++)
            s[v] = d[t[v]][p];
          s[v] = h, f = r.apply(null, s);
        }
        f && (a[u++] = p);
      }
      return u < i && (n._indices = a), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, e.prototype.selectRange = function(t) {
      var r = this.clone(), n = r._count;
      if (!n)
        return this;
      var i = jt(t), o = i.length;
      if (!o)
        return this;
      var a = r.count(), s = op(r._rawCount), l = new s(a), u = 0, c = i[0], d = t[c][0], h = t[c][1], f = r._chunks, p = !1;
      if (!r._indices) {
        var g = 0;
        if (o === 1) {
          for (var v = f[i[0]], m = 0; m < n; m++) {
            var y = v[m];
            (y >= d && y <= h || isNaN(y)) && (l[u++] = g), g++;
          }
          p = !0;
        } else if (o === 2) {
          for (var v = f[i[0]], C = f[i[1]], S = t[i[1]][0], b = t[i[1]][1], m = 0; m < n; m++) {
            var y = v[m], w = C[m];
            (y >= d && y <= h || isNaN(y)) && (w >= S && w <= b || isNaN(w)) && (l[u++] = g), g++;
          }
          p = !0;
        }
      }
      if (!p)
        if (o === 1)
          for (var m = 0; m < a; m++) {
            var x = r.getRawIndex(m), y = f[i[0]][x];
            (y >= d && y <= h || isNaN(y)) && (l[u++] = x);
          }
        else
          for (var m = 0; m < a; m++) {
            for (var R = !0, x = r.getRawIndex(m), _ = 0; _ < o; _++) {
              var T = i[_], y = f[T][x];
              (y < t[T][0] || y > t[T][1]) && (R = !1);
            }
            R && (l[u++] = r.getRawIndex(m));
          }
      return u < a && (r._indices = l), r._count = u, r._extent = [], r._updateGetRawIdx(), r;
    }, e.prototype.map = function(t, r) {
      var n = this.clone(t);
      return this._updateDims(n, t, r), n;
    }, e.prototype.modify = function(t, r) {
      this._updateDims(this, t, r);
    }, e.prototype._updateDims = function(t, r, n) {
      for (var i = t._chunks, o = [], a = r.length, s = t.count(), l = [], u = t._rawExtent, c = 0; c < r.length; c++)
        u[r[c]] = Vd();
      for (var d = 0; d < s; d++) {
        for (var h = t.getRawIndex(d), f = 0; f < a; f++)
          l[f] = i[r[f]][h];
        l[a] = d;
        var p = n && n.apply(null, l);
        if (p != null) {
          typeof p != "object" && (o[0] = p, p = o);
          for (var c = 0; c < p.length; c++) {
            var g = r[c], v = p[c], m = u[g], y = i[g];
            y && (y[h] = v), v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      }
    }, e.prototype.lttbDownSample = function(t, r) {
      var n = this.clone([t], !0), i = n._chunks, o = i[t], a = this.count(), s = 0, l = Math.floor(1 / r), u = this.getRawIndex(0), c, d, h, f = new (op(this._rawCount))(Math.min((Math.ceil(a / l) + 2) * 2, a));
      f[s++] = u;
      for (var p = 1; p < a - 1; p += l) {
        for (var g = Math.min(p + l, a - 1), v = Math.min(p + l * 2, a), m = (v + g) / 2, y = 0, C = g; C < v; C++) {
          var S = this.getRawIndex(C), b = o[S];
          isNaN(b) || (y += b);
        }
        y /= v - g;
        var w = p, x = Math.min(p + l, a), R = p - 1, _ = o[u];
        c = -1, h = w;
        for (var T = -1, P = 0, C = w; C < x; C++) {
          var S = this.getRawIndex(C), b = o[S];
          if (isNaN(b)) {
            P++, T < 0 && (T = S);
            continue;
          }
          d = Math.abs((R - m) * (b - _) - (R - C) * (y - _)), d > c && (c = d, h = S);
        }
        P > 0 && P < x - w && (f[s++] = Math.min(T, h), h = Math.max(T, h)), f[s++] = h, u = h;
      }
      return f[s++] = this.getRawIndex(a - 1), n._count = s, n._indices = f, n.getRawIndex = this._getRawIdx, n;
    }, e.prototype.downSample = function(t, r, n, i) {
      for (var o = this.clone([t], !0), a = o._chunks, s = [], l = Math.floor(1 / r), u = a[t], c = this.count(), d = o._rawExtent[t] = Vd(), h = new (op(this._rawCount))(Math.ceil(c / l)), f = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, s.length = l);
        for (var g = 0; g < l; g++) {
          var v = this.getRawIndex(p + g);
          s[g] = u[v];
        }
        var m = n(s), y = this.getRawIndex(Math.min(p + i(s, m) || 0, c - 1));
        u[y] = m, m < d[0] && (d[0] = m), m > d[1] && (d[1] = m), h[f++] = y;
      }
      return o._count = f, o._indices = h, o._updateGetRawIdx(), o;
    }, e.prototype.each = function(t, r) {
      if (this._count)
        for (var n = t.length, i = this._chunks, o = 0, a = this.count(); o < a; o++) {
          var s = this.getRawIndex(o);
          switch (n) {
            case 0:
              r(o);
              break;
            case 1:
              r(i[t[0]][s], o);
              break;
            case 2:
              r(i[t[0]][s], i[t[1]][s], o);
              break;
            default:
              for (var l = 0, u = []; l < n; l++)
                u[l] = i[t[l]][s];
              u[l] = o, r.apply(null, u);
          }
        }
    }, e.prototype.getDataExtent = function(t) {
      var r = this._chunks[t], n = Vd();
      if (!r)
        return n;
      var i = this.count(), o = !this._indices, a;
      if (o)
        return this._rawExtent[t].slice();
      if (a = this._extent[t], a)
        return a.slice();
      a = n;
      for (var s = a[0], l = a[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), d = r[c];
        d < s && (s = d), d > l && (l = d);
      }
      return a = [s, l], this._extent[t] = a, a;
    }, e.prototype.getRawDataItem = function(t) {
      var r = this.getRawIndex(t);
      if (this._provider.persistent)
        return this._provider.getItem(r);
      for (var n = [], i = this._chunks, o = 0; o < i.length; o++)
        n.push(i[o][r]);
      return n;
    }, e.prototype.clone = function(t, r) {
      var n = new e(), i = this._chunks, o = t && Jo(t, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (o)
        for (var a = 0; a < i.length; a++)
          n._chunks[a] = o[a] ? l1e(i[a]) : i[a];
      else
        n._chunks = i;
      return this._copyCommonProps(n), r || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, e.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = dt(this._extent), t._rawExtent = dt(this._rawExtent);
    }, e.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, r = void 0;
        if (t === Array) {
          var n = this._indices.length;
          r = new t(n);
          for (var i = 0; i < n; i++)
            r[i] = this._indices[i];
        } else
          r = new t(this._indices);
        return r;
      }
      return null;
    }, e.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, e.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, e.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, e.internalField = function() {
      function t(r, n, i, o) {
        return jl(r[o], this._dimensions[o]);
      }
      F1 = {
        arrayRows: t,
        objectRows: function(r, n, i, o) {
          return jl(r[n], this._dimensions[o]);
        },
        keyedColumns: t,
        original: function(r, n, i, o) {
          var a = r && (r.value == null ? r : r.value);
          return jl(a instanceof Array ? a[o] : a, this._dimensions[o]);
        },
        typedArray: function(r, n, i, o) {
          return r[o];
        }
      };
    }(), e;
  }()
), r9 = (
  /** @class */
  function() {
    function e(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
    }
    return e.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, e.prototype._setLocalSource = function(t, r) {
      this._sourceList = t, this._upstreamSignList = r, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, e.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, e.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, e.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, r = this._getUpstreamSourceManagers(), n = !!r.length, i, o;
      if (ap(t)) {
        var a = t, s = void 0, l = void 0, u = void 0;
        if (n) {
          var c = r[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, o = [c._getVersionSign()];
        } else
          s = a.get("data", !0), l = hi(s) ? zs : oa, o = [];
        var d = this._getSourceMetaRawOption() || {}, h = u && u.metaRawOption || {}, f = bt(d.seriesLayoutBy, h.seriesLayoutBy) || null, p = bt(d.sourceHeader, h.sourceHeader), g = bt(d.dimensions, h.dimensions), v = f !== h.seriesLayoutBy || !!p != !!h.sourceHeader || g;
        i = v ? [Y_(s, {
          seriesLayoutBy: f,
          sourceHeader: p,
          dimensions: g
        }, l)] : [];
      } else {
        var m = t;
        if (n) {
          var y = this._applyTransform(r);
          i = y.sourceList, o = y.upstreamSignList;
        } else {
          var C = m.get("source", !0);
          i = [Y_(C, this._getSourceMetaRawOption(), null)], o = [];
        }
      }
      process.env.NODE_ENV !== "production" && ct(i && o), this._setLocalSource(i, o);
    }, e.prototype._applyTransform = function(t) {
      var r = this._sourceHost, n = r.get("transform", !0), i = r.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && ct(i != null || n != null), i != null) {
        var o = "";
        t.length !== 1 && (process.env.NODE_ENV !== "production" && (o = "When using `fromTransformResult`, there should be only one upstream dataset"), gk(o));
      }
      var a, s = [], l = [];
      return $(t, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), d = "";
        i != null && !c && (process.env.NODE_ENV !== "production" && (d = "Can not retrieve result by `fromTransformResult`: " + i), gk(d)), s.push(c), l.push(u._getVersionSign());
      }), n ? a = i1e(n, s, {
        datasetIndex: r.componentIndex
      }) : i != null && (a = [Bbe(s[0])]), {
        sourceList: a,
        upstreamSignList: l
      };
    }, e.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var t = this._getUpstreamSourceManagers(), r = 0; r < t.length; r++) {
        var n = t[r];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          n._isDirty() || this._upstreamSignList[r] !== n._getVersionSign()
        )
          return !0;
      }
    }, e.prototype.getSource = function(t) {
      t = t || 0;
      var r = this._sourceList[t];
      if (!r) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(t);
      }
      return r;
    }, e.prototype.getSharedDataStore = function(t) {
      process.env.NODE_ENV !== "production" && ct(ap(this._sourceHost), "Can only call getDataStore on series source manager.");
      var r = t.makeStoreSchema();
      return this._innerGetDataStore(r.dimensions, t.source, r.hash);
    }, e.prototype._innerGetDataStore = function(t, r, n) {
      var i = 0, o = this._storeList, a = o[i];
      a || (a = o[i] = {});
      var s = a[n];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        ap(this._sourceHost) && l ? s = l._innerGetDataStore(t, r, n) : (s = new q_(), s.initData(new U7(r, t.length), t)), a[n] = s;
      }
      return s;
    }, e.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (ap(t)) {
        var r = bD(t);
        return r ? [r.getSourceManager()] : [];
      } else
        return Ee(hbe(t), function(n) {
          return n.getSourceManager();
        });
    }, e.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, r, n, i;
      if (ap(t))
        r = t.get("seriesLayoutBy", !0), n = t.get("sourceHeader", !0), i = t.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var o = t;
        r = o.get("seriesLayoutBy", !0), n = o.get("sourceHeader", !0), i = o.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: r,
        sourceHeader: n,
        dimensions: i
      };
    }, e;
  }()
);
function pk(e) {
  var t = e.option.transform;
  t && kg(e.option.transform);
}
function ap(e) {
  return e.mainType === "series";
}
function gk(e) {
  throw new Error(e);
}
var n9 = "line-height:1";
function i9(e, t) {
  var r = e.color || "#6e7079", n = e.fontSize || 12, i = e.fontWeight || "400", o = e.color || "#464646", a = e.fontSize || 14, s = e.fontWeight || "900";
  return t === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + Ei(n + "") + "px;color:" + Ei(r) + ";font-weight:" + Ei(i + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + Ei(a + "") + "px;color:" + Ei(o) + ";font-weight:" + Ei(s + "")
  } : {
    nameStyle: {
      fontSize: n,
      fill: r,
      fontWeight: i
    },
    valueStyle: {
      fontSize: a,
      fill: o,
      fontWeight: s
    }
  };
}
var u1e = [0, 10, 20, 30], c1e = ["", `
`, `

`, `


`];
function Hn(e, t) {
  return t.type = e, t;
}
function X_(e) {
  return e.type === "section";
}
function o9(e) {
  return X_(e) ? d1e : h1e;
}
function a9(e) {
  if (X_(e)) {
    var t = 0, r = e.blocks.length, n = r > 1 || r > 0 && !e.noHeader;
    return $(e.blocks, function(i) {
      var o = a9(i);
      o >= t && (t = o + +(n && // 0 always can not be readable gap level.
      (!o || X_(i) && !i.noHeader)));
    }), t;
  }
  return 0;
}
function d1e(e, t, r, n) {
  var i = t.noHeader, o = f1e(a9(t)), a = [], s = t.blocks || [];
  ct(!s || be(s)), s = s || [];
  var l = e.orderMode;
  if (t.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (Ye(u, l)) {
      var c = new Q7(u[l], null);
      s.sort(function(p, g) {
        return c.evaluate(p.sortParam, g.sortParam);
      });
    } else l === "seriesDesc" && s.reverse();
  }
  $(s, function(p, g) {
    var v = t.valueFormatter, m = o9(p)(
      // Inherit valueFormatter
      v ? ge(ge({}, e), {
        valueFormatter: v
      }) : e,
      p,
      g > 0 ? o.html : 0,
      n
    );
    m != null && a.push(m);
  });
  var d = e.renderMode === "richText" ? a.join(o.richText) : Z_(a.join(""), i ? r : o.html);
  if (i)
    return d;
  var h = W_(t.header, "ordinal", e.useUTC), f = i9(n, e.renderMode).nameStyle;
  return e.renderMode === "richText" ? s9(e, h, f) + o.richText + d : Z_('<div style="' + f + ";" + n9 + ';">' + Ei(h) + "</div>" + d, r);
}
function h1e(e, t, r, n) {
  var i = e.renderMode, o = t.noName, a = t.noValue, s = !t.markerType, l = t.name, u = e.useUTC, c = t.valueFormatter || e.valueFormatter || function(S) {
    return S = be(S) ? S : [S], Ee(S, function(b, w) {
      return W_(b, be(f) ? f[w] : f, u);
    });
  };
  if (!(o && a)) {
    var d = s ? "" : e.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || "#333", i), h = o ? "" : W_(l, "ordinal", u), f = t.valueType, p = a ? [] : c(t.value, t.dataIndex), g = !s || !o, v = !s && o, m = i9(n, i), y = m.nameStyle, C = m.valueStyle;
    return i === "richText" ? (s ? "" : d) + (o ? "" : s9(e, h, y)) + (a ? "" : v1e(e, p, g, v, C)) : Z_((s ? "" : d) + (o ? "" : p1e(h, !s, y)) + (a ? "" : g1e(p, g, v, C)), r);
  }
}
function vk(e, t, r, n, i, o) {
  if (e) {
    var a = o9(e), s = {
      useUTC: i,
      renderMode: r,
      orderMode: n,
      markupStyleCreator: t,
      valueFormatter: e.valueFormatter
    };
    return a(s, e, 0, o);
  }
}
function f1e(e) {
  return {
    html: u1e[e],
    richText: c1e[e]
  };
}
function Z_(e, t) {
  var r = '<div style="clear:both"></div>', n = "margin: " + t + "px 0 0";
  return '<div style="' + n + ";" + n9 + ';">' + e + r + "</div>";
}
function p1e(e, t, r) {
  var n = t ? "margin-left:2px" : "";
  return '<span style="' + r + ";" + n + '">' + Ei(e) + "</span>";
}
function g1e(e, t, r, n) {
  var i = r ? "10px" : "20px", o = t ? "float:right;margin-left:" + i : "";
  return e = be(e) ? e : [e], '<span style="' + o + ";" + n + '">' + Ee(e, function(a) {
    return Ei(a);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function s9(e, t, r) {
  return e.markupStyleCreator.wrapRichTextStyle(t, r);
}
function v1e(e, t, r, n, i) {
  var o = [i], a = n ? 10 : 20;
  return r && o.push({
    padding: [0, 0, 0, a],
    align: "right"
  }), e.markupStyleCreator.wrapRichTextStyle(be(t) ? t.join("  ") : t, o);
}
function l9(e, t) {
  var r = e.getData().getItemVisual(t, "style"), n = r[e.visualDrawType];
  return Uc(n);
}
function u9(e, t) {
  var r = e.get("padding");
  return r ?? (t === "richText" ? [8, 10] : 10);
}
var N1 = (
  /** @class */
  function() {
    function e() {
      this.richTextStyles = {}, this._nextStyleNameId = gW();
    }
    return e.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, e.prototype.makeTooltipMarker = function(t, r, n) {
      var i = n === "richText" ? this._generateStyleName() : null, o = A7({
        color: r,
        type: t,
        renderMode: n,
        markerId: i
      });
      return He(o) ? o : (process.env.NODE_ENV !== "production" && ct(i), this.richTextStyles[i] = o.style, o.content);
    }, e.prototype.wrapRichTextStyle = function(t, r) {
      var n = {};
      be(r) ? $(r, function(o) {
        return ge(n, o);
      }) : ge(n, r);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = n, "{" + i + "|" + t + "}";
    }, e;
  }()
);
function c9(e) {
  var t = e.series, r = e.dataIndex, n = e.multipleSeries, i = t.getData(), o = i.mapDimensionsAll("defaultedTooltip"), a = o.length, s = t.getRawValue(r), l = be(s), u = l9(t, r), c, d, h, f;
  if (a > 1 || l && !a) {
    var p = m1e(s, t, r, o, u);
    c = p.inlineValues, d = p.inlineValueTypes, h = p.blocks, f = p.inlineValues[0];
  } else if (a) {
    var g = i.getDimensionInfo(o[0]);
    f = c = Kh(i, r, o[0]), d = g.type;
  } else
    f = c = l ? s[0] : s;
  var v = YM(t), m = v && t.name || "", y = i.getName(r), C = n ? m : y;
  return Hn("section", {
    header: m,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: n || !v,
    sortParam: f,
    blocks: [Hn("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: C,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !Wo(C),
      value: c,
      valueType: d,
      dataIndex: r
    })].concat(h || [])
  });
}
function m1e(e, t, r, n, i) {
  var o = t.getData(), a = Jo(e, function(d, h, f) {
    var p = o.getDimensionInfo(f);
    return d = d || p && p.tooltip !== !1 && p.displayName != null;
  }, !1), s = [], l = [], u = [];
  n.length ? $(n, function(d) {
    c(Kh(o, r, d), d);
  }) : $(e, c);
  function c(d, h) {
    var f = o.getDimensionInfo(h);
    !f || f.otherDims.tooltip === !1 || (a ? u.push(Hn("nameValue", {
      markerType: "subItem",
      markerColor: i,
      name: f.displayName,
      value: d,
      valueType: f.type
    })) : (s.push(d), l.push(f.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var yl = ar();
function Zm(e, t) {
  return e.getName(t) || e.getId(t);
}
var f0 = "__universalTransitionEnabled", Pr = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r._selectedDataIndicesMap = {}, r;
    }
    return t.prototype.init = function(r, n, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = hg({
        count: C1e,
        reset: S1e
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(r, i);
      var o = yl(this).sourceManager = new r9(this);
      o.prepareSource();
      var a = this.getInitialData(r, i);
      yk(a, this), this.dataTask.context.data = a, process.env.NODE_ENV !== "production" && ct(a, "getInitialData returned invalid data."), yl(this).dataBeforeProcessed = a, mk(this), this._initSelectedMapFromData(a);
    }, t.prototype.mergeDefaultAndTheme = function(r, n) {
      var i = Yg(this), o = i ? bf(r) : {}, a = this.subType;
      Vt.hasClass(a) && (a += "Series"), Mt(r, n.getTheme().get(this.subType)), Mt(r, this.getDefaultOption()), Gc(r, "label", ["show"]), this.fillDataTextStyle(r.data), i && su(r, o, i);
    }, t.prototype.mergeOption = function(r, n) {
      r = Mt(this.option, r, !0), this.fillDataTextStyle(r.data);
      var i = Yg(this);
      i && su(this.option, r, i);
      var o = yl(this).sourceManager;
      o.dirty(), o.prepareSource();
      var a = this.getInitialData(r, n);
      yk(a, this), this.dataTask.dirty(), this.dataTask.context.data = a, yl(this).dataBeforeProcessed = a, mk(this), this._initSelectedMapFromData(a);
    }, t.prototype.fillDataTextStyle = function(r) {
      if (r && !hi(r))
        for (var n = ["show"], i = 0; i < r.length; i++)
          r[i] && r[i].label && Gc(r[i], "label", n);
    }, t.prototype.getInitialData = function(r, n) {
    }, t.prototype.appendData = function(r) {
      var n = this.getRawData();
      n.appendData(r.data);
    }, t.prototype.getData = function(r) {
      var n = Q_(this);
      if (n) {
        var i = n.context.data;
        return r == null || !i.getLinkedData ? i : i.getLinkedData(r);
      } else
        return yl(this).data;
    }, t.prototype.getAllData = function() {
      var r = this.getData();
      return r && r.getLinkedDataAll ? r.getLinkedDataAll() : [{
        data: r
      }];
    }, t.prototype.setData = function(r) {
      var n = Q_(this);
      if (n) {
        var i = n.context;
        i.outputData = r, n !== this.dataTask && (i.data = r);
      }
      yl(this).data = r;
    }, t.prototype.getEncode = function() {
      var r = this.get("encode", !0);
      if (r)
        return nt(r);
    }, t.prototype.getSourceManager = function() {
      return yl(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return yl(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var r = this.get("colorBy");
      return r || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var r = this.coordinateSystem;
      return r && r.getBaseAxis && r.getBaseAxis();
    }, t.prototype.formatTooltip = function(r, n, i) {
      return c9({
        series: this,
        dataIndex: r,
        multipleSeries: n
      });
    }, t.prototype.isAnimationEnabled = function() {
      var r = this.ecModel;
      if (nr.node && !(r && r.ssr))
        return !1;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(r, n, i) {
      var o = this.ecModel, a = xD.prototype.getColorFromPalette.call(this, r, n, i);
      return a || (a = o.getColorFromPalette(r, n, i)), a;
    }, t.prototype.coordDimToDataDim = function(r) {
      return this.getRawData().mapDimensionsAll(r);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(r, n) {
      this._innerSelect(this.getData(n), r);
    }, t.prototype.unselect = function(r, n) {
      var i = this.option.selectedMap;
      if (i) {
        var o = this.option.selectedMode, a = this.getData(n);
        if (o === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < r.length; s++) {
          var l = r[s], u = Zm(a, l);
          i[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(r, n) {
      for (var i = [], o = 0; o < r.length; o++)
        i[0] = r[o], this.isSelected(r[o], n) ? this.unselect(i, n) : this.select(i, n);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var r = this._selectedDataIndicesMap, n = jt(r), i = [], o = 0; o < n.length; o++) {
        var a = r[n[o]];
        a >= 0 && i.push(a);
      }
      return i;
    }, t.prototype.isSelected = function(r, n) {
      var i = this.option.selectedMap;
      if (!i)
        return !1;
      var o = this.getData(n);
      return (i === "all" || i[Zm(o, r)]) && !o.getItemModel(r).get(["select", "disabled"]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[f0])
        return !0;
      var r = this.option.universalTransition;
      return r ? r === !0 ? !0 : r && r.enabled : !1;
    }, t.prototype._innerSelect = function(r, n) {
      var i, o, a = this.option, s = a.selectedMode, l = n.length;
      if (!(!s || !l)) {
        if (s === "series")
          a.selectedMap = "all";
        else if (s === "multiple") {
          lt(a.selectedMap) || (a.selectedMap = {});
          for (var u = a.selectedMap, c = 0; c < l; c++) {
            var d = n[c], h = Zm(r, d);
            u[h] = !0, this._selectedDataIndicesMap[h] = r.getRawIndex(d);
          }
        } else if (s === "single" || s === !0) {
          var f = n[l - 1], h = Zm(r, f);
          a.selectedMap = (i = {}, i[h] = !0, i), this._selectedDataIndicesMap = (o = {}, o[h] = r.getRawIndex(f), o);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(r) {
      if (!this.option.selectedMap) {
        var n = [];
        r.hasItemOption && r.each(function(i) {
          var o = r.getRawDataItem(i);
          o && o.selected && n.push(i);
        }), n.length > 0 && this._innerSelect(r, n);
      }
    }, t.registerClass = function(r) {
      return Vt.registerClass(r);
    }, t.protoInitialize = function() {
      var r = t.prototype;
      r.type = "series.__base__", r.seriesIndex = 0, r.ignoreStyleOnData = !1, r.hasSymbolVisual = !1, r.defaultSymbol = "circle", r.visualStyleAccessPath = "itemStyle", r.visualDrawType = "fill";
    }(), t;
  }(Vt)
);
cn(Pr, mw);
cn(Pr, xD);
EW(Pr, Vt);
function mk(e) {
  var t = e.name;
  YM(e) || (e.name = y1e(e) || t);
}
function y1e(e) {
  var t = e.getRawData(), r = t.mapDimensionsAll("seriesName"), n = [];
  return $(r, function(i) {
    var o = t.getDimensionInfo(i);
    o.displayName && n.push(o.displayName);
  }), n.join(" ");
}
function C1e(e) {
  return e.model.getRawData().count();
}
function S1e(e) {
  var t = e.model;
  return t.setData(t.getRawData().cloneShallow()), w1e;
}
function w1e(e, t) {
  t.outputData && e.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
}
function yk(e, t) {
  $(Vg(e.CHANGABLE_METHODS, e.DOWNSAMPLE_METHODS), function(r) {
    e.wrapMethod(r, _t(b1e, t));
  });
}
function b1e(e, t) {
  var r = Q_(e);
  return r && r.setOutputEnd((t || this).count()), t;
}
function Q_(e) {
  var t = (e.ecModel || {}).scheduler, r = t && t.getPipeline(e.uid);
  if (r) {
    var n = r.currentTask;
    if (n) {
      var i = n.agentStubMap;
      i && (n = i.get(e.uid));
    }
    return n;
  }
}
var zr = (
  /** @class */
  function() {
    function e() {
      this.group = new Ct(), this.uid = wf("viewComponent");
    }
    return e.prototype.init = function(t, r) {
    }, e.prototype.render = function(t, r, n, i) {
    }, e.prototype.dispose = function(t, r) {
    }, e.prototype.updateView = function(t, r, n, i) {
    }, e.prototype.updateLayout = function(t, r, n, i) {
    }, e.prototype.updateVisual = function(t, r, n, i) {
    }, e.prototype.toggleBlurSeries = function(t, r, n) {
    }, e.prototype.eachRendered = function(t) {
      var r = this.group;
      r && r.traverse(t);
    }, e;
  }()
);
XM(zr);
JS(zr);
function Ef() {
  var e = ar();
  return function(t) {
    var r = e(t), n = t.pipelineContext, i = !!r.large, o = !!r.progressiveRender, a = r.large = !!(n && n.large), s = r.progressiveRender = !!(n && n.progressiveRender);
    return (i !== a || o !== s) && "reset";
  };
}
var d9 = ar(), x1e = Ef(), br = (
  /** @class */
  function() {
    function e() {
      this.group = new Ct(), this.uid = wf("viewChart"), this.renderTask = hg({
        plan: E1e,
        reset: R1e
      }), this.renderTask.context = {
        view: this
      };
    }
    return e.prototype.init = function(t, r) {
    }, e.prototype.render = function(t, r, n, i) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, e.prototype.highlight = function(t, r, n, i) {
      var o = t.getData(i && i.dataType);
      if (!o) {
        process.env.NODE_ENV !== "production" && ei("Unknown dataType " + i.dataType);
        return;
      }
      Sk(o, i, "emphasis");
    }, e.prototype.downplay = function(t, r, n, i) {
      var o = t.getData(i && i.dataType);
      if (!o) {
        process.env.NODE_ENV !== "production" && ei("Unknown dataType " + i.dataType);
        return;
      }
      Sk(o, i, "normal");
    }, e.prototype.remove = function(t, r) {
      this.group.removeAll();
    }, e.prototype.dispose = function(t, r) {
    }, e.prototype.updateView = function(t, r, n, i) {
      this.render(t, r, n, i);
    }, e.prototype.updateLayout = function(t, r, n, i) {
      this.render(t, r, n, i);
    }, e.prototype.updateVisual = function(t, r, n, i) {
      this.render(t, r, n, i);
    }, e.prototype.eachRendered = function(t) {
      Su(this.group, t);
    }, e.markUpdateMethod = function(t, r) {
      d9(t).updateMethod = r;
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "chart";
    }(), e;
  }()
);
function Ck(e, t, r) {
  e && ou(e) && (t === "emphasis" ? Qs : Js)(e, r);
}
function Sk(e, t, r) {
  var n = zc(e, t), i = t && t.highlightKey != null ? rwe(t.highlightKey) : null;
  n != null ? $(Tr(n), function(o) {
    Ck(e.getItemGraphicEl(o), r, i);
  }) : e.eachItemGraphicEl(function(o) {
    Ck(o, r, i);
  });
}
XM(br, ["dispose"]);
JS(br);
function E1e(e) {
  return x1e(e.model);
}
function R1e(e) {
  var t = e.model, r = e.ecModel, n = e.api, i = e.payload, o = t.pipelineContext.progressiveRender, a = e.view, s = i && d9(i).updateMethod, l = o ? "incrementalPrepareRender" : s && a[s] ? s : "render";
  return l !== "render" && a[l](t, r, n, i), _1e[l];
}
var _1e = {
  incrementalPrepareRender: {
    progress: function(e, t) {
      t.view.incrementalRender(e, t.model, t.ecModel, t.api, t.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(e, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload);
    }
  }
}, vC = "\0__throttleOriginMethod", wk = "\0__throttleRate", bk = "\0__throttleType";
function Cw(e, t, r) {
  var n, i = 0, o = 0, a = null, s, l, u, c;
  t = t || 0;
  function d() {
    o = (/* @__PURE__ */ new Date()).getTime(), a = null, e.apply(l, u || []);
  }
  var h = function() {
    for (var f = [], p = 0; p < arguments.length; p++)
      f[p] = arguments[p];
    n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = f;
    var g = c || t, v = c || r;
    c = null, s = n - (v ? i : o) - g, clearTimeout(a), v ? a = setTimeout(d, g) : s >= 0 ? d() : a = setTimeout(d, -s), i = n;
  };
  return h.clear = function() {
    a && (clearTimeout(a), a = null);
  }, h.debounceNextCall = function(f) {
    c = f;
  }, h;
}
function Rf(e, t, r, n) {
  var i = e[t];
  if (i) {
    var o = i[vC] || i, a = i[bk], s = i[wk];
    if (s !== r || a !== n) {
      if (r == null || !n)
        return e[t] = o;
      i = e[t] = Cw(o, r, n === "debounce"), i[vC] = o, i[bk] = n, i[wk] = r;
    }
    return i;
  }
}
function Xg(e, t) {
  var r = e[t];
  r && r[vC] && (r.clear && r.clear(), e[t] = r[vC]);
}
var xk = ar(), Ek = {
  itemStyle: Wc(w7, !0),
  lineStyle: Wc(S7, !0)
}, T1e = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function h9(e, t) {
  var r = e.visualStyleMapper || Ek[t];
  return r || (console.warn("Unknown style type '" + t + "'."), Ek.itemStyle);
}
function f9(e, t) {
  var r = e.visualDrawType || T1e[t];
  return r || (console.warn("Unknown style type '" + t + "'."), "fill");
}
var P1e = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    var r = e.getData(), n = e.visualStyleAccessPath || "itemStyle", i = e.getModel(n), o = h9(e, n), a = o(i), s = i.getShallow("decal");
    s && (r.setVisual("decal", s), s.dirty = !0);
    var l = f9(e, n), u = a[l], c = at(u) ? u : null, d = a.fill === "auto" || a.stroke === "auto";
    if (!a[l] || c || d) {
      var h = e.getColorFromPalette(
        // TODO series count changed.
        e.name,
        null,
        t.getSeriesCount()
      );
      a[l] || (a[l] = h, r.setVisual("colorFromPalette", !0)), a.fill = a.fill === "auto" || at(a.fill) ? h : a.fill, a.stroke = a.stroke === "auto" || at(a.stroke) ? h : a.stroke;
    }
    if (r.setVisual("style", a), r.setVisual("drawType", l), !t.isSeriesFiltered(e) && c)
      return r.setVisual("colorFromPalette", !1), {
        dataEach: function(f, p) {
          var g = e.getDataParams(p), v = ge({}, a);
          v[l] = c(g), f.setItemVisual(p, "style", v);
        }
      };
  }
}, sp = new _r(), M1e = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    if (!(e.ignoreStyleOnData || t.isSeriesFiltered(e))) {
      var r = e.getData(), n = e.visualStyleAccessPath || "itemStyle", i = h9(e, n), o = r.getVisual("drawType");
      return {
        dataEach: r.hasItemOption ? function(a, s) {
          var l = a.getRawDataItem(s);
          if (l && l[n]) {
            sp.option = l[n];
            var u = i(sp), c = a.ensureUniqueItemVisual(s, "style");
            ge(c, u), sp.option.decal && (a.setItemVisual(s, "decal", sp.option.decal), sp.option.decal.dirty = !0), o in u && a.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, D1e = {
  performRawSeries: !0,
  overallReset: function(e) {
    var t = nt();
    e.eachSeries(function(r) {
      var n = r.getColorBy();
      if (!r.isColorBySeries()) {
        var i = r.type + "-" + n, o = t.get(i);
        o || (o = {}, t.set(i, o)), xk(r).scope = o;
      }
    }), e.eachSeries(function(r) {
      if (!(r.isColorBySeries() || e.isSeriesFiltered(r))) {
        var n = r.getRawData(), i = {}, o = r.getData(), a = xk(r).scope, s = r.visualStyleAccessPath || "itemStyle", l = f9(r, s);
        o.each(function(u) {
          var c = o.getRawIndex(u);
          i[c] = u;
        }), n.each(function(u) {
          var c = i[u], d = o.getItemVisual(c, "colorFromPalette");
          if (d) {
            var h = o.ensureUniqueItemVisual(c, "style"), f = n.getName(u) || u + "", p = n.count();
            h[l] = r.getColorFromPalette(f, a, p);
          }
        });
      }
    });
  }
}, Qm = Math.PI;
function A1e(e, t) {
  t = t || {}, ut(t, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: !0,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var r = new Ct(), n = new or({
    style: {
      fill: t.maskColor
    },
    zlevel: t.zlevel,
    z: 1e4
  });
  r.add(n);
  var i = new ir({
    style: {
      text: t.text,
      fill: t.textColor,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      fontStyle: t.fontStyle,
      fontFamily: t.fontFamily
    },
    zlevel: t.zlevel,
    z: 10001
  }), o = new or({
    style: {
      fill: "none"
    },
    textContent: i,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: t.zlevel,
    z: 10001
  });
  r.add(o);
  var a;
  return t.showSpinner && (a = new aw({
    shape: {
      startAngle: -Qm / 2,
      endAngle: -Qm / 2 + 0.1,
      r: t.spinnerRadius
    },
    style: {
      stroke: t.color,
      lineCap: "round",
      lineWidth: t.lineWidth
    },
    zlevel: t.zlevel,
    z: 10001
  }), a.animateShape(!0).when(1e3, {
    endAngle: Qm * 3 / 2
  }).start("circularInOut"), a.animateShape(!0).when(1e3, {
    startAngle: Qm * 3 / 2
  }).delay(300).start("circularInOut"), r.add(a)), r.resize = function() {
    var s = i.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (e.getWidth() - l * 2 - (t.showSpinner && s ? 10 : 0) - s) / 2 - (t.showSpinner && s ? 0 : 5 + s / 2) + (t.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = e.getHeight() / 2;
    t.showSpinner && a.setShape({
      cx: u,
      cy: c
    }), o.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), n.setShape({
      x: 0,
      y: 0,
      width: e.getWidth(),
      height: e.getHeight()
    });
  }, r.resize(), r;
}
var p9 = (
  /** @class */
  function() {
    function e(t, r, n, i) {
      this._stageTaskMap = nt(), this.ecInstance = t, this.api = r, n = this._dataProcessorHandlers = n.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = n.concat(i);
    }
    return e.prototype.restoreData = function(t, r) {
      t.restoreData(r), this._stageTaskMap.each(function(n) {
        var i = n.overallTask;
        i && i.dirty();
      });
    }, e.prototype.getPerformArgs = function(t, r) {
      if (t.__pipeline) {
        var n = this._pipelineMap.get(t.__pipeline.id), i = n.context, o = !r && n.progressiveEnabled && (!i || i.progressiveRender) && t.__idxInPipeline > n.blockIndex, a = o ? n.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / a) : null;
        return {
          step: a,
          modBy: l,
          modDataCount: s
        };
      }
    }, e.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, e.prototype.updateStreamModes = function(t, r) {
      var n = this._pipelineMap.get(t.uid), i = t.getData(), o = i.count(), a = n.progressiveEnabled && r.incrementalPrepareRender && o >= n.threshold, s = t.get("large") && o >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? o : null;
      t.pipelineContext = n.context = {
        progressiveRender: a,
        modDataCount: l,
        large: s
      };
    }, e.prototype.restorePipelines = function(t) {
      var r = this, n = r._pipelineMap = nt();
      t.eachSeries(function(i) {
        var o = i.getProgressive(), a = i.uid;
        n.set(a, {
          id: a,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: o && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(o || 700),
          count: 0
        }), r._pipe(i, i.dataTask);
      });
    }, e.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, r = this.api.getModel(), n = this.api;
      $(this._allHandlers, function(i) {
        var o = t.get(i.uid) || t.set(i.uid, {}), a = "";
        process.env.NODE_ENV !== "production" && (a = '"reset" and "overallReset" must not be both specified.'), ct(!(i.reset && i.overallReset), a), i.reset && this._createSeriesStageTask(i, o, r, n), i.overallReset && this._createOverallStageTask(i, o, r, n);
      }, this);
    }, e.prototype.prepareView = function(t, r, n, i) {
      var o = t.renderTask, a = o.context;
      a.model = r, a.ecModel = n, a.api = i, o.__block = !t.incrementalPrepareRender, this._pipe(r, o);
    }, e.prototype.performDataProcessorTasks = function(t, r) {
      this._performStageTasks(this._dataProcessorHandlers, t, r, {
        block: !0
      });
    }, e.prototype.performVisualTasks = function(t, r, n) {
      this._performStageTasks(this._visualHandlers, t, r, n);
    }, e.prototype._performStageTasks = function(t, r, n, i) {
      i = i || {};
      var o = !1, a = this;
      $(t, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = a._stageTaskMap.get(l.uid), d = c.seriesTaskMap, h = c.overallTask;
          if (h) {
            var f, p = h.agentStubMap;
            p.each(function(v) {
              s(i, v) && (v.dirty(), f = !0);
            }), f && h.dirty(), a.updatePayload(h, n);
            var g = a.getPerformArgs(h, i.block);
            p.each(function(v) {
              v.perform(g);
            }), h.perform(g) && (o = !0);
          } else d && d.each(function(v, m) {
            s(i, v) && v.dirty();
            var y = a.getPerformArgs(v, i.block);
            y.skip = !l.performRawSeries && r.isSeriesFiltered(v.context.model), a.updatePayload(v, n), v.perform(y) && (o = !0);
          });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = o || this.unfinished;
    }, e.prototype.performSeriesTasks = function(t) {
      var r;
      t.eachSeries(function(n) {
        r = n.dataTask.perform() || r;
      }), this.unfinished = r || this.unfinished;
    }, e.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var r = t.tail;
        do {
          if (r.__block) {
            t.blockIndex = r.__idxInPipeline;
            break;
          }
          r = r.getUpstream();
        } while (r);
      });
    }, e.prototype.updatePayload = function(t, r) {
      r !== "remain" && (t.context.payload = r);
    }, e.prototype._createSeriesStageTask = function(t, r, n, i) {
      var o = this, a = r.seriesTaskMap, s = r.seriesTaskMap = nt(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, i).each(c);
      function c(d) {
        var h = d.uid, f = s.set(h, a && a.get(h) || hg({
          plan: N1e,
          reset: k1e,
          count: B1e
        }));
        f.context = {
          model: d,
          ecModel: n,
          api: i,
          // PENDING: `useClearVisual` not used?
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: o
        }, o._pipe(d, f);
      }
    }, e.prototype._createOverallStageTask = function(t, r, n, i) {
      var o = this, a = r.overallTask = r.overallTask || hg({
        reset: I1e
      });
      a.context = {
        ecModel: n,
        api: i,
        overallReset: t.overallReset,
        scheduler: o
      };
      var s = a.agentStubMap, l = a.agentStubMap = nt(), u = t.seriesType, c = t.getTargetSeries, d = !0, h = !1, f = "";
      process.env.NODE_ENV !== "production" && (f = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), ct(!t.createOnAllSeries, f), u ? n.eachRawSeriesByType(u, p) : c ? c(n, i).each(p) : (d = !1, $(n.getSeries(), p));
      function p(g) {
        var v = g.uid, m = l.set(v, s && s.get(v) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (h = !0, hg({
          reset: O1e,
          onDirty: F1e
        })));
        m.context = {
          model: g,
          overallProgress: d
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, m.agent = a, m.__block = d, o._pipe(g, m);
      }
      h && a.dirty();
    }, e.prototype._pipe = function(t, r) {
      var n = t.uid, i = this._pipelineMap.get(n);
      !i.head && (i.head = r), i.tail && i.tail.pipe(r), i.tail = r, r.__idxInPipeline = i.count++, r.__pipeline = i;
    }, e.wrapStageHandler = function(t, r) {
      return at(t) && (t = {
        overallReset: t,
        seriesType: $1e(t)
      }), t.uid = wf("stageHandler"), r && (t.visualType = r), t;
    }, e;
  }()
);
function I1e(e) {
  e.overallReset(e.ecModel, e.api, e.payload);
}
function O1e(e) {
  return e.overallProgress && L1e;
}
function L1e() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function F1e() {
  this.agent && this.agent.dirty();
}
function N1e(e) {
  return e.plan ? e.plan(e.model, e.ecModel, e.api, e.payload) : null;
}
function k1e(e) {
  e.useClearVisual && e.data.clearAllVisual();
  var t = e.resetDefines = Tr(e.reset(e.model, e.ecModel, e.api, e.payload));
  return t.length > 1 ? Ee(t, function(r, n) {
    return g9(n);
  }) : V1e;
}
var V1e = g9(0);
function g9(e) {
  return function(t, r) {
    var n = r.data, i = r.resetDefines[e];
    if (i && i.dataEach)
      for (var o = t.start; o < t.end; o++)
        i.dataEach(n, o);
    else i && i.progress && i.progress(t, n);
  };
}
function B1e(e) {
  return e.data.count();
}
function $1e(e) {
  mC = null;
  try {
    e(Zg, v9);
  } catch {
  }
  return mC;
}
var Zg = {}, v9 = {}, mC;
m9(Zg, ED);
m9(v9, H7);
Zg.eachSeriesByType = Zg.eachRawSeriesByType = function(e) {
  mC = e;
};
Zg.eachComponent = function(e) {
  e.mainType === "series" && e.subType && (mC = e.subType);
};
function m9(e, t) {
  for (var r in t.prototype)
    e[r] = un;
}
var Rk = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
const H1e = {
  color: Rk,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], Rk]
};
var Si = "#B9B8CE", _k = "#100C2A", Jm = function() {
  return {
    axisLine: {
      lineStyle: {
        color: Si
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
}, Tk = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], y9 = {
  darkMode: !0,
  color: Tk,
  backgroundColor: _k,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: Si
    }
  },
  textStyle: {
    color: Si
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: Si
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: Si
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: Si
    }
  },
  timeline: {
    lineStyle: {
      color: Si
    },
    label: {
      color: Si
    },
    controlStyle: {
      color: Si,
      borderColor: Si
    }
  },
  calendar: {
    itemStyle: {
      color: _k
    },
    dayLabel: {
      color: Si
    },
    monthLabel: {
      color: Si
    },
    yearLabel: {
      color: Si
    }
  },
  timeAxis: Jm(),
  logAxis: Jm(),
  valueAxis: Jm(),
  categoryAxis: Jm(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: Tk
  },
  gauge: {
    title: {
      color: Si
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: Si
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  }
};
y9.categoryAxis.splitLine.show = !1;
var G1e = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.normalizeQuery = function(t) {
      var r = {}, n = {}, i = {};
      if (He(t)) {
        var o = ns(t);
        r.mainType = o.main || null, r.subType = o.sub || null;
      } else {
        var a = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        $(t, function(l, u) {
          for (var c = !1, d = 0; d < a.length; d++) {
            var h = a[d], f = u.lastIndexOf(h);
            if (f > 0 && f === u.length - h.length) {
              var p = u.slice(0, f);
              p !== "data" && (r.mainType = p, r[h.toLowerCase()] = l, c = !0);
            }
          }
          s.hasOwnProperty(u) && (n[u] = l, c = !0), c || (i[u] = l);
        });
      }
      return {
        cptQuery: r,
        dataQuery: n,
        otherQuery: i
      };
    }, e.prototype.filter = function(t, r) {
      var n = this.eventInfo;
      if (!n)
        return !0;
      var i = n.targetEl, o = n.packedEvent, a = n.model, s = n.view;
      if (!a || !s)
        return !0;
      var l = r.cptQuery, u = r.dataQuery;
      return c(l, a, "mainType") && c(l, a, "subType") && c(l, a, "index", "componentIndex") && c(l, a, "name") && c(l, a, "id") && c(u, o, "name") && c(u, o, "dataIndex") && c(u, o, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, r.otherQuery, i, o));
      function c(d, h, f, p) {
        return d[f] == null || h[p || f] === d[f];
      }
    }, e.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, e;
  }()
), J_ = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], Pk = J_.concat(["symbolKeepAspect"]), z1e = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    var r = e.getData();
    if (e.legendIcon && r.setVisual("legendIcon", e.legendIcon), !e.hasSymbolVisual)
      return;
    for (var n = {}, i = {}, o = !1, a = 0; a < J_.length; a++) {
      var s = J_[a], l = e.get(s);
      at(l) ? (o = !0, i[s] = l) : n[s] = l;
    }
    if (n.symbol = n.symbol || e.defaultSymbol, r.setVisual(ge({
      legendIcon: e.legendIcon || n.symbol,
      symbolKeepAspect: e.get("symbolKeepAspect")
    }, n)), t.isSeriesFiltered(e))
      return;
    var u = jt(i);
    function c(d, h) {
      for (var f = e.getRawValue(h), p = e.getDataParams(h), g = 0; g < u.length; g++) {
        var v = u[g];
        d.setItemVisual(h, v, i[v](f, p));
      }
    }
    return {
      dataEach: o ? c : null
    };
  }
}, W1e = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    if (!e.hasSymbolVisual || t.isSeriesFiltered(e))
      return;
    var r = e.getData();
    function n(i, o) {
      for (var a = i.getItemModel(o), s = 0; s < Pk.length; s++) {
        var l = Pk[s], u = a.getShallow(l, !0);
        u != null && i.setItemVisual(o, l, u);
      }
    }
    return {
      dataEach: r.hasItemOption ? n : null
    };
  }
};
function MD(e, t, r) {
  switch (r) {
    case "color":
      var n = e.getItemVisual(t, "style");
      return n[e.getVisual("drawType")];
    case "opacity":
      return e.getItemVisual(t, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getItemVisual(t, r);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + r);
  }
}
function zv(e, t) {
  switch (t) {
    case "color":
      var r = e.getVisual("style");
      return r[e.getVisual("drawType")];
    case "opacity":
      return e.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getVisual(t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function C9(e, t, r, n) {
  switch (r) {
    case "color":
      var i = e.ensureUniqueItemVisual(t, "style");
      i[e.getVisual("drawType")] = n, e.setItemVisual(t, "colorFromPalette", !1);
      break;
    case "opacity":
      e.ensureUniqueItemVisual(t, "style").opacity = n;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      e.setItemVisual(t, r, n);
      break;
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + r);
  }
}
function S9(e, t) {
  function r(n, i) {
    var o = [];
    return n.eachComponent({
      mainType: "series",
      subType: e,
      query: i
    }, function(a) {
      o.push(a.seriesIndex);
    }), o;
  }
  $([[e + "ToggleSelect", "toggleSelect"], [e + "Select", "select"], [e + "UnSelect", "unselect"]], function(n) {
    t(n[0], function(i, o, a) {
      i = ge({}, i), process.env.NODE_ENV !== "production" && pn(i.type, n[1]), a.dispatchAction(ge(i, {
        type: n[1],
        seriesIndex: r(o, i)
      }));
    });
  });
}
function Bd(e, t, r, n, i) {
  var o = e + t;
  r.isSilent(o) || (process.env.NODE_ENV !== "production" && ea("event " + o + " is deprecated."), n.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(a) {
    for (var s = a.seriesIndex, l = a.option.selectedMap, u = i.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === s) {
        var d = a.getData(), h = zc(d, i.fromActionPayload);
        r.trigger(o, {
          type: o,
          seriesId: a.id,
          name: be(h) ? d.getName(h[0]) : d.getName(h),
          selected: He(l) ? l : ge({}, l)
        });
      }
  }));
}
function j1e(e, t, r) {
  e.on("selectchanged", function(n) {
    var i = r.getModel();
    n.isFromClick ? (Bd("map", "selectchanged", t, i, n), Bd("pie", "selectchanged", t, i, n)) : n.fromAction === "select" ? (Bd("map", "selected", t, i, n), Bd("pie", "selected", t, i, n)) : n.fromAction === "unselect" && (Bd("map", "unselected", t, i, n), Bd("pie", "unselected", t, i, n));
  });
}
function Cc(e, t, r) {
  for (var n; e && !(t(e) && (n = e, r)); )
    e = e.__hostTarget || e.parent;
  return n;
}
var U1e = Math.round(Math.random() * 9), K1e = typeof Object.defineProperty == "function", Y1e = function() {
  function e() {
    this._id = "__ec_inner_" + U1e++;
  }
  return e.prototype.get = function(t) {
    return this._guard(t)[this._id];
  }, e.prototype.set = function(t, r) {
    var n = this._guard(t);
    return K1e ? Object.defineProperty(n, this._id, {
      value: r,
      enumerable: !1,
      configurable: !0
    }) : n[this._id] = r, this;
  }, e.prototype.delete = function(t) {
    return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
  }, e.prototype.has = function(t) {
    return !!this._guard(t)[this._id];
  }, e.prototype._guard = function(t) {
    if (t !== Object(t))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return t;
  }, e;
}(), q1e = Ht.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var r = t.cx, n = t.cy, i = t.width / 2, o = t.height / 2;
    e.moveTo(r, n - o), e.lineTo(r + i, n + o), e.lineTo(r - i, n + o), e.closePath();
  }
}), X1e = Ht.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var r = t.cx, n = t.cy, i = t.width / 2, o = t.height / 2;
    e.moveTo(r, n - o), e.lineTo(r + i, n), e.lineTo(r, n + o), e.lineTo(r - i, n), e.closePath();
  }
}), Z1e = Ht.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var r = t.x, n = t.y, i = t.width / 5 * 3, o = Math.max(i, t.height), a = i / 2, s = a * a / (o - a), l = n - o + a + s, u = Math.asin(s / a), c = Math.cos(u) * a, d = Math.sin(u), h = Math.cos(u), f = a * 0.6, p = a * 0.7;
    e.moveTo(r - c, l + s), e.arc(r, l, a, Math.PI - u, Math.PI * 2 + u), e.bezierCurveTo(r + c - d * f, l + s + h * f, r, n - p, r, n), e.bezierCurveTo(r, n - p, r - c + d * f, l + s + h * f, r - c, l + s), e.closePath();
  }
}), Q1e = Ht.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var r = t.height, n = t.width, i = t.x, o = t.y, a = n / 3 * 2;
    e.moveTo(i, o), e.lineTo(i + a, o + r), e.lineTo(i, o + r / 4 * 3), e.lineTo(i - a, o + r), e.lineTo(i, o), e.closePath();
  }
}), J1e = {
  line: Nn,
  rect: or,
  roundRect: or,
  square: or,
  circle: ul,
  diamond: X1e,
  pin: Z1e,
  arrow: Q1e,
  triangle: q1e
}, exe = {
  line: function(e, t, r, n, i) {
    i.x1 = e, i.y1 = t + n / 2, i.x2 = e + r, i.y2 = t + n / 2;
  },
  rect: function(e, t, r, n, i) {
    i.x = e, i.y = t, i.width = r, i.height = n;
  },
  roundRect: function(e, t, r, n, i) {
    i.x = e, i.y = t, i.width = r, i.height = n, i.r = Math.min(r, n) / 4;
  },
  square: function(e, t, r, n, i) {
    var o = Math.min(r, n);
    i.x = e, i.y = t, i.width = o, i.height = o;
  },
  circle: function(e, t, r, n, i) {
    i.cx = e + r / 2, i.cy = t + n / 2, i.r = Math.min(r, n) / 2;
  },
  diamond: function(e, t, r, n, i) {
    i.cx = e + r / 2, i.cy = t + n / 2, i.width = r, i.height = n;
  },
  pin: function(e, t, r, n, i) {
    i.x = e + r / 2, i.y = t + n / 2, i.width = r, i.height = n;
  },
  arrow: function(e, t, r, n, i) {
    i.x = e + r / 2, i.y = t + n / 2, i.width = r, i.height = n;
  },
  triangle: function(e, t, r, n, i) {
    i.cx = e + r / 2, i.cy = t + n / 2, i.width = r, i.height = n;
  }
}, yC = {};
$(J1e, function(e, t) {
  yC[t] = new e();
});
var txe = Ht.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(e, t, r) {
    var n = oC(e, t, r), i = this.shape;
    return i && i.symbolType === "pin" && t.position === "inside" && (n.y = r.y + r.height * 0.4), n;
  },
  buildPath: function(e, t, r) {
    var n = t.symbolType;
    if (n !== "none") {
      var i = yC[n];
      i || (n = "rect", i = yC[n]), exe[n](t.x, t.y, t.width, t.height, i.shape), i.buildPath(e, i.shape, r);
    }
  }
});
function rxe(e, t) {
  if (this.type !== "image") {
    var r = this.style;
    this.__isEmptyBrush ? (r.stroke = e, r.fill = t || "#fff", r.lineWidth = 2) : this.shape.symbolType === "line" ? r.stroke = e : r.fill = e, this.markRedraw();
  }
}
function mn(e, t, r, n, i, o, a) {
  var s = e.indexOf("empty") === 0;
  s && (e = e.substr(5, 1).toLowerCase() + e.substr(6));
  var l;
  return e.indexOf("image://") === 0 ? l = sD(e.slice(8), new At(t, r, n, i), a ? "center" : "cover") : e.indexOf("path://") === 0 ? l = $v(e.slice(7), {}, new At(t, r, n, i), a ? "center" : "cover") : l = new txe({
    shape: {
      symbolType: e,
      x: t,
      y: r,
      width: n,
      height: i
    }
  }), l.__isEmptyBrush = s, l.setColor = rxe, o && l.setColor(o), l;
}
function _f(e) {
  return be(e) || (e = [+e, +e]), [e[0] || 0, e[1] || 0];
}
function ud(e, t) {
  if (e != null)
    return be(e) || (e = [e, e]), [Be(e[0], t[0]) || 0, Be(bt(e[1], e[0]), t[1]) || 0];
}
function Sc(e) {
  return isFinite(e);
}
function nxe(e, t, r) {
  var n = t.x == null ? 0 : t.x, i = t.x2 == null ? 1 : t.x2, o = t.y == null ? 0 : t.y, a = t.y2 == null ? 0 : t.y2;
  t.global || (n = n * r.width + r.x, i = i * r.width + r.x, o = o * r.height + r.y, a = a * r.height + r.y), n = Sc(n) ? n : 0, i = Sc(i) ? i : 1, o = Sc(o) ? o : 0, a = Sc(a) ? a : 0;
  var s = e.createLinearGradient(n, o, i, a);
  return s;
}
function ixe(e, t, r) {
  var n = r.width, i = r.height, o = Math.min(n, i), a = t.x == null ? 0.5 : t.x, s = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
  t.global || (a = a * n + r.x, s = s * i + r.y, l = l * o), a = Sc(a) ? a : 0.5, s = Sc(s) ? s : 0.5, l = l >= 0 && Sc(l) ? l : 0.5;
  var u = e.createRadialGradient(a, s, 0, a, s, l);
  return u;
}
function eT(e, t, r) {
  for (var n = t.type === "radial" ? ixe(e, t, r) : nxe(e, t, r), i = t.colorStops, o = 0; o < i.length; o++)
    n.addColorStop(i[o].offset, i[o].color);
  return n;
}
function oxe(e, t) {
  if (e === t || !e && !t)
    return !1;
  if (!e || !t || e.length !== t.length)
    return !0;
  for (var r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !0;
  return !1;
}
function ey(e) {
  return parseInt(e, 10);
}
function vh(e, t, r) {
  var n = ["width", "height"][t], i = ["clientWidth", "clientHeight"][t], o = ["paddingLeft", "paddingTop"][t], a = ["paddingRight", "paddingBottom"][t];
  if (r[n] != null && r[n] !== "auto")
    return parseFloat(r[n]);
  var s = document.defaultView.getComputedStyle(e);
  return (e[i] || ey(s[n]) || ey(e.style[n])) - (ey(s[o]) || 0) - (ey(s[a]) || 0) | 0;
}
function axe(e, t) {
  return !e || e === "solid" || !(t > 0) ? null : e === "dashed" ? [4 * t, 2 * t] : e === "dotted" ? [t] : sr(e) ? [e] : be(e) ? e : null;
}
function DD(e) {
  var t = e.style, r = t.lineDash && t.lineWidth > 0 && axe(t.lineDash, t.lineWidth), n = t.lineDashOffset;
  if (r) {
    var i = t.strokeNoScale && e.getLineScale ? e.getLineScale() : 1;
    i && i !== 1 && (r = Ee(r, function(o) {
      return o / i;
    }), n /= i);
  }
  return [r, n];
}
var sxe = new ms(!0);
function CC(e) {
  var t = e.stroke;
  return !(t == null || t === "none" || !(e.lineWidth > 0));
}
function Mk(e) {
  return typeof e == "string" && e !== "none";
}
function SC(e) {
  var t = e.fill;
  return t != null && t !== "none";
}
function Dk(e, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var r = e.globalAlpha;
    e.globalAlpha = t.fillOpacity * t.opacity, e.fill(), e.globalAlpha = r;
  } else
    e.fill();
}
function Ak(e, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var r = e.globalAlpha;
    e.globalAlpha = t.strokeOpacity * t.opacity, e.stroke(), e.globalAlpha = r;
  } else
    e.stroke();
}
function tT(e, t, r) {
  var n = ZM(t.image, t.__image, r);
  if (ew(n)) {
    var i = e.createPattern(n, t.repeat || "repeat");
    if (typeof DOMMatrix == "function" && i && i.setTransform) {
      var o = new DOMMatrix();
      o.translateSelf(t.x || 0, t.y || 0), o.rotateSelf(0, 0, (t.rotation || 0) * eg), o.scaleSelf(t.scaleX || 1, t.scaleY || 1), i.setTransform(o);
    }
    return i;
  }
}
function lxe(e, t, r, n) {
  var i, o = CC(r), a = SC(r), s = r.strokePercent, l = s < 1, u = !t.path;
  (!t.silent || l) && u && t.createPathProxy();
  var c = t.path || sxe, d = t.__dirty;
  if (!n) {
    var h = r.fill, f = r.stroke, p = a && !!h.colorStops, g = o && !!f.colorStops, v = a && !!h.image, m = o && !!f.image, y = void 0, C = void 0, S = void 0, b = void 0, w = void 0;
    (p || g) && (w = t.getBoundingRect()), p && (y = d ? eT(e, h, w) : t.__canvasFillGradient, t.__canvasFillGradient = y), g && (C = d ? eT(e, f, w) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = C), v && (S = d || !t.__canvasFillPattern ? tT(e, h, t) : t.__canvasFillPattern, t.__canvasFillPattern = S), m && (b = d || !t.__canvasStrokePattern ? tT(e, f, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = S), p ? e.fillStyle = y : v && (S ? e.fillStyle = S : a = !1), g ? e.strokeStyle = C : m && (b ? e.strokeStyle = b : o = !1);
  }
  var x = t.getGlobalScale();
  c.setScale(x[0], x[1], t.segmentIgnoreThreshold);
  var R, _;
  e.setLineDash && r.lineDash && (i = DD(t), R = i[0], _ = i[1]);
  var T = !0;
  (u || d & nh) && (c.setDPR(e.dpr), l ? c.setContext(null) : (c.setContext(e), T = !1), c.reset(), t.buildPath(c, t.shape, n), c.toStatic(), t.pathUpdated()), T && c.rebuildPath(e, l ? s : 1), R && (e.setLineDash(R), e.lineDashOffset = _), n || (r.strokeFirst ? (o && Ak(e, r), a && Dk(e, r)) : (a && Dk(e, r), o && Ak(e, r))), R && e.setLineDash([]);
}
function uxe(e, t, r) {
  var n = t.__image = ZM(r.image, t.__image, t, t.onload);
  if (!(!n || !ew(n))) {
    var i = r.x || 0, o = r.y || 0, a = t.getWidth(), s = t.getHeight(), l = n.width / n.height;
    if (a == null && s != null ? a = s * l : s == null && a != null ? s = a / l : a == null && s == null && (a = n.width, s = n.height), r.sWidth && r.sHeight) {
      var u = r.sx || 0, c = r.sy || 0;
      e.drawImage(n, u, c, r.sWidth, r.sHeight, i, o, a, s);
    } else if (r.sx && r.sy) {
      var u = r.sx, c = r.sy, d = a - u, h = s - c;
      e.drawImage(n, u, c, d, h, i, o, a, s);
    } else
      e.drawImage(n, i, o, a, s);
  }
}
function cxe(e, t, r) {
  var n, i = r.text;
  if (i != null && (i += ""), i) {
    e.font = r.font || tu, e.textAlign = r.textAlign, e.textBaseline = r.textBaseline;
    var o = void 0, a = void 0;
    e.setLineDash && r.lineDash && (n = DD(t), o = n[0], a = n[1]), o && (e.setLineDash(o), e.lineDashOffset = a), r.strokeFirst ? (CC(r) && e.strokeText(i, r.x, r.y), SC(r) && e.fillText(i, r.x, r.y)) : (SC(r) && e.fillText(i, r.x, r.y), CC(r) && e.strokeText(i, r.x, r.y)), o && e.setLineDash([]);
  }
}
var Ik = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], Ok = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function w9(e, t, r, n, i) {
  var o = !1;
  if (!n && (r = r || {}, t === r))
    return !1;
  if (n || t.opacity !== r.opacity) {
    Ki(e, i), o = !0;
    var a = Math.max(Math.min(t.opacity, 1), 0);
    e.globalAlpha = isNaN(a) ? Tc.opacity : a;
  }
  (n || t.blend !== r.blend) && (o || (Ki(e, i), o = !0), e.globalCompositeOperation = t.blend || Tc.blend);
  for (var s = 0; s < Ik.length; s++) {
    var l = Ik[s];
    (n || t[l] !== r[l]) && (o || (Ki(e, i), o = !0), e[l] = e.dpr * (t[l] || 0));
  }
  return (n || t.shadowColor !== r.shadowColor) && (o || (Ki(e, i), o = !0), e.shadowColor = t.shadowColor || Tc.shadowColor), o;
}
function Lk(e, t, r, n, i) {
  var o = Qg(t, i.inHover), a = n ? null : r && Qg(r, i.inHover) || {};
  if (o === a)
    return !1;
  var s = w9(e, o, a, n, i);
  if ((n || o.fill !== a.fill) && (s || (Ki(e, i), s = !0), Mk(o.fill) && (e.fillStyle = o.fill)), (n || o.stroke !== a.stroke) && (s || (Ki(e, i), s = !0), Mk(o.stroke) && (e.strokeStyle = o.stroke)), (n || o.opacity !== a.opacity) && (s || (Ki(e, i), s = !0), e.globalAlpha = o.opacity == null ? 1 : o.opacity), t.hasStroke()) {
    var l = o.lineWidth, u = l / (o.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
    e.lineWidth !== u && (s || (Ki(e, i), s = !0), e.lineWidth = u);
  }
  for (var c = 0; c < Ok.length; c++) {
    var d = Ok[c], h = d[0];
    (n || o[h] !== a[h]) && (s || (Ki(e, i), s = !0), e[h] = o[h] || d[1]);
  }
  return s;
}
function dxe(e, t, r, n, i) {
  return w9(e, Qg(t, i.inHover), r && Qg(r, i.inHover), n, i);
}
function b9(e, t) {
  var r = t.transform, n = e.dpr || 1;
  r ? e.setTransform(n * r[0], n * r[1], n * r[2], n * r[3], n * r[4], n * r[5]) : e.setTransform(n, 0, 0, n, 0, 0);
}
function hxe(e, t, r) {
  for (var n = !1, i = 0; i < e.length; i++) {
    var o = e[i];
    n = n || o.isZeroArea(), b9(t, o), t.beginPath(), o.buildPath(t, o.shape), t.clip();
  }
  r.allClipped = n;
}
function fxe(e, t) {
  return e && t ? e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || e[4] !== t[4] || e[5] !== t[5] : !(!e && !t);
}
var Fk = 1, Nk = 2, kk = 3, Vk = 4;
function pxe(e) {
  var t = SC(e), r = CC(e);
  return !(e.lineDash || !(+t ^ +r) || t && typeof e.fill != "string" || r && typeof e.stroke != "string" || e.strokePercent < 1 || e.strokeOpacity < 1 || e.fillOpacity < 1);
}
function Ki(e, t) {
  t.batchFill && e.fill(), t.batchStroke && e.stroke(), t.batchFill = "", t.batchStroke = "";
}
function Qg(e, t) {
  return t && e.__hoverStyle || e.style;
}
function AD(e, t) {
  wc(e, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function wc(e, t, r, n) {
  var i = t.transform;
  if (!t.shouldBePainted(r.viewWidth, r.viewHeight, !1, !1)) {
    t.__dirty &= ~ho, t.__isRendered = !1;
    return;
  }
  var o = t.__clipPaths, a = r.prevElClipPaths, s = !1, l = !1;
  if ((!a || oxe(o, a)) && (a && a.length && (Ki(e, r), e.restore(), l = s = !0, r.prevElClipPaths = null, r.allClipped = !1, r.prevEl = null), o && o.length && (Ki(e, r), e.save(), hxe(o, e, r), s = !0), r.prevElClipPaths = o), r.allClipped) {
    t.__isRendered = !1;
    return;
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
  var u = r.prevEl;
  u || (l = s = !0);
  var c = t instanceof Ht && t.autoBatch && pxe(t.style);
  s || fxe(i, u.transform) ? (Ki(e, r), b9(e, t)) : c || Ki(e, r);
  var d = Qg(t, r.inHover);
  t instanceof Ht ? (r.lastDrawType !== Fk && (l = !0, r.lastDrawType = Fk), Lk(e, t, u, l, r), (!c || !r.batchFill && !r.batchStroke) && e.beginPath(), lxe(e, t, d, c), c && (r.batchFill = d.fill || "", r.batchStroke = d.stroke || "")) : t instanceof jh ? (r.lastDrawType !== kk && (l = !0, r.lastDrawType = kk), Lk(e, t, u, l, r), cxe(e, t, d)) : t instanceof qn ? (r.lastDrawType !== Nk && (l = !0, r.lastDrawType = Nk), dxe(e, t, u, l, r), uxe(e, t, d)) : t.getTemporalDisplayables && (r.lastDrawType !== Vk && (l = !0, r.lastDrawType = Vk), gxe(e, t, r)), c && n && Ki(e, r), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), r.prevEl = t, t.__dirty = 0, t.__isRendered = !0;
}
function gxe(e, t, r) {
  var n = t.getDisplayables(), i = t.getTemporalDisplayables();
  e.save();
  var o = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: r.viewWidth,
    viewHeight: r.viewHeight,
    inHover: r.inHover
  }, a, s;
  for (a = t.getCursor(), s = n.length; a < s; a++) {
    var l = n[a];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), wc(e, l, o, a === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), o.prevEl = l;
  }
  for (var u = 0, c = i.length; u < c; u++) {
    var l = i[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), wc(e, l, o, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), o.prevEl = l;
  }
  t.clearTemporalDisplayables(), t.notClear = !0, e.restore();
}
var k1 = new Y1e(), Bk = new Ov(100), $k = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function Yh(e, t) {
  if (e === "none")
    return null;
  var r = t.getDevicePixelRatio(), n = t.getZr(), i = n.painter.type === "svg";
  e.dirty && k1.delete(e);
  var o = k1.get(e);
  if (o)
    return o;
  var a = ut(e, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  a.backgroundColor === "none" && (a.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = a.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / r, k1.set(e, s), e.dirty = !1, s;
  function l(u) {
    for (var c = [r], d = !0, h = 0; h < $k.length; ++h) {
      var f = a[$k[h]];
      if (f != null && !be(f) && !He(f) && !sr(f) && typeof f != "boolean") {
        d = !1;
        break;
      }
      c.push(f);
    }
    var p;
    if (d) {
      p = c.join(",") + (i ? "-svg" : "");
      var g = Bk.get(p);
      g && (i ? u.svgElement = g : u.image = g);
    }
    var v = E9(a.dashArrayX), m = vxe(a.dashArrayY), y = x9(a.symbol), C = mxe(v), S = R9(m), b = !i && Ia.createCanvas(), w = i && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, x = _(), R;
    b && (b.width = x.width * r, b.height = x.height * r, R = b.getContext("2d")), T(), d && Bk.put(p, b || w), u.image = b, u.svgElement = w, u.svgWidth = x.width, u.svgHeight = x.height;
    function _() {
      for (var P = 1, D = 0, O = C.length; D < O; ++D)
        P = eN(P, C[D]);
      for (var A = 1, D = 0, O = y.length; D < O; ++D)
        A = eN(A, y[D].length);
      P *= A;
      var F = S * C.length * y.length;
      if (process.env.NODE_ENV !== "production") {
        var L = function(N) {
          console.warn("Calculated decal size is greater than " + N + " due to decal option settings so " + N + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + N + " to be larger to avoid incontinuity.");
        };
        P > a.maxTileWidth && L("maxTileWidth"), F > a.maxTileHeight && L("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(P, a.maxTileWidth)),
        height: Math.max(1, Math.min(F, a.maxTileHeight))
      };
    }
    function T() {
      R && (R.clearRect(0, 0, b.width, b.height), a.backgroundColor && (R.fillStyle = a.backgroundColor, R.fillRect(0, 0, b.width, b.height)));
      for (var P = 0, D = 0; D < m.length; ++D)
        P += m[D];
      if (P <= 0)
        return;
      for (var O = -S, A = 0, F = 0, L = 0; O < x.height; ) {
        if (A % 2 === 0) {
          for (var N = F / 2 % y.length, I = 0, B = 0, M = 0; I < x.width * 2; ) {
            for (var V = 0, D = 0; D < v[L].length; ++D)
              V += v[L][D];
            if (V <= 0)
              break;
            if (B % 2 === 0) {
              var G = (1 - a.symbolSize) * 0.5, k = I + v[L][B] * G, z = O + m[A] * G, j = v[L][B] * a.symbolSize, q = m[A] * a.symbolSize, K = M / 2 % y[N].length;
              Z(k, z, j, q, y[N][K]);
            }
            I += v[L][B], ++M, ++B, B === v[L].length && (B = 0);
          }
          ++L, L === v.length && (L = 0);
        }
        O += m[A], ++F, ++A, A === m.length && (A = 0);
      }
      function Z(re, X, Y, U, oe) {
        var W = i ? 1 : r, ne = mn(oe, re * W, X * W, Y * W, U * W, a.color, a.symbolKeepAspect);
        if (i) {
          var ce = n.painter.renderOneToVNode(ne);
          ce && w.children.push(ce);
        } else
          AD(R, ne);
      }
    }
  }
}
function x9(e) {
  if (!e || e.length === 0)
    return [["rect"]];
  if (He(e))
    return [[e]];
  for (var t = !0, r = 0; r < e.length; ++r)
    if (!He(e[r])) {
      t = !1;
      break;
    }
  if (t)
    return x9([e]);
  for (var n = [], r = 0; r < e.length; ++r)
    He(e[r]) ? n.push([e[r]]) : n.push(e[r]);
  return n;
}
function E9(e) {
  if (!e || e.length === 0)
    return [[0, 0]];
  if (sr(e)) {
    var t = Math.ceil(e);
    return [[t, t]];
  }
  for (var r = !0, n = 0; n < e.length; ++n)
    if (!sr(e[n])) {
      r = !1;
      break;
    }
  if (r)
    return E9([e]);
  for (var i = [], n = 0; n < e.length; ++n)
    if (sr(e[n])) {
      var t = Math.ceil(e[n]);
      i.push([t, t]);
    } else {
      var t = Ee(e[n], function(s) {
        return Math.ceil(s);
      });
      t.length % 2 === 1 ? i.push(t.concat(t)) : i.push(t);
    }
  return i;
}
function vxe(e) {
  if (!e || typeof e == "object" && e.length === 0)
    return [0, 0];
  if (sr(e)) {
    var t = Math.ceil(e);
    return [t, t];
  }
  var r = Ee(e, function(n) {
    return Math.ceil(n);
  });
  return e.length % 2 ? r.concat(r) : r;
}
function mxe(e) {
  return Ee(e, function(t) {
    return R9(t);
  });
}
function R9(e) {
  for (var t = 0, r = 0; r < e.length; ++r)
    t += e[r];
  return e.length % 2 === 1 ? t * 2 : t;
}
function yxe(e, t) {
  e.eachRawSeries(function(r) {
    if (!e.isSeriesFiltered(r)) {
      var n = r.getData();
      n.hasItemVisual() && n.each(function(a) {
        var s = n.getItemVisual(a, "decal");
        if (s) {
          var l = n.ensureUniqueItemVisual(a, "style");
          l.decal = Yh(s, t);
        }
      });
      var i = n.getVisual("decal");
      if (i) {
        var o = n.getVisual("style");
        o.decal = Yh(i, t);
      }
    }
  });
}
var va = new na(), wC = {};
function Cxe(e, t) {
  process.env.NODE_ENV !== "production" && wC[e] && ei("Already has an implementation of " + e + "."), wC[e] = t;
}
function _9(e) {
  return process.env.NODE_ENV !== "production" && (wC[e] || ei("Implementation of " + e + " doesn't exists.")), wC[e];
}
var Sxe = "5.5.1", wxe = {
  zrender: "5.6.0"
}, bxe = 1, xxe = 800, Exe = 900, Rxe = 1e3, _xe = 2e3, Txe = 5e3, T9 = 1e3, Pxe = 1100, ID = 2e3, P9 = 3e3, Mxe = 4e3, Sw = 4500, Dxe = 4600, Axe = 5e3, Ixe = 6e3, M9 = 7e3, D9 = {
  PROCESSOR: {
    FILTER: Rxe,
    SERIES_FILTER: xxe,
    STATISTIC: Txe
  },
  VISUAL: {
    LAYOUT: T9,
    PROGRESSIVE_LAYOUT: Pxe,
    GLOBAL: ID,
    CHART: P9,
    POST_CHART_LAYOUT: Dxe,
    COMPONENT: Mxe,
    BRUSH: Axe,
    CHART_ITEM: Sw,
    ARIA: Ixe,
    DECAL: M9
  }
}, oi = "__flagInMainProcess", Gi = "__pendingUpdate", V1 = "__needsUpdateStatus", Hk = /^[a-zA-Z0-9_]+$/, B1 = "__connectUpdateStatus", Gk = 0, Oxe = 1, Lxe = 2;
function A9(e) {
  return function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    if (this.isDisposed()) {
      uo(this.id);
      return;
    }
    return O9(this, e, t);
  };
}
function I9(e) {
  return function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    return O9(this, e, t);
  };
}
function O9(e, t, r) {
  return r[0] = r[0] && r[0].toLowerCase(), na.prototype[t].apply(e, r);
}
var L9 = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  }(na)
), F9 = L9.prototype;
F9.on = I9("on");
F9.off = I9("off");
var $d, $1, ty, Cl, H1, G1, z1, lp, up, zk, Wk, W1, jk, ry, Uk, N9, Do, Kk, bC = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i) {
      var o = e.call(this, new G1e()) || this;
      o._chartsViews = [], o._chartsMap = {}, o._componentsViews = [], o._componentsMap = {}, o._pendingActions = [], i = i || {}, He(n) && (n = k9[n]), o._dom = r;
      var a = "canvas", s = "auto", l = !1;
      if (process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          nr.hasGlobalWindow ? window : global
        );
        u && (a = bt(u.__ECHARTS__DEFAULT__RENDERER__, a), s = bt(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = bt(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      i.ssr && dW(function(f) {
        var p = St(f), g = p.dataIndex;
        if (g != null) {
          var v = nt();
          return v.set("series_index", p.seriesIndex), v.set("data_index", g), p.ssrType && v.set("ssr_type", p.ssrType), v;
        }
      });
      var c = o._zr = T_(r, {
        renderer: i.renderer || a,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: bt(i.useDirtyRect, l),
        useCoarsePointer: bt(i.useCoarsePointer, s),
        pointerSize: i.pointerSize
      });
      o._ssr = i.ssr, o._throttledZrFlush = Cw(je(c.flush, c), 17), n = dt(n), n && z7(n, !0), o._theme = n, o._locale = Xwe(i.locale || b7), o._coordSysMgr = new ld();
      var d = o._api = Uk(o);
      function h(f, p) {
        return f.__prio - p.__prio;
      }
      return n0(EC, h), n0(rT, h), o._scheduler = new p9(o, d, rT, EC), o._messageCenter = new L9(), o._initEvents(), o.resize = je(o.resize, o), c.animation.on("frame", o._onframe, o), zk(c, o), Wk(c, o), kg(o), o;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        Kk(this);
        var r = this._scheduler;
        if (this[Gi]) {
          var n = this[Gi].silent;
          this[oi] = !0;
          try {
            $d(this), Cl.update.call(this, null, this[Gi].updateParams);
          } catch (l) {
            throw this[oi] = !1, this[Gi] = null, l;
          }
          this._zr.flush(), this[oi] = !1, this[Gi] = null, lp.call(this, n), up.call(this, n);
        } else if (r.unfinished) {
          var i = bxe, o = this._model, a = this._api;
          r.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            r.performSeriesTasks(o), r.performDataProcessorTasks(o), G1(this, o), r.performVisualTasks(o), ry(this, this._model, a, "remain", {}), i -= +/* @__PURE__ */ new Date() - s;
          } while (i > 0 && r.unfinished);
          r.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(r, n, i) {
      if (this[oi]) {
        process.env.NODE_ENV !== "production" && ei("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        uo(this.id);
        return;
      }
      var o, a, s;
      if (lt(n) && (i = n.lazyUpdate, o = n.silent, a = n.replaceMerge, s = n.transition, n = n.notMerge), this[oi] = !0, !this._model || n) {
        var l = new Rbe(this._api), u = this._theme, c = this._model = new ED();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(r, {
        replaceMerge: a
      }, nT);
      var d = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (i)
        this[Gi] = {
          silent: o,
          updateParams: d
        }, this[oi] = !1, this.getZr().wakeUp();
      else {
        try {
          $d(this), Cl.update.call(this, null, d);
        } catch (h) {
          throw this[Gi] = null, this[oi] = !1, h;
        }
        this._ssr || this._zr.flush(), this[Gi] = null, this[oi] = !1, lp.call(this, o), up.call(this, o);
      }
    }, t.prototype.setTheme = function() {
      ea("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || nr.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(r) {
      return process.env.NODE_ENV !== "production" && pn("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(r);
    }, t.prototype.renderToCanvas = function(r) {
      r = r || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return n.getRenderedCanvas({
        backgroundColor: r.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: r.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(r) {
      r = r || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return n.renderToString({
        useViewBox: r.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      if (nr.svgSupported) {
        var r = this._zr, n = r.storage.getDisplayList();
        return $(n, function(i) {
          i.stopAnimation(null, !0);
        }), r.painter.toDataURL();
      }
    }, t.prototype.getDataURL = function(r) {
      if (this._disposed) {
        uo(this.id);
        return;
      }
      r = r || {};
      var n = r.excludeComponents, i = this._model, o = [], a = this;
      $(n, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = a._componentsMap[u.__viewId];
          c.group.ignore || (o.push(c), c.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(r).toDataURL("image/" + (r && r.type || "png"));
      return $(o, function(l) {
        l.group.ignore = !1;
      }), s;
    }, t.prototype.getConnectedDataURL = function(r) {
      if (this._disposed) {
        uo(this.id);
        return;
      }
      var n = r.type === "svg", i = this.group, o = Math.min, a = Math.max, s = 1 / 0;
      if (RC[i]) {
        var l = s, u = s, c = -s, d = -s, h = [], f = r && r.pixelRatio || this.getDevicePixelRatio();
        $(Dc, function(C, S) {
          if (C.group === i) {
            var b = n ? C.getZr().painter.getSvgDom().innerHTML : C.renderToCanvas(dt(r)), w = C.getDom().getBoundingClientRect();
            l = o(w.left, l), u = o(w.top, u), c = a(w.right, c), d = a(w.bottom, d), h.push({
              dom: b,
              left: w.left,
              top: w.top
            });
          }
        }), l *= f, u *= f, c *= f, d *= f;
        var p = c - l, g = d - u, v = Ia.createCanvas(), m = T_(v, {
          renderer: n ? "svg" : "canvas"
        });
        if (m.resize({
          width: p,
          height: g
        }), n) {
          var y = "";
          return $(h, function(C) {
            var S = C.left - l, b = C.top - u;
            y += '<g transform="translate(' + S + "," + b + ')">' + C.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, r.connectedBackgroundColor && m.painter.setBackgroundColor(r.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else
          return r.connectedBackgroundColor && m.add(new or({
            shape: {
              x: 0,
              y: 0,
              width: p,
              height: g
            },
            style: {
              fill: r.connectedBackgroundColor
            }
          })), $(h, function(C) {
            var S = new qn({
              style: {
                x: C.left * f - l,
                y: C.top * f - u,
                image: C.dom
              }
            });
            m.add(S);
          }), m.refreshImmediately(), v.toDataURL("image/" + (r && r.type || "png"));
      } else
        return this.getDataURL(r);
    }, t.prototype.convertToPixel = function(r, n) {
      return H1(this, "convertToPixel", r, n);
    }, t.prototype.convertFromPixel = function(r, n) {
      return H1(this, "convertFromPixel", r, n);
    }, t.prototype.containPixel = function(r, n) {
      if (this._disposed) {
        uo(this.id);
        return;
      }
      var i = this._model, o, a = sg(i, r);
      return $(a, function(s, l) {
        l.indexOf("Models") >= 0 && $(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            o = o || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var d = this._chartsMap[u.__viewId];
            d && d.containPoint ? o = o || d.containPoint(n, u) : process.env.NODE_ENV !== "production" && nn(l + ": " + (d ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && nn(l + ": containPoint is not supported");
        }, this);
      }, this), !!o;
    }, t.prototype.getVisual = function(r, n) {
      var i = this._model, o = sg(i, r, {
        defaultMainType: "series"
      }), a = o.seriesModel;
      process.env.NODE_ENV !== "production" && (a || nn("There is no specified series model"));
      var s = a.getData(), l = o.hasOwnProperty("dataIndexInside") ? o.dataIndexInside : o.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(o.dataIndex) : null;
      return l != null ? MD(s, l, n) : zv(s, n);
    }, t.prototype.getViewOfComponentModel = function(r) {
      return this._componentsMap[r.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(r) {
      return this._chartsMap[r.__viewId];
    }, t.prototype._initEvents = function() {
      var r = this;
      $(Fxe, function(n) {
        var i = function(o) {
          var a = r.getModel(), s = o.target, l, u = n === "globalout";
          if (u ? l = {} : s && Cc(s, function(p) {
            var g = St(p);
            if (g && g.dataIndex != null) {
              var v = g.dataModel || a.getSeriesByIndex(g.seriesIndex);
              return l = v && v.getDataParams(g.dataIndex, g.dataType, s) || {}, !0;
            } else if (g.eventData)
              return l = ge({}, g.eventData), !0;
          }, !0), l) {
            var c = l.componentType, d = l.componentIndex;
            (c === "markLine" || c === "markPoint" || c === "markArea") && (c = "series", d = l.seriesIndex);
            var h = c && d != null && a.getComponent(c, d), f = h && r[h.mainType === "series" ? "_chartsMap" : "_componentsMap"][h.__viewId];
            process.env.NODE_ENV !== "production" && !u && !(h && f) && nn("model or view can not be found by params"), l.event = o, l.type = n, r._$eventProcessor.eventInfo = {
              targetEl: s,
              packedEvent: l,
              model: h,
              view: f
            }, r.trigger(n, l);
          }
        };
        i.zrEventfulCallAtLast = !0, r._zr.on(n, i, r);
      }), $(fg, function(n, i) {
        r._messageCenter.on(i, function(o) {
          this.trigger(i, o);
        }, r);
      }), $(["selectchanged"], function(n) {
        r._messageCenter.on(n, function(i) {
          this.trigger(n, i);
        }, r);
      }), j1e(this._messageCenter, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        uo(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        uo(this.id);
        return;
      }
      this._disposed = !0;
      var r = this.getDom();
      r && wW(this.getDom(), LD, "");
      var n = this, i = n._api, o = n._model;
      $(n._componentsViews, function(a) {
        a.dispose(o, i);
      }), $(n._chartsViews, function(a) {
        a.dispose(o, i);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete Dc[n.id];
    }, t.prototype.resize = function(r) {
      if (this[oi]) {
        process.env.NODE_ENV !== "production" && ei("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        uo(this.id);
        return;
      }
      this._zr.resize(r);
      var n = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!n) {
        var i = n.resetOption("media"), o = r && r.silent;
        this[Gi] && (o == null && (o = this[Gi].silent), i = !0, this[Gi] = null), this[oi] = !0;
        try {
          i && $d(this), Cl.update.call(this, {
            type: "resize",
            animation: ge({
              // Disable animation
              duration: 0
            }, r && r.animation)
          });
        } catch (a) {
          throw this[oi] = !1, a;
        }
        this[oi] = !1, lp.call(this, o), up.call(this, o);
      }
    }, t.prototype.showLoading = function(r, n) {
      if (this._disposed) {
        uo(this.id);
        return;
      }
      if (lt(r) && (n = r, r = ""), r = r || "default", this.hideLoading(), !iT[r]) {
        process.env.NODE_ENV !== "production" && nn("Loading effects " + r + " not exists.");
        return;
      }
      var i = iT[r](this._api, n), o = this._zr;
      this._loadingFX = i, o.add(i);
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        uo(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(r) {
      var n = ge({}, r);
      return n.type = fg[r.type], n;
    }, t.prototype.dispatchAction = function(r, n) {
      if (this._disposed) {
        uo(this.id);
        return;
      }
      if (lt(n) || (n = {
        silent: !!n
      }), !!xC[r.type] && this._model) {
        if (this[oi]) {
          this._pendingActions.push(r);
          return;
        }
        var i = n.silent;
        z1.call(this, r, i);
        var o = n.flush;
        o ? this._zr.flush() : o !== !1 && nr.browser.weChat && this._throttledZrFlush(), lp.call(this, i), up.call(this, i);
      }
    }, t.prototype.updateLabelLayout = function() {
      va.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, t.prototype.appendData = function(r) {
      if (this._disposed) {
        uo(this.id);
        return;
      }
      var n = r.seriesIndex, i = this.getModel(), o = i.getSeriesByIndex(n);
      process.env.NODE_ENV !== "production" && ct(r.data && o), o.appendData(r), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, t.internalField = function() {
      $d = function(d) {
        var h = d._scheduler;
        h.restorePipelines(d._model), h.prepareStageTasks(), $1(d, !0), $1(d, !1), h.plan();
      }, $1 = function(d, h) {
        for (var f = d._model, p = d._scheduler, g = h ? d._componentsViews : d._chartsViews, v = h ? d._componentsMap : d._chartsMap, m = d._zr, y = d._api, C = 0; C < g.length; C++)
          g[C].__alive = !1;
        h ? f.eachComponent(function(w, x) {
          w !== "series" && S(x);
        }) : f.eachSeries(S);
        function S(w) {
          var x = w.__requireNewView;
          w.__requireNewView = !1;
          var R = "_ec_" + w.id + "_" + w.type, _ = !x && v[R];
          if (!_) {
            var T = ns(w.type), P = h ? zr.getClass(T.main, T.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              br.getClass(T.sub)
            );
            process.env.NODE_ENV !== "production" && ct(P, T.sub + " does not exist."), _ = new P(), _.init(f, y), v[R] = _, g.push(_), m.add(_.group);
          }
          w.__viewId = _.__id = R, _.__alive = !0, _.__model = w, _.group.__ecComponentInfo = {
            mainType: w.mainType,
            index: w.componentIndex
          }, !h && p.prepareView(_, w, f, y);
        }
        for (var C = 0; C < g.length; ) {
          var b = g[C];
          b.__alive ? C++ : (!h && b.renderTask.dispose(), m.remove(b.group), b.dispose(f, y), g.splice(C, 1), v[b.__id] === b && delete v[b.__id], b.__id = b.group.__ecComponentInfo = null);
        }
      }, ty = function(d, h, f, p, g) {
        var v = d._model;
        if (v.setUpdatePayload(f), !p) {
          $([].concat(d._componentsViews).concat(d._chartsViews), b);
          return;
        }
        var m = {};
        m[p + "Id"] = f[p + "Id"], m[p + "Index"] = f[p + "Index"], m[p + "Name"] = f[p + "Name"];
        var y = {
          mainType: p,
          query: m
        };
        g && (y.subType = g);
        var C = f.excludeSeriesId, S;
        C != null && (S = nt(), $(Tr(C), function(w) {
          var x = In(w, null);
          x != null && S.set(x, !0);
        })), v && v.eachComponent(y, function(w) {
          var x = S && S.get(w.id) != null;
          if (!x)
            if (MN(f))
              if (w instanceof Pr)
                f.type === Pc && !f.notBlur && !w.get(["emphasis", "disabled"]) && YSe(w, f, d._api);
              else {
                var R = nD(w.mainType, w.componentIndex, f.name, d._api), _ = R.focusSelf, T = R.dispatchers;
                f.type === Pc && _ && !f.notBlur && k_(w.mainType, w.componentIndex, d._api), T && $(T, function(P) {
                  f.type === Pc ? Qs(P) : Js(P);
                });
              }
            else B_(f) && w instanceof Pr && (ZSe(w, f, d._api), TN(w), Do(d));
        }, d), v && v.eachComponent(y, function(w) {
          var x = S && S.get(w.id) != null;
          x || b(d[p === "series" ? "_chartsMap" : "_componentsMap"][w.__viewId]);
        }, d);
        function b(w) {
          w && w.__alive && w[h] && w[h](w.__model, v, d._api, f);
        }
      }, Cl = {
        prepareAndUpdate: function(d) {
          $d(this), Cl.update.call(this, d, {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: d.newOption != null
          });
        },
        update: function(d, h) {
          var f = this._model, p = this._api, g = this._zr, v = this._coordSysMgr, m = this._scheduler;
          if (f) {
            f.setUpdatePayload(d), m.restoreData(f, d), m.performSeriesTasks(f), v.create(f, p), m.performDataProcessorTasks(f, d), G1(this, f), v.update(f, p), r(f), m.performVisualTasks(f, d), W1(this, f, p, d, h);
            var y = f.get("backgroundColor") || "transparent", C = f.get("darkMode");
            g.setBackgroundColor(y), C != null && C !== "auto" && g.setDarkMode(C), va.trigger("afterupdate", f, p);
          }
        },
        updateTransform: function(d) {
          var h = this, f = this._model, p = this._api;
          if (f) {
            f.setUpdatePayload(d);
            var g = [];
            f.eachComponent(function(m, y) {
              if (m !== "series") {
                var C = h.getViewOfComponentModel(y);
                if (C && C.__alive)
                  if (C.updateTransform) {
                    var S = C.updateTransform(y, f, p, d);
                    S && S.update && g.push(C);
                  } else
                    g.push(C);
              }
            });
            var v = nt();
            f.eachSeries(function(m) {
              var y = h._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var C = y.updateTransform(m, f, p, d);
                C && C.update && v.set(m.uid, 1);
              } else
                v.set(m.uid, 1);
            }), r(f), this._scheduler.performVisualTasks(f, d, {
              setDirty: !0,
              dirtyMap: v
            }), ry(this, f, p, d, {}, v), va.trigger("afterupdate", f, p);
          }
        },
        updateView: function(d) {
          var h = this._model;
          h && (h.setUpdatePayload(d), br.markUpdateMethod(d, "updateView"), r(h), this._scheduler.performVisualTasks(h, d, {
            setDirty: !0
          }), W1(this, h, this._api, d, {}), va.trigger("afterupdate", h, this._api));
        },
        updateVisual: function(d) {
          var h = this, f = this._model;
          f && (f.setUpdatePayload(d), f.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), br.markUpdateMethod(d, "updateVisual"), r(f), this._scheduler.performVisualTasks(f, d, {
            visualType: "visual",
            setDirty: !0
          }), f.eachComponent(function(p, g) {
            if (p !== "series") {
              var v = h.getViewOfComponentModel(g);
              v && v.__alive && v.updateVisual(g, f, h._api, d);
            }
          }), f.eachSeries(function(p) {
            var g = h._chartsMap[p.__viewId];
            g.updateVisual(p, f, h._api, d);
          }), va.trigger("afterupdate", f, this._api));
        },
        updateLayout: function(d) {
          Cl.update.call(this, d);
        }
      }, H1 = function(d, h, f, p) {
        if (d._disposed) {
          uo(d.id);
          return;
        }
        for (var g = d._model, v = d._coordSysMgr.getCoordinateSystems(), m, y = sg(g, f), C = 0; C < v.length; C++) {
          var S = v[C];
          if (S[h] && (m = S[h](g, y, p)) != null)
            return m;
        }
        process.env.NODE_ENV !== "production" && nn("No coordinate system that supports " + h + " found by the given finder.");
      }, G1 = function(d, h) {
        var f = d._chartsMap, p = d._scheduler;
        h.eachSeries(function(g) {
          p.updateStreamModes(g, f[g.__viewId]);
        });
      }, z1 = function(d, h) {
        var f = this, p = this.getModel(), g = d.type, v = d.escapeConnect, m = xC[g], y = m.actionInfo, C = (y.update || "update").split(":"), S = C.pop(), b = C[0] != null && ns(C[0]);
        this[oi] = !0;
        var w = [d], x = !1;
        d.batch && (x = !0, w = Ee(d.batch, function(A) {
          return A = ut(ge({}, A), d), A.batch = null, A;
        }));
        var R = [], _, T = B_(d), P = MN(d);
        if (P && UW(this._api), $(w, function(A) {
          if (_ = m.action(A, f._model, f._api), _ = _ || ge({}, A), _.type = y.event || _.type, R.push(_), P) {
            var F = qM(d), L = F.queryOptionMap, N = F.mainTypeSpecified, I = N ? L.keys()[0] : "series";
            ty(f, S, A, I), Do(f);
          } else T ? (ty(f, S, A, "series"), Do(f)) : b && ty(f, S, A, b.main, b.sub);
        }), S !== "none" && !P && !T && !b)
          try {
            this[Gi] ? ($d(this), Cl.update.call(this, d), this[Gi] = null) : Cl[S].call(this, d);
          } catch (A) {
            throw this[oi] = !1, A;
          }
        if (x ? _ = {
          type: y.event || g,
          escapeConnect: v,
          batch: R
        } : _ = R[0], this[oi] = !1, !h) {
          var D = this._messageCenter;
          if (D.trigger(_.type, _), T) {
            var O = {
              type: "selectchanged",
              escapeConnect: v,
              selected: QSe(p),
              isFromClick: d.isFromClick || !1,
              fromAction: d.type,
              fromActionPayload: d
            };
            D.trigger(O.type, O);
          }
        }
      }, lp = function(d) {
        for (var h = this._pendingActions; h.length; ) {
          var f = h.shift();
          z1.call(this, f, d);
        }
      }, up = function(d) {
        !d && this.trigger("updated");
      }, zk = function(d, h) {
        d.on("rendered", function(f) {
          h.trigger("rendered", f), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          d.animation.isFinished() && !h[Gi] && !h._scheduler.unfinished && !h._pendingActions.length && h.trigger("finished");
        });
      }, Wk = function(d, h) {
        d.on("mouseover", function(f) {
          var p = f.target, g = Cc(p, ou);
          g && (qSe(g, f, h._api), Do(h));
        }).on("mouseout", function(f) {
          var p = f.target, g = Cc(p, ou);
          g && (XSe(g, f, h._api), Do(h));
        }).on("click", function(f) {
          var p = f.target, g = Cc(p, function(y) {
            return St(y).dataIndex != null;
          }, !0);
          if (g) {
            var v = g.selected ? "unselect" : "select", m = St(g);
            h._api.dispatchAction({
              type: v,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function r(d) {
        d.clearColorPalette(), d.eachSeries(function(h) {
          h.clearColorPalette();
        });
      }
      function n(d) {
        var h = [], f = [], p = !1;
        if (d.eachComponent(function(y, C) {
          var S = C.get("zlevel") || 0, b = C.get("z") || 0, w = C.getZLevelKey();
          p = p || !!w, (y === "series" ? f : h).push({
            zlevel: S,
            z: b,
            idx: C.componentIndex,
            type: y,
            key: w
          });
        }), p) {
          var g = h.concat(f), v, m;
          n0(g, function(y, C) {
            return y.zlevel === C.zlevel ? y.z - C.z : y.zlevel - C.zlevel;
          }), $(g, function(y) {
            var C = d.getComponent(y.type, y.idx), S = y.zlevel, b = y.key;
            v != null && (S = Math.max(v, S)), b ? (S === v && b !== m && S++, m = b) : m && (S === v && S++, m = ""), v = S, C.setZLevel(S);
          });
        }
      }
      W1 = function(d, h, f, p, g) {
        n(h), jk(d, h, f, p, g), $(d._chartsViews, function(v) {
          v.__alive = !1;
        }), ry(d, h, f, p, g), $(d._chartsViews, function(v) {
          v.__alive || v.remove(h, f);
        });
      }, jk = function(d, h, f, p, g, v) {
        $(v || d._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, h, f, p), s(y, m), c(y, m);
        });
      }, ry = function(d, h, f, p, g, v) {
        var m = d._scheduler;
        g = ge(g || {}, {
          updatedSeries: h.getSeries()
        }), va.trigger("series:beforeupdate", h, f, g);
        var y = !1;
        h.eachSeries(function(C) {
          var S = d._chartsMap[C.__viewId];
          S.__alive = !0;
          var b = S.renderTask;
          m.updatePayload(b, p), u(C, S), v && v.get(C.uid) && b.dirty(), b.perform(m.getPerformArgs(b)) && (y = !0), S.group.silent = !!C.get("silent"), a(C, S), TN(C);
        }), m.unfinished = y || m.unfinished, va.trigger("series:layoutlabels", h, f, g), va.trigger("series:transition", h, f, g), h.eachSeries(function(C) {
          var S = d._chartsMap[C.__viewId];
          s(C, S), c(C, S);
        }), o(d, h), va.trigger("series:afterupdate", h, f, g);
      }, Do = function(d) {
        d[V1] = !0, d.getZr().wakeUp();
      }, Kk = function(d) {
        d[V1] && (d.getZr().storage.traverse(function(h) {
          Ph(h) || i(h);
        }), d[V1] = !1);
      };
      function i(d) {
        for (var h = [], f = d.currentStates, p = 0; p < f.length; p++) {
          var g = f[p];
          g === "emphasis" || g === "blur" || g === "select" || h.push(g);
        }
        d.selected && d.states.select && h.push("select"), d.hoverState === nw && d.states.emphasis ? h.push("emphasis") : d.hoverState === kv && d.states.blur && h.push("blur"), d.useStates(h);
      }
      function o(d, h) {
        var f = d._zr, p = f.storage, g = 0;
        p.traverse(function(v) {
          v.isGroup || g++;
        }), g > h.get("hoverLayerThreshold") && !nr.node && !nr.worker && h.eachSeries(function(v) {
          if (!v.preventUsingHoverLayer) {
            var m = d._chartsMap[v.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function a(d, h) {
        var f = d.get("blendMode") || null;
        h.eachRendered(function(p) {
          p.isGroup || (p.style.blend = f);
        });
      }
      function s(d, h) {
        if (!d.preventAutoZ) {
          var f = d.get("z") || 0, p = d.get("zlevel") || 0;
          h.eachRendered(function(g) {
            return l(g, f, p, -1 / 0), !0;
          });
        }
      }
      function l(d, h, f, p) {
        var g = d.getTextContent(), v = d.getTextGuideLine(), m = d.isGroup;
        if (m)
          for (var y = d.childrenRef(), C = 0; C < y.length; C++)
            p = Math.max(l(y[C], h, f, p), p);
        else
          d.z = h, d.zlevel = f, p = Math.max(d.z2, p);
        if (g && (g.z = h, g.zlevel = f, isFinite(p) && (g.z2 = p + 2)), v) {
          var S = d.textGuideLineConfig;
          v.z = h, v.zlevel = f, isFinite(p) && (v.z2 = p + (S && S.showAbove ? 1 : -1));
        }
        return p;
      }
      function u(d, h) {
        h.eachRendered(function(f) {
          if (!Ph(f)) {
            var p = f.getTextContent(), g = f.getTextGuideLine();
            f.stateTransition && (f.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), f.hasState() ? (f.prevStates = f.currentStates, f.clearStates()) : f.prevStates && (f.prevStates = null);
          }
        });
      }
      function c(d, h) {
        var f = d.getModel("stateAnimation"), p = d.isAnimationEnabled(), g = f.get("duration"), v = g > 0 ? {
          duration: g,
          delay: f.get("delay"),
          easing: f.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        h.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (Ph(m))
              return;
            if (m instanceof Ht && nwe(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (p) {
              m.stateTransition = v;
              var C = m.getTextContent(), S = m.getTextGuideLine();
              C && (C.stateTransition = v), S && (S.stateTransition = v);
            }
            m.__dirty && i(m);
          }
        });
      }
      Uk = function(d) {
        return new /** @class */
        (function(h) {
          le(f, h);
          function f() {
            return h !== null && h.apply(this, arguments) || this;
          }
          return f.prototype.getCoordinateSystems = function() {
            return d._coordSysMgr.getCoordinateSystems();
          }, f.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var g = p.__ecComponentInfo;
              if (g != null)
                return d._model.getComponent(g.mainType, g.index);
              p = p.parent;
            }
          }, f.prototype.enterEmphasis = function(p, g) {
            Qs(p, g), Do(d);
          }, f.prototype.leaveEmphasis = function(p, g) {
            Js(p, g), Do(d);
          }, f.prototype.enterBlur = function(p) {
            GW(p), Do(d);
          }, f.prototype.leaveBlur = function(p) {
            rD(p), Do(d);
          }, f.prototype.enterSelect = function(p) {
            zW(p), Do(d);
          }, f.prototype.leaveSelect = function(p) {
            WW(p), Do(d);
          }, f.prototype.getModel = function() {
            return d.getModel();
          }, f.prototype.getViewOfComponentModel = function(p) {
            return d.getViewOfComponentModel(p);
          }, f.prototype.getViewOfSeriesModel = function(p) {
            return d.getViewOfSeriesModel(p);
          }, f;
        }(H7))(d);
      }, N9 = function(d) {
        function h(f, p) {
          for (var g = 0; g < f.length; g++) {
            var v = f[g];
            v[B1] = p;
          }
        }
        $(fg, function(f, p) {
          d._messageCenter.on(p, function(g) {
            if (RC[d.group] && d[B1] !== Gk) {
              if (g && g.escapeConnect)
                return;
              var v = d.makeActionFromEvent(g), m = [];
              $(Dc, function(y) {
                y !== d && y.group === d.group && m.push(y);
              }), h(m, Gk), $(m, function(y) {
                y[B1] !== Oxe && y.dispatchAction(v);
              }), h(m, Lxe);
            }
          });
        });
      };
    }(), t;
  }(na)
), OD = bC.prototype;
OD.on = A9("on");
OD.off = A9("off");
OD.one = function(e, t, r) {
  var n = this;
  ea("ECharts#one is deprecated.");
  function i() {
    for (var o = [], a = 0; a < arguments.length; a++)
      o[a] = arguments[a];
    t && t.apply && t.apply(this, o), n.off(e, i);
  }
  this.on.call(this, e, i, r);
};
var Fxe = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function uo(e) {
  process.env.NODE_ENV !== "production" && nn("Instance " + e + " has been disposed");
}
var xC = {}, fg = {}, rT = [], nT = [], EC = [], k9 = {}, iT = {}, Dc = {}, RC = {}, Nxe = +/* @__PURE__ */ new Date() - 0, kxe = +/* @__PURE__ */ new Date() - 0, LD = "_echarts_instance_";
function Vxe(e, t, r) {
  var n = !(r && r.ssr);
  if (n) {
    if (process.env.NODE_ENV !== "production" && !e)
      throw new Error("Initialize failed: invalid dom.");
    var i = FD(e);
    if (i)
      return process.env.NODE_ENV !== "production" && nn("There is a chart instance already initialized on the dom."), i;
    process.env.NODE_ENV !== "production" && ru(e) && e.nodeName.toUpperCase() !== "CANVAS" && (!e.clientWidth && (!r || r.width == null) || !e.clientHeight && (!r || r.height == null)) && nn("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var o = new bC(e, t, r);
  return o.id = "ec_" + Nxe++, Dc[o.id] = o, n && wW(e, LD, o.id), N9(o), va.trigger("afterinit", o), o;
}
function Bxe(e) {
  if (be(e)) {
    var t = e;
    e = null, $(t, function(r) {
      r.group != null && (e = r.group);
    }), e = e || "g_" + kxe++, $(t, function(r) {
      r.group = e;
    });
  }
  return RC[e] = !0, e;
}
function V9(e) {
  RC[e] = !1;
}
var $xe = V9;
function Hxe(e) {
  He(e) ? e = Dc[e] : e instanceof bC || (e = FD(e)), e instanceof bC && !e.isDisposed() && e.dispose();
}
function FD(e) {
  return Dc[jCe(e, LD)];
}
function Gxe(e) {
  return Dc[e];
}
function ND(e, t) {
  k9[e] = t;
}
function kD(e) {
  Ft(nT, e) < 0 && nT.push(e);
}
function VD(e, t) {
  BD(rT, e, t, _xe);
}
function B9(e) {
  ww("afterinit", e);
}
function $9(e) {
  ww("afterupdate", e);
}
function ww(e, t) {
  va.on(e, t);
}
function Va(e, t, r) {
  at(t) && (r = t, t = "");
  var n = lt(e) ? e.type : [e, e = {
    event: t
  }][0];
  e.event = (e.event || n).toLowerCase(), t = e.event, !fg[t] && (ct(Hk.test(n) && Hk.test(t)), xC[n] || (xC[n] = {
    action: r,
    actionInfo: e
  }), fg[t] = n);
}
function H9(e, t) {
  ld.register(e, t);
}
function zxe(e) {
  var t = ld.get(e);
  if (t)
    return t.getDimensionsInfo ? t.getDimensionsInfo() : t.dimensions.slice();
}
function G9(e, t) {
  BD(EC, e, t, T9, "layout");
}
function bu(e, t) {
  BD(EC, e, t, P9, "visual");
}
var Yk = [];
function BD(e, t, r, n, i) {
  if ((at(t) || lt(t)) && (r = t, t = n), process.env.NODE_ENV !== "production") {
    if (isNaN(t) || t == null)
      throw new Error("Illegal priority");
    $(e, function(a) {
      ct(a.__raw !== r);
    });
  }
  if (!(Ft(Yk, r) >= 0)) {
    Yk.push(r);
    var o = p9.wrapStageHandler(r, i);
    o.__prio = t, o.__raw = r, e.push(o);
  }
}
function $D(e, t) {
  iT[e] = t;
}
function Wxe(e) {
  process.env.NODE_ENV !== "production" && ea("setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead."), T6({
    createCanvas: e
  });
}
function z9(e, t, r) {
  var n = _9("registerMap");
  n && n(e, t, r);
}
function jxe(e) {
  var t = _9("getMap");
  return t && t(e);
}
var W9 = n1e;
bu(ID, P1e);
bu(Sw, M1e);
bu(Sw, D1e);
bu(ID, z1e);
bu(Sw, W1e);
bu(M9, yxe);
kD(z7);
VD(Exe, kbe);
$D("default", A1e);
Va({
  type: Pc,
  event: Pc,
  update: Pc
}, un);
Va({
  type: l0,
  event: l0,
  update: l0
}, un);
Va({
  type: lg,
  event: lg,
  update: lg
}, un);
Va({
  type: u0,
  event: u0,
  update: u0
}, un);
Va({
  type: ug,
  event: ug,
  update: ug
}, un);
ND("light", H1e);
ND("dark", y9);
var Uxe = {}, qk = [], Kxe = {
  registerPreprocessor: kD,
  registerProcessor: VD,
  registerPostInit: B9,
  registerPostUpdate: $9,
  registerUpdateLifecycle: ww,
  registerAction: Va,
  registerCoordinateSystem: H9,
  registerLayout: G9,
  registerVisual: bu,
  registerTransform: W9,
  registerLoading: $D,
  registerMap: z9,
  registerImpl: Cxe,
  PRIORITY: D9,
  ComponentModel: Vt,
  ComponentView: zr,
  SeriesModel: Pr,
  ChartView: br,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(e) {
    Vt.registerClass(e);
  },
  registerComponentView: function(e) {
    zr.registerClass(e);
  },
  registerSeriesModel: function(e) {
    Pr.registerClass(e);
  },
  registerChartView: function(e) {
    br.registerClass(e);
  },
  registerSubTypeDefaulter: function(e, t) {
    Vt.registerSubTypeDefaulter(e, t);
  },
  registerPainter: function(e, t) {
    uW(e, t);
  }
};
function Bt(e) {
  if (be(e)) {
    $(e, function(t) {
      Bt(t);
    });
    return;
  }
  Ft(qk, e) >= 0 || (qk.push(e), at(e) && (e = {
    install: e
  }), e.install(Kxe));
}
function cp(e) {
  return e == null ? 0 : e.length || 1;
}
function Xk(e) {
  return e;
}
var el = (
  /** @class */
  function() {
    function e(t, r, n, i, o, a) {
      this._old = t, this._new = r, this._oldKeyGetter = n || Xk, this._newKeyGetter = i || Xk, this.context = o, this._diffModeMultiple = a === "multiple";
    }
    return e.prototype.add = function(t) {
      return this._add = t, this;
    }, e.prototype.update = function(t) {
      return this._update = t, this;
    }, e.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, e.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, e.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, e.prototype.remove = function(t) {
      return this._remove = t, this;
    }, e.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, e.prototype._executeOneToOne = function() {
      var t = this._old, r = this._new, n = {}, i = new Array(t.length), o = new Array(r.length);
      this._initIndexMap(t, null, i, "_oldKeyGetter"), this._initIndexMap(r, n, o, "_newKeyGetter");
      for (var a = 0; a < t.length; a++) {
        var s = i[a], l = n[s], u = cp(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[s] = l[0]), this._update && this._update(c, a);
        } else u === 1 ? (n[s] = null, this._update && this._update(l, a)) : this._remove && this._remove(a);
      }
      this._performRestAdd(o, n);
    }, e.prototype._executeMultiple = function() {
      var t = this._old, r = this._new, n = {}, i = {}, o = [], a = [];
      this._initIndexMap(t, n, o, "_oldKeyGetter"), this._initIndexMap(r, i, a, "_newKeyGetter");
      for (var s = 0; s < o.length; s++) {
        var l = o[s], u = n[l], c = i[l], d = cp(u), h = cp(c);
        if (d > 1 && h === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (d === 1 && h > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (d === 1 && h === 1)
          this._update && this._update(c, u), i[l] = null;
        else if (d > 1 && h > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (d > 1)
          for (var f = 0; f < d; f++)
            this._remove && this._remove(u[f]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(a, i);
    }, e.prototype._performRestAdd = function(t, r) {
      for (var n = 0; n < t.length; n++) {
        var i = t[n], o = r[i], a = cp(o);
        if (a > 1)
          for (var s = 0; s < a; s++)
            this._add && this._add(o[s]);
        else a === 1 && this._add && this._add(o);
        r[i] = null;
      }
    }, e.prototype._initIndexMap = function(t, r, n, i) {
      for (var o = this._diffModeMultiple, a = 0; a < t.length; a++) {
        var s = "_ec_" + this[i](t[a], a);
        if (o || (n[a] = s), !!r) {
          var l = r[s], u = cp(l);
          u === 0 ? (r[s] = a, o && n.push(s)) : u === 1 ? r[s] = [l, a] : l.push(a);
        }
      }
    }, e;
  }()
), Yxe = (
  /** @class */
  function() {
    function e(t, r) {
      this._encode = t, this._schema = r;
    }
    return e.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, e.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, e;
  }()
);
function qxe(e, t) {
  var r = {}, n = r.encode = {}, i = nt(), o = [], a = [], s = {};
  $(e.dimensions, function(h) {
    var f = e.getDimensionInfo(h), p = f.coordDim;
    if (p) {
      process.env.NODE_ENV !== "production" && ct(j_.get(p) == null);
      var g = f.coordDimIndex;
      j1(n, p)[g] = h, f.isExtraCoord || (i.set(p, 1), Xxe(f.type) && (o[0] = h), j1(s, p)[g] = e.getDimensionIndex(f.name)), f.defaultTooltip && a.push(h);
    }
    j_.each(function(v, m) {
      var y = j1(n, m), C = f.otherDims[m];
      C != null && C !== !1 && (y[C] = f.name);
    });
  });
  var l = [], u = {};
  i.each(function(h, f) {
    var p = n[f];
    u[f] = p[0], l = l.concat(p);
  }), r.dataDimsOnCoord = l, r.dataDimIndicesOnCoord = Ee(l, function(h) {
    return e.getDimensionInfo(h).storeDimIndex;
  }), r.encodeFirstDimNotExtra = u;
  var c = n.label;
  c && c.length && (o = c.slice());
  var d = n.tooltip;
  return d && d.length ? a = d.slice() : a.length || (a = o.slice()), n.defaultedLabel = o, n.defaultedTooltip = a, r.userOutput = new Yxe(s, t), r;
}
function j1(e, t) {
  return e.hasOwnProperty(t) || (e[t] = []), e[t];
}
function _C(e) {
  return e === "category" ? "ordinal" : e === "time" ? "time" : "float";
}
function Xxe(e) {
  return !(e === "ordinal" || e === "time");
}
var p0 = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.otherDims = {}, t != null && ge(this, t);
    }
    return e;
  }()
), Zxe = ar(), Qxe = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, j9 = (
  /** @class */
  function() {
    function e(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return e.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, e.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = Y9(this.source)));
    }, e.prototype.getSourceDimensionIndex = function(t) {
      return bt(this._dimNameMap.get(t), -1);
    }, e.prototype.getSourceDimension = function(t) {
      var r = this.source.dimensionsDefine;
      if (r)
        return r[t];
    }, e.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, r = j7(this.source), n = !q9(t), i = "", o = [], a = 0, s = 0; a < t; a++) {
        var l = void 0, u = void 0, c = void 0, d = this.dimensions[s];
        if (d && d.storeDimIndex === a)
          l = r ? d.name : null, u = d.type, c = d.ordinalMeta, s++;
        else {
          var h = this.getSourceDimension(a);
          h && (l = r ? h.name : null, u = h.type);
        }
        o.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), r && l != null && (!d || !d.isCalculationCoord) && (i += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += Qxe[u] || "f", c && (i += c.uid), i += "$";
      }
      var f = this.source, p = [f.seriesLayoutBy, f.startIndex, i].join("$$");
      return {
        dimensions: o,
        hash: p
      };
    }, e.prototype.makeOutputDimensionNames = function() {
      for (var t = [], r = 0, n = 0; r < this._fullDimCount; r++) {
        var i = void 0, o = this.dimensions[n];
        if (o && o.storeDimIndex === r)
          o.isCalculationCoord || (i = o.name), n++;
        else {
          var a = this.getSourceDimension(r);
          a && (i = a.name);
        }
        t.push(i);
      }
      return t;
    }, e.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, e;
  }()
);
function U9(e) {
  return e instanceof j9;
}
function K9(e) {
  for (var t = nt(), r = 0; r < (e || []).length; r++) {
    var n = e[r], i = lt(n) ? n.name : n;
    i != null && t.get(i) == null && t.set(i, r);
  }
  return t;
}
function Y9(e) {
  var t = Zxe(e);
  return t.dimNameMap || (t.dimNameMap = K9(e.dimensionsDefine));
}
function q9(e) {
  return e > 30;
}
var dp = lt, Sl = Ee, Jxe = typeof Int32Array > "u" ? Array : Int32Array, eEe = "e\0\0", Zk = -1, tEe = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], rEe = ["_approximateExtent"], Qk, ny, hp, Hd, U1, iy, K1, nEe = (
  /** @class */
  function() {
    function e(t, r) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
      var n, i = !1;
      U9(t) ? (n = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (i = !0, n = t), n = n || ["x", "y"];
      for (var o = {}, a = [], s = {}, l = !1, u = {}, c = 0; c < n.length; c++) {
        var d = n[c], h = He(d) ? new p0({
          name: d
        }) : d instanceof p0 ? d : new p0(d), f = h.name;
        h.type = h.type || "float", h.coordDim || (h.coordDim = f, h.coordDimIndex = 0);
        var p = h.otherDims = h.otherDims || {};
        a.push(f), o[f] = h, u[f] != null && (l = !0), h.createInvertedIndices && (s[f] = []), p.itemName === 0 && (this._nameDimIdx = c), p.itemId === 0 && (this._idDimIdx = c), process.env.NODE_ENV !== "production" && ct(i || h.storeDimIndex >= 0), i && (h.storeDimIndex = c);
      }
      if (this.dimensions = a, this._dimInfos = o, this._initGetDimensionInfo(l), this.hostModel = r, this._invertedIndicesMap = s, this._dimOmitted) {
        var g = this._dimIdxToName = nt();
        $(a, function(v) {
          g.set(o[v].storeDimIndex, v);
        });
      }
    }
    return e.prototype.getDimension = function(t) {
      var r = this._recognizeDimIndex(t);
      if (r == null)
        return t;
      if (r = t, !this._dimOmitted)
        return this.dimensions[r];
      var n = this._dimIdxToName.get(r);
      if (n != null)
        return n;
      var i = this._schema.getSourceDimension(r);
      if (i)
        return i.name;
    }, e.prototype.getDimensionIndex = function(t) {
      var r = this._recognizeDimIndex(t);
      if (r != null)
        return r;
      if (t == null)
        return -1;
      var n = this._getDimInfo(t);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, e.prototype._recognizeDimIndex = function(t) {
      if (sr(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        return +t;
    }, e.prototype._getStoreDimIndex = function(t) {
      var r = this.getDimensionIndex(t);
      if (process.env.NODE_ENV !== "production" && r == null)
        throw new Error("Unknown dimension " + t);
      return r;
    }, e.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, e.prototype._initGetDimensionInfo = function(t) {
      var r = this._dimInfos;
      this._getDimInfo = t ? function(n) {
        return r.hasOwnProperty(n) ? r[n] : void 0;
      } : function(n) {
        return r[n];
      };
    }, e.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, e.prototype.mapDimension = function(t, r) {
      var n = this._dimSummary;
      if (r == null)
        return n.encodeFirstDimNotExtra[t];
      var i = n.encode[t];
      return i ? i[r] : null;
    }, e.prototype.mapDimensionsAll = function(t) {
      var r = this._dimSummary, n = r.encode[t];
      return (n || []).slice();
    }, e.prototype.getStore = function() {
      return this._store;
    }, e.prototype.initData = function(t, r, n) {
      var i = this, o;
      if (t instanceof q_ && (o = t), !o) {
        var a = this.dimensions, s = RD(t) || Jn(t) ? new U7(t, a.length) : t;
        o = new q_();
        var l = Sl(a, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        o.initData(s, l, n);
      }
      this._store = o, this._nameList = (r || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, o.count()), this._dimSummary = qxe(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, e.prototype.appendData = function(t) {
      var r = this._store.appendData(t);
      this._doInit(r[0], r[1]);
    }, e.prototype.appendValues = function(t, r) {
      var n = this._store.appendValues(t, r.length), i = n.start, o = n.end, a = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), r)
        for (var s = i; s < o; s++) {
          var l = s - i;
          this._nameList[s] = r[l], a && K1(this, s);
        }
    }, e.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, r = this.dimensions, n = 0; n < r.length; n++) {
        var i = this._dimInfos[r[n]];
        i.ordinalMeta && t.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, e.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== zs && !t.fillStorage;
    }, e.prototype._doInit = function(t, r) {
      if (!(t >= r)) {
        var n = this._store, i = n.getProvider();
        this._updateOrdinalMeta();
        var o = this._nameList, a = this._idList, s = i.getSource().sourceFormat, l = s === oa;
        if (l && !i.pure)
          for (var u = [], c = t; c < r; c++) {
            var d = i.getItem(c, u);
            if (!this.hasItemOption && ICe(d) && (this.hasItemOption = !0), d) {
              var h = d.name;
              o[c] == null && h != null && (o[c] = In(h, null));
              var f = d.id;
              a[c] == null && f != null && (a[c] = In(f, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = t; c < r; c++)
            K1(this, c);
        Qk(this);
      }
    }, e.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.setApproximateExtent = function(t, r) {
      r = this.getDimension(r), this._approximateExtent[r] = t.slice();
    }, e.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, e.prototype.setCalculationInfo = function(t, r) {
      dp(t) ? ge(this._calculationInfo, t) : this._calculationInfo[t] = r;
    }, e.prototype.getName = function(t) {
      var r = this.getRawIndex(t), n = this._nameList[r];
      return n == null && this._nameDimIdx != null && (n = hp(this, this._nameDimIdx, r)), n == null && (n = ""), n;
    }, e.prototype._getCategory = function(t, r) {
      var n = this._store.get(t, r), i = this._store.getOrdinalMeta(t);
      return i ? i.categories[n] : n;
    }, e.prototype.getId = function(t) {
      return ny(this, this.getRawIndex(t));
    }, e.prototype.count = function() {
      return this._store.count();
    }, e.prototype.get = function(t, r) {
      var n = this._store, i = this._dimInfos[t];
      if (i)
        return n.get(i.storeDimIndex, r);
    }, e.prototype.getByRawIndex = function(t, r) {
      var n = this._store, i = this._dimInfos[t];
      if (i)
        return n.getByRawIndex(i.storeDimIndex, r);
    }, e.prototype.getIndices = function() {
      return this._store.getIndices();
    }, e.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, e.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, e.prototype.getValues = function(t, r) {
      var n = this, i = this._store;
      return be(t) ? i.getValues(Sl(t, function(o) {
        return n._getStoreDimIndex(o);
      }), r) : i.getValues(t);
    }, e.prototype.hasValue = function(t) {
      for (var r = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = r.length; n < i; n++)
        if (isNaN(this._store.get(r[n], t)))
          return !1;
      return !0;
    }, e.prototype.indexOfName = function(t) {
      for (var r = 0, n = this._store.count(); r < n; r++)
        if (this.getName(r) === t)
          return r;
      return -1;
    }, e.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, e.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, e.prototype.rawIndexOf = function(t, r) {
      var n = t && this._invertedIndicesMap[t];
      if (process.env.NODE_ENV !== "production" && !n)
        throw new Error("Do not supported yet");
      var i = n[r];
      return i == null || isNaN(i) ? Zk : i;
    }, e.prototype.indicesOfNearest = function(t, r, n) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(t), r, n);
    }, e.prototype.each = function(t, r, n) {
      at(t) && (n = r, r = t, t = []);
      var i = n || this, o = Sl(Hd(t), this._getStoreDimIndex, this);
      this._store.each(o, i ? je(r, i) : r);
    }, e.prototype.filterSelf = function(t, r, n) {
      at(t) && (n = r, r = t, t = []);
      var i = n || this, o = Sl(Hd(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(o, i ? je(r, i) : r), this;
    }, e.prototype.selectRange = function(t) {
      var r = this, n = {}, i = jt(t);
      return $(i, function(o) {
        var a = r._getStoreDimIndex(o);
        n[a] = t[o];
      }), this._store = this._store.selectRange(n), this;
    }, e.prototype.mapArray = function(t, r, n) {
      at(t) && (n = r, r = t, t = []), n = n || this;
      var i = [];
      return this.each(t, function() {
        i.push(r && r.apply(this, arguments));
      }, n), i;
    }, e.prototype.map = function(t, r, n, i) {
      var o = n || i || this, a = Sl(Hd(t), this._getStoreDimIndex, this), s = iy(this);
      return s._store = this._store.map(a, o ? je(r, o) : r), s;
    }, e.prototype.modify = function(t, r, n, i) {
      var o = this, a = n || i || this;
      process.env.NODE_ENV !== "production" && $(Hd(t), function(l) {
        var u = o.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var s = Sl(Hd(t), this._getStoreDimIndex, this);
      this._store.modify(s, a ? je(r, a) : r);
    }, e.prototype.downSample = function(t, r, n, i) {
      var o = iy(this);
      return o._store = this._store.downSample(this._getStoreDimIndex(t), r, n, i), o;
    }, e.prototype.lttbDownSample = function(t, r) {
      var n = iy(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), r), n;
    }, e.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, e.prototype.getItemModel = function(t) {
      var r = this.hostModel, n = this.getRawDataItem(t);
      return new _r(n, r, r && r.ecModel);
    }, e.prototype.diff = function(t) {
      var r = this;
      return new el(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return ny(t, n);
      }, function(n) {
        return ny(r, n);
      });
    }, e.prototype.getVisual = function(t) {
      var r = this._visual;
      return r && r[t];
    }, e.prototype.setVisual = function(t, r) {
      this._visual = this._visual || {}, dp(t) ? ge(this._visual, t) : this._visual[t] = r;
    }, e.prototype.getItemVisual = function(t, r) {
      var n = this._itemVisuals[t], i = n && n[r];
      return i ?? this.getVisual(r);
    }, e.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, e.prototype.ensureUniqueItemVisual = function(t, r) {
      var n = this._itemVisuals, i = n[t];
      i || (i = n[t] = {});
      var o = i[r];
      return o == null && (o = this.getVisual(r), be(o) ? o = o.slice() : dp(o) && (o = ge({}, o)), i[r] = o), o;
    }, e.prototype.setItemVisual = function(t, r, n) {
      var i = this._itemVisuals[t] || {};
      this._itemVisuals[t] = i, dp(r) ? ge(i, r) : i[r] = n;
    }, e.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, e.prototype.setLayout = function(t, r) {
      dp(t) ? ge(this._layout, t) : this._layout[t] = r;
    }, e.prototype.getLayout = function(t) {
      return this._layout[t];
    }, e.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, e.prototype.setItemLayout = function(t, r, n) {
      this._itemLayouts[t] = n ? ge(this._itemLayouts[t] || {}, r) : r;
    }, e.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, e.prototype.setItemGraphicEl = function(t, r) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      F_(n, this.dataType, t, r), this._graphicEls[t] = r;
    }, e.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, e.prototype.eachItemGraphicEl = function(t, r) {
      $(this._graphicEls, function(n, i) {
        n && t && t.call(r, n, i);
      });
    }, e.prototype.cloneShallow = function(t) {
      return t || (t = new e(this._schema ? this._schema : Sl(this.dimensions, this._getDimInfo, this), this.hostModel)), U1(t, this), t._store = this._store, t;
    }, e.prototype.wrapMethod = function(t, r) {
      var n = this[t];
      at(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var i = n.apply(this, arguments);
        return r.apply(this, [i].concat(WS(arguments)));
      });
    }, e.internalField = function() {
      Qk = function(t) {
        var r = t._invertedIndicesMap;
        $(r, function(n, i) {
          var o = t._dimInfos[i], a = o.ordinalMeta, s = t._store;
          if (a) {
            n = r[i] = new Jxe(a.categories.length);
            for (var l = 0; l < n.length; l++)
              n[l] = Zk;
            for (var l = 0; l < s.count(); l++)
              n[s.get(o.storeDimIndex, l)] = l;
          }
        });
      }, hp = function(t, r, n) {
        return In(t._getCategory(r, n), null);
      }, ny = function(t, r) {
        var n = t._idList[r];
        return n == null && t._idDimIdx != null && (n = hp(t, t._idDimIdx, r)), n == null && (n = eEe + r), n;
      }, Hd = function(t) {
        return be(t) || (t = t != null ? [t] : []), t;
      }, iy = function(t) {
        var r = new e(t._schema ? t._schema : Sl(t.dimensions, t._getDimInfo, t), t.hostModel);
        return U1(r, t), r;
      }, U1 = function(t, r) {
        $(tEe.concat(r.__wrappedMethods || []), function(n) {
          r.hasOwnProperty(n) && (t[n] = r[n]);
        }), t.__wrappedMethods = r.__wrappedMethods, $(rEe, function(n) {
          t[n] = dt(r[n]);
        }), t._calculationInfo = ge({}, r._calculationInfo);
      }, K1 = function(t, r) {
        var n = t._nameList, i = t._idList, o = t._nameDimIdx, a = t._idDimIdx, s = n[r], l = i[r];
        if (s == null && o != null && (n[r] = s = hp(t, o, r)), l == null && a != null && (i[r] = l = hp(t, a, r)), l == null && s != null) {
          var u = t._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), i[r] = l;
        }
      };
    }(), e;
  }()
);
const di = nEe;
function iEe(e, t) {
  return Tf(e, t).dimensions;
}
function Tf(e, t) {
  RD(e) || (e = _D(e)), t = t || {};
  var r = t.coordDimensions || [], n = t.dimensionsDefine || e.dimensionsDefine || [], i = nt(), o = [], a = aEe(e, r, n, t.dimensionsCount), s = t.canOmitUnusedDimensions && q9(a), l = n === e.dimensionsDefine, u = l ? Y9(e) : K9(n), c = t.encodeDefine;
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(e, a));
  for (var d = nt(c), h = new e9(a), f = 0; f < h.length; f++)
    h[f] = -1;
  function p(_) {
    var T = h[_];
    if (T < 0) {
      var P = n[_], D = lt(P) ? P : {
        name: P
      }, O = new p0(), A = D.name;
      A != null && u.get(A) != null && (O.name = O.displayName = A), D.type != null && (O.type = D.type), D.displayName != null && (O.displayName = D.displayName);
      var F = o.length;
      return h[_] = F, O.storeDimIndex = _, o.push(O), O;
    }
    return o[T];
  }
  if (!s)
    for (var f = 0; f < a; f++)
      p(f);
  d.each(function(_, T) {
    var P = Tr(_).slice();
    if (P.length === 1 && !He(P[0]) && P[0] < 0) {
      d.set(T, !1);
      return;
    }
    var D = d.set(T, []);
    $(P, function(O, A) {
      var F = He(O) ? u.get(O) : O;
      F != null && F < a && (D[A] = F, v(p(F), T, A));
    });
  });
  var g = 0;
  $(r, function(_) {
    var T, P, D, O;
    if (He(_))
      T = _, O = {};
    else {
      O = _, T = O.name;
      var A = O.ordinalMeta;
      O.ordinalMeta = null, O = ge({}, O), O.ordinalMeta = A, P = O.dimsDef, D = O.otherDims, O.name = O.coordDim = O.coordDimIndex = O.dimsDef = O.otherDims = null;
    }
    var F = d.get(T);
    if (F !== !1) {
      if (F = Tr(F), !F.length)
        for (var L = 0; L < (P && P.length || 1); L++) {
          for (; g < a && p(g).coordDim != null; )
            g++;
          g < a && F.push(g++);
        }
      $(F, function(N, I) {
        var B = p(N);
        if (l && O.type != null && (B.type = O.type), v(ut(B, O), T, I), B.name == null && P) {
          var M = P[I];
          !lt(M) && (M = {
            name: M
          }), B.name = B.displayName = M.name, B.defaultTooltip = M.defaultTooltip;
        }
        D && ut(B.otherDims, D);
      });
    }
  });
  function v(_, T, P) {
    j_.get(T) != null ? _.otherDims[T] = P : (_.coordDim = T, _.coordDimIndex = P, i.set(T, !0));
  }
  var m = t.generateCoord, y = t.generateCoordCount, C = y != null;
  y = m ? y || 1 : 0;
  var S = m || "value";
  function b(_) {
    _.name == null && (_.name = _.coordDim);
  }
  if (s)
    $(o, function(_) {
      b(_);
    }), o.sort(function(_, T) {
      return _.storeDimIndex - T.storeDimIndex;
    });
  else
    for (var w = 0; w < a; w++) {
      var x = p(w), R = x.coordDim;
      R == null && (x.coordDim = sEe(S, i, C), x.coordDimIndex = 0, (!m || y <= 0) && (x.isExtraCoord = !0), y--), b(x), x.type == null && (V7(e, w) === Xn.Must || x.isExtraCoord && (x.otherDims.itemName != null || x.otherDims.seriesName != null)) && (x.type = "ordinal");
    }
  return oEe(o), new j9({
    source: e,
    dimensions: o,
    fullDimensionCount: a,
    dimensionOmitted: s
  });
}
function oEe(e) {
  for (var t = nt(), r = 0; r < e.length; r++) {
    var n = e[r], i = n.name, o = t.get(i) || 0;
    o > 0 && (n.name = i + (o - 1)), o++, t.set(i, o);
  }
}
function aEe(e, t, r, n) {
  var i = Math.max(e.dimensionsDetectedCount || 1, t.length, r.length, n || 0);
  return $(t, function(o) {
    var a;
    lt(o) && (a = o.dimsDef) && (i = Math.max(i, a.length));
  }), i;
}
function sEe(e, t, r) {
  if (r || t.hasKey(e)) {
    for (var n = 0; t.hasKey(e + n); )
      n++;
    e += n;
  }
  return t.set(e, !0), e;
}
var lEe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.coordSysDims = [], this.axisMap = nt(), this.categoryAxisMap = nt(), this.coordSysName = t;
    }
    return e;
  }()
);
function uEe(e) {
  var t = e.get("coordinateSystem"), r = new lEe(t), n = cEe[t];
  if (n)
    return n(e, r, r.axisMap, r.categoryAxisMap), r;
}
var cEe = {
  cartesian2d: function(e, t, r, n) {
    var i = e.getReferringComponents("xAxis", bn).models[0], o = e.getReferringComponents("yAxis", bn).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!i)
        throw new Error('xAxis "' + vn(e.get("xAxisIndex"), e.get("xAxisId"), 0) + '" not found');
      if (!o)
        throw new Error('yAxis "' + vn(e.get("xAxisIndex"), e.get("yAxisId"), 0) + '" not found');
    }
    t.coordSysDims = ["x", "y"], r.set("x", i), r.set("y", o), Gd(i) && (n.set("x", i), t.firstCategoryDimIndex = 0), Gd(o) && (n.set("y", o), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  singleAxis: function(e, t, r, n) {
    var i = e.getReferringComponents("singleAxis", bn).models[0];
    if (process.env.NODE_ENV !== "production" && !i)
      throw new Error("singleAxis should be specified.");
    t.coordSysDims = ["single"], r.set("single", i), Gd(i) && (n.set("single", i), t.firstCategoryDimIndex = 0);
  },
  polar: function(e, t, r, n) {
    var i = e.getReferringComponents("polar", bn).models[0], o = i.findAxisModel("radiusAxis"), a = i.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!a)
        throw new Error("angleAxis option not found");
      if (!o)
        throw new Error("radiusAxis option not found");
    }
    t.coordSysDims = ["radius", "angle"], r.set("radius", o), r.set("angle", a), Gd(o) && (n.set("radius", o), t.firstCategoryDimIndex = 0), Gd(a) && (n.set("angle", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  geo: function(e, t, r, n) {
    t.coordSysDims = ["lng", "lat"];
  },
  parallel: function(e, t, r, n) {
    var i = e.ecModel, o = i.getComponent("parallel", e.get("parallelIndex")), a = t.coordSysDims = o.dimensions.slice();
    $(o.parallelAxisIndex, function(s, l) {
      var u = i.getComponent("parallelAxis", s), c = a[l];
      r.set(c, u), Gd(u) && (n.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
    });
  }
};
function Gd(e) {
  return e.get("type") === "category";
}
function X9(e, t, r) {
  r = r || {};
  var n = r.byIndex, i = r.stackedCoordDimension, o, a, s;
  dEe(t) ? o = t : (a = t.schema, o = a.dimensions, s = t.store);
  var l = !!(e && e.get("stack")), u, c, d, h;
  if ($(o, function(y, C) {
    He(y) && (o[C] = y = {
      name: y
    }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
  }), c && !n && !u && (n = !0), c) {
    d = "__\0ecstackresult_" + e.id, h = "__\0ecstackedover_" + e.id, u && (u.createInvertedIndices = !0);
    var f = c.coordDim, p = c.type, g = 0;
    $(o, function(y) {
      y.coordDim === f && g++;
    });
    var v = {
      name: d,
      coordDim: f,
      coordDimIndex: g,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: o.length
    }, m = {
      name: h,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: h,
      coordDimIndex: g + 1,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: o.length + 1
    };
    a ? (s && (v.storeDimIndex = s.ensureCalculationDimension(h, p), m.storeDimIndex = s.ensureCalculationDimension(d, p)), a.appendCalculationDimension(v), a.appendCalculationDimension(m)) : (o.push(v), o.push(m));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: h,
    stackResultDimension: d
  };
}
function dEe(e) {
  return !U9(e.schema);
}
function tl(e, t) {
  return !!t && t === e.getCalculationInfo("stackedDimension");
}
function HD(e, t) {
  return tl(e, t) ? e.getCalculationInfo("stackResultDimension") : t;
}
function hEe(e, t) {
  var r = e.get("coordinateSystem"), n = ld.get(r), i;
  return t && t.coordSysDims && (i = Ee(t.coordSysDims, function(o) {
    var a = {
      name: o
    }, s = t.axisMap.get(o);
    if (s) {
      var l = s.get("type");
      a.type = _C(l);
    }
    return a;
  })), i || (i = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || ["x", "y"]), i;
}
function fEe(e, t, r) {
  var n, i;
  return r && $(e, function(o, a) {
    var s = o.coordDim, l = r.categoryAxisMap.get(s);
    l && (n == null && (n = a), o.ordinalMeta = l.getOrdinalMeta(), t && (o.createInvertedIndices = !0)), o.otherDims.itemName != null && (i = !0);
  }), !i && n != null && (e[n].otherDims.itemName = 0), n;
}
function ws(e, t, r) {
  r = r || {};
  var n = t.getSourceManager(), i, o = !1;
  e ? (o = !0, i = _D(e)) : (i = n.getSource(), o = i.sourceFormat === oa);
  var a = uEe(t), s = hEe(t, a), l = r.useEncodeDefaulter, u = at(l) ? l : l ? _t(k7, s, t) : null, c = {
    coordDimensions: s,
    generateCoord: r.generateCoord,
    encodeDefine: t.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !o
  }, d = Tf(i, c), h = fEe(d.dimensions, r.createInvertedIndices, a), f = o ? null : n.getSharedDataStore(d), p = X9(t, {
    schema: d,
    store: f
  }), g = new di(d, t);
  g.setCalculationInfo(p);
  var v = h != null && pEe(i) ? function(m, y, C, S) {
    return S === h ? C : this.defaultDimValueGetter(m, y, C, S);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    o ? i : f,
    null,
    v
  ), g;
}
function pEe(e) {
  if (e.sourceFormat === oa) {
    var t = gEe(e.data || []);
    return !be(pf(t));
  }
}
function gEe(e) {
  for (var t = 0; t < e.length && e[t] == null; )
    t++;
  return e[t];
}
var bs = (
  /** @class */
  function() {
    function e(t) {
      this._setting = t || {}, this._extent = [1 / 0, -1 / 0];
    }
    return e.prototype.getSetting = function(t) {
      return this._setting[t];
    }, e.prototype.unionExtent = function(t) {
      var r = this._extent;
      t[0] < r[0] && (r[0] = t[0]), t[1] > r[1] && (r[1] = t[1]);
    }, e.prototype.unionExtentFromData = function(t, r) {
      this.unionExtent(t.getApproximateExtent(r));
    }, e.prototype.getExtent = function() {
      return this._extent.slice();
    }, e.prototype.setExtent = function(t, r) {
      var n = this._extent;
      isNaN(t) || (n[0] = t), isNaN(r) || (n[1] = r);
    }, e.prototype.isInExtentRange = function(t) {
      return this._extent[0] <= t && this._extent[1] >= t;
    }, e.prototype.isBlank = function() {
      return this._isBlank;
    }, e.prototype.setBlank = function(t) {
      this._isBlank = t;
    }, e;
  }()
);
JS(bs);
var vEe = 0, oT = (
  /** @class */
  function() {
    function e(t) {
      this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this.uid = ++vEe;
    }
    return e.createByAxisModel = function(t) {
      var r = t.option, n = r.data, i = n && Ee(n, mEe);
      return new e({
        categories: i,
        needCollect: !i,
        // deduplication is default in axis.
        deduplication: r.dedplication !== !1
      });
    }, e.prototype.getOrdinal = function(t) {
      return this._getOrCreateMap().get(t);
    }, e.prototype.parseAndCollect = function(t) {
      var r, n = this._needCollect;
      if (!He(t) && !n)
        return t;
      if (n && !this._deduplication)
        return r = this.categories.length, this.categories[r] = t, r;
      var i = this._getOrCreateMap();
      return r = i.get(t), r == null && (n ? (r = this.categories.length, this.categories[r] = t, i.set(t, r)) : r = NaN), r;
    }, e.prototype._getOrCreateMap = function() {
      return this._map || (this._map = nt(this.categories));
    }, e;
  }()
);
function mEe(e) {
  return lt(e) && e.value != null ? e.value : e + "";
}
function yEe(e) {
  var t = Math.pow(10, Fv(Math.abs(e))), r = Math.abs(e / t);
  return r === 0 || r === 1 || r === 2 || r === 3 || r === 5;
}
function aT(e) {
  return e.type === "interval" || e.type === "log";
}
function CEe(e, t, r, n) {
  var i = {}, o = e[1] - e[0], a = i.interval = KM(o / t, !0);
  r != null && a < r && (a = i.interval = r), n != null && a > n && (a = i.interval = n);
  var s = i.intervalPrecision = Z9(a), l = i.niceTickExtent = [an(Math.ceil(e[0] / a) * a, s), an(Math.floor(e[1] / a) * a, s)];
  return SEe(l, e), i;
}
function Y1(e) {
  var t = Math.pow(10, Fv(e)), r = e / t;
  return r ? r === 2 ? r = 3 : r === 3 ? r = 5 : r *= 2 : r = 1, an(r * t);
}
function Z9(e) {
  return ba(e) + 2;
}
function Jk(e, t, r) {
  e[t] = Math.max(Math.min(e[t], r[1]), r[0]);
}
function SEe(e, t) {
  !isFinite(e[0]) && (e[0] = t[0]), !isFinite(e[1]) && (e[1] = t[1]), Jk(e, 0, t), Jk(e, 1, t), e[0] > e[1] && (e[0] = e[1]);
}
function bw(e, t) {
  return e >= t[0] && e <= t[1];
}
function xw(e, t) {
  return t[1] === t[0] ? 0.5 : (e - t[0]) / (t[1] - t[0]);
}
function Ew(e, t) {
  return e * (t[1] - t[0]) + t[0];
}
var Rw = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      n.type = "ordinal";
      var i = n.getSetting("ordinalMeta");
      return i || (i = new oT({})), be(i) && (i = new oT({
        categories: Ee(i, function(o) {
          return lt(o) ? o.value : o;
        })
      })), n._ordinalMeta = i, n._extent = n.getSetting("extent") || [0, i.categories.length - 1], n;
    }
    return t.prototype.parse = function(r) {
      return r == null ? NaN : He(r) ? this._ordinalMeta.getOrdinal(r) : Math.round(r);
    }, t.prototype.contain = function(r) {
      return r = this.parse(r), bw(r, this._extent) && this._ordinalMeta.categories[r] != null;
    }, t.prototype.normalize = function(r) {
      return r = this._getTickNumber(this.parse(r)), xw(r, this._extent);
    }, t.prototype.scale = function(r) {
      return r = Math.round(Ew(r, this._extent)), this.getRawOrdinalNumber(r);
    }, t.prototype.getTicks = function() {
      for (var r = [], n = this._extent, i = n[0]; i <= n[1]; )
        r.push({
          value: i
        }), i++;
      return r;
    }, t.prototype.getMinorTicks = function(r) {
    }, t.prototype.setSortInfo = function(r) {
      if (r == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var n = r.ordinalNumbers, i = this._ordinalNumbersByTick = [], o = this._ticksByOrdinalNumber = [], a = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, n.length); a < l; ++a) {
        var u = n[a];
        i[a] = u, o[u] = a;
      }
      for (var c = 0; a < s; ++a) {
        for (; o[c] != null; )
          c++;
        i.push(c), o[c] = a;
      }
    }, t.prototype._getTickNumber = function(r) {
      var n = this._ticksByOrdinalNumber;
      return n && r >= 0 && r < n.length ? n[r] : r;
    }, t.prototype.getRawOrdinalNumber = function(r) {
      var n = this._ordinalNumbersByTick;
      return n && r >= 0 && r < n.length ? n[r] : r;
    }, t.prototype.getLabel = function(r) {
      if (!this.isBlank()) {
        var n = this.getRawOrdinalNumber(r.value), i = this._ordinalMeta.categories[n];
        return i == null ? "" : i + "";
      }
    }, t.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, t.prototype.unionExtentFromData = function(r, n) {
      this.unionExtent(r.getApproximateExtent(n));
    }, t.prototype.isInExtentRange = function(r) {
      return r = this._getTickNumber(r), this._extent[0] <= r && this._extent[1] >= r;
    }, t.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, t.prototype.calcNiceTicks = function() {
    }, t.prototype.calcNiceExtent = function() {
    }, t.type = "ordinal", t;
  }(bs)
);
bs.registerClass(Rw);
var ju = an, rl = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "interval", r._interval = 0, r._intervalPrecision = 2, r;
    }
    return t.prototype.parse = function(r) {
      return r;
    }, t.prototype.contain = function(r) {
      return bw(r, this._extent);
    }, t.prototype.normalize = function(r) {
      return xw(r, this._extent);
    }, t.prototype.scale = function(r) {
      return Ew(r, this._extent);
    }, t.prototype.setExtent = function(r, n) {
      var i = this._extent;
      isNaN(r) || (i[0] = parseFloat(r)), isNaN(n) || (i[1] = parseFloat(n));
    }, t.prototype.unionExtent = function(r) {
      var n = this._extent;
      r[0] < n[0] && (n[0] = r[0]), r[1] > n[1] && (n[1] = r[1]), this.setExtent(n[0], n[1]);
    }, t.prototype.getInterval = function() {
      return this._interval;
    }, t.prototype.setInterval = function(r) {
      this._interval = r, this._niceExtent = this._extent.slice(), this._intervalPrecision = Z9(r);
    }, t.prototype.getTicks = function(r) {
      var n = this._interval, i = this._extent, o = this._niceExtent, a = this._intervalPrecision, s = [];
      if (!n)
        return s;
      var l = 1e4;
      i[0] < o[0] && (r ? s.push({
        value: ju(o[0] - n, a)
      }) : s.push({
        value: i[0]
      }));
      for (var u = o[0]; u <= o[1] && (s.push({
        value: u
      }), u = ju(u + n, a), u !== s[s.length - 1].value); )
        if (s.length > l)
          return [];
      var c = s.length ? s[s.length - 1].value : o[1];
      return i[1] > c && (r ? s.push({
        value: ju(c + n, a)
      }) : s.push({
        value: i[1]
      })), s;
    }, t.prototype.getMinorTicks = function(r) {
      for (var n = this.getTicks(!0), i = [], o = this.getExtent(), a = 1; a < n.length; a++) {
        for (var s = n[a], l = n[a - 1], u = 0, c = [], d = s.value - l.value, h = d / r; u < r - 1; ) {
          var f = ju(l.value + (u + 1) * h);
          f > o[0] && f < o[1] && c.push(f), u++;
        }
        i.push(c);
      }
      return i;
    }, t.prototype.getLabel = function(r, n) {
      if (r == null)
        return "";
      var i = n && n.precision;
      i == null ? i = ba(r.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var o = ju(r.value, i, !0);
      return mD(o);
    }, t.prototype.calcNiceTicks = function(r, n, i) {
      r = r || 5;
      var o = this._extent, a = o[1] - o[0];
      if (isFinite(a)) {
        a < 0 && (a = -a, o.reverse());
        var s = CEe(o, r, n, i);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, t.prototype.calcNiceExtent = function(r) {
      var n = this._extent;
      if (n[0] === n[1])
        if (n[0] !== 0) {
          var i = Math.abs(n[0]);
          r.fixMax || (n[1] += i / 2), n[0] -= i / 2;
        } else
          n[1] = 1;
      var o = n[1] - n[0];
      isFinite(o) || (n[0] = 0, n[1] = 1), this.calcNiceTicks(r.splitNumber, r.minInterval, r.maxInterval);
      var a = this._interval;
      r.fixMin || (n[0] = ju(Math.floor(n[0] / a) * a)), r.fixMax || (n[1] = ju(Math.ceil(n[1] / a) * a));
    }, t.prototype.setNiceExtent = function(r, n) {
      this._niceExtent = [r, n];
    }, t.type = "interval", t;
  }(bs)
);
bs.registerClass(rl);
var Q9 = typeof Float32Array < "u", wEe = Q9 ? Float32Array : Array;
function is(e) {
  return be(e) ? Q9 ? new Float32Array(e) : e : new wEe(e);
}
var sT = "__ec_stack_";
function GD(e) {
  return e.get("stack") || sT + e.seriesIndex;
}
function zD(e) {
  return e.dim + e.index;
}
function bEe(e) {
  var t = [], r = e.axis, n = "axis0";
  if (r.type === "category") {
    for (var i = r.getBandWidth(), o = 0; o < e.count; o++)
      t.push(ut({
        bandWidth: i,
        axisKey: n,
        stackId: sT + o
      }, e));
    for (var a = tj(t), s = [], o = 0; o < e.count; o++) {
      var l = a[n][sT + o];
      l.offsetCenter = l.offset + l.width / 2, s.push(l);
    }
    return s;
  }
}
function J9(e, t) {
  var r = [];
  return t.eachSeriesByType(e, function(n) {
    ij(n) && r.push(n);
  }), r;
}
function xEe(e) {
  var t = {};
  $(e, function(l) {
    var u = l.coordinateSystem, c = u.getBaseAxis();
    if (!(c.type !== "time" && c.type !== "value"))
      for (var d = l.getData(), h = c.dim + "_" + c.index, f = d.getDimensionIndex(d.mapDimension(c.dim)), p = d.getStore(), g = 0, v = p.count(); g < v; ++g) {
        var m = p.get(f, g);
        t[h] ? t[h].push(m) : t[h] = [m];
      }
  });
  var r = {};
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var i = t[n];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var o = null, a = 1; a < i.length; ++a) {
          var s = i[a] - i[a - 1];
          s > 0 && (o = o === null ? s : Math.min(o, s));
        }
        r[n] = o;
      }
    }
  return r;
}
function ej(e) {
  var t = xEe(e), r = [];
  return $(e, function(n) {
    var i = n.coordinateSystem, o = i.getBaseAxis(), a = o.getExtent(), s;
    if (o.type === "category")
      s = o.getBandWidth();
    else if (o.type === "value" || o.type === "time") {
      var l = o.dim + "_" + o.index, u = t[l], c = Math.abs(a[1] - a[0]), d = o.scale.getExtent(), h = Math.abs(d[1] - d[0]);
      s = u ? c / h * u : c;
    } else {
      var f = n.getData();
      s = Math.abs(a[1] - a[0]) / f.count();
    }
    var p = Be(n.get("barWidth"), s), g = Be(n.get("barMaxWidth"), s), v = Be(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      n.get("barMinWidth") || (oj(n) ? 0.5 : 1),
      s
    ), m = n.get("barGap"), y = n.get("barCategoryGap");
    r.push({
      bandWidth: s,
      barWidth: p,
      barMaxWidth: g,
      barMinWidth: v,
      barGap: m,
      barCategoryGap: y,
      axisKey: zD(o),
      stackId: GD(n)
    });
  }), tj(r);
}
function tj(e) {
  var t = {};
  $(e, function(n, i) {
    var o = n.axisKey, a = n.bandWidth, s = t[o] || {
      bandWidth: a,
      remainedWidth: a,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    }, l = s.stacks;
    t[o] = s;
    var u = n.stackId;
    l[u] || s.autoWidthCount++, l[u] = l[u] || {
      width: 0,
      maxWidth: 0
    };
    var c = n.barWidth;
    c && !l[u].width && (l[u].width = c, c = Math.min(s.remainedWidth, c), s.remainedWidth -= c);
    var d = n.barMaxWidth;
    d && (l[u].maxWidth = d);
    var h = n.barMinWidth;
    h && (l[u].minWidth = h);
    var f = n.barGap;
    f != null && (s.gap = f);
    var p = n.barCategoryGap;
    p != null && (s.categoryGap = p);
  });
  var r = {};
  return $(t, function(n, i) {
    r[i] = {};
    var o = n.stacks, a = n.bandWidth, s = n.categoryGap;
    if (s == null) {
      var l = jt(o).length;
      s = Math.max(35 - l * 4, 15) + "%";
    }
    var u = Be(s, a), c = Be(n.gap, 1), d = n.remainedWidth, h = n.autoWidthCount, f = (d - u) / (h + (h - 1) * c);
    f = Math.max(f, 0), $(o, function(m) {
      var y = m.maxWidth, C = m.minWidth;
      if (m.width) {
        var S = m.width;
        y && (S = Math.min(S, y)), C && (S = Math.max(S, C)), m.width = S, d -= S + c * S, h--;
      } else {
        var S = f;
        y && y < S && (S = Math.min(y, d)), C && C > S && (S = C), S !== f && (m.width = S, d -= S + c * S, h--);
      }
    }), f = (d - u) / (h + (h - 1) * c), f = Math.max(f, 0);
    var p = 0, g;
    $(o, function(m, y) {
      m.width || (m.width = f), g = m, p += m.width * (1 + c);
    }), g && (p -= g.width * c);
    var v = -p / 2;
    $(o, function(m, y) {
      r[i][y] = r[i][y] || {
        bandWidth: a,
        offset: v,
        width: m.width
      }, v += m.width * (1 + c);
    });
  }), r;
}
function EEe(e, t, r) {
  if (e && t) {
    var n = e[zD(t)];
    return n != null && r != null ? n[GD(r)] : n;
  }
}
function rj(e, t) {
  var r = J9(e, t), n = ej(r);
  $(r, function(i) {
    var o = i.getData(), a = i.coordinateSystem, s = a.getBaseAxis(), l = GD(i), u = n[zD(s)][l], c = u.offset, d = u.width;
    o.setLayout({
      bandWidth: u.bandWidth,
      offset: c,
      size: d
    });
  });
}
function nj(e) {
  return {
    seriesType: e,
    plan: Ef(),
    reset: function(t) {
      if (ij(t)) {
        var r = t.getData(), n = t.coordinateSystem, i = n.getBaseAxis(), o = n.getOtherAxis(i), a = r.getDimensionIndex(r.mapDimension(o.dim)), s = r.getDimensionIndex(r.mapDimension(i.dim)), l = t.get("showBackground", !0), u = r.mapDimension(o.dim), c = r.getCalculationInfo("stackResultDimension"), d = tl(r, u) && !!r.getCalculationInfo("stackedOnSeries"), h = o.isHorizontal(), f = REe(i, o), p = oj(t), g = t.get("barMinHeight") || 0, v = c && r.getDimensionIndex(c), m = r.getLayout("size"), y = r.getLayout("offset");
        return {
          progress: function(C, S) {
            for (var b = C.count, w = p && is(b * 3), x = p && l && is(b * 3), R = p && is(b), _ = n.master.getRect(), T = h ? _.width : _.height, P, D = S.getStore(), O = 0; (P = C.next()) != null; ) {
              var A = D.get(d ? v : a, P), F = D.get(s, P), L = f, N = void 0;
              d && (N = +A - D.get(a, P));
              var I = void 0, B = void 0, M = void 0, V = void 0;
              if (h) {
                var G = n.dataToPoint([A, F]);
                if (d) {
                  var k = n.dataToPoint([N, F]);
                  L = k[0];
                }
                I = L, B = G[1] + y, M = G[0] - L, V = m, Math.abs(M) < g && (M = (M < 0 ? -1 : 1) * g);
              } else {
                var G = n.dataToPoint([F, A]);
                if (d) {
                  var k = n.dataToPoint([F, N]);
                  L = k[1];
                }
                I = G[0] + y, B = L, M = m, V = G[1] - L, Math.abs(V) < g && (V = (V <= 0 ? -1 : 1) * g);
              }
              p ? (w[O] = I, w[O + 1] = B, w[O + 2] = h ? M : V, x && (x[O] = h ? _.x : I, x[O + 1] = h ? B : _.y, x[O + 2] = T), R[P] = P) : S.setItemLayout(P, {
                x: I,
                y: B,
                width: M,
                height: V
              }), O += 3;
            }
            p && S.setLayout({
              largePoints: w,
              largeDataIndices: R,
              largeBackgroundPoints: x,
              valueAxisHorizontal: h
            });
          }
        };
      }
    }
  };
}
function ij(e) {
  return e.coordinateSystem && e.coordinateSystem.type === "cartesian2d";
}
function oj(e) {
  return e.pipelineContext && e.pipelineContext.large;
}
function REe(e, t) {
  var r = t.model.get("startValue");
  return r || (r = 0), t.toGlobalCoord(t.dataToCoord(t.type === "log" ? r > 0 ? r : 1 : r));
}
var _Ee = function(e, t, r, n) {
  for (; r < n; ) {
    var i = r + n >>> 1;
    e[i][1] < t ? r = i + 1 : n = i;
  }
  return r;
}, WD = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "time", n;
    }
    return t.prototype.getLabel = function(r) {
      var n = this.getSetting("useUTC");
      return Gv(r.value, WN[Jwe(Dh(this._minLevelUnit))] || WN.second, n, this.getSetting("locale"));
    }, t.prototype.getFormattedLabel = function(r, n, i) {
      var o = this.getSetting("useUTC"), a = this.getSetting("locale");
      return ebe(r, n, i, a, o);
    }, t.prototype.getTicks = function() {
      var r = this._interval, n = this._extent, i = [];
      if (!r)
        return i;
      i.push({
        value: n[0],
        level: 0
      });
      var o = this.getSetting("useUTC"), a = OEe(this._minLevelUnit, this._approxInterval, o, n);
      return i = i.concat(a), i.push({
        value: n[1],
        level: 0
      }), i;
    }, t.prototype.calcNiceExtent = function(r) {
      var n = this._extent;
      if (n[0] === n[1] && (n[0] -= zo, n[1] += zo), n[1] === -1 / 0 && n[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        n[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), n[0] = n[1] - zo;
      }
      this.calcNiceTicks(r.splitNumber, r.minInterval, r.maxInterval);
    }, t.prototype.calcNiceTicks = function(r, n, i) {
      r = r || 10;
      var o = this._extent, a = o[1] - o[0];
      this._approxInterval = a / r, n != null && this._approxInterval < n && (this._approxInterval = n), i != null && this._approxInterval > i && (this._approxInterval = i);
      var s = oy.length, l = Math.min(_Ee(oy, this._approxInterval, 0, s), s - 1);
      this._interval = oy[l][1], this._minLevelUnit = oy[Math.max(l - 1, 0)][0];
    }, t.prototype.parse = function(r) {
      return sr(r) ? r : +bo(r);
    }, t.prototype.contain = function(r) {
      return bw(this.parse(r), this._extent);
    }, t.prototype.normalize = function(r) {
      return xw(this.parse(r), this._extent);
    }, t.prototype.scale = function(r) {
      return Ew(r, this._extent);
    }, t.type = "time", t;
  }(rl)
), oy = [
  // Format                           interval
  ["second", pD],
  ["minute", gD],
  ["hour", dg],
  ["quarter-day", dg * 6],
  ["half-day", dg * 12],
  ["day", zo * 1.2],
  ["half-week", zo * 3.5],
  ["week", zo * 7],
  ["month", zo * 31],
  ["quarter", zo * 95],
  ["half-year", zN / 2],
  ["year", zN]
  // 1Y
];
function TEe(e, t, r, n) {
  var i = bo(t), o = bo(r), a = function(p) {
    return jN(i, p, n) === jN(o, p, n);
  }, s = function() {
    return a("year");
  }, l = function() {
    return s() && a("month");
  }, u = function() {
    return l() && a("day");
  }, c = function() {
    return u() && a("hour");
  }, d = function() {
    return c() && a("minute");
  }, h = function() {
    return d() && a("second");
  }, f = function() {
    return h() && a("millisecond");
  };
  switch (e) {
    case "year":
      return s();
    case "month":
      return l();
    case "day":
      return u();
    case "hour":
      return c();
    case "minute":
      return d();
    case "second":
      return h();
    case "millisecond":
      return f();
  }
}
function PEe(e, t) {
  return e /= zo, e > 16 ? 16 : e > 7.5 ? 7 : e > 3.5 ? 4 : e > 1.5 ? 2 : 1;
}
function MEe(e) {
  var t = 30 * zo;
  return e /= t, e > 6 ? 6 : e > 3 ? 3 : e > 2 ? 2 : 1;
}
function DEe(e) {
  return e /= dg, e > 12 ? 12 : e > 6 ? 6 : e > 3.5 ? 4 : e > 2 ? 2 : 1;
}
function eV(e, t) {
  return e /= t ? gD : pD, e > 30 ? 30 : e > 20 ? 20 : e > 15 ? 15 : e > 10 ? 10 : e > 5 ? 5 : e > 2 ? 2 : 1;
}
function AEe(e) {
  return KM(e, !0);
}
function IEe(e, t, r) {
  var n = new Date(e);
  switch (Dh(t)) {
    case "year":
    case "month":
      n[R7(r)](0);
    case "day":
      n[_7(r)](1);
    case "hour":
      n[T7(r)](0);
    case "minute":
      n[P7(r)](0);
    case "second":
      n[M7(r)](0), n[D7(r)](0);
  }
  return n.getTime();
}
function OEe(e, t, r, n) {
  var i = 1e4, o = x7, a = 0;
  function s(T, P, D, O, A, F, L) {
    for (var N = new Date(P), I = P, B = N[O](); I < D && I <= n[1]; )
      L.push({
        value: I
      }), B += T, N[A](B), I = N.getTime();
    L.push({
      value: I,
      notAdd: !0
    });
  }
  function l(T, P, D) {
    var O = [], A = !P.length;
    if (!TEe(Dh(T), n[0], n[1], r)) {
      A && (P = [{
        // TODO Optimize. Not include so may ticks.
        value: IEe(new Date(n[0]), T, r)
      }, {
        value: n[1]
      }]);
      for (var F = 0; F < P.length - 1; F++) {
        var L = P[F].value, N = P[F + 1].value;
        if (L !== N) {
          var I = void 0, B = void 0, M = void 0, V = !1;
          switch (T) {
            case "year":
              I = Math.max(1, Math.round(t / zo / 365)), B = vD(r), M = tbe(r);
              break;
            case "half-year":
            case "quarter":
            case "month":
              I = MEe(t), B = Ah(r), M = R7(r);
              break;
            case "week":
            case "half-week":
            case "day":
              I = PEe(t), B = dw(r), M = _7(r), V = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              I = DEe(t), B = Kg(r), M = T7(r);
              break;
            case "minute":
              I = eV(t, !0), B = hw(r), M = P7(r);
              break;
            case "second":
              I = eV(t, !1), B = fw(r), M = M7(r);
              break;
            case "millisecond":
              I = AEe(t), B = pw(r), M = D7(r);
              break;
          }
          s(I, L, N, B, M, V, O), T === "year" && D.length > 1 && F === 0 && D.unshift({
            value: D[0].value - I
          });
        }
      }
      for (var F = 0; F < O.length; F++)
        D.push(O[F]);
      return O;
    }
  }
  for (var u = [], c = [], d = 0, h = 0, f = 0; f < o.length && a++ < i; ++f) {
    var p = Dh(o[f]);
    if (Qwe(o[f])) {
      l(o[f], u[u.length - 1] || [], c);
      var g = o[f + 1] ? Dh(o[f + 1]) : null;
      if (p !== g) {
        if (c.length) {
          h = d, c.sort(function(T, P) {
            return T.value - P.value;
          });
          for (var v = [], m = 0; m < c.length; ++m) {
            var y = c[m].value;
            (m === 0 || c[m - 1].value !== y) && (v.push(c[m]), y >= n[0] && y <= n[1] && d++);
          }
          var C = (n[1] - n[0]) / t;
          if (d > C * 1.5 && h > C / 1.5 || (u.push(v), d > C || e === o[f]))
            break;
        }
        c = [];
      }
    }
  }
  process.env.NODE_ENV !== "production" && a >= i && nn("Exceed safe limit.");
  for (var S = Sr(Ee(u, function(T) {
    return Sr(T, function(P) {
      return P.value >= n[0] && P.value <= n[1] && !P.notAdd;
    });
  }), function(T) {
    return T.length > 0;
  }), b = [], w = S.length - 1, f = 0; f < S.length; ++f)
    for (var x = S[f], R = 0; R < x.length; ++R)
      b.push({
        value: x[R].value,
        level: w - f
      });
  b.sort(function(T, P) {
    return T.value - P.value;
  });
  for (var _ = [], f = 0; f < b.length; ++f)
    (f === 0 || b[f].value !== b[f - 1].value) && _.push(b[f]);
  return _;
}
bs.registerClass(WD);
var tV = bs.prototype, pg = rl.prototype, LEe = an, FEe = Math.floor, NEe = Math.ceil, ay = Math.pow, da = Math.log, jD = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "log", r.base = 10, r._originalScale = new rl(), r._interval = 0, r;
    }
    return t.prototype.getTicks = function(r) {
      var n = this._originalScale, i = this._extent, o = n.getExtent(), a = pg.getTicks.call(this, r);
      return Ee(a, function(s) {
        var l = s.value, u = an(ay(this.base, l));
        return u = l === i[0] && this._fixMin ? sy(u, o[0]) : u, u = l === i[1] && this._fixMax ? sy(u, o[1]) : u, {
          value: u
        };
      }, this);
    }, t.prototype.setExtent = function(r, n) {
      var i = da(this.base);
      r = da(Math.max(0, r)) / i, n = da(Math.max(0, n)) / i, pg.setExtent.call(this, r, n);
    }, t.prototype.getExtent = function() {
      var r = this.base, n = tV.getExtent.call(this);
      n[0] = ay(r, n[0]), n[1] = ay(r, n[1]);
      var i = this._originalScale, o = i.getExtent();
      return this._fixMin && (n[0] = sy(n[0], o[0])), this._fixMax && (n[1] = sy(n[1], o[1])), n;
    }, t.prototype.unionExtent = function(r) {
      this._originalScale.unionExtent(r);
      var n = this.base;
      r[0] = da(r[0]) / da(n), r[1] = da(r[1]) / da(n), tV.unionExtent.call(this, r);
    }, t.prototype.unionExtentFromData = function(r, n) {
      this.unionExtent(r.getApproximateExtent(n));
    }, t.prototype.calcNiceTicks = function(r) {
      r = r || 10;
      var n = this._extent, i = n[1] - n[0];
      if (!(i === 1 / 0 || i <= 0)) {
        var o = pW(i), a = r / i * o;
        for (a <= 0.5 && (o *= 10); !isNaN(o) && Math.abs(o) < 1 && Math.abs(o) > 0; )
          o *= 10;
        var s = [an(NEe(n[0] / o) * o), an(FEe(n[1] / o) * o)];
        this._interval = o, this._niceExtent = s;
      }
    }, t.prototype.calcNiceExtent = function(r) {
      pg.calcNiceExtent.call(this, r), this._fixMin = r.fixMin, this._fixMax = r.fixMax;
    }, t.prototype.parse = function(r) {
      return r;
    }, t.prototype.contain = function(r) {
      return r = da(r) / da(this.base), bw(r, this._extent);
    }, t.prototype.normalize = function(r) {
      return r = da(r) / da(this.base), xw(r, this._extent);
    }, t.prototype.scale = function(r) {
      return r = Ew(r, this._extent), ay(this.base, r);
    }, t.type = "log", t;
  }(bs)
), aj = jD.prototype;
aj.getMinorTicks = pg.getMinorTicks;
aj.getLabel = pg.getLabel;
function sy(e, t) {
  return LEe(e, ba(t));
}
bs.registerClass(jD);
var kEe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this._prepareParams(t, r, n);
    }
    return e.prototype._prepareParams = function(t, r, n) {
      n[1] < n[0] && (n = [NaN, NaN]), this._dataMin = n[0], this._dataMax = n[1];
      var i = this._isOrdinal = t.type === "ordinal";
      this._needCrossZero = t.type === "interval" && r.getNeedCrossZero && r.getNeedCrossZero();
      var o = r.get("min", !0);
      o == null && (o = r.get("startValue", !0));
      var a = this._modelMinRaw = o;
      at(a) ? this._modelMinNum = ly(t, a({
        min: n[0],
        max: n[1]
      })) : a !== "dataMin" && (this._modelMinNum = ly(t, a));
      var s = this._modelMaxRaw = r.get("max", !0);
      if (at(s) ? this._modelMaxNum = ly(t, s({
        min: n[0],
        max: n[1]
      })) : s !== "dataMax" && (this._modelMaxNum = ly(t, s)), i)
        this._axisDataLen = r.getCategories().length;
      else {
        var l = r.get("boundaryGap"), u = be(l) ? l : [l || 0, l || 0];
        typeof u[0] == "boolean" || typeof u[1] == "boolean" ? (process.env.NODE_ENV !== "production" && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [La(u[0], 1), La(u[1], 1)];
      }
    }, e.prototype.calculate = function() {
      var t = this._isOrdinal, r = this._dataMin, n = this._dataMax, i = this._axisDataLen, o = this._boundaryGapInner, a = t ? null : n - r || Math.abs(r), s = this._modelMinRaw === "dataMin" ? r : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? n : this._modelMaxNum, u = s != null, c = l != null;
      s == null && (s = t ? i ? 0 : NaN : r - o[0] * a), l == null && (l = t ? i ? i - 1 : NaN : n + o[1] * a), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var d = nu(s) || nu(l) || t && !i;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0));
      var h = this._determinedMin, f = this._determinedMax;
      return h != null && (s = h, u = !0), f != null && (l = f, c = !0), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: d
      };
    }, e.prototype.modifyDataMinMax = function(t, r) {
      process.env.NODE_ENV !== "production" && ct(!this.frozen), this[BEe[t]] = r;
    }, e.prototype.setDeterminedMinMax = function(t, r) {
      var n = VEe[t];
      process.env.NODE_ENV !== "production" && ct(!this.frozen && this[n] == null), this[n] = r;
    }, e.prototype.freeze = function() {
      this.frozen = !0;
    }, e;
  }()
), VEe = {
  min: "_determinedMin",
  max: "_determinedMax"
}, BEe = {
  min: "_dataMin",
  max: "_dataMax"
};
function sj(e, t, r) {
  var n = e.rawExtentInfo;
  return n || (n = new kEe(e, t, r), e.rawExtentInfo = n, n);
}
function ly(e, t) {
  return t == null ? null : nu(t) ? NaN : e.parse(t);
}
function lj(e, t) {
  var r = e.type, n = sj(e, t, e.getExtent()).calculate();
  e.setBlank(n.isBlank);
  var i = n.min, o = n.max, a = t.ecModel;
  if (a && r === "time") {
    var s = J9("bar", a), l = !1;
    if ($(s, function(d) {
      l = l || d.getBaseAxis() === t.axis;
    }), l) {
      var u = ej(s), c = $Ee(i, o, t, u);
      i = c.min, o = c.max;
    }
  }
  return {
    extent: [i, o],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: n.minFixed,
    fixMax: n.maxFixed
  };
}
function $Ee(e, t, r, n) {
  var i = r.axis.getExtent(), o = i[1] - i[0], a = EEe(n, r.axis);
  if (a === void 0)
    return {
      min: e,
      max: t
    };
  var s = 1 / 0;
  $(a, function(f) {
    s = Math.min(f.offset, s);
  });
  var l = -1 / 0;
  $(a, function(f) {
    l = Math.max(f.offset + f.width, l);
  }), s = Math.abs(s), l = Math.abs(l);
  var u = s + l, c = t - e, d = 1 - (s + l) / o, h = c / d - c;
  return t += h * (l / u), e -= h * (s / u), {
    min: e,
    max: t
  };
}
function Kc(e, t) {
  var r = t, n = lj(e, r), i = n.extent, o = r.get("splitNumber");
  e instanceof jD && (e.base = r.get("logBase"));
  var a = e.type, s = r.get("interval"), l = a === "interval" || a === "time";
  e.setExtent(i[0], i[1]), e.calcNiceExtent({
    splitNumber: o,
    fixMin: n.fixMin,
    fixMax: n.fixMax,
    minInterval: l ? r.get("minInterval") : null,
    maxInterval: l ? r.get("maxInterval") : null
  }), s != null && e.setInterval && e.setInterval(s);
}
function Wv(e, t) {
  if (t = t || e.get("type"), t)
    switch (t) {
      case "category":
        return new Rw({
          ordinalMeta: e.getOrdinalMeta ? e.getOrdinalMeta() : e.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new WD({
          locale: e.ecModel.getLocaleModel(),
          useUTC: e.ecModel.get("useUTC")
        });
      default:
        return new (bs.getClass(t) || rl)();
    }
}
function HEe(e) {
  var t = e.scale.getExtent(), r = t[0], n = t[1];
  return !(r > 0 && n > 0 || r < 0 && n < 0);
}
function Pf(e) {
  var t = e.getLabelModel().get("formatter"), r = e.type === "category" ? e.scale.getExtent()[0] : null;
  return e.scale.type === "time" ? /* @__PURE__ */ function(n) {
    return function(i, o) {
      return e.scale.getFormattedLabel(i, o, n);
    };
  }(t) : He(t) ? /* @__PURE__ */ function(n) {
    return function(i) {
      var o = e.scale.getLabel(i), a = n.replace("{value}", o ?? "");
      return a;
    };
  }(t) : at(t) ? /* @__PURE__ */ function(n) {
    return function(i, o) {
      return r != null && (o = i.value - r), n(UD(e, i), o, i.level != null ? {
        level: i.level
      } : null);
    };
  }(t) : function(n) {
    return e.scale.getLabel(n);
  };
}
function UD(e, t) {
  return e.type === "category" ? e.scale.getLabel(t) : t.value;
}
function GEe(e) {
  var t = e.model, r = e.scale;
  if (!(!t.get(["axisLabel", "show"]) || r.isBlank())) {
    var n, i, o = r.getExtent();
    r instanceof Rw ? i = r.count() : (n = r.getTicks(), i = n.length);
    var a = e.getLabelModel(), s = Pf(e), l, u = 1;
    i > 40 && (u = Math.ceil(i / 40));
    for (var c = 0; c < i; c += u) {
      var d = n ? n[c] : {
        value: o[0] + c
      }, h = s(d, c), f = a.getTextRect(h), p = zEe(f, a.get("rotate") || 0);
      l ? l.union(p) : l = p;
    }
    return l;
  }
}
function zEe(e, t) {
  var r = t * Math.PI / 180, n = e.width, i = e.height, o = n * Math.abs(Math.cos(r)) + Math.abs(i * Math.sin(r)), a = n * Math.abs(Math.sin(r)) + Math.abs(i * Math.cos(r)), s = new At(e.x, e.y, o, a);
  return s;
}
function KD(e) {
  var t = e.get("interval");
  return t ?? "auto";
}
function uj(e) {
  return e.type === "category" && KD(e.getLabelModel()) === 0;
}
function TC(e, t) {
  var r = {};
  return $(e.mapDimensionsAll(t), function(n) {
    r[HD(e, n)] = !0;
  }), jt(r);
}
function WEe(e, t, r) {
  t && $(TC(t, r), function(n) {
    var i = t.getApproximateExtent(n);
    i[0] < e[0] && (e[0] = i[0]), i[1] > e[1] && (e[1] = i[1]);
  });
}
var Mf = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getNeedCrossZero = function() {
      var t = this.option;
      return !t.scale;
    }, e.prototype.getCoordSysModel = function() {
    }, e;
  }()
);
function jEe(e) {
  return ws(null, e);
}
var UEe = {
  isDimensionStacked: tl,
  enableDataStack: X9,
  getStackedDimension: HD
};
function KEe(e, t) {
  var r = t;
  t instanceof _r || (r = new _r(t));
  var n = Wv(r);
  return n.setExtent(e[0], e[1]), Kc(n, r), n;
}
function YEe(e) {
  cn(e, Mf);
}
function qEe(e, t) {
  return t = t || {}, Vr(e, null, null, t.state !== "normal");
}
const XEe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createDimensions: iEe,
  createList: jEe,
  createScale: KEe,
  createSymbol: mn,
  createTextStyle: qEe,
  dataStack: UEe,
  enableHoverEmphasis: zl,
  getECData: St,
  getLayoutRect: En,
  mixinAxisModelCommonMethods: YEe
}, Symbol.toStringTag, { value: "Module" }));
var ZEe = 1e-8;
function rV(e, t) {
  return Math.abs(e - t) < ZEe;
}
function sc(e, t, r) {
  var n = 0, i = e[0];
  if (!i)
    return !1;
  for (var o = 1; o < e.length; o++) {
    var a = e[o];
    n += Os(i[0], i[1], a[0], a[1], t, r), i = a;
  }
  var s = e[0];
  return (!rV(i[0], s[0]) || !rV(i[1], s[1])) && (n += Os(i[0], i[1], s[0], s[1], t, r)), n !== 0;
}
var QEe = [];
function q1(e, t) {
  for (var r = 0; r < e.length; r++)
    Un(e[r], e[r], t);
}
function nV(e, t, r, n) {
  for (var i = 0; i < e.length; i++) {
    var o = e[i];
    n && (o = n.project(o)), o && isFinite(o[0]) && isFinite(o[1]) && (Vs(t, t, o), Bs(r, r, o));
  }
}
function JEe(e) {
  for (var t = 0, r = 0, n = 0, i = e.length, o = e[i - 1][0], a = e[i - 1][1], s = 0; s < i; s++) {
    var l = e[s][0], u = e[s][1], c = o * u - l * a;
    t += c, r += (o + l) * c, n += (a + u) * c, o = l, a = u;
  }
  return t ? [r / t / 3, n / t / 3, t] : [e[0][0] || 0, e[0][1] || 0];
}
var cj = (
  /** @class */
  function() {
    function e(t) {
      this.name = t;
    }
    return e.prototype.setCenter = function(t) {
      this._center = t;
    }, e.prototype.getCenter = function() {
      var t = this._center;
      return t || (t = this._center = this.calcCenter()), t;
    }, e;
  }()
), iV = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, r) {
      this.type = "polygon", this.exterior = t, this.interiors = r;
    }
    return e;
  }()
), oV = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.type = "linestring", this.points = t;
    }
    return e;
  }()
), dj = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i) {
      var o = e.call(this, r) || this;
      return o.type = "geoJSON", o.geometries = n, o._center = i && [i[0], i[1]], o;
    }
    return t.prototype.calcCenter = function() {
      for (var r = this.geometries, n, i = 0, o = 0; o < r.length; o++) {
        var a = r[o], s = a.exterior, l = s && s.length;
        l > i && (n = a, i = l);
      }
      if (n)
        return JEe(n.exterior);
      var u = this.getBoundingRect();
      return [u.x + u.width / 2, u.y + u.height / 2];
    }, t.prototype.getBoundingRect = function(r) {
      var n = this._rect;
      if (n && !r)
        return n;
      var i = [1 / 0, 1 / 0], o = [-1 / 0, -1 / 0], a = this.geometries;
      return $(a, function(s) {
        s.type === "polygon" ? nV(s.exterior, i, o, r) : $(s.points, function(l) {
          nV(l, i, o, r);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(o[0]) && isFinite(o[1]) || (i[0] = i[1] = o[0] = o[1] = 0), n = new At(i[0], i[1], o[0] - i[0], o[1] - i[1]), r || (this._rect = n), n;
    }, t.prototype.contain = function(r) {
      var n = this.getBoundingRect(), i = this.geometries;
      if (!n.contain(r[0], r[1]))
        return !1;
      e: for (var o = 0, a = i.length; o < a; o++) {
        var s = i[o];
        if (s.type === "polygon") {
          var l = s.exterior, u = s.interiors;
          if (sc(l, r[0], r[1])) {
            for (var c = 0; c < (u ? u.length : 0); c++)
              if (sc(u[c], r[0], r[1]))
                continue e;
            return !0;
          }
        }
      }
      return !1;
    }, t.prototype.transformTo = function(r, n, i, o) {
      var a = this.getBoundingRect(), s = a.width / a.height;
      i ? o || (o = i / s) : i = s * o;
      for (var l = new At(r, n, i, o), u = a.calculateTransform(l), c = this.geometries, d = 0; d < c.length; d++) {
        var h = c[d];
        h.type === "polygon" ? (q1(h.exterior, u), $(h.interiors, function(f) {
          q1(f, u);
        })) : $(h.points, function(f) {
          q1(f, u);
        });
      }
      a = this._rect, a.copy(l), this._center = [a.x + a.width / 2, a.y + a.height / 2];
    }, t.prototype.cloneShallow = function(r) {
      r == null && (r = this.name);
      var n = new t(r, this.geometries, this._center);
      return n._rect = this._rect, n.transformTo = null, n;
    }, t;
  }(cj)
), eRe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n) {
      var i = e.call(this, r) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = n, i;
    }
    return t.prototype.calcCenter = function() {
      for (var r = this._elOnlyForCalculate, n = r.getBoundingRect(), i = [n.x + n.width / 2, n.y + n.height / 2], o = Iv(QEe), a = r; a && !a.isGeoSVGGraphicRoot; )
        us(o, a.getLocalTransform(), o), a = a.parent;
      return id(o, o), Un(i, i, o), i;
    }, t;
  }(cj)
);
function tRe(e) {
  if (!e.UTF8Encoding)
    return e;
  var t = e, r = t.UTF8Scale;
  r == null && (r = 1024);
  var n = t.features;
  return $(n, function(i) {
    var o = i.geometry, a = o.encodeOffsets, s = o.coordinates;
    if (a)
      switch (o.type) {
        case "LineString":
          o.coordinates = hj(s, a, r);
          break;
        case "Polygon":
          X1(s, a, r);
          break;
        case "MultiLineString":
          X1(s, a, r);
          break;
        case "MultiPolygon":
          $(s, function(l, u) {
            return X1(l, a[u], r);
          });
      }
  }), t.UTF8Encoding = !1, t;
}
function X1(e, t, r) {
  for (var n = 0; n < e.length; n++)
    e[n] = hj(e[n], t[n], r);
}
function hj(e, t, r) {
  for (var n = [], i = t[0], o = t[1], a = 0; a < e.length; a += 2) {
    var s = e.charCodeAt(a) - 64, l = e.charCodeAt(a + 1) - 64;
    s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += o, i = s, o = l, n.push([s / r, l / r]);
  }
  return n;
}
function lT(e, t) {
  return e = tRe(e), Ee(Sr(e.features, function(r) {
    return r.geometry && r.properties && r.geometry.coordinates.length > 0;
  }), function(r) {
    var n = r.properties, i = r.geometry, o = [];
    switch (i.type) {
      case "Polygon":
        var a = i.coordinates;
        o.push(new iV(a[0], a.slice(1)));
        break;
      case "MultiPolygon":
        $(i.coordinates, function(l) {
          l[0] && o.push(new iV(l[0], l.slice(1)));
        });
        break;
      case "LineString":
        o.push(new oV([i.coordinates]));
        break;
      case "MultiLineString":
        o.push(new oV(i.coordinates));
    }
    var s = new dj(n[t || "name"], o, n.cp);
    return s.properties = n, s;
  });
}
const rRe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MAX_SAFE_INTEGER: M_,
  asc: vo,
  getPercentWithPrecision: _Ce,
  getPixelPrecision: jM,
  getPrecision: ba,
  getPrecisionSafe: aC,
  isNumeric: ZS,
  isRadianAroundZero: zh,
  linearMap: Cr,
  nice: KM,
  numericToNumber: vs,
  parseDate: bo,
  quantile: s0,
  quantity: pW,
  quantityExponent: Fv,
  reformIntervals: D_,
  remRadian: UM,
  round: an
}, Symbol.toStringTag, { value: "Module" })), nRe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  format: Gv,
  parse: bo
}, Symbol.toStringTag, { value: "Module" })), iRe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: aw,
  BezierCurve: Bv,
  BoundingRect: At,
  Circle: ul,
  CompoundPath: sw,
  Ellipse: ow,
  Group: Ct,
  Image: qn,
  IncrementalDisplayable: c7,
  Line: Nn,
  LinearGradient: vf,
  Polygon: Li,
  Polyline: Ni,
  RadialGradient: oD,
  Rect: or,
  Ring: Vv,
  Sector: Oi,
  Text: ir,
  clipPointsByRect: uD,
  clipRectByRect: g7,
  createIcon: yf,
  extendPath: f7,
  extendShape: h7,
  getShapeClass: lw,
  getTransform: Wl,
  initProps: jr,
  makeImage: sD,
  makePath: $v,
  mergePath: fo,
  registerShape: ia,
  resizePath: lD,
  updateProps: ur
}, Symbol.toStringTag, { value: "Module" })), oRe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCommas: mD,
  capitalFirst: obe,
  encodeHTML: Ei,
  formatTime: ibe,
  formatTpl: CD,
  getTextRect: rbe,
  getTooltipMarker: A7,
  normalizeCssArray: sd,
  toCamelCase: yD,
  truncateText: RW
}, Symbol.toStringTag, { value: "Module" })), aRe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bind: je,
  clone: dt,
  curry: _t,
  defaults: ut,
  each: $,
  extend: ge,
  filter: Sr,
  indexOf: Ft,
  inherits: NM,
  isArray: be,
  isFunction: at,
  isObject: lt,
  isString: He,
  map: Ee,
  merge: Mt,
  reduce: Jo
}, Symbol.toStringTag, { value: "Module" }));
var Jg = ar();
function fj(e, t) {
  var r = Ee(t, function(n) {
    return e.scale.parse(n);
  });
  return e.type === "time" && r.length > 0 && (r.sort(), r.unshift(r[0]), r.push(r[r.length - 1])), r;
}
function sRe(e) {
  var t = e.getLabelModel().get("customValues");
  if (t) {
    var r = Pf(e);
    return {
      labels: fj(e, t).map(function(n) {
        var i = {
          value: n
        };
        return {
          formattedLabel: r(i),
          rawLabel: e.scale.getLabel(i),
          tickValue: n
        };
      })
    };
  }
  return e.type === "category" ? uRe(e) : dRe(e);
}
function lRe(e, t) {
  var r = e.getTickModel().get("customValues");
  return r ? {
    ticks: fj(e, r)
  } : e.type === "category" ? cRe(e, t) : {
    ticks: Ee(e.scale.getTicks(), function(n) {
      return n.value;
    })
  };
}
function uRe(e) {
  var t = e.getLabelModel(), r = pj(e, t);
  return !t.get("show") || e.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: r.labelCategoryInterval
  } : r;
}
function pj(e, t) {
  var r = gj(e, "labels"), n = KD(t), i = vj(r, n);
  if (i)
    return i;
  var o, a;
  return at(n) ? o = Cj(e, n) : (a = n === "auto" ? hRe(e) : n, o = yj(e, a)), mj(r, n, {
    labels: o,
    labelCategoryInterval: a
  });
}
function cRe(e, t) {
  var r = gj(e, "ticks"), n = KD(t), i = vj(r, n);
  if (i)
    return i;
  var o, a;
  if ((!t.get("show") || e.scale.isBlank()) && (o = []), at(n))
    o = Cj(e, n, !0);
  else if (n === "auto") {
    var s = pj(e, e.getLabelModel());
    a = s.labelCategoryInterval, o = Ee(s.labels, function(l) {
      return l.tickValue;
    });
  } else
    a = n, o = yj(e, a, !0);
  return mj(r, n, {
    ticks: o,
    tickCategoryInterval: a
  });
}
function dRe(e) {
  var t = e.scale.getTicks(), r = Pf(e);
  return {
    labels: Ee(t, function(n, i) {
      return {
        level: n.level,
        formattedLabel: r(n, i),
        rawLabel: e.scale.getLabel(n),
        tickValue: n.value
      };
    })
  };
}
function gj(e, t) {
  return Jg(e)[t] || (Jg(e)[t] = []);
}
function vj(e, t) {
  for (var r = 0; r < e.length; r++)
    if (e[r].key === t)
      return e[r].value;
}
function mj(e, t, r) {
  return e.push({
    key: t,
    value: r
  }), r;
}
function hRe(e) {
  var t = Jg(e).autoInterval;
  return t ?? (Jg(e).autoInterval = e.calculateCategoryInterval());
}
function fRe(e) {
  var t = pRe(e), r = Pf(e), n = (t.axisRotate - t.labelRotate) / 180 * Math.PI, i = e.scale, o = i.getExtent(), a = i.count();
  if (o[1] - o[0] < 1)
    return 0;
  var s = 1;
  a > 40 && (s = Math.max(1, Math.floor(a / 40)));
  for (var l = o[0], u = e.dataToCoord(l + 1) - e.dataToCoord(l), c = Math.abs(u * Math.cos(n)), d = Math.abs(u * Math.sin(n)), h = 0, f = 0; l <= o[1]; l += s) {
    var p = 0, g = 0, v = Lv(r({
      value: l
    }), t.font, "center", "top");
    p = v.width * 1.3, g = v.height * 1.3, h = Math.max(h, p, 7), f = Math.max(f, g, 7);
  }
  var m = h / c, y = f / d;
  isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0);
  var C = Math.max(0, Math.floor(Math.min(m, y))), S = Jg(e.model), b = e.getExtent(), w = S.lastAutoInterval, x = S.lastTickCount;
  return w != null && x != null && Math.abs(w - C) <= 1 && Math.abs(x - a) <= 1 && w > C && S.axisExtent0 === b[0] && S.axisExtent1 === b[1] ? C = w : (S.lastTickCount = a, S.lastAutoInterval = C, S.axisExtent0 = b[0], S.axisExtent1 = b[1]), C;
}
function pRe(e) {
  var t = e.getLabelModel();
  return {
    axisRotate: e.getRotate ? e.getRotate() : e.isHorizontal && !e.isHorizontal() ? 90 : 0,
    labelRotate: t.get("rotate") || 0,
    font: t.getFont()
  };
}
function yj(e, t, r) {
  var n = Pf(e), i = e.scale, o = i.getExtent(), a = e.getLabelModel(), s = [], l = Math.max((t || 0) + 1, 1), u = o[0], c = i.count();
  u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
  var d = uj(e), h = a.get("showMinLabel") || d, f = a.get("showMaxLabel") || d;
  h && u !== o[0] && g(o[0]);
  for (var p = u; p <= o[1]; p += l)
    g(p);
  f && p - l !== o[1] && g(o[1]);
  function g(v) {
    var m = {
      value: v
    };
    s.push(r ? v : {
      formattedLabel: n(m),
      rawLabel: i.getLabel(m),
      tickValue: v
    });
  }
  return s;
}
function Cj(e, t, r) {
  var n = e.scale, i = Pf(e), o = [];
  return $(n.getTicks(), function(a) {
    var s = n.getLabel(a), l = a.value;
    t(a.value, s) && o.push(r ? l : {
      formattedLabel: i(a),
      rawLabel: s,
      tickValue: l
    });
  }), o;
}
var aV = [0, 1], gRe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.onBand = !1, this.inverse = !1, this.dim = t, this.scale = r, this._extent = n || [0, 0];
    }
    return e.prototype.contain = function(t) {
      var r = this._extent, n = Math.min(r[0], r[1]), i = Math.max(r[0], r[1]);
      return t >= n && t <= i;
    }, e.prototype.containData = function(t) {
      return this.scale.contain(t);
    }, e.prototype.getExtent = function() {
      return this._extent.slice();
    }, e.prototype.getPixelPrecision = function(t) {
      return jM(t || this.scale.getExtent(), this._extent);
    }, e.prototype.setExtent = function(t, r) {
      var n = this._extent;
      n[0] = t, n[1] = r;
    }, e.prototype.dataToCoord = function(t, r) {
      var n = this._extent, i = this.scale;
      return t = i.normalize(t), this.onBand && i.type === "ordinal" && (n = n.slice(), sV(n, i.count())), Cr(t, aV, n, r);
    }, e.prototype.coordToData = function(t, r) {
      var n = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (n = n.slice(), sV(n, i.count()));
      var o = Cr(t, n, aV, r);
      return this.scale.scale(o);
    }, e.prototype.pointToData = function(t, r) {
    }, e.prototype.getTicksCoords = function(t) {
      t = t || {};
      var r = t.tickModel || this.getTickModel(), n = lRe(this, r), i = n.ticks, o = Ee(i, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), a = r.get("alignWithLabel");
      return vRe(this, o, a, t.clamp), o;
    }, e.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var t = this.model.getModel("minorTick"), r = t.get("splitNumber");
      r > 0 && r < 100 || (r = 5);
      var n = this.scale.getMinorTicks(r), i = Ee(n, function(o) {
        return Ee(o, function(a) {
          return {
            coord: this.dataToCoord(a),
            tickValue: a
          };
        }, this);
      }, this);
      return i;
    }, e.prototype.getViewLabels = function() {
      return sRe(this).labels;
    }, e.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, e.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, e.prototype.getBandWidth = function() {
      var t = this._extent, r = this.scale.getExtent(), n = r[1] - r[0] + (this.onBand ? 1 : 0);
      n === 0 && (n = 1);
      var i = Math.abs(t[1] - t[0]);
      return Math.abs(i) / n;
    }, e.prototype.calculateCategoryInterval = function() {
      return fRe(this);
    }, e;
  }()
);
function sV(e, t) {
  var r = e[1] - e[0], n = t, i = r / n / 2;
  e[0] += i, e[1] -= i;
}
function vRe(e, t, r, n) {
  var i = t.length;
  if (!e.onBand || r || !i)
    return;
  var o = e.getExtent(), a, s;
  if (i === 1)
    t[0].coord = o[0], a = t[1] = {
      coord: o[1]
    };
  else {
    var l = t[i - 1].tickValue - t[0].tickValue, u = (t[i - 1].coord - t[0].coord) / l;
    $(t, function(f) {
      f.coord -= u / 2;
    });
    var c = e.scale.getExtent();
    s = 1 + c[1] - t[i - 1].tickValue, a = {
      coord: t[i - 1].coord + u * s
    }, t.push(a);
  }
  var d = o[0] > o[1];
  h(t[0].coord, o[0]) && (n ? t[0].coord = o[0] : t.shift()), n && h(o[0], t[0].coord) && t.unshift({
    coord: o[0]
  }), h(o[1], a.coord) && (n ? a.coord = o[1] : t.pop()), n && h(a.coord, o[1]) && t.push({
    coord: o[1]
  });
  function h(f, p) {
    return f = an(f), p = an(p), d ? f > p : f < p;
  }
}
const sa = gRe;
function mRe(e) {
  var t = Vt.extend(e);
  return Vt.registerClass(t), t;
}
function yRe(e) {
  var t = zr.extend(e);
  return zr.registerClass(t), t;
}
function CRe(e) {
  var t = Pr.extend(e);
  return Pr.registerClass(t), t;
}
function SRe(e) {
  var t = br.extend(e);
  return br.registerClass(t), t;
}
var fp = Math.PI * 2, Uu = ms.CMD, wRe = ["top", "right", "bottom", "left"];
function bRe(e, t, r, n, i) {
  var o = r.width, a = r.height;
  switch (e) {
    case "top":
      n.set(r.x + o / 2, r.y - t), i.set(0, -1);
      break;
    case "bottom":
      n.set(r.x + o / 2, r.y + a + t), i.set(0, 1);
      break;
    case "left":
      n.set(r.x - t, r.y + a / 2), i.set(-1, 0);
      break;
    case "right":
      n.set(r.x + o + t, r.y + a / 2), i.set(1, 0);
      break;
  }
}
function xRe(e, t, r, n, i, o, a, s, l) {
  a -= e, s -= t;
  var u = Math.sqrt(a * a + s * s);
  a /= u, s /= u;
  var c = a * r + e, d = s * r + t;
  if (Math.abs(n - i) % fp < 1e-4)
    return l[0] = c, l[1] = d, u - r;
  if (o) {
    var h = n;
    n = mo(i), i = mo(h);
  } else
    n = mo(n), i = mo(i);
  n > i && (i += fp);
  var f = Math.atan2(s, a);
  if (f < 0 && (f += fp), f >= n && f <= i || f + fp >= n && f + fp <= i)
    return l[0] = c, l[1] = d, u - r;
  var p = r * Math.cos(n) + e, g = r * Math.sin(n) + t, v = r * Math.cos(i) + e, m = r * Math.sin(i) + t, y = (p - a) * (p - a) + (g - s) * (g - s), C = (v - a) * (v - a) + (m - s) * (m - s);
  return y < C ? (l[0] = p, l[1] = g, Math.sqrt(y)) : (l[0] = v, l[1] = m, Math.sqrt(C));
}
function PC(e, t, r, n, i, o, a, s) {
  var l = i - e, u = o - t, c = r - e, d = n - t, h = Math.sqrt(c * c + d * d);
  c /= h, d /= h;
  var f = l * c + u * d, p = f / h;
  s && (p = Math.min(Math.max(p, 0), 1)), p *= h;
  var g = a[0] = e + p * c, v = a[1] = t + p * d;
  return Math.sqrt((g - i) * (g - i) + (v - o) * (v - o));
}
function Sj(e, t, r, n, i, o, a) {
  r < 0 && (e = e + r, r = -r), n < 0 && (t = t + n, n = -n);
  var s = e + r, l = t + n, u = a[0] = Math.min(Math.max(i, e), s), c = a[1] = Math.min(Math.max(o, t), l);
  return Math.sqrt((u - i) * (u - i) + (c - o) * (c - o));
}
var ma = [];
function ERe(e, t, r) {
  var n = Sj(t.x, t.y, t.width, t.height, e.x, e.y, ma);
  return r.set(ma[0], ma[1]), n;
}
function RRe(e, t, r) {
  for (var n = 0, i = 0, o = 0, a = 0, s, l, u = 1 / 0, c = t.data, d = e.x, h = e.y, f = 0; f < c.length; ) {
    var p = c[f++];
    f === 1 && (n = c[f], i = c[f + 1], o = n, a = i);
    var g = u;
    switch (p) {
      case Uu.M:
        o = c[f++], a = c[f++], n = o, i = a;
        break;
      case Uu.L:
        g = PC(n, i, c[f], c[f + 1], d, h, ma, !0), n = c[f++], i = c[f++];
        break;
      case Uu.C:
        g = U6(n, i, c[f++], c[f++], c[f++], c[f++], c[f], c[f + 1], d, h, ma), n = c[f++], i = c[f++];
        break;
      case Uu.Q:
        g = Y6(n, i, c[f++], c[f++], c[f], c[f + 1], d, h, ma), n = c[f++], i = c[f++];
        break;
      case Uu.A:
        var v = c[f++], m = c[f++], y = c[f++], C = c[f++], S = c[f++], b = c[f++];
        f += 1;
        var w = !!(1 - c[f++]);
        s = Math.cos(S) * y + v, l = Math.sin(S) * C + m, f <= 1 && (o = s, a = l);
        var x = (d - v) * C / y + v;
        g = xRe(v, m, C, S, S + b, w, x, h, ma), n = Math.cos(S + b) * y + v, i = Math.sin(S + b) * C + m;
        break;
      case Uu.R:
        o = n = c[f++], a = i = c[f++];
        var R = c[f++], _ = c[f++];
        g = Sj(o, a, R, _, d, h, ma);
        break;
      case Uu.Z:
        g = PC(n, i, o, a, d, h, ma, !0), n = o, i = a;
        break;
    }
    g < u && (u = g, r.set(ma[0], ma[1]));
  }
  return u;
}
var xa = new Dt(), Gr = new Dt(), fn = new Dt(), os = new Dt(), ts = new Dt();
function lV(e, t) {
  if (e) {
    var r = e.getTextGuideLine(), n = e.getTextContent();
    if (n && r) {
      var i = e.textGuideLineConfig || {}, o = [[0, 0], [0, 0], [0, 0]], a = i.candidates || wRe, s = n.getBoundingRect().clone();
      s.applyTransform(n.getComputedTransform());
      var l = 1 / 0, u = i.anchor, c = e.getComputedTransform(), d = c && id([], c), h = t.get("length2") || 0;
      u && fn.copy(u);
      for (var f = 0; f < a.length; f++) {
        var p = a[f];
        bRe(p, 0, s, xa, os), Dt.scaleAndAdd(Gr, xa, os, h), Gr.transform(d);
        var g = e.getBoundingRect(), v = u ? u.distance(Gr) : e instanceof Ht ? RRe(Gr, e.path, fn) : ERe(Gr, g, fn);
        v < l && (l = v, Gr.transform(c), fn.transform(c), fn.toArray(o[0]), Gr.toArray(o[1]), xa.toArray(o[2]));
      }
      wj(o, t.get("minTurnAngle")), r.setShape({
        points: o
      });
    }
  }
}
var MC = [], xi = new Dt();
function wj(e, t) {
  if (t <= 180 && t > 0) {
    t = t / 180 * Math.PI, xa.fromArray(e[0]), Gr.fromArray(e[1]), fn.fromArray(e[2]), Dt.sub(os, xa, Gr), Dt.sub(ts, fn, Gr);
    var r = os.len(), n = ts.len();
    if (!(r < 1e-3 || n < 1e-3)) {
      os.scale(1 / r), ts.scale(1 / n);
      var i = os.dot(ts), o = Math.cos(t);
      if (o < i) {
        var a = PC(Gr.x, Gr.y, fn.x, fn.y, xa.x, xa.y, MC, !1);
        xi.fromArray(MC), xi.scaleAndAdd(ts, a / Math.tan(Math.PI - t));
        var s = fn.x !== Gr.x ? (xi.x - Gr.x) / (fn.x - Gr.x) : (xi.y - Gr.y) / (fn.y - Gr.y);
        if (isNaN(s))
          return;
        s < 0 ? Dt.copy(xi, Gr) : s > 1 && Dt.copy(xi, fn), xi.toArray(e[1]);
      }
    }
  }
}
function _Re(e, t, r) {
  if (r <= 180 && r > 0) {
    r = r / 180 * Math.PI, xa.fromArray(e[0]), Gr.fromArray(e[1]), fn.fromArray(e[2]), Dt.sub(os, Gr, xa), Dt.sub(ts, fn, Gr);
    var n = os.len(), i = ts.len();
    if (!(n < 1e-3 || i < 1e-3)) {
      os.scale(1 / n), ts.scale(1 / i);
      var o = os.dot(t), a = Math.cos(r);
      if (o < a) {
        var s = PC(Gr.x, Gr.y, fn.x, fn.y, xa.x, xa.y, MC, !1);
        xi.fromArray(MC);
        var l = Math.PI / 2, u = Math.acos(ts.dot(t)), c = l + u - r;
        if (c >= l)
          Dt.copy(xi, fn);
        else {
          xi.scaleAndAdd(ts, s / Math.tan(Math.PI / 2 - c));
          var d = fn.x !== Gr.x ? (xi.x - Gr.x) / (fn.x - Gr.x) : (xi.y - Gr.y) / (fn.y - Gr.y);
          if (isNaN(d))
            return;
          d < 0 ? Dt.copy(xi, Gr) : d > 1 && Dt.copy(xi, fn);
        }
        xi.toArray(e[1]);
      }
    }
  }
}
function Z1(e, t, r, n) {
  var i = r === "normal", o = i ? e : e.ensureState(r);
  o.ignore = t;
  var a = n.get("smooth");
  a && a === !0 && (a = 0.3), o.shape = o.shape || {}, a > 0 && (o.shape.smooth = a);
  var s = n.getModel("lineStyle").getLineStyle();
  i ? e.useStyle(s) : o.style = s;
}
function TRe(e, t) {
  var r = t.smooth, n = t.points;
  if (n)
    if (e.moveTo(n[0][0], n[0][1]), r > 0 && n.length >= 3) {
      var i = ks(n[0], n[1]), o = ks(n[1], n[2]);
      if (!i || !o) {
        e.lineTo(n[1][0], n[1][1]), e.lineTo(n[2][0], n[2][1]);
        return;
      }
      var a = Math.min(i, o) * r, s = rg([], n[1], n[0], a / i), l = rg([], n[1], n[2], a / o), u = rg([], s, l, 0.5);
      e.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), e.bezierCurveTo(l[0], l[1], l[0], l[1], n[2][0], n[2][1]);
    } else
      for (var c = 1; c < n.length; c++)
        e.lineTo(n[c][0], n[c][1]);
}
function YD(e, t, r) {
  var n = e.getTextGuideLine(), i = e.getTextContent();
  if (!i) {
    n && e.removeTextGuideLine();
    return;
  }
  for (var o = t.normal, a = o.get("show"), s = i.ignore, l = 0; l < jg.length; l++) {
    var u = jg[l], c = t[u], d = u === "normal";
    if (c) {
      var h = c.get("show"), f = d ? s : bt(i.states[u] && i.states[u].ignore, s);
      if (f || !bt(h, a)) {
        var p = d ? n : n && n.states[u];
        p && (p.ignore = !0), n && Z1(n, !0, u, c);
        continue;
      }
      n || (n = new Ni(), e.setTextGuideLine(n), !d && (s || !a) && Z1(n, !0, "normal", t.normal), e.stateProxy && (n.stateProxy = e.stateProxy)), Z1(n, !1, u, c);
    }
  }
  if (n) {
    ut(n.style, r), n.style.fill = null;
    var g = o.get("showAbove"), v = e.textGuideLineConfig = e.textGuideLineConfig || {};
    v.showAbove = g || !1, n.buildPath = TRe;
  }
}
function qD(e, t) {
  t = t || "labelLine";
  for (var r = {
    normal: e.getModel(t)
  }, n = 0; n < Ii.length; n++) {
    var i = Ii[n];
    r[i] = e.getModel([i, t]);
  }
  return r;
}
function bj(e) {
  for (var t = [], r = 0; r < e.length; r++) {
    var n = e[r];
    if (!n.defaultAttr.ignore) {
      var i = n.label, o = i.getComputedTransform(), a = i.getBoundingRect(), s = !o || o[1] < 1e-5 && o[2] < 1e-5, l = i.style.margin || 0, u = a.clone();
      u.applyTransform(o), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
      var c = s ? new uC(a, o) : null;
      t.push({
        label: i,
        labelLine: n.labelLine,
        rect: u,
        localRect: a,
        obb: c,
        priority: n.priority,
        defaultAttr: n.defaultAttr,
        layoutOption: n.computedLayoutOption,
        axisAligned: s,
        transform: o
      });
    }
  }
  return t;
}
function xj(e, t, r, n, i, o) {
  var a = e.length;
  if (a < 2)
    return;
  e.sort(function(R, _) {
    return R.rect[t] - _.rect[t];
  });
  for (var s = 0, l, u = !1, c = 0, d = 0; d < a; d++) {
    var h = e[d], f = h.rect;
    l = f[t] - s, l < 0 && (f[t] -= l, h.label[t] -= l, u = !0);
    var p = Math.max(-l, 0);
    c += p, s = f[t] + f[r];
  }
  c > 0 && o && b(-c / a, 0, a);
  var g = e[0], v = e[a - 1], m, y;
  C(), m < 0 && w(-m, 0.8), y < 0 && w(y, 0.8), C(), S(m, y, 1), S(y, m, -1), C(), m < 0 && x(-m), y < 0 && x(y);
  function C() {
    m = g.rect[t] - n, y = i - v.rect[t] - v.rect[r];
  }
  function S(R, _, T) {
    if (R < 0) {
      var P = Math.min(_, -R);
      if (P > 0) {
        b(P * T, 0, a);
        var D = P + R;
        D < 0 && w(-D * T, 1);
      } else
        w(-R * T, 1);
    }
  }
  function b(R, _, T) {
    R !== 0 && (u = !0);
    for (var P = _; P < T; P++) {
      var D = e[P], O = D.rect;
      O[t] += R, D.label[t] += R;
    }
  }
  function w(R, _) {
    for (var T = [], P = 0, D = 1; D < a; D++) {
      var O = e[D - 1].rect, A = Math.max(e[D].rect[t] - O[t] - O[r], 0);
      T.push(A), P += A;
    }
    if (P) {
      var F = Math.min(Math.abs(R) / P, _);
      if (R > 0)
        for (var D = 0; D < a - 1; D++) {
          var L = T[D] * F;
          b(L, 0, D + 1);
        }
      else
        for (var D = a - 1; D > 0; D--) {
          var L = T[D - 1] * F;
          b(-L, D, a);
        }
    }
  }
  function x(R) {
    var _ = R < 0 ? -1 : 1;
    R = Math.abs(R);
    for (var T = Math.ceil(R / (a - 1)), P = 0; P < a - 1; P++)
      if (_ > 0 ? b(T, 0, P + 1) : b(-T, a - P - 1, a), R -= T, R <= 0)
        return;
  }
  return u;
}
function PRe(e, t, r, n) {
  return xj(e, "x", "width", t, r, n);
}
function Ej(e, t, r, n) {
  return xj(e, "y", "height", t, r, n);
}
function Rj(e) {
  var t = [];
  e.sort(function(g, v) {
    return v.priority - g.priority;
  });
  var r = new At(0, 0, 0, 0);
  function n(g) {
    if (!g.ignore) {
      var v = g.ensureState("emphasis");
      v.ignore == null && (v.ignore = !1);
    }
    g.ignore = !0;
  }
  for (var i = 0; i < e.length; i++) {
    var o = e[i], a = o.axisAligned, s = o.localRect, l = o.transform, u = o.label, c = o.labelLine;
    r.copy(o.rect), r.width -= 0.1, r.height -= 0.1, r.x += 0.05, r.y += 0.05;
    for (var d = o.obb, h = !1, f = 0; f < t.length; f++) {
      var p = t[f];
      if (r.intersect(p.rect)) {
        if (a && p.axisAligned) {
          h = !0;
          break;
        }
        if (p.obb || (p.obb = new uC(p.localRect, p.transform)), d || (d = new uC(s, l)), d.intersect(p.obb)) {
          h = !0;
          break;
        }
      }
    }
    h ? (n(u), c && n(c)) : (u.attr("ignore", o.defaultAttr.ignore), c && c.attr("ignore", o.defaultAttr.labelGuideIgnore), t.push(o));
  }
}
function MRe(e) {
  if (e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push(e[r].slice());
    return t;
  }
}
function DRe(e, t) {
  var r = e.label, n = t && t.getTextGuideLine();
  return {
    dataIndex: e.dataIndex,
    dataType: e.dataType,
    seriesIndex: e.seriesModel.seriesIndex,
    text: e.label.style.text,
    rect: e.hostRect,
    labelRect: e.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: r.style.align,
    verticalAlign: r.style.verticalAlign,
    labelLinePoints: MRe(n && n.shape.points)
  };
}
var uV = ["align", "verticalAlign", "width", "height", "fontSize"], Ci = new $s(), Q1 = ar(), ARe = ar();
function uy(e, t, r) {
  for (var n = 0; n < r.length; n++) {
    var i = r[n];
    t[i] != null && (e[i] = t[i]);
  }
}
var cy = ["x", "y", "rotation"], IRe = (
  /** @class */
  function() {
    function e() {
      this._labelList = [], this._chartViewList = [];
    }
    return e.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, e.prototype._addLabel = function(t, r, n, i, o) {
      var a = i.style, s = i.__hostTarget, l = s.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      At.applyTransform(c, c, u), u ? Ci.setLocalTransform(u) : (Ci.x = Ci.y = Ci.rotation = Ci.originX = Ci.originY = 0, Ci.scaleX = Ci.scaleY = 1), Ci.rotation = mo(Ci.rotation);
      var d = i.__hostTarget, h;
      if (d) {
        h = d.getBoundingRect().plain();
        var f = d.getComputedTransform();
        At.applyTransform(h, h, f);
      }
      var p = h && d.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: p,
        seriesModel: n,
        dataIndex: t,
        dataType: r,
        layoutOption: o,
        computedLayoutOption: null,
        rect: c,
        hostRect: h,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: h ? h.width * h.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: p && p.ignore,
          x: Ci.x,
          y: Ci.y,
          scaleX: Ci.scaleX,
          scaleY: Ci.scaleY,
          rotation: Ci.rotation,
          style: {
            x: a.x,
            y: a.y,
            align: a.align,
            verticalAlign: a.verticalAlign,
            width: a.width,
            height: a.height,
            fontSize: a.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, e.prototype.addLabelsOfSeries = function(t) {
      var r = this;
      this._chartViewList.push(t);
      var n = t.__model, i = n.get("labelLayout");
      (at(i) || jt(i).length) && t.group.traverse(function(o) {
        if (o.ignore)
          return !0;
        var a = o.getTextContent(), s = St(o);
        a && !a.disableLabelLayout && r._addLabel(s.dataIndex, s.dataType, n, a, i);
      });
    }, e.prototype.updateLayoutConfig = function(t) {
      var r = t.getWidth(), n = t.getHeight();
      function i(C, S) {
        return function() {
          lV(C, S);
        };
      }
      for (var o = 0; o < this._labelList.length; o++) {
        var a = this._labelList[o], s = a.label, l = s.__hostTarget, u = a.defaultAttr, c = void 0;
        at(a.layoutOption) ? c = a.layoutOption(DRe(a, l)) : c = a.layoutOption, c = c || {}, a.computedLayoutOption = c;
        var d = Math.PI / 180;
        l && l.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: c.x != null || c.y != null ? null : u.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: c.rotate != null ? c.rotate * d : u.attachedRot,
          offset: [c.dx || 0, c.dy || 0]
        });
        var h = !1;
        if (c.x != null ? (s.x = Be(c.x, r), s.setStyle("x", 0), h = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), c.y != null ? (s.y = Be(c.y, n), s.setStyle("y", 0), h = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), c.labelLinePoints) {
          var f = l.getTextGuideLine();
          f && (f.setShape({
            points: c.labelLinePoints
          }), h = !1);
        }
        var p = Q1(s);
        p.needsUpdateLabelLine = h, s.rotation = c.rotate != null ? c.rotate * d : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var g = 0; g < uV.length; g++) {
          var v = uV[g];
          s.setStyle(v, c[v] != null ? c[v] : u.style[v]);
        }
        if (c.draggable) {
          if (s.draggable = !0, s.cursor = "move", l) {
            var m = a.seriesModel;
            if (a.dataIndex != null) {
              var y = a.seriesModel.getData(a.dataType);
              m = y.getItemModel(a.dataIndex);
            }
            s.on("drag", i(l, m.getModel("labelLine")));
          }
        } else
          s.off("drag"), s.cursor = u.cursor;
      }
    }, e.prototype.layout = function(t) {
      var r = t.getWidth(), n = t.getHeight(), i = bj(this._labelList), o = Sr(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), a = Sr(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      PRe(o, 0, r), Ej(a, 0, n);
      var s = Sr(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      Rj(s);
    }, e.prototype.processLabelsOverall = function() {
      var t = this;
      $(this._chartViewList, function(r) {
        var n = r.__model, i = r.ignoreLabelLineUpdate, o = n.isAnimationEnabled();
        r.group.traverse(function(a) {
          if (a.ignore && !a.forceLabelAnimation)
            return !0;
          var s = !i, l = a.getTextContent();
          !s && l && (s = Q1(l).needsUpdateLabelLine), s && t._updateLabelLine(a, n), o && t._animateLabels(a, n);
        });
      });
    }, e.prototype._updateLabelLine = function(t, r) {
      var n = t.getTextContent(), i = St(t), o = i.dataIndex;
      if (n && o != null) {
        var a = r.getData(i.dataType), s = a.getItemModel(o), l = {}, u = a.getItemVisual(o, "style");
        if (u) {
          var c = a.getVisual("drawType");
          l.stroke = u[c];
        }
        var d = s.getModel("labelLine");
        YD(t, qD(s), l), lV(t, d);
      }
    }, e.prototype._animateLabels = function(t, r) {
      var n = t.getTextContent(), i = t.getTextGuideLine();
      if (n && (t.forceLabelAnimation || !n.ignore && !n.invisible && !t.disableLabelAnimation && !Ph(t))) {
        var o = Q1(n), a = o.oldLayout, s = St(t), l = s.dataIndex, u = {
          x: n.x,
          y: n.y,
          rotation: n.rotation
        }, c = r.getData(s.dataType);
        if (a) {
          n.attr(a);
          var h = t.prevStates;
          h && (Ft(h, "select") >= 0 && n.attr(o.oldLayoutSelect), Ft(h, "emphasis") >= 0 && n.attr(o.oldLayoutEmphasis)), ur(n, u, r, l);
        } else if (n.attr(u), !Sf(n).valueAnimation) {
          var d = bt(n.style.opacity, 1);
          n.style.opacity = 0, jr(n, {
            style: {
              opacity: d
            }
          }, r, l);
        }
        if (o.oldLayout = u, n.states.select) {
          var f = o.oldLayoutSelect = {};
          uy(f, u, cy), uy(f, n.states.select, cy);
        }
        if (n.states.emphasis) {
          var p = o.oldLayoutEmphasis = {};
          uy(p, u, cy), uy(p, n.states.emphasis, cy);
        }
        C7(n, l, c, r, r);
      }
      if (i && !i.ignore && !i.invisible) {
        var o = ARe(i), a = o.oldLayout, g = {
          points: i.shape.points
        };
        a ? (i.attr({
          shape: a
        }), ur(i, {
          shape: g
        }, r)) : (i.setShape(g), i.style.strokePercent = 0, jr(i, {
          style: {
            strokePercent: 1
          }
        }, r)), o.oldLayout = g;
      }
    }, e;
  }()
), J1 = ar();
function ORe(e) {
  e.registerUpdateLifecycle("series:beforeupdate", function(t, r, n) {
    var i = J1(r).labelManager;
    i || (i = J1(r).labelManager = new IRe()), i.clearLabels();
  }), e.registerUpdateLifecycle("series:layoutlabels", function(t, r, n) {
    var i = J1(r).labelManager;
    n.updatedSeries.forEach(function(o) {
      i.addLabelsOfSeries(r.getViewOfSeriesModel(o));
    }), i.updateLayoutConfig(r), i.layout(r), i.processLabelsOverall();
  });
}
var ex = Math.sin, tx = Math.cos, _j = Math.PI, Ku = Math.PI * 2, LRe = 180 / _j, Tj = function() {
  function e() {
  }
  return e.prototype.reset = function(t) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, t || 4);
  }, e.prototype.moveTo = function(t, r) {
    this._add("M", t, r);
  }, e.prototype.lineTo = function(t, r) {
    this._add("L", t, r);
  }, e.prototype.bezierCurveTo = function(t, r, n, i, o, a) {
    this._add("C", t, r, n, i, o, a);
  }, e.prototype.quadraticCurveTo = function(t, r, n, i) {
    this._add("Q", t, r, n, i);
  }, e.prototype.arc = function(t, r, n, i, o, a) {
    this.ellipse(t, r, n, n, 0, i, o, a);
  }, e.prototype.ellipse = function(t, r, n, i, o, a, s, l) {
    var u = s - a, c = !l, d = Math.abs(u), h = Nl(d - Ku) || (c ? u >= Ku : -u >= Ku), f = u > 0 ? u % Ku : u % Ku + Ku, p = !1;
    h ? p = !0 : Nl(d) ? p = !1 : p = f >= _j == !!c;
    var g = t + n * tx(a), v = r + i * ex(a);
    this._start && this._add("M", g, v);
    var m = Math.round(o * LRe);
    if (h) {
      var y = 1 / this._p, C = (c ? 1 : -1) * (Ku - y);
      this._add("A", n, i, m, 1, +c, t + n * tx(a + C), r + i * ex(a + C)), y > 0.01 && this._add("A", n, i, m, 0, +c, g, v);
    } else {
      var S = t + n * tx(s), b = r + i * ex(s);
      this._add("A", n, i, m, +p, +c, S, b);
    }
  }, e.prototype.rect = function(t, r, n, i) {
    this._add("M", t, r), this._add("l", n, 0), this._add("l", 0, i), this._add("l", -n, 0), this._add("Z");
  }, e.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, e.prototype._add = function(t, r, n, i, o, a, s, l, u) {
    for (var c = [], d = this._p, h = 1; h < arguments.length; h++) {
      var f = arguments[h];
      if (isNaN(f)) {
        this._invalid = !0;
        return;
      }
      c.push(Math.round(f * d) / d);
    }
    this._d.push(t + c.join(" ")), this._start = t === "Z";
  }, e.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, e.prototype.getStr = function() {
    return this._str;
  }, e;
}(), XD = "none", FRe = Math.round;
function NRe(e) {
  var t = e.fill;
  return t != null && t !== XD;
}
function kRe(e) {
  var t = e.stroke;
  return t != null && t !== XD;
}
var uT = ["lineCap", "miterLimit", "lineJoin"], VRe = Ee(uT, function(e) {
  return "stroke-" + e.toLowerCase();
});
function BRe(e, t, r, n) {
  var i = t.opacity == null ? 1 : t.opacity;
  if (r instanceof qn) {
    e("opacity", i);
    return;
  }
  if (NRe(t)) {
    var o = Wg(t.fill);
    e("fill", o.color);
    var a = t.fillOpacity != null ? t.fillOpacity * o.opacity * i : o.opacity * i;
    a < 1 && e("fill-opacity", a);
  } else
    e("fill", XD);
  if (kRe(t)) {
    var s = Wg(t.stroke);
    e("stroke", s.color);
    var l = t.strokeNoScale ? r.getLineScale() : 1, u = l ? (t.lineWidth || 0) / l : 0, c = t.strokeOpacity != null ? t.strokeOpacity * s.opacity * i : s.opacity * i, d = t.strokeFirst;
    if (u !== 1 && e("stroke-width", u), d && e("paint-order", d ? "stroke" : "fill"), c < 1 && e("stroke-opacity", c), t.lineDash) {
      var h = DD(r), f = h[0], p = h[1];
      f && (p = FRe(p || 0), e("stroke-dasharray", f.join(",")), (p || n) && e("stroke-dashoffset", p));
    }
    for (var g = 0; g < uT.length; g++) {
      var v = uT[g];
      if (t[v] !== sC[v]) {
        var m = t[v] || sC[v];
        m && e(VRe[g], m);
      }
    }
  }
}
var Pj = "http://www.w3.org/2000/svg", Mj = "http://www.w3.org/1999/xlink", $Re = "http://www.w3.org/2000/xmlns/", HRe = "http://www.w3.org/XML/1998/namespace", cV = "ecmeta_";
function Dj(e) {
  return document.createElementNS(Pj, e);
}
function kn(e, t, r, n, i) {
  return {
    tag: e,
    attrs: r || {},
    children: n,
    text: i,
    key: t
  };
}
function GRe(e, t) {
  var r = [];
  if (t)
    for (var n in t) {
      var i = t[n], o = n;
      i !== !1 && (i !== !0 && i != null && (o += '="' + i + '"'), r.push(o));
    }
  return "<" + e + " " + r.join(" ") + ">";
}
function zRe(e) {
  return "</" + e + ">";
}
function ZD(e, t) {
  t = t || {};
  var r = t.newline ? `
` : "";
  function n(i) {
    var o = i.children, a = i.tag, s = i.attrs, l = i.text;
    return GRe(a, s) + (a !== "style" ? Ei(l) : l || "") + (o ? "" + r + Ee(o, function(u) {
      return n(u);
    }).join(r) + r : "") + zRe(a);
  }
  return n(e);
}
function WRe(e, t, r) {
  r = r || {};
  var n = r.newline ? `
` : "", i = " {" + n, o = n + "}", a = Ee(jt(e), function(l) {
    return l + i + Ee(jt(e[l]), function(u) {
      return u + ":" + e[l][u] + ";";
    }).join(n) + o;
  }).join(n), s = Ee(jt(t), function(l) {
    return "@keyframes " + l + i + Ee(jt(t[l]), function(u) {
      return u + i + Ee(jt(t[l][u]), function(c) {
        var d = t[l][u][c];
        return c === "d" && (d = 'path("' + d + '")'), c + ":" + d + ";";
      }).join(n) + o;
    }).join(n) + o;
  }).join(n);
  return !a && !s ? "" : ["<![CDATA[", a, s, "]]>"].join(n);
}
function cT(e) {
  return {
    zrId: e,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function dV(e, t, r, n) {
  return kn("svg", "root", {
    width: e,
    height: t,
    xmlns: Pj,
    "xmlns:xlink": Mj,
    version: "1.1",
    baseProfile: "full",
    viewBox: n ? "0 0 " + e + " " + t : !1
  }, r);
}
var jRe = 0;
function Aj() {
  return jRe++;
}
var hV = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, Qu = "transform-origin";
function URe(e, t, r) {
  var n = ge({}, e.shape);
  ge(n, t), e.buildPath(r, n);
  var i = new Tj();
  return i.reset(tW(e)), r.rebuildPath(i, 1), i.generateStr(), i.getStr();
}
function KRe(e, t) {
  var r = t.originX, n = t.originY;
  (r || n) && (e[Qu] = r + "px " + n + "px");
}
var YRe = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function Ij(e, t) {
  var r = t.zrId + "-ani-" + t.cssAnimIdx++;
  return t.cssAnims[r] = e, r;
}
function qRe(e, t, r) {
  var n = e.shape.paths, i = {}, o, a;
  if ($(n, function(l) {
    var u = cT(r.zrId);
    u.animation = !0, _w(l, {}, u, !0);
    var c = u.cssAnims, d = u.cssNodes, h = jt(c), f = h.length;
    if (f) {
      a = h[f - 1];
      var p = c[a];
      for (var g in p) {
        var v = p[g];
        i[g] = i[g] || { d: "" }, i[g].d += v.d || "";
      }
      for (var m in d) {
        var y = d[m].animation;
        y.indexOf(a) >= 0 && (o = y);
      }
    }
  }), !!o) {
    t.d = !1;
    var s = Ij(i, r);
    return o.replace(a, s);
  }
}
function fV(e) {
  return He(e) ? hV[e] ? "cubic-bezier(" + hV[e] + ")" : HM(e) ? e : "" : "";
}
function _w(e, t, r, n) {
  var i = e.animators, o = i.length, a = [];
  if (e instanceof sw) {
    var s = qRe(e, t, r);
    if (s)
      a.push(s);
    else if (!o)
      return;
  } else if (!o)
    return;
  for (var l = {}, u = 0; u < o; u++) {
    var c = i[u], d = [c.getMaxTime() / 1e3 + "s"], h = fV(c.getClip().easing), f = c.getDelay();
    h ? d.push(h) : d.push("linear"), f && d.push(f / 1e3 + "s"), c.getLoop() && d.push("infinite");
    var p = d.join(" ");
    l[p] = l[p] || [p, []], l[p][1].push(c);
  }
  function g(y) {
    var C = y[1], S = C.length, b = {}, w = {}, x = {}, R = "animation-timing-function";
    function _(Z, re, X) {
      for (var Y = Z.getTracks(), U = Z.getMaxTime(), oe = 0; oe < Y.length; oe++) {
        var W = Y[oe];
        if (W.needsAnimate()) {
          var ne = W.keyframes, ce = W.propName;
          if (X && (ce = X(ce)), ce)
            for (var we = 0; we < ne.length; we++) {
              var Re = ne[we], ve = Math.round(Re.time / U * 100) + "%", xe = fV(Re.easing), _e = Re.rawValue;
              (He(_e) || sr(_e)) && (re[ve] = re[ve] || {}, re[ve][ce] = Re.rawValue, xe && (re[ve][R] = xe));
            }
        }
      }
    }
    for (var T = 0; T < S; T++) {
      var P = C[T], D = P.targetName;
      D ? D === "shape" && _(P, w) : !n && _(P, b);
    }
    for (var O in b) {
      var A = {};
      aW(A, e), ge(A, b[O]);
      var F = rW(A), L = b[O][R];
      x[O] = F ? {
        transform: F
      } : {}, KRe(x[O], A), L && (x[O][R] = L);
    }
    var N, I = !0;
    for (var O in w) {
      x[O] = x[O] || {};
      var B = !N, L = w[O][R];
      B && (N = new ms());
      var M = N.len();
      N.reset(), x[O].d = URe(e, w[O], N);
      var V = N.len();
      if (!B && M !== V) {
        I = !1;
        break;
      }
      L && (x[O][R] = L);
    }
    if (!I)
      for (var O in x)
        delete x[O].d;
    if (!n)
      for (var T = 0; T < S; T++) {
        var P = C[T], D = P.targetName;
        D === "style" && _(P, x, function(Y) {
          return YRe[Y];
        });
      }
    for (var G = jt(x), k = !0, z, T = 1; T < G.length; T++) {
      var j = G[T - 1], q = G[T];
      if (x[j][Qu] !== x[q][Qu]) {
        k = !1;
        break;
      }
      z = x[j][Qu];
    }
    if (k && z) {
      for (var O in x)
        x[O][Qu] && delete x[O][Qu];
      t[Qu] = z;
    }
    if (Sr(G, function(Z) {
      return jt(x[Z]).length > 0;
    }).length) {
      var K = Ij(x, r);
      return K + " " + y[0] + " both";
    }
  }
  for (var v in l) {
    var s = g(l[v]);
    s && a.push(s);
  }
  if (a.length) {
    var m = r.zrId + "-cls-" + Aj();
    r.cssNodes["." + m] = {
      animation: a.join(",")
    }, t.class = m;
  }
}
function XRe(e, t, r) {
  if (!e.ignore)
    if (e.isSilent()) {
      var n = {
        "pointer-events": "none"
      };
      pV(n, t, r);
    } else {
      var i = e.states.emphasis && e.states.emphasis.style ? e.states.emphasis.style : {}, o = i.fill;
      if (!o) {
        var a = e.style && e.style.fill, s = e.states.select && e.states.select.style && e.states.select.style.fill, l = e.currentStates.indexOf("select") >= 0 && s || a;
        l && (o = rC(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && e.transform ? e.transform[0] : 1;
        u = u / c;
      }
      var n = {
        cursor: "pointer"
      };
      o && (n.fill = o), i.stroke && (n.stroke = i.stroke), u && (n["stroke-width"] = u), pV(n, t, r);
    }
}
function pV(e, t, r, n) {
  var i = JSON.stringify(e), o = r.cssStyleCache[i];
  o || (o = r.zrId + "-cls-" + Aj(), r.cssStyleCache[i] = o, r.cssNodes["." + o + ":hover"] = e), t.class = t.class ? t.class + " " + o : o;
}
var ev = Math.round;
function Oj(e) {
  return e && He(e.src);
}
function Lj(e) {
  return e && at(e.toDataURL);
}
function QD(e, t, r, n) {
  BRe(function(i, o) {
    var a = i === "fill" || i === "stroke";
    a && eW(o) ? Nj(t, e, i, n) : a && zM(o) ? kj(r, e, i, n) : a && o === "none" ? e[i] = "transparent" : e[i] = o;
  }, t, r, !1), n_e(r, e, n);
}
function JD(e, t) {
  var r = cW(t);
  r && (r.each(function(n, i) {
    n != null && (e[(cV + i).toLowerCase()] = n + "");
  }), t.isSilent() && (e[cV + "silent"] = "true"));
}
function gV(e) {
  return Nl(e[0] - 1) && Nl(e[1]) && Nl(e[2]) && Nl(e[3] - 1);
}
function ZRe(e) {
  return Nl(e[4]) && Nl(e[5]);
}
function eA(e, t, r) {
  if (t && !(ZRe(t) && gV(t))) {
    var n = 1e4;
    e.transform = gV(t) ? "translate(" + ev(t[4] * n) / n + " " + ev(t[5] * n) / n + ")" : z0e(t);
  }
}
function vV(e, t, r) {
  for (var n = e.points, i = [], o = 0; o < n.length; o++)
    i.push(ev(n[o][0] * r) / r), i.push(ev(n[o][1] * r) / r);
  t.points = i.join(" ");
}
function mV(e) {
  return !e.smooth;
}
function QRe(e) {
  var t = Ee(e, function(r) {
    return typeof r == "string" ? [r, r] : r;
  });
  return function(r, n, i) {
    for (var o = 0; o < t.length; o++) {
      var a = t[o], s = r[a[0]];
      s != null && (n[a[1]] = ev(s * i) / i);
    }
  };
}
var JRe = {
  circle: [QRe(["cx", "cy", "r"])],
  polyline: [vV, mV],
  polygon: [vV, mV]
};
function e_e(e) {
  for (var t = e.animators, r = 0; r < t.length; r++)
    if (t[r].targetName === "shape")
      return !0;
  return !1;
}
function Fj(e, t) {
  var r = e.style, n = e.shape, i = JRe[e.type], o = {}, a = t.animation, s = "path", l = e.style.strokePercent, u = t.compress && tW(e) || 4;
  if (i && !t.willUpdate && !(i[1] && !i[1](n)) && !(a && e_e(e)) && !(l < 1)) {
    s = e.type;
    var c = Math.pow(10, u);
    i[0](n, o, c);
  } else {
    var d = !e.path || e.shapeChanged();
    e.path || e.createPathProxy();
    var h = e.path;
    d && (h.beginPath(), e.buildPath(h, e.shape), e.pathUpdated());
    var f = h.getVersion(), p = e, g = p.__svgPathBuilder;
    (p.__svgPathVersion !== f || !g || l !== p.__svgPathStrokePercent) && (g || (g = p.__svgPathBuilder = new Tj()), g.reset(u), h.rebuildPath(g, l), g.generateStr(), p.__svgPathVersion = f, p.__svgPathStrokePercent = l), o.d = g.getStr();
  }
  return eA(o, e.transform), QD(o, r, e, t), JD(o, e), t.animation && _w(e, o, t), t.emphasis && XRe(e, o, t), kn(s, e.id + "", o);
}
function t_e(e, t) {
  var r = e.style, n = r.image;
  if (n && !He(n) && (Oj(n) ? n = n.src : Lj(n) && (n = n.toDataURL())), !!n) {
    var i = r.x || 0, o = r.y || 0, a = r.width, s = r.height, l = {
      href: n,
      width: a,
      height: s
    };
    return i && (l.x = i), o && (l.y = o), eA(l, e.transform), QD(l, r, e, t), JD(l, e), t.animation && _w(e, l, t), kn("image", e.id + "", l);
  }
}
function r_e(e, t) {
  var r = e.style, n = r.text;
  if (n != null && (n += ""), !(!n || isNaN(r.x) || isNaN(r.y))) {
    var i = r.font || tu, o = r.x || 0, a = j0e(r.y || 0, qS(i), r.textBaseline), s = W0e[r.textAlign] || r.textAlign, l = {
      "dominant-baseline": "central",
      "text-anchor": s
    };
    if (kW(r)) {
      var u = "", c = r.fontStyle, d = NW(r.fontSize);
      if (!parseFloat(d))
        return;
      var h = r.fontFamily || _6, f = r.fontWeight;
      u += "font-size:" + d + ";font-family:" + h + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), f && f !== "normal" && (u += "font-weight:" + f + ";"), l.style = u;
    } else
      l.style = "font: " + i;
    return n.match(/\s/) && (l["xml:space"] = "preserve"), o && (l.x = o), a && (l.y = a), eA(l, e.transform), QD(l, r, e, t), JD(l, e), t.animation && _w(e, l, t), kn("text", e.id + "", l, void 0, n);
  }
}
function yV(e, t) {
  if (e instanceof Ht)
    return Fj(e, t);
  if (e instanceof qn)
    return t_e(e, t);
  if (e instanceof jh)
    return r_e(e, t);
}
function n_e(e, t, r) {
  var n = e.style;
  if (U0e(n)) {
    var i = K0e(e), o = r.shadowCache, a = o[i];
    if (!a) {
      var s = e.getGlobalScale(), l = s[0], u = s[1];
      if (!l || !u)
        return;
      var c = n.shadowOffsetX || 0, d = n.shadowOffsetY || 0, h = n.shadowBlur, f = Wg(n.shadowColor), p = f.opacity, g = f.color, v = h / 2 / l, m = h / 2 / u, y = v + " " + m;
      a = r.zrId + "-s" + r.shadowIdx++, r.defs[a] = kn("filter", a, {
        id: a,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        kn("feDropShadow", "", {
          dx: c / l,
          dy: d / u,
          stdDeviation: y,
          "flood-color": g,
          "flood-opacity": p
        })
      ]), o[i] = a;
    }
    t.filter = YS(a);
  }
}
function Nj(e, t, r, n) {
  var i = e[r], o, a = {
    gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (Q6(i))
    o = "linearGradient", a.x1 = i.x, a.y1 = i.y, a.x2 = i.x2, a.y2 = i.y2;
  else if (J6(i))
    o = "radialGradient", a.cx = bt(i.x, 0.5), a.cy = bt(i.y, 0.5), a.r = bt(i.r, 0.5);
  else {
    process.env.NODE_ENV !== "production" && Ko("Illegal gradient type.");
    return;
  }
  for (var s = i.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
    var d = y_(s[u].offset) * 100 + "%", h = s[u].color, f = Wg(h), p = f.color, g = f.opacity, v = {
      offset: d
    };
    v["stop-color"] = p, g < 1 && (v["stop-opacity"] = g), l.push(kn("stop", u + "", v));
  }
  var m = kn(o, "", a, l), y = ZD(m), C = n.gradientCache, S = C[y];
  S || (S = n.zrId + "-g" + n.gradientIdx++, C[y] = S, a.id = S, n.defs[S] = kn(o, S, a, l)), t[r] = YS(S);
}
function kj(e, t, r, n) {
  var i = e.style[r], o = e.getBoundingRect(), a = {}, s = i.repeat, l = s === "no-repeat", u = s === "repeat-x", c = s === "repeat-y", d;
  if (Z6(i)) {
    var h = i.imageWidth, f = i.imageHeight, p = void 0, g = i.image;
    if (He(g) ? p = g : Oj(g) ? p = g.src : Lj(g) && (p = g.toDataURL()), typeof Image > "u") {
      var v = "Image width/height must been given explictly in svg-ssr renderer.";
      ct(h, v), ct(f, v);
    } else if (h == null || f == null) {
      var m = function(T, P) {
        if (T) {
          var D = T.elm, O = h || P.width, A = f || P.height;
          T.tag === "pattern" && (u ? (A = 1, O /= o.width) : c && (O = 1, A /= o.height)), T.attrs.width = O, T.attrs.height = A, D && (D.setAttribute("width", O), D.setAttribute("height", A));
        }
      }, y = ZM(p, null, e, function(T) {
        l || m(w, T), m(d, T);
      });
      y && y.width && y.height && (h = h || y.width, f = f || y.height);
    }
    d = kn("image", "img", {
      href: p,
      width: h,
      height: f
    }), a.width = h, a.height = f;
  } else i.svgElement && (d = dt(i.svgElement), a.width = i.svgWidth, a.height = i.svgHeight);
  if (d) {
    var C, S;
    l ? C = S = 1 : u ? (S = 1, C = a.width / o.width) : c ? (C = 1, S = a.height / o.height) : a.patternUnits = "userSpaceOnUse", C != null && !isNaN(C) && (a.width = C), S != null && !isNaN(S) && (a.height = S);
    var b = rW(i);
    b && (a.patternTransform = b);
    var w = kn("pattern", "", a, [d]), x = ZD(w), R = n.patternCache, _ = R[x];
    _ || (_ = n.zrId + "-p" + n.patternIdx++, R[x] = _, a.id = _, w = n.defs[_] = kn("pattern", _, a, [d])), t[r] = YS(_);
  }
}
function i_e(e, t, r) {
  var n = r.clipPathCache, i = r.defs, o = n[e.id];
  if (!o) {
    o = r.zrId + "-c" + r.clipPathIdx++;
    var a = {
      id: o
    };
    n[e.id] = o, i[o] = kn("clipPath", o, a, [Fj(e, r)]);
  }
  t["clip-path"] = YS(o);
}
function CV(e) {
  return document.createTextNode(e);
}
function lc(e, t, r) {
  e.insertBefore(t, r);
}
function SV(e, t) {
  e.removeChild(t);
}
function wV(e, t) {
  e.appendChild(t);
}
function Vj(e) {
  return e.parentNode;
}
function Bj(e) {
  return e.nextSibling;
}
function rx(e, t) {
  e.textContent = t;
}
var bV = 58, o_e = 120, a_e = kn("", "");
function dT(e) {
  return e === void 0;
}
function Qa(e) {
  return e !== void 0;
}
function s_e(e, t, r) {
  for (var n = {}, i = t; i <= r; ++i) {
    var o = e[i].key;
    o !== void 0 && (process.env.NODE_ENV !== "production" && n[o] != null && console.error("Duplicate key " + o), n[o] = i);
  }
  return n;
}
function Vp(e, t) {
  var r = e.key === t.key, n = e.tag === t.tag;
  return n && r;
}
function tv(e) {
  var t, r = e.children, n = e.tag;
  if (Qa(n)) {
    var i = e.elm = Dj(n);
    if (tA(a_e, e), be(r))
      for (t = 0; t < r.length; ++t) {
        var o = r[t];
        o != null && wV(i, tv(o));
      }
    else Qa(e.text) && !lt(e.text) && wV(i, CV(e.text));
  } else
    e.elm = CV(e.text);
  return e.elm;
}
function $j(e, t, r, n, i) {
  for (; n <= i; ++n) {
    var o = r[n];
    o != null && lc(e, tv(o), t);
  }
}
function DC(e, t, r, n) {
  for (; r <= n; ++r) {
    var i = t[r];
    if (i != null)
      if (Qa(i.tag)) {
        var o = Vj(i.elm);
        SV(o, i.elm);
      } else
        SV(e, i.elm);
  }
}
function tA(e, t) {
  var r, n = t.elm, i = e && e.attrs || {}, o = t.attrs || {};
  if (i !== o) {
    for (r in o) {
      var a = o[r], s = i[r];
      s !== a && (a === !0 ? n.setAttribute(r, "") : a === !1 ? n.removeAttribute(r) : r === "style" ? n.style.cssText = a : r.charCodeAt(0) !== o_e ? n.setAttribute(r, a) : r === "xmlns:xlink" || r === "xmlns" ? n.setAttributeNS($Re, r, a) : r.charCodeAt(3) === bV ? n.setAttributeNS(HRe, r, a) : r.charCodeAt(5) === bV ? n.setAttributeNS(Mj, r, a) : n.setAttribute(r, a));
    }
    for (r in i)
      r in o || n.removeAttribute(r);
  }
}
function l_e(e, t, r) {
  for (var n = 0, i = 0, o = t.length - 1, a = t[0], s = t[o], l = r.length - 1, u = r[0], c = r[l], d, h, f, p; n <= o && i <= l; )
    a == null ? a = t[++n] : s == null ? s = t[--o] : u == null ? u = r[++i] : c == null ? c = r[--l] : Vp(a, u) ? (oh(a, u), a = t[++n], u = r[++i]) : Vp(s, c) ? (oh(s, c), s = t[--o], c = r[--l]) : Vp(a, c) ? (oh(a, c), lc(e, a.elm, Bj(s.elm)), a = t[++n], c = r[--l]) : Vp(s, u) ? (oh(s, u), lc(e, s.elm, a.elm), s = t[--o], u = r[++i]) : (dT(d) && (d = s_e(t, n, o)), h = d[u.key], dT(h) ? lc(e, tv(u), a.elm) : (f = t[h], f.tag !== u.tag ? lc(e, tv(u), a.elm) : (oh(f, u), t[h] = void 0, lc(e, f.elm, a.elm))), u = r[++i]);
  (n <= o || i <= l) && (n > o ? (p = r[l + 1] == null ? null : r[l + 1].elm, $j(e, p, r, i, l)) : DC(e, t, n, o));
}
function oh(e, t) {
  var r = t.elm = e.elm, n = e.children, i = t.children;
  e !== t && (tA(e, t), dT(t.text) ? Qa(n) && Qa(i) ? n !== i && l_e(r, n, i) : Qa(i) ? (Qa(e.text) && rx(r, ""), $j(r, null, i, 0, i.length - 1)) : Qa(n) ? DC(r, n, 0, n.length - 1) : Qa(e.text) && rx(r, "") : e.text !== t.text && (Qa(n) && DC(r, n, 0, n.length - 1), rx(r, t.text)));
}
function u_e(e, t) {
  if (Vp(e, t))
    oh(e, t);
  else {
    var r = e.elm, n = Vj(r);
    tv(t), n !== null && (lc(n, t.elm, Bj(r)), DC(n, [e], 0, 0));
  }
  return t;
}
var c_e = 0, d_e = function() {
  function e(t, r, n) {
    if (this.type = "svg", this.refreshHover = xV("refreshHover"), this.configLayer = xV("configLayer"), this.storage = r, this._opts = n = ge({}, n), this.root = t, this._id = "zr" + c_e++, this._oldVNode = dV(n.width, n.height), t && !n.ssr) {
      var i = this._viewport = document.createElement("div");
      i.style.cssText = "position:relative;overflow:hidden";
      var o = this._svgDom = this._oldVNode.elm = Dj("svg");
      tA(null, this._oldVNode), i.appendChild(o), t.appendChild(i);
    }
    this.resize(n.width, n.height);
  }
  return e.prototype.getType = function() {
    return this.type;
  }, e.prototype.getViewportRoot = function() {
    return this._viewport;
  }, e.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, e.prototype.getSvgDom = function() {
    return this._svgDom;
  }, e.prototype.refresh = function() {
    if (this.root) {
      var t = this.renderToVNode({
        willUpdate: !0
      });
      t.attrs.style = "position:absolute;left:0;top:0;user-select:none", u_e(this._oldVNode, t), this._oldVNode = t;
    }
  }, e.prototype.renderOneToVNode = function(t) {
    return yV(t, cT(this._id));
  }, e.prototype.renderToVNode = function(t) {
    t = t || {};
    var r = this.storage.getDisplayList(!0), n = this._width, i = this._height, o = cT(this._id);
    o.animation = t.animation, o.willUpdate = t.willUpdate, o.compress = t.compress, o.emphasis = t.emphasis;
    var a = [], s = this._bgVNode = h_e(n, i, this._backgroundColor, o);
    s && a.push(s);
    var l = t.compress ? null : this._mainVNode = kn("g", "main", {}, []);
    this._paintList(r, o, l ? l.children : a), l && a.push(l);
    var u = Ee(jt(o.defs), function(h) {
      return o.defs[h];
    });
    if (u.length && a.push(kn("defs", "defs", {}, u)), t.animation) {
      var c = WRe(o.cssNodes, o.cssAnims, { newline: !0 });
      if (c) {
        var d = kn("style", "stl", {}, [], c);
        a.push(d);
      }
    }
    return dV(n, i, a, t.useViewBox);
  }, e.prototype.renderToString = function(t) {
    return t = t || {}, ZD(this.renderToVNode({
      animation: bt(t.cssAnimation, !0),
      emphasis: bt(t.cssEmphasis, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: bt(t.useViewBox, !0)
    }), { newline: !0 });
  }, e.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t;
  }, e.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, e.prototype._paintList = function(t, r, n) {
    for (var i = t.length, o = [], a = 0, s, l, u = 0, c = 0; c < i; c++) {
      var d = t[c];
      if (!d.invisible) {
        var h = d.__clipPaths, f = h && h.length || 0, p = l && l.length || 0, g = void 0;
        for (g = Math.max(f - 1, p - 1); g >= 0 && !(h && l && h[g] === l[g]); g--)
          ;
        for (var v = p - 1; v > g; v--)
          a--, s = o[a - 1];
        for (var m = g + 1; m < f; m++) {
          var y = {};
          i_e(h[m], y, r);
          var C = kn("g", "clip-g-" + u++, y, []);
          (s ? s.children : n).push(C), o[a++] = C, s = C;
        }
        l = h;
        var S = yV(d, r);
        S && (s ? s.children : n).push(S);
      }
    }
  }, e.prototype.resize = function(t, r) {
    var n = this._opts, i = this.root, o = this._viewport;
    if (t != null && (n.width = t), r != null && (n.height = r), i && o && (o.style.display = "none", t = vh(i, 0, n), r = vh(i, 1, n), o.style.display = ""), this._width !== t || this._height !== r) {
      if (this._width = t, this._height = r, o) {
        var a = o.style;
        a.width = t + "px", a.height = r + "px";
      }
      if (zM(this._backgroundColor))
        this.refresh();
      else {
        var s = this._svgDom;
        s && (s.setAttribute("width", t), s.setAttribute("height", r));
        var l = this._bgVNode && this._bgVNode.elm;
        l && (l.setAttribute("width", t), l.setAttribute("height", r));
      }
    }
  }, e.prototype.getWidth = function() {
    return this._width;
  }, e.prototype.getHeight = function() {
    return this._height;
  }, e.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, e.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, e.prototype.toDataURL = function(t) {
    var r = this.renderToString(), n = "data:image/svg+xml;";
    return t ? (r = q0e(r), r && n + "base64," + r) : n + "charset=UTF-8," + encodeURIComponent(r);
  }, e;
}();
function xV(e) {
  return function() {
    process.env.NODE_ENV !== "production" && Ko('In SVG mode painter not support method "' + e + '"');
  };
}
function h_e(e, t, r, n) {
  var i;
  if (r && r !== "none")
    if (i = kn("rect", "bg", {
      width: e,
      height: t,
      x: "0",
      y: "0"
    }), eW(r))
      Nj({ fill: r }, i.attrs, "fill", n);
    else if (zM(r))
      kj({
        style: {
          fill: r
        },
        dirty: un,
        getBoundingRect: function() {
          return { width: e, height: t };
        }
      }, i.attrs, "fill", n);
    else {
      var o = Wg(r), a = o.color, s = o.opacity;
      i.attrs.fill = a, s < 1 && (i.attrs["fill-opacity"] = s);
    }
  return i;
}
function f_e(e) {
  e.registerPainter("svg", d_e);
}
function EV(e, t, r) {
  var n = Ia.createCanvas(), i = t.getWidth(), o = t.getHeight(), a = n.style;
  return a && (a.position = "absolute", a.left = "0", a.top = "0", a.width = i + "px", a.height = o + "px", n.setAttribute("data-zr-dom-id", e)), n.width = i * r, n.height = o * r, n;
}
var nx = function(e) {
  Ur(t, e);
  function t(r, n, i) {
    var o = e.call(this) || this;
    o.motionBlur = !1, o.lastFrameAlpha = 0.7, o.dpr = 1, o.virtual = !1, o.config = {}, o.incremental = !1, o.zlevel = 0, o.maxRepaintRectCount = 5, o.__dirty = !0, o.__firstTimePaint = !0, o.__used = !1, o.__drawIndex = 0, o.__startIndex = 0, o.__endIndex = 0, o.__prevStartIndex = null, o.__prevEndIndex = null;
    var a;
    i = i || iC, typeof r == "string" ? a = EV(r, n, i) : lt(r) && (a = r, r = a.id), o.id = r, o.dom = a;
    var s = a.style;
    return s && (VM(a), a.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), o.painter = n, o.dpr = i, o;
  }
  return t.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, t.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, t.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, t.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, t.prototype.createBackBuffer = function() {
    var r = this.dpr;
    this.domBack = EV("back-" + this.id, this.painter, r), this.ctxBack = this.domBack.getContext("2d"), r !== 1 && this.ctxBack.scale(r, r);
  }, t.prototype.createRepaintRects = function(r, n, i, o) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var a = [], s = this.maxRepaintRectCount, l = !1, u = new At(0, 0, 0, 0);
    function c(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (a.length === 0) {
          var C = new At(0, 0, 0, 0);
          C.copy(y), a.push(C);
        } else {
          for (var S = !1, b = 1 / 0, w = 0, x = 0; x < a.length; ++x) {
            var R = a[x];
            if (R.intersect(y)) {
              var _ = new At(0, 0, 0, 0);
              _.copy(R), _.union(y), a[x] = _, S = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(R);
              var T = y.width * y.height, P = R.width * R.height, D = u.width * u.height, O = D - T - P;
              O < b && (b = O, w = x);
            }
          }
          if (l && (a[w].union(y), S = !0), !S) {
            var C = new At(0, 0, 0, 0);
            C.copy(y), a.push(C);
          }
          l || (l = a.length >= s);
        }
    }
    for (var d = this.__startIndex; d < this.__endIndex; ++d) {
      var h = r[d];
      if (h) {
        var f = h.shouldBePainted(i, o, !0, !0), p = h.__isRendered && (h.__dirty & ho || !f) ? h.getPrevPaintRect() : null;
        p && c(p);
        var g = f && (h.__dirty & ho || !h.__isRendered) ? h.getPaintRect() : null;
        g && c(g);
      }
    }
    for (var d = this.__prevStartIndex; d < this.__prevEndIndex; ++d) {
      var h = n[d], f = h && h.shouldBePainted(i, o, !0, !0);
      if (h && (!f || !h.__zr) && h.__isRendered) {
        var p = h.getPrevPaintRect();
        p && c(p);
      }
    }
    var v;
    do {
      v = !1;
      for (var d = 0; d < a.length; ) {
        if (a[d].isZero()) {
          a.splice(d, 1);
          continue;
        }
        for (var m = d + 1; m < a.length; )
          a[d].intersect(a[m]) ? (v = !0, a[d].union(a[m]), a.splice(m, 1)) : m++;
        d++;
      }
    } while (v);
    return this._paintRects = a, a;
  }, t.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, t.prototype.resize = function(r, n) {
    var i = this.dpr, o = this.dom, a = o.style, s = this.domBack;
    a && (a.width = r + "px", a.height = n + "px"), o.width = r * i, o.height = n * i, s && (s.width = r * i, s.height = n * i, i !== 1 && this.ctxBack.scale(i, i));
  }, t.prototype.clear = function(r, n, i) {
    var o = this.dom, a = this.ctx, s = o.width, l = o.height;
    n = n || this.clearColor;
    var u = this.motionBlur && !r, c = this.lastFrameAlpha, d = this.dpr, h = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(o, 0, 0, s / d, l / d));
    var f = this.domBack;
    function p(g, v, m, y) {
      if (a.clearRect(g, v, m, y), n && n !== "transparent") {
        var C = void 0;
        if (Dv(n)) {
          var S = n.global || n.__width === m && n.__height === y;
          C = S && n.__canvasGradient || eT(a, n, {
            x: 0,
            y: 0,
            width: m,
            height: y
          }), n.__canvasGradient = C, n.__width = m, n.__height = y;
        } else A6(n) && (n.scaleX = n.scaleX || d, n.scaleY = n.scaleY || d, C = tT(a, n, {
          dirty: function() {
            h.setUnpainted(), h.painter.refresh();
          }
        }));
        a.save(), a.fillStyle = C || n, a.fillRect(g, v, m, y), a.restore();
      }
      u && (a.save(), a.globalAlpha = c, a.drawImage(f, g, v, m, y), a.restore());
    }
    !i || u ? p(0, 0, s, l) : i.length && $(i, function(g) {
      p(g.x * d, g.y * d, g.width * d, g.height * d);
    });
  }, t;
}(na), RV = 1e5, Yu = 314159, dy = 0.01, p_e = 1e-3;
function g_e(e) {
  return e ? e.__builtin__ ? !0 : !(typeof e.resize != "function" || typeof e.refresh != "function") : !1;
}
function v_e(e, t) {
  var r = document.createElement("div");
  return r.style.cssText = [
    "position:relative",
    "width:" + e + "px",
    "height:" + t + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", r;
}
var m_e = function() {
  function e(t, r, n, i) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var o = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    this._opts = n = ge({}, n || {}), this.dpr = n.devicePixelRatio || iC, this._singleCanvas = o, this.root = t;
    var a = t.style;
    a && (VM(t), t.innerHTML = ""), this.storage = r;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (o) {
      var c = t, d = c.width, h = c.height;
      n.width != null && (d = n.width), n.height != null && (h = n.height), this.dpr = n.devicePixelRatio || 1, c.width = d * this.dpr, c.height = h * this.dpr, this._width = d, this._height = h;
      var f = new nx(c, this, this.dpr);
      f.__builtin__ = !0, f.initContext(), l[Yu] = f, f.zlevel = Yu, s.push(Yu), this._domRoot = t;
    } else {
      this._width = vh(t, 0, n), this._height = vh(t, 1, n);
      var u = this._domRoot = v_e(this._width, this._height);
      t.appendChild(u);
    }
  }
  return e.prototype.getType = function() {
    return "canvas";
  }, e.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, e.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, e.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, e.prototype.refresh = function(t) {
    var r = this.storage.getDisplayList(!0), n = this._prevDisplayList, i = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(r, n, t, this._redrawId);
    for (var o = 0; o < i.length; o++) {
      var a = i[o], s = this._layers[a];
      if (!s.__builtin__ && s.refresh) {
        var l = o === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = r.slice()), this;
  }, e.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, e.prototype._paintHoverList = function(t) {
    var r = t.length, n = this._hoverlayer;
    if (n && n.clear(), !!r) {
      for (var i = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, o, a = 0; a < r; a++) {
        var s = t[a];
        s.__inHover && (n || (n = this._hoverlayer = this.getLayer(RV)), o || (o = n.ctx, o.save()), wc(o, s, i, a === r - 1));
      }
      o && o.restore();
    }
  }, e.prototype.getHoverLayer = function() {
    return this.getLayer(RV);
  }, e.prototype.paintOne = function(t, r) {
    AD(t, r);
  }, e.prototype._paintList = function(t, r, n, i) {
    if (this._redrawId === i) {
      n = n || !1, this._updateLayerStatus(t);
      var o = this._doPaintList(t, r, n), a = o.finished, s = o.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(t), a)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        Q0(function() {
          l._paintList(t, r, n, i);
        });
      }
    }
  }, e.prototype._compositeManually = function() {
    var t = this.getLayer(Yu).ctx, r = this._domRoot.width, n = this._domRoot.height;
    t.clearRect(0, 0, r, n), this.eachBuiltinLayer(function(i) {
      i.virtual && t.drawImage(i.dom, 0, 0, r, n);
    });
  }, e.prototype._doPaintList = function(t, r, n) {
    for (var i = this, o = [], a = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && o.push(u);
    }
    for (var c = !0, d = !1, h = function(g) {
      var v = o[g], m = v.ctx, y = a && v.createRepaintRects(t, r, f._width, f._height), C = n ? v.__startIndex : v.__drawIndex, S = !n && v.incremental && Date.now, b = S && Date.now(), w = v.zlevel === f._zlevelList[0] ? f._backgroundColor : null;
      if (v.__startIndex === v.__endIndex)
        v.clear(!1, w, y);
      else if (C === v.__startIndex) {
        var x = t[C];
        (!x.incremental || !x.notClear || n) && v.clear(!1, w, y);
      }
      C === -1 && (console.error("For some unknown reason. drawIndex is -1"), C = v.__startIndex);
      var R, _ = function(O) {
        var A = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: i._width,
          viewHeight: i._height
        };
        for (R = C; R < v.__endIndex; R++) {
          var F = t[R];
          if (F.__inHover && (d = !0), i._doPaintEl(F, v, a, O, A, R === v.__endIndex - 1), S) {
            var L = Date.now() - b;
            if (L > 15)
              break;
          }
        }
        A.prevElClipPaths && m.restore();
      };
      if (y)
        if (y.length === 0)
          R = v.__endIndex;
        else
          for (var T = f.dpr, P = 0; P < y.length; ++P) {
            var D = y[P];
            m.save(), m.beginPath(), m.rect(D.x * T, D.y * T, D.width * T, D.height * T), m.clip(), _(D), m.restore();
          }
      else
        m.save(), _(), m.restore();
      v.__drawIndex = R, v.__drawIndex < v.__endIndex && (c = !1);
    }, f = this, p = 0; p < o.length; p++)
      h(p);
    return nr.wxa && $(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: d
    };
  }, e.prototype._doPaintEl = function(t, r, n, i, o, a) {
    var s = r.ctx;
    if (n) {
      var l = t.getPaintRect();
      (!i || l && l.intersect(i)) && (wc(s, t, o, a), t.setPrevPaintRect(l));
    } else
      wc(s, t, o, a);
  }, e.prototype.getLayer = function(t, r) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = Yu);
    var n = this._layers[t];
    return n || (n = new nx("zr_" + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] ? Mt(n, this._layerConfig[t], !0) : this._layerConfig[t - dy] && Mt(n, this._layerConfig[t - dy], !0), r && (n.virtual = r), this.insertLayer(t, n), n.initContext()), n;
  }, e.prototype.insertLayer = function(t, r) {
    var n = this._layers, i = this._zlevelList, o = i.length, a = this._domRoot, s = null, l = -1;
    if (n[t]) {
      process.env.NODE_ENV !== "production" && Ko("ZLevel " + t + " has been used already");
      return;
    }
    if (!g_e(r)) {
      process.env.NODE_ENV !== "production" && Ko("Layer of zlevel " + t + " is not valid");
      return;
    }
    if (o > 0 && t > i[0]) {
      for (l = 0; l < o - 1 && !(i[l] < t && i[l + 1] > t); l++)
        ;
      s = n[i[l]];
    }
    if (i.splice(l + 1, 0, t), n[t] = r, !r.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? a.insertBefore(r.dom, u.nextSibling) : a.appendChild(r.dom);
      } else
        a.firstChild ? a.insertBefore(r.dom, a.firstChild) : a.appendChild(r.dom);
    r.painter || (r.painter = this);
  }, e.prototype.eachLayer = function(t, r) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var o = n[i];
      t.call(r, this._layers[o], o);
    }
  }, e.prototype.eachBuiltinLayer = function(t, r) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var o = n[i], a = this._layers[o];
      a.__builtin__ && t.call(r, a, o);
    }
  }, e.prototype.eachOtherLayer = function(t, r) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var o = n[i], a = this._layers[o];
      a.__builtin__ || t.call(r, a, o);
    }
  }, e.prototype.getLayers = function() {
    return this._layers;
  }, e.prototype._updateLayerStatus = function(t) {
    this.eachBuiltinLayer(function(d, h) {
      d.__dirty = d.__used = !1;
    });
    function r(d) {
      o && (o.__endIndex !== d && (o.__dirty = !0), o.__endIndex = d);
    }
    if (this._singleCanvas)
      for (var n = 1; n < t.length; n++) {
        var i = t[n];
        if (i.zlevel !== t[n - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var o = null, a = 0, s, l;
    for (l = 0; l < t.length; l++) {
      var i = t[l], u = i.zlevel, c = void 0;
      s !== u && (s = u, a = 0), i.incremental ? (c = this.getLayer(u + p_e, this._needsManuallyCompositing), c.incremental = !0, a = 1) : c = this.getLayer(u + (a > 0 ? dy : 0), this._needsManuallyCompositing), c.__builtin__ || Ko("ZLevel " + u + " has been used by unkown layer " + c.id), c !== o && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, r(l), o = c), i.__dirty & ho && !i.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    r(l), this.eachBuiltinLayer(function(d, h) {
      !d.__used && d.getElementCount() > 0 && (d.__dirty = !0, d.__startIndex = d.__endIndex = d.__drawIndex = 0), d.__dirty && d.__drawIndex < 0 && (d.__drawIndex = d.__startIndex);
    });
  }, e.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, e.prototype._clearLayer = function(t) {
    t.clear();
  }, e.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t, $(this._layers, function(r) {
      r.setUnpainted();
    });
  }, e.prototype.configLayer = function(t, r) {
    if (r) {
      var n = this._layerConfig;
      n[t] ? Mt(n[t], r, !0) : n[t] = r;
      for (var i = 0; i < this._zlevelList.length; i++) {
        var o = this._zlevelList[i];
        if (o === t || o === t + dy) {
          var a = this._layers[o];
          Mt(a, n[t], !0);
        }
      }
    }
  }, e.prototype.delLayer = function(t) {
    var r = this._layers, n = this._zlevelList, i = r[t];
    i && (i.dom.parentNode.removeChild(i.dom), delete r[t], n.splice(Ft(n, t), 1));
  }, e.prototype.resize = function(t, r) {
    if (this._domRoot.style) {
      var n = this._domRoot;
      n.style.display = "none";
      var i = this._opts, o = this.root;
      if (t != null && (i.width = t), r != null && (i.height = r), t = vh(o, 0, i), r = vh(o, 1, i), n.style.display = "", this._width !== t || r !== this._height) {
        n.style.width = t + "px", n.style.height = r + "px";
        for (var a in this._layers)
          this._layers.hasOwnProperty(a) && this._layers[a].resize(t, r);
        this.refresh(!0);
      }
      this._width = t, this._height = r;
    } else {
      if (t == null || r == null)
        return;
      this._width = t, this._height = r, this.getLayer(Yu).resize(t, r);
    }
    return this;
  }, e.prototype.clearLayer = function(t) {
    var r = this._layers[t];
    r && r.clear();
  }, e.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, e.prototype.getRenderedCanvas = function(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Yu].dom;
    var r = new nx("image", this, t.pixelRatio || this.dpr);
    r.initContext(), r.clear(!1, t.backgroundColor || this._backgroundColor);
    var n = r.ctx;
    if (t.pixelRatio <= this.dpr) {
      this.refresh();
      var i = r.dom.width, o = r.dom.height;
      this.eachLayer(function(d) {
        d.__builtin__ ? n.drawImage(d.dom, 0, 0, i, o) : d.renderToCanvas && (n.save(), d.renderToCanvas(n), n.restore());
      });
    } else
      for (var a = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        wc(n, c, a, l === u - 1);
      }
    return r.dom;
  }, e.prototype.getWidth = function() {
    return this._width;
  }, e.prototype.getHeight = function() {
    return this._height;
  }, e;
}();
function y_e(e) {
  e.registerPainter("canvas", m_e);
}
var C_e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.getInitialData = function(r) {
      if (process.env.NODE_ENV !== "production") {
        var n = r.coordinateSystem;
        if (n !== "polar" && n !== "cartesian2d")
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
      return ws(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getLegendIcon = function(r) {
      var n = new Ct(), i = mn("line", 0, r.itemHeight / 2, r.itemWidth, 0, r.lineStyle.stroke, !1);
      n.add(i), i.setStyle(r.lineStyle);
      var o = this.getData().getVisual("symbol"), a = this.getData().getVisual("symbolRotate"), s = o === "none" ? "circle" : o, l = r.itemHeight * 0.8, u = mn(s, (r.itemWidth - l) / 2, (r.itemHeight - l) / 2, l, l, r.itemStyle.fill);
      n.add(u), u.setStyle(r.itemStyle);
      var c = r.iconRotate === "inherit" ? a : r.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([r.itemWidth / 2, r.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), n;
    }, t.type = "series.line", t.dependencies = ["grid", "polar"], t.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, t;
  }(Pr)
);
function qh(e, t) {
  var r = e.mapDimensionsAll("defaultedLabel"), n = r.length;
  if (n === 1) {
    var i = Kh(e, t, r[0]);
    return i != null ? i + "" : null;
  } else if (n) {
    for (var o = [], a = 0; a < r.length; a++)
      o.push(Kh(e, t, r[a]));
    return o.join(" ");
  }
}
function Hj(e, t) {
  var r = e.mapDimensionsAll("defaultedLabel");
  if (!be(t))
    return t + "";
  for (var n = [], i = 0; i < r.length; i++) {
    var o = e.getDimensionIndex(r[i]);
    o >= 0 && n.push(t[o]);
  }
  return n.join(" ");
}
var jv = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i, o) {
      var a = e.call(this) || this;
      return a.updateData(r, n, i, o), a;
    }
    return t.prototype._createSymbol = function(r, n, i, o, a) {
      this.removeAll();
      var s = mn(r, -1, -1, 2, 2, null, a);
      s.attr({
        z2: 100,
        culling: !0,
        scaleX: o[0] / 2,
        scaleY: o[1] / 2
      }), s.drift = S_e, this._symbolType = r, this.add(s);
    }, t.prototype.stopSymbolAnimation = function(r) {
      this.childAt(0).stopAnimation(null, r);
    }, t.prototype.getSymbolType = function() {
      return this._symbolType;
    }, t.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, t.prototype.highlight = function() {
      Qs(this.childAt(0));
    }, t.prototype.downplay = function() {
      Js(this.childAt(0));
    }, t.prototype.setZ = function(r, n) {
      var i = this.childAt(0);
      i.zlevel = r, i.z = n;
    }, t.prototype.setDraggable = function(r, n) {
      var i = this.childAt(0);
      i.draggable = r, i.cursor = !n && r ? "move" : i.cursor;
    }, t.prototype.updateData = function(r, n, i, o) {
      this.silent = !1;
      var a = r.getItemVisual(n, "symbol") || "circle", s = r.hostModel, l = t.getSymbolSize(r, n), u = a !== this._symbolType, c = o && o.disableAnimation;
      if (u) {
        var d = r.getItemVisual(n, "symbolKeepAspect");
        this._createSymbol(a, r, n, l, d);
      } else {
        var h = this.childAt(0);
        h.silent = !1;
        var f = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        c ? h.attr(f) : ur(h, f, s, n), Fa(h);
      }
      if (this._updateCommon(r, n, l, i, o), u) {
        var h = this.childAt(0);
        if (!c) {
          var f = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: h.style.opacity
            }
          };
          h.scaleX = h.scaleY = 0, h.style.opacity = 0, jr(h, f, s, n);
        }
      }
      c && this.childAt(0).stopAnimation("leave");
    }, t.prototype._updateCommon = function(r, n, i, o, a) {
      var s = this.childAt(0), l = r.hostModel, u, c, d, h, f, p, g, v, m;
      if (o && (u = o.emphasisItemStyle, c = o.blurItemStyle, d = o.selectItemStyle, h = o.focus, f = o.blurScope, g = o.labelStatesModels, v = o.hoverScale, m = o.cursorStyle, p = o.emphasisDisabled), !o || r.hasItemOption) {
        var y = o && o.itemModel ? o.itemModel : r.getItemModel(n), C = y.getModel("emphasis");
        u = C.getModel("itemStyle").getItemStyle(), d = y.getModel(["select", "itemStyle"]).getItemStyle(), c = y.getModel(["blur", "itemStyle"]).getItemStyle(), h = C.get("focus"), f = C.get("blurScope"), p = C.get("disabled"), g = $n(y), v = C.getShallow("scale"), m = y.getShallow("cursor");
      }
      var S = r.getItemVisual(n, "symbolRotate");
      s.attr("rotation", (S || 0) * Math.PI / 180 || 0);
      var b = ud(r.getItemVisual(n, "symbolOffset"), i);
      b && (s.x = b[0], s.y = b[1]), m && s.attr("cursor", m);
      var w = r.getItemVisual(n, "style"), x = w.fill;
      if (s instanceof qn) {
        var R = s.style;
        s.useStyle(ge({
          // TODO other properties like x, y ?
          image: R.image,
          x: R.x,
          y: R.y,
          width: R.width,
          height: R.height
        }, w));
      } else
        s.__isEmptyBrush ? s.useStyle(ge({}, w)) : s.useStyle(w), s.style.decal = null, s.setColor(x, a && a.symbolInnerColor), s.style.strokeNoScale = !0;
      var _ = r.getItemVisual(n, "liftZ"), T = this._z2;
      _ != null ? T == null && (this._z2 = s.z2, s.z2 += _) : T != null && (s.z2 = T, this._z2 = null);
      var P = a && a.useNameLabel;
      ri(s, g, {
        labelFetcher: l,
        labelDataIndex: n,
        defaultText: D,
        inheritColor: x,
        defaultOpacity: w.opacity
      });
      function D(F) {
        return P ? r.getName(F) : qh(r, F);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var O = s.ensureState("emphasis");
      O.style = u, s.ensureState("select").style = d, s.ensureState("blur").style = c;
      var A = v == null || v === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(v) && v > 0 ? +v : 1;
      O.scaleX = this._sizeX * A, O.scaleY = this._sizeY * A, this.setSymbolScale(1), sn(this, h, f, p);
    }, t.prototype.setSymbolScale = function(r) {
      this.scaleX = this.scaleY = r;
    }, t.prototype.fadeOut = function(r, n, i) {
      var o = this.childAt(0), a = St(this).dataIndex, s = i && i.animation;
      if (this.silent = o.silent = !0, i && i.fadeLabel) {
        var l = o.getTextContent();
        l && au(l, {
          style: {
            opacity: 0
          }
        }, n, {
          dataIndex: a,
          removeOpt: s,
          cb: function() {
            o.removeTextContent();
          }
        });
      } else
        o.removeTextContent();
      au(o, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, n, {
        dataIndex: a,
        cb: r,
        removeOpt: s
      });
    }, t.getSymbolSize = function(r, n) {
      return _f(r.getItemVisual(n, "symbolSize"));
    }, t;
  }(Ct)
);
function S_e(e, t) {
  this.parent.drift(e, t);
}
function ix(e, t, r, n) {
  return t && !isNaN(t[0]) && !isNaN(t[1]) && !(n.isIgnore && n.isIgnore(r)) && !(n.clipShape && !n.clipShape.contain(t[0], t[1])) && e.getItemVisual(r, "symbol") !== "none";
}
function _V(e) {
  return e != null && !lt(e) && (e = {
    isIgnore: e
  }), e || {};
}
function TV(e) {
  var t = e.hostModel, r = t.getModel("emphasis");
  return {
    emphasisItemStyle: r.getModel("itemStyle").getItemStyle(),
    blurItemStyle: t.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: t.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: r.get("focus"),
    blurScope: r.get("blurScope"),
    emphasisDisabled: r.get("disabled"),
    hoverScale: r.get("scale"),
    labelStatesModels: $n(t),
    cursorStyle: t.get("cursor")
  };
}
var Uv = (
  /** @class */
  function() {
    function e(t) {
      this.group = new Ct(), this._SymbolCtor = t || jv;
    }
    return e.prototype.updateData = function(t, r) {
      this._progressiveEls = null, r = _V(r);
      var n = this.group, i = t.hostModel, o = this._data, a = this._SymbolCtor, s = r.disableAnimation, l = TV(t), u = {
        disableAnimation: s
      }, c = r.getSymbolPoint || function(d) {
        return t.getItemLayout(d);
      };
      o || n.removeAll(), t.diff(o).add(function(d) {
        var h = c(d);
        if (ix(t, h, d, r)) {
          var f = new a(t, d, l, u);
          f.setPosition(h), t.setItemGraphicEl(d, f), n.add(f);
        }
      }).update(function(d, h) {
        var f = o.getItemGraphicEl(h), p = c(d);
        if (!ix(t, p, d, r)) {
          n.remove(f);
          return;
        }
        var g = t.getItemVisual(d, "symbol") || "circle", v = f && f.getSymbolType && f.getSymbolType();
        if (!f || v && v !== g)
          n.remove(f), f = new a(t, d, l, u), f.setPosition(p);
        else {
          f.updateData(t, d, l, u);
          var m = {
            x: p[0],
            y: p[1]
          };
          s ? f.attr(m) : ur(f, m, i);
        }
        n.add(f), t.setItemGraphicEl(d, f);
      }).remove(function(d) {
        var h = o.getItemGraphicEl(d);
        h && h.fadeOut(function() {
          n.remove(h);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = t;
    }, e.prototype.updateLayout = function() {
      var t = this, r = this._data;
      r && r.eachItemGraphicEl(function(n, i) {
        var o = t._getSymbolPoint(i);
        n.setPosition(o), n.markRedraw();
      });
    }, e.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = TV(t), this._data = null, this.group.removeAll();
    }, e.prototype.incrementalUpdate = function(t, r, n) {
      this._progressiveEls = [], n = _V(n);
      function i(l) {
        l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0);
      }
      for (var o = t.start; o < t.end; o++) {
        var a = r.getItemLayout(o);
        if (ix(r, a, o, n)) {
          var s = new this._SymbolCtor(r, o, this._seriesScope);
          s.traverse(i), s.setPosition(a), this.group.add(s), r.setItemGraphicEl(o, s), this._progressiveEls.push(s);
        }
      }
    }, e.prototype.eachRendered = function(t) {
      Su(this._progressiveEls || this.group, t);
    }, e.prototype.remove = function(t) {
      var r = this.group, n = this._data;
      n && t ? n.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          r.remove(i);
        }, n.hostModel);
      }) : r.removeAll();
    }, e;
  }()
);
function Gj(e, t, r) {
  var n = e.getBaseAxis(), i = e.getOtherAxis(n), o = w_e(i, r), a = n.dim, s = i.dim, l = t.mapDimension(s), u = t.mapDimension(a), c = s === "x" || s === "radius" ? 1 : 0, d = Ee(e.dimensions, function(p) {
    return t.mapDimension(p);
  }), h = !1, f = t.getCalculationInfo("stackResultDimension");
  return tl(
    t,
    d[0]
    /* , dims[1] */
  ) && (h = !0, d[0] = f), tl(
    t,
    d[1]
    /* , dims[0] */
  ) && (h = !0, d[1] = f), {
    dataDimsForPoint: d,
    valueStart: o,
    valueAxisDim: s,
    baseAxisDim: a,
    stacked: !!h,
    valueDim: l,
    baseDim: u,
    baseDataOffset: c,
    stackedOverDimension: t.getCalculationInfo("stackedOverDimension")
  };
}
function w_e(e, t) {
  var r = 0, n = e.scale.getExtent();
  return t === "start" ? r = n[0] : t === "end" ? r = n[1] : sr(t) && !isNaN(t) ? r = t : n[0] > 0 ? r = n[0] : n[1] < 0 && (r = n[1]), r;
}
function zj(e, t, r, n) {
  var i = NaN;
  e.stacked && (i = r.get(r.getCalculationInfo("stackedOverDimension"), n)), isNaN(i) && (i = e.valueStart);
  var o = e.baseDataOffset, a = [];
  return a[o] = r.get(e.baseDim, n), a[1 - o] = i, t.dataToPoint(a);
}
function b_e(e, t) {
  var r = [];
  return t.diff(e).add(function(n) {
    r.push({
      cmd: "+",
      idx: n
    });
  }).update(function(n, i) {
    r.push({
      cmd: "=",
      idx: i,
      idx1: n
    });
  }).remove(function(n) {
    r.push({
      cmd: "-",
      idx: n
    });
  }).execute(), r;
}
function x_e(e, t, r, n, i, o, a, s) {
  for (var l = b_e(e, t), u = [], c = [], d = [], h = [], f = [], p = [], g = [], v = Gj(i, t, a), m = e.getLayout("points") || [], y = t.getLayout("points") || [], C = 0; C < l.length; C++) {
    var S = l[C], b = !0, w = void 0, x = void 0;
    switch (S.cmd) {
      case "=":
        w = S.idx * 2, x = S.idx1 * 2;
        var R = m[w], _ = m[w + 1], T = y[x], P = y[x + 1];
        (isNaN(R) || isNaN(_)) && (R = T, _ = P), u.push(R, _), c.push(T, P), d.push(r[w], r[w + 1]), h.push(n[x], n[x + 1]), g.push(t.getRawIndex(S.idx1));
        break;
      case "+":
        var D = S.idx, O = v.dataDimsForPoint, A = i.dataToPoint([t.get(O[0], D), t.get(O[1], D)]);
        x = D * 2, u.push(A[0], A[1]), c.push(y[x], y[x + 1]);
        var F = zj(v, i, t, D);
        d.push(F[0], F[1]), h.push(n[x], n[x + 1]), g.push(t.getRawIndex(D));
        break;
      case "-":
        b = !1;
    }
    b && (f.push(S), p.push(p.length));
  }
  p.sort(function(j, q) {
    return g[j] - g[q];
  });
  for (var L = u.length, N = is(L), I = is(L), B = is(L), M = is(L), V = [], C = 0; C < p.length; C++) {
    var G = p[C], k = C * 2, z = G * 2;
    N[k] = u[z], N[k + 1] = u[z + 1], I[k] = c[z], I[k + 1] = c[z + 1], B[k] = d[z], B[k + 1] = d[z + 1], M[k] = h[z], M[k + 1] = h[z + 1], V[C] = f[G];
  }
  return {
    current: N,
    next: I,
    stackedOnCurrent: B,
    stackedOnNext: M,
    status: V
  };
}
var wl = Math.min, bl = Math.max;
function Ac(e, t) {
  return isNaN(e) || isNaN(t);
}
function hT(e, t, r, n, i, o, a, s, l) {
  for (var u, c, d, h, f, p, g = r, v = 0; v < n; v++) {
    var m = t[g * 2], y = t[g * 2 + 1];
    if (g >= i || g < 0)
      break;
    if (Ac(m, y)) {
      if (l) {
        g += o;
        continue;
      }
      break;
    }
    if (g === r)
      e[o > 0 ? "moveTo" : "lineTo"](m, y), d = m, h = y;
    else {
      var C = m - u, S = y - c;
      if (C * C + S * S < 0.5) {
        g += o;
        continue;
      }
      if (a > 0) {
        for (var b = g + o, w = t[b * 2], x = t[b * 2 + 1]; w === m && x === y && v < n; )
          v++, b += o, g += o, w = t[b * 2], x = t[b * 2 + 1], m = t[g * 2], y = t[g * 2 + 1], C = m - u, S = y - c;
        var R = v + 1;
        if (l)
          for (; Ac(w, x) && R < n; )
            R++, b += o, w = t[b * 2], x = t[b * 2 + 1];
        var _ = 0.5, T = 0, P = 0, D = void 0, O = void 0;
        if (R >= n || Ac(w, x))
          f = m, p = y;
        else {
          T = w - u, P = x - c;
          var A = m - u, F = w - m, L = y - c, N = x - y, I = void 0, B = void 0;
          if (s === "x") {
            I = Math.abs(A), B = Math.abs(F);
            var M = T > 0 ? 1 : -1;
            f = m - M * I * a, p = y, D = m + M * B * a, O = y;
          } else if (s === "y") {
            I = Math.abs(L), B = Math.abs(N);
            var V = P > 0 ? 1 : -1;
            f = m, p = y - V * I * a, D = m, O = y + V * B * a;
          } else
            I = Math.sqrt(A * A + L * L), B = Math.sqrt(F * F + N * N), _ = B / (B + I), f = m - T * a * (1 - _), p = y - P * a * (1 - _), D = m + T * a * _, O = y + P * a * _, D = wl(D, bl(w, m)), O = wl(O, bl(x, y)), D = bl(D, wl(w, m)), O = bl(O, wl(x, y)), T = D - m, P = O - y, f = m - T * I / B, p = y - P * I / B, f = wl(f, bl(u, m)), p = wl(p, bl(c, y)), f = bl(f, wl(u, m)), p = bl(p, wl(c, y)), T = m - f, P = y - p, D = m + T * B / I, O = y + P * B / I;
        }
        e.bezierCurveTo(d, h, f, p, m, y), d = D, h = O;
      } else
        e.lineTo(m, y);
    }
    u = m, c = y, g += o;
  }
  return v;
}
var Wj = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return e;
  }()
), E_e = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "ec-polyline", n;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new Wj();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points, o = 0, a = i.length / 2;
      if (n.connectNulls) {
        for (; a > 0 && Ac(i[a * 2 - 2], i[a * 2 - 1]); a--)
          ;
        for (; o < a && Ac(i[o * 2], i[o * 2 + 1]); o++)
          ;
      }
      for (; o < a; )
        o += hT(r, i, o, a, a, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1;
    }, t.prototype.getPointOn = function(r, n) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, o = i.data, a = ms.CMD, s, l, u = n === "x", c = [], d = 0; d < o.length; ) {
        var h = o[d++], f = void 0, p = void 0, g = void 0, v = void 0, m = void 0, y = void 0, C = void 0;
        switch (h) {
          case a.M:
            s = o[d++], l = o[d++];
            break;
          case a.L:
            if (f = o[d++], p = o[d++], C = u ? (r - s) / (f - s) : (r - l) / (p - l), C <= 1 && C >= 0) {
              var S = u ? (p - l) * C + l : (f - s) * C + s;
              return u ? [r, S] : [S, r];
            }
            s = f, l = p;
            break;
          case a.C:
            f = o[d++], p = o[d++], g = o[d++], v = o[d++], m = o[d++], y = o[d++];
            var b = u ? eC(s, f, g, m, r, c) : eC(l, p, v, y, r, c);
            if (b > 0)
              for (var w = 0; w < b; w++) {
                var x = c[w];
                if (x <= 1 && x >= 0) {
                  var S = u ? Fn(l, p, v, y, x) : Fn(s, f, g, m, x);
                  return u ? [r, S] : [S, r];
                }
              }
            s = m, l = y;
            break;
        }
      }
    }, t;
  }(Ht)
), R_e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  }(Wj)
), jj = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "ec-polygon", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new R_e();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points, o = n.stackedOnPoints, a = 0, s = i.length / 2, l = n.smoothMonotone;
      if (n.connectNulls) {
        for (; s > 0 && Ac(i[s * 2 - 2], i[s * 2 - 1]); s--)
          ;
        for (; a < s && Ac(i[a * 2], i[a * 2 + 1]); a++)
          ;
      }
      for (; a < s; ) {
        var u = hT(r, i, a, s, s, 1, n.smooth, l, n.connectNulls);
        hT(r, o, a + u - 1, u, s, -1, n.stackedOnSmooth, l, n.connectNulls), a += u + 1, r.closePath();
      }
    }, t;
  }(Ht)
);
function Uj(e, t, r, n, i) {
  var o = e.getArea(), a = o.x, s = o.y, l = o.width, u = o.height, c = r.get(["lineStyle", "width"]) || 2;
  a -= c / 2, s -= c / 2, l += c, u += c, l = Math.ceil(l), a !== Math.floor(a) && (a = Math.floor(a), l++);
  var d = new or({
    shape: {
      x: a,
      y: s,
      width: l,
      height: u
    }
  });
  if (t) {
    var h = e.getBaseAxis(), f = h.isHorizontal(), p = h.inverse;
    f ? (p && (d.shape.x += l), d.shape.width = 0) : (p || (d.shape.y += u), d.shape.height = 0);
    var g = at(i) ? function(v) {
      i(v, d);
    } : null;
    jr(d, {
      shape: {
        width: l,
        height: u,
        x: a,
        y: s
      }
    }, r, null, n, g);
  }
  return d;
}
function Kj(e, t, r) {
  var n = e.getArea(), i = an(n.r0, 1), o = an(n.r, 1), a = new Oi({
    shape: {
      cx: an(e.cx, 1),
      cy: an(e.cy, 1),
      r0: i,
      r: o,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    }
  });
  if (t) {
    var s = e.getBaseAxis().dim === "angle";
    s ? a.shape.endAngle = n.startAngle : a.shape.r = i, jr(a, {
      shape: {
        endAngle: n.endAngle,
        r: o
      }
    }, r);
  }
  return a;
}
function Kv(e, t, r, n, i) {
  if (e) {
    if (e.type === "polar")
      return Kj(e, t, r);
    if (e.type === "cartesian2d")
      return Uj(e, t, r, n, i);
  } else return null;
  return null;
}
function cd(e, t) {
  return e.type === t;
}
function PV(e, t) {
  if (e.length === t.length) {
    for (var r = 0; r < e.length; r++)
      if (e[r] !== t[r])
        return;
    return !0;
  }
}
function MV(e) {
  for (var t = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, o = 0; o < e.length; ) {
    var a = e[o++], s = e[o++];
    isNaN(a) || (t = Math.min(a, t), n = Math.max(a, n)), isNaN(s) || (r = Math.min(s, r), i = Math.max(s, i));
  }
  return [[t, r], [n, i]];
}
function DV(e, t) {
  var r = MV(e), n = r[0], i = r[1], o = MV(t), a = o[0], s = o[1];
  return Math.max(Math.abs(n[0] - a[0]), Math.abs(n[1] - a[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]));
}
function AV(e) {
  return sr(e) ? e : e ? 0.5 : 0;
}
function __e(e, t, r) {
  if (!r.valueDim)
    return [];
  for (var n = t.count(), i = is(n * 2), o = 0; o < n; o++) {
    var a = zj(r, e, t, o);
    i[o * 2] = a[0], i[o * 2 + 1] = a[1];
  }
  return i;
}
function xl(e, t, r, n) {
  var i = t.getBaseAxis(), o = i.dim === "x" || i.dim === "radius" ? 0 : 1, a = [], s = 0, l = [], u = [], c = [], d = [];
  if (n) {
    for (s = 0; s < e.length; s += 2)
      !isNaN(e[s]) && !isNaN(e[s + 1]) && d.push(e[s], e[s + 1]);
    e = d;
  }
  for (s = 0; s < e.length - 2; s += 2)
    switch (c[0] = e[s + 2], c[1] = e[s + 3], u[0] = e[s], u[1] = e[s + 1], a.push(u[0], u[1]), r) {
      case "end":
        l[o] = c[o], l[1 - o] = u[1 - o], a.push(l[0], l[1]);
        break;
      case "middle":
        var h = (u[o] + c[o]) / 2, f = [];
        l[o] = f[o] = h, l[1 - o] = u[1 - o], f[1 - o] = c[1 - o], a.push(l[0], l[1]), a.push(f[0], f[1]);
        break;
      default:
        l[o] = u[o], l[1 - o] = c[1 - o], a.push(l[0], l[1]);
    }
  return a.push(e[s++], e[s++]), a;
}
function T_e(e, t) {
  var r = [], n = e.length, i, o;
  function a(c, d, h) {
    var f = c.coord, p = (h - f) / (d.coord - f), g = GM(p, [c.color, d.color]);
    return {
      coord: h,
      color: g
    };
  }
  for (var s = 0; s < n; s++) {
    var l = e[s], u = l.coord;
    if (u < 0)
      i = l;
    else if (u > t) {
      o ? r.push(a(o, l, t)) : i && r.push(a(i, l, 0), a(i, l, t));
      break;
    } else
      i && (r.push(a(i, l, 0)), i = null), r.push(l), o = l;
  }
  return r;
}
function P_e(e, t, r) {
  var n = e.getVisual("visualMeta");
  if (!(!n || !n.length || !e.count())) {
    if (t.type !== "cartesian2d") {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
      return;
    }
    for (var i, o, a = n.length - 1; a >= 0; a--) {
      var s = e.getDimensionInfo(n[a].dimension);
      if (i = s && s.coordDim, i === "x" || i === "y") {
        o = n[a];
        break;
      }
    }
    if (!o) {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
      return;
    }
    var l = t.getAxis(i), u = Ee(o.stops, function(C) {
      return {
        coord: l.toGlobalCoord(l.dataToCoord(C.value)),
        color: C.color
      };
    }), c = u.length, d = o.outerColors.slice();
    c && u[0].coord > u[c - 1].coord && (u.reverse(), d.reverse());
    var h = T_e(u, i === "x" ? r.getWidth() : r.getHeight()), f = h.length;
    if (!f && c)
      return u[0].coord < 0 ? d[1] ? d[1] : u[c - 1].color : d[0] ? d[0] : u[0].color;
    var p = 10, g = h[0].coord - p, v = h[f - 1].coord + p, m = v - g;
    if (m < 1e-3)
      return "transparent";
    $(h, function(C) {
      C.offset = (C.coord - g) / m;
    }), h.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: f ? h[f - 1].offset : 0.5,
      color: d[1] || "transparent"
    }), h.unshift({
      offset: f ? h[0].offset : 0.5,
      color: d[0] || "transparent"
    });
    var y = new vf(0, 0, 0, 0, h, !0);
    return y[i] = g, y[i + "2"] = v, y;
  }
}
function M_e(e, t, r) {
  var n = e.get("showAllSymbol"), i = n === "auto";
  if (!(n && !i)) {
    var o = r.getAxesByScale("ordinal")[0];
    if (o && !(i && D_e(o, t))) {
      var a = t.mapDimension(o.dim), s = {};
      return $(o.getViewLabels(), function(l) {
        var u = o.scale.getRawOrdinalNumber(l.tickValue);
        s[u] = 1;
      }), function(l) {
        return !s.hasOwnProperty(t.get(a, l));
      };
    }
  }
}
function D_e(e, t) {
  var r = e.getExtent(), n = Math.abs(r[1] - r[0]) / e.scale.count();
  isNaN(n) && (n = 0);
  for (var i = t.count(), o = Math.max(1, Math.round(i / 5)), a = 0; a < i; a += o)
    if (jv.getSymbolSize(
      t,
      a
      // Only for cartesian, where `isHorizontal` exists.
    )[e.isHorizontal() ? 1 : 0] * 1.5 > n)
      return !1;
  return !0;
}
function A_e(e, t) {
  return isNaN(e) || isNaN(t);
}
function I_e(e) {
  for (var t = e.length / 2; t > 0 && A_e(e[t * 2 - 2], e[t * 2 - 1]); t--)
    ;
  return t - 1;
}
function IV(e, t) {
  return [e[t * 2], e[t * 2 + 1]];
}
function O_e(e, t, r) {
  for (var n = e.length / 2, i = r === "x" ? 0 : 1, o, a, s = 0, l = -1, u = 0; u < n; u++)
    if (a = e[u * 2 + i], !(isNaN(a) || isNaN(e[u * 2 + 1 - i]))) {
      if (u === 0) {
        o = a;
        continue;
      }
      if (o <= t && a >= t || o >= t && a <= t) {
        l = u;
        break;
      }
      s = u, o = a;
    }
  return {
    range: [s, l],
    t: (t - o) / (a - o)
  };
}
function Yj(e) {
  if (e.get(["endLabel", "show"]))
    return !0;
  for (var t = 0; t < Ii.length; t++)
    if (e.get([Ii[t], "endLabel", "show"]))
      return !0;
  return !1;
}
function ox(e, t, r, n) {
  if (cd(t, "cartesian2d")) {
    var i = n.getModel("endLabel"), o = i.get("valueAnimation"), a = n.getData(), s = {
      lastFrameIndex: 0
    }, l = Yj(n) ? function(f, p) {
      e._endLabelOnDuring(f, p, a, s, o, i, t);
    } : null, u = t.getBaseAxis().isHorizontal(), c = Uj(t, r, n, function() {
      var f = e._endLabel;
      f && r && s.originalX != null && f.attr({
        x: s.originalX,
        y: s.originalY
      });
    }, l);
    if (!n.get("clip", !0)) {
      var d = c.shape, h = Math.max(d.width, d.height);
      u ? (d.y -= h, d.height += h * 2) : (d.x -= h, d.width += h * 2);
    }
    return l && l(1, c), c;
  } else
    return process.env.NODE_ENV !== "production" && n.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), Kj(t, r, n);
}
function L_e(e, t) {
  var r = t.getBaseAxis(), n = r.isHorizontal(), i = r.inverse, o = n ? i ? "right" : "left" : "center", a = n ? "middle" : i ? "top" : "bottom";
  return {
    normal: {
      align: e.get("align") || o,
      verticalAlign: e.get("verticalAlign") || a
    }
  };
}
var F_e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function() {
      var r = new Ct(), n = new Uv();
      this.group.add(n.group), this._symbolDraw = n, this._lineGroup = r;
    }, t.prototype.render = function(r, n, i) {
      var o = this, a = r.coordinateSystem, s = this.group, l = r.getData(), u = r.getModel("lineStyle"), c = r.getModel("areaStyle"), d = l.getLayout("points") || [], h = a.type === "polar", f = this._coordSys, p = this._symbolDraw, g = this._polyline, v = this._polygon, m = this._lineGroup, y = !n.ssr && r.get("animation"), C = !c.isEmpty(), S = c.get("origin"), b = Gj(a, l, S), w = C && __e(a, l, b), x = r.get("showSymbol"), R = r.get("connectNulls"), _ = x && !h && M_e(r, l, a), T = this._data;
      T && T.eachItemGraphicEl(function(q, K) {
        q.__temp && (s.remove(q), T.setItemGraphicEl(K, null));
      }), x || p.remove(), s.add(m);
      var P = h ? !1 : r.get("step"), D;
      a && a.getArea && r.get("clip", !0) && (D = a.getArea(), D.width != null ? (D.x -= 0.1, D.y -= 0.1, D.width += 0.2, D.height += 0.2) : D.r0 && (D.r0 -= 0.5, D.r += 0.5)), this._clipShapeForSymbol = D;
      var O = P_e(l, a, i) || l.getVisual("style")[l.getVisual("drawType")];
      if (!(g && f.type === a.type && P === this._step))
        x && p.updateData(l, {
          isIgnore: _,
          clipShape: D,
          disableAnimation: !0,
          getSymbolPoint: function(q) {
            return [d[q * 2], d[q * 2 + 1]];
          }
        }), y && this._initSymbolLabelAnimation(l, a, D), P && (d = xl(d, a, P, R), w && (w = xl(w, a, P, R))), g = this._newPolyline(d), C ? v = this._newPolygon(d, w) : v && (m.remove(v), v = this._polygon = null), h || this._initOrUpdateEndLabel(r, a, Uc(O)), m.setClipPath(ox(this, a, !0, r));
      else {
        C && !v ? v = this._newPolygon(d, w) : v && !C && (m.remove(v), v = this._polygon = null), h || this._initOrUpdateEndLabel(r, a, Uc(O));
        var A = m.getClipPath();
        if (A) {
          var F = ox(this, a, !1, r);
          jr(A, {
            shape: F.shape
          }, r);
        } else
          m.setClipPath(ox(this, a, !0, r));
        x && p.updateData(l, {
          isIgnore: _,
          clipShape: D,
          disableAnimation: !0,
          getSymbolPoint: function(q) {
            return [d[q * 2], d[q * 2 + 1]];
          }
        }), (!PV(this._stackedOnPoints, w) || !PV(this._points, d)) && (y ? this._doUpdateAnimation(l, w, a, i, P, S, R) : (P && (d = xl(d, a, P, R), w && (w = xl(w, a, P, R))), g.setShape({
          points: d
        }), v && v.setShape({
          points: d,
          stackedOnPoints: w
        })));
      }
      var L = r.getModel("emphasis"), N = L.get("focus"), I = L.get("blurScope"), B = L.get("disabled");
      if (g.useStyle(ut(
        // Use color in lineStyle first
        u.getLineStyle(),
        {
          fill: "none",
          stroke: O,
          lineJoin: "bevel"
        }
      )), ti(g, r, "lineStyle"), g.style.lineWidth > 0 && r.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var M = g.getState("emphasis").style;
        M.lineWidth = +g.style.lineWidth + 1;
      }
      St(g).seriesIndex = r.seriesIndex, sn(g, N, I, B);
      var V = AV(r.get("smooth")), G = r.get("smoothMonotone");
      if (g.setShape({
        smooth: V,
        smoothMonotone: G,
        connectNulls: R
      }), v) {
        var k = l.getCalculationInfo("stackedOnSeries"), z = 0;
        v.useStyle(ut(c.getAreaStyle(), {
          fill: O,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: l.getVisual("style").decal
        })), k && (z = AV(k.get("smooth"))), v.setShape({
          smooth: V,
          stackedOnSmooth: z,
          smoothMonotone: G,
          connectNulls: R
        }), ti(v, r, "areaStyle"), St(v).seriesIndex = r.seriesIndex, sn(v, N, I, B);
      }
      var j = function(q) {
        o._changePolyState(q);
      };
      l.eachItemGraphicEl(function(q) {
        q && (q.onHoverStateChange = j);
      }), this._polyline.onHoverStateChange = j, this._data = l, this._coordSys = a, this._stackedOnPoints = w, this._points = d, this._step = P, this._valueOrigin = S, r.get("triggerLineEvent") && (this.packEventData(r, g), v && this.packEventData(r, v));
    }, t.prototype.packEventData = function(r, n) {
      St(n).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: r.componentIndex,
        seriesIndex: r.seriesIndex,
        seriesName: r.name,
        seriesType: "line"
      };
    }, t.prototype.highlight = function(r, n, i, o) {
      var a = r.getData(), s = zc(a, o);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = a.getLayout("points"), u = a.getItemGraphicEl(s);
        if (!u) {
          var c = l[s * 2], d = l[s * 2 + 1];
          if (isNaN(c) || isNaN(d) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, d))
            return;
          var h = r.get("zlevel") || 0, f = r.get("z") || 0;
          u = new jv(a, s), u.x = c, u.y = d, u.setZ(h, f);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = h, p.z = f, p.z2 = this._polyline.z2 + 1), u.__temp = !0, a.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u);
        }
        u.highlight();
      } else
        br.prototype.highlight.call(this, r, n, i, o);
    }, t.prototype.downplay = function(r, n, i, o) {
      var a = r.getData(), s = zc(a, o);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = a.getItemGraphicEl(s);
        l && (l.__temp ? (a.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else
        br.prototype.downplay.call(this, r, n, i, o);
    }, t.prototype._changePolyState = function(r) {
      var n = this._polygon;
      lC(this._polyline, r), n && lC(n, r);
    }, t.prototype._newPolyline = function(r) {
      var n = this._polyline;
      return n && this._lineGroup.remove(n), n = new E_e({
        shape: {
          points: r
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(n), this._polyline = n, n;
    }, t.prototype._newPolygon = function(r, n) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new jj({
        shape: {
          points: r,
          stackedOnPoints: n
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, t.prototype._initSymbolLabelAnimation = function(r, n, i) {
      var o, a, s = n.getBaseAxis(), l = s.inverse;
      n.type === "cartesian2d" ? (o = s.isHorizontal(), a = !1) : n.type === "polar" && (o = s.dim === "angle", a = !0);
      var u = r.hostModel, c = u.get("animationDuration");
      at(c) && (c = c(null));
      var d = u.get("animationDelay") || 0, h = at(d) ? d(null) : d;
      r.eachItemGraphicEl(function(f, p) {
        var g = f;
        if (g) {
          var v = [f.x, f.y], m = void 0, y = void 0, C = void 0;
          if (i)
            if (a) {
              var S = i, b = n.pointToCoord(v);
              o ? (m = S.startAngle, y = S.endAngle, C = -b[1] / 180 * Math.PI) : (m = S.r0, y = S.r, C = b[0]);
            } else {
              var w = i;
              o ? (m = w.x, y = w.x + w.width, C = f.x) : (m = w.y + w.height, y = w.y, C = f.y);
            }
          var x = y === m ? 0 : (C - m) / (y - m);
          l && (x = 1 - x);
          var R = at(d) ? d(p) : c * x + h, _ = g.getSymbolPath(), T = _.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: R
          }), T && T.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: R
          }), _.disableLabelAnimation = !0;
        }
      });
    }, t.prototype._initOrUpdateEndLabel = function(r, n, i) {
      var o = r.getModel("endLabel");
      if (Yj(r)) {
        var a = r.getData(), s = this._polyline, l = a.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new ir({
          z2: 200
          // should be higher than item symbol
        }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
        var c = I_e(l);
        c >= 0 && (ri(s, $n(r, "endLabel"), {
          inheritColor: i,
          labelFetcher: r,
          labelDataIndex: c,
          defaultText: function(d, h, f) {
            return f != null ? Hj(a, f) : qh(a, d);
          },
          enableTextSetter: !0
        }, L_e(o, n)), s.textConfig.position = null);
      } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, t.prototype._endLabelOnDuring = function(r, n, i, o, a, s, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        r < 1 && o.originalX == null && (o.originalX = u.x, o.originalY = u.y);
        var d = i.getLayout("points"), h = i.hostModel, f = h.get("connectNulls"), p = s.get("precision"), g = s.get("distance") || 0, v = l.getBaseAxis(), m = v.isHorizontal(), y = v.inverse, C = n.shape, S = y ? m ? C.x : C.y + C.height : m ? C.x + C.width : C.y, b = (m ? g : 0) * (y ? -1 : 1), w = (m ? 0 : -g) * (y ? -1 : 1), x = m ? "x" : "y", R = O_e(d, S, x), _ = R.range, T = _[1] - _[0], P = void 0;
        if (T >= 1) {
          if (T > 1 && !f) {
            var D = IV(d, _[0]);
            u.attr({
              x: D[0] + b,
              y: D[1] + w
            }), a && (P = h.getRawValue(_[0]));
          } else {
            var D = c.getPointOn(S, x);
            D && u.attr({
              x: D[0] + b,
              y: D[1] + w
            });
            var O = h.getRawValue(_[0]), A = h.getRawValue(_[1]);
            a && (P = bW(i, p, O, A, R.t));
          }
          o.lastFrameIndex = _[0];
        } else {
          var F = r === 1 || o.lastFrameIndex > 0 ? _[0] : 0, D = IV(d, F);
          a && (P = h.getRawValue(F)), u.attr({
            x: D[0] + b,
            y: D[1] + w
          });
        }
        if (a) {
          var L = Sf(u);
          typeof L.setLabelText == "function" && L.setLabelText(P);
        }
      }
    }, t.prototype._doUpdateAnimation = function(r, n, i, o, a, s, l) {
      var u = this._polyline, c = this._polygon, d = r.hostModel, h = x_e(this._data, r, this._stackedOnPoints, n, this._coordSys, i, this._valueOrigin), f = h.current, p = h.stackedOnCurrent, g = h.next, v = h.stackedOnNext;
      if (a && (f = xl(h.current, i, a, l), p = xl(h.stackedOnCurrent, i, a, l), g = xl(h.next, i, a, l), v = xl(h.stackedOnNext, i, a, l)), DV(f, g) > 3e3 || c && DV(p, v) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), c && (c.stopAnimation(), c.setShape({
          points: g,
          stackedOnPoints: v
        }));
        return;
      }
      u.shape.__points = h.current, u.shape.points = f;
      var m = {
        shape: {
          points: g
        }
      };
      h.current !== f && (m.shape.__points = h.next), u.stopAnimation(), ur(u, m, d), c && (c.setShape({
        // Reuse the points with polyline.
        points: f,
        stackedOnPoints: p
      }), c.stopAnimation(), ur(c, {
        shape: {
          stackedOnPoints: v
        }
      }, d), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], C = h.status, S = 0; S < C.length; S++) {
        var b = C[S].cmd;
        if (b === "=") {
          var w = r.getItemGraphicEl(C[S].idx1);
          w && y.push({
            el: w,
            ptIdx: S
            // Index of points
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var x = u.shape.__points, R = 0; R < y.length; R++) {
          var _ = y[R].el, T = y[R].ptIdx * 2;
          _.x = x[T], _.y = x[T + 1], _.markRedraw();
        }
      });
    }, t.prototype.remove = function(r) {
      var n = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function(o, a) {
        o.__temp && (n.remove(o), i.setItemGraphicEl(a, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, t.type = "line", t;
  }(br)
);
function Yv(e, t) {
  return {
    seriesType: e,
    plan: Ef(),
    reset: function(r) {
      var n = r.getData(), i = r.coordinateSystem, o = r.pipelineContext, a = t || o.large;
      if (i) {
        var s = Ee(i.dimensions, function(f) {
          return n.mapDimension(f);
        }).slice(0, 2), l = s.length, u = n.getCalculationInfo("stackResultDimension");
        tl(n, s[0]) && (s[0] = u), tl(n, s[1]) && (s[1] = u);
        var c = n.getStore(), d = n.getDimensionIndex(s[0]), h = n.getDimensionIndex(s[1]);
        return l && {
          progress: function(f, p) {
            for (var g = f.end - f.start, v = a && is(g * l), m = [], y = [], C = f.start, S = 0; C < f.end; C++) {
              var b = void 0;
              if (l === 1) {
                var w = c.get(d, C);
                b = i.dataToPoint(w, null, y);
              } else
                m[0] = c.get(d, C), m[1] = c.get(h, C), b = i.dataToPoint(m, null, y);
              a ? (v[S++] = b[0], v[S++] = b[1]) : p.setItemLayout(C, b.slice());
            }
            a && p.setLayout("points", v);
          }
        };
      }
    }
  };
}
var N_e = {
  average: function(e) {
    for (var t = 0, r = 0, n = 0; n < e.length; n++)
      isNaN(e[n]) || (t += e[n], r++);
    return r === 0 ? NaN : t / r;
  },
  sum: function(e) {
    for (var t = 0, r = 0; r < e.length; r++)
      t += e[r] || 0;
    return t;
  },
  max: function(e) {
    for (var t = -1 / 0, r = 0; r < e.length; r++)
      e[r] > t && (t = e[r]);
    return isFinite(t) ? t : NaN;
  },
  min: function(e) {
    for (var t = 1 / 0, r = 0; r < e.length; r++)
      e[r] < t && (t = e[r]);
    return isFinite(t) ? t : NaN;
  },
  minmax: function(e) {
    for (var t = -1 / 0, r = -1 / 0, n = 0; n < e.length; n++) {
      var i = e[n], o = Math.abs(i);
      o > t && (t = o, r = i);
    }
    return isFinite(r) ? r : NaN;
  },
  // TODO
  // Median
  nearest: function(e) {
    return e[0];
  }
}, k_e = function(e) {
  return Math.round(e.length / 2);
};
function qj(e) {
  return {
    seriesType: e,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(t, r, n) {
      var i = t.getData(), o = t.get("sampling"), a = t.coordinateSystem, s = i.count();
      if (s > 10 && a.type === "cartesian2d" && o) {
        var l = a.getBaseAxis(), u = a.getOtherAxis(l), c = l.getExtent(), d = n.getDevicePixelRatio(), h = Math.abs(c[1] - c[0]) * (d || 1), f = Math.round(s / h);
        if (isFinite(f) && f > 1) {
          o === "lttb" && t.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / f));
          var p = void 0;
          He(o) ? p = N_e[o] : at(o) && (p = o), p && t.setData(i.downSample(i.mapDimension(u.dim), 1 / f, p, k_e));
        }
      }
    }
  };
}
function V_e(e) {
  e.registerChartView(F_e), e.registerSeriesModel(C_e), e.registerLayout(Yv("line", !0)), e.registerVisual({
    seriesType: "line",
    reset: function(t) {
      var r = t.getData(), n = t.getModel("lineStyle").getLineStyle();
      n && !n.stroke && (n.stroke = r.getVisual("style").fill), r.setVisual("legendLineStyle", n);
    }
  }), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, qj("line"));
}
var rv = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return ws(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getMarkerPosition = function(r, n, i) {
      var o = this.coordinateSystem;
      if (o && o.clampData) {
        var a = o.clampData(r), s = o.dataToPoint(a);
        if (i)
          $(o.getAxes(), function(h, f) {
            if (h.type === "category" && n != null) {
              var p = h.getTicksCoords(), g = h.getTickModel().get("alignWithLabel"), v = a[f], m = n[f] === "x1" || n[f] === "y1";
              if (m && !g && (v += 1), p.length < 2)
                return;
              if (p.length === 2) {
                s[f] = h.toGlobalCoord(h.getExtent()[m ? 1 : 0]);
                return;
              }
              for (var y = void 0, C = void 0, S = 1, b = 0; b < p.length; b++) {
                var w = p[b].coord, x = b === p.length - 1 ? p[b - 1].tickValue + S : p[b].tickValue;
                if (x === v) {
                  C = w;
                  break;
                } else if (x < v)
                  y = w;
                else if (y != null && x > v) {
                  C = (w + y) / 2;
                  break;
                }
                b === 1 && (S = x - p[0].tickValue);
              }
              C == null && (y ? y && (C = p[p.length - 1].coord) : C = p[0].coord), s[f] = h.toGlobalCoord(C);
            }
          });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), d = o.getBaseAxis().isHorizontal() ? 0 : 1;
          s[d] += u + c / 2;
        }
        return s;
      }
      return [NaN, NaN];
    }, t.type = "series.__base_bar__", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, t;
  }(Pr)
);
Pr.registerClass(rv);
var B_e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getInitialData = function() {
      return ws(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, t.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, t.prototype.getProgressiveThreshold = function() {
      var r = this.get("progressiveThreshold"), n = this.get("largeThreshold");
      return n > r && (r = n), r;
    }, t.prototype.brushSelector = function(r, n, i) {
      return i.rect(n.getItemLayout(r));
    }, t.type = "series.bar", t.dependencies = ["grid", "polar"], t.defaultOption = wu(rv.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: !1
    }), t;
  }(rv)
), $_e = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return e;
  }()
), AC = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "sausage", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new $_e();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.cx, o = n.cy, a = Math.max(n.r0 || 0, 0), s = Math.max(n.r, 0), l = (s - a) * 0.5, u = a + l, c = n.startAngle, d = n.endAngle, h = n.clockwise, f = Math.PI * 2, p = h ? d - c < f : c - d < f;
      p || (c = d - (h ? f : -f));
      var g = Math.cos(c), v = Math.sin(c), m = Math.cos(d), y = Math.sin(d);
      p ? (r.moveTo(g * a + i, v * a + o), r.arc(g * u + i, v * u + o, l, -Math.PI + c, c, !h)) : r.moveTo(g * s + i, v * s + o), r.arc(i, o, s, c, d, !h), r.arc(m * u + i, y * u + o, l, d - Math.PI * 2, d - Math.PI, !h), a !== 0 && r.arc(i, o, a, d, c, h);
    }, t;
  }(Ht)
);
function H_e(e, t) {
  t = t || {};
  var r = t.isRoundCap;
  return function(n, i, o) {
    var a = i.position;
    if (!a || a instanceof Array)
      return oC(n, i, o);
    var s = e(a), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, d = u.cy, h = u.r, f = u.r0, p = (h + f) / 2, g = u.startAngle, v = u.endAngle, m = (g + v) / 2, y = r ? Math.abs(h - f) / 2 : 0, C = Math.cos, S = Math.sin, b = c + h * C(g), w = d + h * S(g), x = "left", R = "top";
    switch (s) {
      case "startArc":
        b = c + (f - l) * C(m), w = d + (f - l) * S(m), x = "center", R = "top";
        break;
      case "insideStartArc":
        b = c + (f + l) * C(m), w = d + (f + l) * S(m), x = "center", R = "bottom";
        break;
      case "startAngle":
        b = c + p * C(g) + hy(g, l + y, !1), w = d + p * S(g) + fy(g, l + y, !1), x = "right", R = "middle";
        break;
      case "insideStartAngle":
        b = c + p * C(g) + hy(g, -l + y, !1), w = d + p * S(g) + fy(g, -l + y, !1), x = "left", R = "middle";
        break;
      case "middle":
        b = c + p * C(m), w = d + p * S(m), x = "center", R = "middle";
        break;
      case "endArc":
        b = c + (h + l) * C(m), w = d + (h + l) * S(m), x = "center", R = "bottom";
        break;
      case "insideEndArc":
        b = c + (h - l) * C(m), w = d + (h - l) * S(m), x = "center", R = "top";
        break;
      case "endAngle":
        b = c + p * C(v) + hy(v, l + y, !0), w = d + p * S(v) + fy(v, l + y, !0), x = "left", R = "middle";
        break;
      case "insideEndAngle":
        b = c + p * C(v) + hy(v, -l + y, !0), w = d + p * S(v) + fy(v, -l + y, !0), x = "right", R = "middle";
        break;
      default:
        return oC(n, i, o);
    }
    return n = n || {}, n.x = b, n.y = w, n.align = x, n.verticalAlign = R, n;
  };
}
function G_e(e, t, r, n) {
  if (sr(n)) {
    e.setTextConfig({
      rotation: n
    });
    return;
  } else if (be(t)) {
    e.setTextConfig({
      rotation: 0
    });
    return;
  }
  var i = e.shape, o = i.clockwise ? i.startAngle : i.endAngle, a = i.clockwise ? i.endAngle : i.startAngle, s = (o + a) / 2, l, u = r(t);
  switch (u) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      l = s;
      break;
    case "startAngle":
    case "insideStartAngle":
      l = o;
      break;
    case "endAngle":
    case "insideEndAngle":
      l = a;
      break;
    default:
      e.setTextConfig({
        rotation: 0
      });
      return;
  }
  var c = Math.PI * 1.5 - l;
  u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), e.setTextConfig({
    rotation: c
  });
}
function hy(e, t, r) {
  return t * Math.sin(e) * (r ? -1 : 1);
}
function fy(e, t, r) {
  return t * Math.cos(e) * (r ? 1 : -1);
}
function bc(e, t, r) {
  var n = e.get("borderRadius");
  if (n == null)
    return r ? {
      cornerRadius: 0
    } : null;
  be(n) || (n = [n, n, n, n]);
  var i = Math.abs(t.r || 0 - t.r0 || 0);
  return {
    cornerRadius: Ee(n, function(o) {
      return La(o, i);
    })
  };
}
var ax = Math.max, sx = Math.min;
function z_e(e, t) {
  var r = e.getArea && e.getArea();
  if (cd(e, "cartesian2d")) {
    var n = e.getBaseAxis();
    if (n.type !== "category" || !n.onBand) {
      var i = t.getLayout("bandWidth");
      n.isHorizontal() ? (r.x -= i, r.width += i * 2) : (r.y -= i, r.height += i * 2);
    }
  }
  return r;
}
var W_e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e.call(this) || this;
      return r.type = t.type, r._isFirstFrame = !0, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this._model = r, this._removeOnRenderedListener(i), this._updateDrawMode(r);
      var a = r.get("coordinateSystem");
      a === "cartesian2d" || a === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(r, n, i) : this._renderNormal(r, n, i, o)) : process.env.NODE_ENV !== "production" && nn("Only cartesian2d and polar supported for bar.");
    }, t.prototype.incrementalPrepareRender = function(r) {
      this._clear(), this._updateDrawMode(r), this._updateLargeClip(r);
    }, t.prototype.incrementalRender = function(r, n) {
      this._progressiveEls = [], this._incrementalRenderLarge(r, n);
    }, t.prototype.eachRendered = function(r) {
      Su(this._progressiveEls || this.group, r);
    }, t.prototype._updateDrawMode = function(r) {
      var n = r.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, t.prototype._renderNormal = function(r, n, i, o) {
      var a = this.group, s = r.getData(), l = this._data, u = r.coordinateSystem, c = u.getBaseAxis(), d;
      u.type === "cartesian2d" ? d = c.isHorizontal() : u.type === "polar" && (d = c.dim === "angle");
      var h = r.isAnimationEnabled() ? r : null, f = j_e(r, u);
      f && this._enableRealtimeSort(f, s, i);
      var p = r.get("clip", !0) || f, g = z_e(u, s);
      a.removeClipPath();
      var v = r.get("roundCap", !0), m = r.get("showBackground", !0), y = r.getModel("backgroundStyle"), C = y.get("borderRadius") || 0, S = [], b = this._backgroundEls, w = o && o.isInitSort, x = o && o.type === "changeAxisOrder";
      function R(P) {
        var D = py[u.type](s, P), O = Q_e(u, d, D);
        return O.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? O.setShape("r", C) : O.setShape("cornerRadius", C), S[P] = O, O;
      }
      s.diff(l).add(function(P) {
        var D = s.getItemModel(P), O = py[u.type](s, P, D);
        if (m && R(P), !(!s.hasValue(P) || !kV[u.type](O))) {
          var A = !1;
          p && (A = OV[u.type](g, O));
          var F = LV[u.type](r, s, P, O, d, h, c.model, !1, v);
          f && (F.forceLabelAnimation = !0), VV(F, s, P, D, O, r, d, u.type === "polar"), w ? F.attr({
            shape: O
          }) : f ? FV(f, h, F, O, P, d, !1, !1) : jr(F, {
            shape: O
          }, r, P), s.setItemGraphicEl(P, F), a.add(F), F.ignore = A;
        }
      }).update(function(P, D) {
        var O = s.getItemModel(P), A = py[u.type](s, P, O);
        if (m) {
          var F = void 0;
          b.length === 0 ? F = R(D) : (F = b[D], F.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? F.setShape("r", C) : F.setShape("cornerRadius", C), S[P] = F);
          var L = py[u.type](s, P), N = Zj(d, L, u);
          ur(F, {
            shape: N
          }, h, P);
        }
        var I = l.getItemGraphicEl(D);
        if (!s.hasValue(P) || !kV[u.type](A)) {
          a.remove(I);
          return;
        }
        var B = !1;
        if (p && (B = OV[u.type](g, A), B && a.remove(I)), I ? Fa(I) : I = LV[u.type](r, s, P, A, d, h, c.model, !!I, v), f && (I.forceLabelAnimation = !0), x) {
          var M = I.getTextContent();
          if (M) {
            var V = Sf(M);
            V.prevValue != null && (V.prevValue = V.value);
          }
        } else
          VV(I, s, P, O, A, r, d, u.type === "polar");
        w ? I.attr({
          shape: A
        }) : f ? FV(f, h, I, A, P, d, !0, x) : ur(I, {
          shape: A
        }, r, P, null), s.setItemGraphicEl(P, I), I.ignore = B, a.add(I);
      }).remove(function(P) {
        var D = l.getItemGraphicEl(P);
        D && Ug(D, r, P);
      }).execute();
      var _ = this._backgroundGroup || (this._backgroundGroup = new Ct());
      _.removeAll();
      for (var T = 0; T < S.length; ++T)
        _.add(S[T]);
      a.add(_), this._backgroundEls = S, this._data = s;
    }, t.prototype._renderLarge = function(r, n, i) {
      this._clear(), $V(r, this.group), this._updateLargeClip(r);
    }, t.prototype._incrementalRenderLarge = function(r, n) {
      this._removeBackground(), $V(n, this.group, this._progressiveEls, !0);
    }, t.prototype._updateLargeClip = function(r) {
      var n = r.get("clip", !0) && Kv(r.coordinateSystem, !1, r), i = this.group;
      n ? i.setClipPath(n) : i.removeClipPath();
    }, t.prototype._enableRealtimeSort = function(r, n, i) {
      var o = this;
      if (n.count()) {
        var a = r.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(n, r, i), this._isFirstFrame = !1;
        else {
          var s = function(l) {
            var u = n.getItemGraphicEl(l), c = u && u.shape;
            return c && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(a.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            o._updateSortWithinSameData(n, s, a, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, t.prototype._dataSort = function(r, n, i) {
      var o = [];
      return r.each(r.mapDimension(n.dim), function(a, s) {
        var l = i(s);
        l = l ?? NaN, o.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: a
        });
      }), o.sort(function(a, s) {
        return s.mappedValue - a.mappedValue;
      }), {
        ordinalNumbers: Ee(o, function(a) {
          return a.ordinalNumber;
        })
      };
    }, t.prototype._isOrderChangedWithinSameData = function(r, n, i) {
      for (var o = i.scale, a = r.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, u = o.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = r.rawIndexOf(a, o.getRawOrdinalNumber(l)), d = c < 0 ? Number.MIN_VALUE : n(r.indexOfRawIndex(c));
        if (d > s)
          return !0;
        s = d;
      }
      return !1;
    }, t.prototype._isOrderDifferentInView = function(r, n) {
      for (var i = n.scale, o = i.getExtent(), a = Math.max(0, o[0]), s = Math.min(o[1], i.getOrdinalMeta().categories.length - 1); a <= s; ++a)
        if (r.ordinalNumbers[a] !== i.getRawOrdinalNumber(a))
          return !0;
    }, t.prototype._updateSortWithinSameData = function(r, n, i, o) {
      if (this._isOrderChangedWithinSameData(r, n, i)) {
        var a = this._dataSort(r, i, n);
        this._isOrderDifferentInView(a, i) && (this._removeOnRenderedListener(o), o.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: a
        }));
      }
    }, t.prototype._dispatchInitSort = function(r, n, i) {
      var o = n.baseAxis, a = this._dataSort(r, o, function(s) {
        return r.get(r.mapDimension(n.otherAxis.dim), s);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: o.dim + "Axis",
        isInitSort: !0,
        axisId: o.index,
        sortInfo: a
      });
    }, t.prototype.remove = function(r, n) {
      this._clear(this._model), this._removeOnRenderedListener(n);
    }, t.prototype.dispose = function(r, n) {
      this._removeOnRenderedListener(n);
    }, t.prototype._removeOnRenderedListener = function(r) {
      this._onRendered && (r.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, t.prototype._clear = function(r) {
      var n = this.group, i = this._data;
      r && r.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(o) {
        Ug(o, r, St(o).dataIndex);
      })) : n.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, t.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, t.type = "bar", t;
  }(br)
), OV = {
  cartesian2d: function(e, t) {
    var r = t.width < 0 ? -1 : 1, n = t.height < 0 ? -1 : 1;
    r < 0 && (t.x += t.width, t.width = -t.width), n < 0 && (t.y += t.height, t.height = -t.height);
    var i = e.x + e.width, o = e.y + e.height, a = ax(t.x, e.x), s = sx(t.x + t.width, i), l = ax(t.y, e.y), u = sx(t.y + t.height, o), c = s < a, d = u < l;
    return t.x = c && a > i ? s : a, t.y = d && l > o ? u : l, t.width = c ? 0 : s - a, t.height = d ? 0 : u - l, r < 0 && (t.x += t.width, t.width = -t.width), n < 0 && (t.y += t.height, t.height = -t.height), c || d;
  },
  polar: function(e, t) {
    var r = t.r0 <= t.r ? 1 : -1;
    if (r < 0) {
      var n = t.r;
      t.r = t.r0, t.r0 = n;
    }
    var i = sx(t.r, e.r), o = ax(t.r0, e.r0);
    t.r = i, t.r0 = o;
    var a = i - o < 0;
    if (r < 0) {
      var n = t.r;
      t.r = t.r0, t.r0 = n;
    }
    return a;
  }
}, LV = {
  cartesian2d: function(e, t, r, n, i, o, a, s, l) {
    var u = new or({
      shape: ge({}, n),
      z2: 1
    });
    if (u.__dataIndex = r, u.name = "item", o) {
      var c = u.shape, d = i ? "height" : "width";
      c[d] = 0;
    }
    return u;
  },
  polar: function(e, t, r, n, i, o, a, s, l) {
    var u = !i && l ? AC : Oi, c = new u({
      shape: n,
      z2: 1
    });
    c.name = "item";
    var d = Xj(i);
    if (c.calculateTextPosition = H_e(d, {
      isRoundCap: u === AC
    }), o) {
      var h = c.shape, f = i ? "r" : "endAngle", p = {};
      h[f] = i ? n.r0 : n.startAngle, p[f] = n[f], (s ? ur : jr)(c, {
        shape: p
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, o);
    }
    return c;
  }
};
function j_e(e, t) {
  var r = e.get("realtimeSort", !0), n = t.getBaseAxis();
  if (process.env.NODE_ENV !== "production" && r && (n.type !== "category" && nn("`realtimeSort` will not work because this bar series is not based on a category axis."), t.type !== "cartesian2d" && nn("`realtimeSort` will not work because this bar series is not on cartesian2d.")), r && n.type === "category" && t.type === "cartesian2d")
    return {
      baseAxis: n,
      otherAxis: t.getOtherAxis(n)
    };
}
function FV(e, t, r, n, i, o, a, s) {
  var l, u;
  o ? (u = {
    x: n.x,
    width: n.width
  }, l = {
    y: n.y,
    height: n.height
  }) : (u = {
    y: n.y,
    height: n.height
  }, l = {
    x: n.x,
    width: n.width
  }), s || (a ? ur : jr)(r, {
    shape: l
  }, t, i, null);
  var c = t ? e.baseAxis.model : null;
  (a ? ur : jr)(r, {
    shape: u
  }, c, i);
}
function NV(e, t) {
  for (var r = 0; r < t.length; r++)
    if (!isFinite(e[t[r]]))
      return !0;
  return !1;
}
var U_e = ["x", "y", "width", "height"], K_e = ["cx", "cy", "r", "startAngle", "endAngle"], kV = {
  cartesian2d: function(e) {
    return !NV(e, U_e);
  },
  polar: function(e) {
    return !NV(e, K_e);
  }
}, py = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(e, t, r) {
    var n = e.getItemLayout(t), i = r ? q_e(r, n) : 0, o = n.width > 0 ? 1 : -1, a = n.height > 0 ? 1 : -1;
    return {
      x: n.x + o * i / 2,
      y: n.y + a * i / 2,
      width: n.width - o * i,
      height: n.height - a * i
    };
  },
  polar: function(e, t, r) {
    var n = e.getItemLayout(t);
    return {
      cx: n.cx,
      cy: n.cy,
      r0: n.r0,
      r: n.r,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    };
  }
};
function Y_e(e) {
  return e.startAngle != null && e.endAngle != null && e.startAngle === e.endAngle;
}
function Xj(e) {
  return /* @__PURE__ */ function(t) {
    var r = t ? "Arc" : "Angle";
    return function(n) {
      switch (n) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return n + r;
        default:
          return n;
      }
    };
  }(e);
}
function VV(e, t, r, n, i, o, a, s) {
  var l = t.getItemVisual(r, "style");
  if (s) {
    if (!o.get("roundCap")) {
      var c = e.shape, d = bc(n.getModel("itemStyle"), c, !0);
      ge(c, d), e.setShape(c);
    }
  } else {
    var u = n.get(["itemStyle", "borderRadius"]) || 0;
    e.setShape("r", u);
  }
  e.useStyle(l);
  var h = n.getShallow("cursor");
  h && e.attr("cursor", h);
  var f = s ? a ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : a ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = $n(n);
  ri(e, p, {
    labelFetcher: o,
    labelDataIndex: r,
    defaultText: qh(o.getData(), r),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: f
  });
  var g = e.getTextContent();
  if (s && g) {
    var v = n.get(["label", "position"]);
    e.textConfig.inside = v === "middle" ? !0 : null, G_e(e, v === "outside" ? f : v, Xj(a), n.get(["label", "rotate"]));
  }
  y7(g, p, o.getRawValue(r), function(y) {
    return Hj(t, y);
  });
  var m = n.getModel(["emphasis"]);
  sn(e, m.get("focus"), m.get("blurScope"), m.get("disabled")), ti(e, n), Y_e(i) && (e.style.fill = "none", e.style.stroke = "none", $(e.states, function(y) {
    y.style && (y.style.fill = y.style.stroke = "none");
  }));
}
function q_e(e, t) {
  var r = e.get(["itemStyle", "borderColor"]);
  if (!r || r === "none")
    return 0;
  var n = e.get(["itemStyle", "borderWidth"]) || 0, i = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width), o = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height);
  return Math.min(n, i, o);
}
var X_e = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), BV = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "largeBar", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new X_e();
    }, t.prototype.buildPath = function(r, n) {
      for (var i = n.points, o = this.baseDimIdx, a = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3)
        l[o] = u, l[a] = i[c + 2], s[o] = i[c + o], s[a] = i[c + a], r.rect(s[0], s[1], l[0], l[1]);
    }, t;
  }(Ht)
);
function $V(e, t, r, n) {
  var i = e.getData(), o = i.getLayout("valueAxisHorizontal") ? 1 : 0, a = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = e.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
  if (u) {
    var c = new BV({
      shape: {
        points: u
      },
      incremental: !!n,
      silent: !0,
      z2: 0
    });
    c.baseDimIdx = o, c.largeDataIndices = a, c.barWidth = s, c.useStyle(l.getItemStyle()), t.add(c), r && r.push(c);
  }
  var d = new BV({
    shape: {
      points: i.getLayout("largePoints")
    },
    incremental: !!n,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  d.baseDimIdx = o, d.largeDataIndices = a, d.barWidth = s, t.add(d), d.useStyle(i.getVisual("style")), St(d).seriesIndex = e.seriesIndex, e.get("silent") || (d.on("mousedown", HV), d.on("mousemove", HV)), r && r.push(d);
}
var HV = Cw(function(e) {
  var t = this, r = Z_e(t, e.offsetX, e.offsetY);
  St(t).dataIndex = r >= 0 ? r : null;
}, 30, !1);
function Z_e(e, t, r) {
  for (var n = e.baseDimIdx, i = 1 - n, o = e.shape.points, a = e.largeDataIndices, s = [], l = [], u = e.barWidth, c = 0, d = o.length / 3; c < d; c++) {
    var h = c * 3;
    if (l[n] = u, l[i] = o[h + 2], s[n] = o[h + n], s[i] = o[h + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), t >= s[0] && t <= s[0] + l[0] && r >= s[1] && r <= s[1] + l[1])
      return a[c];
  }
  return -1;
}
function Zj(e, t, r) {
  if (cd(r, "cartesian2d")) {
    var n = t, i = r.getArea();
    return {
      x: e ? n.x : i.x,
      y: e ? i.y : n.y,
      width: e ? n.width : i.width,
      height: e ? i.height : n.height
    };
  } else {
    var i = r.getArea(), o = t;
    return {
      cx: i.cx,
      cy: i.cy,
      r0: e ? i.r0 : o.r0,
      r: e ? i.r : o.r,
      startAngle: e ? o.startAngle : 0,
      endAngle: e ? o.endAngle : Math.PI * 2
    };
  }
}
function Q_e(e, t, r) {
  var n = e.type === "polar" ? Oi : or;
  return new n({
    shape: Zj(t, r, e),
    silent: !0,
    z2: 0
  });
}
function J_e(e) {
  e.registerChartView(W_e), e.registerSeriesModel(B_e), e.registerLayout(e.PRIORITY.VISUAL.LAYOUT, _t(rj, "bar")), e.registerLayout(e.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, nj("bar")), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, qj("bar")), e.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(t, r) {
    var n = t.componentType || "series";
    r.eachComponent({
      mainType: n,
      query: t
    }, function(i) {
      t.sortInfo && i.axis.setCategorySortInfo(t.sortInfo);
    });
  });
}
var GV = Math.PI * 2, gy = Math.PI / 180;
function Qj(e, t) {
  return En(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function Jj(e, t) {
  var r = Qj(e, t), n = e.get("center"), i = e.get("radius");
  be(i) || (i = [0, i]);
  var o = Be(r.width, t.getWidth()), a = Be(r.height, t.getHeight()), s = Math.min(o, a), l = Be(i[0], s / 2), u = Be(i[1], s / 2), c, d, h = e.coordinateSystem;
  if (h) {
    var f = h.dataToPoint(n);
    c = f[0] || 0, d = f[1] || 0;
  } else
    be(n) || (n = [n, n]), c = Be(n[0], o) + r.x, d = Be(n[1], a) + r.y;
  return {
    cx: c,
    cy: d,
    r0: l,
    r: u
  };
}
function eTe(e, t, r) {
  t.eachSeriesByType(e, function(n) {
    var i = n.getData(), o = i.mapDimension("value"), a = Qj(n, r), s = Jj(n, r), l = s.cx, u = s.cy, c = s.r, d = s.r0, h = -n.get("startAngle") * gy, f = n.get("endAngle"), p = n.get("padAngle") * gy;
    f = f === "auto" ? h - GV : -f * gy;
    var g = n.get("minAngle") * gy, v = g + p, m = 0;
    i.each(o, function(N) {
      !isNaN(N) && m++;
    });
    var y = i.getSum(o), C = Math.PI / (y || m) * 2, S = n.get("clockwise"), b = n.get("roseType"), w = n.get("stillShowZeroSum"), x = i.getDataExtent(o);
    x[0] = 0;
    var R = S ? 1 : -1, _ = [h, f], T = R * p / 2;
    QM(_, !S), h = _[0], f = _[1];
    var P = eU(n);
    P.startAngle = h, P.endAngle = f, P.clockwise = S;
    var D = Math.abs(f - h), O = D, A = 0, F = h;
    if (i.setLayout({
      viewRect: a,
      r: c
    }), i.each(o, function(N, I) {
      var B;
      if (isNaN(N)) {
        i.setItemLayout(I, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: S,
          cx: l,
          cy: u,
          r0: d,
          r: b ? NaN : c
        });
        return;
      }
      b !== "area" ? B = y === 0 && w ? C : N * C : B = D / m, B < v ? (B = v, O -= v) : A += N;
      var M = F + R * B, V = 0, G = 0;
      p > B ? (V = F + R * B / 2, G = V) : (V = F + T, G = M - T), i.setItemLayout(I, {
        angle: B,
        startAngle: V,
        endAngle: G,
        clockwise: S,
        cx: l,
        cy: u,
        r0: d,
        r: b ? Cr(N, x, [d, c]) : c
      }), F = M;
    }), O < GV && m)
      if (O <= 1e-3) {
        var L = D / m;
        i.each(o, function(N, I) {
          if (!isNaN(N)) {
            var B = i.getItemLayout(I);
            B.angle = L;
            var M = 0, V = 0;
            L < p ? (M = h + R * (I + 1 / 2) * L, V = M) : (M = h + R * I * L + T, V = h + R * (I + 1) * L - T), B.startAngle = M, B.endAngle = V;
          }
        });
      } else
        C = O / A, F = h, i.each(o, function(N, I) {
          if (!isNaN(N)) {
            var B = i.getItemLayout(I), M = B.angle === v ? v : N * C, V = 0, G = 0;
            M < p ? (V = F + R * M / 2, G = V) : (V = F + T, G = F + R * M - T), B.startAngle = V, B.endAngle = G, F += R * M;
          }
        });
  });
}
var eU = ar();
function qv(e) {
  return {
    seriesType: e,
    reset: function(t, r) {
      var n = r.findComponents({
        mainType: "legend"
      });
      if (!(!n || !n.length)) {
        var i = t.getData();
        i.filterSelf(function(o) {
          for (var a = i.getName(o), s = 0; s < n.length; s++)
            if (!n[s].isSelected(a))
              return !1;
          return !0;
        });
      }
    }
  };
}
var tTe = Math.PI / 180;
function zV(e, t, r, n, i, o, a, s, l, u) {
  if (e.length < 2)
    return;
  function c(g) {
    for (var v = g.rB, m = v * v, y = 0; y < g.list.length; y++) {
      var C = g.list[y], S = Math.abs(C.label.y - r), b = n + C.len, w = b * b, x = Math.sqrt((1 - Math.abs(S * S / m)) * w), R = t + (x + C.len2) * i, _ = R - C.label.x, T = C.targetTextWidth - _ * i;
      tU(C, T, !0), C.label.x = R;
    }
  }
  function d(g) {
    for (var v = {
      list: [],
      maxY: 0
    }, m = {
      list: [],
      maxY: 0
    }, y = 0; y < g.length; y++)
      if (g[y].labelAlignTo === "none") {
        var C = g[y], S = C.label.y > r ? m : v, b = Math.abs(C.label.y - r);
        if (b >= S.maxY) {
          var w = C.label.x - t - C.len2 * i, x = n + C.len, R = Math.abs(w) < x ? Math.sqrt(b * b / (1 - w * w / x / x)) : x;
          S.rB = R, S.maxY = b;
        }
        S.list.push(C);
      }
    c(v), c(m);
  }
  for (var h = e.length, f = 0; f < h; f++)
    if (e[f].position === "outer" && e[f].labelAlignTo === "labelLine") {
      var p = e[f].label.x - u;
      e[f].linePoints[1][0] += p, e[f].label.x = u;
    }
  Ej(e, l, l + a) && d(e);
}
function rTe(e, t, r, n, i, o, a, s) {
  for (var l = [], u = [], c = Number.MAX_VALUE, d = -Number.MAX_VALUE, h = 0; h < e.length; h++) {
    var f = e[h].label;
    lx(e[h]) || (f.x < t ? (c = Math.min(c, f.x), l.push(e[h])) : (d = Math.max(d, f.x), u.push(e[h])));
  }
  for (var h = 0; h < e.length; h++) {
    var p = e[h];
    if (!lx(p) && p.linePoints) {
      if (p.labelStyleWidth != null)
        continue;
      var f = p.label, g = p.linePoints, v = void 0;
      p.labelAlignTo === "edge" ? f.x < t ? v = g[2][0] - p.labelDistance - a - p.edgeDistance : v = a + i - p.edgeDistance - g[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? f.x < t ? v = c - a - p.bleedMargin : v = a + i - d - p.bleedMargin : f.x < t ? v = f.x - a - p.bleedMargin : v = a + i - f.x - p.bleedMargin, p.targetTextWidth = v, tU(p, v);
    }
  }
  zV(u, t, r, n, 1, i, o, a, s, d), zV(l, t, r, n, -1, i, o, a, s, c);
  for (var h = 0; h < e.length; h++) {
    var p = e[h];
    if (!lx(p) && p.linePoints) {
      var f = p.label, g = p.linePoints, m = p.labelAlignTo === "edge", y = f.style.padding, C = y ? y[1] + y[3] : 0, S = f.style.backgroundColor ? 0 : C, b = p.rect.width + S, w = g[1][0] - g[2][0];
      m ? f.x < t ? g[2][0] = a + p.edgeDistance + b + p.labelDistance : g[2][0] = a + i - p.edgeDistance - b - p.labelDistance : (f.x < t ? g[2][0] = f.x + p.labelDistance : g[2][0] = f.x - p.labelDistance, g[1][0] = g[2][0] + w), g[1][1] = g[2][1] = f.y;
    }
  }
}
function tU(e, t, r) {
  if (r === void 0 && (r = !1), e.labelStyleWidth == null) {
    var n = e.label, i = n.style, o = e.rect, a = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, u = i.overflow, c = o.width + (a ? 0 : l);
    if (t < c || r) {
      var d = o.height;
      if (u && u.match("break")) {
        n.setStyle("backgroundColor", null), n.setStyle("width", t - l);
        var h = n.getBoundingRect();
        n.setStyle("width", Math.ceil(h.width)), n.setStyle("backgroundColor", a);
      } else {
        var f = t - l, p = t < c ? f : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          r ? f > e.unconstrainedWidth ? null : f : null
        );
        n.setStyle("width", p);
      }
      var g = n.getBoundingRect();
      o.width = g.width;
      var v = (n.style.margin || 0) + 2.1;
      o.height = g.height + v, o.y -= (o.height - d) / 2;
    }
  }
}
function lx(e) {
  return e.position === "center";
}
function nTe(e) {
  var t = e.getData(), r = [], n, i, o = !1, a = (e.get("minShowLabelAngle") || 0) * tTe, s = t.getLayout("viewRect"), l = t.getLayout("r"), u = s.width, c = s.x, d = s.y, h = s.height;
  function f(w) {
    w.ignore = !0;
  }
  function p(w) {
    if (!w.ignore)
      return !0;
    for (var x in w.states)
      if (w.states[x].ignore === !1)
        return !0;
    return !1;
  }
  t.each(function(w) {
    var x = t.getItemGraphicEl(w), R = x.shape, _ = x.getTextContent(), T = x.getTextGuideLine(), P = t.getItemModel(w), D = P.getModel("label"), O = D.get("position") || P.get(["emphasis", "label", "position"]), A = D.get("distanceToLabelLine"), F = D.get("alignTo"), L = Be(D.get("edgeDistance"), u), N = D.get("bleedMargin"), I = P.getModel("labelLine"), B = I.get("length");
    B = Be(B, u);
    var M = I.get("length2");
    if (M = Be(M, u), Math.abs(R.endAngle - R.startAngle) < a) {
      $(_.states, f), _.ignore = !0, T && ($(T.states, f), T.ignore = !0);
      return;
    }
    if (p(_)) {
      var V = (R.startAngle + R.endAngle) / 2, G = Math.cos(V), k = Math.sin(V), z, j, q, K;
      n = R.cx, i = R.cy;
      var Z = O === "inside" || O === "inner";
      if (O === "center")
        z = R.cx, j = R.cy, K = "center";
      else {
        var re = (Z ? (R.r + R.r0) / 2 * G : R.r * G) + n, X = (Z ? (R.r + R.r0) / 2 * k : R.r * k) + i;
        if (z = re + G * 3, j = X + k * 3, !Z) {
          var Y = re + G * (B + l - R.r), U = X + k * (B + l - R.r), oe = Y + (G < 0 ? -1 : 1) * M, W = U;
          F === "edge" ? z = G < 0 ? c + L : c + u - L : z = oe + (G < 0 ? -A : A), j = W, q = [[re, X], [Y, U], [oe, W]];
        }
        K = Z ? "center" : F === "edge" ? G > 0 ? "right" : "left" : G > 0 ? "left" : "right";
      }
      var ne = Math.PI, ce = 0, we = D.get("rotate");
      if (sr(we))
        ce = we * (ne / 180);
      else if (O === "center")
        ce = 0;
      else if (we === "radial" || we === !0) {
        var Re = G < 0 ? -V + ne : -V;
        ce = Re;
      } else if (we === "tangential" && O !== "outside" && O !== "outer") {
        var ve = Math.atan2(G, k);
        ve < 0 && (ve = ne * 2 + ve);
        var xe = k > 0;
        xe && (ve = ne + ve), ce = ve - ne;
      }
      if (o = !!ce, _.x = z, _.y = j, _.rotation = ce, _.setStyle({
        verticalAlign: "middle"
      }), Z) {
        _.setStyle({
          align: K
        });
        var Fe = _.states.select;
        Fe && (Fe.x += _.x, Fe.y += _.y);
      } else {
        var _e = _.getBoundingRect().clone();
        _e.applyTransform(_.getComputedTransform());
        var Ve = (_.style.margin || 0) + 2.1;
        _e.y -= Ve / 2, _e.height += Ve, r.push({
          label: _,
          labelLine: T,
          position: O,
          len: B,
          len2: M,
          minTurnAngle: I.get("minTurnAngle"),
          maxSurfaceAngle: I.get("maxSurfaceAngle"),
          surfaceNormal: new Dt(G, k),
          linePoints: q,
          textAlign: K,
          labelDistance: A,
          labelAlignTo: F,
          edgeDistance: L,
          bleedMargin: N,
          rect: _e,
          unconstrainedWidth: _e.width,
          labelStyleWidth: _.style.width
        });
      }
      x.setTextConfig({
        inside: Z
      });
    }
  }), !o && e.get("avoidLabelOverlap") && rTe(r, n, i, l, u, h, c, d);
  for (var g = 0; g < r.length; g++) {
    var v = r[g], m = v.label, y = v.labelLine, C = isNaN(m.x) || isNaN(m.y);
    if (m) {
      m.setStyle({
        align: v.textAlign
      }), C && ($(m.states, f), m.ignore = !0);
      var S = m.states.select;
      S && (S.x += m.x, S.y += m.y);
    }
    if (y) {
      var b = v.linePoints;
      C || !b ? ($(y.states, f), y.ignore = !0) : (wj(b, v.minTurnAngle), _Re(b, v.surfaceNormal, v.maxSurfaceAngle), y.setShape({
        points: b
      }), m.__hostTarget.textGuideLineConfig = {
        anchor: new Dt(b[0][0], b[0][1])
      });
    }
  }
}
var iTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i) {
      var o = e.call(this) || this;
      o.z2 = 2;
      var a = new ir();
      return o.setTextContent(a), o.updateData(r, n, i, !0), o;
    }
    return t.prototype.updateData = function(r, n, i, o) {
      var a = this, s = r.hostModel, l = r.getItemModel(n), u = l.getModel("emphasis"), c = r.getItemLayout(n), d = ge(bc(l.getModel("itemStyle"), c, !0), c);
      if (isNaN(d.startAngle)) {
        a.setShape(d);
        return;
      }
      if (o) {
        a.setShape(d);
        var h = s.getShallow("animationType");
        s.ecModel.ssr ? (jr(a, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: n,
          isFrom: !0
        }), a.originX = d.cx, a.originY = d.cy) : h === "scale" ? (a.shape.r = c.r0, jr(a, {
          shape: {
            r: c.r
          }
        }, s, n)) : i != null ? (a.setShape({
          startAngle: i,
          endAngle: i
        }), jr(a, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, s, n)) : (a.shape.endAngle = c.startAngle, ur(a, {
          shape: {
            endAngle: c.endAngle
          }
        }, s, n));
      } else
        Fa(a), ur(a, {
          shape: d
        }, s, n);
      a.useStyle(r.getItemVisual(n, "style")), ti(a, l);
      var f = (c.startAngle + c.endAngle) / 2, p = s.get("selectedOffset"), g = Math.cos(f) * p, v = Math.sin(f) * p, m = l.getShallow("cursor");
      m && a.attr("cursor", m), this._updateLabel(s, r, n), a.ensureState("emphasis").shape = ge({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, bc(u.getModel("itemStyle"), c)), ge(a.ensureState("select"), {
        x: g,
        y: v,
        shape: bc(l.getModel(["select", "itemStyle"]), c)
      }), ge(a.ensureState("blur"), {
        shape: bc(l.getModel(["blur", "itemStyle"]), c)
      });
      var y = a.getTextGuideLine(), C = a.getTextContent();
      y && ge(y.ensureState("select"), {
        x: g,
        y: v
      }), ge(C.ensureState("select"), {
        x: g,
        y: v
      }), sn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(r, n, i) {
      var o = this, a = n.getItemModel(i), s = a.getModel("labelLine"), l = n.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      ri(o, $n(a), {
        labelFetcher: n.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: r.getFormattedLabel(i, "normal") || n.getName(i)
      });
      var d = o.getTextContent();
      o.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), d.attr({
        z2: 10
      });
      var h = r.get(["label", "position"]);
      if (h !== "outside" && h !== "outer")
        o.removeTextGuideLine();
      else {
        var f = this.getTextGuideLine();
        f || (f = new Ni(), this.setTextGuideLine(f)), YD(this, qD(a), {
          stroke: u,
          opacity: So(s.get(["lineStyle", "opacity"]), c, 1)
        });
      }
    }, t;
  }(Oi)
), oTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.ignoreLabelLineUpdate = !0, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = r.getData(), s = this._data, l = this.group, u;
      if (!s && a.count() > 0) {
        for (var c = a.getItemLayout(0), d = 1; isNaN(c && c.startAngle) && d < a.count(); ++d)
          c = a.getItemLayout(d);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), a.count() === 0 && r.get("showEmptyCircle")) {
        var h = eU(r), f = new Oi({
          shape: ge(Jj(r, i), h)
        });
        f.useStyle(r.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = f, l.add(f);
      }
      a.diff(s).add(function(p) {
        var g = new iTe(a, p, u);
        a.setItemGraphicEl(p, g), l.add(g);
      }).update(function(p, g) {
        var v = s.getItemGraphicEl(g);
        v.updateData(a, p, u), v.off("click"), l.add(v), a.setItemGraphicEl(p, v);
      }).remove(function(p) {
        var g = s.getItemGraphicEl(p);
        Ug(g, r, p);
      }).execute(), nTe(r), r.get("animationTypeUpdate") !== "expansion" && (this._data = a);
    }, t.prototype.dispose = function() {
    }, t.prototype.containPoint = function(r, n) {
      var i = n.getData(), o = i.getItemLayout(0);
      if (o) {
        var a = r[0] - o.cx, s = r[1] - o.cy, l = Math.sqrt(a * a + s * s);
        return l <= o.r && l >= o.r0;
      }
    }, t.type = "pie", t;
  }(br)
);
function Df(e, t, r) {
  t = be(t) && {
    coordDimensions: t
  } || ge({
    encodeDefine: e.getEncode()
  }, t);
  var n = e.getSource(), i = Tf(n, t).dimensions, o = new di(i, e);
  return o.initData(n, r), o;
}
var Xv = (
  /** @class */
  function() {
    function e(t, r) {
      this._getDataWithEncodedVisual = t, this._getRawData = r;
    }
    return e.prototype.getAllNames = function() {
      var t = this._getRawData();
      return t.mapArray(t.getName);
    }, e.prototype.containName = function(t) {
      var r = this._getRawData();
      return r.indexOfName(t) >= 0;
    }, e.prototype.indexOfName = function(t) {
      var r = this._getDataWithEncodedVisual();
      return r.indexOfName(t);
    }, e.prototype.getItemVisual = function(t, r) {
      var n = this._getDataWithEncodedVisual();
      return n.getItemVisual(t, r);
    }, e;
  }()
), aTe = ar(), sTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments), this.legendVisualProvider = new Xv(je(this.getData, this), je(this.getRawData, this)), this._defaultLabelLine(r);
    }, t.prototype.mergeOption = function() {
      e.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.getInitialData = function() {
      return Df(this, {
        coordDimensions: ["value"],
        encodeDefaulter: _t(wD, this)
      });
    }, t.prototype.getDataParams = function(r) {
      var n = this.getData(), i = aTe(n), o = i.seats;
      if (!o) {
        var a = [];
        n.each(n.mapDimension("value"), function(l) {
          a.push(l);
        }), o = i.seats = fW(a, n.hostModel.get("percentPrecision"));
      }
      var s = e.prototype.getDataParams.call(this, r);
      return s.percent = o[r] || 0, s.$vars.push("percent"), s;
    }, t.prototype._defaultLabelLine = function(r) {
      Gc(r, "labelLine", ["show"]);
      var n = r.labelLine, i = r.emphasis.labelLine;
      n.show = n.show && r.label.show, i.show = i.show && r.emphasis.label.show;
    }, t.type = "series.pie", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      // 0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 
      selectedOffset: 10,
      // singlemultiple
      // selectedMode: false,
      // 'radius' | 'area'
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter:  tooltip.formatter
        //  textStyle
        // distance: positioninnerlabel()
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 
        length: 15,
        // 
        length2: 15,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: ,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, t;
  }(Pr)
);
function lTe(e) {
  return {
    seriesType: e,
    reset: function(t, r) {
      var n = t.getData();
      n.filterSelf(function(i) {
        var o = n.mapDimension("value"), a = n.get(o, i);
        return !(sr(a) && !isNaN(a) && a < 0);
      });
    }
  };
}
function uTe(e) {
  e.registerChartView(oTe), e.registerSeriesModel(sTe), S9("pie", e.registerAction), e.registerLayout(_t(eTe, "pie")), e.registerProcessor(qv("pie")), e.registerProcessor(lTe("pie"));
}
var cTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return ws(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getProgressive = function() {
      var r = this.option.progressive;
      return r ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var r = this.option.progressiveThreshold;
      return r ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, t.prototype.brushSelector = function(r, n, i) {
      return i.point(n.getItemLayout(r));
    }, t.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, t.type = "series.scatter", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, t;
  }(Pr)
), rU = 4, dTe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), hTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return t.prototype.getDefaultShape = function() {
      return new dTe();
    }, t.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points, o = n.size, a = this.symbolProxy, s = a.shape, l = r.getContext ? r.getContext() : r, u = l && o[0] < rU, c = this.softClipShape, d;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, d = this._off; d < i.length; ) {
        var h = i[d++], f = i[d++];
        isNaN(h) || isNaN(f) || c && !c.contain(h, f) || (s.x = h - o[0] / 2, s.y = f - o[1] / 2, s.width = o[0], s.height = o[1], a.buildPath(r, s, !0));
      }
      this.incremental && (this._off = d, this.notClear = !0);
    }, t.prototype.afterBrush = function() {
      var r = this.shape, n = r.points, i = r.size, o = this._ctx, a = this.softClipShape, s;
      if (o) {
        for (s = this._off; s < n.length; ) {
          var l = n[s++], u = n[s++];
          isNaN(l) || isNaN(u) || a && !a.contain(l, u) || o.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = s, this.notClear = !0);
      }
    }, t.prototype.findDataIndex = function(r, n) {
      for (var i = this.shape, o = i.points, a = i.size, s = Math.max(a[0], 4), l = Math.max(a[1], 4), u = o.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, d = o[c] - s / 2, h = o[c + 1] - l / 2;
        if (r >= d && n >= h && r <= d + s && n <= h + l)
          return u;
      }
      return -1;
    }, t.prototype.contain = function(r, n) {
      var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect();
      if (r = i[0], n = i[1], o.contain(r, n)) {
        var a = this.hoverDataIdx = this.findDataIndex(r, n);
        return a >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, t.prototype.getBoundingRect = function() {
      var r = this._rect;
      if (!r) {
        for (var n = this.shape, i = n.points, o = n.size, a = o[0], s = o[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, d = -1 / 0, h = 0; h < i.length; ) {
          var f = i[h++], p = i[h++];
          l = Math.min(f, l), c = Math.max(f, c), u = Math.min(p, u), d = Math.max(p, d);
        }
        r = this._rect = new At(l - a / 2, u - s / 2, c - l + a, d - u + s);
      }
      return r;
    }, t;
  }(Ht)
), fTe = (
  /** @class */
  function() {
    function e() {
      this.group = new Ct();
    }
    return e.prototype.updateData = function(t, r) {
      this._clear();
      var n = this._create();
      n.setShape({
        points: t.getLayout("points")
      }), this._setCommon(n, t, r);
    }, e.prototype.updateLayout = function(t) {
      var r = t.getLayout("points");
      this.group.eachChild(function(n) {
        if (n.startIndex != null) {
          var i = (n.endIndex - n.startIndex) * 2, o = n.startIndex * 4 * 2;
          r = new Float32Array(r.buffer, o, i);
        }
        n.setShape("points", r), n.reset();
      });
    }, e.prototype.incrementalPrepareUpdate = function(t) {
      this._clear();
    }, e.prototype.incrementalUpdate = function(t, r, n) {
      var i = this._newAdded[0], o = r.getLayout("points"), a = i && i.shape.points;
      if (a && a.length < 2e4) {
        var s = a.length, l = new Float32Array(s + o.length);
        l.set(a), l.set(o, s), i.endIndex = t.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = t.start, u.endIndex = t.end, u.incremental = !0, u.setShape({
          points: o
        }), this._setCommon(u, r, n);
      }
    }, e.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, e.prototype._create = function() {
      var t = new hTe({
        cursor: "default"
      });
      return t.ignoreCoarsePointer = !0, this.group.add(t), this._newAdded.push(t), t;
    }, e.prototype._setCommon = function(t, r, n) {
      var i = r.hostModel;
      n = n || {};
      var o = r.getVisual("symbolSize");
      t.setShape("size", o instanceof Array ? o : [o, o]), t.softClipShape = n.clipShape || null, t.symbolProxy = mn(r.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor;
      var a = t.shape.size[0] < rU;
      t.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        i.getModel("itemStyle").getItemStyle(a ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var s = r.getVisual("style"), l = s && s.fill;
      l && t.setColor(l);
      var u = St(t);
      u.seriesIndex = i.seriesIndex, t.on("mousemove", function(c) {
        u.dataIndex = null;
        var d = t.hoverDataIdx;
        d >= 0 && (u.dataIndex = d + (t.startIndex || 0));
      });
    }, e.prototype.remove = function() {
      this._clear();
    }, e.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, e;
  }()
), pTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this._updateSymbolDraw(o, r);
      a.updateData(o, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(r)
      }), this._finished = !0;
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      var o = r.getData(), a = this._updateSymbolDraw(o, r);
      a.incrementalPrepareUpdate(o), this._finished = !1;
    }, t.prototype.incrementalRender = function(r, n, i) {
      this._symbolDraw.incrementalUpdate(r, n.getData(), {
        clipShape: this._getClipShape(n)
      }), this._finished = r.end === n.getData().count();
    }, t.prototype.updateTransform = function(r, n, i) {
      var o = r.getData();
      if (this.group.dirty(), !this._finished || o.count() > 1e4)
        return {
          update: !0
        };
      var a = Yv("").reset(r, n, i);
      a.progress && a.progress({
        start: 0,
        end: o.count(),
        count: o.count()
      }, o), this._symbolDraw.updateLayout(o);
    }, t.prototype.eachRendered = function(r) {
      this._symbolDraw && this._symbolDraw.eachRendered(r);
    }, t.prototype._getClipShape = function(r) {
      if (r.get("clip", !0)) {
        var n = r.coordinateSystem;
        return n && n.getArea && n.getArea(0.1);
      }
    }, t.prototype._updateSymbolDraw = function(r, n) {
      var i = this._symbolDraw, o = n.pipelineContext, a = o.large;
      return (!i || a !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = a ? new fTe() : new Uv(), this._isLargeDraw = a, this.group.removeAll()), this.group.add(i.group), i;
    }, t.prototype.remove = function(r, n) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, t.prototype.dispose = function() {
    }, t.type = "scatter", t;
  }(br)
), gTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.type = "grid", t.dependencies = ["xAxis", "yAxis"], t.layoutMode = "box", t.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      // If grid size contain label
      containLabel: !1,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, t;
  }(Vt)
), fT = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", bn).models[0];
    }, t.type = "cartesian2dAxis", t;
  }(Vt)
);
cn(fT, Mf);
var nU = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: !0,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
}, vTe = Mt({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, nU), rA = Mt({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, nU), mTe = Mt({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, rA), yTe = ut({
  logBase: 10
}, rA);
const iU = {
  category: vTe,
  value: rA,
  time: mTe,
  log: yTe
};
var CTe = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function Xh(e, t, r, n) {
  $(CTe, function(i, o) {
    var a = Mt(Mt({}, iU[o], !0), n, !0), s = (
      /** @class */
      function(l) {
        le(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = t + "Axis." + o, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, d) {
          var h = Yg(this), f = h ? bf(c) : {}, p = d.getTheme();
          Mt(c, p.get(o + "Axis")), Mt(c, this.getDefaultOption()), c.type = WV(c), h && su(c, f, h);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = oT.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var d = this.option;
          if (d.type === "category")
            return c ? d.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = t + "Axis." + o, u.defaultOption = a, u;
      }(r)
    );
    e.registerComponentModel(s);
  }), e.registerSubTypeDefaulter(t + "Axis", WV);
}
function WV(e) {
  return e.type || (e.data ? "category" : "value");
}
var STe = (
  /** @class */
  function() {
    function e(t) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = t || "";
    }
    return e.prototype.getAxis = function(t) {
      return this._axes[t];
    }, e.prototype.getAxes = function() {
      return Ee(this._dimList, function(t) {
        return this._axes[t];
      }, this);
    }, e.prototype.getAxesByScale = function(t) {
      return t = t.toLowerCase(), Sr(this.getAxes(), function(r) {
        return r.scale.type === t;
      });
    }, e.prototype.addAxis = function(t) {
      var r = t.dim;
      this._axes[r] = t, this._dimList.push(r);
    }, e;
  }()
), pT = ["x", "y"];
function jV(e) {
  return e.type === "interval" || e.type === "time";
}
var wTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "cartesian2d", r.dimensions = pT, r;
    }
    return t.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var r = this.getAxis("x").scale, n = this.getAxis("y").scale;
      if (!(!jV(r) || !jV(n))) {
        var i = r.getExtent(), o = n.getExtent(), a = this.dataToPoint([i[0], o[0]]), s = this.dataToPoint([i[1], o[1]]), l = i[1] - i[0], u = o[1] - o[0];
        if (!(!l || !u)) {
          var c = (s[0] - a[0]) / l, d = (s[1] - a[1]) / u, h = a[0] - i[0] * c, f = a[1] - o[0] * d, p = this._transform = [c, 0, 0, d, h, f];
          this._invTransform = id([], p);
        }
      }
    }, t.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, t.prototype.containPoint = function(r) {
      var n = this.getAxis("x"), i = this.getAxis("y");
      return n.contain(n.toLocalCoord(r[0])) && i.contain(i.toLocalCoord(r[1]));
    }, t.prototype.containData = function(r) {
      return this.getAxis("x").containData(r[0]) && this.getAxis("y").containData(r[1]);
    }, t.prototype.containZone = function(r, n) {
      var i = this.dataToPoint(r), o = this.dataToPoint(n), a = this.getArea(), s = new At(i[0], i[1], o[0] - i[0], o[1] - i[1]);
      return a.intersect(s);
    }, t.prototype.dataToPoint = function(r, n, i) {
      i = i || [];
      var o = r[0], a = r[1];
      if (this._transform && o != null && isFinite(o) && a != null && isFinite(a))
        return Un(i, r, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = s.toGlobalCoord(s.dataToCoord(o, n)), i[1] = l.toGlobalCoord(l.dataToCoord(a, n)), i;
    }, t.prototype.clampData = function(r, n) {
      var i = this.getAxis("x").scale, o = this.getAxis("y").scale, a = i.getExtent(), s = o.getExtent(), l = i.parse(r[0]), u = o.parse(r[1]);
      return n = n || [], n[0] = Math.min(Math.max(Math.min(a[0], a[1]), l), Math.max(a[0], a[1])), n[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), n;
    }, t.prototype.pointToData = function(r, n) {
      var i = [];
      if (this._invTransform)
        return Un(i, r, this._invTransform);
      var o = this.getAxis("x"), a = this.getAxis("y");
      return i[0] = o.coordToData(o.toLocalCoord(r[0]), n), i[1] = a.coordToData(a.toLocalCoord(r[1]), n), i;
    }, t.prototype.getOtherAxis = function(r) {
      return this.getAxis(r.dim === "x" ? "y" : "x");
    }, t.prototype.getArea = function(r) {
      r = r || 0;
      var n = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), o = Math.min(n[0], n[1]) - r, a = Math.min(i[0], i[1]) - r, s = Math.max(n[0], n[1]) - o + r, l = Math.max(i[0], i[1]) - a + r;
      return new At(o, a, s, l);
    }, t;
  }(STe)
), bTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i, o, a) {
      var s = e.call(this, r, n, i) || this;
      return s.index = 0, s.type = o || "value", s.position = a || "bottom", s;
    }
    return t.prototype.isHorizontal = function() {
      var r = this.position;
      return r === "top" || r === "bottom";
    }, t.prototype.getGlobalExtent = function(r) {
      var n = this.getExtent();
      return n[0] = this.toGlobalCoord(n[0]), n[1] = this.toGlobalCoord(n[1]), r && n[0] > n[1] && n.reverse(), n;
    }, t.prototype.pointToData = function(r, n) {
      return this.coordToData(this.toLocalCoord(r[this.dim === "x" ? 0 : 1]), n);
    }, t.prototype.setCategorySortInfo = function(r) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = r, this.scale.setSortInfo(r);
    }, t;
  }(sa)
);
function gT(e, t, r) {
  r = r || {};
  var n = e.coordinateSystem, i = t.axis, o = {}, a = i.getAxesOnZeroOf()[0], s = i.position, l = a ? "onZero" : s, u = i.dim, c = n.getRect(), d = [c.x, c.x + c.width, c.y, c.y + c.height], h = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, f = t.get("offset") || 0, p = u === "x" ? [d[2] - f, d[3] + f] : [d[0] - f, d[1] + f];
  if (a) {
    var g = a.toGlobalCoord(a.dataToCoord(0));
    p[h.onZero] = Math.max(Math.min(g, p[1]), p[0]);
  }
  o.position = [u === "y" ? p[h[l]] : d[0], u === "x" ? p[h[l]] : d[3]], o.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  o.labelDirection = o.tickDirection = o.nameDirection = v[s], o.labelOffset = a ? p[h[s]] - p[h.onZero] : 0, t.get(["axisTick", "inside"]) && (o.tickDirection = -o.tickDirection), vn(r.labelInside, t.get(["axisLabel", "inside"])) && (o.labelDirection = -o.labelDirection);
  var m = t.get(["axisLabel", "rotate"]);
  return o.labelRotate = l === "top" ? -m : m, o.z2 = 1, o;
}
function UV(e) {
  return e.get("coordinateSystem") === "cartesian2d";
}
function KV(e) {
  var t = {
    xAxisModel: null,
    yAxisModel: null
  };
  return $(t, function(r, n) {
    var i = n.replace(/Model$/, ""), o = e.getReferringComponents(i, bn).models[0];
    if (process.env.NODE_ENV !== "production" && !o)
      throw new Error(i + ' "' + So(e.get(i + "Index"), e.get(i + "Id"), 0) + '" not found');
    t[n] = o;
  }), t;
}
var ux = Math.log;
function oU(e, t, r) {
  var n = rl.prototype, i = n.getTicks.call(r), o = n.getTicks.call(r, !0), a = i.length - 1, s = n.getInterval.call(r), l = lj(e, t), u = l.extent, c = l.fixMin, d = l.fixMax;
  if (e.type === "log") {
    var h = ux(e.base);
    u = [ux(u[0]) / h, ux(u[1]) / h];
  }
  e.setExtent(u[0], u[1]), e.calcNiceExtent({
    splitNumber: a,
    fixMin: c,
    fixMax: d
  });
  var f = n.getExtent.call(e);
  c && (u[0] = f[0]), d && (u[1] = f[1]);
  var p = n.getInterval.call(e), g = u[0], v = u[1];
  if (c && d)
    p = (v - g) / a;
  else if (c)
    for (v = u[0] + p * a; v < u[1] && isFinite(v) && isFinite(u[1]); )
      p = Y1(p), v = u[0] + p * a;
  else if (d)
    for (g = u[1] - p * a; g > u[0] && isFinite(g) && isFinite(u[0]); )
      p = Y1(p), g = u[1] - p * a;
  else {
    var m = e.getTicks().length - 1;
    m > a && (p = Y1(p));
    var y = p * a;
    v = Math.ceil(u[1] / p) * p, g = an(v - y), g < 0 && u[0] >= 0 ? (g = 0, v = an(y)) : v > 0 && u[1] <= 0 && (v = 0, g = -an(y));
  }
  var C = (i[0].value - o[0].value) / s, S = (i[a].value - o[a].value) / s;
  if (n.setExtent.call(e, g + p * C, v + p * S), n.setInterval.call(e, p), (C || S) && n.setNiceExtent.call(e, g + p, v - p), process.env.NODE_ENV !== "production") {
    var b = n.getTicks.call(e);
    b[1] && (!yEe(p) || aC(b[1].value) > aC(p)) && nn(
      // eslint-disable-next-line
      "The ticks may be not readable when set min: " + t.get("min") + ", max: " + t.get("max") + " and alignTicks: true"
    );
  }
}
var xTe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = pT, this._initCartesian(t, r, n), this.model = t;
    }
    return e.prototype.getRect = function() {
      return this._rect;
    }, e.prototype.update = function(t, r) {
      var n = this._axesMap;
      this._updateScale(t, this.model);
      function i(a) {
        var s, l = jt(a), u = l.length;
        if (u) {
          for (var c = [], d = u - 1; d >= 0; d--) {
            var h = +l[d], f = a[h], p = f.model, g = f.scale;
            // Only value and log axis without interval support alignTicks.
            aT(g) && p.get("alignTicks") && p.get("interval") == null ? c.push(f) : (Kc(g, p), aT(g) && (s = f));
          }
          c.length && (s || (s = c.pop(), Kc(s.scale, s.model)), $(c, function(v) {
            oU(v.scale, v.model, s.scale);
          }));
        }
      }
      i(n.x), i(n.y);
      var o = {};
      $(n.x, function(a) {
        YV(n, "y", a, o);
      }), $(n.y, function(a) {
        YV(n, "x", a, o);
      }), this.resize(this.model, r);
    }, e.prototype.resize = function(t, r, n) {
      var i = t.getBoxLayoutParams(), o = !n && t.get("containLabel"), a = En(i, {
        width: r.getWidth(),
        height: r.getHeight()
      });
      this._rect = a;
      var s = this._axesList;
      l(), o && ($(s, function(u) {
        if (!u.model.get(["axisLabel", "inside"])) {
          var c = GEe(u);
          if (c) {
            var d = u.isHorizontal() ? "height" : "width", h = u.model.get(["axisLabel", "margin"]);
            a[d] -= c[d] + h, u.position === "top" ? a.y += c.height + h : u.position === "left" && (a.x += c.width + h);
          }
        }
      }), l()), $(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        $(s, function(u) {
          var c = u.isHorizontal(), d = c ? [0, a.width] : [0, a.height], h = u.inverse ? 1 : 0;
          u.setExtent(d[h], d[1 - h]), ETe(u, c ? a.x : a.y);
        });
      }
    }, e.prototype.getAxis = function(t, r) {
      var n = this._axesMap[t];
      if (n != null)
        return n[r || 0];
    }, e.prototype.getAxes = function() {
      return this._axesList.slice();
    }, e.prototype.getCartesian = function(t, r) {
      if (t != null && r != null) {
        var n = "x" + t + "y" + r;
        return this._coordsMap[n];
      }
      lt(t) && (r = t.yAxisIndex, t = t.xAxisIndex);
      for (var i = 0, o = this._coordsList; i < o.length; i++)
        if (o[i].getAxis("x").index === t || o[i].getAxis("y").index === r)
          return o[i];
    }, e.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, e.prototype.convertToPixel = function(t, r, n) {
      var i = this._findConvertTarget(r);
      return i.cartesian ? i.cartesian.dataToPoint(n) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(n)) : null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      var i = this._findConvertTarget(r);
      return i.cartesian ? i.cartesian.pointToData(n) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(n)) : null;
    }, e.prototype._findConvertTarget = function(t) {
      var r = t.seriesModel, n = t.xAxisModel || r && r.getReferringComponents("xAxis", bn).models[0], i = t.yAxisModel || r && r.getReferringComponents("yAxis", bn).models[0], o = t.gridModel, a = this._coordsList, s, l;
      if (r)
        s = r.coordinateSystem, Ft(a, s) < 0 && (s = null);
      else if (n && i)
        s = this.getCartesian(n.componentIndex, i.componentIndex);
      else if (n)
        l = this.getAxis("x", n.componentIndex);
      else if (i)
        l = this.getAxis("y", i.componentIndex);
      else if (o) {
        var u = o.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, e.prototype.containPoint = function(t) {
      var r = this._coordsList[0];
      if (r)
        return r.containPoint(t);
    }, e.prototype._initCartesian = function(t, r, n) {
      var i = this, o = this, a = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (r.eachComponent("xAxis", u("x"), this), r.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, $(s.x, function(c, d) {
        $(s.y, function(h, f) {
          var p = "x" + d + "y" + f, g = new wTe(p);
          g.master = i, g.model = t, i._coordsMap[p] = g, i._coordsList.push(g), g.addAxis(c), g.addAxis(h);
        });
      });
      function u(c) {
        return function(d, h) {
          if (cx(d, t)) {
            var f = d.get("position");
            c === "x" ? f !== "top" && f !== "bottom" && (f = a.bottom ? "top" : "bottom") : f !== "left" && f !== "right" && (f = a.left ? "right" : "left"), a[f] = !0;
            var p = new bTe(c, Wv(d), [0, 0], d.get("type"), f), g = p.type === "category";
            p.onBand = g && d.get("boundaryGap"), p.inverse = d.get("inverse"), d.axis = p, p.model = d, p.grid = o, p.index = h, o._axesList.push(p), s[c][h] = p, l[c]++;
          }
        };
      }
    }, e.prototype._updateScale = function(t, r) {
      $(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var o = i.model.get("categorySortInfo");
          i.scale.setSortInfo(o);
        }
      }), t.eachSeries(function(i) {
        if (UV(i)) {
          var o = KV(i), a = o.xAxisModel, s = o.yAxisModel;
          if (!cx(a, r) || !cx(s, r))
            return;
          var l = this.getCartesian(a.componentIndex, s.componentIndex), u = i.getData(), c = l.getAxis("x"), d = l.getAxis("y");
          n(u, c), n(u, d);
        }
      }, this);
      function n(i, o) {
        $(TC(i, o.dim), function(a) {
          o.scale.unionExtentFromData(i, a);
        });
      }
    }, e.prototype.getTooltipAxes = function(t) {
      var r = [], n = [];
      return $(this.getCartesians(), function(i) {
        var o = t != null && t !== "auto" ? i.getAxis(t) : i.getBaseAxis(), a = i.getOtherAxis(o);
        Ft(r, o) < 0 && r.push(o), Ft(n, a) < 0 && n.push(a);
      }), {
        baseAxes: r,
        otherAxes: n
      };
    }, e.create = function(t, r) {
      var n = [];
      return t.eachComponent("grid", function(i, o) {
        var a = new e(i, t, r);
        a.name = "grid_" + o, a.resize(i, r, !0), i.coordinateSystem = a, n.push(a);
      }), t.eachSeries(function(i) {
        if (UV(i)) {
          var o = KV(i), a = o.xAxisModel, s = o.yAxisModel, l = a.getCoordSysModel();
          if (process.env.NODE_ENV !== "production") {
            if (!l)
              throw new Error('Grid "' + So(a.get("gridIndex"), a.get("gridId"), 0) + '" not found');
            if (a.getCoordSysModel() !== s.getCoordSysModel())
              throw new Error("xAxis and yAxis must use the same grid");
          }
          var u = l.coordinateSystem;
          i.coordinateSystem = u.getCartesian(a.componentIndex, s.componentIndex);
        }
      }), n;
    }, e.dimensions = pT, e;
  }()
);
function cx(e, t) {
  return e.getCoordSysModel() === t;
}
function YV(e, t, r, n) {
  r.getAxesOnZeroOf = function() {
    return o ? [o] : [];
  };
  var i = e[t], o, a = r.model, s = a.get(["axisLine", "onZero"]), l = a.get(["axisLine", "onZeroAxisIndex"]);
  if (!s)
    return;
  if (l != null)
    qV(i[l]) && (o = i[l]);
  else
    for (var u in i)
      if (i.hasOwnProperty(u) && qV(i[u]) && !n[c(i[u])]) {
        o = i[u];
        break;
      }
  o && (n[c(o)] = !0);
  function c(d) {
    return d.dim + "_" + d.index;
  }
}
function qV(e) {
  return e && e.type !== "category" && e.type !== "time" && HEe(e);
}
function ETe(e, t) {
  var r = e.getExtent(), n = r[0] + r[1];
  e.toGlobalCoord = e.dim === "x" ? function(i) {
    return i + t;
  } : function(i) {
    return n - i + t;
  }, e.toLocalCoord = e.dim === "x" ? function(i) {
    return i - t;
  } : function(i) {
    return n - i + t;
  };
}
var kl = Math.PI, Mi = (
  /** @class */
  function() {
    function e(t, r) {
      this.group = new Ct(), this.opt = r, this.axisModel = t, ut(r, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0,
        handleAutoShown: function() {
          return !0;
        }
      });
      var n = new Ct({
        x: r.position[0],
        y: r.position[1],
        rotation: r.rotation
      });
      n.updateTransform(), this._transformGroup = n;
    }
    return e.prototype.hasBuilder = function(t) {
      return !!XV[t];
    }, e.prototype.add = function(t) {
      XV[t](this.opt, this.axisModel, this.group, this._transformGroup);
    }, e.prototype.getGroup = function() {
      return this.group;
    }, e.innerTextLayout = function(t, r, n) {
      var i = UM(r - t), o, a;
      return zh(i) ? (a = n > 0 ? "top" : "bottom", o = "center") : zh(i - kl) ? (a = n > 0 ? "bottom" : "top", o = "center") : (a = "middle", i > 0 && i < kl ? o = n > 0 ? "right" : "left" : o = n > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: o,
        textVerticalAlign: a
      };
    }, e.makeAxisEventDataBase = function(t) {
      var r = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return r[t.mainType + "Index"] = t.componentIndex, r;
    }, e.isLabelSilent = function(t) {
      var r = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || r && r.show);
    }, e;
  }()
), XV = {
  axisLine: function(e, t, r, n) {
    var i = t.get(["axisLine", "show"]);
    if (i === "auto" && e.handleAutoShown && (i = e.handleAutoShown("axisLine")), !!i) {
      var o = t.axis.getExtent(), a = n.transform, s = [o[0], 0], l = [o[1], 0], u = s[0] > l[0];
      a && (Un(s, s, a), Un(l, l, a));
      var c = ge({
        lineCap: "round"
      }, t.getModel(["axisLine", "lineStyle"]).getLineStyle()), d = new Nn({
        shape: {
          x1: s[0],
          y1: s[1],
          x2: l[0],
          y2: l[1]
        },
        style: c,
        strokeContainThreshold: e.strokeContainThreshold || 5,
        silent: !0,
        z2: 1
      });
      Uh(d.shape, d.style.lineWidth), d.anid = "line", r.add(d);
      var h = t.get(["axisLine", "symbol"]);
      if (h != null) {
        var f = t.get(["axisLine", "symbolSize"]);
        He(h) && (h = [h, h]), (He(f) || sr(f)) && (f = [f, f]);
        var p = ud(t.get(["axisLine", "symbolOffset"]) || 0, f), g = f[0], v = f[1];
        $([{
          rotate: e.rotation + Math.PI / 2,
          offset: p[0],
          r: 0
        }, {
          rotate: e.rotation - Math.PI / 2,
          offset: p[1],
          r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
        }], function(m, y) {
          if (h[y] !== "none" && h[y] != null) {
            var C = mn(h[y], -g / 2, -v / 2, g, v, c.stroke, !0), S = m.r + m.offset, b = u ? l : s;
            C.attr({
              rotation: m.rotate,
              x: b[0] + S * Math.cos(e.rotation),
              y: b[1] - S * Math.sin(e.rotation),
              silent: !0,
              z2: 11
            }), r.add(C);
          }
        });
      }
    }
  },
  axisTickLabel: function(e, t, r, n) {
    var i = TTe(r, n, t, e), o = MTe(r, n, t, e);
    if (_Te(t, o, i), PTe(r, n, t, e.tickDirection), t.get(["axisLabel", "hideOverlap"])) {
      var a = bj(Ee(o, function(s) {
        return {
          label: s,
          priority: s.z2,
          defaultAttr: {
            ignore: s.ignore
          }
        };
      }));
      Rj(a);
    }
  },
  axisName: function(e, t, r, n) {
    var i = vn(e.axisName, t.get("name"));
    if (i) {
      var o = t.get("nameLocation"), a = e.nameDirection, s = t.getModel("nameTextStyle"), l = t.get("nameGap") || 0, u = t.axis.getExtent(), c = u[0] > u[1] ? -1 : 1, d = [
        o === "start" ? u[0] - c * l : o === "end" ? u[1] + c * l : (u[0] + u[1]) / 2,
        // Reuse labelOffset.
        QV(o) ? e.labelOffset + a * l : 0
      ], h, f = t.get("nameRotate");
      f != null && (f = f * kl / 180);
      var p;
      QV(o) ? h = Mi.innerTextLayout(
        e.rotation,
        f ?? e.rotation,
        // Adapt to axis.
        a
      ) : (h = RTe(e.rotation, o, f || 0, u), p = e.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(h.rotation)), !isFinite(p) && (p = null)));
      var g = s.getFont(), v = t.get("nameTruncate", !0) || {}, m = v.ellipsis, y = vn(e.nameTruncateMaxWidth, v.maxWidth, p), C = new ir({
        x: d[0],
        y: d[1],
        rotation: h.rotation,
        silent: Mi.isLabelSilent(t),
        style: Vr(s, {
          text: i,
          font: g,
          overflow: "truncate",
          width: y,
          ellipsis: m,
          fill: s.getTextColor() || t.get(["axisLine", "lineStyle", "color"]),
          align: s.get("align") || h.textAlign,
          verticalAlign: s.get("verticalAlign") || h.textVerticalAlign
        }),
        z2: 1
      });
      if (Cf({
        el: C,
        componentModel: t,
        itemName: i
      }), C.__fullText = i, C.anid = "name", t.get("triggerEvent")) {
        var S = Mi.makeAxisEventDataBase(t);
        S.targetType = "axisName", S.name = i, St(C).eventData = S;
      }
      n.add(C), C.updateTransform(), r.add(C), C.decomposeTransform();
    }
  }
};
function RTe(e, t, r, n) {
  var i = UM(r - e), o, a, s = n[0] > n[1], l = t === "start" && !s || t !== "start" && s;
  return zh(i - kl / 2) ? (a = l ? "bottom" : "top", o = "center") : zh(i - kl * 1.5) ? (a = l ? "top" : "bottom", o = "center") : (a = "middle", i < kl * 1.5 && i > kl / 2 ? o = l ? "left" : "right" : o = l ? "right" : "left"), {
    rotation: i,
    textAlign: o,
    textVerticalAlign: a
  };
}
function _Te(e, t, r) {
  if (!uj(e.axis)) {
    var n = e.get(["axisLabel", "showMinLabel"]), i = e.get(["axisLabel", "showMaxLabel"]);
    t = t || [], r = r || [];
    var o = t[0], a = t[1], s = t[t.length - 1], l = t[t.length - 2], u = r[0], c = r[1], d = r[r.length - 1], h = r[r.length - 2];
    n === !1 ? (Ao(o), Ao(u)) : ZV(o, a) && (n ? (Ao(a), Ao(c)) : (Ao(o), Ao(u))), i === !1 ? (Ao(s), Ao(d)) : ZV(l, s) && (i ? (Ao(l), Ao(h)) : (Ao(s), Ao(d)));
  }
}
function Ao(e) {
  e && (e.ignore = !0);
}
function ZV(e, t) {
  var r = e && e.getBoundingRect().clone(), n = t && t.getBoundingRect().clone();
  if (!(!r || !n)) {
    var i = Iv([]);
    return Cu(i, i, -e.rotation), r.applyTransform(us([], i, e.getLocalTransform())), n.applyTransform(us([], i, t.getLocalTransform())), r.intersect(n);
  }
}
function QV(e) {
  return e === "middle" || e === "center";
}
function aU(e, t, r, n, i) {
  for (var o = [], a = [], s = [], l = 0; l < e.length; l++) {
    var u = e[l].coord;
    a[0] = u, a[1] = 0, s[0] = u, s[1] = r, t && (Un(a, a, t), Un(s, s, t));
    var c = new Nn({
      shape: {
        x1: a[0],
        y1: a[1],
        x2: s[0],
        y2: s[1]
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    Uh(c.shape, c.style.lineWidth), c.anid = i + "_" + e[l].tickValue, o.push(c);
  }
  return o;
}
function TTe(e, t, r, n) {
  var i = r.axis, o = r.getModel("axisTick"), a = o.get("show");
  if (a === "auto" && n.handleAutoShown && (a = n.handleAutoShown("axisTick")), !(!a || i.scale.isBlank())) {
    for (var s = o.getModel("lineStyle"), l = n.tickDirection * o.get("length"), u = i.getTicksCoords(), c = aU(u, t.transform, l, ut(s.getLineStyle(), {
      stroke: r.get(["axisLine", "lineStyle", "color"])
    }), "ticks"), d = 0; d < c.length; d++)
      e.add(c[d]);
    return c;
  }
}
function PTe(e, t, r, n) {
  var i = r.axis, o = r.getModel("minorTick");
  if (!(!o.get("show") || i.scale.isBlank())) {
    var a = i.getMinorTicksCoords();
    if (a.length)
      for (var s = o.getModel("lineStyle"), l = n * o.get("length"), u = ut(s.getLineStyle(), ut(r.getModel("axisTick").getLineStyle(), {
        stroke: r.get(["axisLine", "lineStyle", "color"])
      })), c = 0; c < a.length; c++)
        for (var d = aU(a[c], t.transform, l, u, "minorticks_" + c), h = 0; h < d.length; h++)
          e.add(d[h]);
  }
}
function MTe(e, t, r, n) {
  var i = r.axis, o = vn(n.axisLabelShow, r.get(["axisLabel", "show"]));
  if (!(!o || i.scale.isBlank())) {
    var a = r.getModel("axisLabel"), s = a.get("margin"), l = i.getViewLabels(), u = (vn(n.labelRotate, a.get("rotate")) || 0) * kl / 180, c = Mi.innerTextLayout(n.rotation, u, n.labelDirection), d = r.getCategories && r.getCategories(!0), h = [], f = Mi.isLabelSilent(r), p = r.get("triggerEvent");
    return $(l, function(g, v) {
      var m = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(g.tickValue) : g.tickValue, y = g.formattedLabel, C = g.rawLabel, S = a;
      if (d && d[m]) {
        var b = d[m];
        lt(b) && b.textStyle && (S = new _r(b.textStyle, a, r.ecModel));
      }
      var w = S.getTextColor() || r.get(["axisLine", "lineStyle", "color"]), x = i.dataToCoord(m), R = S.getShallow("align", !0) || c.textAlign, _ = bt(S.getShallow("alignMinLabel", !0), R), T = bt(S.getShallow("alignMaxLabel", !0), R), P = S.getShallow("verticalAlign", !0) || S.getShallow("baseline", !0) || c.textVerticalAlign, D = bt(S.getShallow("verticalAlignMinLabel", !0), P), O = bt(S.getShallow("verticalAlignMaxLabel", !0), P), A = new ir({
        x,
        y: n.labelOffset + n.labelDirection * s,
        rotation: c.rotation,
        silent: f,
        z2: 10 + (g.level || 0),
        style: Vr(S, {
          text: y,
          align: v === 0 ? _ : v === l.length - 1 ? T : R,
          verticalAlign: v === 0 ? D : v === l.length - 1 ? O : P,
          fill: at(w) ? w(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            i.type === "category" ? C : i.type === "value" ? m + "" : m,
            v
          ) : w
        })
      });
      if (A.anid = "label_" + m, p) {
        var F = Mi.makeAxisEventDataBase(r);
        F.targetType = "axisLabel", F.value = C, F.tickIndex = v, i.type === "category" && (F.dataIndex = m), St(A).eventData = F;
      }
      t.add(A), A.updateTransform(), h.push(A), e.add(A), A.decomposeTransform();
    }), h;
  }
}
function DTe(e, t) {
  var r = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return ATe(r, e, t), r.seriesInvolved && OTe(r, e), r;
}
function ATe(e, t, r) {
  var n = t.getComponent("tooltip"), i = t.getComponent("axisPointer"), o = i.get("link", !0) || [], a = [];
  $(r.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = nv(s.model), u = e.coordSysAxesInfo[l] = {};
    e.coordSysMap[l] = s;
    var c = s.model, d = c.getModel("tooltip", n);
    if ($(s.getAxes(), _t(g, !1, null)), s.getTooltipAxes && n && d.get("show")) {
      var h = d.get("trigger") === "axis", f = d.get(["axisPointer", "type"]) === "cross", p = s.getTooltipAxes(d.get(["axisPointer", "axis"]));
      (h || f) && $(p.baseAxes, _t(g, f ? "cross" : !0, h)), f && $(p.otherAxes, _t(g, "cross", !1));
    }
    function g(v, m, y) {
      var C = y.model.getModel("axisPointer", i), S = C.get("show");
      if (!(!S || S === "auto" && !v && !vT(C))) {
        m == null && (m = C.get("triggerTooltip")), C = v ? ITe(y, d, i, t, v, m) : C;
        var b = C.get("snap"), w = C.get("triggerEmphasis"), x = nv(y.model), R = m || b || y.type === "category", _ = e.axesInfo[x] = {
          key: x,
          axis: y,
          coordSys: s,
          axisPointerModel: C,
          triggerTooltip: m,
          triggerEmphasis: w,
          involveSeries: R,
          snap: b,
          useHandle: vT(C),
          seriesModels: [],
          linkGroup: null
        };
        u[x] = _, e.seriesInvolved = e.seriesInvolved || R;
        var T = LTe(o, y);
        if (T != null) {
          var P = a[T] || (a[T] = {
            axesInfo: {}
          });
          P.axesInfo[x] = _, P.mapper = o[T].mapper, _.linkGroup = P;
        }
      }
    }
  });
}
function ITe(e, t, r, n, i, o) {
  var a = t.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  $(s, function(h) {
    l[h] = dt(a.get(h));
  }), l.snap = e.type !== "category" && !!o, a.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), i === "cross") {
    var c = a.get(["label", "show"]);
    if (u.show = c ?? !0, !o) {
      var d = l.lineStyle = a.get("crossStyle");
      d && ut(u, d.textStyle);
    }
  }
  return e.model.getModel("axisPointer", new _r(l, r, n));
}
function OTe(e, t) {
  t.eachSeries(function(r) {
    var n = r.coordinateSystem, i = r.get(["tooltip", "trigger"], !0), o = r.get(["tooltip", "show"], !0);
    !n || i === "none" || i === !1 || i === "item" || o === !1 || r.get(["axisPointer", "show"], !0) === !1 || $(e.coordSysAxesInfo[nv(n.model)], function(a) {
      var s = a.axis;
      n.getAxis(s.dim) === s && (a.seriesModels.push(r), a.seriesDataCount == null && (a.seriesDataCount = 0), a.seriesDataCount += r.getData().count());
    });
  });
}
function LTe(e, t) {
  for (var r = t.model, n = t.dim, i = 0; i < e.length; i++) {
    var o = e[i] || {};
    if (dx(o[n + "AxisId"], r.id) || dx(o[n + "AxisIndex"], r.componentIndex) || dx(o[n + "AxisName"], r.name))
      return i;
  }
}
function dx(e, t) {
  return e === "all" || be(e) && Ft(e, t) >= 0 || e === t;
}
function FTe(e) {
  var t = nA(e);
  if (t) {
    var r = t.axisPointerModel, n = t.axis.scale, i = r.option, o = r.get("status"), a = r.get("value");
    a != null && (a = n.parse(a));
    var s = vT(r);
    o == null && (i.status = s ? "show" : "hide");
    var l = n.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (a == null || a > l[1]) && (a = l[1]), a < l[0] && (a = l[0]), i.value = a, s && (i.status = t.axis.scale.isBlank() ? "hide" : "show");
  }
}
function nA(e) {
  var t = (e.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return t && t.axesInfo[nv(e)];
}
function NTe(e) {
  var t = nA(e);
  return t && t.axisPointerModel;
}
function vT(e) {
  return !!e.get(["handle", "show"]);
}
function nv(e) {
  return e.type + "||" + e.id;
}
var hx = {}, dd = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this.axisPointerClass && FTe(r), e.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(r, i, !0);
    }, t.prototype.updateAxisPointer = function(r, n, i, o) {
      this._doUpdateAxisPointerClass(r, i, !1);
    }, t.prototype.remove = function(r, n) {
      var i = this._axisPointer;
      i && i.remove(n);
    }, t.prototype.dispose = function(r, n) {
      this._disposeAxisPointer(n), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(r, n, i) {
      var o = t.getAxisPointerClass(this.axisPointerClass);
      if (o) {
        var a = NTe(r);
        a ? (this._axisPointer || (this._axisPointer = new o())).render(r, a, n, i) : this._disposeAxisPointer(n);
      }
    }, t.prototype._disposeAxisPointer = function(r) {
      this._axisPointer && this._axisPointer.dispose(r), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(r, n) {
      if (process.env.NODE_ENV !== "production" && hx[r])
        throw new Error("axisPointer " + r + " exists");
      hx[r] = n;
    }, t.getAxisPointerClass = function(r) {
      return r && hx[r];
    }, t.type = "axis", t;
  }(zr)
), mT = ar();
function sU(e, t, r, n) {
  var i = r.axis;
  if (!i.scale.isBlank()) {
    var o = r.getModel("splitArea"), a = o.getModel("areaStyle"), s = a.get("color"), l = n.coordinateSystem.getRect(), u = i.getTicksCoords({
      tickModel: o,
      clamp: !0
    });
    if (u.length) {
      var c = s.length, d = mT(e).splitAreaColors, h = nt(), f = 0;
      if (d)
        for (var p = 0; p < u.length; p++) {
          var g = d.get(u[p].tickValue);
          if (g != null) {
            f = (g + (c - 1) * p) % c;
            break;
          }
        }
      var v = i.toGlobalCoord(u[0].coord), m = a.getAreaStyle();
      s = be(s) ? s : [s];
      for (var p = 1; p < u.length; p++) {
        var y = i.toGlobalCoord(u[p].coord), C = void 0, S = void 0, b = void 0, w = void 0;
        i.isHorizontal() ? (C = v, S = l.y, b = y - C, w = l.height, v = C + b) : (C = l.x, S = v, b = l.width, w = y - S, v = S + w);
        var x = u[p - 1].tickValue;
        x != null && h.set(x, f), t.add(new or({
          anid: x != null ? "area_" + x : null,
          shape: {
            x: C,
            y: S,
            width: b,
            height: w
          },
          style: ut({
            fill: s[f]
          }, m),
          autoBatch: !0,
          silent: !0
        })), f = (f + 1) % c;
      }
      mT(e).splitAreaColors = h;
    }
  }
}
function lU(e) {
  mT(e).splitAreaColors = null;
}
var kTe = ["axisLine", "axisTickLabel", "axisName"], VTe = ["splitArea", "splitLine", "minorSplitLine"], uU = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.axisPointerClass = "CartesianAxisPointer", r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this.group.removeAll();
      var a = this._axisGroup;
      if (this._axisGroup = new Ct(), this.group.add(this._axisGroup), !!r.get("show")) {
        var s = r.getCoordSysModel(), l = gT(s, r), u = new Mi(r, ge({
          handleAutoShown: function(d) {
            for (var h = s.coordinateSystem.getCartesians(), f = 0; f < h.length; f++)
              if (aT(h[f].getOtherAxis(r.axis).scale))
                return !0;
            return !1;
          }
        }, l));
        $(kTe, u.add, u), this._axisGroup.add(u.getGroup()), $(VTe, function(d) {
          r.get([d, "show"]) && BTe[d](this, this._axisGroup, r, s);
        }, this);
        var c = o && o.type === "changeAxisOrder" && o.isInitSort;
        c || Hv(a, this._axisGroup, r), e.prototype.render.call(this, r, n, i, o);
      }
    }, t.prototype.remove = function() {
      lU(this);
    }, t.type = "cartesianAxis", t;
  }(dd)
), BTe = {
  splitLine: function(e, t, r, n) {
    var i = r.axis;
    if (!i.scale.isBlank()) {
      var o = r.getModel("splitLine"), a = o.getModel("lineStyle"), s = a.get("color");
      s = be(s) ? s : [s];
      for (var l = n.coordinateSystem.getRect(), u = i.isHorizontal(), c = 0, d = i.getTicksCoords({
        tickModel: o
      }), h = [], f = [], p = a.getLineStyle(), g = 0; g < d.length; g++) {
        var v = i.toGlobalCoord(d[g].coord);
        u ? (h[0] = v, h[1] = l.y, f[0] = v, f[1] = l.y + l.height) : (h[0] = l.x, h[1] = v, f[0] = l.x + l.width, f[1] = v);
        var m = c++ % s.length, y = d[g].tickValue, C = new Nn({
          anid: y != null ? "line_" + d[g].tickValue : null,
          autoBatch: !0,
          shape: {
            x1: h[0],
            y1: h[1],
            x2: f[0],
            y2: f[1]
          },
          style: ut({
            stroke: s[m]
          }, p),
          silent: !0
        });
        Uh(C.shape, p.lineWidth), t.add(C);
      }
    }
  },
  minorSplitLine: function(e, t, r, n) {
    var i = r.axis, o = r.getModel("minorSplitLine"), a = o.getModel("lineStyle"), s = n.coordinateSystem.getRect(), l = i.isHorizontal(), u = i.getMinorTicksCoords();
    if (u.length)
      for (var c = [], d = [], h = a.getLineStyle(), f = 0; f < u.length; f++)
        for (var p = 0; p < u[f].length; p++) {
          var g = i.toGlobalCoord(u[f][p].coord);
          l ? (c[0] = g, c[1] = s.y, d[0] = g, d[1] = s.y + s.height) : (c[0] = s.x, c[1] = g, d[0] = s.x + s.width, d[1] = g);
          var v = new Nn({
            anid: "minor_line_" + u[f][p].tickValue,
            autoBatch: !0,
            shape: {
              x1: c[0],
              y1: c[1],
              x2: d[0],
              y2: d[1]
            },
            style: h,
            silent: !0
          });
          Uh(v.shape, h.lineWidth), t.add(v);
        }
  },
  splitArea: function(e, t, r, n) {
    sU(e, t, r, n);
  }
}, cU = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "xAxis", t;
  }(uU)
), $Te = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = cU.type, r;
    }
    return t.type = "yAxis", t;
  }(uU)
), HTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "grid", r;
    }
    return t.prototype.render = function(r, n) {
      this.group.removeAll(), r.get("show") && this.group.add(new or({
        shape: r.coordinateSystem.getRect(),
        style: ut({
          fill: r.get("backgroundColor")
        }, r.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, t.type = "grid", t;
  }(zr)
), JV = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function dU(e) {
  e.registerComponentView(HTe), e.registerComponentModel(gTe), e.registerCoordinateSystem("cartesian2d", xTe), Xh(e, "x", fT, JV), Xh(e, "y", fT, JV), e.registerComponentView(cU), e.registerComponentView($Te), e.registerPreprocessor(function(t) {
    t.xAxis && t.yAxis && !t.grid && (t.grid = {});
  });
}
function GTe(e) {
  Bt(dU), e.registerSeriesModel(cTe), e.registerChartView(pTe), e.registerLayout(Yv("scatter"));
}
function zTe(e) {
  e.eachSeriesByType("radar", function(t) {
    var r = t.getData(), n = [], i = t.coordinateSystem;
    if (i) {
      var o = i.getIndicatorAxes();
      $(o, function(a, s) {
        r.each(r.mapDimension(o[s].dim), function(l, u) {
          n[u] = n[u] || [];
          var c = i.dataToPoint(l, s);
          n[u][s] = eB(c) ? c : tB(i);
        });
      }), r.each(function(a) {
        var s = D6(n[a], function(l) {
          return eB(l);
        }) || tB(i);
        n[a].push(s.slice()), r.setItemLayout(a, n[a]);
      });
    }
  });
}
function eB(e) {
  return !isNaN(e[0]) && !isNaN(e[1]);
}
function tB(e) {
  return [e.cx, e.cy];
}
function WTe(e) {
  var t = e.polar;
  if (t) {
    be(t) || (t = [t]);
    var r = [];
    $(t, function(n, i) {
      n.indicator ? (n.type && !n.shape && (n.shape = n.type), e.radar = e.radar || [], be(e.radar) || (e.radar = [e.radar]), e.radar.push(n)) : r.push(n);
    }), e.polar = r;
  }
  $(e.series, function(n) {
    n && n.type === "radar" && n.polarIndex && (n.radarIndex = n.polarIndex);
  });
}
var jTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.coordinateSystem, a = this.group, s = r.getData(), l = this._data;
      function u(h, f) {
        var p = h.getItemVisual(f, "symbol") || "circle";
        if (p !== "none") {
          var g = _f(h.getItemVisual(f, "symbolSize")), v = mn(p, -1, -1, 2, 2), m = h.getItemVisual(f, "symbolRotate") || 0;
          return v.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: g[0] / 2,
            scaleY: g[1] / 2,
            rotation: m * Math.PI / 180 || 0
          }), v;
        }
      }
      function c(h, f, p, g, v, m) {
        p.removeAll();
        for (var y = 0; y < f.length - 1; y++) {
          var C = u(g, v);
          C && (C.__dimIdx = y, h[y] ? (C.setPosition(h[y]), od[m ? "initProps" : "updateProps"](C, {
            x: f[y][0],
            y: f[y][1]
          }, r, v)) : C.setPosition(f[y]), p.add(C));
        }
      }
      function d(h) {
        return Ee(h, function(f) {
          return [o.cx, o.cy];
        });
      }
      s.diff(l).add(function(h) {
        var f = s.getItemLayout(h);
        if (f) {
          var p = new Li(), g = new Ni(), v = {
            shape: {
              points: f
            }
          };
          p.shape.points = d(f), g.shape.points = d(f), jr(p, v, r, h), jr(g, v, r, h);
          var m = new Ct(), y = new Ct();
          m.add(g), m.add(p), m.add(y), c(g.shape.points, f, y, s, h, !0), s.setItemGraphicEl(h, m);
        }
      }).update(function(h, f) {
        var p = l.getItemGraphicEl(f), g = p.childAt(0), v = p.childAt(1), m = p.childAt(2), y = {
          shape: {
            points: s.getItemLayout(h)
          }
        };
        y.shape.points && (c(g.shape.points, y.shape.points, m, s, h, !1), Fa(v), Fa(g), ur(g, y, r), ur(v, y, r), s.setItemGraphicEl(h, p));
      }).remove(function(h) {
        a.remove(l.getItemGraphicEl(h));
      }).execute(), s.eachItemGraphicEl(function(h, f) {
        var p = s.getItemModel(f), g = h.childAt(0), v = h.childAt(1), m = h.childAt(2), y = s.getItemVisual(f, "style"), C = y.fill;
        a.add(h), g.useStyle(ut(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: C
        })), ti(g, p, "lineStyle"), ti(v, p, "areaStyle");
        var S = p.getModel("areaStyle"), b = S.isEmpty() && S.parentModel.isEmpty();
        v.ignore = b, $(["emphasis", "select", "blur"], function(R) {
          var _ = p.getModel([R, "areaStyle"]), T = _.isEmpty() && _.parentModel.isEmpty();
          v.ensureState(R).ignore = T && b;
        }), v.useStyle(ut(S.getAreaStyle(), {
          fill: C,
          opacity: 0.7,
          decal: y.decal
        }));
        var w = p.getModel("emphasis"), x = w.getModel("itemStyle").getItemStyle();
        m.eachChild(function(R) {
          if (R instanceof qn) {
            var _ = R.style;
            R.useStyle(ge({
              // TODO other properties like x, y ?
              image: _.image,
              x: _.x,
              y: _.y,
              width: _.width,
              height: _.height
            }, y));
          } else
            R.useStyle(y), R.setColor(C), R.style.strokeNoScale = !0;
          var T = R.ensureState("emphasis");
          T.style = dt(x);
          var P = s.getStore().get(s.getDimensionIndex(R.__dimIdx), f);
          (P == null || isNaN(P)) && (P = ""), ri(R, $n(p), {
            labelFetcher: s.hostModel,
            labelDataIndex: f,
            labelDimIndex: R.__dimIdx,
            defaultText: P,
            inheritColor: C,
            defaultOpacity: y.opacity
          });
        }), sn(h, w.get("focus"), w.get("blurScope"), w.get("disabled"));
      }), this._data = s;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "radar", t;
  }(br)
), UTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments), this.legendVisualProvider = new Xv(je(this.getData, this), je(this.getRawData, this));
    }, t.prototype.getInitialData = function(r, n) {
      return Df(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = this.coordinateSystem, s = a.getIndicatorAxes(), l = this.getData().getName(r), u = l === "" ? this.name : l, c = l9(this, r);
      return Hn("section", {
        header: u,
        sortBlocks: !0,
        blocks: Ee(s, function(d) {
          var h = o.get(o.mapDimension(d.dim), r);
          return Hn("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: d.name,
            value: h,
            sortParam: h
          });
        })
      });
    }, t.prototype.getTooltipPosition = function(r) {
      if (r != null) {
        for (var n = this.getData(), i = this.coordinateSystem, o = n.getValues(Ee(i.dimensions, function(u) {
          return n.mapDimension(u);
        }), r), a = 0, s = o.length; a < s; a++)
          if (!isNaN(o[a])) {
            var l = i.getIndicatorAxes();
            return i.coordToPoint(l[a].dataToCoord(o[a]), a);
          }
      }
    }, t.type = "series.radar", t.dependencies = ["radar"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, t;
  }(Pr)
), pp = iU.value;
function vy(e, t) {
  return ut({
    show: t
  }, e);
}
var KTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.optionUpdated = function() {
      var r = this.get("boundaryGap"), n = this.get("splitNumber"), i = this.get("scale"), o = this.get("axisLine"), a = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), c = this.get(["axisName", "formatter"]), d = this.get("axisNameGap"), h = this.get("triggerEvent"), f = Ee(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var g = l;
        p.color != null && (g = ut({
          color: p.color
        }, l));
        var v = Mt(dt(p), {
          boundaryGap: r,
          splitNumber: n,
          scale: i,
          axisLine: o,
          axisTick: a,
          // axisType: axisType,
          axisLabel: s,
          // Compatible with 2 and use text
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: d,
          // min: 0,
          nameTextStyle: g,
          triggerEvent: h
        }, !1);
        if (He(c)) {
          var m = v.name;
          v.name = c.replace("{value}", m ?? "");
        } else at(c) && (v.name = c(v.name, v));
        var y = new _r(v, null, this.ecModel);
        return cn(y, Mf.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = f;
    }, t.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, t.type = "radar", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: !0
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: Mt({
        lineStyle: {
          color: "#bbb"
        }
      }, pp.axisLine),
      axisLabel: vy(pp.axisLabel, !1),
      axisTick: vy(pp.axisTick, !1),
      // axisType: 'value',
      splitLine: vy(pp.splitLine, !0),
      splitArea: vy(pp.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, t;
  }(Vt)
), YTe = ["axisLine", "axisTickLabel", "axisName"], qTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = this.group;
      o.removeAll(), this._buildAxes(r), this._buildSplitLineAndArea(r);
    }, t.prototype._buildAxes = function(r) {
      var n = r.coordinateSystem, i = n.getIndicatorAxes(), o = Ee(i, function(a) {
        var s = a.model.get("showName") ? a.name : "", l = new Mi(a.model, {
          axisName: s,
          position: [n.cx, n.cy],
          rotation: a.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      $(o, function(a) {
        $(YTe, a.add, a), this.group.add(a.getGroup());
      }, this);
    }, t.prototype._buildSplitLineAndArea = function(r) {
      var n = r.coordinateSystem, i = n.getIndicatorAxes();
      if (!i.length)
        return;
      var o = r.get("shape"), a = r.getModel("splitLine"), s = r.getModel("splitArea"), l = a.getModel("lineStyle"), u = s.getModel("areaStyle"), c = a.get("show"), d = s.get("show"), h = l.get("color"), f = u.get("color"), p = be(h) ? h : [h], g = be(f) ? f : [f], v = [], m = [];
      function y(F, L, N) {
        var I = N % L.length;
        return F[I] = F[I] || [], I;
      }
      if (o === "circle")
        for (var C = i[0].getTicksCoords(), S = n.cx, b = n.cy, w = 0; w < C.length; w++) {
          if (c) {
            var x = y(v, p, w);
            v[x].push(new ul({
              shape: {
                cx: S,
                cy: b,
                r: C[w].coord
              }
            }));
          }
          if (d && w < C.length - 1) {
            var x = y(m, g, w);
            m[x].push(new Vv({
              shape: {
                cx: S,
                cy: b,
                r0: C[w].coord,
                r: C[w + 1].coord
              }
            }));
          }
        }
      else
        for (var R, _ = Ee(i, function(F, L) {
          var N = F.getTicksCoords();
          return R = R == null ? N.length - 1 : Math.min(N.length - 1, R), Ee(N, function(I) {
            return n.coordToPoint(I.coord, L);
          });
        }), T = [], w = 0; w <= R; w++) {
          for (var P = [], D = 0; D < i.length; D++)
            P.push(_[D][w]);
          if (P[0] ? P.push(P[0].slice()) : process.env.NODE_ENV !== "production" && console.error("Can't draw value axis " + w), c) {
            var x = y(v, p, w);
            v[x].push(new Ni({
              shape: {
                points: P
              }
            }));
          }
          if (d && T) {
            var x = y(m, g, w - 1);
            m[x].push(new Li({
              shape: {
                points: P.concat(T)
              }
            }));
          }
          T = P.slice().reverse();
        }
      var O = l.getLineStyle(), A = u.getAreaStyle();
      $(m, function(F, L) {
        this.group.add(fo(F, {
          style: ut({
            stroke: "none",
            fill: g[L % g.length]
          }, A),
          silent: !0
        }));
      }, this), $(v, function(F, L) {
        this.group.add(fo(F, {
          style: ut({
            fill: "none",
            stroke: p[L % p.length]
          }, O),
          silent: !0
        }));
      }, this);
    }, t.type = "radar", t;
  }(zr)
), XTe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i) {
      var o = e.call(this, r, n, i) || this;
      return o.type = "value", o.angle = 0, o.name = "", o;
    }
    return t;
  }(sa)
), ZTe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.dimensions = [], this._model = t, this._indicatorAxes = Ee(t.getIndicatorModels(), function(i, o) {
        var a = "indicator_" + o, s = new XTe(
          a,
          new rl()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return s.name = i.get("name"), s.model = i, i.axis = s, this.dimensions.push(a), s;
      }, this), this.resize(t, n);
    }
    return e.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, e.prototype.dataToPoint = function(t, r) {
      var n = this._indicatorAxes[r];
      return this.coordToPoint(n.dataToCoord(t), r);
    }, e.prototype.coordToPoint = function(t, r) {
      var n = this._indicatorAxes[r], i = n.angle, o = this.cx + t * Math.cos(i), a = this.cy - t * Math.sin(i);
      return [o, a];
    }, e.prototype.pointToData = function(t) {
      var r = t[0] - this.cx, n = t[1] - this.cy, i = Math.sqrt(r * r + n * n);
      r /= i, n /= i;
      for (var o = Math.atan2(-n, r), a = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], d = Math.abs(o - c.angle);
        d < a && (s = c, l = u, a = d);
      }
      return [l, +(s && s.coordToData(i))];
    }, e.prototype.resize = function(t, r) {
      var n = t.get("center"), i = r.getWidth(), o = r.getHeight(), a = Math.min(i, o) / 2;
      this.cx = Be(n[0], i), this.cy = Be(n[1], o), this.startAngle = t.get("startAngle") * Math.PI / 180;
      var s = t.get("radius");
      (He(s) || sr(s)) && (s = [0, s]), this.r0 = Be(s[0], a), this.r = Be(s[1], a), $(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var c = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        c = Math.atan2(Math.sin(c), Math.cos(c)), l.angle = c;
      }, this);
    }, e.prototype.update = function(t, r) {
      var n = this._indicatorAxes, i = this._model;
      $(n, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), t.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || t.getComponent("radar", s.get("radarIndex")) !== i)) {
          var u = s.getData();
          $(n, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var o = i.get("splitNumber"), a = new rl();
      a.setExtent(0, o), a.setInterval(1), $(n, function(s, l) {
        oU(s.scale, s.model, a);
      });
    }, e.prototype.convertToPixel = function(t, r, n) {
      return console.warn("Not implemented."), null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      return console.warn("Not implemented."), null;
    }, e.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), !1;
    }, e.create = function(t, r) {
      var n = [];
      return t.eachComponent("radar", function(i) {
        var o = new e(i, t, r);
        n.push(o), i.coordinateSystem = o;
      }), t.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = n[i.get("radarIndex") || 0]);
      }), n;
    }, e.dimensions = [], e;
  }()
);
function QTe(e) {
  e.registerCoordinateSystem("radar", ZTe), e.registerComponentModel(KTe), e.registerComponentView(qTe), e.registerVisual({
    seriesType: "radar",
    reset: function(t) {
      var r = t.getData();
      r.each(function(n) {
        r.setItemVisual(n, "legendIcon", "roundRect");
      }), r.setVisual("legendIcon", "roundRect");
    }
  });
}
function JTe(e) {
  Bt(QTe), e.registerChartView(jTe), e.registerSeriesModel(UTe), e.registerLayout(zTe), e.registerProcessor(qv("radar")), e.registerPreprocessor(WTe);
}
var rB = "\0_ec_interaction_mutex";
function ePe(e, t, r) {
  var n = iA(e);
  n[t] = r;
}
function tPe(e, t, r) {
  var n = iA(e), i = n[t];
  i === r && (n[t] = null);
}
function nB(e, t) {
  return !!iA(e)[t];
}
function iA(e) {
  return e[rB] || (e[rB] = {});
}
Va({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, un);
var Zv = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this) || this;
      n._zr = r;
      var i = je(n._mousedownHandler, n), o = je(n._mousemoveHandler, n), a = je(n._mouseupHandler, n), s = je(n._mousewheelHandler, n), l = je(n._pinchHandler, n);
      return n.enable = function(u, c) {
        this.disable(), this._opt = ut(dt(c) || {}, {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0
        }), u == null && (u = !0), (u === !0 || u === "move" || u === "pan") && (r.on("mousedown", i), r.on("mousemove", o), r.on("mouseup", a)), (u === !0 || u === "scale" || u === "zoom") && (r.on("mousewheel", s), r.on("pinch", l));
      }, n.disable = function() {
        r.off("mousedown", i), r.off("mousemove", o), r.off("mouseup", a), r.off("mousewheel", s), r.off("pinch", l);
      }, n;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype.setPointerChecker = function(r) {
      this.pointerChecker = r;
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(r) {
      if (!AF(r)) {
        for (var n = r.target; n; ) {
          if (n.draggable)
            return;
          n = n.__hostTarget || n.parent;
        }
        var i = r.offsetX, o = r.offsetY;
        this.pointerChecker && this.pointerChecker(r, i, o) && (this._x = i, this._y = o, this._dragging = !0);
      }
    }, t.prototype._mousemoveHandler = function(r) {
      if (!(!this._dragging || !g0("moveOnMouseMove", r, this._opt) || r.gestureEvent === "pinch" || nB(this._zr, "globalPan"))) {
        var n = r.offsetX, i = r.offsetY, o = this._x, a = this._y, s = n - o, l = i - a;
        this._x = n, this._y = i, this._opt.preventDefaultMouseMove && Zs(r.event), hU(this, "pan", "moveOnMouseMove", r, {
          dx: s,
          dy: l,
          oldX: o,
          oldY: a,
          newX: n,
          newY: i,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(r) {
      AF(r) || (this._dragging = !1);
    }, t.prototype._mousewheelHandler = function(r) {
      var n = g0("zoomOnMouseWheel", r, this._opt), i = g0("moveOnMouseWheel", r, this._opt), o = r.wheelDelta, a = Math.abs(o), s = r.offsetX, l = r.offsetY;
      if (!(o === 0 || !n && !i)) {
        if (n) {
          var u = a > 3 ? 1.4 : a > 1 ? 1.2 : 1.1, c = o > 0 ? u : 1 / u;
          fx(this, "zoom", "zoomOnMouseWheel", r, {
            scale: c,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (i) {
          var d = Math.abs(o), h = (o > 0 ? 1 : -1) * (d > 3 ? 0.4 : d > 1 ? 0.15 : 0.05);
          fx(this, "scrollMove", "moveOnMouseWheel", r, {
            scrollDelta: h,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, t.prototype._pinchHandler = function(r) {
      if (!nB(this._zr, "globalPan")) {
        var n = r.pinchScale > 1 ? 1.1 : 1 / 1.1;
        fx(this, "zoom", null, r, {
          scale: n,
          originX: r.pinchX,
          originY: r.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t;
  }(na)
);
function fx(e, t, r, n, i) {
  e.pointerChecker && e.pointerChecker(n, i.originX, i.originY) && (Zs(n.event), hU(e, t, r, n, i));
}
function hU(e, t, r, n, i) {
  i.isAvailableBehavior = je(g0, null, r, n), e.trigger(t, i);
}
function g0(e, t, r) {
  var n = r[e];
  return !e || n && (!He(n) || t.event[n + "Key"]);
}
function oA(e, t, r) {
  var n = e.target;
  n.x += t, n.y += r, n.dirty();
}
function aA(e, t, r, n) {
  var i = e.target, o = e.zoomLimit, a = e.zoom = e.zoom || 1;
  if (a *= t, o) {
    var s = o.min || 0, l = o.max || 1 / 0;
    a = Math.max(Math.min(l, a), s);
  }
  var u = a / e.zoom;
  e.zoom = a, i.x -= (r - i.x) * (u - 1), i.y -= (n - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty();
}
var rPe = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function Tw(e, t, r) {
  var n = t.getComponentByElement(e.topTarget), i = n && n.coordinateSystem;
  return n && n !== r && !rPe.hasOwnProperty(n.mainType) && i && i.model !== r;
}
function fU(e) {
  if (He(e)) {
    var t = new DOMParser();
    e = t.parseFromString(e, "text/xml");
  }
  var r = e;
  for (r.nodeType === 9 && (r = r.firstChild); r.nodeName.toLowerCase() !== "svg" || r.nodeType !== 1; )
    r = r.nextSibling;
  return r;
}
var px, IC = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, iB = jt(IC), OC = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, oB = jt(OC), nPe = function() {
  function e() {
    this._defs = {}, this._root = null;
  }
  return e.prototype.parse = function(t, r) {
    r = r || {};
    var n = fU(t);
    if (process.env.NODE_ENV !== "production" && !n)
      throw new Error("Illegal svg");
    this._defsUsePending = [];
    var i = new Ct();
    this._root = i;
    var o = [], a = n.getAttribute("viewBox") || "", s = parseFloat(n.getAttribute("width") || r.width), l = parseFloat(n.getAttribute("height") || r.height);
    isNaN(s) && (s = null), isNaN(l) && (l = null), oo(n, i, null, !0, !1);
    for (var u = n.firstChild; u; )
      this._parseNode(u, i, o, null, !1, !1), u = u.nextSibling;
    aPe(this._defs, this._defsUsePending), this._defsUsePending = [];
    var c, d;
    if (a) {
      var h = Pw(a);
      h.length >= 4 && (c = {
        x: parseFloat(h[0] || 0),
        y: parseFloat(h[1] || 0),
        width: parseFloat(h[2]),
        height: parseFloat(h[3])
      });
    }
    if (c && s != null && l != null && (d = gU(c, { x: 0, y: 0, width: s, height: l }), !r.ignoreViewBox)) {
      var f = i;
      i = new Ct(), i.add(f), f.scaleX = f.scaleY = d.scale, f.x = d.x, f.y = d.y;
    }
    return !r.ignoreRootClip && s != null && l != null && i.setClipPath(new or({
      shape: { x: 0, y: 0, width: s, height: l }
    })), {
      root: i,
      width: s,
      height: l,
      viewBoxRect: c,
      viewBoxTransform: d,
      named: o
    };
  }, e.prototype._parseNode = function(t, r, n, i, o, a) {
    var s = t.nodeName.toLowerCase(), l, u = i;
    if (s === "defs" && (o = !0), s === "text" && (a = !0), s === "defs" || s === "switch")
      l = r;
    else {
      if (!o) {
        var c = px[s];
        if (c && Ye(px, s)) {
          l = c.call(this, t, r);
          var d = t.getAttribute("name");
          if (d) {
            var h = {
              name: d,
              namedFrom: null,
              svgNodeTagLower: s,
              el: l
            };
            n.push(h), s === "g" && (u = h);
          } else i && n.push({
            name: i.name,
            namedFrom: i,
            svgNodeTagLower: s,
            el: l
          });
          r.add(l);
        }
      }
      var f = aB[s];
      if (f && Ye(aB, s)) {
        var p = f.call(this, t), g = t.getAttribute("id");
        g && (this._defs[g] = p);
      }
    }
    if (l && l.isGroup)
      for (var v = t.firstChild; v; )
        v.nodeType === 1 ? this._parseNode(v, l, n, u, o, a) : v.nodeType === 3 && a && this._parseText(v, l), v = v.nextSibling;
  }, e.prototype._parseText = function(t, r) {
    var n = new jh({
      style: {
        text: t.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    Io(r, n), oo(t, n, this._defsUsePending, !1, !1), iPe(n, r);
    var i = n.style, o = i.fontSize;
    o && o < 9 && (i.fontSize = 9, n.scaleX *= o / 9, n.scaleY *= o / 9);
    var a = (i.fontSize || i.fontFamily) && [
      i.fontStyle,
      i.fontWeight,
      (i.fontSize || 12) + "px",
      i.fontFamily || "sans-serif"
    ].join(" ");
    i.font = a;
    var s = n.getBoundingRect();
    return this._textX += s.width, r.add(n), n;
  }, e.internalField = function() {
    px = {
      g: function(t, r) {
        var n = new Ct();
        return Io(r, n), oo(t, n, this._defsUsePending, !1, !1), n;
      },
      rect: function(t, r) {
        var n = new or();
        return Io(r, n), oo(t, n, this._defsUsePending, !1, !1), n.setShape({
          x: parseFloat(t.getAttribute("x") || "0"),
          y: parseFloat(t.getAttribute("y") || "0"),
          width: parseFloat(t.getAttribute("width") || "0"),
          height: parseFloat(t.getAttribute("height") || "0")
        }), n.silent = !0, n;
      },
      circle: function(t, r) {
        var n = new ul();
        return Io(r, n), oo(t, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(t.getAttribute("cx") || "0"),
          cy: parseFloat(t.getAttribute("cy") || "0"),
          r: parseFloat(t.getAttribute("r") || "0")
        }), n.silent = !0, n;
      },
      line: function(t, r) {
        var n = new Nn();
        return Io(r, n), oo(t, n, this._defsUsePending, !1, !1), n.setShape({
          x1: parseFloat(t.getAttribute("x1") || "0"),
          y1: parseFloat(t.getAttribute("y1") || "0"),
          x2: parseFloat(t.getAttribute("x2") || "0"),
          y2: parseFloat(t.getAttribute("y2") || "0")
        }), n.silent = !0, n;
      },
      ellipse: function(t, r) {
        var n = new ow();
        return Io(r, n), oo(t, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(t.getAttribute("cx") || "0"),
          cy: parseFloat(t.getAttribute("cy") || "0"),
          rx: parseFloat(t.getAttribute("rx") || "0"),
          ry: parseFloat(t.getAttribute("ry") || "0")
        }), n.silent = !0, n;
      },
      polygon: function(t, r) {
        var n = t.getAttribute("points"), i;
        n && (i = uB(n));
        var o = new Li({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Io(r, o), oo(t, o, this._defsUsePending, !1, !1), o;
      },
      polyline: function(t, r) {
        var n = t.getAttribute("points"), i;
        n && (i = uB(n));
        var o = new Ni({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return Io(r, o), oo(t, o, this._defsUsePending, !1, !1), o;
      },
      image: function(t, r) {
        var n = new qn();
        return Io(r, n), oo(t, n, this._defsUsePending, !1, !1), n.setStyle({
          image: t.getAttribute("xlink:href") || t.getAttribute("href"),
          x: +t.getAttribute("x"),
          y: +t.getAttribute("y"),
          width: +t.getAttribute("width"),
          height: +t.getAttribute("height")
        }), n.silent = !0, n;
      },
      text: function(t, r) {
        var n = t.getAttribute("x") || "0", i = t.getAttribute("y") || "0", o = t.getAttribute("dx") || "0", a = t.getAttribute("dy") || "0";
        this._textX = parseFloat(n) + parseFloat(o), this._textY = parseFloat(i) + parseFloat(a);
        var s = new Ct();
        return Io(r, s), oo(t, s, this._defsUsePending, !1, !0), s;
      },
      tspan: function(t, r) {
        var n = t.getAttribute("x"), i = t.getAttribute("y");
        n != null && (this._textX = parseFloat(n)), i != null && (this._textY = parseFloat(i));
        var o = t.getAttribute("dx") || "0", a = t.getAttribute("dy") || "0", s = new Ct();
        return Io(r, s), oo(t, s, this._defsUsePending, !1, !0), this._textX += parseFloat(o), this._textY += parseFloat(a), s;
      },
      path: function(t, r) {
        var n = t.getAttribute("d") || "", i = ZW(n);
        return Io(r, i), oo(t, i, this._defsUsePending, !1, !1), i.silent = !0, i;
      }
    };
  }(), e;
}(), aB = {
  lineargradient: function(e) {
    var t = parseInt(e.getAttribute("x1") || "0", 10), r = parseInt(e.getAttribute("y1") || "0", 10), n = parseInt(e.getAttribute("x2") || "10", 10), i = parseInt(e.getAttribute("y2") || "0", 10), o = new vf(t, r, n, i);
    return sB(e, o), lB(e, o), o;
  },
  radialgradient: function(e) {
    var t = parseInt(e.getAttribute("cx") || "0", 10), r = parseInt(e.getAttribute("cy") || "0", 10), n = parseInt(e.getAttribute("r") || "0", 10), i = new oD(t, r, n);
    return sB(e, i), lB(e, i), i;
  }
};
function sB(e, t) {
  var r = e.getAttribute("gradientUnits");
  r === "userSpaceOnUse" && (t.global = !0);
}
function lB(e, t) {
  for (var r = e.firstChild; r; ) {
    if (r.nodeType === 1 && r.nodeName.toLocaleLowerCase() === "stop") {
      var n = r.getAttribute("offset"), i = void 0;
      n && n.indexOf("%") > 0 ? i = parseInt(n, 10) / 100 : n ? i = parseFloat(n) : i = 0;
      var o = {};
      pU(r, o, o);
      var a = o.stopColor || r.getAttribute("stop-color") || "#000000";
      t.colorStops.push({
        offset: i,
        color: a
      });
    }
    r = r.nextSibling;
  }
}
function Io(e, t) {
  e && e.__inheritedStyle && (t.__inheritedStyle || (t.__inheritedStyle = {}), ut(t.__inheritedStyle, e.__inheritedStyle));
}
function uB(e) {
  for (var t = Pw(e), r = [], n = 0; n < t.length; n += 2) {
    var i = parseFloat(t[n]), o = parseFloat(t[n + 1]);
    r.push([i, o]);
  }
  return r;
}
function oo(e, t, r, n, i) {
  var o = t, a = o.__inheritedStyle = o.__inheritedStyle || {}, s = {};
  e.nodeType === 1 && (uPe(e, t), pU(e, a, s), n || cPe(e, a, s)), o.style = o.style || {}, a.fill != null && (o.style.fill = cB(o, "fill", a.fill, r)), a.stroke != null && (o.style.stroke = cB(o, "stroke", a.stroke, r)), $([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(l) {
    a[l] != null && (o.style[l] = parseFloat(a[l]));
  }), $([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(l) {
    a[l] != null && (o.style[l] = a[l]);
  }), i && (o.__selfStyle = s), a.lineDash && (o.style.lineDash = Ee(Pw(a.lineDash), function(l) {
    return parseFloat(l);
  })), (a.visibility === "hidden" || a.visibility === "collapse") && (o.invisible = !0), a.display === "none" && (o.ignore = !0);
}
function iPe(e, t) {
  var r = t.__selfStyle;
  if (r) {
    var n = r.textBaseline, i = n;
    !n || n === "auto" || n === "baseline" ? i = "alphabetic" : n === "before-edge" || n === "text-before-edge" ? i = "top" : n === "after-edge" || n === "text-after-edge" ? i = "bottom" : (n === "central" || n === "mathematical") && (i = "middle"), e.style.textBaseline = i;
  }
  var o = t.__inheritedStyle;
  if (o) {
    var a = o.textAlign, s = a;
    a && (a === "middle" && (s = "center"), e.style.textAlign = s);
  }
}
var oPe = /^url\(\s*#(.*?)\)/;
function cB(e, t, r, n) {
  var i = r && r.match(oPe);
  if (i) {
    var o = Wo(i[1]);
    n.push([e, t, o]);
    return;
  }
  return r === "none" && (r = null), r;
}
function aPe(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n[0].style[n[1]] = e[n[2]];
  }
}
var sPe = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function Pw(e) {
  return e.match(sPe) || [];
}
var lPe = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, gx = Math.PI / 180;
function uPe(e, t) {
  var r = e.getAttribute("transform");
  if (r) {
    r = r.replace(/,/g, " ");
    var n = [], i = null;
    r.replace(lPe, function(d, h, f) {
      return n.push(h, f), "";
    });
    for (var o = n.length - 1; o > 0; o -= 2) {
      var a = n[o], s = n[o - 1], l = Pw(a);
      switch (i = i || Zi(), s) {
        case "translate":
          Oa(i, i, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
          break;
        case "scale":
          KS(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
          break;
        case "rotate":
          Cu(i, i, -parseFloat(l[0]) * gx, [
            parseFloat(l[1] || "0"),
            parseFloat(l[2] || "0")
          ]);
          break;
        case "skewX":
          var u = Math.tan(parseFloat(l[0]) * gx);
          us(i, [1, 0, u, 1, 0, 0], i);
          break;
        case "skewY":
          var c = Math.tan(parseFloat(l[0]) * gx);
          us(i, [1, c, 0, 1, 0, 0], i);
          break;
        case "matrix":
          i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
          break;
      }
    }
    t.setLocalTransform(i);
  }
}
var dB = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function pU(e, t, r) {
  var n = e.getAttribute("style");
  if (n) {
    dB.lastIndex = 0;
    for (var i; (i = dB.exec(n)) != null; ) {
      var o = i[1], a = Ye(IC, o) ? IC[o] : null;
      a && (t[a] = i[2]);
      var s = Ye(OC, o) ? OC[o] : null;
      s && (r[s] = i[2]);
    }
  }
}
function cPe(e, t, r) {
  for (var n = 0; n < iB.length; n++) {
    var i = iB[n], o = e.getAttribute(i);
    o != null && (t[IC[i]] = o);
  }
  for (var n = 0; n < oB.length; n++) {
    var i = oB[n], o = e.getAttribute(i);
    o != null && (r[OC[i]] = o);
  }
}
function gU(e, t) {
  var r = t.width / e.width, n = t.height / e.height, i = Math.min(r, n);
  return {
    scale: i,
    x: -(e.x + e.width / 2) * i + (t.x + t.width / 2),
    y: -(e.y + e.height / 2) * i + (t.y + t.height / 2)
  };
}
function dPe(e, t) {
  var r = new nPe();
  return r.parse(e, t);
}
var hPe = nt([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), fPe = (
  /** @class */
  function() {
    function e(t, r) {
      this.type = "geoSVG", this._usedGraphicMap = nt(), this._freedGraphics = [], this._mapName = t, this._parsedXML = fU(r);
    }
    return e.prototype.load = function() {
      var t = this._firstGraphic;
      if (!t) {
        t = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(t), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var r = gPe(t.named), n = r.regions, i = r.regionsMap;
        this._regions = n, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, e.prototype._buildGraphic = function(t) {
      var r, n;
      try {
        r = t && dPe(t, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, n = r.root, ct(n != null);
      } catch (v) {
        throw new Error(`Invalid svg format
` + v.message);
      }
      var i = new Ct();
      i.add(n), i.isGeoSVGGraphicRoot = !0;
      var o = r.width, a = r.height, s = r.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, d = void 0, h = void 0;
        if (o != null ? (u = 0, d = o) : s && (u = s.x, d = s.width), a != null ? (c = 0, h = a) : s && (c = s.y, h = s.height), u == null || c == null) {
          var f = n.getBoundingRect();
          u == null && (u = f.x, d = f.width), c == null && (c = f.y, h = f.height);
        }
        l = this._boundingRect = new At(u, c, d, h);
      }
      if (s) {
        var p = gU(s, l);
        n.scaleX = n.scaleY = p.scale, n.x = p.x, n.y = p.y;
      }
      i.setClipPath(new or({
        shape: l.plain()
      }));
      var g = [];
      return $(r.named, function(v) {
        hPe.get(v.svgNodeTagLower) != null && (g.push(v), pPe(v.el));
      }), {
        root: i,
        boundingRect: l,
        named: g
      };
    }, e.prototype.useGraphic = function(t) {
      var r = this._usedGraphicMap, n = r.get(t);
      return n || (n = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), r.set(t, n), n);
    }, e.prototype.freeGraphic = function(t) {
      var r = this._usedGraphicMap, n = r.get(t);
      n && (r.removeKey(t), this._freedGraphics.push(n));
    }, e;
  }()
);
function pPe(e) {
  e.silent = !1, e.isGroup && e.traverse(function(t) {
    t.silent = !1;
  });
}
function gPe(e) {
  var t = [], r = nt();
  return $(e, function(n) {
    if (n.namedFrom == null) {
      var i = new eRe(n.name, n.el);
      t.push(i), r.set(n.name, i);
    }
  }), {
    regions: t,
    regionsMap: r
  };
}
var yT = [126, 25], hB = "", Ju = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var qu = 0; qu < Ju.length; qu++)
  for (var zd = 0; zd < Ju[qu].length; zd++)
    Ju[qu][zd][0] /= 10.5, Ju[qu][zd][1] /= -10.5 / 0.75, Ju[qu][zd][0] += yT[0], Ju[qu][zd][1] += yT[1];
function vPe(e, t) {
  if (e === "china") {
    for (var r = 0; r < t.length; r++)
      if (t[r].name === hB)
        return;
    t.push(new dj(hB, Ee(Ju, function(n) {
      return {
        type: "polygon",
        exterior: n
      };
    }), yT));
  }
}
var mPe = {
  : [32, 80],
  // 
  : [0, -10],
  : [10, 5],
  : [-10, 10],
  // '': [-10, 0],
  : [5, 5]
};
function yPe(e, t) {
  if (e === "china") {
    var r = mPe[t.name];
    if (r) {
      var n = t.getCenter();
      n[0] += r[0] / 10.5, n[1] += -r[1] / (10.5 / 0.75), t.setCenter(n);
    }
  }
}
var CPe = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function SPe(e, t) {
  e === "china" && t.name === "" && t.geometries.push({
    type: "polygon",
    exterior: CPe[0]
  });
}
var wPe = "name", bPe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "geoJSON", this._parsedMap = nt(), this._mapName = t, this._specialAreas = n, this._geoJSON = EPe(r);
    }
    return e.prototype.load = function(t, r) {
      r = r || wPe;
      var n = this._parsedMap.get(r);
      if (!n) {
        var i = this._parseToRegions(r);
        n = this._parsedMap.set(r, {
          regions: i,
          boundingRect: xPe(i)
        });
      }
      var o = nt(), a = [];
      return $(n.regions, function(s) {
        var l = s.name;
        t && Ye(t, l) && (s = s.cloneShallow(l = t[l])), a.push(s), o.set(l, s);
      }), {
        regions: a,
        boundingRect: n.boundingRect || new At(0, 0, 0, 0),
        regionsMap: o
      };
    }, e.prototype._parseToRegions = function(t) {
      var r = this._mapName, n = this._geoJSON, i;
      try {
        i = n ? lT(n, t) : [];
      } catch (o) {
        throw new Error(`Invalid geoJson format
` + o.message);
      }
      return vPe(r, i), $(i, function(o) {
        var a = o.name;
        yPe(r, o), SPe(r, o);
        var s = this._specialAreas && this._specialAreas[a];
        s && o.transformTo(s.left, s.top, s.width, s.height);
      }, this), i;
    }, e.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, e;
  }()
);
function xPe(e) {
  for (var t, r = 0; r < e.length; r++) {
    var n = e[r].getBoundingRect();
    t = t || n.clone(), t.union(n);
  }
  return t;
}
function EPe(e) {
  return He(e) ? typeof JSON < "u" && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")() : e;
}
var gp = nt();
const nl = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(e, t, r) {
    if (t.svg) {
      var n = new fPe(e, t.svg);
      gp.set(e, n);
    } else {
      var i = t.geoJson || t.geoJSON;
      i && !t.features ? r = t.specialAreas : i = t;
      var n = new bPe(e, i, r);
      gp.set(e, n);
    }
  },
  getGeoResource: function(e) {
    return gp.get(e);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(e) {
    var t = gp.get(e);
    return t && t.type === "geoJSON" && t.getMapForUser();
  },
  load: function(e, t, r) {
    var n = gp.get(e);
    if (!n) {
      process.env.NODE_ENV !== "production" && console.error("Map " + e + " not exists. The GeoJSON of the map must be provided.");
      return;
    }
    return n.load(t, r);
  }
};
var sA = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], RPe = nt(sA), _Pe = nt(sA.concat(["g"])), TPe = nt(sA.concat(["g"])), vU = ar();
function my(e) {
  var t = e.getItemStyle(), r = e.get("areaColor");
  return r != null && (t.fill = r), t;
}
function fB(e) {
  var t = e.style;
  t && (t.stroke = t.stroke || t.fill, t.fill = null);
}
var mU = (
  /** @class */
  function() {
    function e(t) {
      var r = new Ct();
      this.uid = wf("ec_map_draw"), this._controller = new Zv(t.getZr()), this._controllerHost = {
        target: r
      }, this.group = r, r.add(this._regionsGroup = new Ct()), r.add(this._svgGroup = new Ct());
    }
    return e.prototype.draw = function(t, r, n, i, o) {
      var a = t.mainType === "geo", s = t.getData && t.getData();
      a && r.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(m) {
        !s && m.getHostGeoModel() === t && (s = m.getData());
      });
      var l = t.coordinateSystem, u = this._regionsGroup, c = this.group, d = l.getTransformInfo(), h = d.raw, f = d.roam, p = !u.childAt(0) || o;
      p ? (c.x = f.x, c.y = f.y, c.scaleX = f.scaleX, c.scaleY = f.scaleY, c.dirty()) : ur(c, f, t);
      var g = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, v = {
        api: n,
        geo: l,
        mapOrGeoModel: t,
        data: s,
        isVisualEncodedByVisualMap: g,
        isGeo: a,
        transformInfoRaw: h
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(v) : l.resourceType === "geoSVG" && this._buildSVG(v), this._updateController(t, r, n), this._updateMapSelectHandler(t, u, n, i);
    }, e.prototype._buildGeoJSON = function(t) {
      var r = this._regionsGroupByName = nt(), n = nt(), i = this._regionsGroup, o = t.transformInfoRaw, a = t.mapOrGeoModel, s = t.data, l = t.geo.projection, u = l && l.stream;
      function c(f, p) {
        return p && (f = p(f)), f && [f[0] * o.scaleX + o.x, f[1] * o.scaleY + o.y];
      }
      function d(f) {
        for (var p = [], g = !u && l && l.project, v = 0; v < f.length; ++v) {
          var m = c(f[v], g);
          m && p.push(m);
        }
        return p;
      }
      function h(f) {
        return {
          shape: {
            points: d(f)
          }
        };
      }
      i.removeAll(), $(t.geo.regions, function(f) {
        var p = f.name, g = r.get(p), v = n.get(p) || {}, m = v.dataIdx, y = v.regionModel;
        g || (g = r.set(p, new Ct()), i.add(g), m = s ? s.indexOfName(p) : null, y = t.isGeo ? a.getRegionModel(p) : s ? s.getItemModel(m) : null, n.set(p, {
          dataIdx: m,
          regionModel: y
        }));
        var C = [], S = [];
        $(f.geometries, function(x) {
          if (x.type === "polygon") {
            var R = [x.exterior].concat(x.interiors || []);
            u && (R = CB(R, u)), $(R, function(T) {
              C.push(new Li(h(T)));
            });
          } else {
            var _ = x.points;
            u && (_ = CB(_, u, !0)), $(_, function(T) {
              S.push(new Ni(h(T)));
            });
          }
        });
        var b = c(f.getCenter(), l && l.project);
        function w(x, R) {
          if (x.length) {
            var _ = new sw({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: x
              }
            });
            g.add(_), pB(t, _, m, y), gB(t, _, p, y, a, m, b), R && (fB(_), $(_.states, fB));
          }
        }
        w(C), w(S, !0);
      }), r.each(function(f, p) {
        var g = n.get(p), v = g.dataIdx, m = g.regionModel;
        vB(t, f, p, m, a, v), mB(t, f, p, m, a), yB(t, f, p, m, a);
      }, this);
    }, e.prototype._buildSVG = function(t) {
      var r = t.geo.map, n = t.transformInfoRaw;
      this._svgGroup.x = n.x, this._svgGroup.y = n.y, this._svgGroup.scaleX = n.scaleX, this._svgGroup.scaleY = n.scaleY, this._svgResourceChanged(r) && (this._freeSVG(), this._useSVG(r));
      var i = this._svgDispatcherMap = nt(), o = !1;
      $(this._svgGraphicRecord.named, function(a) {
        var s = a.name, l = t.mapOrGeoModel, u = t.data, c = a.svgNodeTagLower, d = a.el, h = u ? u.indexOfName(s) : null, f = l.getRegionModel(s);
        if (RPe.get(c) != null && d instanceof ta && pB(t, d, h, f), d instanceof ta && (d.culling = !0), d.z2EmphasisLift = 0, !a.namedFrom && (TPe.get(c) != null && gB(t, d, s, f, l, h, null), vB(t, d, s, f, l, h), mB(t, d, s, f, l), _Pe.get(c) != null)) {
          var p = yB(t, d, s, f, l);
          p === "self" && (o = !0);
          var g = i.get(s) || i.set(s, []);
          g.push(d);
        }
      }, this), this._enableBlurEntireSVG(o, t);
    }, e.prototype._enableBlurEntireSVG = function(t, r) {
      if (t && r.isGeo) {
        var n = r.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), i = n.opacity;
        this._svgGraphicRecord.root.traverse(function(o) {
          if (!o.isGroup) {
            jc(o);
            var a = o.ensureState("blur").style || {};
            a.opacity == null && i != null && (a.opacity = i), o.ensureState("emphasis");
          }
        });
      }
    }, e.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, e.prototype.findHighDownDispatchers = function(t, r) {
      if (t == null)
        return [];
      var n = r.coordinateSystem;
      if (n.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var o = i.get(t);
          return o ? [o] : [];
        }
      } else if (n.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(t) || [];
    }, e.prototype._svgResourceChanged = function(t) {
      return this._svgMapName !== t;
    }, e.prototype._useSVG = function(t) {
      var r = nl.getGeoResource(t);
      if (r && r.type === "geoSVG") {
        var n = r.useGraphic(this.uid);
        this._svgGroup.add(n.root), this._svgGraphicRecord = n, this._svgMapName = t;
      }
    }, e.prototype._freeSVG = function() {
      var t = this._svgMapName;
      if (t != null) {
        var r = nl.getGeoResource(t);
        r && r.type === "geoSVG" && r.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, e.prototype._updateController = function(t, r, n) {
      var i = t.coordinateSystem, o = this._controller, a = this._controllerHost;
      a.zoomLimit = t.get("scaleLimit"), a.zoom = i.getZoom(), o.enable(t.get("roam") || !1);
      var s = t.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: s
        };
        return u[s + "Id"] = t.id, u;
      }
      o.off("pan").on("pan", function(u) {
        this._mouseDownFlag = !1, oA(a, u.dx, u.dy), n.dispatchAction(ge(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), o.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = !1, aA(a, u.scale, u.originX, u.originY), n.dispatchAction(ge(l(), {
          totalZoom: a.zoom,
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), o.setPointerChecker(function(u, c, d) {
        return i.containPoint([c, d]) && !Tw(u, n, t);
      });
    }, e.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(t) {
        var r = t.getTextContent();
        r && (r.ignore = vU(r).ignore);
      });
    }, e.prototype._updateMapSelectHandler = function(t, r, n, i) {
      var o = this;
      r.off("mousedown"), r.off("click"), t.get("selectedMode") && (r.on("mousedown", function() {
        o._mouseDownFlag = !0;
      }), r.on("click", function(a) {
        o._mouseDownFlag && (o._mouseDownFlag = !1);
      }));
    }, e;
  }()
);
function pB(e, t, r, n) {
  var i = n.getModel("itemStyle"), o = n.getModel(["emphasis", "itemStyle"]), a = n.getModel(["blur", "itemStyle"]), s = n.getModel(["select", "itemStyle"]), l = my(i), u = my(o), c = my(s), d = my(a), h = e.data;
  if (h) {
    var f = h.getItemVisual(r, "style"), p = h.getItemVisual(r, "decal");
    e.isVisualEncodedByVisualMap && f.fill && (l.fill = f.fill), p && (l.decal = Yh(p, e.api));
  }
  t.setStyle(l), t.style.strokeNoScale = !0, t.ensureState("emphasis").style = u, t.ensureState("select").style = c, t.ensureState("blur").style = d, jc(t);
}
function gB(e, t, r, n, i, o, a) {
  var s = e.data, l = e.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), o)), c = s && s.getItemLayout(o);
  if (l || u || c && c.showLabel) {
    var d = l ? r : o, h = void 0;
    (!s || o >= 0) && (h = i);
    var f = a ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    ri(t, $n(n), {
      labelFetcher: h,
      labelDataIndex: d,
      defaultText: r
    }, f);
    var p = t.getTextContent();
    if (p && (vU(p).ignore = p.ignore, t.textConfig && a)) {
      var g = t.getBoundingRect().clone();
      t.textConfig.layoutRect = g, t.textConfig.position = [(a[0] - g.x) / g.width * 100 + "%", (a[1] - g.y) / g.height * 100 + "%"];
    }
    t.disableLabelAnimation = !0;
  } else
    t.removeTextContent(), t.removeTextConfig(), t.disableLabelAnimation = null;
}
function vB(e, t, r, n, i, o) {
  e.data ? e.data.setItemGraphicEl(o, t) : St(t).eventData = {
    componentType: "geo",
    componentIndex: i.componentIndex,
    geoIndex: i.componentIndex,
    name: r,
    region: n && n.option || {}
  };
}
function mB(e, t, r, n, i) {
  e.data || Cf({
    el: t,
    componentModel: i,
    itemName: r,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: n.get("tooltip")
  });
}
function yB(e, t, r, n, i) {
  t.highDownSilentOnTouch = !!i.get("selectedMode");
  var o = n.getModel("emphasis"), a = o.get("focus");
  return sn(t, a, o.get("blurScope"), o.get("disabled")), e.isGeo && twe(t, i, r), a;
}
function CB(e, t, r) {
  var n = [], i;
  function o() {
    i = [];
  }
  function a() {
    i.length && (n.push(i), i = []);
  }
  var s = t({
    polygonStart: o,
    polygonEnd: a,
    lineStart: o,
    lineEnd: a,
    point: function(l, u) {
      isFinite(l) && isFinite(u) && i.push([l, u]);
    },
    sphere: function() {
    }
  });
  return !r && s.polygonStart(), $(e, function(l) {
    s.lineStart();
    for (var u = 0; u < l.length; u++)
      s.point(l[u][0], l[u][1]);
    s.lineEnd();
  }), !r && s.polygonEnd(), n;
}
var PPe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      if (!(o && o.type === "mapToggleSelect" && o.from === this.uid)) {
        var a = this.group;
        if (a.removeAll(), !r.getHostGeoModel()) {
          if (this._mapDraw && o && o.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), o && o.type === "geoRoam" && o.componentType === "series" && o.seriesId === r.id) {
            var s = this._mapDraw;
            s && a.add(s.group);
          } else if (r.needsDrawMap) {
            var s = this._mapDraw || new mU(i);
            a.add(s.group), s.draw(r, n, i, this, o), this._mapDraw = s;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          r.get("showLegendSymbol") && n.getComponent("legend") && this._renderSymbols(r, n, i);
        }
      }
    }, t.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, t.prototype._renderSymbols = function(r, n, i) {
      var o = r.originalData, a = this.group;
      o.each(o.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = o.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, d = u.offset, h = new ul({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: r.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + d * 9,
                cy: c[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (d ? 0 : gf + 1)
            });
            if (!d) {
              var f = r.mainSeries.getData(), p = o.getName(l), g = f.indexOfName(p), v = o.getItemModel(l), m = v.getModel("label"), y = f.getItemGraphicEl(g);
              ri(h, $n(v), {
                labelFetcher: {
                  getFormattedLabel: function(C, S) {
                    return r.getFormattedLabel(g, S);
                  }
                },
                defaultText: p
              }), h.disableLabelAnimation = !0, m.get("position") || h.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(C) {
                lC(h, C);
              };
            }
            a.add(h);
          }
        }
      });
    }, t.type = "map", t;
  }(br)
), MPe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.needsDrawMap = !1, r.seriesGroup = [], r.getTooltipPosition = function(n) {
        if (n != null) {
          var i = this.getData().getName(n), o = this.coordinateSystem, a = o.getRegion(i);
          return a && o.dataToPoint(a.getCenter());
        }
      }, r;
    }
    return t.prototype.getInitialData = function(r) {
      for (var n = Df(this, {
        coordDimensions: ["value"],
        encodeDefaulter: _t(wD, this)
      }), i = nt(), o = [], a = 0, s = n.count(); a < s; a++) {
        var l = n.getName(a);
        i.set(l, !0);
      }
      var u = nl.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return $(u.regions, function(c) {
        var d = c.name;
        i.get(d) || o.push(d);
      }), n.appendValues([], o), n;
    }, t.prototype.getHostGeoModel = function() {
      var r = this.option.geoIndex;
      return r != null ? this.ecModel.getComponent("geo", r) : null;
    }, t.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, t.prototype.getRawValue = function(r) {
      var n = this.getData();
      return n.get(n.mapDimension("value"), r);
    }, t.prototype.getRegionModel = function(r) {
      var n = this.getData();
      return n.getItemModel(n.indexOfName(r));
    }, t.prototype.formatTooltip = function(r, n, i) {
      for (var o = this.getData(), a = this.getRawValue(r), s = o.getName(r), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var d = l[c].originalData.indexOfName(s), h = o.mapDimension("value");
        isNaN(l[c].originalData.get(h, d)) || u.push(l[c].name);
      }
      return Hn("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [Hn("nameValue", {
          name: s,
          value: a
        })]
      });
    }, t.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, t.prototype.setCenter = function(r) {
      this.option.center = r;
    }, t.prototype.getLegendIcon = function(r) {
      var n = r.icon || "roundRect", i = mn(n, 0, 0, r.itemWidth, r.itemHeight, r.itemStyle.fill);
      return i.setStyle(r.itemStyle), i.style.stroke = "none", n.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i;
    }, t.type = "series.map", t.dependencies = ["geo"], t.layoutMode = "box", t.defaultOption = {
      // 
      // zlevel: 0,
      // 
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, t;
  }(Pr)
);
function DPe(e, t) {
  var r = {};
  return $(e, function(n) {
    n.each(n.mapDimension("value"), function(i, o) {
      var a = "ec-" + n.getName(o);
      r[a] = r[a] || [], isNaN(i) || r[a].push(i);
    });
  }), e[0].map(e[0].mapDimension("value"), function(n, i) {
    for (var o = "ec-" + e[0].getName(i), a = 0, s = 1 / 0, l = -1 / 0, u = r[o].length, c = 0; c < u; c++)
      s = Math.min(s, r[o][c]), l = Math.max(l, r[o][c]), a += r[o][c];
    var d;
    return t === "min" ? d = s : t === "max" ? d = l : t === "average" ? d = a / u : d = a, u === 0 ? NaN : d;
  });
}
function APe(e) {
  var t = {};
  e.eachSeriesByType("map", function(r) {
    var n = r.getHostGeoModel(), i = n ? "o" + n.id : "i" + r.getMapType();
    (t[i] = t[i] || []).push(r);
  }), $(t, function(r, n) {
    for (var i = DPe(Ee(r, function(a) {
      return a.getData();
    }), r[0].get("mapValueCalculation")), o = 0; o < r.length; o++)
      r[o].originalData = r[o].getData();
    for (var o = 0; o < r.length; o++)
      r[o].seriesGroup = r, r[o].needsDrawMap = o === 0 && !r[o].getHostGeoModel(), r[o].setData(i.cloneShallow()), r[o].mainSeries = r[0];
  });
}
function IPe(e) {
  var t = {};
  e.eachSeriesByType("map", function(r) {
    var n = r.getMapType();
    if (!(r.getHostGeoModel() || t[n])) {
      var i = {};
      $(r.seriesGroup, function(a) {
        var s = a.coordinateSystem, l = a.originalData;
        a.get("showLegendSymbol") && e.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
          var d = l.getName(c), h = s.getRegion(d);
          if (!(!h || isNaN(u))) {
            var f = i[d] || 0, p = s.dataToPoint(h.getCenter());
            i[d] = f + 1, l.setItemLayout(c, {
              point: p,
              offset: f
            });
          }
        });
      });
      var o = r.getData();
      o.each(function(a) {
        var s = o.getName(a), l = o.getItemLayout(a) || {};
        l.showLabel = !i[s], o.setItemLayout(a, l);
      }), t[n] = !0;
    }
  });
}
var SB = Un, Qv = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this) || this;
      return n.type = "view", n.dimensions = ["x", "y"], n._roamTransformable = new $s(), n._rawTransformable = new $s(), n.name = r, n;
    }
    return t.prototype.setBoundingRect = function(r, n, i, o) {
      return this._rect = new At(r, n, i, o), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(r, n, i, o) {
      this._transformTo(r, n, i, o), this._viewRect = new At(r, n, i, o);
    }, t.prototype._transformTo = function(r, n, i, o) {
      var a = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = a.calculateTransform(new At(r, n, i, o));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(r, n) {
      r && (this._center = [Be(r[0], n.getWidth()), Be(r[1], n.getHeight())], this._updateCenterAndZoom());
    }, t.prototype.setZoom = function(r) {
      r = r || 1;
      var n = this.zoomLimit;
      n && (n.max != null && (r = Math.min(n.max, r)), n.min != null && (r = Math.max(n.min, r))), this._zoom = r, this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var r = this.getBoundingRect(), n = r.x + r.width / 2, i = r.y + r.height / 2;
      return [n, i];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var r = this._rawTransformable.getLocalTransform(), n = this._roamTransformable, i = this.getDefaultCenter(), o = this.getCenter(), a = this.getZoom();
      o = Un([], o, r), i = Un([], i, r), n.originX = o[0], n.originY = o[1], n.x = i[0] - o[0], n.y = i[1] - o[1], n.scaleX = n.scaleY = a, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var r = this._roamTransformable, n = this._rawTransformable;
      n.parent = r, r.updateTransform(), n.updateTransform(), US(this.transform || (this.transform = []), n.transform || Zi()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], id(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var r = this._rawTransformable, n = this._roamTransformable, i = new $s();
      return i.transform = n.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: r.x,
          y: r.y,
          scaleX: r.scaleX,
          scaleY: r.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var r = this.getBoundingRect().clone();
      return r.applyTransform(this.transform), r;
    }, t.prototype.dataToPoint = function(r, n, i) {
      var o = n ? this._rawTransform : this.transform;
      return i = i || [], o ? SB(i, r, o) : ai(i, r);
    }, t.prototype.pointToData = function(r) {
      var n = this.invTransform;
      return n ? SB([], r, n) : [r[0], r[1]];
    }, t.prototype.convertToPixel = function(r, n, i) {
      var o = wB(n);
      return o === this ? o.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(r, n, i) {
      var o = wB(n);
      return o === this ? o.pointToData(i) : null;
    }, t.prototype.containPoint = function(r) {
      return this.getViewRectAfterRoam().contain(r[0], r[1]);
    }, t.dimensions = ["x", "y"], t;
  }($s)
);
function wB(e) {
  var t = e.seriesModel;
  return t ? t.coordinateSystem : null;
}
var OPe = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, yU = ["lng", "lat"], CU = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i) {
      var o = e.call(this, r) || this;
      o.dimensions = yU, o.type = "geo", o._nameCoordMap = nt(), o.map = n;
      var a = i.projection, s = nl.load(n, i.nameMap, i.nameProperty), l = nl.getGeoResource(n), u = o.resourceType = l ? l.type : null, c = o.regions = s.regions, d = OPe[l.type];
      o._regionsMap = s.regionsMap, o.regions = s.regions, process.env.NODE_ENV !== "production" && a && (u === "geoSVG" && (process.env.NODE_ENV !== "production" && nn("Map " + n + " with SVG source can't use projection. Only GeoJSON source supports projection."), a = null), a.project && a.unproject || (process.env.NODE_ENV !== "production" && nn("project and unproject must be both provided in the projeciton."), a = null)), o.projection = a;
      var h;
      if (a)
        for (var f = 0; f < c.length; f++) {
          var p = c[f].getBoundingRect(a);
          h = h || p.clone(), h.union(p);
        }
      else
        h = s.boundingRect;
      return o.setBoundingRect(h.x, h.y, h.width, h.height), o.aspectScale = a ? 1 : bt(i.aspectScale, d.aspectScale), o._invertLongitute = a ? !1 : d.invertLongitute, o;
    }
    return t.prototype._transformTo = function(r, n, i, o) {
      var a = this.getBoundingRect(), s = this._invertLongitute;
      a = a.clone(), s && (a.y = -a.y - a.height);
      var l = this._rawTransformable;
      l.transform = a.calculateTransform(new At(r, n, i, o));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, t.prototype.getRegion = function(r) {
      return this._regionsMap.get(r);
    }, t.prototype.getRegionByCoord = function(r) {
      for (var n = this.regions, i = 0; i < n.length; i++) {
        var o = n[i];
        if (o.type === "geoJSON" && o.contain(r))
          return n[i];
      }
    }, t.prototype.addGeoCoord = function(r, n) {
      this._nameCoordMap.set(r, n);
    }, t.prototype.getGeoCoord = function(r) {
      var n = this._regionsMap.get(r);
      return this._nameCoordMap.get(r) || n && n.getCenter();
    }, t.prototype.dataToPoint = function(r, n, i) {
      if (He(r) && (r = this.getGeoCoord(r)), r) {
        var o = this.projection;
        return o && (r = o.project(r)), r && this.projectedToPoint(r, n, i);
      }
    }, t.prototype.pointToData = function(r) {
      var n = this.projection;
      return n && (r = n.unproject(r)), r && this.pointToProjected(r);
    }, t.prototype.pointToProjected = function(r) {
      return e.prototype.pointToData.call(this, r);
    }, t.prototype.projectedToPoint = function(r, n, i) {
      return e.prototype.dataToPoint.call(this, r, n, i);
    }, t.prototype.convertToPixel = function(r, n, i) {
      var o = bB(n);
      return o === this ? o.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(r, n, i) {
      var o = bB(n);
      return o === this ? o.pointToData(i) : null;
    }, t;
  }(Qv)
);
cn(CU, Qv);
function bB(e) {
  var t = e.geoModel, r = e.seriesModel;
  return t ? t.coordinateSystem : r ? r.coordinateSystem || (r.getReferringComponents("geo", bn).models[0] || {}).coordinateSystem : null;
}
const xB = CU;
function EB(e, t) {
  var r = e.get("boundingCoords");
  if (r != null) {
    var n = r[0], i = r[1];
    if (!(isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1])))
      process.env.NODE_ENV !== "production" && console.error("Invalid boundingCoords");
    else {
      var o = this.projection;
      if (o) {
        var a = n[0], s = n[1], l = i[0], u = i[1];
        n = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0];
        var c = function(w, x, R, _) {
          for (var T = R - w, P = _ - x, D = 0; D <= 100; D++) {
            var O = D / 100, A = o.project([w + T * O, x + P * O]);
            Vs(n, n, A), Bs(i, i, A);
          }
        };
        c(a, s, l, s), c(l, s, l, u), c(l, u, a, u), c(a, u, l, s);
      }
      this.setBoundingRect(n[0], n[1], i[0] - n[0], i[1] - n[1]);
    }
  }
  var d = this.getBoundingRect(), h = e.get("layoutCenter"), f = e.get("layoutSize"), p = t.getWidth(), g = t.getHeight(), v = d.width / d.height * this.aspectScale, m = !1, y, C;
  h && f && (y = [Be(h[0], p), Be(h[1], g)], C = Be(f, Math.min(p, g)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(C) ? m = !0 : process.env.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
  var S;
  if (m)
    S = {}, v > 1 ? (S.width = C, S.height = C / v) : (S.height = C, S.width = C * v), S.y = y[1] - S.height / 2, S.x = y[0] - S.width / 2;
  else {
    var b = e.getBoxLayoutParams();
    b.aspect = v, S = En(b, {
      width: p,
      height: g
    });
  }
  this.setViewRect(S.x, S.y, S.width, S.height), this.setCenter(e.get("center"), t), this.setZoom(e.get("zoom"));
}
function LPe(e, t) {
  $(t.get("geoCoord"), function(r, n) {
    e.addGeoCoord(n, r);
  });
}
var FPe = (
  /** @class */
  function() {
    function e() {
      this.dimensions = yU;
    }
    return e.prototype.create = function(t, r) {
      var n = [];
      function i(a) {
        return {
          nameProperty: a.get("nameProperty"),
          aspectScale: a.get("aspectScale"),
          projection: a.get("projection")
        };
      }
      t.eachComponent("geo", function(a, s) {
        var l = a.get("map"), u = new xB(l + s, l, ge({
          nameMap: a.get("nameMap")
        }, i(a)));
        u.zoomLimit = a.get("scaleLimit"), n.push(u), a.coordinateSystem = u, u.model = a, u.resize = EB, u.resize(a, r);
      }), t.eachSeries(function(a) {
        var s = a.get("coordinateSystem");
        if (s === "geo") {
          var l = a.get("geoIndex") || 0;
          a.coordinateSystem = n[l];
        }
      });
      var o = {};
      return t.eachSeriesByType("map", function(a) {
        if (!a.getHostGeoModel()) {
          var s = a.getMapType();
          o[s] = o[s] || [], o[s].push(a);
        }
      }), $(o, function(a, s) {
        var l = Ee(a, function(c) {
          return c.get("nameMap");
        }), u = new xB(s, s, ge({
          nameMap: zS(l)
        }, i(a[0])));
        u.zoomLimit = vn.apply(null, Ee(a, function(c) {
          return c.get("scaleLimit");
        })), n.push(u), u.resize = EB, u.resize(a[0], r), $(a, function(c) {
          c.coordinateSystem = u, LPe(u, c);
        });
      }), n;
    }, e.prototype.getFilledRegions = function(t, r, n, i) {
      for (var o = (t || []).slice(), a = nt(), s = 0; s < o.length; s++)
        a.set(o[s].name, o[s]);
      var l = nl.load(r, n, i);
      return $(l.regions, function(u) {
        var c = u.name;
        !a.get(c) && o.push({
          name: c
        });
      }), o;
    }, e;
  }()
), SU = new FPe(), NPe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n, i) {
      var o = nl.getGeoResource(r.map);
      if (o && o.type === "geoJSON") {
        var a = r.itemStyle = r.itemStyle || {};
        "color" in a || (a.color = "#eee");
      }
      this.mergeDefaultAndTheme(r, i), Gc(r, "label", ["show"]);
    }, t.prototype.optionUpdated = function() {
      var r = this, n = this.option;
      n.regions = SU.getFilledRegions(n.regions, n.map, n.nameMap, n.nameProperty);
      var i = {};
      this._optionModelMap = Jo(n.regions || [], function(o, a) {
        var s = a.name;
        return s && (o.set(s, new _r(a, r, r.ecModel)), a.selected && (i[s] = !0)), o;
      }, nt()), n.selectedMap || (n.selectedMap = i);
    }, t.prototype.getRegionModel = function(r) {
      return this._optionModelMap.get(r) || new _r(null, this, this.ecModel);
    }, t.prototype.getFormattedLabel = function(r, n) {
      var i = this.getRegionModel(r), o = n === "normal" ? i.get(["label", "formatter"]) : i.get(["emphasis", "label", "formatter"]), a = {
        name: r
      };
      if (at(o))
        return a.status = n, o(a);
      if (He(o))
        return o.replace("{a}", r ?? "");
    }, t.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, t.prototype.setCenter = function(r) {
      this.option.center = r;
    }, t.prototype.select = function(r) {
      var n = this.option, i = n.selectedMode;
      if (i) {
        i !== "multiple" && (n.selectedMap = null);
        var o = n.selectedMap || (n.selectedMap = {});
        o[r] = !0;
      }
    }, t.prototype.unSelect = function(r) {
      var n = this.option.selectedMap;
      n && (n[r] = !1);
    }, t.prototype.toggleSelected = function(r) {
      this[this.isSelected(r) ? "unSelect" : "select"](r);
    }, t.prototype.isSelected = function(r) {
      var n = this.option.selectedMap;
      return !!(n && n[r]);
    }, t.type = "geo", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
        // Default color:
        // + geoJSON: #eee
        // + geoSVG: null (use SVG original `fill`)
        // color: '#eee'
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, t;
  }(Vt)
);
function RB(e, t) {
  return e.pointToProjected ? e.pointToProjected(t) : e.pointToData(t);
}
function lA(e, t, r, n) {
  var i = e.getZoom(), o = e.getCenter(), a = t.zoom, s = e.projectedToPoint ? e.projectedToPoint(o) : e.dataToPoint(o);
  if (t.dx != null && t.dy != null && (s[0] -= t.dx, s[1] -= t.dy, e.setCenter(RB(e, s), n)), a != null) {
    if (r) {
      var l = r.min || 0, u = r.max || 1 / 0;
      a = Math.max(Math.min(i * a, u), l) / i;
    }
    e.scaleX *= a, e.scaleY *= a;
    var c = (t.originX - e.x) * (a - 1), d = (t.originY - e.y) * (a - 1);
    e.x -= c, e.y -= d, e.updateTransform(), e.setCenter(RB(e, s), n), e.setZoom(a * i);
  }
  return {
    center: e.getCenter(),
    zoom: e.getZoom()
  };
}
var kPe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.focusBlurEnabled = !0, r;
    }
    return t.prototype.init = function(r, n) {
      this._api = n;
    }, t.prototype.render = function(r, n, i, o) {
      if (this._model = r, !r.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new mU(i));
      var a = this._mapDraw;
      a.draw(r, n, i, this, o), a.group.on("click", this._handleRegionClick, this), a.group.silent = r.get("silent"), this.group.add(a.group), this.updateSelectStatus(r, n, i);
    }, t.prototype._handleRegionClick = function(r) {
      var n;
      Cc(r.target, function(i) {
        return (n = St(i).eventData) != null;
      }, !0), n && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: n.name
      });
    }, t.prototype.updateSelectStatus = function(r, n, i) {
      var o = this;
      this._mapDraw.group.traverse(function(a) {
        var s = St(a).eventData;
        if (s)
          return o._model.isSelected(s.name) ? i.enterSelect(a) : i.leaveSelect(a), !0;
      });
    }, t.prototype.findHighDownDispatchers = function(r) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(r, this._model);
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, t.type = "geo", t;
  }(zr)
);
function VPe(e, t, r) {
  nl.registerMap(e, t, r);
}
function wU(e) {
  e.registerCoordinateSystem("geo", SU), e.registerComponentModel(NPe), e.registerComponentView(kPe), e.registerImpl("registerMap", VPe), e.registerImpl("getMap", function(r) {
    return nl.getMapForUser(r);
  });
  function t(r, n) {
    n.update = "geo:updateSelectStatus", e.registerAction(n, function(i, o) {
      var a = {}, s = [];
      return o.eachComponent({
        mainType: "geo",
        query: i
      }, function(l) {
        l[r](i.name);
        var u = l.coordinateSystem;
        $(u.regions, function(d) {
          a[d.name] = l.isSelected(d.name) || !1;
        });
        var c = [];
        $(a, function(d, h) {
          a[h] && c.push(h);
        }), s.push({
          geoIndex: l.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: c
        });
      }), {
        selected: a,
        allSelected: s,
        name: i.name
      };
    });
  }
  t("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), t("select", {
    type: "geoSelect",
    event: "geoselected"
  }), t("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), e.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(r, n, i) {
    var o = r.componentType || "series";
    n.eachComponent({
      mainType: o,
      query: r
    }, function(a) {
      var s = a.coordinateSystem;
      if (s.type === "geo") {
        var l = lA(s, r, a.get("scaleLimit"), i);
        a.setCenter && a.setCenter(l.center), a.setZoom && a.setZoom(l.zoom), o === "series" && $(a.seriesGroup, function(u) {
          u.setCenter(l.center), u.setZoom(l.zoom);
        });
      }
    });
  });
}
function BPe(e) {
  Bt(wU), e.registerChartView(PPe), e.registerSeriesModel(MPe), e.registerLayout(IPe), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, APe), S9("map", e.registerAction);
}
function $Pe(e) {
  var t = e;
  t.hierNode = {
    defaultAncestor: null,
    ancestor: t,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var r = [t], n, i; n = r.pop(); )
    if (i = n.children, n.isExpand && i.length)
      for (var o = i.length, a = o - 1; a >= 0; a--) {
        var s = i[a];
        s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: a,
          thread: null
        }, r.push(s);
      }
}
function HPe(e, t) {
  var r = e.isExpand ? e.children : [], n = e.parentNode.children, i = e.hierNode.i ? n[e.hierNode.i - 1] : null;
  if (r.length) {
    WPe(e);
    var o = (r[0].hierNode.prelim + r[r.length - 1].hierNode.prelim) / 2;
    i ? (e.hierNode.prelim = i.hierNode.prelim + t(e, i), e.hierNode.modifier = e.hierNode.prelim - o) : e.hierNode.prelim = o;
  } else i && (e.hierNode.prelim = i.hierNode.prelim + t(e, i));
  e.parentNode.hierNode.defaultAncestor = jPe(e, i, e.parentNode.hierNode.defaultAncestor || n[0], t);
}
function GPe(e) {
  var t = e.hierNode.prelim + e.parentNode.hierNode.modifier;
  e.setLayout({
    x: t
  }, !0), e.hierNode.modifier += e.parentNode.hierNode.modifier;
}
function _B(e) {
  return arguments.length ? e : YPe;
}
function Bp(e, t) {
  return e -= Math.PI / 2, {
    x: t * Math.cos(e),
    y: t * Math.sin(e)
  };
}
function zPe(e, t) {
  return En(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function WPe(e) {
  for (var t = e.children, r = t.length, n = 0, i = 0; --r >= 0; ) {
    var o = t[r];
    o.hierNode.prelim += n, o.hierNode.modifier += n, i += o.hierNode.change, n += o.hierNode.shift + i;
  }
}
function jPe(e, t, r, n) {
  if (t) {
    for (var i = e, o = e, a = o.parentNode.children[0], s = t, l = i.hierNode.modifier, u = o.hierNode.modifier, c = a.hierNode.modifier, d = s.hierNode.modifier; s = vx(s), o = mx(o), s && o; ) {
      i = vx(i), a = mx(a), i.hierNode.ancestor = e;
      var h = s.hierNode.prelim + d - o.hierNode.prelim - u + n(s, o);
      h > 0 && (KPe(UPe(s, e, r), e, h), u += h, l += h), d += s.hierNode.modifier, u += o.hierNode.modifier, l += i.hierNode.modifier, c += a.hierNode.modifier;
    }
    s && !vx(i) && (i.hierNode.thread = s, i.hierNode.modifier += d - l), o && !mx(a) && (a.hierNode.thread = o, a.hierNode.modifier += u - c, r = e);
  }
  return r;
}
function vx(e) {
  var t = e.children;
  return t.length && e.isExpand ? t[t.length - 1] : e.hierNode.thread;
}
function mx(e) {
  var t = e.children;
  return t.length && e.isExpand ? t[0] : e.hierNode.thread;
}
function UPe(e, t, r) {
  return e.hierNode.ancestor.parentNode === t.parentNode ? e.hierNode.ancestor : r;
}
function KPe(e, t, r) {
  var n = r / (t.hierNode.i - e.hierNode.i);
  t.hierNode.change -= n, t.hierNode.shift += r, t.hierNode.modifier += r, t.hierNode.prelim += r, e.hierNode.change += n;
}
function YPe(e, t) {
  return e.parentNode === t.parentNode ? 1 : 2;
}
var qPe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.parentPoint = [], this.childPoints = [];
    }
    return e;
  }()
), XPe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      return e.call(this, r) || this;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new qPe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.childPoints, o = i.length, a = n.parentPoint, s = i[0], l = i[o - 1];
      if (o === 1) {
        r.moveTo(a[0], a[1]), r.lineTo(s[0], s[1]);
        return;
      }
      var u = n.orient, c = u === "TB" || u === "BT" ? 0 : 1, d = 1 - c, h = Be(n.forkPosition, 1), f = [];
      f[c] = a[c], f[d] = a[d] + (l[d] - a[d]) * h, r.moveTo(a[0], a[1]), r.lineTo(f[0], f[1]), r.moveTo(s[0], s[1]), f[c] = s[c], r.lineTo(f[0], f[1]), f[c] = l[c], r.lineTo(f[0], f[1]), r.lineTo(l[0], l[1]);
      for (var p = 1; p < o - 1; p++) {
        var g = i[p];
        r.moveTo(g[0], g[1]), f[c] = g[c], r.lineTo(f[0], f[1]);
      }
    }, t;
  }(Ht)
), ZPe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._mainGroup = new Ct(), r;
    }
    return t.prototype.init = function(r, n) {
      this._controller = new Zv(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = r.layoutInfo, s = this._mainGroup, l = r.get("layout");
      l === "radial" ? (s.x = a.x + a.width / 2, s.y = a.y + a.height / 2) : (s.x = a.x, s.y = a.y), this._updateViewCoordSys(r, i), this._updateController(r, n, i);
      var u = this._data;
      o.diff(u).add(function(c) {
        TB(o, c) && PB(o, c, null, s, r);
      }).update(function(c, d) {
        var h = u.getItemGraphicEl(d);
        if (!TB(o, c)) {
          h && DB(u, d, h, s, r);
          return;
        }
        PB(o, c, h, s, r);
      }).remove(function(c) {
        var d = u.getItemGraphicEl(c);
        d && DB(u, c, d, s, r);
      }).execute(), this._nodeScaleRatio = r.get("nodeScaleRatio"), this._updateNodeAndLinkScale(r), r.get("expandAndCollapse") === !0 && o.eachItemGraphicEl(function(c, d) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: r.id,
            dataIndex: d
          });
        });
      }), this._data = o;
    }, t.prototype._updateViewCoordSys = function(r, n) {
      var i = r.getData(), o = [];
      i.each(function(d) {
        var h = i.getItemLayout(d);
        h && !isNaN(h.x) && !isNaN(h.y) && o.push([+h.x, +h.y]);
      });
      var a = [], s = [];
      rw(o, a, s);
      var l = this._min, u = this._max;
      s[0] - a[0] === 0 && (a[0] = l ? l[0] : a[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - a[1] === 0 && (a[1] = l ? l[1] : a[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var c = r.coordinateSystem = new Qv();
      c.zoomLimit = r.get("scaleLimit"), c.setBoundingRect(a[0], a[1], s[0] - a[0], s[1] - a[1]), c.setCenter(r.get("center"), n), c.setZoom(r.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = a, this._max = s;
    }, t.prototype._updateController = function(r, n, i) {
      var o = this, a = this._controller, s = this._controllerHost, l = this.group;
      a.setPointerChecker(function(u, c, d) {
        var h = l.getBoundingRect();
        return h.applyTransform(l.transform), h.contain(c, d) && !Tw(u, i, r);
      }), a.enable(r.get("roam")), s.zoomLimit = r.get("scaleLimit"), s.zoom = r.coordinateSystem.getZoom(), a.off("pan").off("zoom").on("pan", function(u) {
        oA(s, u.dx, u.dy), i.dispatchAction({
          seriesId: r.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        aA(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: r.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), o._updateNodeAndLinkScale(r), i.updateLabelLayout();
      });
    }, t.prototype._updateNodeAndLinkScale = function(r) {
      var n = r.getData(), i = this._getNodeGlobalScale(r);
      n.eachItemGraphicEl(function(o, a) {
        o.setSymbolScale(i);
      });
    }, t.prototype._getNodeGlobalScale = function(r) {
      var n = r.coordinateSystem;
      if (n.type !== "view")
        return 1;
      var i = this._nodeScaleRatio, o = n.scaleX || 1, a = n.getZoom(), s = (a - 1) * i + 1;
      return s / o;
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, t.type = "tree", t;
  }(br)
);
function TB(e, t) {
  var r = e.getItemLayout(t);
  return r && !isNaN(r.x) && !isNaN(r.y);
}
function PB(e, t, r, n, i) {
  var o = !r, a = e.tree.getNodeByDataIndex(t), s = a.getModel(), l = a.getVisual("style").fill, u = a.isExpand === !1 && a.children.length !== 0 ? l : "#fff", c = e.tree.root, d = a.parentNode === c ? a : a.parentNode || a, h = e.getItemGraphicEl(d.dataIndex), f = d.getLayout(), p = h ? {
    x: h.__oldX,
    y: h.__oldY,
    rawX: h.__radialOldRawX,
    rawY: h.__radialOldRawY
  } : f, g = a.getLayout();
  o ? (r = new jv(e, t, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), r.x = p.x, r.y = p.y) : r.updateData(e, t, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), r.__radialOldRawX = r.__radialRawX, r.__radialOldRawY = r.__radialRawY, r.__radialRawX = g.rawX, r.__radialRawY = g.rawY, n.add(r), e.setItemGraphicEl(t, r), r.__oldX = r.x, r.__oldY = r.y, ur(r, {
    x: g.x,
    y: g.y
  }, i);
  var v = r.getSymbolPath();
  if (i.get("layout") === "radial") {
    var m = c.children[0], y = m.getLayout(), C = m.children.length, S = void 0, b = void 0;
    if (g.x === y.x && a.isExpand === !0 && m.children.length) {
      var w = {
        x: (m.children[0].getLayout().x + m.children[C - 1].getLayout().x) / 2,
        y: (m.children[0].getLayout().y + m.children[C - 1].getLayout().y) / 2
      };
      S = Math.atan2(w.y - y.y, w.x - y.x), S < 0 && (S = Math.PI * 2 + S), b = w.x < y.x, b && (S = S - Math.PI);
    } else
      S = Math.atan2(g.y - y.y, g.x - y.x), S < 0 && (S = Math.PI * 2 + S), a.children.length === 0 || a.children.length !== 0 && a.isExpand === !1 ? (b = g.x < y.x, b && (S = S - Math.PI)) : (b = g.x > y.x, b || (S = S - Math.PI));
    var x = b ? "left" : "right", R = s.getModel("label"), _ = R.get("rotate"), T = _ * (Math.PI / 180), P = v.getTextContent();
    P && (v.setTextConfig({
      position: R.get("position") || x,
      rotation: _ == null ? -S : T,
      origin: "center"
    }), P.setStyle("verticalAlign", "middle"));
  }
  var D = s.get(["emphasis", "focus"]), O = D === "relative" ? Vg(a.getAncestorsIndices(), a.getDescendantIndices()) : D === "ancestor" ? a.getAncestorsIndices() : D === "descendant" ? a.getDescendantIndices() : null;
  O && (St(r).focus = O), QPe(i, a, c, r, p, f, g, n), r.__edge && (r.onHoverStateChange = function(A) {
    if (A !== "blur") {
      var F = a.parentNode && e.getItemGraphicEl(a.parentNode.dataIndex);
      F && F.hoverState === kv || lC(r.__edge, A);
    }
  });
}
function QPe(e, t, r, n, i, o, a, s) {
  var l = t.getModel(), u = e.get("edgeShape"), c = e.get("layout"), d = e.getOrient(), h = e.get(["lineStyle", "curveness"]), f = e.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), g = n.__edge;
  if (u === "curve")
    t.parentNode && t.parentNode !== r && (g || (g = n.__edge = new Bv({
      shape: CT(c, d, h, i, i)
    })), ur(g, {
      shape: CT(c, d, h, o, a)
    }, e));
  else if (u === "polyline") {
    if (c === "orthogonal") {
      if (t !== r && t.children && t.children.length !== 0 && t.isExpand === !0) {
        for (var v = t.children, m = [], y = 0; y < v.length; y++) {
          var C = v[y].getLayout();
          m.push([C.x, C.y]);
        }
        g || (g = n.__edge = new XPe({
          shape: {
            parentPoint: [a.x, a.y],
            childPoints: [[a.x, a.y]],
            orient: d,
            forkPosition: f
          }
        })), ur(g, {
          shape: {
            parentPoint: [a.x, a.y],
            childPoints: m
          }
        }, e);
      }
    } else if (process.env.NODE_ENV !== "production")
      throw new Error("The polyline edgeShape can only be used in orthogonal layout");
  }
  g && !(u === "polyline" && !t.isExpand) && (g.useStyle(ut({
    strokeNoScale: !0,
    fill: null
  }, p)), ti(g, l, "lineStyle"), jc(g), s.add(g));
}
function MB(e, t, r, n, i) {
  var o = t.tree.root, a = bU(o, e), s = a.source, l = a.sourceLayout, u = t.getItemGraphicEl(e.dataIndex);
  if (u) {
    var c = t.getItemGraphicEl(s.dataIndex), d = c.__edge, h = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? d : void 0), f = n.get("edgeShape"), p = n.get("layout"), g = n.get("orient"), v = n.get(["lineStyle", "curveness"]);
    h && (f === "curve" ? au(h, {
      shape: CT(p, g, v, l, l),
      style: {
        opacity: 0
      }
    }, n, {
      cb: function() {
        r.remove(h);
      },
      removeOpt: i
    }) : f === "polyline" && n.get("layout") === "orthogonal" && au(h, {
      shape: {
        parentPoint: [l.x, l.y],
        childPoints: [[l.x, l.y]]
      },
      style: {
        opacity: 0
      }
    }, n, {
      cb: function() {
        r.remove(h);
      },
      removeOpt: i
    }));
  }
}
function bU(e, t) {
  for (var r = t.parentNode === e ? t : t.parentNode || t, n; n = r.getLayout(), n == null; )
    r = r.parentNode === e ? r : r.parentNode || r;
  return {
    source: r,
    sourceLayout: n
  };
}
function DB(e, t, r, n, i) {
  var o = e.tree.getNodeByDataIndex(t), a = e.tree.root, s = bU(a, o).sourceLayout, l = {
    duration: i.get("animationDurationUpdate"),
    easing: i.get("animationEasingUpdate")
  };
  au(r, {
    x: s.x + 1,
    y: s.y + 1
  }, i, {
    cb: function() {
      n.remove(r), e.setItemGraphicEl(t, null);
    },
    removeOpt: l
  }), r.fadeOut(null, e.hostModel, {
    fadeLabel: !0,
    animation: l
  }), o.children.forEach(function(u) {
    MB(u, e, n, i, l);
  }), MB(o, e, n, i, l);
}
function CT(e, t, r, n, i) {
  var o, a, s, l, u, c, d, h;
  if (e === "radial") {
    u = n.rawX, d = n.rawY, c = i.rawX, h = i.rawY;
    var f = Bp(u, d), p = Bp(u, d + (h - d) * r), g = Bp(c, h + (d - h) * r), v = Bp(c, h);
    return {
      x1: f.x || 0,
      y1: f.y || 0,
      x2: v.x || 0,
      y2: v.y || 0,
      cpx1: p.x || 0,
      cpy1: p.y || 0,
      cpx2: g.x || 0,
      cpy2: g.y || 0
    };
  } else
    u = n.x, d = n.y, c = i.x, h = i.y, (t === "LR" || t === "RL") && (o = u + (c - u) * r, a = d, s = c + (u - c) * r, l = h), (t === "TB" || t === "BT") && (o = u, a = d + (h - d) * r, s = c, l = h + (d - h) * r);
  return {
    x1: u,
    y1: d,
    x2: c,
    y2: h,
    cpx1: o,
    cpy1: a,
    cpx2: s,
    cpy2: l
  };
}
var Yo = ar();
function xU(e) {
  var t = e.mainData, r = e.datas;
  r || (r = {
    main: t
  }, e.datasAttr = {
    main: "data"
  }), e.datas = e.mainData = null, EU(t, r, e), $(r, function(n) {
    $(t.TRANSFERABLE_METHODS, function(i) {
      n.wrapMethod(i, _t(JPe, e));
    });
  }), t.wrapMethod("cloneShallow", _t(tMe, e)), $(t.CHANGABLE_METHODS, function(n) {
    t.wrapMethod(n, _t(eMe, e));
  }), ct(r[t.dataType] === t);
}
function JPe(e, t) {
  if (iMe(this)) {
    var r = ge({}, Yo(this).datas);
    r[this.dataType] = t, EU(t, r, e);
  } else
    uA(t, this.dataType, Yo(this).mainData, e);
  return t;
}
function eMe(e, t) {
  return e.struct && e.struct.update(), t;
}
function tMe(e, t) {
  return $(Yo(t).datas, function(r, n) {
    r !== t && uA(r.cloneShallow(), n, t, e);
  }), t;
}
function rMe(e) {
  var t = Yo(this).mainData;
  return e == null || t == null ? t : Yo(t).datas[e];
}
function nMe() {
  var e = Yo(this).mainData;
  return e == null ? [{
    data: e
  }] : Ee(jt(Yo(e).datas), function(t) {
    return {
      type: t,
      data: Yo(e).datas[t]
    };
  });
}
function iMe(e) {
  return Yo(e).mainData === e;
}
function EU(e, t, r) {
  Yo(e).datas = {}, $(t, function(n, i) {
    uA(n, i, e, r);
  });
}
function uA(e, t, r, n) {
  Yo(r).datas[t] = e, Yo(e).mainData = r, e.dataType = t, n.struct && (e[n.structAttr] = n.struct, n.struct[n.datasAttr[t]] = e), e.getLinkedData = rMe, e.getLinkedDataAll = nMe;
}
var oMe = (
  /** @class */
  function() {
    function e(t, r) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = t || "", this.hostTree = r;
    }
    return e.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, e.prototype.eachNode = function(t, r, n) {
      at(t) && (n = r, r = t, t = null), t = t || {}, He(t) && (t = {
        order: t
      });
      var i = t.order || "preorder", o = this[t.attr || "children"], a;
      i === "preorder" && (a = r.call(n, this));
      for (var s = 0; !a && s < o.length; s++)
        o[s].eachNode(t, r, n);
      i === "postorder" && r.call(n, this);
    }, e.prototype.updateDepthAndHeight = function(t) {
      var r = 0;
      this.depth = t;
      for (var n = 0; n < this.children.length; n++) {
        var i = this.children[n];
        i.updateDepthAndHeight(t + 1), i.height > r && (r = i.height);
      }
      this.height = r + 1;
    }, e.prototype.getNodeById = function(t) {
      if (this.getId() === t)
        return this;
      for (var r = 0, n = this.children, i = n.length; r < i; r++) {
        var o = n[r].getNodeById(t);
        if (o)
          return o;
      }
    }, e.prototype.contains = function(t) {
      if (t === this)
        return !0;
      for (var r = 0, n = this.children, i = n.length; r < i; r++) {
        var o = n[r].contains(t);
        if (o)
          return o;
      }
    }, e.prototype.getAncestors = function(t) {
      for (var r = [], n = t ? this : this.parentNode; n; )
        r.push(n), n = n.parentNode;
      return r.reverse(), r;
    }, e.prototype.getAncestorsIndices = function() {
      for (var t = [], r = this; r; )
        t.push(r.dataIndex), r = r.parentNode;
      return t.reverse(), t;
    }, e.prototype.getDescendantIndices = function() {
      var t = [];
      return this.eachNode(function(r) {
        t.push(r.dataIndex);
      }), t;
    }, e.prototype.getValue = function(t) {
      var r = this.hostTree.data;
      return r.getStore().get(r.getDimensionIndex(t || "value"), this.dataIndex);
    }, e.prototype.setLayout = function(t, r) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, r);
    }, e.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var r = this.hostTree, n = r.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, e.prototype.setVisual = function(t, r) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, r);
    }, e.prototype.getVisual = function(t) {
      return this.hostTree.data.getItemVisual(this.dataIndex, t);
    }, e.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, e.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, e.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var t = this.parentNode.children, r = 0; r < t.length; ++r)
          if (t[r] === this)
            return r;
        return -1;
      }
      return -1;
    }, e.prototype.isAncestorOf = function(t) {
      for (var r = t.parentNode; r; ) {
        if (r === this)
          return !0;
        r = r.parentNode;
      }
      return !1;
    }, e.prototype.isDescendantOf = function(t) {
      return t !== this && t.isAncestorOf(this);
    }, e;
  }()
), cA = (
  /** @class */
  function() {
    function e(t) {
      this.type = "tree", this._nodes = [], this.hostModel = t;
    }
    return e.prototype.eachNode = function(t, r, n) {
      this.root.eachNode(t, r, n);
    }, e.prototype.getNodeByDataIndex = function(t) {
      var r = this.data.getRawIndex(t);
      return this._nodes[r];
    }, e.prototype.getNodeById = function(t) {
      return this.root.getNodeById(t);
    }, e.prototype.update = function() {
      for (var t = this.data, r = this._nodes, n = 0, i = r.length; n < i; n++)
        r[n].dataIndex = -1;
      for (var n = 0, i = t.count(); n < i; n++)
        r[t.getRawIndex(n)].dataIndex = n;
    }, e.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, e.createTree = function(t, r, n) {
      var i = new e(r), o = [], a = 1;
      s(t);
      function s(c, d) {
        var h = c.value;
        a = Math.max(a, be(h) ? h.length : 1), o.push(c);
        var f = new oMe(In(c.name, ""), i);
        d ? aMe(f, d) : i.root = f, i._nodes.push(f);
        var p = c.children;
        if (p)
          for (var g = 0; g < p.length; g++)
            s(p[g], f);
      }
      i.root.updateDepthAndHeight(0);
      var l = Tf(o, {
        coordDimensions: ["value"],
        dimensionsCount: a
      }).dimensions, u = new di(l, r);
      return u.initData(o), n && n(u), xU({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, e;
  }()
);
function aMe(e, t) {
  var r = t.children;
  e.parentNode !== t && (r.push(e), e.parentNode = t);
}
function iv(e, t, r) {
  if (e && Ft(t, e.type) >= 0) {
    var n = r.getData().tree.root, i = e.targetNode;
    if (He(i) && (i = n.getNodeById(i)), i && n.contains(i))
      return {
        node: i
      };
    var o = e.targetNodeId;
    if (o != null && (i = n.getNodeById(o)))
      return {
        node: i
      };
  }
}
function RU(e) {
  for (var t = []; e; )
    e = e.parentNode, e && t.push(e);
  return t.reverse();
}
function dA(e, t) {
  var r = RU(e);
  return Ft(r, t) >= 0;
}
function Mw(e, t) {
  for (var r = []; e; ) {
    var n = e.dataIndex;
    r.push({
      name: e.name,
      dataIndex: n,
      value: t.getRawValue(n)
    }), e = e.parentNode;
  }
  return r.reverse(), r;
}
var sMe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.hasSymbolVisual = !0, r.ignoreStyleOnData = !0, r;
    }
    return t.prototype.getInitialData = function(r) {
      var n = {
        name: r.name,
        children: r.data
      }, i = r.leaves || {}, o = new _r(i, this, this.ecModel), a = cA.createTree(n, this, s);
      function s(d) {
        d.wrapMethod("getItemModel", function(h, f) {
          var p = a.getNodeByDataIndex(f);
          return p && p.children.length && p.isExpand || (h.parentModel = o), h;
        });
      }
      var l = 0;
      a.eachNode("preorder", function(d) {
        d.depth > l && (l = d.depth);
      });
      var u = r.expandAndCollapse, c = u && r.initialTreeDepth >= 0 ? r.initialTreeDepth : l;
      return a.root.eachNode("preorder", function(d) {
        var h = d.hostTree.data.getRawDataItem(d.dataIndex);
        d.isExpand = h && h.collapsed != null ? !h.collapsed : d.depth <= c;
      }), a.data;
    }, t.prototype.getOrient = function() {
      var r = this.get("orient");
      return r === "horizontal" ? r = "LR" : r === "vertical" && (r = "TB"), r;
    }, t.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, t.prototype.setCenter = function(r) {
      this.option.center = r;
    }, t.prototype.formatTooltip = function(r, n, i) {
      for (var o = this.getData().tree, a = o.root.children[0], s = o.getNodeByDataIndex(r), l = s.getValue(), u = s.name; s && s !== a; )
        u = s.parentNode.name + "." + u, s = s.parentNode;
      return Hn("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, t.prototype.getDataParams = function(r) {
      var n = e.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(r);
      return n.treeAncestors = Mw(i, this), n.collapsed = !i.isExpand, n;
    }, t.type = "series.tree", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, t;
  }(Pr)
);
function lMe(e, t, r) {
  for (var n = [e], i = [], o; o = n.pop(); )
    if (i.push(o), o.isExpand) {
      var a = o.children;
      if (a.length)
        for (var s = 0; s < a.length; s++)
          n.push(a[s]);
    }
  for (; o = i.pop(); )
    t(o, r);
}
function vp(e, t) {
  for (var r = [e], n; n = r.pop(); )
    if (t(n), n.isExpand) {
      var i = n.children;
      if (i.length)
        for (var o = i.length - 1; o >= 0; o--)
          r.push(i[o]);
    }
}
function uMe(e, t) {
  e.eachSeriesByType("tree", function(r) {
    cMe(r, t);
  });
}
function cMe(e, t) {
  var r = zPe(e, t);
  e.layoutInfo = r;
  var n = e.get("layout"), i = 0, o = 0, a = null;
  n === "radial" ? (i = 2 * Math.PI, o = Math.min(r.height, r.width) / 2, a = _B(function(C, S) {
    return (C.parentNode === S.parentNode ? 1 : 2) / C.depth;
  })) : (i = r.width, o = r.height, a = _B());
  var s = e.getData().tree.root, l = s.children[0];
  if (l) {
    $Pe(s), lMe(l, HPe, a), s.hierNode.modifier = -l.hierNode.prelim, vp(l, GPe);
    var u = l, c = l, d = l;
    vp(l, function(C) {
      var S = C.getLayout().x;
      S < u.getLayout().x && (u = C), S > c.getLayout().x && (c = C), C.depth > d.depth && (d = C);
    });
    var h = u === c ? 1 : a(u, c) / 2, f = h - u.getLayout().x, p = 0, g = 0, v = 0, m = 0;
    if (n === "radial")
      p = i / (c.getLayout().x + h + f), g = o / (d.depth - 1 || 1), vp(l, function(C) {
        v = (C.getLayout().x + f) * p, m = (C.depth - 1) * g;
        var S = Bp(v, m);
        C.setLayout({
          x: S.x,
          y: S.y,
          rawX: v,
          rawY: m
        }, !0);
      });
    else {
      var y = e.getOrient();
      y === "RL" || y === "LR" ? (g = o / (c.getLayout().x + h + f), p = i / (d.depth - 1 || 1), vp(l, function(C) {
        m = (C.getLayout().x + f) * g, v = y === "LR" ? (C.depth - 1) * p : i - (C.depth - 1) * p, C.setLayout({
          x: v,
          y: m
        }, !0);
      })) : (y === "TB" || y === "BT") && (p = i / (c.getLayout().x + h + f), g = o / (d.depth - 1 || 1), vp(l, function(C) {
        v = (C.getLayout().x + f) * p, m = y === "TB" ? (C.depth - 1) * g : o - (C.depth - 1) * g, C.setLayout({
          x: v,
          y: m
        }, !0);
      }));
    }
  }
}
function dMe(e) {
  e.eachSeriesByType("tree", function(t) {
    var r = t.getData(), n = r.tree;
    n.eachNode(function(i) {
      var o = i.getModel(), a = o.getModel("itemStyle").getItemStyle(), s = r.ensureUniqueItemVisual(i.dataIndex, "style");
      ge(s, a);
    });
  });
}
function hMe(e) {
  e.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(t, r) {
    r.eachComponent({
      mainType: "series",
      subType: "tree",
      query: t
    }, function(n) {
      var i = t.dataIndex, o = n.getData().tree, a = o.getNodeByDataIndex(i);
      a.isExpand = !a.isExpand;
    });
  }), e.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(t, r, n) {
    r.eachComponent({
      mainType: "series",
      subType: "tree",
      query: t
    }, function(i) {
      var o = i.coordinateSystem, a = lA(o, t, void 0, n);
      i.setCenter && i.setCenter(a.center), i.setZoom && i.setZoom(a.zoom);
    });
  });
}
function fMe(e) {
  e.registerChartView(ZPe), e.registerSeriesModel(sMe), e.registerLayout(uMe), e.registerVisual(dMe), hMe(e);
}
var AB = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function pMe(e) {
  for (var t = 0; t < AB.length; t++)
    e.registerAction({
      type: AB[t],
      update: "updateView"
    }, un);
  e.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(r, n) {
    n.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: r
    }, i);
    function i(o, a) {
      var s = ["treemapZoomToNode", "treemapRootToNode"], l = iv(r, s, o);
      if (l) {
        var u = o.getViewRoot();
        u && (r.direction = dA(u, l.node) ? "rollUp" : "drillDown"), o.resetViewRoot(l.node);
      }
    }
  });
}
function _U(e) {
  var t = e.getData(), r = t.tree, n = {};
  r.eachNode(function(i) {
    for (var o = i; o && o.depth > 1; )
      o = o.parentNode;
    var a = K_(e.ecModel, o.name || o.dataIndex + "", n);
    i.setVisual("decal", a);
  });
}
var gMe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.preventUsingHoverLayer = !0, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      var i = {
        name: r.name,
        children: r.data
      };
      TU(i);
      var o = r.levels || [], a = this.designatedVisualItemStyle = {}, s = new _r({
        itemStyle: a
      }, this, n);
      o = r.levels = vMe(o, n);
      var l = Ee(o || [], function(d) {
        return new _r(d, s, n);
      }, this), u = cA.createTree(i, this, c);
      function c(d) {
        d.wrapMethod("getItemModel", function(h, f) {
          var p = u.getNodeByDataIndex(f), g = p ? l[p.depth] : null;
          return h.parentModel = g || s, h;
        });
      }
      return u.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = this.getRawValue(r), s = o.getName(r);
      return Hn("nameValue", {
        name: s,
        value: a
      });
    }, t.prototype.getDataParams = function(r) {
      var n = e.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(r);
      return n.treeAncestors = Mw(i, this), n.treePathInfo = n.treeAncestors, n;
    }, t.prototype.setLayoutInfo = function(r) {
      this.layoutInfo = this.layoutInfo || {}, ge(this.layoutInfo, r);
    }, t.prototype.mapIdToIndex = function(r) {
      var n = this._idIndexMap;
      n || (n = this._idIndexMap = nt(), this._idIndexMapCount = 0);
      var i = n.get(r);
      return i == null && n.set(r, i = this._idIndexMapCount++), i;
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(r) {
      r ? this._viewRoot = r : r = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!r || r !== n && !n.contains(r)) && (this._viewRoot = n);
    }, t.prototype.enableAriaDecal = function() {
      _U(this);
    }, t.type = "series.treemap", t.layoutMode = "box", t.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "",
      // to align specialized icon. 
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: !0,
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        top: "bottom",
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
            // '#5793f3',
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: "#fff",
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, t;
  }(Pr)
);
function TU(e) {
  var t = 0;
  $(e.children, function(n) {
    TU(n);
    var i = n.value;
    be(i) && (i = i[0]), t += i;
  });
  var r = e.value;
  be(r) && (r = r[0]), (r == null || isNaN(r)) && (r = t), r < 0 && (r = 0), be(e.value) ? e.value[0] = r : e.value = r;
}
function vMe(e, t) {
  var r = Tr(t.get("color")), n = Tr(t.get(["aria", "decal", "decals"]));
  if (r) {
    e = e || [];
    var i, o;
    $(e, function(s) {
      var l = new _r(s), u = l.get("color"), c = l.get("decal");
      (l.get(["itemStyle", "color"]) || u && u !== "none") && (i = !0), (l.get(["itemStyle", "decal"]) || c && c !== "none") && (o = !0);
    });
    var a = e[0] || (e[0] = {});
    return i || (a.color = r.slice()), !o && n && (a.decal = n.slice()), e;
  }
}
var mMe = 8, IB = 8, yx = 5, yMe = (
  /** @class */
  function() {
    function e(t) {
      this.group = new Ct(), t.add(this.group);
    }
    return e.prototype.render = function(t, r, n, i) {
      var o = t.getModel("breadcrumb"), a = this.group;
      if (a.removeAll(), !(!o.get("show") || !n)) {
        var s = o.getModel("itemStyle"), l = o.getModel("emphasis"), u = s.getModel("textStyle"), c = l.getModel(["itemStyle", "textStyle"]), d = {
          pos: {
            left: o.get("left"),
            right: o.get("right"),
            top: o.get("top"),
            bottom: o.get("bottom")
          },
          box: {
            width: r.getWidth(),
            height: r.getHeight()
          },
          emptyItemWidth: o.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(n, d, u), this._renderContent(t, d, s, l, u, c, i), gw(a, d.pos, d.box);
      }
    }, e.prototype._prepare = function(t, r, n) {
      for (var i = t; i; i = i.parentNode) {
        var o = In(i.getModel().get("name"), ""), a = n.getTextRect(o), s = Math.max(a.width + mMe * 2, r.emptyItemWidth);
        r.totalWidth += s + IB, r.renderList.push({
          node: i,
          text: o,
          width: s
        });
      }
    }, e.prototype._renderContent = function(t, r, n, i, o, a, s) {
      for (var l = 0, u = r.emptyItemWidth, c = t.get(["breadcrumb", "height"]), d = abe(r.pos, r.box), h = r.totalWidth, f = r.renderList, p = i.getModel("itemStyle").getItemStyle(), g = f.length - 1; g >= 0; g--) {
        var v = f[g], m = v.node, y = v.width, C = v.text;
        h > d.width && (h -= y - u, y = u, C = null);
        var S = new Li({
          shape: {
            points: CMe(l, 0, y, c, g === f.length - 1, g === 0)
          },
          style: ut(n.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new ir({
            style: Vr(o, {
              text: C
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: gf * 1e4,
          onclick: _t(s, m)
        });
        S.disableLabelAnimation = !0, S.getTextContent().ensureState("emphasis").style = Vr(a, {
          text: C
        }), S.ensureState("emphasis").style = p, sn(S, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(S), SMe(S, t, m), l += y + IB;
      }
    }, e.prototype.remove = function() {
      this.group.removeAll();
    }, e;
  }()
);
function CMe(e, t, r, n, i, o) {
  var a = [[i ? e : e - yx, t], [e + r, t], [e + r, t + n], [i ? e : e - yx, t + n]];
  return !o && a.splice(2, 0, [e + r + yx, t + n / 2]), !i && a.push([e, t + n / 2]), a;
}
function SMe(e, t, r) {
  St(e).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: t.componentIndex,
    seriesIndex: t.seriesIndex,
    seriesName: t.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: r && r.dataIndex,
      name: r && r.name
    },
    treePathInfo: r && Mw(r, t)
  };
}
var wMe = (
  /** @class */
  function() {
    function e() {
      this._storage = [], this._elExistsMap = {};
    }
    return e.prototype.add = function(t, r, n, i, o) {
      return this._elExistsMap[t.id] ? !1 : (this._elExistsMap[t.id] = !0, this._storage.push({
        el: t,
        target: r,
        duration: n,
        delay: i,
        easing: o
      }), !0);
    }, e.prototype.finished = function(t) {
      return this._finishedCallback = t, this;
    }, e.prototype.start = function() {
      for (var t = this, r = this._storage.length, n = function() {
        r--, r <= 0 && (t._storage.length = 0, t._elExistsMap = {}, t._finishedCallback && t._finishedCallback());
      }, i = 0, o = this._storage.length; i < o; i++) {
        var a = this._storage[i];
        a.el.animateTo(a.target, {
          duration: a.duration,
          delay: a.delay,
          easing: a.easing,
          setToFinal: !0,
          done: n,
          aborted: n
        });
      }
      return this;
    }, e;
  }()
);
function bMe() {
  return new wMe();
}
var ST = Ct, OB = or, LB = 3, FB = "label", NB = "upperLabel", xMe = gf * 10, EMe = gf * 2, RMe = gf * 3, ec = Wc([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), kB = function(e) {
  var t = ec(e);
  return t.stroke = t.fill = t.lineWidth = null, t;
}, LC = ar(), _Me = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._state = "ready", r._storage = mp(), r;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = n.findComponents({
        mainType: "series",
        subType: "treemap",
        query: o
      });
      if (!(Ft(a, r) < 0)) {
        this.seriesModel = r, this.api = i, this.ecModel = n;
        var s = ["treemapZoomToNode", "treemapRootToNode"], l = iv(o, s, r), u = o && o.type, c = r.layoutInfo, d = !this._oldTree, h = this._storage, f = u === "treemapRootToNode" && l && h ? {
          rootNodeGroup: h.nodeGroup[l.node.getRawIndex()],
          direction: o.direction
        } : null, p = this._giveContainerGroup(c), g = r.get("animation"), v = this._doRender(p, r, f);
        g && !d && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, v, r, f) : v.renderFinally(), this._resetController(i), this._renderBreadcrumb(r, i, l);
      }
    }, t.prototype._giveContainerGroup = function(r) {
      var n = this._containerGroup;
      return n || (n = this._containerGroup = new ST(), this._initEvents(n), this.group.add(n)), n.x = r.x, n.y = r.y, n;
    }, t.prototype._doRender = function(r, n, i) {
      var o = n.getData().tree, a = this._oldTree, s = mp(), l = mp(), u = this._storage, c = [];
      function d(y, C, S, b) {
        return TMe(n, l, u, i, s, c, y, C, S, b);
      }
      g(o.root ? [o.root] : [], a && a.root ? [a.root] : [], r, o === a || !a, 0);
      var h = v(u);
      if (this._oldTree = o, this._storage = l, this._controllerHost) {
        var f = this.seriesModel.layoutInfo, p = o.root.getLayout();
        p.width === f.width && p.height === f.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: s,
        willDeleteEls: h,
        renderFinally: m
      };
      function g(y, C, S, b, w) {
        b ? (C = y, $(y, function(_, T) {
          !_.isRemoved() && R(T, T);
        })) : new el(C, y, x, x).add(R).update(R).remove(_t(R, null)).execute();
        function x(_) {
          return _.getId();
        }
        function R(_, T) {
          var P = _ != null ? y[_] : null, D = T != null ? C[T] : null, O = d(P, D, S, w);
          O && g(P && P.viewChildren || [], D && D.viewChildren || [], O, b, w + 1);
        }
      }
      function v(y) {
        var C = mp();
        return y && $(y, function(S, b) {
          var w = C[b];
          $(S, function(x) {
            x && (w.push(x), LC(x).willDelete = !0);
          });
        }), C;
      }
      function m() {
        $(h, function(y) {
          $(y, function(C) {
            C.parent && C.parent.remove(C);
          });
        }), $(c, function(y) {
          y.invisible = !0, y.dirty();
        });
      }
    }, t.prototype._doAnimation = function(r, n, i, o) {
      var a = i.get("animationDurationUpdate"), s = i.get("animationEasing"), l = (at(a) ? 0 : a) || 0, u = (at(s) ? null : s) || "cubicOut", c = bMe();
      $(n.willDeleteEls, function(d, h) {
        $(d, function(f, p) {
          if (!f.invisible) {
            var g = f.parent, v, m = LC(g);
            if (o && o.direction === "drillDown")
              v = g === o.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: m.nodeWidth,
                  height: m.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var y = 0, C = 0;
              m.willDelete || (y = m.nodeWidth / 2, C = m.nodeHeight / 2), v = h === "nodeGroup" ? {
                x: y,
                y: C,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: C,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            v && c.add(f, v, l, 0, u);
          }
        });
      }), $(this._storage, function(d, h) {
        $(d, function(f, p) {
          var g = n.lastsForAnimation[h][p], v = {};
          g && (f instanceof Ct ? g.oldX != null && (v.x = f.x, v.y = f.y, f.x = g.oldX, f.y = g.oldY) : (g.oldShape && (v.shape = ge({}, f.shape), f.setShape(g.oldShape)), g.fadein ? (f.setStyle("opacity", 0), v.style = {
            opacity: 1
          }) : f.style.opacity !== 1 && (v.style = {
            opacity: 1
          })), c.add(f, v, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(je(function() {
        this._state = "ready", n.renderFinally();
      }, this)).start();
    }, t.prototype._resetController = function(r) {
      var n = this._controller, i = this._controllerHost;
      i || (this._controllerHost = {
        target: this.group
      }, i = this._controllerHost), n || (n = this._controller = new Zv(r.getZr()), n.enable(this.seriesModel.get("roam")), i.zoomLimit = this.seriesModel.get("scaleLimit"), i.zoom = this.seriesModel.get("zoom"), n.on("pan", je(this._onPan, this)), n.on("zoom", je(this._onZoom, this)));
      var o = new At(0, 0, r.getWidth(), r.getHeight());
      n.setPointerChecker(function(a, s, l) {
        return o.contain(s, l);
      });
    }, t.prototype._clearController = function() {
      var r = this._controller;
      this._controllerHost = null, r && (r.dispose(), r = null);
    }, t.prototype._onPan = function(r) {
      if (this._state !== "animating" && (Math.abs(r.dx) > LB || Math.abs(r.dy) > LB)) {
        var n = this.seriesModel.getData().tree.root;
        if (!n)
          return;
        var i = n.getLayout();
        if (!i)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + r.dx,
            y: i.y + r.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, t.prototype._onZoom = function(r) {
      var n = r.originX, i = r.originY, o = r.scale;
      if (this._state !== "animating") {
        var a = this.seriesModel.getData().tree.root;
        if (!a)
          return;
        var s = a.getLayout();
        if (!s)
          return;
        var l = new At(s.x, s.y, s.width, s.height), u = null, c = this._controllerHost;
        u = c.zoomLimit;
        var d = c.zoom = c.zoom || 1;
        if (d *= o, u) {
          var h = u.min || 0, f = u.max || 1 / 0;
          d = Math.max(Math.min(f, d), h);
        }
        var p = d / c.zoom;
        c.zoom = d;
        var g = this.seriesModel.layoutInfo;
        n -= g.x, i -= g.y;
        var v = Zi();
        Oa(v, v, [-n, -i]), KS(v, v, [p, p]), Oa(v, v, [n, i]), l.applyTransform(v), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: l.x,
            y: l.y,
            width: l.width,
            height: l.height
          }
        });
      }
    }, t.prototype._initEvents = function(r) {
      var n = this;
      r.on("click", function(i) {
        if (n._state === "ready") {
          var o = n.seriesModel.get("nodeClick", !0);
          if (o) {
            var a = n.findTarget(i.offsetX, i.offsetY);
            if (a) {
              var s = a.node;
              if (s.getLayout().isLeafRoot)
                n._rootToNode(a);
              else if (o === "zoomToNode")
                n._zoomToNode(a);
              else if (o === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", !0), c = l.get("target", !0) || "blank";
                u && pC(u, c);
              }
            }
          }
        }
      }, this);
    }, t.prototype._renderBreadcrumb = function(r, n, i) {
      var o = this;
      i || (i = r.get("leafDepth", !0) != null ? {
        node: r.getViewRoot()
      } : this.findTarget(n.getWidth() / 2, n.getHeight() / 2), i || (i = {
        node: r.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new yMe(this.group))).render(r, n, i.node, function(a) {
        o._state !== "animating" && (dA(r.getViewRoot(), a) ? o._rootToNode({
          node: a
        }) : o._zoomToNode({
          node: a
        }));
      });
    }, t.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = mp(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, t.prototype.dispose = function() {
      this._clearController();
    }, t.prototype._zoomToNode = function(r) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: r.node
      });
    }, t.prototype._rootToNode = function(r) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: r.node
      });
    }, t.prototype.findTarget = function(r, n) {
      var i, o = this.seriesModel.getViewRoot();
      return o.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(a) {
        var s = this._storage.background[a.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(r, n), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height)
            i = {
              node: a,
              offsetX: l[0],
              offsetY: l[1]
            };
          else
            return !1;
        }
      }, this), i;
    }, t.type = "treemap", t;
  }(br)
);
function mp() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function TMe(e, t, r, n, i, o, a, s, l, u) {
  if (!a)
    return;
  var c = a.getLayout(), d = e.getData(), h = a.getModel();
  if (d.setItemGraphicEl(a.dataIndex, null), !c || !c.isInView)
    return;
  var f = c.width, p = c.height, g = c.borderWidth, v = c.invisible, m = a.getRawIndex(), y = s && s.getRawIndex(), C = a.viewChildren, S = c.upperHeight, b = C && C.length, w = h.getModel("itemStyle"), x = h.getModel(["emphasis", "itemStyle"]), R = h.getModel(["blur", "itemStyle"]), _ = h.getModel(["select", "itemStyle"]), T = w.get("borderRadius") || 0, P = z("nodeGroup", ST);
  if (!P)
    return;
  if (l.add(P), P.x = c.x || 0, P.y = c.y || 0, P.markRedraw(), LC(P).nodeWidth = f, LC(P).nodeHeight = p, c.isAboveViewRoot)
    return P;
  var D = z("background", OB, u, EMe);
  D && B(P, D, b && c.upperLabelHeight);
  var O = h.getModel("emphasis"), A = O.get("focus"), F = O.get("blurScope"), L = O.get("disabled"), N = A === "ancestor" ? a.getAncestorsIndices() : A === "descendant" ? a.getDescendantIndices() : A;
  if (b)
    ou(P) && mc(P, !1), D && (mc(D, !L), d.setItemGraphicEl(a.dataIndex, D), V_(D, N, F));
  else {
    var I = z("content", OB, u, RMe);
    I && M(P, I), D.disableMorphing = !0, D && ou(D) && mc(D, !1), mc(P, !L), d.setItemGraphicEl(a.dataIndex, P), V_(P, N, F);
  }
  return P;
  function B(K, Z, re) {
    var X = St(Z);
    if (X.dataIndex = a.dataIndex, X.seriesIndex = e.seriesIndex, Z.setShape({
      x: 0,
      y: 0,
      width: f,
      height: p,
      r: T
    }), v)
      V(Z);
    else {
      Z.invisible = !1;
      var Y = a.getVisual("style"), U = Y.stroke, oe = kB(w);
      oe.fill = U;
      var W = ec(x);
      W.fill = x.get("borderColor");
      var ne = ec(R);
      ne.fill = R.get("borderColor");
      var ce = ec(_);
      if (ce.fill = _.get("borderColor"), re) {
        var we = f - 2 * g;
        G(
          // PENDING: convert ZRColor to ColorString for text.
          Z,
          U,
          Y.opacity,
          {
            x: g,
            y: 0,
            width: we,
            height: S
          }
        );
      } else
        Z.removeTextContent();
      Z.setStyle(oe), Z.ensureState("emphasis").style = W, Z.ensureState("blur").style = ne, Z.ensureState("select").style = ce, jc(Z);
    }
    K.add(Z);
  }
  function M(K, Z) {
    var re = St(Z);
    re.dataIndex = a.dataIndex, re.seriesIndex = e.seriesIndex;
    var X = Math.max(f - 2 * g, 0), Y = Math.max(p - 2 * g, 0);
    if (Z.culling = !0, Z.setShape({
      x: g,
      y: g,
      width: X,
      height: Y,
      r: T
    }), v)
      V(Z);
    else {
      Z.invisible = !1;
      var U = a.getVisual("style"), oe = U.fill, W = kB(w);
      W.fill = oe, W.decal = U.decal;
      var ne = ec(x), ce = ec(R), we = ec(_);
      G(Z, oe, U.opacity, null), Z.setStyle(W), Z.ensureState("emphasis").style = ne, Z.ensureState("blur").style = ce, Z.ensureState("select").style = we, jc(Z);
    }
    K.add(Z);
  }
  function V(K) {
    !K.invisible && o.push(K);
  }
  function G(K, Z, re, X) {
    var Y = h.getModel(X ? NB : FB), U = In(h.get("name"), null), oe = Y.getShallow("show");
    ri(K, $n(h, X ? NB : FB), {
      defaultText: oe ? U : null,
      inheritColor: Z,
      defaultOpacity: re,
      labelFetcher: e,
      labelDataIndex: a.dataIndex
    });
    var W = K.getTextContent();
    if (W) {
      var ne = W.style, ce = jS(ne.padding || 0);
      X && (K.setTextConfig({
        layoutRect: X
      }), W.disableLabelLayout = !0), W.beforeUpdate = function() {
        var Re = Math.max((X ? X.width : K.shape.width) - ce[1] - ce[3], 0), ve = Math.max((X ? X.height : K.shape.height) - ce[0] - ce[2], 0);
        (ne.width !== Re || ne.height !== ve) && W.setStyle({
          width: Re,
          height: ve
        });
      }, ne.truncateMinChar = 2, ne.lineOverflow = "truncate", k(ne, X, c);
      var we = W.getState("emphasis");
      k(we ? we.style : null, X, c);
    }
  }
  function k(K, Z, re) {
    var X = K ? K.text : null;
    if (!Z && re.isLeafRoot && X != null) {
      var Y = e.get("drillDownIcon", !0);
      K.text = Y ? Y + " " + X : X;
    }
  }
  function z(K, Z, re, X) {
    var Y = y != null && r[K][y], U = i[K];
    return Y ? (r[K][y] = null, j(U, Y)) : v || (Y = new Z(), Y instanceof ta && (Y.z2 = PMe(re, X)), q(U, Y)), t[K][m] = Y;
  }
  function j(K, Z) {
    var re = K[m] = {};
    Z instanceof ST ? (re.oldX = Z.x, re.oldY = Z.y) : re.oldShape = ge({}, Z.shape);
  }
  function q(K, Z) {
    var re = K[m] = {}, X = a.parentNode, Y = Z instanceof Ct;
    if (X && (!n || n.direction === "drillDown")) {
      var U = 0, oe = 0, W = i.background[X.getRawIndex()];
      !n && W && W.oldShape && (U = W.oldShape.width, oe = W.oldShape.height), Y ? (re.oldX = 0, re.oldY = oe) : re.oldShape = {
        x: U,
        y: oe,
        width: 0,
        height: 0
      };
    }
    re.fadein = !Y;
  }
}
function PMe(e, t) {
  return e * xMe + t;
}
var ov = $, MMe = lt, FC = -1, Vn = (
  /** @class */
  function() {
    function e(t) {
      var r = t.mappingMethod, n = t.type, i = this.option = dt(t);
      this.type = n, this.mappingMethod = r, this._normalizeData = IMe[r];
      var o = e.visualHandlers[n];
      this.applyVisual = o.applyVisual, this.getColorMapper = o.getColorMapper, this._normalizedToVisual = o._normalizedToVisual[r], r === "piecewise" ? (Cx(i), DMe(i)) : r === "category" ? i.categories ? AMe(i) : Cx(i, !0) : (ct(r !== "linear" || i.dataExtent), Cx(i));
    }
    return e.prototype.mapValueToVisual = function(t) {
      var r = this._normalizeData(t);
      return this._normalizedToVisual(r, t);
    }, e.prototype.getNormalizer = function() {
      return je(this._normalizeData, this);
    }, e.listVisualTypes = function() {
      return jt(e.visualHandlers);
    }, e.isValidType = function(t) {
      return e.visualHandlers.hasOwnProperty(t);
    }, e.eachVisual = function(t, r, n) {
      lt(t) ? $(t, r, n) : r.call(n, t);
    }, e.mapVisual = function(t, r, n) {
      var i, o = be(t) ? [] : lt(t) ? {} : (i = !0, null);
      return e.eachVisual(t, function(a, s) {
        var l = r.call(n, a, s);
        i ? o = l : o[s] = l;
      }), o;
    }, e.retrieveVisuals = function(t) {
      var r = {}, n;
      return t && ov(e.visualHandlers, function(i, o) {
        t.hasOwnProperty(o) && (r[o] = t[o], n = !0);
      }), n ? r : null;
    }, e.prepareVisualTypes = function(t) {
      if (be(t))
        t = t.slice();
      else if (MMe(t)) {
        var r = [];
        ov(t, function(n, i) {
          r.push(i);
        }), t = r;
      } else
        return [];
      return t.sort(function(n, i) {
        return i === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, e.dependsOn = function(t, r) {
      return r === "color" ? !!(t && t.indexOf(r) === 0) : t === r;
    }, e.findPieceIndex = function(t, r, n) {
      for (var i, o = 1 / 0, a = 0, s = r.length; a < s; a++) {
        var l = r[a].value;
        if (l != null) {
          if (l === t || He(l) && l === t + "")
            return a;
          n && h(l, a);
        }
      }
      for (var a = 0, s = r.length; a < s; a++) {
        var u = r[a], c = u.interval, d = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (Cy(d[1], t, c[1]))
              return a;
          } else if (c[1] === 1 / 0) {
            if (Cy(d[0], c[0], t))
              return a;
          } else if (Cy(d[0], c[0], t) && Cy(d[1], t, c[1]))
            return a;
          n && h(c[0], a), n && h(c[1], a);
        }
      }
      if (n)
        return t === 1 / 0 ? r.length - 1 : t === -1 / 0 ? 0 : i;
      function h(f, p) {
        var g = Math.abs(f - t);
        g < o && (o = g, i = p);
      }
    }, e.visualHandlers = {
      color: {
        applyVisual: yp("color"),
        getColorMapper: function() {
          var t = this.option;
          return je(t.mappingMethod === "category" ? function(r, n) {
            return !n && (r = this._normalizeData(r)), $p.call(this, r);
          } : function(r, n, i) {
            var o = !!i;
            return !n && (r = this._normalizeData(r)), i = ig(r, t.parsedVisual, i), o ? i : Pa(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return Pa(ig(t, this.option.parsedVisual), "rgba");
          },
          category: $p,
          piecewise: function(t, r) {
            var n = bT.call(this, r);
            return n == null && (n = Pa(ig(t, this.option.parsedVisual), "rgba")), n;
          },
          fixed: tc
        }
      },
      colorHue: yy(function(t, r) {
        return Th(t, r);
      }),
      colorSaturation: yy(function(t, r) {
        return Th(t, null, r);
      }),
      colorLightness: yy(function(t, r) {
        return Th(t, null, null, r);
      }),
      colorAlpha: yy(function(t, r) {
        return Gg(t, r);
      }),
      decal: {
        applyVisual: yp("decal"),
        _normalizedToVisual: {
          linear: null,
          category: $p,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: yp("opacity"),
        _normalizedToVisual: wT([0, 1])
      },
      liftZ: {
        applyVisual: yp("liftZ"),
        _normalizedToVisual: {
          linear: tc,
          category: tc,
          piecewise: tc,
          fixed: tc
        }
      },
      symbol: {
        applyVisual: function(t, r, n) {
          var i = this.mapValueToVisual(t);
          n("symbol", i);
        },
        _normalizedToVisual: {
          linear: VB,
          category: $p,
          piecewise: function(t, r) {
            var n = bT.call(this, r);
            return n == null && (n = VB.call(this, t)), n;
          },
          fixed: tc
        }
      },
      symbolSize: {
        applyVisual: yp("symbolSize"),
        _normalizedToVisual: wT([0, 1])
      }
    }, e;
  }()
);
function DMe(e) {
  var t = e.pieceList;
  e.hasSpecialVisual = !1, $(t, function(r, n) {
    r.originIndex = n, r.visual != null && (e.hasSpecialVisual = !0);
  });
}
function AMe(e) {
  var t = e.categories, r = e.categoryMap = {}, n = e.visual;
  if (ov(t, function(a, s) {
    r[a] = s;
  }), !be(n)) {
    var i = [];
    lt(n) ? ov(n, function(a, s) {
      var l = r[s];
      i[l ?? FC] = a;
    }) : i[FC] = n, n = PU(e, i);
  }
  for (var o = t.length - 1; o >= 0; o--)
    n[o] == null && (delete r[t[o]], t.pop());
}
function Cx(e, t) {
  var r = e.visual, n = [];
  lt(r) ? ov(r, function(o) {
    n.push(o);
  }) : r != null && n.push(r);
  var i = {
    color: 1,
    symbol: 1
  };
  !t && n.length === 1 && !i.hasOwnProperty(e.type) && (n[1] = n[0]), PU(e, n);
}
function yy(e) {
  return {
    applyVisual: function(t, r, n) {
      var i = this.mapValueToVisual(t);
      n("color", e(r("color"), i));
    },
    _normalizedToVisual: wT([0, 1])
  };
}
function VB(e) {
  var t = this.option.visual;
  return t[Math.round(Cr(e, [0, 1], [0, t.length - 1], !0))] || {};
}
function yp(e) {
  return function(t, r, n) {
    n(e, this.mapValueToVisual(t));
  };
}
function $p(e) {
  var t = this.option.visual;
  return t[this.option.loop && e !== FC ? e % t.length : e];
}
function tc() {
  return this.option.visual[0];
}
function wT(e) {
  return {
    linear: function(t) {
      return Cr(t, e, this.option.visual, !0);
    },
    category: $p,
    piecewise: function(t, r) {
      var n = bT.call(this, r);
      return n == null && (n = Cr(t, e, this.option.visual, !0)), n;
    },
    fixed: tc
  };
}
function bT(e) {
  var t = this.option, r = t.pieceList;
  if (t.hasSpecialVisual) {
    var n = Vn.findPieceIndex(e, r), i = r[n];
    if (i && i.visual)
      return i.visual[this.type];
  }
}
function PU(e, t) {
  return e.visual = t, e.type === "color" && (e.parsedVisual = Ee(t, function(r) {
    var n = Pi(r);
    return !n && process.env.NODE_ENV !== "production" && nn("'" + r + "' is an illegal color, fallback to '#000000'", !0), n || [0, 0, 0, 1];
  })), t;
}
var IMe = {
  linear: function(e) {
    return Cr(e, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(e) {
    var t = this.option.pieceList, r = Vn.findPieceIndex(e, t, !0);
    if (r != null)
      return Cr(r, [0, t.length - 1], [0, 1], !0);
  },
  category: function(e) {
    var t = this.option.categories ? this.option.categoryMap[e] : e;
    return t ?? FC;
  },
  fixed: un
};
function Cy(e, t, r) {
  return e ? t <= r : t < r;
}
var OMe = "itemStyle", MU = ar();
const LMe = {
  seriesType: "treemap",
  reset: function(e) {
    var t = e.getData().tree, r = t.root;
    r.isRemoved() || DU(
      r,
      // Visual should calculate from tree root but not view root.
      {},
      e.getViewRoot().getAncestors(),
      e
    );
  }
};
function DU(e, t, r, n) {
  var i = e.getModel(), o = e.getLayout(), a = e.hostTree.data;
  if (!(!o || o.invisible || !o.isInView)) {
    var s = i.getModel(OMe), l = FMe(s, t, n), u = a.ensureUniqueItemVisual(e.dataIndex, "style"), c = s.get("borderColor"), d = s.get("borderColorSaturation"), h;
    d != null && (h = BB(l), c = NMe(d, h)), u.stroke = c;
    var f = e.viewChildren;
    if (!f || !f.length)
      h = BB(l), u.fill = h;
    else {
      var p = kMe(e, i, o, s, l, f);
      $(f, function(g, v) {
        if (g.depth >= r.length || g === r[g.depth]) {
          var m = VMe(i, l, g, v, p, n);
          DU(g, m, r, n);
        }
      });
    }
  }
}
function FMe(e, t, r) {
  var n = ge({}, t), i = r.designatedVisualItemStyle;
  return $(["color", "colorAlpha", "colorSaturation"], function(o) {
    i[o] = t[o];
    var a = e.get(o);
    i[o] = null, a != null && (n[o] = a);
  }), n;
}
function BB(e) {
  var t = Sx(e, "color");
  if (t) {
    var r = Sx(e, "colorAlpha"), n = Sx(e, "colorSaturation");
    return n && (t = Th(t, null, null, n)), r && (t = Gg(t, r)), t;
  }
}
function NMe(e, t) {
  return t != null ? Th(t, null, null, e) : null;
}
function Sx(e, t) {
  var r = e[t];
  if (r != null && r !== "none")
    return r;
}
function kMe(e, t, r, n, i, o) {
  if (!(!o || !o.length)) {
    var a = bx(t, "color") || i.color != null && i.color !== "none" && (bx(t, "colorAlpha") || bx(t, "colorSaturation"));
    if (a) {
      var s = t.get("visualMin"), l = t.get("visualMax"), u = r.dataExtent.slice();
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
      var c = t.get("colorMappingBy"), d = {
        type: a.name,
        dataExtent: u,
        visual: a.range
      };
      d.type === "color" && (c === "index" || c === "id") ? (d.mappingMethod = "category", d.loop = !0) : d.mappingMethod = "linear";
      var h = new Vn(d);
      return MU(h).drColorMappingBy = c, h;
    }
  }
}
function bx(e, t) {
  var r = e.get(t);
  return be(r) && r.length ? {
    name: t,
    range: r
  } : null;
}
function VMe(e, t, r, n, i, o) {
  var a = ge({}, t);
  if (i) {
    var s = i.type, l = s === "color" && MU(i).drColorMappingBy, u = l === "index" ? n : l === "id" ? o.mapIdToIndex(r.getId()) : r.getValue(e.get("visualDimension"));
    a[s] = i.mapValueToVisual(u);
  }
  return a;
}
var av = Math.max, NC = Math.min, $B = vn, hA = $, AU = ["itemStyle", "borderWidth"], BMe = ["itemStyle", "gapWidth"], $Me = ["upperLabel", "show"], HMe = ["upperLabel", "height"];
const GMe = {
  seriesType: "treemap",
  reset: function(e, t, r, n) {
    var i = r.getWidth(), o = r.getHeight(), a = e.option, s = En(e.getBoxLayoutParams(), {
      width: r.getWidth(),
      height: r.getHeight()
    }), l = a.size || [], u = Be($B(s.width, l[0]), i), c = Be($B(s.height, l[1]), o), d = n && n.type, h = ["treemapZoomToNode", "treemapRootToNode"], f = iv(n, h, e), p = d === "treemapRender" || d === "treemapMove" ? n.rootRect : null, g = e.getViewRoot(), v = RU(g);
    if (d !== "treemapMove") {
      var m = d === "treemapZoomToNode" ? YMe(e, f, g, u, c) : p ? [p.width, p.height] : [u, c], y = a.sort;
      y && y !== "asc" && y !== "desc" && (y = "desc");
      var C = {
        squareRatio: a.squareRatio,
        sort: y,
        leafDepth: a.leafDepth
      };
      g.hostTree.clearLayouts();
      var S = {
        x: 0,
        y: 0,
        width: m[0],
        height: m[1],
        area: m[0] * m[1]
      };
      g.setLayout(S), IU(g, C, !1, 0), S = g.getLayout(), hA(v, function(w, x) {
        var R = (v[x + 1] || g).getValue();
        w.setLayout(ge({
          dataExtent: [R, R],
          borderWidth: 0,
          upperHeight: 0
        }, S));
      });
    }
    var b = e.getData().tree.root;
    b.setLayout(qMe(s, p, f), !0), e.setLayoutInfo(s), OU(
      b,
      // Transform to base element coordinate system.
      new At(-s.x, -s.y, i, o),
      v,
      g,
      0
    );
  }
};
function IU(e, t, r, n) {
  var i, o;
  if (!e.isRemoved()) {
    var a = e.getLayout();
    i = a.width, o = a.height;
    var s = e.getModel(), l = s.get(AU), u = s.get(BMe) / 2, c = LU(s), d = Math.max(l, c), h = l - u, f = d - u;
    e.setLayout({
      borderWidth: l,
      upperHeight: d,
      upperLabelHeight: c
    }, !0), i = av(i - 2 * h, 0), o = av(o - h - f, 0);
    var p = i * o, g = zMe(e, s, p, t, r, n);
    if (g.length) {
      var v = {
        x: h,
        y: f,
        width: i,
        height: o
      }, m = NC(i, o), y = 1 / 0, C = [];
      C.area = 0;
      for (var S = 0, b = g.length; S < b; ) {
        var w = g[S];
        C.push(w), C.area += w.getLayout().area;
        var x = KMe(C, m, t.squareRatio);
        x <= y ? (S++, y = x) : (C.area -= C.pop().getLayout().area, HB(C, m, v, u, !1), m = NC(v.width, v.height), C.length = C.area = 0, y = 1 / 0);
      }
      if (C.length && HB(C, m, v, u, !0), !r) {
        var R = s.get("childrenVisibleMin");
        R != null && p < R && (r = !0);
      }
      for (var S = 0, b = g.length; S < b; S++)
        IU(g[S], t, r, n + 1);
    }
  }
}
function zMe(e, t, r, n, i, o) {
  var a = e.children || [], s = n.sort;
  s !== "asc" && s !== "desc" && (s = null);
  var l = n.leafDepth != null && n.leafDepth <= o;
  if (i && !l)
    return e.viewChildren = [];
  a = Sr(a, function(f) {
    return !f.isRemoved();
  }), jMe(a, s);
  var u = UMe(t, a, s);
  if (u.sum === 0)
    return e.viewChildren = [];
  if (u.sum = WMe(t, r, u.sum, s, a), u.sum === 0)
    return e.viewChildren = [];
  for (var c = 0, d = a.length; c < d; c++) {
    var h = a[c].getValue() / u.sum * r;
    a[c].setLayout({
      area: h
    });
  }
  return l && (a.length && e.setLayout({
    isLeafRoot: !0
  }, !0), a.length = 0), e.viewChildren = a, e.setLayout({
    dataExtent: u.dataExtent
  }, !0), a;
}
function WMe(e, t, r, n, i) {
  if (!n)
    return r;
  for (var o = e.get("visibleMin"), a = i.length, s = a, l = a - 1; l >= 0; l--) {
    var u = i[n === "asc" ? a - l - 1 : l].getValue();
    u / r * t < o && (s = l, r -= u);
  }
  return n === "asc" ? i.splice(0, a - s) : i.splice(s, a - s), r;
}
function jMe(e, t) {
  return t && e.sort(function(r, n) {
    var i = t === "asc" ? r.getValue() - n.getValue() : n.getValue() - r.getValue();
    return i === 0 ? t === "asc" ? r.dataIndex - n.dataIndex : n.dataIndex - r.dataIndex : i;
  }), e;
}
function UMe(e, t, r) {
  for (var n = 0, i = 0, o = t.length; i < o; i++)
    n += t[i].getValue();
  var a = e.get("visualDimension"), s;
  return !t || !t.length ? s = [NaN, NaN] : a === "value" && r ? (s = [t[t.length - 1].getValue(), t[0].getValue()], r === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], hA(t, function(l) {
    var u = l.getValue(a);
    u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
  })), {
    sum: n,
    dataExtent: s
  };
}
function KMe(e, t, r) {
  for (var n = 0, i = 1 / 0, o = 0, a = void 0, s = e.length; o < s; o++)
    a = e[o].getLayout().area, a && (a < i && (i = a), a > n && (n = a));
  var l = e.area * e.area, u = t * t * r;
  return l ? av(u * n / l, l / (u * i)) : 1 / 0;
}
function HB(e, t, r, n, i) {
  var o = t === r.width ? 0 : 1, a = 1 - o, s = ["x", "y"], l = ["width", "height"], u = r[s[o]], c = t ? e.area / t : 0;
  (i || c > r[l[a]]) && (c = r[l[a]]);
  for (var d = 0, h = e.length; d < h; d++) {
    var f = e[d], p = {}, g = c ? f.getLayout().area / c : 0, v = p[l[a]] = av(c - 2 * n, 0), m = r[s[o]] + r[l[o]] - u, y = d === h - 1 || m < g ? m : g, C = p[l[o]] = av(y - 2 * n, 0);
    p[s[a]] = r[s[a]] + NC(n, v / 2), p[s[o]] = u + NC(n, C / 2), u += y, f.setLayout(p, !0);
  }
  r[s[a]] += c, r[l[a]] -= c;
}
function YMe(e, t, r, n, i) {
  var o = (t || {}).node, a = [n, i];
  if (!o || o === r)
    return a;
  for (var s, l = n * i, u = l * e.option.zoomToNodeRatio; s = o.parentNode; ) {
    for (var c = 0, d = s.children, h = 0, f = d.length; h < f; h++)
      c += d[h].getValue();
    var p = o.getValue();
    if (p === 0)
      return a;
    u *= c / p;
    var g = s.getModel(), v = g.get(AU), m = Math.max(v, LU(g));
    u += 4 * v * v + (3 * v + m) * Math.pow(u, 0.5), u > M_ && (u = M_), o = s;
  }
  u < l && (u = l);
  var y = Math.pow(u / l, 0.5);
  return [n * y, i * y];
}
function qMe(e, t, r) {
  if (t)
    return {
      x: t.x,
      y: t.y
    };
  var n = {
    x: 0,
    y: 0
  };
  if (!r)
    return n;
  var i = r.node, o = i.getLayout();
  if (!o)
    return n;
  for (var a = [o.width / 2, o.height / 2], s = i; s; ) {
    var l = s.getLayout();
    a[0] += l.x, a[1] += l.y, s = s.parentNode;
  }
  return {
    x: e.width / 2 - a[0],
    y: e.height / 2 - a[1]
  };
}
function OU(e, t, r, n, i) {
  var o = e.getLayout(), a = r[i], s = a && a === e;
  if (!(a && !s || i === r.length && e !== n)) {
    e.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !s && !t.intersect(o),
      isAboveViewRoot: s
    }, !0);
    var l = new At(t.x - o.x, t.y - o.y, t.width, t.height);
    hA(e.viewChildren || [], function(u) {
      OU(u, l, r, n, i + 1);
    });
  }
}
function LU(e) {
  return e.get($Me) ? e.get(HMe) : 0;
}
function XMe(e) {
  e.registerSeriesModel(gMe), e.registerChartView(_Me), e.registerVisual(LMe), e.registerLayout(GMe), pMe(e);
}
function ZMe(e) {
  var t = e.findComponents({
    mainType: "legend"
  });
  !t || !t.length || e.eachSeriesByType("graph", function(r) {
    var n = r.getCategoriesData(), i = r.getGraph(), o = i.data, a = n.mapArray(n.getName);
    o.filterSelf(function(s) {
      var l = o.getItemModel(s), u = l.getShallow("category");
      if (u != null) {
        sr(u) && (u = a[u]);
        for (var c = 0; c < t.length; c++)
          if (!t[c].isSelected(u))
            return !1;
      }
      return !0;
    });
  });
}
function QMe(e) {
  var t = {};
  e.eachSeriesByType("graph", function(r) {
    var n = r.getCategoriesData(), i = r.getData(), o = {};
    n.each(function(a) {
      var s = n.getName(a);
      o["ec-" + s] = a;
      var l = n.getItemModel(a), u = l.getModel("itemStyle").getItemStyle();
      u.fill || (u.fill = r.getColorFromPalette(s, t)), n.setItemVisual(a, "style", u);
      for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], d = 0; d < c.length; d++) {
        var h = l.getShallow(c[d], !0);
        h != null && n.setItemVisual(a, c[d], h);
      }
    }), n.count() && i.each(function(a) {
      var s = i.getItemModel(a), l = s.getShallow("category");
      if (l != null) {
        He(l) && (l = o["ec-" + l]);
        var u = n.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(a, "style");
        ge(c, u);
        for (var d = ["symbol", "symbolSize", "symbolKeepAspect"], h = 0; h < d.length; h++)
          i.setItemVisual(a, d[h], n.getItemVisual(l, d[h]));
      }
    });
  });
}
function Sy(e) {
  return e instanceof Array || (e = [e, e]), e;
}
function JMe(e) {
  e.eachSeriesByType("graph", function(t) {
    var r = t.getGraph(), n = t.getEdgeData(), i = Sy(t.get("edgeSymbol")), o = Sy(t.get("edgeSymbolSize"));
    n.setVisual("fromSymbol", i && i[0]), n.setVisual("toSymbol", i && i[1]), n.setVisual("fromSymbolSize", o && o[0]), n.setVisual("toSymbolSize", o && o[1]), n.setVisual("style", t.getModel("lineStyle").getLineStyle()), n.each(function(a) {
      var s = n.getItemModel(a), l = r.getEdgeByIndex(a), u = Sy(s.getShallow("symbol", !0)), c = Sy(s.getShallow("symbolSize", !0)), d = s.getModel("lineStyle").getLineStyle(), h = n.ensureUniqueItemVisual(a, "style");
      switch (ge(h, d), h.stroke) {
        case "source": {
          var f = l.node1.getVisual("style");
          h.stroke = f && f.fill;
          break;
        }
        case "target": {
          var f = l.node2.getVisual("style");
          h.stroke = f && f.fill;
          break;
        }
      }
      u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
    });
  });
}
var xT = "-->", Dw = function(e) {
  return e.get("autoCurveness") || null;
}, FU = function(e, t) {
  var r = Dw(e), n = 20, i = [];
  if (sr(r))
    n = r;
  else if (be(r)) {
    e.__curvenessList = r;
    return;
  }
  t > n && (n = t);
  var o = n % 2 ? n + 2 : n + 3;
  i = [];
  for (var a = 0; a < o; a++)
    i.push((a % 2 ? a + 1 : a) / 10 * (a % 2 ? -1 : 1));
  e.__curvenessList = i;
}, sv = function(e, t, r) {
  var n = [e.id, e.dataIndex].join("."), i = [t.id, t.dataIndex].join(".");
  return [r.uid, n, i].join(xT);
}, NU = function(e) {
  var t = e.split(xT);
  return [t[0], t[2], t[1]].join(xT);
}, eDe = function(e, t) {
  var r = sv(e.node1, e.node2, t);
  return t.__edgeMap[r];
}, tDe = function(e, t) {
  var r = ET(sv(e.node1, e.node2, t), t), n = ET(sv(e.node2, e.node1, t), t);
  return r + n;
}, ET = function(e, t) {
  var r = t.__edgeMap;
  return r[e] ? r[e].length : 0;
};
function rDe(e) {
  Dw(e) && (e.__curvenessList = [], e.__edgeMap = {}, FU(e));
}
function nDe(e, t, r, n) {
  if (Dw(r)) {
    var i = sv(e, t, r), o = r.__edgeMap, a = o[NU(i)];
    o[i] && !a ? o[i].isForward = !0 : a && o[i] && (a.isForward = !0, o[i].isForward = !1), o[i] = o[i] || [], o[i].push(n);
  }
}
function fA(e, t, r, n) {
  var i = Dw(t), o = be(i);
  if (!i)
    return null;
  var a = eDe(e, t);
  if (!a)
    return null;
  for (var s = -1, l = 0; l < a.length; l++)
    if (a[l] === r) {
      s = l;
      break;
    }
  var u = tDe(e, t);
  FU(t, u), e.lineStyle = e.lineStyle || {};
  var c = sv(e.node1, e.node2, t), d = t.__curvenessList, h = o || u % 2 ? 0 : 1;
  if (a.isForward)
    return d[h + s];
  var f = NU(c), p = ET(f, t), g = d[s + p + h];
  return n ? o ? i && i[0] === 0 ? (p + h) % 2 ? g : -g : ((p % 2 ? 0 : 1) + h) % 2 ? g : -g : (p + h) % 2 ? g : -g : d[s + p + h];
}
function kU(e) {
  var t = e.coordinateSystem;
  if (!(t && t.type !== "view")) {
    var r = e.getGraph();
    r.eachNode(function(n) {
      var i = n.getModel();
      n.setLayout([+i.get("x"), +i.get("y")]);
    }), pA(r, e);
  }
}
function pA(e, t) {
  e.eachEdge(function(r, n) {
    var i = So(r.getModel().get(["lineStyle", "curveness"]), -fA(r, t, n, !0), 0), o = ls(r.node1.getLayout()), a = ls(r.node2.getLayout()), s = [o, a];
    +i && s.push([(o[0] + a[0]) / 2 - (o[1] - a[1]) * i, (o[1] + a[1]) / 2 - (a[0] - o[0]) * i]), r.setLayout(s);
  });
}
function iDe(e, t) {
  e.eachSeriesByType("graph", function(r) {
    var n = r.get("layout"), i = r.coordinateSystem;
    if (i && i.type !== "view") {
      var o = r.getData(), a = [];
      $(i.dimensions, function(h) {
        a = a.concat(o.mapDimensionsAll(h));
      });
      for (var s = 0; s < o.count(); s++) {
        for (var l = [], u = !1, c = 0; c < a.length; c++) {
          var d = o.get(a[c], s);
          isNaN(d) || (u = !0), l.push(d);
        }
        u ? o.setItemLayout(s, i.dataToPoint(l)) : o.setItemLayout(s, [NaN, NaN]);
      }
      pA(o.graph, r);
    } else (!n || n === "none") && kU(r);
  });
}
function Hp(e) {
  var t = e.coordinateSystem;
  if (t.type !== "view")
    return 1;
  var r = e.option.nodeScaleRatio, n = t.scaleX, i = t.getZoom(), o = (i - 1) * r + 1;
  return o / n;
}
function Gp(e) {
  var t = e.getVisual("symbolSize");
  return t instanceof Array && (t = (t[0] + t[1]) / 2), +t;
}
var GB = Math.PI, xx = [];
function gA(e, t, r, n) {
  var i = e.coordinateSystem;
  if (!(i && i.type !== "view")) {
    var o = i.getBoundingRect(), a = e.getData(), s = a.graph, l = o.width / 2 + o.x, u = o.height / 2 + o.y, c = Math.min(o.width, o.height) / 2, d = a.count();
    if (a.setLayout({
      cx: l,
      cy: u
    }), !!d) {
      if (r) {
        var h = i.pointToData(n), f = h[0], p = h[1], g = [f - l, p - u];
        nd(g, g), tg(g, g, c), r.setLayout([l + g[0], u + g[1]], !0);
        var v = e.get(["circular", "rotateLabel"]);
        VU(r, v, l, u);
      }
      oDe[t](e, s, a, c, l, u, d), s.eachEdge(function(m, y) {
        var C = So(m.getModel().get(["lineStyle", "curveness"]), fA(m, e, y), 0), S = ls(m.node1.getLayout()), b = ls(m.node2.getLayout()), w, x = (S[0] + b[0]) / 2, R = (S[1] + b[1]) / 2;
        +C && (C *= 3, w = [l * C + x * (1 - C), u * C + R * (1 - C)]), m.setLayout([S, b, w]);
      });
    }
  }
}
var oDe = {
  value: function(e, t, r, n, i, o, a) {
    var s = 0, l = r.getSum("value"), u = Math.PI * 2 / (l || a);
    t.eachNode(function(c) {
      var d = c.getValue("value"), h = u * (l ? d : 1) / 2;
      s += h, c.setLayout([n * Math.cos(s) + i, n * Math.sin(s) + o]), s += h;
    });
  },
  symbolSize: function(e, t, r, n, i, o, a) {
    var s = 0;
    xx.length = a;
    var l = Hp(e);
    t.eachNode(function(d) {
      var h = Gp(d);
      isNaN(h) && (h = 2), h < 0 && (h = 0), h *= l;
      var f = Math.asin(h / 2 / n);
      isNaN(f) && (f = GB / 2), xx[d.dataIndex] = f, s += f * 2;
    });
    var u = (2 * GB - s) / a / 2, c = 0;
    t.eachNode(function(d) {
      var h = u + xx[d.dataIndex];
      c += h, (!d.getLayout() || !d.getLayout().fixed) && d.setLayout([n * Math.cos(c) + i, n * Math.sin(c) + o]), c += h;
    });
  }
};
function VU(e, t, r, n) {
  var i = e.getGraphicEl();
  if (i) {
    var o = e.getModel(), a = o.get(["label", "rotate"]) || 0, s = i.getSymbolPath();
    if (t) {
      var l = e.getLayout(), u = Math.atan2(l[1] - n, l[0] - r);
      u < 0 && (u = Math.PI * 2 + u);
      var c = l[0] < r;
      c && (u = u - Math.PI);
      var d = c ? "left" : "right";
      s.setTextConfig({
        rotation: -u,
        position: d,
        origin: "center"
      });
      var h = s.ensureState("emphasis");
      ge(h.textConfig || (h.textConfig = {}), {
        position: d
      });
    } else
      s.setTextConfig({
        rotation: a *= Math.PI / 180
      });
  }
}
function aDe(e) {
  e.eachSeriesByType("graph", function(t) {
    t.get("layout") === "circular" && gA(t, "symbolSize");
  });
}
var Wd = X0;
function sDe(e, t, r) {
  for (var n = e, i = t, o = r.rect, a = o.width, s = o.height, l = [o.x + a / 2, o.y + s / 2], u = r.gravity == null ? 0.1 : r.gravity, c = 0; c < n.length; c++) {
    var d = n[c];
    d.p || (d.p = yu(a * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), d.pp = ls(d.p), d.edges = null;
  }
  var h = r.friction == null ? 0.6 : r.friction, f = h, p, g;
  return {
    warmUp: function() {
      f = h * 0.8;
    },
    setFixed: function(v) {
      n[v].fixed = !0;
    },
    setUnfixed: function(v) {
      n[v].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(v) {
      p = v;
    },
    /**
     * After step hook
     */
    afterStep: function(v) {
      g = v;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(v) {
      p && p(n, i);
      for (var m = [], y = n.length, C = 0; C < i.length; C++) {
        var S = i[C];
        if (!S.ignoreForceLayout) {
          var b = S.n1, w = S.n2;
          Ol(m, w.p, b.p);
          var x = Bg(m) - S.d, R = w.w / (b.w + w.w);
          isNaN(R) && (R = 0), nd(m, m), !b.fixed && Wd(b.p, b.p, m, R * x * f), !w.fixed && Wd(w.p, w.p, m, -(1 - R) * x * f);
        }
      }
      for (var C = 0; C < y; C++) {
        var _ = n[C];
        _.fixed || (Ol(m, l, _.p), Wd(_.p, _.p, m, u * f));
      }
      for (var C = 0; C < y; C++)
        for (var b = n[C], T = C + 1; T < y; T++) {
          var w = n[T];
          Ol(m, w.p, b.p);
          var x = Bg(m);
          x === 0 && (F6(m, Math.random() - 0.5, Math.random() - 0.5), x = 1);
          var P = (b.rep + w.rep) / x / x;
          !b.fixed && Wd(b.pp, b.pp, m, P), !w.fixed && Wd(w.pp, w.pp, m, -P);
        }
      for (var D = [], C = 0; C < y; C++) {
        var _ = n[C];
        _.fixed || (Ol(D, _.p, _.pp), Wd(_.p, _.p, D, f), ai(_.pp, _.p));
      }
      f = f * 0.992;
      var O = f < 0.01;
      g && g(n, i, O), v && v(O);
    }
  };
}
function lDe(e) {
  e.eachSeriesByType("graph", function(t) {
    var r = t.coordinateSystem;
    if (!(r && r.type !== "view"))
      if (t.get("layout") === "force") {
        var n = t.preservedPoints || {}, i = t.getGraph(), o = i.data, a = i.edgeData, s = t.getModel("force"), l = s.get("initLayout");
        t.preservedPoints ? o.each(function(C) {
          var S = o.getId(C);
          o.setItemLayout(C, n[S] || [NaN, NaN]);
        }) : !l || l === "none" ? kU(t) : l === "circular" && gA(t, "value");
        var u = o.getDataExtent("value"), c = a.getDataExtent("value"), d = s.get("repulsion"), h = s.get("edgeLength"), f = be(d) ? d : [d, d], p = be(h) ? h : [h, h];
        p = [p[1], p[0]];
        var g = o.mapArray("value", function(C, S) {
          var b = o.getItemLayout(S), w = Cr(C, u, f);
          return isNaN(w) && (w = (f[0] + f[1]) / 2), {
            w,
            rep: w,
            fixed: o.getItemModel(S).get("fixed"),
            p: !b || isNaN(b[0]) || isNaN(b[1]) ? null : b
          };
        }), v = a.mapArray("value", function(C, S) {
          var b = i.getEdgeByIndex(S), w = Cr(C, c, p);
          isNaN(w) && (w = (p[0] + p[1]) / 2);
          var x = b.getModel(), R = So(b.getModel().get(["lineStyle", "curveness"]), -fA(b, t, S, !0), 0);
          return {
            n1: g[b.node1.dataIndex],
            n2: g[b.node2.dataIndex],
            d: w,
            curveness: R,
            ignoreForceLayout: x.get("ignoreForceLayout")
          };
        }), m = r.getBoundingRect(), y = sDe(g, v, {
          rect: m,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        y.beforeStep(function(C, S) {
          for (var b = 0, w = C.length; b < w; b++)
            C[b].fixed && ai(C[b].p, i.getNodeByIndex(b).getLayout());
        }), y.afterStep(function(C, S, b) {
          for (var w = 0, x = C.length; w < x; w++)
            C[w].fixed || i.getNodeByIndex(w).setLayout(C[w].p), n[o.getId(w)] = C[w].p;
          for (var w = 0, x = S.length; w < x; w++) {
            var R = S[w], _ = i.getEdgeByIndex(w), T = R.n1.p, P = R.n2.p, D = _.getLayout();
            D = D ? D.slice() : [], D[0] = D[0] || [], D[1] = D[1] || [], ai(D[0], T), ai(D[1], P), +R.curveness && (D[2] = [(T[0] + P[0]) / 2 - (T[1] - P[1]) * R.curveness, (T[1] + P[1]) / 2 - (P[0] - T[0]) * R.curveness]), _.setLayout(D);
          }
        }), t.forceLayout = y, t.preservedPoints = n, y.step();
      } else
        t.forceLayout = null;
  });
}
function uDe(e, t, r) {
  var n = ge(e.getBoxLayoutParams(), {
    aspect: r
  });
  return En(n, {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function cDe(e, t) {
  var r = [];
  return e.eachSeriesByType("graph", function(n) {
    var i = n.get("coordinateSystem");
    if (!i || i === "view") {
      var o = n.getData(), a = o.mapArray(function(v) {
        var m = o.getItemModel(v);
        return [+m.get("x"), +m.get("y")];
      }), s = [], l = [];
      rw(a, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
      var u = (l[0] - s[0]) / (l[1] - s[1]), c = uDe(n, t, u);
      isNaN(u) && (s = [c.x, c.y], l = [c.x + c.width, c.y + c.height]);
      var d = l[0] - s[0], h = l[1] - s[1], f = c.width, p = c.height, g = n.coordinateSystem = new Qv();
      g.zoomLimit = n.get("scaleLimit"), g.setBoundingRect(s[0], s[1], d, h), g.setViewRect(c.x, c.y, f, p), g.setCenter(n.get("center"), t), g.setZoom(n.get("zoom")), r.push(g);
    }
  }), r;
}
var zB = Nn.prototype, Ex = Bv.prototype, BU = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return e;
  }()
);
(function(e) {
  le(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t;
})(BU);
function Rx(e) {
  return isNaN(+e.cpx1) || isNaN(+e.cpy1);
}
var dDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "ec-line", n;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new BU();
    }, t.prototype.buildPath = function(r, n) {
      Rx(n) ? zB.buildPath.call(this, r, n) : Ex.buildPath.call(this, r, n);
    }, t.prototype.pointAt = function(r) {
      return Rx(this.shape) ? zB.pointAt.call(this, r) : Ex.pointAt.call(this, r);
    }, t.prototype.tangentAt = function(r) {
      var n = this.shape, i = Rx(n) ? [n.x2 - n.x1, n.y2 - n.y1] : Ex.tangentAt.call(this, r);
      return nd(i, i);
    }, t;
  }(Ht)
), _x = ["fromSymbol", "toSymbol"];
function WB(e) {
  return "_" + e + "Type";
}
function jB(e, t, r) {
  var n = t.getItemVisual(r, e);
  if (!n || n === "none")
    return n;
  var i = t.getItemVisual(r, e + "Size"), o = t.getItemVisual(r, e + "Rotate"), a = t.getItemVisual(r, e + "Offset"), s = t.getItemVisual(r, e + "KeepAspect"), l = _f(i), u = ud(a || 0, l);
  return n + l + u + (o || "") + (s || "");
}
function UB(e, t, r) {
  var n = t.getItemVisual(r, e);
  if (!(!n || n === "none")) {
    var i = t.getItemVisual(r, e + "Size"), o = t.getItemVisual(r, e + "Rotate"), a = t.getItemVisual(r, e + "Offset"), s = t.getItemVisual(r, e + "KeepAspect"), l = _f(i), u = ud(a || 0, l), c = mn(n, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
    return c.__specifiedRotation = o == null || isNaN(o) ? void 0 : +o * Math.PI / 180 || 0, c.name = e, c;
  }
}
function hDe(e) {
  var t = new dDe({
    name: "line",
    subPixelOptimize: !0
  });
  return RT(t.shape, e), t;
}
function RT(e, t) {
  e.x1 = t[0][0], e.y1 = t[0][1], e.x2 = t[1][0], e.y2 = t[1][1], e.percent = 1;
  var r = t[2];
  r ? (e.cpx1 = r[0], e.cpy1 = r[1]) : (e.cpx1 = NaN, e.cpy1 = NaN);
}
var vA = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i) {
      var o = e.call(this) || this;
      return o._createLine(r, n, i), o;
    }
    return t.prototype._createLine = function(r, n, i) {
      var o = r.hostModel, a = r.getItemLayout(n), s = hDe(a);
      s.shape.percent = 0, jr(s, {
        shape: {
          percent: 1
        }
      }, o, n), this.add(s), $(_x, function(l) {
        var u = UB(l, r, n);
        this.add(u), this[WB(l)] = jB(l, r, n);
      }, this), this._updateCommonStl(r, n, i);
    }, t.prototype.updateData = function(r, n, i) {
      var o = r.hostModel, a = this.childOfName("line"), s = r.getItemLayout(n), l = {
        shape: {}
      };
      RT(l.shape, s), ur(a, l, o, n), $(_x, function(u) {
        var c = jB(u, r, n), d = WB(u);
        if (this[d] !== c) {
          this.remove(this.childOfName(u));
          var h = UB(u, r, n);
          this.add(h);
        }
        this[d] = c;
      }, this), this._updateCommonStl(r, n, i);
    }, t.prototype.getLinePath = function() {
      return this.childAt(0);
    }, t.prototype._updateCommonStl = function(r, n, i) {
      var o = r.hostModel, a = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, d = i && i.emphasisDisabled, h = i && i.focus, f = i && i.blurScope;
      if (!i || r.hasItemOption) {
        var p = r.getItemModel(n), g = p.getModel("emphasis");
        s = g.getModel("lineStyle").getLineStyle(), l = p.getModel(["blur", "lineStyle"]).getLineStyle(), u = p.getModel(["select", "lineStyle"]).getLineStyle(), d = g.get("disabled"), h = g.get("focus"), f = g.get("blurScope"), c = $n(p);
      }
      var v = r.getItemVisual(n, "style"), m = v.stroke;
      a.useStyle(v), a.style.fill = null, a.style.strokeNoScale = !0, a.ensureState("emphasis").style = s, a.ensureState("blur").style = l, a.ensureState("select").style = u, $(_x, function(w) {
        var x = this.childOfName(w);
        if (x) {
          x.setColor(m), x.style.opacity = v.opacity;
          for (var R = 0; R < Ii.length; R++) {
            var _ = Ii[R], T = a.getState(_);
            if (T) {
              var P = T.style || {}, D = x.ensureState(_), O = D.style || (D.style = {});
              P.stroke != null && (O[x.__isEmptyBrush ? "stroke" : "fill"] = P.stroke), P.opacity != null && (O.opacity = P.opacity);
            }
          }
          x.markRedraw();
        }
      }, this);
      var y = o.getRawValue(n);
      ri(this, c, {
        labelDataIndex: n,
        labelFetcher: {
          getFormattedLabel: function(w, x) {
            return o.getFormattedLabel(w, x, r.dataType);
          }
        },
        inheritColor: m || "#000",
        defaultOpacity: v.opacity,
        defaultText: (y == null ? r.getName(n) : isFinite(y) ? an(y) : y) + ""
      });
      var C = this.getTextContent();
      if (C) {
        var S = c.normal;
        C.__align = C.style.align, C.__verticalAlign = C.style.verticalAlign, C.__position = S.get("position") || "middle";
        var b = S.get("distance");
        be(b) || (b = [b, b]), C.__labelDistance = b;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), sn(this, h, f, d);
    }, t.prototype.highlight = function() {
      Qs(this);
    }, t.prototype.downplay = function() {
      Js(this);
    }, t.prototype.updateLayout = function(r, n) {
      this.setLinePoints(r.getItemLayout(n));
    }, t.prototype.setLinePoints = function(r) {
      var n = this.childOfName("line");
      RT(n.shape, r), n.dirty();
    }, t.prototype.beforeUpdate = function() {
      var r = this, n = r.childOfName("fromSymbol"), i = r.childOfName("toSymbol"), o = r.getTextContent();
      if (!n && !i && (!o || o.ignore))
        return;
      for (var a = 1, s = this.parent; s; )
        s.scaleX && (a /= s.scaleX), s = s.parent;
      var l = r.childOfName("line");
      if (!this.__dirty && !l.__dirty)
        return;
      var u = l.shape.percent, c = l.pointAt(0), d = l.pointAt(u), h = Ol([], d, c);
      nd(h, h);
      function f(T, P) {
        var D = T.__specifiedRotation;
        if (D == null) {
          var O = l.tangentAt(P);
          T.attr("rotation", (P === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(O[1], O[0]));
        } else
          T.attr("rotation", D);
      }
      if (n && (n.setPosition(c), f(n, 0), n.scaleX = n.scaleY = a * u, n.markRedraw()), i && (i.setPosition(d), f(i, 1), i.scaleX = i.scaleY = a * u, i.markRedraw()), o && !o.ignore) {
        o.x = o.y = 0, o.originX = o.originY = 0;
        var p = void 0, g = void 0, v = o.__labelDistance, m = v[0] * a, y = v[1] * a, C = u / 2, S = l.tangentAt(C), b = [S[1], -S[0]], w = l.pointAt(C);
        b[1] > 0 && (b[0] = -b[0], b[1] = -b[1]);
        var x = S[0] < 0 ? -1 : 1;
        if (o.__position !== "start" && o.__position !== "end") {
          var R = -Math.atan2(S[1], S[0]);
          d[0] < c[0] && (R = Math.PI + R), o.rotation = R;
        }
        var _ = void 0;
        switch (o.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            _ = -y, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            _ = y, g = "top";
            break;
          default:
            _ = 0, g = "middle";
        }
        switch (o.__position) {
          case "end":
            o.x = h[0] * m + d[0], o.y = h[1] * y + d[1], p = h[0] > 0.8 ? "left" : h[0] < -0.8 ? "right" : "center", g = h[1] > 0.8 ? "top" : h[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            o.x = -h[0] * m + c[0], o.y = -h[1] * y + c[1], p = h[0] > 0.8 ? "right" : h[0] < -0.8 ? "left" : "center", g = h[1] > 0.8 ? "bottom" : h[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            o.x = m * x + c[0], o.y = c[1] + _, p = S[0] < 0 ? "right" : "left", o.originX = -m * x, o.originY = -_;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            o.x = w[0], o.y = w[1] + _, p = "center", o.originY = -_;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            o.x = -m * x + d[0], o.y = d[1] + _, p = S[0] >= 0 ? "right" : "left", o.originX = m * x, o.originY = -_;
            break;
        }
        o.scaleX = o.scaleY = a, o.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: o.__verticalAlign || g,
          align: o.__align || p
        });
      }
    }, t;
  }(Ct)
), mA = (
  /** @class */
  function() {
    function e(t) {
      this.group = new Ct(), this._LineCtor = t || vA;
    }
    return e.prototype.updateData = function(t) {
      var r = this;
      this._progressiveEls = null;
      var n = this, i = n.group, o = n._lineData;
      n._lineData = t, o || i.removeAll();
      var a = KB(t);
      t.diff(o).add(function(s) {
        r._doAdd(t, s, a);
      }).update(function(s, l) {
        r._doUpdate(o, t, l, s, a);
      }).remove(function(s) {
        i.remove(o.getItemGraphicEl(s));
      }).execute();
    }, e.prototype.updateLayout = function() {
      var t = this._lineData;
      t && t.eachItemGraphicEl(function(r, n) {
        r.updateLayout(t, n);
      }, this);
    }, e.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = KB(t), this._lineData = null, this.group.removeAll();
    }, e.prototype.incrementalUpdate = function(t, r) {
      this._progressiveEls = [];
      function n(s) {
        !s.isGroup && !fDe(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0);
      }
      for (var i = t.start; i < t.end; i++) {
        var o = r.getItemLayout(i);
        if (Tx(o)) {
          var a = new this._LineCtor(r, i, this._seriesScope);
          a.traverse(n), this.group.add(a), r.setItemGraphicEl(i, a), this._progressiveEls.push(a);
        }
      }
    }, e.prototype.remove = function() {
      this.group.removeAll();
    }, e.prototype.eachRendered = function(t) {
      Su(this._progressiveEls || this.group, t);
    }, e.prototype._doAdd = function(t, r, n) {
      var i = t.getItemLayout(r);
      if (Tx(i)) {
        var o = new this._LineCtor(t, r, n);
        t.setItemGraphicEl(r, o), this.group.add(o);
      }
    }, e.prototype._doUpdate = function(t, r, n, i, o) {
      var a = t.getItemGraphicEl(n);
      if (!Tx(r.getItemLayout(i))) {
        this.group.remove(a);
        return;
      }
      a ? a.updateData(r, i, o) : a = new this._LineCtor(r, i, o), r.setItemGraphicEl(i, a), this.group.add(a);
    }, e;
  }()
);
function fDe(e) {
  return e.animators && e.animators.length > 0;
}
function KB(e) {
  var t = e.hostModel, r = t.getModel("emphasis");
  return {
    lineStyle: t.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: r.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: t.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: t.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: r.get("disabled"),
    blurScope: r.get("blurScope"),
    focus: r.get("focus"),
    labelStatesModels: $n(t)
  };
}
function YB(e) {
  return isNaN(e[0]) || isNaN(e[1]);
}
function Tx(e) {
  return e && !YB(e[0]) && !YB(e[1]);
}
var Px = [], Mx = [], Dx = [], jd = zn, Ax = Hl, qB = Math.abs;
function XB(e, t, r) {
  for (var n = e[0], i = e[1], o = e[2], a = 1 / 0, s, l = r * r, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
    Px[0] = jd(n[0], i[0], o[0], c), Px[1] = jd(n[1], i[1], o[1], c);
    var d = qB(Ax(Px, t) - l);
    d < a && (a = d, s = c);
  }
  for (var h = 0; h < 32; h++) {
    var f = s + u;
    Mx[0] = jd(n[0], i[0], o[0], s), Mx[1] = jd(n[1], i[1], o[1], s), Dx[0] = jd(n[0], i[0], o[0], f), Dx[1] = jd(n[1], i[1], o[1], f);
    var d = Ax(Mx, t) - l;
    if (qB(d) < 0.01)
      break;
    var p = Ax(Dx, t) - l;
    u /= 2, d < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u;
  }
  return s;
}
function Ix(e, t) {
  var r = [], n = $g, i = [[], [], []], o = [[], []], a = [];
  t /= 2, e.eachEdge(function(s, l) {
    var u = s.getLayout(), c = s.getVisual("fromSymbol"), d = s.getVisual("toSymbol");
    u.__original || (u.__original = [ls(u[0]), ls(u[1])], u[2] && u.__original.push(ls(u[2])));
    var h = u.__original;
    if (u[2] != null) {
      if (ai(i[0], h[0]), ai(i[1], h[2]), ai(i[2], h[1]), c && c !== "none") {
        var f = Gp(s.node1), p = XB(i, h[0], f * t);
        n(i[0][0], i[1][0], i[2][0], p, r), i[0][0] = r[3], i[1][0] = r[4], n(i[0][1], i[1][1], i[2][1], p, r), i[0][1] = r[3], i[1][1] = r[4];
      }
      if (d && d !== "none") {
        var f = Gp(s.node2), p = XB(i, h[1], f * t);
        n(i[0][0], i[1][0], i[2][0], p, r), i[1][0] = r[1], i[2][0] = r[2], n(i[0][1], i[1][1], i[2][1], p, r), i[1][1] = r[1], i[2][1] = r[2];
      }
      ai(u[0], i[0]), ai(u[1], i[2]), ai(u[2], i[1]);
    } else {
      if (ai(o[0], h[0]), ai(o[1], h[1]), Ol(a, o[1], o[0]), nd(a, a), c && c !== "none") {
        var f = Gp(s.node1);
        X0(o[0], o[0], a, f * t);
      }
      if (d && d !== "none") {
        var f = Gp(s.node2);
        X0(o[1], o[1], a, -f * t);
      }
      ai(u[0], o[0]), ai(u[1], o[1]);
    }
  });
}
function ZB(e) {
  return e.type === "view";
}
var pDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      var i = new Uv(), o = new mA(), a = this.group;
      this._controller = new Zv(n.getZr()), this._controllerHost = {
        target: a
      }, a.add(i.group), a.add(o.group), this._symbolDraw = i, this._lineDraw = o, this._firstRender = !0;
    }, t.prototype.render = function(r, n, i) {
      var o = this, a = r.coordinateSystem;
      this._model = r;
      var s = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (ZB(a)) {
        var c = {
          x: a.x,
          y: a.y,
          scaleX: a.scaleX,
          scaleY: a.scaleY
        };
        this._firstRender ? u.attr(c) : ur(u, c, r);
      }
      Ix(r.getGraph(), Hp(r));
      var d = r.getData();
      s.updateData(d);
      var h = r.getEdgeData();
      l.updateData(h), this._updateNodeAndLinkScale(), this._updateController(r, n, i), clearTimeout(this._layoutTimeout);
      var f = r.forceLayout, p = r.get(["force", "layoutAnimation"]);
      f && this._startForceLayoutIteration(f, p);
      var g = r.get("layout");
      d.graph.eachNode(function(C) {
        var S = C.dataIndex, b = C.getGraphicEl(), w = C.getModel();
        if (b) {
          b.off("drag").off("dragend");
          var x = w.get("draggable");
          x && b.on("drag", function(_) {
            switch (g) {
              case "force":
                f.warmUp(), !o._layouting && o._startForceLayoutIteration(f, p), f.setFixed(S), d.setItemLayout(S, [b.x, b.y]);
                break;
              case "circular":
                d.setItemLayout(S, [b.x, b.y]), C.setLayout({
                  fixed: !0
                }, !0), gA(r, "symbolSize", C, [_.offsetX, _.offsetY]), o.updateLayout(r);
                break;
              case "none":
              default:
                d.setItemLayout(S, [b.x, b.y]), pA(r.getGraph(), r), o.updateLayout(r);
                break;
            }
          }).on("dragend", function() {
            f && f.setUnfixed(S);
          }), b.setDraggable(x, !!w.get("cursor"));
          var R = w.get(["emphasis", "focus"]);
          R === "adjacency" && (St(b).focus = C.getAdjacentDataIndices());
        }
      }), d.graph.eachEdge(function(C) {
        var S = C.getGraphicEl(), b = C.getModel().get(["emphasis", "focus"]);
        S && b === "adjacency" && (St(S).focus = {
          edge: [C.dataIndex],
          node: [C.node1.dataIndex, C.node2.dataIndex]
        });
      });
      var v = r.get("layout") === "circular" && r.get(["circular", "rotateLabel"]), m = d.getLayout("cx"), y = d.getLayout("cy");
      d.graph.eachNode(function(C) {
        VU(C, v, m, y);
      }), this._firstRender = !1;
    }, t.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._startForceLayoutIteration = function(r, n) {
      var i = this;
      (function o() {
        r.step(function(a) {
          i.updateLayout(i._model), (i._layouting = !a) && (n ? i._layoutTimeout = setTimeout(o, 16) : o());
        });
      })();
    }, t.prototype._updateController = function(r, n, i) {
      var o = this, a = this._controller, s = this._controllerHost, l = this.group;
      if (a.setPointerChecker(function(u, c, d) {
        var h = l.getBoundingRect();
        return h.applyTransform(l.transform), h.contain(c, d) && !Tw(u, i, r);
      }), !ZB(r.coordinateSystem)) {
        a.disable();
        return;
      }
      a.enable(r.get("roam")), s.zoomLimit = r.get("scaleLimit"), s.zoom = r.coordinateSystem.getZoom(), a.off("pan").off("zoom").on("pan", function(u) {
        oA(s, u.dx, u.dy), i.dispatchAction({
          seriesId: r.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        aA(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: r.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), o._updateNodeAndLinkScale(), Ix(r.getGraph(), Hp(r)), o._lineDraw.updateLayout(), i.updateLabelLayout();
      });
    }, t.prototype._updateNodeAndLinkScale = function() {
      var r = this._model, n = r.getData(), i = Hp(r);
      n.eachItemGraphicEl(function(o, a) {
        o && o.setSymbolScale(i);
      });
    }, t.prototype.updateLayout = function(r) {
      Ix(r.getGraph(), Hp(r)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, t.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, t.type = "graph", t;
  }(br)
);
function Ud(e) {
  return "_EC_" + e;
}
var gDe = (
  /** @class */
  function() {
    function e(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
    }
    return e.prototype.isDirected = function() {
      return this._directed;
    }, e.prototype.addNode = function(t, r) {
      t = t == null ? "" + r : "" + t;
      var n = this._nodesMap;
      if (n[Ud(t)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var i = new rc(t, r);
      return i.hostGraph = this, this.nodes.push(i), n[Ud(t)] = i, i;
    }, e.prototype.getNodeByIndex = function(t) {
      var r = this.data.getRawIndex(t);
      return this.nodes[r];
    }, e.prototype.getNodeById = function(t) {
      return this._nodesMap[Ud(t)];
    }, e.prototype.addEdge = function(t, r, n) {
      var i = this._nodesMap, o = this._edgesMap;
      if (sr(t) && (t = this.nodes[t]), sr(r) && (r = this.nodes[r]), t instanceof rc || (t = i[Ud(t)]), r instanceof rc || (r = i[Ud(r)]), !(!t || !r)) {
        var a = t.id + "-" + r.id, s = new $U(t, r, n);
        return s.hostGraph = this, this._directed && (t.outEdges.push(s), r.inEdges.push(s)), t.edges.push(s), t !== r && r.edges.push(s), this.edges.push(s), o[a] = s, s;
      }
    }, e.prototype.getEdgeByIndex = function(t) {
      var r = this.edgeData.getRawIndex(t);
      return this.edges[r];
    }, e.prototype.getEdge = function(t, r) {
      t instanceof rc && (t = t.id), r instanceof rc && (r = r.id);
      var n = this._edgesMap;
      return this._directed ? n[t + "-" + r] : n[t + "-" + r] || n[r + "-" + t];
    }, e.prototype.eachNode = function(t, r) {
      for (var n = this.nodes, i = n.length, o = 0; o < i; o++)
        n[o].dataIndex >= 0 && t.call(r, n[o], o);
    }, e.prototype.eachEdge = function(t, r) {
      for (var n = this.edges, i = n.length, o = 0; o < i; o++)
        n[o].dataIndex >= 0 && n[o].node1.dataIndex >= 0 && n[o].node2.dataIndex >= 0 && t.call(r, n[o], o);
    }, e.prototype.breadthFirstTraverse = function(t, r, n, i) {
      if (r instanceof rc || (r = this._nodesMap[Ud(r)]), !!r) {
        for (var o = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", a = 0; a < this.nodes.length; a++)
          this.nodes[a].__visited = !1;
        if (!t.call(i, r, null))
          for (var s = [r]; s.length; )
            for (var l = s.shift(), u = l[o], a = 0; a < u.length; a++) {
              var c = u[a], d = c.node1 === l ? c.node2 : c.node1;
              if (!d.__visited) {
                if (t.call(i, d, l))
                  return;
                s.push(d), d.__visited = !0;
              }
            }
      }
    }, e.prototype.update = function() {
      for (var t = this.data, r = this.edgeData, n = this.nodes, i = this.edges, o = 0, a = n.length; o < a; o++)
        n[o].dataIndex = -1;
      for (var o = 0, a = t.count(); o < a; o++)
        n[t.getRawIndex(o)].dataIndex = o;
      r.filterSelf(function(s) {
        var l = i[r.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var o = 0, a = i.length; o < a; o++)
        i[o].dataIndex = -1;
      for (var o = 0, a = r.count(); o < a; o++)
        i[r.getRawIndex(o)].dataIndex = o;
    }, e.prototype.clone = function() {
      for (var t = new e(this._directed), r = this.nodes, n = this.edges, i = 0; i < r.length; i++)
        t.addNode(r[i].id, r[i].dataIndex);
      for (var i = 0; i < n.length; i++) {
        var o = n[i];
        t.addEdge(o.node1.id, o.node2.id, o.dataIndex);
      }
      return t;
    }, e;
  }()
), rc = (
  /** @class */
  function() {
    function e(t, r) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = r ?? -1;
    }
    return e.prototype.degree = function() {
      return this.edges.length;
    }, e.prototype.inDegree = function() {
      return this.inEdges.length;
    }, e.prototype.outDegree = function() {
      return this.outEdges.length;
    }, e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var r = this.hostGraph, n = r.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, r = 0; r < this.edges.length; r++) {
        var n = this.edges[r];
        n.dataIndex < 0 || (t.edge.push(n.dataIndex), t.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return t;
    }, e.prototype.getTrajectoryDataIndices = function() {
      for (var t = nt(), r = nt(), n = 0; n < this.edges.length; n++) {
        var i = this.edges[n];
        if (!(i.dataIndex < 0)) {
          t.set(i.dataIndex, !0);
          for (var o = [i.node1], a = [i.node2], s = 0; s < o.length; ) {
            var l = o[s];
            s++, r.set(l.dataIndex, !0);
            for (var u = 0; u < l.inEdges.length; u++)
              t.set(l.inEdges[u].dataIndex, !0), o.push(l.inEdges[u].node1);
          }
          for (s = 0; s < a.length; ) {
            var c = a[s];
            s++, r.set(c.dataIndex, !0);
            for (var u = 0; u < c.outEdges.length; u++)
              t.set(c.outEdges[u].dataIndex, !0), a.push(c.outEdges[u].node2);
          }
        }
      }
      return {
        edge: t.keys(),
        node: r.keys()
      };
    }, e;
  }()
), $U = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.dataIndex = -1, this.node1 = t, this.node2 = r, this.dataIndex = n ?? -1;
    }
    return e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var r = this.hostGraph, n = r.edgeData.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, e.prototype.getTrajectoryDataIndices = function() {
      var t = nt(), r = nt();
      t.set(this.dataIndex, !0);
      for (var n = [this.node1], i = [this.node2], o = 0; o < n.length; ) {
        var a = n[o];
        o++, r.set(a.dataIndex, !0);
        for (var s = 0; s < a.inEdges.length; s++)
          t.set(a.inEdges[s].dataIndex, !0), n.push(a.inEdges[s].node1);
      }
      for (o = 0; o < i.length; ) {
        var l = i[o];
        o++, r.set(l.dataIndex, !0);
        for (var s = 0; s < l.outEdges.length; s++)
          t.set(l.outEdges[s].dataIndex, !0), i.push(l.outEdges[s].node2);
      }
      return {
        edge: t.keys(),
        node: r.keys()
      };
    }, e;
  }()
);
function HU(e, t) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(r) {
      var n = this[e][t];
      return n.getStore().get(n.getDimensionIndex(r || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(r, n) {
      this.dataIndex >= 0 && this[e][t].setItemVisual(this.dataIndex, r, n);
    },
    getVisual: function(r) {
      return this[e][t].getItemVisual(this.dataIndex, r);
    },
    setLayout: function(r, n) {
      this.dataIndex >= 0 && this[e][t].setItemLayout(this.dataIndex, r, n);
    },
    getLayout: function() {
      return this[e][t].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[e][t].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[e][t].getRawIndex(this.dataIndex);
    }
  };
}
cn(rc, HU("hostGraph", "data"));
cn($U, HU("hostGraph", "edgeData"));
function GU(e, t, r, n, i) {
  for (var o = new gDe(n), a = 0; a < e.length; a++)
    o.addNode(vn(
      // Id, name, dataIndex
      e[a].id,
      e[a].name,
      a
    ), a);
  for (var s = [], l = [], u = 0, a = 0; a < t.length; a++) {
    var c = t[a], d = c.source, h = c.target;
    o.addEdge(d, h, u) && (l.push(c), s.push(vn(In(c.id, null), d + " > " + h)), u++);
  }
  var f = r.get("coordinateSystem"), p;
  if (f === "cartesian2d" || f === "polar")
    p = ws(e, r);
  else {
    var g = ld.get(f), v = g ? g.dimensions || [] : [];
    Ft(v, "value") < 0 && v.concat(["value"]);
    var m = Tf(e, {
      coordDimensions: v,
      encodeDefine: r.getEncode()
    }).dimensions;
    p = new di(m, r), p.initData(e);
  }
  var y = new di(["value"], r);
  return y.initData(l, s), i && i(p, y), xU({
    mainData: p,
    struct: o,
    structAttr: "graph",
    datas: {
      node: p,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), o.update(), o;
}
var vDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments);
      var n = this;
      function i() {
        return n._categoriesData;
      }
      this.legendVisualProvider = new Xv(i, i), this.fillDataTextStyle(r.edges || r.links), this._updateCategoriesData();
    }, t.prototype.mergeOption = function(r) {
      e.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(r.edges || r.links), this._updateCategoriesData();
    }, t.prototype.mergeDefaultAndTheme = function(r) {
      e.prototype.mergeDefaultAndTheme.apply(this, arguments), Gc(r, "edgeLabel", ["show"]);
    }, t.prototype.getInitialData = function(r, n) {
      var i = r.edges || r.links || [], o = r.data || r.nodes || [], a = this;
      if (o && i) {
        rDe(this);
        var s = GU(o, i, this, !0, l);
        return $(s.edges, function(u) {
          nDe(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var g = a._categoriesModels, v = p.getShallow("category"), m = g[v];
          return m && (m.parentModel = p.parentModel, p.parentModel = m), p;
        });
        var d = _r.prototype.getModel;
        function h(p, g) {
          var v = d.call(this, p, g);
          return v.resolveParentPath = f, v;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = f, p.getModel = h, p;
        });
        function f(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var g = p.slice();
            return p[0] === "label" ? g[0] = "edgeLabel" : p[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return p;
        }
      }
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, t.prototype.formatTooltip = function(r, n, i) {
      if (i === "edge") {
        var o = this.getData(), a = this.getDataParams(r, i), s = o.graph.getEdgeByIndex(r), l = o.getName(s.node1.dataIndex), u = o.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), Hn("nameValue", {
          name: c.join(" > "),
          value: a.value,
          noValue: a.value == null
        });
      }
      var d = c9({
        series: this,
        dataIndex: r,
        multipleSeries: n
      });
      return d;
    }, t.prototype._updateCategoriesData = function() {
      var r = Ee(this.option.categories || [], function(i) {
        return i.value != null ? i : ge({
          value: 0
        }, i);
      }), n = new di(["value"], this);
      n.initData(r), this._categoriesData = n, this._categoriesModels = n.mapArray(function(i) {
        return n.getItemModel(i);
      });
    }, t.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, t.prototype.setCenter = function(r) {
      this.option.center = r;
    }, t.prototype.isAnimationEnabled = function() {
      return e.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, t.type = "series.graph", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, t;
  }(Pr)
), mDe = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function yDe(e) {
  e.registerChartView(pDe), e.registerSeriesModel(vDe), e.registerProcessor(ZMe), e.registerVisual(QMe), e.registerVisual(JMe), e.registerLayout(iDe), e.registerLayout(e.PRIORITY.VISUAL.POST_CHART_LAYOUT, aDe), e.registerLayout(lDe), e.registerCoordinateSystem("graphView", {
    dimensions: Qv.dimensions,
    create: cDe
  }), e.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, un), e.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, un), e.registerAction(mDe, function(t, r, n) {
    r.eachComponent({
      mainType: "series",
      query: t
    }, function(i) {
      var o = i.coordinateSystem, a = lA(o, t, void 0, n);
      i.setCenter && i.setCenter(a.center), i.setZoom && i.setZoom(a.zoom);
    });
  });
}
var CDe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return e;
  }()
), SDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "pointer", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new CDe();
    }, t.prototype.buildPath = function(r, n) {
      var i = Math.cos, o = Math.sin, a = n.r, s = n.width, l = n.angle, u = n.x - i(l) * s * (s >= a / 3 ? 1 : 2), c = n.y - o(l) * s * (s >= a / 3 ? 1 : 2);
      l = n.angle - Math.PI / 2, r.moveTo(u, c), r.lineTo(n.x + i(l) * s, n.y + o(l) * s), r.lineTo(n.x + i(n.angle) * a, n.y + o(n.angle) * a), r.lineTo(n.x - i(l) * s, n.y - o(l) * s), r.lineTo(u, c);
    }, t;
  }(Ht)
);
function wDe(e, t) {
  var r = e.get("center"), n = t.getWidth(), i = t.getHeight(), o = Math.min(n, i), a = Be(r[0], t.getWidth()), s = Be(r[1], t.getHeight()), l = Be(e.get("radius"), o / 2);
  return {
    cx: a,
    cy: s,
    r: l
  };
}
function wy(e, t) {
  var r = e == null ? "" : e + "";
  return t && (He(t) ? r = t.replace("{value}", r) : at(t) && (r = t(e))), r;
}
var bDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      this.group.removeAll();
      var o = r.get(["axisLine", "lineStyle", "color"]), a = wDe(r, i);
      this._renderMain(r, n, i, o, a), this._data = r.getData();
    }, t.prototype.dispose = function() {
    }, t.prototype._renderMain = function(r, n, i, o, a) {
      var s = this.group, l = r.get("clockwise"), u = -r.get("startAngle") / 180 * Math.PI, c = -r.get("endAngle") / 180 * Math.PI, d = r.getModel("axisLine"), h = d.get("roundCap"), f = h ? AC : Oi, p = d.get("show"), g = d.getModel("lineStyle"), v = g.get("width"), m = [u, c];
      QM(m, !l), u = m[0], c = m[1];
      for (var y = c - u, C = u, S = [], b = 0; p && b < o.length; b++) {
        var w = Math.min(Math.max(o[b][0], 0), 1);
        c = u + y * w;
        var x = new f({
          shape: {
            startAngle: C,
            endAngle: c,
            cx: a.cx,
            cy: a.cy,
            clockwise: l,
            r0: a.r - v,
            r: a.r
          },
          silent: !0
        });
        x.setStyle({
          fill: o[b][1]
        }), x.setStyle(g.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), S.push(x), C = c;
      }
      S.reverse(), $(S, function(_) {
        return s.add(_);
      });
      var R = function(_) {
        if (_ <= 0)
          return o[0][1];
        var T;
        for (T = 0; T < o.length; T++)
          if (o[T][0] >= _ && (T === 0 ? 0 : o[T - 1][0]) < _)
            return o[T][1];
        return o[T - 1][1];
      };
      this._renderTicks(r, n, i, R, a, u, c, l, v), this._renderTitleAndDetail(r, n, i, R, a), this._renderAnchor(r, a), this._renderPointer(r, n, i, R, a, u, c, l, v);
    }, t.prototype._renderTicks = function(r, n, i, o, a, s, l, u, c) {
      for (var d = this.group, h = a.cx, f = a.cy, p = a.r, g = +r.get("min"), v = +r.get("max"), m = r.getModel("splitLine"), y = r.getModel("axisTick"), C = r.getModel("axisLabel"), S = r.get("splitNumber"), b = y.get("splitNumber"), w = Be(m.get("length"), p), x = Be(y.get("length"), p), R = s, _ = (l - s) / S, T = _ / b, P = m.getModel("lineStyle").getLineStyle(), D = y.getModel("lineStyle").getLineStyle(), O = m.get("distance"), A, F, L = 0; L <= S; L++) {
        if (A = Math.cos(R), F = Math.sin(R), m.get("show")) {
          var N = O ? O + c : c, I = new Nn({
            shape: {
              x1: A * (p - N) + h,
              y1: F * (p - N) + f,
              x2: A * (p - w - N) + h,
              y2: F * (p - w - N) + f
            },
            style: P,
            silent: !0
          });
          P.stroke === "auto" && I.setStyle({
            stroke: o(L / S)
          }), d.add(I);
        }
        if (C.get("show")) {
          var N = C.get("distance") + O, B = wy(an(L / S * (v - g) + g), C.get("formatter")), M = o(L / S), V = A * (p - w - N) + h, G = F * (p - w - N) + f, k = C.get("rotate"), z = 0;
          k === "radial" ? (z = -R + 2 * Math.PI, z > Math.PI / 2 && (z += Math.PI)) : k === "tangential" ? z = -R - Math.PI / 2 : sr(k) && (z = k * Math.PI / 180), z === 0 ? d.add(new ir({
            style: Vr(C, {
              text: B,
              x: V,
              y: G,
              verticalAlign: F < -0.8 ? "top" : F > 0.8 ? "bottom" : "middle",
              align: A < -0.4 ? "left" : A > 0.4 ? "right" : "center"
            }, {
              inheritColor: M
            }),
            silent: !0
          })) : d.add(new ir({
            style: Vr(C, {
              text: B,
              x: V,
              y: G,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: M
            }),
            silent: !0,
            originX: V,
            originY: G,
            rotation: z
          }));
        }
        if (y.get("show") && L !== S) {
          var N = y.get("distance");
          N = N ? N + c : c;
          for (var j = 0; j <= b; j++) {
            A = Math.cos(R), F = Math.sin(R);
            var q = new Nn({
              shape: {
                x1: A * (p - N) + h,
                y1: F * (p - N) + f,
                x2: A * (p - x - N) + h,
                y2: F * (p - x - N) + f
              },
              silent: !0,
              style: D
            });
            D.stroke === "auto" && q.setStyle({
              stroke: o((L + j / b) / S)
            }), d.add(q), R += T;
          }
          R -= T;
        } else
          R += _;
      }
    }, t.prototype._renderPointer = function(r, n, i, o, a, s, l, u, c) {
      var d = this.group, h = this._data, f = this._progressEls, p = [], g = r.get(["pointer", "show"]), v = r.getModel("progress"), m = v.get("show"), y = r.getData(), C = y.mapDimension("value"), S = +r.get("min"), b = +r.get("max"), w = [S, b], x = [s, l];
      function R(T, P) {
        var D = y.getItemModel(T), O = D.getModel("pointer"), A = Be(O.get("width"), a.r), F = Be(O.get("length"), a.r), L = r.get(["pointer", "icon"]), N = O.get("offsetCenter"), I = Be(N[0], a.r), B = Be(N[1], a.r), M = O.get("keepAspect"), V;
        return L ? V = mn(L, I - A / 2, B - F, A, F, null, M) : V = new SDe({
          shape: {
            angle: -Math.PI / 2,
            width: A,
            r: F,
            x: I,
            y: B
          }
        }), V.rotation = -(P + Math.PI / 2), V.x = a.cx, V.y = a.cy, V;
      }
      function _(T, P) {
        var D = v.get("roundCap"), O = D ? AC : Oi, A = v.get("overlap"), F = A ? v.get("width") : c / y.count(), L = A ? a.r - F : a.r - (T + 1) * F, N = A ? a.r : a.r - T * F, I = new O({
          shape: {
            startAngle: s,
            endAngle: P,
            cx: a.cx,
            cy: a.cy,
            clockwise: u,
            r0: L,
            r: N
          }
        });
        return A && (I.z2 = b - y.get(C, T) % b), I;
      }
      (m || g) && (y.diff(h).add(function(T) {
        var P = y.get(C, T);
        if (g) {
          var D = R(T, s);
          jr(D, {
            rotation: -((isNaN(+P) ? x[0] : Cr(P, w, x, !0)) + Math.PI / 2)
          }, r), d.add(D), y.setItemGraphicEl(T, D);
        }
        if (m) {
          var O = _(T, s), A = v.get("clip");
          jr(O, {
            shape: {
              endAngle: Cr(P, w, x, A)
            }
          }, r), d.add(O), F_(r.seriesIndex, y.dataType, T, O), p[T] = O;
        }
      }).update(function(T, P) {
        var D = y.get(C, T);
        if (g) {
          var O = h.getItemGraphicEl(P), A = O ? O.rotation : s, F = R(T, A);
          F.rotation = A, ur(F, {
            rotation: -((isNaN(+D) ? x[0] : Cr(D, w, x, !0)) + Math.PI / 2)
          }, r), d.add(F), y.setItemGraphicEl(T, F);
        }
        if (m) {
          var L = f[P], N = L ? L.shape.endAngle : s, I = _(T, N), B = v.get("clip");
          ur(I, {
            shape: {
              endAngle: Cr(D, w, x, B)
            }
          }, r), d.add(I), F_(r.seriesIndex, y.dataType, T, I), p[T] = I;
        }
      }).execute(), y.each(function(T) {
        var P = y.getItemModel(T), D = P.getModel("emphasis"), O = D.get("focus"), A = D.get("blurScope"), F = D.get("disabled");
        if (g) {
          var L = y.getItemGraphicEl(T), N = y.getItemVisual(T, "style"), I = N.fill;
          if (L instanceof qn) {
            var B = L.style;
            L.useStyle(ge({
              image: B.image,
              x: B.x,
              y: B.y,
              width: B.width,
              height: B.height
            }, N));
          } else
            L.useStyle(N), L.type !== "pointer" && L.setColor(I);
          L.setStyle(P.getModel(["pointer", "itemStyle"]).getItemStyle()), L.style.fill === "auto" && L.setStyle("fill", o(Cr(y.get(C, T), w, [0, 1], !0))), L.z2EmphasisLift = 0, ti(L, P), sn(L, O, A, F);
        }
        if (m) {
          var M = p[T];
          M.useStyle(y.getItemVisual(T, "style")), M.setStyle(P.getModel(["progress", "itemStyle"]).getItemStyle()), M.z2EmphasisLift = 0, ti(M, P), sn(M, O, A, F);
        }
      }), this._progressEls = p);
    }, t.prototype._renderAnchor = function(r, n) {
      var i = r.getModel("anchor"), o = i.get("show");
      if (o) {
        var a = i.get("size"), s = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = mn(s, n.cx - a / 2 + Be(l[0], n.r), n.cy - a / 2 + Be(l[1], n.r), a, a, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, t.prototype._renderTitleAndDetail = function(r, n, i, o, a) {
      var s = this, l = r.getData(), u = l.mapDimension("value"), c = +r.get("min"), d = +r.get("max"), h = new Ct(), f = [], p = [], g = r.isAnimationEnabled(), v = r.get(["pointer", "showAbove"]);
      l.diff(this._data).add(function(m) {
        f[m] = new ir({
          silent: !0
        }), p[m] = new ir({
          silent: !0
        });
      }).update(function(m, y) {
        f[m] = s._titleEls[y], p[m] = s._detailEls[y];
      }).execute(), l.each(function(m) {
        var y = l.getItemModel(m), C = l.get(u, m), S = new Ct(), b = o(Cr(C, [c, d], [0, 1], !0)), w = y.getModel("title");
        if (w.get("show")) {
          var x = w.get("offsetCenter"), R = a.cx + Be(x[0], a.r), _ = a.cy + Be(x[1], a.r), T = f[m];
          T.attr({
            z2: v ? 0 : 2,
            style: Vr(w, {
              x: R,
              y: _,
              text: l.getName(m),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: b
            })
          }), S.add(T);
        }
        var P = y.getModel("detail");
        if (P.get("show")) {
          var D = P.get("offsetCenter"), O = a.cx + Be(D[0], a.r), A = a.cy + Be(D[1], a.r), F = Be(P.get("width"), a.r), L = Be(P.get("height"), a.r), N = r.get(["progress", "show"]) ? l.getItemVisual(m, "style").fill : b, T = p[m], I = P.get("formatter");
          T.attr({
            z2: v ? 0 : 2,
            style: Vr(P, {
              x: O,
              y: A,
              text: wy(C, I),
              width: isNaN(F) ? null : F,
              height: isNaN(L) ? null : L,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: N
            })
          }), y7(T, {
            normal: P
          }, C, function(M) {
            return wy(M, I);
          }), g && C7(T, m, l, r, {
            getFormattedLabel: function(M, V, G, k, z, j) {
              return wy(j ? j.interpolatedValue : C, I);
            }
          }), S.add(T);
        }
        h.add(S);
      }), this.group.add(h), this._titleEls = f, this._detailEls = p;
    }, t.type = "gauge", t;
  }(br)
), xDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.visualStyleAccessPath = "itemStyle", r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return Df(this, ["value"]);
    }, t.type = "series.gauge", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 
      min: 0,
      // 
      max: 100,
      // 10
      splitNumber: 10,
      // 
      axisLine: {
        // show
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, "#E6EBF8"]],
          width: 10
        }
      },
      // 
      progress: {
        // show
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 
      splitLine: {
        // show
        show: !0,
        // length
        length: 10,
        distance: 10,
        // lineStylelineStyle
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      // 
      axisTick: {
        // show
        show: !0,
        // split
        splitNumber: 5,
        // length
        length: 6,
        distance: 10,
        // lineStyle
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: !0,
        // x, ypx
        offsetCenter: [0, "20%"],
        // TEXTSTYLE
        color: "#464646",
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [5, 10],
        // x, ypx
        offsetCenter: [0, "40%"],
        // formatter: null,
        // TEXTSTYLE
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, t;
  }(Pr)
);
function EDe(e) {
  e.registerChartView(bDe), e.registerSeriesModel(xDe);
}
var RDe = ["itemStyle", "opacity"], _De = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n) {
      var i = e.call(this) || this, o = i, a = new Ni(), s = new ir();
      return o.setTextContent(s), i.setTextGuideLine(a), i.updateData(r, n, !0), i;
    }
    return t.prototype.updateData = function(r, n, i) {
      var o = this, a = r.hostModel, s = r.getItemModel(n), l = r.getItemLayout(n), u = s.getModel("emphasis"), c = s.get(RDe);
      c = c ?? 1, i || Fa(o), o.useStyle(r.getItemVisual(n, "style")), o.style.lineJoin = "round", i ? (o.setShape({
        points: l.points
      }), o.style.opacity = 0, jr(o, {
        style: {
          opacity: c
        }
      }, a, n)) : ur(o, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, a, n), ti(o, s), this._updateLabel(r, n), sn(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(r, n) {
      var i = this, o = this.getTextGuideLine(), a = i.getTextContent(), s = r.hostModel, l = r.getItemModel(n), u = r.getItemLayout(n), c = u.label, d = r.getItemVisual(n, "style"), h = d.fill;
      ri(
        // position will not be used in setLabelStyle
        a,
        $n(l),
        {
          labelFetcher: r.hostModel,
          labelDataIndex: n,
          defaultOpacity: d.opacity,
          defaultText: r.getName(n)
        },
        {
          normal: {
            align: c.textAlign,
            verticalAlign: c.verticalAlign
          }
        }
      ), i.setTextConfig({
        local: !0,
        inside: !!c.inside,
        insideStroke: h,
        // insideFill: 'auto',
        outsideFill: h
      });
      var f = c.linePoints;
      o.setShape({
        points: f
      }), i.textGuideLineConfig = {
        anchor: f ? new Dt(f[0][0], f[0][1]) : null
      }, ur(a, {
        style: {
          x: c.x,
          y: c.y
        }
      }, s, n), a.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), YD(i, qD(l), {
        // Default use item visual color
        stroke: h
      });
    }, t;
  }(Li)
), TDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.ignoreLabelLineUpdate = !0, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this._data, s = this.group;
      o.diff(a).add(function(l) {
        var u = new _De(o, l);
        o.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var c = a.getItemGraphicEl(u);
        c.updateData(o, l), s.add(c), o.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = a.getItemGraphicEl(l);
        Ug(u, r, l);
      }).execute(), this._data = o;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.prototype.dispose = function() {
    }, t.type = "funnel", t;
  }(br)
), PDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments), this.legendVisualProvider = new Xv(je(this.getData, this), je(this.getRawData, this)), this._defaultLabelLine(r);
    }, t.prototype.getInitialData = function(r, n) {
      return Df(this, {
        coordDimensions: ["value"],
        encodeDefaulter: _t(wD, this)
      });
    }, t.prototype._defaultLabelLine = function(r) {
      Gc(r, "labelLine", ["show"]);
      var n = r.labelLine, i = r.emphasis.labelLine;
      n.show = n.show && r.label.show, i.show = i.show && r.emphasis.label.show;
    }, t.prototype.getDataParams = function(r) {
      var n = this.getData(), i = e.prototype.getDataParams.call(this, r), o = n.mapDimension("value"), a = n.getSum(o);
      return i.percent = a ? +(n.get(o, r) / a * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, t.type = "series.funnel", t.defaultOption = {
      // zlevel: 0,                  // 
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: Tooltip.formatter
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: ,
          width: 1
        }
      },
      itemStyle: {
        // color: ,
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, t;
  }(Pr)
);
function MDe(e, t) {
  return En(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function DDe(e, t) {
  for (var r = e.mapDimension("value"), n = e.mapArray(r, function(l) {
    return l;
  }), i = [], o = t === "ascending", a = 0, s = e.count(); a < s; a++)
    i[a] = a;
  return at(t) ? i.sort(t) : t !== "none" && i.sort(function(l, u) {
    return o ? n[l] - n[u] : n[u] - n[l];
  }), i;
}
function ADe(e) {
  var t = e.hostModel, r = t.get("orient");
  e.each(function(n) {
    var i = e.getItemModel(n), o = i.getModel("label"), a = o.get("position"), s = i.getModel("labelLine"), l = e.getItemLayout(n), u = l.points, c = a === "inner" || a === "inside" || a === "center" || a === "insideLeft" || a === "insideRight", d, h, f, p;
    if (c)
      a === "insideLeft" ? (h = (u[0][0] + u[3][0]) / 2 + 5, f = (u[0][1] + u[3][1]) / 2, d = "left") : a === "insideRight" ? (h = (u[1][0] + u[2][0]) / 2 - 5, f = (u[1][1] + u[2][1]) / 2, d = "right") : (h = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, f = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, d = "center"), p = [[h, f], [h, f]];
    else {
      var g = void 0, v = void 0, m = void 0, y = void 0, C = s.get("length");
      process.env.NODE_ENV !== "production" && (r === "vertical" && ["top", "bottom"].indexOf(a) > -1 && (a = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), r === "horizontal" && ["left", "right"].indexOf(a) > -1 && (a = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), a === "left" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, m = g - C, h = m - 5, d = "right") : a === "right" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, m = g + C, h = m + 5, d = "left") : a === "top" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, y = v - C, f = y - 5, d = "center") : a === "bottom" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, y = v + C, f = y + 5, d = "center") : a === "rightTop" ? (g = r === "horizontal" ? u[3][0] : u[1][0], v = r === "horizontal" ? u[3][1] : u[1][1], r === "horizontal" ? (y = v - C, f = y - 5, d = "center") : (m = g + C, h = m + 5, d = "top")) : a === "rightBottom" ? (g = u[2][0], v = u[2][1], r === "horizontal" ? (y = v + C, f = y + 5, d = "center") : (m = g + C, h = m + 5, d = "bottom")) : a === "leftTop" ? (g = u[0][0], v = r === "horizontal" ? u[0][1] : u[1][1], r === "horizontal" ? (y = v - C, f = y - 5, d = "center") : (m = g - C, h = m - 5, d = "right")) : a === "leftBottom" ? (g = r === "horizontal" ? u[1][0] : u[3][0], v = r === "horizontal" ? u[1][1] : u[2][1], r === "horizontal" ? (y = v + C, f = y + 5, d = "center") : (m = g - C, h = m - 5, d = "right")) : (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, r === "horizontal" ? (y = v + C, f = y + 5, d = "center") : (m = g + C, h = m + 5, d = "left")), r === "horizontal" ? (m = g, h = m) : (y = v, f = y), p = [[g, v], [m, y]];
    }
    l.label = {
      linePoints: p,
      x: h,
      y: f,
      verticalAlign: "middle",
      textAlign: d,
      inside: c
    };
  });
}
function IDe(e, t) {
  e.eachSeriesByType("funnel", function(r) {
    var n = r.getData(), i = n.mapDimension("value"), o = r.get("sort"), a = MDe(r, t), s = r.get("orient"), l = a.width, u = a.height, c = DDe(n, o), d = a.x, h = a.y, f = s === "horizontal" ? [Be(r.get("minSize"), u), Be(r.get("maxSize"), u)] : [Be(r.get("minSize"), l), Be(r.get("maxSize"), l)], p = n.getDataExtent(i), g = r.get("min"), v = r.get("max");
    g == null && (g = Math.min(p[0], 0)), v == null && (v = p[1]);
    var m = r.get("funnelAlign"), y = r.get("gap"), C = s === "horizontal" ? l : u, S = (C - y * (n.count() - 1)) / n.count(), b = function(A, F) {
      if (s === "horizontal") {
        var L = n.get(i, A) || 0, N = Cr(L, [g, v], f, !0), I = void 0;
        switch (m) {
          case "top":
            I = h;
            break;
          case "center":
            I = h + (u - N) / 2;
            break;
          case "bottom":
            I = h + (u - N);
            break;
        }
        return [[F, I], [F, I + N]];
      }
      var B = n.get(i, A) || 0, M = Cr(B, [g, v], f, !0), V;
      switch (m) {
        case "left":
          V = d;
          break;
        case "center":
          V = d + (l - M) / 2;
          break;
        case "right":
          V = d + l - M;
          break;
      }
      return [[V, F], [V + M, F]];
    };
    o === "ascending" && (S = -S, y = -y, s === "horizontal" ? d += l : h += u, c = c.reverse());
    for (var w = 0; w < c.length; w++) {
      var x = c[w], R = c[w + 1], _ = n.getItemModel(x);
      if (s === "horizontal") {
        var T = _.get(["itemStyle", "width"]);
        T == null ? T = S : (T = Be(T, l), o === "ascending" && (T = -T));
        var P = b(x, d), D = b(R, d + T);
        d += T + y, n.setItemLayout(x, {
          points: P.concat(D.slice().reverse())
        });
      } else {
        var O = _.get(["itemStyle", "height"]);
        O == null ? O = S : (O = Be(O, u), o === "ascending" && (O = -O));
        var P = b(x, h), D = b(R, h + O);
        h += O + y, n.setItemLayout(x, {
          points: P.concat(D.slice().reverse())
        });
      }
    }
    ADe(n);
  });
}
function ODe(e) {
  e.registerChartView(TDe), e.registerSeriesModel(PDe), e.registerLayout(IDe), e.registerProcessor(qv("funnel"));
}
var LDe = 0.3, FDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._dataGroup = new Ct(), r._initialized = !1, r;
    }
    return t.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, t.prototype.render = function(r, n, i, o) {
      this._progressiveEls = null;
      var a = this._dataGroup, s = r.getData(), l = this._data, u = r.coordinateSystem, c = u.dimensions, d = JB(r);
      s.diff(l).add(h).update(f).remove(p).execute();
      function h(v) {
        var m = QB(s, a, v, c, u);
        Ox(m, s, v, d);
      }
      function f(v, m) {
        var y = l.getItemGraphicEl(m), C = zU(s, v, c, u);
        s.setItemGraphicEl(v, y), ur(y, {
          shape: {
            points: C
          }
        }, r, v), Fa(y), Ox(y, s, v, d);
      }
      function p(v) {
        var m = l.getItemGraphicEl(v);
        a.remove(m);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var g = NDe(u, r, function() {
          setTimeout(function() {
            a.removeClipPath();
          });
        });
        a.setClipPath(g);
      }
      this._data = s;
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, t.prototype.incrementalRender = function(r, n, i) {
      for (var o = n.getData(), a = n.coordinateSystem, s = a.dimensions, l = JB(n), u = this._progressiveEls = [], c = r.start; c < r.end; c++) {
        var d = QB(o, this._dataGroup, c, s, a);
        d.incremental = !0, Ox(d, o, c, l), u.push(d);
      }
    }, t.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, t.type = "parallel", t;
  }(br)
);
function NDe(e, t, r) {
  var n = e.model, i = e.getRect(), o = new or({
    shape: {
      x: i.x,
      y: i.y,
      width: i.width,
      height: i.height
    }
  }), a = n.get("layout") === "horizontal" ? "width" : "height";
  return o.setShape(a, 0), jr(o, {
    shape: {
      width: i.width,
      height: i.height
    }
  }, t, r), o;
}
function zU(e, t, r, n) {
  for (var i = [], o = 0; o < r.length; o++) {
    var a = r[o], s = e.get(e.mapDimension(a), t);
    kDe(s, n.getAxis(a).type) || i.push(n.dataToPoint(s, a));
  }
  return i;
}
function QB(e, t, r, n, i) {
  var o = zU(e, r, n, i), a = new Ni({
    shape: {
      points: o
    },
    // silent: true,
    z2: 10
  });
  return t.add(a), e.setItemGraphicEl(r, a), a;
}
function JB(e) {
  var t = e.get("smooth", !0);
  return t === !0 && (t = LDe), t = vs(t), nu(t) && (t = 0), {
    smooth: t
  };
}
function Ox(e, t, r, n) {
  e.useStyle(t.getItemVisual(r, "style")), e.style.fill = null, e.setShape("smooth", n.smooth);
  var i = t.getItemModel(r), o = i.getModel("emphasis");
  ti(e, i, "lineStyle"), sn(e, o.get("focus"), o.get("blurScope"), o.get("disabled"));
}
function kDe(e, t) {
  return t === "category" ? e == null : e == null || isNaN(e);
}
var VDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.visualStyleAccessPath = "lineStyle", r.visualDrawType = "stroke", r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return ws(null, this, {
        useEncodeDefaulter: je(BDe, null, this)
      });
    }, t.prototype.getRawIndicesByActiveState = function(r) {
      var n = this.coordinateSystem, i = this.getData(), o = [];
      return n.eachActiveState(i, function(a, s) {
        r === a && o.push(i.getRawIndex(s));
      }), o;
    }, t.type = "series.parallel", t.dependencies = ["parallel"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, t;
  }(Pr)
);
function BDe(e) {
  var t = e.ecModel.getComponent("parallel", e.get("parallelIndex"));
  if (t) {
    var r = {};
    return $(t.dimensions, function(n) {
      var i = $De(n);
      r[n] = i;
    }), r;
  }
}
function $De(e) {
  return +e.replace("dim", "");
}
var HDe = ["lineStyle", "opacity"], GDe = {
  seriesType: "parallel",
  reset: function(e, t) {
    var r = e.coordinateSystem, n = {
      normal: e.get(["lineStyle", "opacity"]),
      active: e.get("activeOpacity"),
      inactive: e.get("inactiveOpacity")
    };
    return {
      progress: function(i, o) {
        r.eachActiveState(o, function(a, s) {
          var l = n[a];
          if (a === "normal" && o.hasItemOption) {
            var u = o.getItemModel(s).get(HDe, !0);
            u != null && (l = u);
          }
          var c = o.ensureUniqueItemVisual(s, "style");
          c.opacity = l;
        }, i.start, i.end);
      }
    };
  }
};
function zDe(e) {
  WDe(e), jDe(e);
}
function WDe(e) {
  if (!e.parallel) {
    var t = !1;
    $(e.series, function(r) {
      r && r.type === "parallel" && (t = !0);
    }), t && (e.parallel = [{}]);
  }
}
function jDe(e) {
  var t = Tr(e.parallelAxis);
  $(t, function(r) {
    if (lt(r)) {
      var n = r.parallelIndex || 0, i = Tr(e.parallel)[n];
      i && i.parallelAxisDefault && Mt(r, i.parallelAxisDefault, !1);
    }
  });
}
var UDe = 5, KDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      this._model = r, this._api = i, this._handlers || (this._handlers = {}, $(YDe, function(o, a) {
        i.getZr().on(a, this._handlers[a] = je(o, this));
      }, this)), Rf(this, "_throttledDispatchExpand", r.get("axisExpandRate"), "fixRate");
    }, t.prototype.dispose = function(r, n) {
      Xg(this, "_throttledDispatchExpand"), $(this._handlers, function(i, o) {
        n.getZr().off(o, i);
      }), this._handlers = null;
    }, t.prototype._throttledDispatchExpand = function(r) {
      this._dispatchExpand(r);
    }, t.prototype._dispatchExpand = function(r) {
      r && this._api.dispatchAction(ge({
        type: "parallelAxisExpand"
      }, r));
    }, t.type = "parallel", t;
  }(zr)
), YDe = {
  mousedown: function(e) {
    Lx(this, "click") && (this._mouseDownPoint = [e.offsetX, e.offsetY]);
  },
  mouseup: function(e) {
    var t = this._mouseDownPoint;
    if (Lx(this, "click") && t) {
      var r = [e.offsetX, e.offsetY], n = Math.pow(t[0] - r[0], 2) + Math.pow(t[1] - r[1], 2);
      if (n > UDe)
        return;
      var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);
      i.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: i.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(e) {
    if (!(this._mouseDownPoint || !Lx(this, "mousemove"))) {
      var t = this._model, r = t.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]), n = r.behavior;
      n === "jump" && this._throttledDispatchExpand.debounceNextCall(t.get("axisExpandDebounce")), this._throttledDispatchExpand(n === "none" ? null : {
        axisExpandWindow: r.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: n === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function Lx(e, t) {
  var r = e._model;
  return r.get("axisExpandable") && r.get("axisExpandTriggerOn") === t;
}
var qDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function() {
      e.prototype.init.apply(this, arguments), this.mergeOption({});
    }, t.prototype.mergeOption = function(r) {
      var n = this.option;
      r && Mt(n, r, !0), this._initDimensions();
    }, t.prototype.contains = function(r, n) {
      var i = r.get("parallelIndex");
      return i != null && n.getComponent("parallel", i) === this;
    }, t.prototype.setAxisExpand = function(r) {
      $(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(n) {
        r.hasOwnProperty(n) && (this.option[n] = r[n]);
      }, this);
    }, t.prototype._initDimensions = function() {
      var r = this.dimensions = [], n = this.parallelAxisIndex = [], i = Sr(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(o) {
        return (o.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      $(i, function(o) {
        r.push("dim" + o.get("dim")), n.push(o.componentIndex);
      });
    }, t.type = "parallel", t.dependencies = ["parallelAxis"], t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, t;
  }(Vt)
), XDe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i, o, a) {
      var s = e.call(this, r, n, i) || this;
      return s.type = o || "value", s.axisIndex = a, s;
    }
    return t.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, t;
  }(sa)
);
function hd(e, t, r, n, i, o) {
  e = e || 0;
  var a = r[1] - r[0];
  if (i != null && (i = Kd(i, [0, a])), o != null && (o = Math.max(o, i ?? 0)), n === "all") {
    var s = Math.abs(t[1] - t[0]);
    s = Kd(s, [0, a]), i = o = Kd(s, [i, o]), n = 0;
  }
  t[0] = Kd(t[0], r), t[1] = Kd(t[1], r);
  var l = Fx(t, n);
  t[n] += e;
  var u = i || 0, c = r.slice();
  l.sign < 0 ? c[0] += u : c[1] -= u, t[n] = Kd(t[n], c);
  var d;
  return d = Fx(t, n), i != null && (d.sign !== l.sign || d.span < i) && (t[1 - n] = t[n] + l.sign * i), d = Fx(t, n), o != null && d.span > o && (t[1 - n] = t[n] + d.sign * o), t;
}
function Fx(e, t) {
  var r = e[t] - e[1 - t];
  return {
    span: Math.abs(r),
    sign: r > 0 ? -1 : r < 0 ? 1 : t ? -1 : 1
  };
}
function Kd(e, t) {
  return Math.min(t[1] != null ? t[1] : 1 / 0, Math.max(t[0] != null ? t[0] : -1 / 0, e));
}
var Nx = $, WU = Math.min, jU = Math.max, e4 = Math.floor, ZDe = Math.ceil, t4 = an, QDe = Math.PI, JDe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "parallel", this._axesMap = nt(), this._axesLayout = {}, this.dimensions = t.dimensions, this._model = t, this._init(t, r, n);
    }
    return e.prototype._init = function(t, r, n) {
      var i = t.dimensions, o = t.parallelAxisIndex;
      Nx(i, function(a, s) {
        var l = o[s], u = r.getComponent("parallelAxis", l), c = this._axesMap.set(a, new XDe(a, Wv(u), [0, 0], u.get("type"), l)), d = c.type === "category";
        c.onBand = d && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, e.prototype.update = function(t, r) {
      this._updateAxesFromSeries(this._model, t);
    }, e.prototype.containPoint = function(t) {
      var r = this._makeLayoutInfo(), n = r.axisBase, i = r.layoutBase, o = r.pixelDimIndex, a = t[1 - o], s = t[o];
      return a >= n && a <= n + r.axisLength && s >= i && s <= i + r.layoutLength;
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype._updateAxesFromSeries = function(t, r) {
      r.eachSeries(function(n) {
        if (t.contains(n, r)) {
          var i = n.getData();
          Nx(this.dimensions, function(o) {
            var a = this._axesMap.get(o);
            a.scale.unionExtentFromData(i, i.mapDimension(o)), Kc(a.scale, a.model);
          }, this);
        }
      }, this);
    }, e.prototype.resize = function(t, r) {
      this._rect = En(t.getBoxLayoutParams(), {
        width: r.getWidth(),
        height: r.getHeight()
      }), this._layoutAxes();
    }, e.prototype.getRect = function() {
      return this._rect;
    }, e.prototype._makeLayoutInfo = function() {
      var t = this._model, r = this._rect, n = ["x", "y"], i = ["width", "height"], o = t.get("layout"), a = o === "horizontal" ? 0 : 1, s = r[i[a]], l = [0, s], u = this.dimensions.length, c = by(t.get("axisExpandWidth"), l), d = by(t.get("axisExpandCount") || 0, [0, u]), h = t.get("axisExpandable") && u > 3 && u > d && d > 1 && c > 0 && s > 0, f = t.get("axisExpandWindow"), p;
      if (f)
        p = by(f[1] - f[0], l), f[1] = f[0] + p;
      else {
        p = by(c * (d - 1), l);
        var g = t.get("axisExpandCenter") || e4(u / 2);
        f = [c * g - p / 2], f[1] = f[0] + p;
      }
      var v = (s - p) / (u - d);
      v < 3 && (v = 0);
      var m = [e4(t4(f[0] / c, 1)) + 1, ZDe(t4(f[1] / c, 1)) - 1], y = v / c * f[0];
      return {
        layout: o,
        pixelDimIndex: a,
        layoutBase: r[n[a]],
        layoutLength: s,
        axisBase: r[n[1 - a]],
        axisLength: r[i[1 - a]],
        axisExpandable: h,
        axisExpandWidth: c,
        axisCollapseWidth: v,
        axisExpandWindow: f,
        axisCount: u,
        winInnerIndices: m,
        axisExpandWindow0Pos: y
      };
    }, e.prototype._layoutAxes = function() {
      var t = this._rect, r = this._axesMap, n = this.dimensions, i = this._makeLayoutInfo(), o = i.layout;
      r.each(function(a) {
        var s = [0, i.axisLength], l = a.inverse ? 1 : 0;
        a.setExtent(s[l], s[1 - l]);
      }), Nx(n, function(a, s) {
        var l = (i.axisExpandable ? tAe : eAe)(s, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: QDe / 2,
          vertical: 0
        }, d = [u[o].x + t.x, u[o].y + t.y], h = c[o], f = Zi();
        Cu(f, f, h), Oa(f, f, d), this._axesLayout[a] = {
          position: d,
          rotation: h,
          transform: f,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, e.prototype.getAxis = function(t) {
      return this._axesMap.get(t);
    }, e.prototype.dataToPoint = function(t, r) {
      return this.axisCoordToPoint(this._axesMap.get(r).dataToCoord(t), r);
    }, e.prototype.eachActiveState = function(t, r, n, i) {
      n == null && (n = 0), i == null && (i = t.count());
      var o = this._axesMap, a = this.dimensions, s = [], l = [];
      $(a, function(v) {
        s.push(t.mapDimension(v)), l.push(o.get(v).model);
      });
      for (var u = this.hasAxisBrushed(), c = n; c < i; c++) {
        var d = void 0;
        if (!u)
          d = "normal";
        else {
          d = "active";
          for (var h = t.getValues(s, c), f = 0, p = a.length; f < p; f++) {
            var g = l[f].getActiveState(h[f]);
            if (g === "inactive") {
              d = "inactive";
              break;
            }
          }
        }
        r(d, c);
      }
    }, e.prototype.hasAxisBrushed = function() {
      for (var t = this.dimensions, r = this._axesMap, n = !1, i = 0, o = t.length; i < o; i++)
        r.get(t[i]).model.getActiveState() !== "normal" && (n = !0);
      return n;
    }, e.prototype.axisCoordToPoint = function(t, r) {
      var n = this._axesLayout[r];
      return Ma([t, 0], n.transform);
    }, e.prototype.getAxisLayout = function(t) {
      return dt(this._axesLayout[t]);
    }, e.prototype.getSlidedAxisExpandWindow = function(t) {
      var r = this._makeLayoutInfo(), n = r.pixelDimIndex, i = r.axisExpandWindow.slice(), o = i[1] - i[0], a = [0, r.axisExpandWidth * (r.axisCount - 1)];
      if (!this.containPoint(t))
        return {
          behavior: "none",
          axisExpandWindow: i
        };
      var s = t[n] - r.layoutBase - r.axisExpandWindow0Pos, l, u = "slide", c = r.axisCollapseWidth, d = this._model.get("axisExpandSlideTriggerArea"), h = d[0] != null;
      if (c)
        h && c && s < o * d[0] ? (u = "jump", l = s - o * d[2]) : h && c && s > o * (1 - d[0]) ? (u = "jump", l = s - o * (1 - d[2])) : (l = s - o * d[1]) >= 0 && (l = s - o * (1 - d[1])) <= 0 && (l = 0), l *= r.axisExpandWidth / c, l ? hd(l, i, a, "all") : u = "none";
      else {
        var f = i[1] - i[0], p = a[1] * s / f;
        i = [jU(0, p - f / 2)], i[1] = WU(a[1], i[0] + f), i[0] = i[1] - f;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, e;
  }()
);
function by(e, t) {
  return WU(jU(e, t[0]), t[1]);
}
function eAe(e, t) {
  var r = t.layoutLength / (t.axisCount - 1);
  return {
    position: r * e,
    axisNameAvailableWidth: r,
    axisLabelShow: !0
  };
}
function tAe(e, t) {
  var r = t.layoutLength, n = t.axisExpandWidth, i = t.axisCount, o = t.axisCollapseWidth, a = t.winInnerIndices, s, l = o, u = !1, c;
  return e < a[0] ? (s = e * o, c = o) : e <= a[1] ? (s = t.axisExpandWindow0Pos + e * n - t.axisExpandWindow[0], l = n, u = !0) : (s = r - (i - 1 - e) * o, c = o), {
    position: s,
    axisNameAvailableWidth: l,
    axisLabelShow: u,
    nameTruncateMaxWidth: c
  };
}
function rAe(e, t) {
  var r = [];
  return e.eachComponent("parallel", function(n, i) {
    var o = new JDe(n, e, t);
    o.name = "parallel_" + i, o.resize(n, t), n.coordinateSystem = o, o.model = n, r.push(o);
  }), e.eachSeries(function(n) {
    if (n.get("coordinateSystem") === "parallel") {
      var i = n.getReferringComponents("parallel", bn).models[0];
      n.coordinateSystem = i.coordinateSystem;
    }
  }), r;
}
var nAe = {
  create: rAe
}, _T = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.activeIntervals = [], r;
    }
    return t.prototype.getAreaSelectStyle = function() {
      return Wc([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, t.prototype.setActiveIntervals = function(r) {
      var n = this.activeIntervals = dt(r);
      if (n)
        for (var i = n.length - 1; i >= 0; i--)
          vo(n[i]);
    }, t.prototype.getActiveState = function(r) {
      var n = this.activeIntervals;
      if (!n.length)
        return "normal";
      if (r == null || isNaN(+r))
        return "inactive";
      if (n.length === 1) {
        var i = n[0];
        if (i[0] <= r && r <= i[1])
          return "active";
      } else
        for (var o = 0, a = n.length; o < a; o++)
          if (n[o][0] <= r && r <= n[o][1])
            return "active";
      return "inactive";
    }, t;
  }(Vt)
);
cn(_T, Mf);
var Yc = !0, lv = Math.min, Zh = Math.max, iAe = Math.pow, oAe = 1e4, aAe = 6, sAe = 6, r4 = "globalPan", lAe = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, uAe = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, n4 = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, cAe = 0, yA = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this) || this;
      return n._track = [], n._covers = [], n._handlers = {}, process.env.NODE_ENV !== "production" && ct(r), n._zr = r, n.group = new Ct(), n._uid = "brushController_" + cAe++, $(mAe, function(i, o) {
        this._handlers[o] = je(i, this);
      }, n), n;
    }
    return t.prototype.enableBrush = function(r) {
      return process.env.NODE_ENV !== "production" && ct(this._mounted), this._brushType && this._doDisableBrush(), r.brushType && this._doEnableBrush(r), this;
    }, t.prototype._doEnableBrush = function(r) {
      var n = this._zr;
      this._enableGlobalPan || ePe(n, r4, this._uid), $(this._handlers, function(i, o) {
        n.on(o, i);
      }), this._brushType = r.brushType, this._brushOption = Mt(dt(n4), r, !0);
    }, t.prototype._doDisableBrush = function() {
      var r = this._zr;
      tPe(r, r4, this._uid), $(this._handlers, function(n, i) {
        r.off(i, n);
      }), this._brushType = this._brushOption = null;
    }, t.prototype.setPanels = function(r) {
      if (r && r.length) {
        var n = this._panels = {};
        $(r, function(i) {
          n[i.panelId] = dt(i);
        });
      } else
        this._panels = null;
      return this;
    }, t.prototype.mount = function(r) {
      r = r || {}, process.env.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = r.enableGlobalPan;
      var n = this.group;
      return this._zr.add(n), n.attr({
        x: r.x || 0,
        y: r.y || 0,
        rotation: r.rotation || 0,
        scaleX: r.scaleX || 1,
        scaleY: r.scaleY || 1
      }), this._transform = n.getLocalTransform(), this;
    }, t.prototype.updateCovers = function(r) {
      process.env.NODE_ENV !== "production" && ct(this._mounted), r = Ee(r, function(h) {
        return Mt(dt(n4), h, !0);
      });
      var n = "\0-brush-index-", i = this._covers, o = this._covers = [], a = this, s = this._creatingCover;
      return new el(i, r, u, l).add(c).update(c).remove(d).execute(), this;
      function l(h, f) {
        return (h.id != null ? h.id : n + f) + "-" + h.brushType;
      }
      function u(h, f) {
        return l(h.__brushOption, f);
      }
      function c(h, f) {
        var p = r[h];
        if (f != null && i[f] === s)
          o[h] = i[f];
        else {
          var g = o[h] = f != null ? (i[f].__brushOption = p, i[f]) : KU(a, UU(a, p));
          CA(a, g);
        }
      }
      function d(h) {
        i[h] !== s && a.group.remove(i[h]);
      }
    }, t.prototype.unmount = function() {
      if (!(process.env.NODE_ENV !== "production" && !this._mounted))
        return this.enableBrush(!1), TT(this), this._zr.remove(this.group), process.env.NODE_ENV !== "production" && (this._mounted = !1), this;
    }, t.prototype.dispose = function() {
      this.unmount(), this.off();
    }, t;
  }(na)
);
function UU(e, t) {
  var r = Aw[t.brushType].createCover(e, t);
  return r.__brushOption = t, qU(r, t), e.group.add(r), r;
}
function KU(e, t) {
  var r = SA(t);
  return r.endCreating && (r.endCreating(e, t), qU(t, t.__brushOption)), t;
}
function YU(e, t) {
  var r = t.__brushOption;
  SA(t).updateCoverShape(e, t, r.range, r);
}
function qU(e, t) {
  var r = t.z;
  r == null && (r = oAe), e.traverse(function(n) {
    n.z = r, n.z2 = r;
  });
}
function CA(e, t) {
  SA(t).updateCommon(e, t), YU(e, t);
}
function SA(e) {
  return Aw[e.__brushOption.brushType];
}
function wA(e, t, r) {
  var n = e._panels;
  if (!n)
    return Yc;
  var i, o = e._transform;
  return $(n, function(a) {
    a.isTargetByCursor(t, r, o) && (i = a);
  }), i;
}
function XU(e, t) {
  var r = e._panels;
  if (!r)
    return Yc;
  var n = t.__brushOption.panelId;
  return n != null ? r[n] : Yc;
}
function TT(e) {
  var t = e._covers, r = t.length;
  return $(t, function(n) {
    e.group.remove(n);
  }, e), t.length = 0, !!r;
}
function qc(e, t) {
  var r = Ee(e._covers, function(n) {
    var i = n.__brushOption, o = dt(i.range);
    return {
      brushType: i.brushType,
      panelId: i.panelId,
      range: o
    };
  });
  e.trigger("brush", {
    areas: r,
    isEnd: !!t.isEnd,
    removeOnClick: !!t.removeOnClick
  });
}
function dAe(e) {
  var t = e._track;
  if (!t.length)
    return !1;
  var r = t[t.length - 1], n = t[0], i = r[0] - n[0], o = r[1] - n[1], a = iAe(i * i + o * o, 0.5);
  return a > aAe;
}
function ZU(e) {
  var t = e.length - 1;
  return t < 0 && (t = 0), [e[0], e[t]];
}
function QU(e, t, r, n) {
  var i = new Ct();
  return i.add(new or({
    name: "main",
    style: bA(r),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: _t(i4, e, t, i, ["n", "s", "w", "e"]),
    ondragend: _t(qc, t, {
      isEnd: !0
    })
  })), $(n, function(o) {
    i.add(new or({
      name: o.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: _t(i4, e, t, i, o),
      ondragend: _t(qc, t, {
        isEnd: !0
      })
    }));
  }), i;
}
function JU(e, t, r, n) {
  var i = n.brushStyle.lineWidth || 0, o = Zh(i, sAe), a = r[0][0], s = r[1][0], l = a - i / 2, u = s - i / 2, c = r[0][1], d = r[1][1], h = c - o + i / 2, f = d - o + i / 2, p = c - a, g = d - s, v = p + i, m = g + i;
  Ps(e, t, "main", a, s, p, g), n.transformable && (Ps(e, t, "w", l, u, o, m), Ps(e, t, "e", h, u, o, m), Ps(e, t, "n", l, u, v, o), Ps(e, t, "s", l, f, v, o), Ps(e, t, "nw", l, u, o, o), Ps(e, t, "ne", h, u, o, o), Ps(e, t, "sw", l, f, o, o), Ps(e, t, "se", h, f, o, o));
}
function PT(e, t) {
  var r = t.__brushOption, n = r.transformable, i = t.childAt(0);
  i.useStyle(bA(r)), i.attr({
    silent: !n,
    cursor: n ? "move" : "default"
  }), $([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(o) {
    var a = t.childOfName(o.join("")), s = o.length === 1 ? MT(e, o[0]) : fAe(e, o);
    a && a.attr({
      silent: !n,
      invisible: !n,
      cursor: n ? uAe[s] + "-resize" : null
    });
  });
}
function Ps(e, t, r, n, i, o, a) {
  var s = t.childOfName(r);
  s && s.setShape(gAe(xA(e, t, [[n, i], [n + o, i + a]])));
}
function bA(e) {
  return ut({
    strokeNoScale: !0
  }, e.brushStyle);
}
function eK(e, t, r, n) {
  var i = [lv(e, r), lv(t, n)], o = [Zh(e, r), Zh(t, n)];
  return [
    [i[0], o[0]],
    [i[1], o[1]]
    // y range
  ];
}
function hAe(e) {
  return Wl(e.group);
}
function MT(e, t) {
  var r = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, n = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, i = uw(r[t], hAe(e));
  return n[i];
}
function fAe(e, t) {
  var r = [MT(e, t[0]), MT(e, t[1])];
  return (r[0] === "e" || r[0] === "w") && r.reverse(), r.join("");
}
function i4(e, t, r, n, i, o) {
  var a = r.__brushOption, s = e.toRectRange(a.range), l = tK(t, i, o);
  $(n, function(u) {
    var c = lAe[u];
    s[c[0]][c[1]] += l[c[0]];
  }), a.range = e.fromRectRange(eK(s[0][0], s[1][0], s[0][1], s[1][1])), CA(t, r), qc(t, {
    isEnd: !1
  });
}
function pAe(e, t, r, n) {
  var i = t.__brushOption.range, o = tK(e, r, n);
  $(i, function(a) {
    a[0] += o[0], a[1] += o[1];
  }), CA(e, t), qc(e, {
    isEnd: !1
  });
}
function tK(e, t, r) {
  var n = e.group, i = n.transformCoordToLocal(t, r), o = n.transformCoordToLocal(0, 0);
  return [i[0] - o[0], i[1] - o[1]];
}
function xA(e, t, r) {
  var n = XU(e, t);
  return n && n !== Yc ? n.clipPath(r, e._transform) : dt(r);
}
function gAe(e) {
  var t = lv(e[0][0], e[1][0]), r = lv(e[0][1], e[1][1]), n = Zh(e[0][0], e[1][0]), i = Zh(e[0][1], e[1][1]);
  return {
    x: t,
    y: r,
    width: n - t,
    height: i - r
  };
}
function vAe(e, t, r) {
  if (
    // Check active
    !(!e._brushType || yAe(e, t.offsetX, t.offsetY))
  ) {
    var n = e._zr, i = e._covers, o = wA(e, t, r);
    if (!e._dragging)
      for (var a = 0; a < i.length; a++) {
        var s = i[a].__brushOption;
        if (o && (o === Yc || s.panelId === o.panelId) && Aw[s.brushType].contain(i[a], r[0], r[1]))
          return;
      }
    o && n.setCursorStyle("crosshair");
  }
}
function DT(e) {
  var t = e.event;
  t.preventDefault && t.preventDefault();
}
function AT(e, t, r) {
  return e.childOfName("main").contain(t, r);
}
function rK(e, t, r, n) {
  var i = e._creatingCover, o = e._creatingPanel, a = e._brushOption, s;
  if (e._track.push(r.slice()), dAe(e) || i) {
    if (o && !i) {
      a.brushMode === "single" && TT(e);
      var l = dt(a);
      l.brushType = o4(l.brushType, o), l.panelId = o === Yc ? null : o.panelId, i = e._creatingCover = UU(e, l), e._covers.push(i);
    }
    if (i) {
      var u = Aw[o4(e._brushType, o)], c = i.__brushOption;
      c.range = u.getCreatingRange(xA(e, i, e._track)), n && (KU(e, i), u.updateCommon(e, i)), YU(e, i), s = {
        isEnd: n
      };
    }
  } else n && a.brushMode === "single" && a.removeOnClick && wA(e, t, r) && TT(e) && (s = {
    isEnd: n,
    removeOnClick: !0
  });
  return s;
}
function o4(e, t) {
  return e === "auto" ? (process.env.NODE_ENV !== "production" && ct(t && t.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), t.defaultBrushType) : e;
}
var mAe = {
  mousedown: function(e) {
    if (this._dragging)
      a4(this, e);
    else if (!e.target || !e.target.draggable) {
      DT(e);
      var t = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
      this._creatingCover = null;
      var r = this._creatingPanel = wA(this, e, t);
      r && (this._dragging = !0, this._track = [t.slice()]);
    }
  },
  mousemove: function(e) {
    var t = e.offsetX, r = e.offsetY, n = this.group.transformCoordToLocal(t, r);
    if (vAe(this, e, n), this._dragging) {
      DT(e);
      var i = rK(this, e, n, !1);
      i && qc(this, i);
    }
  },
  mouseup: function(e) {
    a4(this, e);
  }
};
function a4(e, t) {
  if (e._dragging) {
    DT(t);
    var r = t.offsetX, n = t.offsetY, i = e.group.transformCoordToLocal(r, n), o = rK(e, t, i, !0);
    e._dragging = !1, e._track = [], e._creatingCover = null, o && qc(e, o);
  }
}
function yAe(e, t, r) {
  var n = e._zr;
  return t < 0 || t > n.getWidth() || r < 0 || r > n.getHeight();
}
var Aw = {
  lineX: s4(0),
  lineY: s4(1),
  rect: {
    createCover: function(e, t) {
      function r(n) {
        return n;
      }
      return QU({
        toRectRange: r,
        fromRectRange: r
      }, e, t, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(e) {
      var t = ZU(e);
      return eK(t[1][0], t[1][1], t[0][0], t[0][1]);
    },
    updateCoverShape: function(e, t, r, n) {
      JU(e, t, r, n);
    },
    updateCommon: PT,
    contain: AT
  },
  polygon: {
    createCover: function(e, t) {
      var r = new Ct();
      return r.add(new Ni({
        name: "main",
        style: bA(t),
        silent: !0
      })), r;
    },
    getCreatingRange: function(e) {
      return e;
    },
    endCreating: function(e, t) {
      t.remove(t.childAt(0)), t.add(new Li({
        name: "main",
        draggable: !0,
        drift: _t(pAe, e, t),
        ondragend: _t(qc, e, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(e, t, r, n) {
      t.childAt(0).setShape({
        points: xA(e, t, r)
      });
    },
    updateCommon: PT,
    contain: AT
  }
};
function s4(e) {
  return {
    createCover: function(t, r) {
      return QU({
        toRectRange: function(n) {
          var i = [n, [0, 100]];
          return e && i.reverse(), i;
        },
        fromRectRange: function(n) {
          return n[e];
        }
      }, t, r, [[["w"], ["e"]], [["n"], ["s"]]][e]);
    },
    getCreatingRange: function(t) {
      var r = ZU(t), n = lv(r[0][e], r[1][e]), i = Zh(r[0][e], r[1][e]);
      return [n, i];
    },
    updateCoverShape: function(t, r, n, i) {
      var o, a = XU(t, r);
      if (a !== Yc && a.getLinearBrushOtherExtent)
        o = a.getLinearBrushOtherExtent(e);
      else {
        var s = t._zr;
        o = [0, [s.getWidth(), s.getHeight()][1 - e]];
      }
      var l = [n, o];
      e && l.reverse(), JU(t, r, l, i);
    },
    updateCommon: PT,
    contain: AT
  };
}
function nK(e) {
  return e = EA(e), function(t) {
    return uD(t, e);
  };
}
function iK(e, t) {
  return e = EA(e), function(r) {
    var n = t ?? r, i = n ? e.width : e.height, o = n ? e.x : e.y;
    return [o, o + (i || 0)];
  };
}
function oK(e, t, r) {
  var n = EA(e);
  return function(i, o) {
    return n.contain(o[0], o[1]) && !Tw(i, t, r);
  };
}
function EA(e) {
  return At.create(e);
}
var CAe = ["axisLine", "axisTickLabel", "axisName"], SAe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      e.prototype.init.apply(this, arguments), (this._brushController = new yA(n.getZr())).on("brush", je(this._onBrush, this));
    }, t.prototype.render = function(r, n, i, o) {
      if (!wAe(r, n, o)) {
        this.axisModel = r, this.api = i, this.group.removeAll();
        var a = this._axisGroup;
        if (this._axisGroup = new Ct(), this.group.add(this._axisGroup), !!r.get("show")) {
          var s = xAe(r, n), l = s.coordinateSystem, u = r.getAreaSelectStyle(), c = u.width, d = r.axis.dim, h = l.getAxisLayout(d), f = ge({
            strokeContainThreshold: c
          }, h), p = new Mi(r, f);
          $(CAe, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(f, u, r, s, c, i), Hv(a, this._axisGroup, r);
        }
      }
    }, t.prototype._refreshBrushController = function(r, n, i, o, a, s) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), d = At.create({
        x: l[0],
        y: -a / 2,
        width: u,
        height: a
      });
      d.x -= c, d.width += 2 * c, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: r.rotation,
        x: r.position[0],
        y: r.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: nK(d),
        isTargetByCursor: oK(d, s, o),
        getLinearBrushOtherExtent: iK(d, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: n,
        removeOnClick: !0
      }).updateCovers(bAe(i));
    }, t.prototype._onBrush = function(r) {
      var n = r.areas, i = this.axisModel, o = i.axis, a = Ee(n, function(s) {
        return [o.coordToData(s.range[0], !0), o.coordToData(s.range[1], !0)];
      });
      (!i.option.realtime === r.isEnd || r.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: a
      });
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.type = "parallelAxis", t;
  }(zr)
);
function wAe(e, t, r) {
  return r && r.type === "axisAreaSelect" && t.findComponents({
    mainType: "parallelAxis",
    query: r
  })[0] === e;
}
function bAe(e) {
  var t = e.axis;
  return Ee(e.activeIntervals, function(r) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [t.dataToCoord(r[0], !0), t.dataToCoord(r[1], !0)]
    };
  });
}
function xAe(e, t) {
  return t.getComponent("parallel", e.get("parallelIndex"));
}
var EAe = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function RAe(e) {
  e.registerAction(EAe, function(t, r) {
    r.eachComponent({
      mainType: "parallelAxis",
      query: t
    }, function(n) {
      n.axis.model.setActiveIntervals(t.intervals);
    });
  }), e.registerAction("parallelAxisExpand", function(t, r) {
    r.eachComponent({
      mainType: "parallel",
      query: t
    }, function(n) {
      n.setAxisExpand(t);
    });
  });
}
var _Ae = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function aK(e) {
  e.registerComponentView(KDe), e.registerComponentModel(qDe), e.registerCoordinateSystem("parallel", nAe), e.registerPreprocessor(zDe), e.registerComponentModel(_T), e.registerComponentView(SAe), Xh(e, "parallel", _T, _Ae), RAe(e);
}
function TAe(e) {
  Bt(aK), e.registerChartView(FDe), e.registerSeriesModel(VDe), e.registerVisual(e.PRIORITY.VISUAL.BRUSH, GDe);
}
var PAe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return e;
  }()
), MAe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      return e.call(this, r) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new PAe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.extent;
      r.moveTo(n.x1, n.y1), r.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (r.lineTo(n.x2 + i, n.y2), r.bezierCurveTo(n.cpx2 + i, n.cpy2, n.cpx1 + i, n.cpy1, n.x1 + i, n.y1)) : (r.lineTo(n.x2, n.y2 + i), r.bezierCurveTo(n.cpx2, n.cpy2 + i, n.cpx1, n.cpy1 + i, n.x1, n.y1 + i)), r.closePath();
    }, t.prototype.highlight = function() {
      Qs(this);
    }, t.prototype.downplay = function() {
      Js(this);
    }, t;
  }(Ht)
), DAe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._focusAdjacencyDisabled = !1, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = this, a = r.getGraph(), s = this.group, l = r.layoutInfo, u = l.width, c = l.height, d = r.getData(), h = r.getData("edge"), f = r.get("orient");
      this._model = r, s.removeAll(), s.x = l.x, s.y = l.y, a.eachEdge(function(p) {
        var g = new MAe(), v = St(g);
        v.dataIndex = p.dataIndex, v.seriesIndex = r.seriesIndex, v.dataType = "edge";
        var m = p.getModel(), y = m.getModel("lineStyle"), C = y.get("curveness"), S = p.node1.getLayout(), b = p.node1.getModel(), w = b.get("localX"), x = b.get("localY"), R = p.node2.getLayout(), _ = p.node2.getModel(), T = _.get("localX"), P = _.get("localY"), D = p.getLayout(), O, A, F, L, N, I, B, M;
        g.shape.extent = Math.max(1, D.dy), g.shape.orient = f, f === "vertical" ? (O = (w != null ? w * u : S.x) + D.sy, A = (x != null ? x * c : S.y) + S.dy, F = (T != null ? T * u : R.x) + D.ty, L = P != null ? P * c : R.y, N = O, I = A * (1 - C) + L * C, B = F, M = A * C + L * (1 - C)) : (O = (w != null ? w * u : S.x) + S.dx, A = (x != null ? x * c : S.y) + D.sy, F = T != null ? T * u : R.x, L = (P != null ? P * c : R.y) + D.ty, N = O * (1 - C) + F * C, I = A, B = O * C + F * (1 - C), M = L), g.setShape({
          x1: O,
          y1: A,
          x2: F,
          y2: L,
          cpx1: N,
          cpy1: I,
          cpx2: B,
          cpy2: M
        }), g.useStyle(y.getItemStyle()), l4(g.style, f, p);
        var V = "" + m.get("value"), G = $n(m, "edgeLabel");
        ri(g, G, {
          labelFetcher: {
            getFormattedLabel: function(j, q, K, Z, re, X) {
              return r.getFormattedLabel(
                j,
                q,
                "edge",
                Z,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                So(re, G.normal && G.normal.get("formatter"), V),
                X
              );
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: V
        }), g.setTextConfig({
          position: "inside"
        });
        var k = m.getModel("emphasis");
        ti(g, m, "lineStyle", function(j) {
          var q = j.getItemStyle();
          return l4(q, f, p), q;
        }), s.add(g), h.setItemGraphicEl(p.dataIndex, g);
        var z = k.get("focus");
        sn(g, z === "adjacency" ? p.getAdjacentDataIndices() : z === "trajectory" ? p.getTrajectoryDataIndices() : z, k.get("blurScope"), k.get("disabled"));
      }), a.eachNode(function(p) {
        var g = p.getLayout(), v = p.getModel(), m = v.get("localX"), y = v.get("localY"), C = v.getModel("emphasis"), S = v.get(["itemStyle", "borderRadius"]) || 0, b = new or({
          shape: {
            x: m != null ? m * u : g.x,
            y: y != null ? y * c : g.y,
            width: g.dx,
            height: g.dy,
            r: S
          },
          style: v.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        ri(b, $n(v), {
          labelFetcher: {
            getFormattedLabel: function(x, R) {
              return r.getFormattedLabel(x, R, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), b.disableLabelAnimation = !0, b.setStyle("fill", p.getVisual("color")), b.setStyle("decal", p.getVisual("style").decal), ti(b, v), s.add(b), d.setItemGraphicEl(p.dataIndex, b), St(b).dataType = "node";
        var w = C.get("focus");
        sn(b, w === "adjacency" ? p.getAdjacentDataIndices() : w === "trajectory" ? p.getTrajectoryDataIndices() : w, C.get("blurScope"), C.get("disabled"));
      }), d.eachItemGraphicEl(function(p, g) {
        var v = d.getItemModel(g);
        v.get("draggable") && (p.drift = function(m, y) {
          o._focusAdjacencyDisabled = !0, this.shape.x += m, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: r.id,
            dataIndex: d.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          o._focusAdjacencyDisabled = !1;
        }, p.draggable = !0, p.cursor = "move");
      }), !this._data && r.isAnimationEnabled() && s.setClipPath(AAe(s.getBoundingRect(), r, function() {
        s.removeClipPath();
      })), this._data = r.getData();
    }, t.prototype.dispose = function() {
    }, t.type = "sankey", t;
  }(br)
);
function l4(e, t, r) {
  switch (e.fill) {
    case "source":
      e.fill = r.node1.getVisual("color"), e.decal = r.node1.getVisual("style").decal;
      break;
    case "target":
      e.fill = r.node2.getVisual("color"), e.decal = r.node2.getVisual("style").decal;
      break;
    case "gradient":
      var n = r.node1.getVisual("color"), i = r.node2.getVisual("color");
      He(n) && He(i) && (e.fill = new vf(0, 0, +(t === "horizontal"), +(t === "vertical"), [{
        color: n,
        offset: 0
      }, {
        color: i,
        offset: 1
      }]));
  }
}
function AAe(e, t, r) {
  var n = new or({
    shape: {
      x: e.x - 10,
      y: e.y - 10,
      width: 0,
      height: e.height + 20
    }
  });
  return jr(n, {
    shape: {
      width: e.width + 20
    }
  }, t, r), n;
}
var IAe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      var i = r.edges || r.links, o = r.data || r.nodes, a = r.levels;
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < a.length; l++)
        if (a[l].depth != null && a[l].depth >= 0)
          s[a[l].depth] = new _r(a[l], this, n);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      if (o && i) {
        var u = GU(o, i, this, !0, c);
        return u.data;
      }
      function c(d, h) {
        d.wrapMethod("getItemModel", function(f, p) {
          var g = f.parentModel, v = g.getData().getItemLayout(p);
          if (v) {
            var m = v.depth, y = g.levelModels[m];
            y && (f.parentModel = y);
          }
          return f;
        }), h.wrapMethod("getItemModel", function(f, p) {
          var g = f.parentModel, v = g.getGraph().getEdgeByIndex(p), m = v.node1.getLayout();
          if (m) {
            var y = m.depth, C = g.levelModels[y];
            C && (f.parentModel = C);
          }
          return f;
        });
      }
    }, t.prototype.setNodePosition = function(r, n) {
      var i = this.option.data || this.option.nodes, o = i[r];
      o.localX = n[0], o.localY = n[1];
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(r, n, i) {
      function o(f) {
        return isNaN(f) || f == null;
      }
      if (i === "edge") {
        var a = this.getDataParams(r, i), s = a.data, l = a.value, u = s.source + " -- " + s.target;
        return Hn("nameValue", {
          name: u,
          value: l,
          noValue: o(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(r), d = c.getLayout().value, h = this.getDataParams(r, i).data.name;
        return Hn("nameValue", {
          name: h != null ? h + "" : null,
          value: d,
          noValue: o(d)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(r, n) {
      var i = e.prototype.getDataParams.call(this, r, n);
      if (i.value == null && n === "node") {
        var o = this.getGraph().getNodeByIndex(r), a = o.getLayout().value;
        i.value = a;
      }
      return i;
    }, t.type = "series.sankey", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  }(Pr)
);
function OAe(e, t) {
  e.eachSeriesByType("sankey", function(r) {
    var n = r.get("nodeWidth"), i = r.get("nodeGap"), o = LAe(r, t);
    r.layoutInfo = o;
    var a = o.width, s = o.height, l = r.getGraph(), u = l.nodes, c = l.edges;
    NAe(u);
    var d = Sr(u, function(g) {
      return g.getLayout().value === 0;
    }), h = d.length !== 0 ? 0 : r.get("layoutIterations"), f = r.get("orient"), p = r.get("nodeAlign");
    FAe(u, c, n, i, a, s, h, f, p);
  });
}
function LAe(e, t) {
  return En(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function FAe(e, t, r, n, i, o, a, s, l) {
  kAe(e, t, r, i, o, s, l), HAe(e, t, o, i, n, a, s), XAe(e, s);
}
function NAe(e) {
  $(e, function(t) {
    var r = Ul(t.outEdges, kC), n = Ul(t.inEdges, kC), i = t.getValue() || 0, o = Math.max(r, n, i);
    t.setLayout({
      value: o
    }, !0);
  });
}
function kAe(e, t, r, n, i, o, a) {
  for (var s = [], l = [], u = [], c = [], d = 0, h = 0; h < t.length; h++)
    s[h] = 1;
  for (var h = 0; h < e.length; h++)
    l[h] = e[h].inEdges.length, l[h] === 0 && u.push(e[h]);
  for (var f = -1; u.length; ) {
    for (var p = 0; p < u.length; p++) {
      var g = u[p], v = g.hostGraph.data.getRawDataItem(g.dataIndex), m = v.depth != null && v.depth >= 0;
      m && v.depth > f && (f = v.depth), g.setLayout({
        depth: m ? v.depth : d
      }, !0), o === "vertical" ? g.setLayout({
        dy: r
      }, !0) : g.setLayout({
        dx: r
      }, !0);
      for (var y = 0; y < g.outEdges.length; y++) {
        var C = g.outEdges[y], S = t.indexOf(C);
        s[S] = 0;
        var b = C.node2, w = e.indexOf(b);
        --l[w] === 0 && c.indexOf(b) < 0 && c.push(b);
      }
    }
    ++d, u = c, c = [];
  }
  for (var h = 0; h < s.length; h++)
    if (s[h] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var x = f > d - 1 ? f : d - 1;
  a && a !== "left" && VAe(e, a, o, x);
  var R = o === "vertical" ? (i - r) / x : (n - r) / x;
  $Ae(e, R, o);
}
function sK(e) {
  var t = e.hostGraph.data.getRawDataItem(e.dataIndex);
  return t.depth != null && t.depth >= 0;
}
function VAe(e, t, r, n) {
  if (t === "right") {
    for (var i = [], o = e, a = 0; o.length; ) {
      for (var s = 0; s < o.length; s++) {
        var l = o[s];
        l.setLayout({
          skNodeHeight: a
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          i.indexOf(c.node1) < 0 && i.push(c.node1);
        }
      }
      o = i, i = [], ++a;
    }
    $(e, function(d) {
      sK(d) || d.setLayout({
        depth: Math.max(0, n - d.getLayout().skNodeHeight)
      }, !0);
    });
  } else t === "justify" && BAe(e, n);
}
function BAe(e, t) {
  $(e, function(r) {
    !sK(r) && !r.outEdges.length && r.setLayout({
      depth: t
    }, !0);
  });
}
function $Ae(e, t, r) {
  $(e, function(n) {
    var i = n.getLayout().depth * t;
    r === "vertical" ? n.setLayout({
      y: i
    }, !0) : n.setLayout({
      x: i
    }, !0);
  });
}
function HAe(e, t, r, n, i, o, a) {
  var s = GAe(e, a);
  zAe(s, t, r, n, i, a), kx(s, i, r, n, a);
  for (var l = 1; o > 0; o--)
    l *= 0.99, WAe(s, l, a), kx(s, i, r, n, a), qAe(s, l, a), kx(s, i, r, n, a);
}
function GAe(e, t) {
  var r = [], n = t === "vertical" ? "y" : "x", i = A_(e, function(o) {
    return o.getLayout()[n];
  });
  return i.keys.sort(function(o, a) {
    return o - a;
  }), $(i.keys, function(o) {
    r.push(i.buckets.get(o));
  }), r;
}
function zAe(e, t, r, n, i, o) {
  var a = 1 / 0;
  $(e, function(s) {
    var l = s.length, u = 0;
    $(s, function(d) {
      u += d.getLayout().value;
    });
    var c = o === "vertical" ? (n - (l - 1) * i) / u : (r - (l - 1) * i) / u;
    c < a && (a = c);
  }), $(e, function(s) {
    $(s, function(l, u) {
      var c = l.getLayout().value * a;
      o === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), $(t, function(s) {
    var l = +s.getValue() * a;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function kx(e, t, r, n, i) {
  var o = i === "vertical" ? "x" : "y";
  $(e, function(a) {
    a.sort(function(g, v) {
      return g.getLayout()[o] - v.getLayout()[o];
    });
    for (var s, l, u, c = 0, d = a.length, h = i === "vertical" ? "dx" : "dy", f = 0; f < d; f++)
      l = a[f], u = c - l.getLayout()[o], u > 0 && (s = l.getLayout()[o] + u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), c = l.getLayout()[o] + l.getLayout()[h] + t;
    var p = i === "vertical" ? n : r;
    if (u = c - t - p, u > 0) {
      s = l.getLayout()[o] - u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), c = s;
      for (var f = d - 2; f >= 0; --f)
        l = a[f], u = l.getLayout()[o] + l.getLayout()[h] + t - c, u > 0 && (s = l.getLayout()[o] - u, i === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), c = l.getLayout()[o];
    }
  });
}
function WAe(e, t, r) {
  $(e.slice().reverse(), function(n) {
    $(n, function(i) {
      if (i.outEdges.length) {
        var o = Ul(i.outEdges, jAe, r) / Ul(i.outEdges, kC);
        if (isNaN(o)) {
          var a = i.outEdges.length;
          o = a ? Ul(i.outEdges, UAe, r) / a : 0;
        }
        if (r === "vertical") {
          var s = i.getLayout().x + (o - lu(i, r)) * t;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (o - lu(i, r)) * t;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function jAe(e, t) {
  return lu(e.node2, t) * e.getValue();
}
function UAe(e, t) {
  return lu(e.node2, t);
}
function KAe(e, t) {
  return lu(e.node1, t) * e.getValue();
}
function YAe(e, t) {
  return lu(e.node1, t);
}
function lu(e, t) {
  return t === "vertical" ? e.getLayout().x + e.getLayout().dx / 2 : e.getLayout().y + e.getLayout().dy / 2;
}
function kC(e) {
  return e.getValue();
}
function Ul(e, t, r) {
  for (var n = 0, i = e.length, o = -1; ++o < i; ) {
    var a = +t(e[o], r);
    isNaN(a) || (n += a);
  }
  return n;
}
function qAe(e, t, r) {
  $(e, function(n) {
    $(n, function(i) {
      if (i.inEdges.length) {
        var o = Ul(i.inEdges, KAe, r) / Ul(i.inEdges, kC);
        if (isNaN(o)) {
          var a = i.inEdges.length;
          o = a ? Ul(i.inEdges, YAe, r) / a : 0;
        }
        if (r === "vertical") {
          var s = i.getLayout().x + (o - lu(i, r)) * t;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (o - lu(i, r)) * t;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function XAe(e, t) {
  var r = t === "vertical" ? "x" : "y";
  $(e, function(n) {
    n.outEdges.sort(function(i, o) {
      return i.node2.getLayout()[r] - o.node2.getLayout()[r];
    }), n.inEdges.sort(function(i, o) {
      return i.node1.getLayout()[r] - o.node1.getLayout()[r];
    });
  }), $(e, function(n) {
    var i = 0, o = 0;
    $(n.outEdges, function(a) {
      a.setLayout({
        sy: i
      }, !0), i += a.getLayout().dy;
    }), $(n.inEdges, function(a) {
      a.setLayout({
        ty: o
      }, !0), o += a.getLayout().dy;
    });
  });
}
function ZAe(e) {
  e.eachSeriesByType("sankey", function(t) {
    var r = t.getGraph(), n = r.nodes, i = r.edges;
    if (n.length) {
      var o = 1 / 0, a = -1 / 0;
      $(n, function(s) {
        var l = s.getLayout().value;
        l < o && (o = l), l > a && (a = l);
      }), $(n, function(s) {
        var l = new Vn({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [o, a],
          visual: t.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get(["itemStyle", "color"]);
        c != null ? (s.setVisual("color", c), s.setVisual("style", {
          fill: c
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    i.length && $(i, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function QAe(e) {
  e.registerChartView(DAe), e.registerSeriesModel(IAe), e.registerLayout(OAe), e.registerVisual(ZAe), e.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(t, r) {
    r.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(n) {
      n.setNodePosition(t.dataIndex, [t.localX, t.localY]);
    });
  });
}
var lK = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getInitialData = function(t, r) {
      var n, i = r.getComponent("xAxis", this.get("xAxisIndex")), o = r.getComponent("yAxis", this.get("yAxisIndex")), a = i.get("type"), s = o.get("type"), l;
      a === "category" ? (t.layout = "horizontal", n = i.getOrdinalMeta(), l = !0) : s === "category" ? (t.layout = "vertical", n = o.getOrdinalMeta(), l = !0) : t.layout = t.layout || "horizontal";
      var u = ["x", "y"], c = t.layout === "horizontal" ? 0 : 1, d = this._baseAxisDim = u[c], h = u[1 - c], f = [i, o], p = f[c].get("type"), g = f[1 - c].get("type"), v = t.data;
      if (v && l) {
        var m = [];
        $(v, function(S, b) {
          var w;
          be(S) ? (w = S.slice(), S.unshift(b)) : be(S.value) ? (w = ge({}, S), w.value = w.value.slice(), S.value.unshift(b)) : w = S, m.push(w);
        }), t.data = m;
      }
      var y = this.defaultValueDimensions, C = [{
        name: d,
        type: _C(p),
        ordinalMeta: n,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: h,
        type: _C(g),
        dimsDef: y.slice()
      }];
      return Df(this, {
        coordDimensions: C,
        dimensionsCount: y.length + 1,
        encodeDefaulter: _t(k7, C, this)
      });
    }, e.prototype.getBaseAxis = function() {
      var t = this._baseAxisDim;
      return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
    }, e;
  }()
), uK = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], r.visualDrawType = "stroke", r;
    }
    return t.type = "series.boxplot", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, t;
  }(Pr)
);
cn(uK, lK, !0);
var JAe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this.group, s = this._data;
      this._data || a.removeAll();
      var l = r.get("layout") === "horizontal" ? 1 : 0;
      o.diff(s).add(function(u) {
        if (o.hasValue(u)) {
          var c = o.getItemLayout(u), d = u4(c, o, u, l, !0);
          o.setItemGraphicEl(u, d), a.add(d);
        }
      }).update(function(u, c) {
        var d = s.getItemGraphicEl(c);
        if (!o.hasValue(u)) {
          a.remove(d);
          return;
        }
        var h = o.getItemLayout(u);
        d ? (Fa(d), cK(h, d, o, u)) : d = u4(h, o, u, l), a.add(d), o.setItemGraphicEl(u, d);
      }).remove(function(u) {
        var c = s.getItemGraphicEl(u);
        c && a.remove(c);
      }).execute(), this._data = o;
    }, t.prototype.remove = function(r) {
      var n = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(o) {
        o && n.remove(o);
      });
    }, t.type = "boxplot", t;
  }(br)
), eIe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), tIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "boxplotBoxPath", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new eIe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points, o = 0;
      for (r.moveTo(i[o][0], i[o][1]), o++; o < 4; o++)
        r.lineTo(i[o][0], i[o][1]);
      for (r.closePath(); o < i.length; o++)
        r.moveTo(i[o][0], i[o][1]), o++, r.lineTo(i[o][0], i[o][1]);
    }, t;
  }(Ht)
);
function u4(e, t, r, n, i) {
  var o = e.ends, a = new tIe({
    shape: {
      points: i ? rIe(o, n, e) : o
    }
  });
  return cK(e, a, t, r, i), a;
}
function cK(e, t, r, n, i) {
  var o = r.hostModel, a = od[i ? "initProps" : "updateProps"];
  a(t, {
    shape: {
      points: e.ends
    }
  }, o, n), t.useStyle(r.getItemVisual(n, "style")), t.style.strokeNoScale = !0, t.z2 = 100;
  var s = r.getItemModel(n), l = s.getModel("emphasis");
  ti(t, s), sn(t, l.get("focus"), l.get("blurScope"), l.get("disabled"));
}
function rIe(e, t, r) {
  return Ee(e, function(n) {
    return n = n.slice(), n[t] = r.initBaseline, n;
  });
}
var gg = $;
function nIe(e) {
  var t = iIe(e);
  gg(t, function(r) {
    var n = r.seriesModels;
    n.length && (oIe(r), gg(n, function(i, o) {
      aIe(i, r.boxOffsetList[o], r.boxWidthList[o]);
    }));
  });
}
function iIe(e) {
  var t = [], r = [];
  return e.eachSeriesByType("boxplot", function(n) {
    var i = n.getBaseAxis(), o = Ft(r, i);
    o < 0 && (o = r.length, r[o] = i, t[o] = {
      axis: i,
      seriesModels: []
    }), t[o].seriesModels.push(n);
  }), t;
}
function oIe(e) {
  var t = e.axis, r = e.seriesModels, n = r.length, i = e.boxWidthList = [], o = e.boxOffsetList = [], a = [], s;
  if (t.type === "category")
    s = t.getBandWidth();
  else {
    var l = 0;
    gg(r, function(p) {
      l = Math.max(l, p.getData().count());
    });
    var u = t.getExtent();
    s = Math.abs(u[1] - u[0]) / l;
  }
  gg(r, function(p) {
    var g = p.get("boxWidth");
    be(g) || (g = [g, g]), a.push([Be(g[0], s) || 0, Be(g[1], s) || 0]);
  });
  var c = s * 0.8 - 2, d = c / n * 0.3, h = (c - d * (n - 1)) / n, f = h / 2 - c / 2;
  gg(r, function(p, g) {
    o.push(f), f += d + h, i.push(Math.min(Math.max(h, a[g][0]), a[g][1]));
  });
}
function aIe(e, t, r) {
  var n = e.coordinateSystem, i = e.getData(), o = r / 2, a = e.get("layout") === "horizontal" ? 0 : 1, s = 1 - a, l = ["x", "y"], u = i.mapDimension(l[a]), c = i.mapDimensionsAll(l[s]);
  if (u == null || c.length < 5)
    return;
  for (var d = 0; d < i.count(); d++) {
    var h = i.get(u, d), f = C(h, c[2], d), p = C(h, c[0], d), g = C(h, c[1], d), v = C(h, c[3], d), m = C(h, c[4], d), y = [];
    S(y, g, !1), S(y, v, !0), y.push(p, g, m, v), b(y, p), b(y, m), b(y, f), i.setItemLayout(d, {
      initBaseline: f[s],
      ends: y
    });
  }
  function C(w, x, R) {
    var _ = i.get(x, R), T = [];
    T[a] = w, T[s] = _;
    var P;
    return isNaN(w) || isNaN(_) ? P = [NaN, NaN] : (P = n.dataToPoint(T), P[a] += t), P;
  }
  function S(w, x, R) {
    var _ = x.slice(), T = x.slice();
    _[a] += o, T[a] -= o, R ? w.push(_, T) : w.push(T, _);
  }
  function b(w, x) {
    var R = x.slice(), _ = x.slice();
    R[a] -= o, _[a] += o, w.push(R, _);
  }
}
function sIe(e, t) {
  t = t || {};
  for (var r = [], n = [], i = t.boundIQR, o = i === "none" || i === 0, a = 0; a < e.length; a++) {
    var s = vo(e[a].slice()), l = s0(s, 0.25), u = s0(s, 0.5), c = s0(s, 0.75), d = s[0], h = s[s.length - 1], f = (i ?? 1.5) * (c - l), p = o ? d : Math.max(d, l - f), g = o ? h : Math.min(h, c + f), v = t.itemNameFormatter, m = at(v) ? v({
      value: a
    }) : He(v) ? v.replace("{value}", a + "") : a + "";
    r.push([m, p, l, u, c, g]);
    for (var y = 0; y < s.length; y++) {
      var C = s[y];
      if (C < p || C > g) {
        var S = [m, C];
        n.push(S);
      }
    }
  }
  return {
    boxData: r,
    outliers: n
  };
}
var lIe = {
  type: "echarts:boxplot",
  transform: function(t) {
    var r = t.upstream;
    if (r.sourceFormat !== fi) {
      var n = "";
      process.env.NODE_ENV !== "production" && (n = Ai("source data is not applicable for this boxplot transform. Expect number[][].")), mr(n);
    }
    var i = sIe(r.getRawData(), t.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: i.boxData
    }, {
      data: i.outliers
    }];
  }
};
function uIe(e) {
  e.registerSeriesModel(uK), e.registerChartView(JAe), e.registerLayout(nIe), e.registerTransform(lIe);
}
var cIe = ["color", "borderColor"], dIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(r), this._isLargeDraw ? this._renderLarge(r) : this._renderNormal(r);
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      this._clear(), this._updateDrawMode(r);
    }, t.prototype.incrementalRender = function(r, n, i, o) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(r, n) : this._incrementalRenderNormal(r, n);
    }, t.prototype.eachRendered = function(r) {
      Su(this._progressiveEls || this.group, r);
    }, t.prototype._updateDrawMode = function(r) {
      var n = r.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, t.prototype._renderNormal = function(r) {
      var n = r.getData(), i = this._data, o = this.group, a = n.getLayout("isSimpleBox"), s = r.get("clip", !0), l = r.coordinateSystem, u = l.getArea && l.getArea();
      this._data || o.removeAll(), n.diff(i).add(function(c) {
        if (n.hasValue(c)) {
          var d = n.getItemLayout(c);
          if (s && c4(u, d))
            return;
          var h = Vx(d, c, !0);
          jr(h, {
            shape: {
              points: d.ends
            }
          }, r, c), Bx(h, n, c, a), o.add(h), n.setItemGraphicEl(c, h);
        }
      }).update(function(c, d) {
        var h = i.getItemGraphicEl(d);
        if (!n.hasValue(c)) {
          o.remove(h);
          return;
        }
        var f = n.getItemLayout(c);
        if (s && c4(u, f)) {
          o.remove(h);
          return;
        }
        h ? (ur(h, {
          shape: {
            points: f.ends
          }
        }, r, c), Fa(h)) : h = Vx(f), Bx(h, n, c, a), o.add(h), n.setItemGraphicEl(c, h);
      }).remove(function(c) {
        var d = i.getItemGraphicEl(c);
        d && o.remove(d);
      }).execute(), this._data = n;
    }, t.prototype._renderLarge = function(r) {
      this._clear(), d4(r, this.group);
      var n = r.get("clip", !0) ? Kv(r.coordinateSystem, !1, r) : null;
      n ? this.group.setClipPath(n) : this.group.removeClipPath();
    }, t.prototype._incrementalRenderNormal = function(r, n) {
      for (var i = n.getData(), o = i.getLayout("isSimpleBox"), a; (a = r.next()) != null; ) {
        var s = i.getItemLayout(a), l = Vx(s);
        Bx(l, i, a, o), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l);
      }
    }, t.prototype._incrementalRenderLarge = function(r, n) {
      d4(n, this.group, this._progressiveEls, !0);
    }, t.prototype.remove = function(r) {
      this._clear();
    }, t.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "candlestick", t;
  }(br)
), hIe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), fIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "normalCandlestickBox", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new hIe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points;
      this.__simpleBox ? (r.moveTo(i[4][0], i[4][1]), r.lineTo(i[6][0], i[6][1])) : (r.moveTo(i[0][0], i[0][1]), r.lineTo(i[1][0], i[1][1]), r.lineTo(i[2][0], i[2][1]), r.lineTo(i[3][0], i[3][1]), r.closePath(), r.moveTo(i[4][0], i[4][1]), r.lineTo(i[5][0], i[5][1]), r.moveTo(i[6][0], i[6][1]), r.lineTo(i[7][0], i[7][1]));
    }, t;
  }(Ht)
);
function Vx(e, t, r) {
  var n = e.ends;
  return new fIe({
    shape: {
      points: r ? pIe(n, e) : n
    },
    z2: 100
  });
}
function c4(e, t) {
  for (var r = !0, n = 0; n < t.ends.length; n++)
    if (e.contain(t.ends[n][0], t.ends[n][1])) {
      r = !1;
      break;
    }
  return r;
}
function Bx(e, t, r, n) {
  var i = t.getItemModel(r);
  e.useStyle(t.getItemVisual(r, "style")), e.style.strokeNoScale = !0, e.__simpleBox = n, ti(e, i);
}
function pIe(e, t) {
  return Ee(e, function(r) {
    return r = r.slice(), r[1] = t.initBaseline, r;
  });
}
var gIe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), $x = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "largeCandlestickBox", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new gIe();
    }, t.prototype.buildPath = function(r, n) {
      for (var i = n.points, o = 0; o < i.length; )
        if (this.__sign === i[o++]) {
          var a = i[o++];
          r.moveTo(a, i[o++]), r.lineTo(a, i[o++]);
        } else
          o += 3;
    }, t;
  }(Ht)
);
function d4(e, t, r, n) {
  var i = e.getData(), o = i.getLayout("largePoints"), a = new $x({
    shape: {
      points: o
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  t.add(a);
  var s = new $x({
    shape: {
      points: o
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  t.add(s);
  var l = new $x({
    shape: {
      points: o
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  t.add(l), Hx(1, a, e), Hx(-1, s, e), Hx(0, l, e), n && (a.incremental = !0, s.incremental = !0), r && r.push(a, s);
}
function Hx(e, t, r, n) {
  var i = r.get(["itemStyle", e > 0 ? "borderColor" : "borderColor0"]) || r.get(["itemStyle", e > 0 ? "color" : "color0"]);
  e === 0 && (i = r.get(["itemStyle", "borderColorDoji"]));
  var o = r.getModel("itemStyle").getItemStyle(cIe);
  t.useStyle(o), t.style.fill = null, t.style.stroke = i;
}
var dK = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], r;
    }
    return t.prototype.getShadowDim = function() {
      return "open";
    }, t.prototype.brushSelector = function(r, n, i) {
      var o = n.getItemLayout(r);
      return o && i.rect(o.brushRect);
    }, t.type = "series.candlestick", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, t;
  }(Pr)
);
cn(dK, lK, !0);
function vIe(e) {
  !e || !be(e.series) || $(e.series, function(t) {
    lt(t) && t.type === "k" && (t.type = "candlestick");
  });
}
var mIe = ["itemStyle", "borderColor"], yIe = ["itemStyle", "borderColor0"], CIe = ["itemStyle", "borderColorDoji"], SIe = ["itemStyle", "color"], wIe = ["itemStyle", "color0"], bIe = {
  seriesType: "candlestick",
  plan: Ef(),
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    function r(o, a) {
      return a.get(o > 0 ? SIe : wIe);
    }
    function n(o, a) {
      return a.get(o === 0 ? CIe : o > 0 ? mIe : yIe);
    }
    if (!t.isSeriesFiltered(e)) {
      var i = e.pipelineContext.large;
      return !i && {
        progress: function(o, a) {
          for (var s; (s = o.next()) != null; ) {
            var l = a.getItemModel(s), u = a.getItemLayout(s).sign, c = l.getItemStyle();
            c.fill = r(u, l), c.stroke = n(u, l) || c.fill;
            var d = a.ensureUniqueItemVisual(s, "style");
            ge(d, c);
          }
        }
      };
    }
  }
}, xIe = {
  seriesType: "candlestick",
  plan: Ef(),
  reset: function(e) {
    var t = e.coordinateSystem, r = e.getData(), n = EIe(e, r), i = 0, o = 1, a = ["x", "y"], s = r.getDimensionIndex(r.mapDimension(a[i])), l = Ee(r.mapDimensionsAll(a[o]), r.getDimensionIndex, r), u = l[0], c = l[1], d = l[2], h = l[3];
    if (r.setLayout({
      candleWidth: n,
      // The value is experimented visually.
      isSimpleBox: n <= 1.3
    }), s < 0 || l.length < 4)
      return;
    return {
      progress: e.pipelineContext.large ? p : f
    };
    function f(g, v) {
      for (var m, y = v.getStore(); (m = g.next()) != null; ) {
        var C = y.get(s, m), S = y.get(u, m), b = y.get(c, m), w = y.get(d, m), x = y.get(h, m), R = Math.min(S, b), _ = Math.max(S, b), T = N(R, C), P = N(_, C), D = N(w, C), O = N(x, C), A = [];
        I(A, P, 0), I(A, T, 1), A.push(M(O), M(P), M(D), M(T));
        var F = v.getItemModel(m), L = !!F.get(["itemStyle", "borderColorDoji"]);
        v.setItemLayout(m, {
          sign: h4(y, m, S, b, c, L),
          initBaseline: S > b ? P[o] : T[o],
          ends: A,
          brushRect: B(w, x, C)
        });
      }
      function N(V, G) {
        var k = [];
        return k[i] = G, k[o] = V, isNaN(G) || isNaN(V) ? [NaN, NaN] : t.dataToPoint(k);
      }
      function I(V, G, k) {
        var z = G.slice(), j = G.slice();
        z[i] = c0(z[i] + n / 2, 1, !1), j[i] = c0(j[i] - n / 2, 1, !0), k ? V.push(z, j) : V.push(j, z);
      }
      function B(V, G, k) {
        var z = N(V, k), j = N(G, k);
        return z[i] -= n / 2, j[i] -= n / 2, {
          x: z[0],
          y: z[1],
          width: n,
          height: j[1] - z[1]
        };
      }
      function M(V) {
        return V[i] = c0(V[i], 1), V;
      }
    }
    function p(g, v) {
      for (var m = is(g.count * 4), y = 0, C, S = [], b = [], w, x = v.getStore(), R = !!e.get(["itemStyle", "borderColorDoji"]); (w = g.next()) != null; ) {
        var _ = x.get(s, w), T = x.get(u, w), P = x.get(c, w), D = x.get(d, w), O = x.get(h, w);
        if (isNaN(_) || isNaN(D) || isNaN(O)) {
          m[y++] = NaN, y += 3;
          continue;
        }
        m[y++] = h4(x, w, T, P, c, R), S[i] = _, S[o] = D, C = t.dataToPoint(S, null, b), m[y++] = C ? C[0] : NaN, m[y++] = C ? C[1] : NaN, S[o] = O, C = t.dataToPoint(S, null, b), m[y++] = C ? C[1] : NaN;
      }
      v.setLayout("largePoints", m);
    }
  }
};
function h4(e, t, r, n, i, o) {
  var a;
  return r > n ? a = -1 : r < n ? a = 1 : a = o ? 0 : t > 0 ? e.get(i, t - 1) <= n ? 1 : -1 : 1, a;
}
function EIe(e, t) {
  var r = e.getBaseAxis(), n, i = r.type === "category" ? r.getBandWidth() : (n = r.getExtent(), Math.abs(n[1] - n[0]) / t.count()), o = Be(bt(e.get("barMaxWidth"), i), i), a = Be(bt(e.get("barMinWidth"), 1), i), s = e.get("barWidth");
  return s != null ? Be(s, i) : Math.max(Math.min(i / 2, o), a);
}
function RIe(e) {
  e.registerChartView(dIe), e.registerSeriesModel(dK), e.registerPreprocessor(vIe), e.registerVisual(bIe), e.registerLayout(xIe);
}
function f4(e, t) {
  var r = t.rippleEffectColor || t.color;
  e.eachChild(function(n) {
    n.attr({
      z: t.z,
      zlevel: t.zlevel,
      style: {
        stroke: t.brushType === "stroke" ? r : null,
        fill: t.brushType === "fill" ? r : null
      }
    });
  });
}
var _Ie = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n) {
      var i = e.call(this) || this, o = new jv(r, n), a = new Ct();
      return i.add(o), i.add(a), i.updateData(r, n), i;
    }
    return t.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, t.prototype.startEffectAnimation = function(r) {
      for (var n = r.symbolType, i = r.color, o = r.rippleNumber, a = this.childAt(1), s = 0; s < o; s++) {
        var l = mn(n, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / o * r.period + r.effectOffset;
        l.animate("", !0).when(r.period, {
          scaleX: r.rippleScale / 2,
          scaleY: r.rippleScale / 2
        }).delay(u).start(), l.animateStyle(!0).when(r.period, {
          opacity: 0
        }).delay(u).start(), a.add(l);
      }
      f4(a, r);
    }, t.prototype.updateEffectAnimation = function(r) {
      for (var n = this._effectCfg, i = this.childAt(1), o = ["symbolType", "period", "rippleScale", "rippleNumber"], a = 0; a < o.length; a++) {
        var s = o[a];
        if (n[s] !== r[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(r);
          return;
        }
      }
      f4(i, r);
    }, t.prototype.highlight = function() {
      Qs(this);
    }, t.prototype.downplay = function() {
      Js(this);
    }, t.prototype.getSymbolType = function() {
      var r = this.childAt(0);
      return r && r.getSymbolType();
    }, t.prototype.updateData = function(r, n) {
      var i = this, o = r.hostModel;
      this.childAt(0).updateData(r, n);
      var a = this.childAt(1), s = r.getItemModel(n), l = r.getItemVisual(n, "symbol"), u = _f(r.getItemVisual(n, "symbolSize")), c = r.getItemVisual(n, "style"), d = c && c.fill, h = s.getModel("emphasis");
      a.setScale(u), a.traverse(function(v) {
        v.setStyle("fill", d);
      });
      var f = ud(r.getItemVisual(n, "symbolOffset"), u);
      f && (a.x = f[0], a.y = f[1]);
      var p = r.getItemVisual(n, "symbolRotate");
      a.rotation = (p || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = o.get("showEffectOn"), g.rippleScale = s.get(["rippleEffect", "scale"]), g.brushType = s.get(["rippleEffect", "brushType"]), g.period = s.get(["rippleEffect", "period"]) * 1e3, g.effectOffset = n / r.count(), g.z = o.getShallow("z") || 0, g.zlevel = o.getShallow("zlevel") || 0, g.symbolType = l, g.color = d, g.rippleEffectColor = s.get(["rippleEffect", "color"]), g.rippleNumber = s.get(["rippleEffect", "number"]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(v) {
        v === "emphasis" ? g.showEffectOn !== "render" && i.startEffectAnimation(g) : v === "normal" && g.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = g, sn(this, h.get("focus"), h.get("blurScope"), h.get("disabled"));
    }, t.prototype.fadeOut = function(r) {
      r && r();
    }, t;
  }(Ct)
), TIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function() {
      this._symbolDraw = new Uv(_Ie);
    }, t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this._symbolDraw;
      a.updateData(o, {
        clipShape: this._getClipShape(r)
      }), this.group.add(a.group);
    }, t.prototype._getClipShape = function(r) {
      var n = r.coordinateSystem, i = n && n.getArea && n.getArea();
      return r.get("clip", !0) ? i : null;
    }, t.prototype.updateTransform = function(r, n, i) {
      var o = r.getData();
      this.group.dirty();
      var a = Yv("").reset(r, n, i);
      a.progress && a.progress({
        start: 0,
        end: o.count(),
        count: o.count()
      }, o), this._symbolDraw.updateLayout();
    }, t.prototype._updateGroupTransform = function(r) {
      var n = r.coordinateSystem;
      n && n.getRoamTransform && (this.group.transform = V6(n.getRoamTransform()), this.group.decomposeTransform());
    }, t.prototype.remove = function(r, n) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, t.type = "effectScatter", t;
  }(br)
), PIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return ws(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.brushSelector = function(r, n, i) {
      return i.point(n.getItemLayout(r));
    }, t.type = "series.effectScatter", t.dependencies = ["grid", "polar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 
      symbolSize: 10
      // symbolSize * 2
      // symbolRotate: null,  // 
      // itemStyle: {
      //     opacity: 1
      // }
    }, t;
  }(Pr)
);
function MIe(e) {
  e.registerChartView(TIe), e.registerSeriesModel(PIe), e.registerLayout(Yv("effectScatter"));
}
var hK = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i) {
      var o = e.call(this) || this;
      return o.add(o.createLine(r, n, i)), o._updateEffectSymbol(r, n), o;
    }
    return t.prototype.createLine = function(r, n, i) {
      return new vA(r, n, i);
    }, t.prototype._updateEffectSymbol = function(r, n) {
      var i = r.getItemModel(n), o = i.getModel("effect"), a = o.get("symbolSize"), s = o.get("symbol");
      be(a) || (a = [a, a]);
      var l = r.getItemVisual(n, "style"), u = o.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== s && (this.remove(c), c = mn(s, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = !0, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(o.getItemStyle(["color"])), c.scaleX = a[0], c.scaleY = a[1], c.setColor(u), this._symbolType = s, this._symbolScale = a, this._updateEffectAnimation(r, o, n));
    }, t.prototype._updateEffectAnimation = function(r, n, i) {
      var o = this.childAt(1);
      if (o) {
        var a = r.getItemLayout(i), s = n.get("period") * 1e3, l = n.get("loop"), u = n.get("roundTrip"), c = n.get("constantSpeed"), d = vn(n.get("delay"), function(f) {
          return f / r.count() * s / 3;
        });
        if (o.ignore = !0, this._updateAnimationPoints(o, a), c > 0 && (s = this._getLineLength(o) / c * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          o.stopAnimation();
          var h = void 0;
          at(d) ? h = d(i) : h = d, o.__t > 0 && (h = -s * o.__t), this._animateSymbol(o, s, h, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, t.prototype._animateSymbol = function(r, n, i, o, a) {
      if (n > 0) {
        r.__t = 0;
        var s = this, l = r.animate("", o).when(a ? n * 2 : n, {
          __t: a ? 2 : 1
        }).delay(i).during(function() {
          s._updateSymbolPosition(r);
        });
        o || l.done(function() {
          s.remove(r);
        }), l.start();
      }
    }, t.prototype._getLineLength = function(r) {
      return ks(r.__p1, r.__cp1) + ks(r.__cp1, r.__p2);
    }, t.prototype._updateAnimationPoints = function(r, n) {
      r.__p1 = n[0], r.__p2 = n[1], r.__cp1 = n[2] || [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2];
    }, t.prototype.updateData = function(r, n, i) {
      this.childAt(0).updateData(r, n, i), this._updateEffectSymbol(r, n);
    }, t.prototype._updateSymbolPosition = function(r) {
      var n = r.__p1, i = r.__p2, o = r.__cp1, a = r.__t < 1 ? r.__t : 2 - r.__t, s = [r.x, r.y], l = s.slice(), u = zn, c = g_;
      s[0] = u(n[0], o[0], i[0], a), s[1] = u(n[1], o[1], i[1], a);
      var d = r.__t < 1 ? c(n[0], o[0], i[0], a) : c(i[0], o[0], n[0], 1 - a), h = r.__t < 1 ? c(n[1], o[1], i[1], a) : c(i[1], o[1], n[1], 1 - a);
      r.rotation = -Math.atan2(h, d) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (r.__lastT !== void 0 && r.__lastT < r.__t ? (r.scaleY = ks(l, s) * 1.05, a === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : r.__lastT === 1 ? r.scaleY = 2 * ks(n, s) : r.scaleY = this._symbolScale[1]), r.__lastT = r.__t, r.ignore = !1, r.x = s[0], r.y = s[1];
    }, t.prototype.updateLayout = function(r, n) {
      this.childAt(0).updateLayout(r, n);
      var i = r.getItemModel(n).getModel("effect");
      this._updateEffectAnimation(r, i, n);
    }, t;
  }(Ct)
), fK = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i) {
      var o = e.call(this) || this;
      return o._createPolyline(r, n, i), o;
    }
    return t.prototype._createPolyline = function(r, n, i) {
      var o = r.getItemLayout(n), a = new Ni({
        shape: {
          points: o
        }
      });
      this.add(a), this._updateCommonStl(r, n, i);
    }, t.prototype.updateData = function(r, n, i) {
      var o = r.hostModel, a = this.childAt(0), s = {
        shape: {
          points: r.getItemLayout(n)
        }
      };
      ur(a, s, o, n), this._updateCommonStl(r, n, i);
    }, t.prototype._updateCommonStl = function(r, n, i) {
      var o = this.childAt(0), a = r.getItemModel(n), s = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || r.hasItemOption) {
        var d = a.getModel("emphasis");
        s = d.getModel("lineStyle").getLineStyle(), c = d.get("disabled"), l = d.get("focus"), u = d.get("blurScope");
      }
      o.useStyle(r.getItemVisual(n, "style")), o.style.fill = null, o.style.strokeNoScale = !0;
      var h = o.ensureState("emphasis");
      h.style = s, sn(this, l, u, c);
    }, t.prototype.updateLayout = function(r, n) {
      var i = this.childAt(0);
      i.setShape("points", r.getItemLayout(n));
    }, t;
  }(Ct)
), DIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r._lastFrame = 0, r._lastFramePercent = 0, r;
    }
    return t.prototype.createLine = function(r, n, i) {
      return new fK(r, n, i);
    }, t.prototype._updateAnimationPoints = function(r, n) {
      this._points = n;
      for (var i = [0], o = 0, a = 1; a < n.length; a++) {
        var s = n[a - 1], l = n[a];
        o += ks(s, l), i.push(o);
      }
      if (o === 0) {
        this._length = 0;
        return;
      }
      for (var a = 0; a < i.length; a++)
        i[a] /= o;
      this._offsets = i, this._length = o;
    }, t.prototype._getLineLength = function() {
      return this._length;
    }, t.prototype._updateSymbolPosition = function(r) {
      var n = r.__t < 1 ? r.__t : 2 - r.__t, i = this._points, o = this._offsets, a = i.length;
      if (o) {
        var s = this._lastFrame, l;
        if (n < this._lastFramePercent) {
          var u = Math.min(s + 1, a - 1);
          for (l = u; l >= 0 && !(o[l] <= n); l--)
            ;
          l = Math.min(l, a - 2);
        } else {
          for (l = s; l < a && !(o[l] > n); l++)
            ;
          l = Math.min(l - 1, a - 2);
        }
        var c = (n - o[l]) / (o[l + 1] - o[l]), d = i[l], h = i[l + 1];
        r.x = d[0] * (1 - c) + c * h[0], r.y = d[1] * (1 - c) + c * h[1];
        var f = r.__t < 1 ? h[0] - d[0] : d[0] - h[0], p = r.__t < 1 ? h[1] - d[1] : d[1] - h[1];
        r.rotation = -Math.atan2(p, f) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = n, r.ignore = !1;
      }
    }, t;
  }(hK)
), AIe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return e;
  }()
), IIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return t.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new AIe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.segs, o = n.curveness, a;
      if (n.polyline)
        for (a = this._off; a < i.length; ) {
          var s = i[a++];
          if (s > 0) {
            r.moveTo(i[a++], i[a++]);
            for (var l = 1; l < s; l++)
              r.lineTo(i[a++], i[a++]);
          }
        }
      else
        for (a = this._off; a < i.length; ) {
          var u = i[a++], c = i[a++], d = i[a++], h = i[a++];
          if (r.moveTo(u, c), o > 0) {
            var f = (u + d) / 2 - (c - h) * o, p = (c + h) / 2 - (d - u) * o;
            r.quadraticCurveTo(f, p, d, h);
          } else
            r.lineTo(d, h);
        }
      this.incremental && (this._off = a, this.notClear = !0);
    }, t.prototype.findDataIndex = function(r, n) {
      var i = this.shape, o = i.segs, a = i.curveness, s = this.style.lineWidth;
      if (i.polyline)
        for (var l = 0, u = 0; u < o.length; ) {
          var c = o[u++];
          if (c > 0)
            for (var d = o[u++], h = o[u++], f = 1; f < c; f++) {
              var p = o[u++], g = o[u++];
              if (Pl(d, h, p, g, s, r, n))
                return l;
            }
          l++;
        }
      else
        for (var l = 0, u = 0; u < o.length; ) {
          var d = o[u++], h = o[u++], p = o[u++], g = o[u++];
          if (a > 0) {
            var v = (d + p) / 2 - (h - g) * a, m = (h + g) / 2 - (p - d) * a;
            if (MW(d, h, v, m, p, g, s, r, n))
              return l;
          } else if (Pl(d, h, p, g, s, r, n))
            return l;
          l++;
        }
      return -1;
    }, t.prototype.contain = function(r, n) {
      var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect();
      if (r = i[0], n = i[1], o.contain(r, n)) {
        var a = this.hoverDataIdx = this.findDataIndex(r, n);
        return a >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, t.prototype.getBoundingRect = function() {
      var r = this._rect;
      if (!r) {
        for (var n = this.shape, i = n.segs, o = 1 / 0, a = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], d = i[u++];
          o = Math.min(c, o), s = Math.max(c, s), a = Math.min(d, a), l = Math.max(d, l);
        }
        r = this._rect = new At(o, a, s, l);
      }
      return r;
    }, t;
  }(Ht)
), OIe = (
  /** @class */
  function() {
    function e() {
      this.group = new Ct();
    }
    return e.prototype.updateData = function(t) {
      this._clear();
      var r = this._create();
      r.setShape({
        segs: t.getLayout("linesPoints")
      }), this._setCommon(r, t);
    }, e.prototype.incrementalPrepareUpdate = function(t) {
      this.group.removeAll(), this._clear();
    }, e.prototype.incrementalUpdate = function(t, r) {
      var n = this._newAdded[0], i = r.getLayout("linesPoints"), o = n && n.shape.segs;
      if (o && o.length < 2e4) {
        var a = o.length, s = new Float32Array(a + i.length);
        s.set(o), s.set(i, a), n.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = !0, l.setShape({
          segs: i
        }), this._setCommon(l, r), l.__startIndex = t.start;
      }
    }, e.prototype.remove = function() {
      this._clear();
    }, e.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, e.prototype._create = function() {
      var t = new IIe({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(t), this.group.add(t), t;
    }, e.prototype._setCommon = function(t, r, n) {
      var i = r.hostModel;
      t.setShape({
        polyline: i.get("polyline"),
        curveness: i.get(["lineStyle", "curveness"])
      }), t.useStyle(i.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = !0;
      var o = r.getVisual("style");
      o && o.stroke && t.setStyle("stroke", o.stroke), t.setStyle("fill", null);
      var a = St(t);
      a.seriesIndex = i.seriesIndex, t.on("mousemove", function(s) {
        a.dataIndex = null;
        var l = t.hoverDataIdx;
        l > 0 && (a.dataIndex = l + t.__startIndex);
      });
    }, e.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, e;
  }()
), pK = {
  seriesType: "lines",
  plan: Ef(),
  reset: function(e) {
    var t = e.coordinateSystem;
    if (!t) {
      process.env.NODE_ENV !== "production" && ei("The lines series must have a coordinate system.");
      return;
    }
    var r = e.get("polyline"), n = e.pipelineContext.large;
    return {
      progress: function(i, o) {
        var a = [];
        if (n) {
          var s = void 0, l = i.end - i.start;
          if (r) {
            for (var u = 0, c = i.start; c < i.end; c++)
              u += e.getLineCoordsCount(c);
            s = new Float32Array(l + u * 2);
          } else
            s = new Float32Array(l * 4);
          for (var d = 0, h = [], c = i.start; c < i.end; c++) {
            var f = e.getLineCoords(c, a);
            r && (s[d++] = f);
            for (var p = 0; p < f; p++)
              h = t.dataToPoint(a[p], !1, h), s[d++] = h[0], s[d++] = h[1];
          }
          o.setLayout("linesPoints", s);
        } else
          for (var c = i.start; c < i.end; c++) {
            var g = o.getItemModel(c), f = e.getLineCoords(c, a), v = [];
            if (r)
              for (var m = 0; m < f; m++)
                v.push(t.dataToPoint(a[m]));
            else {
              v[0] = t.dataToPoint(a[0]), v[1] = t.dataToPoint(a[1]);
              var y = g.get(["lineStyle", "curveness"]);
              +y && (v[2] = [(v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * y, (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * y]);
            }
            o.setItemLayout(c, v);
          }
      }
    };
  }
}, LIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this._updateLineDraw(o, r), s = r.get("zlevel"), l = r.get(["effect", "trailLength"]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(r) && l > 0 && (c ? process.env.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : u.configLayer(s, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), a.updateData(o);
      var d = r.get("clip", !0) && Kv(r.coordinateSystem, !1, r);
      d ? this.group.setClipPath(d) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0;
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      var o = r.getData(), a = this._updateLineDraw(o, r);
      a.incrementalPrepareUpdate(o), this._clearLayer(i), this._finished = !1;
    }, t.prototype.incrementalRender = function(r, n, i) {
      this._lineDraw.incrementalUpdate(r, n.getData()), this._finished = r.end === n.getData().count();
    }, t.prototype.eachRendered = function(r) {
      this._lineDraw && this._lineDraw.eachRendered(r);
    }, t.prototype.updateTransform = function(r, n, i) {
      var o = r.getData(), a = r.pipelineContext;
      if (!this._finished || a.large || a.progressiveRender)
        return {
          update: !0
        };
      var s = pK.reset(r, n, i);
      s.progress && s.progress({
        start: 0,
        end: o.count(),
        count: o.count()
      }, o), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, t.prototype._updateLineDraw = function(r, n) {
      var i = this._lineDraw, o = this._showEffect(n), a = !!n.get("polyline"), s = n.pipelineContext, l = s.large;
      return process.env.NODE_ENV !== "production" && o && l && console.warn("Large lines not support effect"), (!i || o !== this._hasEffet || a !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new OIe() : new mA(a ? o ? DIe : fK : o ? hK : vA), this._hasEffet = o, this._isPolyline = a, this._isLargeDraw = l), this.group.add(i.group), i;
    }, t.prototype._showEffect = function(r) {
      return !!r.get(["effect", "show"]);
    }, t.prototype._clearLayer = function(r) {
      var n = r.getZr(), i = n.painter.getType() === "svg";
      !i && this._lastZlevel != null && n.painter.getLayer(this._lastZlevel).clear(!0);
    }, t.prototype.remove = function(r, n) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(n);
    }, t.prototype.dispose = function(r, n) {
      this.remove(r, n);
    }, t.type = "lines", t;
  }(br)
), FIe = typeof Uint32Array > "u" ? Array : Uint32Array, NIe = typeof Float64Array > "u" ? Array : Float64Array;
function p4(e) {
  var t = e.data;
  t && t[0] && t[0][0] && t[0][0].coord && (process.env.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), e.data = Ee(t, function(r) {
    var n = [r[0].coord, r[1].coord], i = {
      coords: n
    };
    return r[0].name && (i.fromName = r[0].name), r[1].name && (i.toName = r[1].name), zS([i, r[0], r[1]]);
  }));
}
var kIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.visualStyleAccessPath = "lineStyle", r.visualDrawType = "stroke", r;
    }
    return t.prototype.init = function(r) {
      r.data = r.data || [], p4(r);
      var n = this._processFlatCoordsArray(r.data);
      this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (r.data = new Float32Array(n.count)), e.prototype.init.apply(this, arguments);
    }, t.prototype.mergeOption = function(r) {
      if (p4(r), r.data) {
        var n = this._processFlatCoordsArray(r.data);
        this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (r.data = new Float32Array(n.count));
      }
      e.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.appendData = function(r) {
      var n = this._processFlatCoordsArray(r.data);
      n.flatCoords && (this._flatCoords ? (this._flatCoords = Vg(this._flatCoords, n.flatCoords), this._flatCoordsOffset = Vg(this._flatCoordsOffset, n.flatCoordsOffset)) : (this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset), r.data = new Float32Array(n.count)), this.getRawData().appendData(r.data);
    }, t.prototype._getCoordsFromItemModel = function(r) {
      var n = this.getData().getItemModel(r), i = n.option instanceof Array ? n.option : n.getShallow("coords");
      if (process.env.NODE_ENV !== "production" && !(i instanceof Array && i.length > 0 && i[0] instanceof Array))
        throw new Error("Invalid coords " + JSON.stringify(i) + ". Lines must have 2d coords array in data item.");
      return i;
    }, t.prototype.getLineCoordsCount = function(r) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[r * 2 + 1] : this._getCoordsFromItemModel(r).length;
    }, t.prototype.getLineCoords = function(r, n) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[r * 2], o = this._flatCoordsOffset[r * 2 + 1], a = 0; a < o; a++)
          n[a] = n[a] || [], n[a][0] = this._flatCoords[i + a * 2], n[a][1] = this._flatCoords[i + a * 2 + 1];
        return o;
      } else {
        for (var s = this._getCoordsFromItemModel(r), a = 0; a < s.length; a++)
          n[a] = n[a] || [], n[a][0] = s[a][0], n[a][1] = s[a][1];
        return s.length;
      }
    }, t.prototype._processFlatCoordsArray = function(r) {
      var n = 0;
      if (this._flatCoords && (n = this._flatCoords.length), sr(r[0])) {
        for (var i = r.length, o = new FIe(i), a = new NIe(i), s = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var d = r[c++];
          o[l++] = s + n, o[l++] = d;
          for (var h = 0; h < d; h++) {
            var f = r[c++], p = r[c++];
            if (a[s++] = f, a[s++] = p, c > i && process.env.NODE_ENV !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(o.buffer, 0, l),
          flatCoords: a,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: r.length
      };
    }, t.prototype.getInitialData = function(r, n) {
      if (process.env.NODE_ENV !== "production") {
        var i = ld.get(r.coordinateSystem);
        if (!i)
          throw new Error("Unknown coordinate system " + r.coordinateSystem);
      }
      var o = new di(["value"], this);
      return o.hasItemOption = !1, o.initData(r.data, [], function(a, s, l, u) {
        if (a instanceof Array)
          return NaN;
        o.hasItemOption = !0;
        var c = a.value;
        if (c != null)
          return c instanceof Array ? c[u] : c;
      }), o;
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = o.getItemModel(r), s = a.get("name");
      if (s)
        return s;
      var l = a.get("fromName"), u = a.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), Hn("nameValue", {
        name: c.join(" > ")
      });
    }, t.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, t.prototype.getProgressive = function() {
      var r = this.option.progressive;
      return r ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var r = this.option.progressiveThreshold;
      return r ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, t.prototype.getZLevelKey = function() {
      var r = this.getModel("effect"), n = r.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : r.get("show") && n > 0 ? n + "" : "";
    }, t.type = "series.lines", t.dependencies = ["grid", "polar", "geo", "calendar"], t.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: Tooltip.formatter
      },
      lineStyle: {
        opacity: 0.5
      }
    }, t;
  }(Pr)
);
function xy(e) {
  return e instanceof Array || (e = [e, e]), e;
}
var VIe = {
  seriesType: "lines",
  reset: function(e) {
    var t = xy(e.get("symbol")), r = xy(e.get("symbolSize")), n = e.getData();
    n.setVisual("fromSymbol", t && t[0]), n.setVisual("toSymbol", t && t[1]), n.setVisual("fromSymbolSize", r && r[0]), n.setVisual("toSymbolSize", r && r[1]);
    function i(o, a) {
      var s = o.getItemModel(a), l = xy(s.getShallow("symbol", !0)), u = xy(s.getShallow("symbolSize", !0));
      l[0] && o.setItemVisual(a, "fromSymbol", l[0]), l[1] && o.setItemVisual(a, "toSymbol", l[1]), u[0] && o.setItemVisual(a, "fromSymbolSize", u[0]), u[1] && o.setItemVisual(a, "toSymbolSize", u[1]);
    }
    return {
      dataEach: n.hasItemOption ? i : null
    };
  }
};
function BIe(e) {
  e.registerChartView(LIe), e.registerSeriesModel(kIe), e.registerLayout(pK), e.registerVisual(VIe);
}
var $Ie = 256, HIe = (
  /** @class */
  function() {
    function e() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var t = Ia.createCanvas();
      this.canvas = t;
    }
    return e.prototype.update = function(t, r, n, i, o, a) {
      var s = this._getBrush(), l = this._getGradient(o, "inRange"), u = this._getGradient(o, "outOfRange"), c = this.pointSize + this.blurSize, d = this.canvas, h = d.getContext("2d"), f = t.length;
      d.width = r, d.height = n;
      for (var p = 0; p < f; ++p) {
        var g = t[p], v = g[0], m = g[1], y = g[2], C = i(y);
        h.globalAlpha = C, h.drawImage(s, v - c, m - c);
      }
      if (!d.width || !d.height)
        return d;
      for (var S = h.getImageData(0, 0, d.width, d.height), b = S.data, w = 0, x = b.length, R = this.minOpacity, _ = this.maxOpacity, T = _ - R; w < x; ) {
        var C = b[w + 3] / 256, P = Math.floor(C * ($Ie - 1)) * 4;
        if (C > 0) {
          var D = a(C) ? l : u;
          C > 0 && (C = C * T + R), b[w++] = D[P], b[w++] = D[P + 1], b[w++] = D[P + 2], b[w++] = D[P + 3] * C * 256;
        } else
          w += 4;
      }
      return h.putImageData(S, 0, 0), d;
    }, e.prototype._getBrush = function() {
      var t = this._brushCanvas || (this._brushCanvas = Ia.createCanvas()), r = this.pointSize + this.blurSize, n = r * 2;
      t.width = n, t.height = n;
      var i = t.getContext("2d");
      return i.clearRect(0, 0, n, n), i.shadowOffsetX = n, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-r, r, this.pointSize, 0, Math.PI * 2, !0), i.closePath(), i.fill(), t;
    }, e.prototype._getGradient = function(t, r) {
      for (var n = this._gradientPixels, i = n[r] || (n[r] = new Uint8ClampedArray(256 * 4)), o = [0, 0, 0, 0], a = 0, s = 0; s < 256; s++)
        t[r](s / 255, !0, o), i[a++] = o[0], i[a++] = o[1], i[a++] = o[2], i[a++] = o[3];
      return i;
    }, e;
  }()
);
function GIe(e, t, r) {
  var n = e[1] - e[0];
  t = Ee(t, function(a) {
    return {
      interval: [(a.interval[0] - e[0]) / n, (a.interval[1] - e[0]) / n]
    };
  });
  var i = t.length, o = 0;
  return function(a) {
    var s;
    for (s = o; s < i; s++) {
      var l = t[s].interval;
      if (l[0] <= a && a <= l[1]) {
        o = s;
        break;
      }
    }
    if (s === i)
      for (s = o - 1; s >= 0; s--) {
        var l = t[s].interval;
        if (l[0] <= a && a <= l[1]) {
          o = s;
          break;
        }
      }
    return s >= 0 && s < i && r[s];
  };
}
function zIe(e, t) {
  var r = e[1] - e[0];
  return t = [(t[0] - e[0]) / r, (t[1] - e[0]) / r], function(n) {
    return n >= t[0] && n <= t[1];
  };
}
function g4(e) {
  var t = e.dimensions;
  return t[0] === "lng" && t[1] === "lat";
}
var WIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o;
      if (n.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === r && (o = s);
        });
      }), process.env.NODE_ENV !== "production" && !o)
        throw new Error("Heatmap must use with visualMap");
      this._progressiveEls = null, this.group.removeAll();
      var a = r.coordinateSystem;
      a.type === "cartesian2d" || a.type === "calendar" ? this._renderOnCartesianAndCalendar(r, i, 0, r.getData().count()) : g4(a) && this._renderOnGeo(a, r, o, i);
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      this.group.removeAll();
    }, t.prototype.incrementalRender = function(r, n, i, o) {
      var a = n.coordinateSystem;
      a && (g4(a) ? this.render(n, i, o) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(n, o, r.start, r.end, !0)));
    }, t.prototype.eachRendered = function(r) {
      Su(this._progressiveEls || this.group, r);
    }, t.prototype._renderOnCartesianAndCalendar = function(r, n, i, o, a) {
      var s = r.coordinateSystem, l = cd(s, "cartesian2d"), u, c, d, h;
      if (l) {
        var f = s.getAxis("x"), p = s.getAxis("y");
        if (process.env.NODE_ENV !== "production") {
          if (!(f.type === "category" && p.type === "category"))
            throw new Error("Heatmap on cartesian must have two category axes");
          if (!(f.onBand && p.onBand))
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
        u = f.getBandWidth() + 0.5, c = p.getBandWidth() + 0.5, d = f.scale.getExtent(), h = p.scale.getExtent();
      }
      for (var g = this.group, v = r.getData(), m = r.getModel(["emphasis", "itemStyle"]).getItemStyle(), y = r.getModel(["blur", "itemStyle"]).getItemStyle(), C = r.getModel(["select", "itemStyle"]).getItemStyle(), S = r.get(["itemStyle", "borderRadius"]), b = $n(r), w = r.getModel("emphasis"), x = w.get("focus"), R = w.get("blurScope"), _ = w.get("disabled"), T = l ? [v.mapDimension("x"), v.mapDimension("y"), v.mapDimension("value")] : [v.mapDimension("time"), v.mapDimension("value")], P = i; P < o; P++) {
        var D = void 0, O = v.getItemVisual(P, "style");
        if (l) {
          var A = v.get(T[0], P), F = v.get(T[1], P);
          if (isNaN(v.get(T[2], P)) || isNaN(A) || isNaN(F) || A < d[0] || A > d[1] || F < h[0] || F > h[1])
            continue;
          var L = s.dataToPoint([A, F]);
          D = new or({
            shape: {
              x: L[0] - u / 2,
              y: L[1] - c / 2,
              width: u,
              height: c
            },
            style: O
          });
        } else {
          if (isNaN(v.get(T[1], P)))
            continue;
          D = new or({
            z2: 1,
            shape: s.dataToRect([v.get(T[0], P)]).contentShape,
            style: O
          });
        }
        if (v.hasItemOption) {
          var N = v.getItemModel(P), I = N.getModel("emphasis");
          m = I.getModel("itemStyle").getItemStyle(), y = N.getModel(["blur", "itemStyle"]).getItemStyle(), C = N.getModel(["select", "itemStyle"]).getItemStyle(), S = N.get(["itemStyle", "borderRadius"]), x = I.get("focus"), R = I.get("blurScope"), _ = I.get("disabled"), b = $n(N);
        }
        D.shape.r = S;
        var B = r.getRawValue(P), M = "-";
        B && B[2] != null && (M = B[2] + ""), ri(D, b, {
          labelFetcher: r,
          labelDataIndex: P,
          defaultOpacity: O.opacity,
          defaultText: M
        }), D.ensureState("emphasis").style = m, D.ensureState("blur").style = y, D.ensureState("select").style = C, sn(D, x, R, _), D.incremental = a, a && (D.states.emphasis.hoverLayer = !0), g.add(D), v.setItemGraphicEl(P, D), this._progressiveEls && this._progressiveEls.push(D);
      }
    }, t.prototype._renderOnGeo = function(r, n, i, o) {
      var a = i.targetVisuals.inRange, s = i.targetVisuals.outOfRange, l = n.getData(), u = this._hmLayer || this._hmLayer || new HIe();
      u.blurSize = n.get("blurSize"), u.pointSize = n.get("pointSize"), u.minOpacity = n.get("minOpacity"), u.maxOpacity = n.get("maxOpacity");
      var c = r.getViewRect().clone(), d = r.getRoamTransform();
      c.applyTransform(d);
      var h = Math.max(c.x, 0), f = Math.max(c.y, 0), p = Math.min(c.width + c.x, o.getWidth()), g = Math.min(c.height + c.y, o.getHeight()), v = p - h, m = g - f, y = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], C = l.mapArray(y, function(x, R, _) {
        var T = r.dataToPoint([x, R]);
        return T[0] -= h, T[1] -= f, T.push(_), T;
      }), S = i.getExtent(), b = i.type === "visualMap.continuous" ? zIe(S, i.option.range) : GIe(S, i.getPieceList(), i.option.selected);
      u.update(C, v, m, a.color.getNormalizer(), {
        inRange: a.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, b);
      var w = new qn({
        style: {
          width: v,
          height: m,
          x: h,
          y: f,
          image: u.canvas
        },
        silent: !0
      });
      this.group.add(w);
    }, t.type = "heatmap", t;
  }(br)
), jIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return ws(null, this, {
        generateCoord: "value"
      });
    }, t.prototype.preventIncremental = function() {
      var r = ld.get(this.get("coordinateSystem"));
      if (r && r.dimensions)
        return r.dimensions[0] === "lng" && r.dimensions[1] === "lat";
    }, t.type = "series.heatmap", t.dependencies = ["grid", "geo", "calendar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, t;
  }(Pr)
);
function UIe(e) {
  e.registerChartView(WIe), e.registerSeriesModel(jIe);
}
var KIe = ["itemStyle", "borderWidth"], v4 = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], Gx = new ul(), YIe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = this.group, a = r.getData(), s = this._data, l = r.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), d = l.master.getRect(), h = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: r,
        coordSys: l,
        coordSysExtent: [[d.x, d.x + d.width], [d.y, d.y + d.height]],
        isHorizontal: c,
        valueDim: v4[+c],
        categoryDim: v4[1 - +c]
      };
      a.diff(s).add(function(p) {
        if (a.hasValue(p)) {
          var g = y4(a, p), v = m4(a, p, g, h), m = C4(a, h, v);
          a.setItemGraphicEl(p, m), o.add(m), w4(m, h, v);
        }
      }).update(function(p, g) {
        var v = s.getItemGraphicEl(g);
        if (!a.hasValue(p)) {
          o.remove(v);
          return;
        }
        var m = y4(a, p), y = m4(a, p, m, h), C = SK(a, y);
        v && C !== v.__pictorialShapeStr && (o.remove(v), a.setItemGraphicEl(p, null), v = null), v ? t2e(v, h, y) : v = C4(a, h, y, !0), a.setItemGraphicEl(p, v), v.__pictorialSymbolMeta = y, o.add(v), w4(v, h, y);
      }).remove(function(p) {
        var g = s.getItemGraphicEl(p);
        g && S4(s, p, g.__pictorialSymbolMeta.animationModel, g);
      }).execute();
      var f = r.get("clip", !0) ? Kv(r.coordinateSystem, !1, r) : null;
      return f ? o.setClipPath(f) : o.removeClipPath(), this._data = a, this.group;
    }, t.prototype.remove = function(r, n) {
      var i = this.group, o = this._data;
      r.get("animation") ? o && o.eachItemGraphicEl(function(a) {
        S4(o, St(a).dataIndex, r, a);
      }) : i.removeAll();
    }, t.type = "pictorialBar", t;
  }(br)
);
function m4(e, t, r, n) {
  var i = e.getItemLayout(t), o = r.get("symbolRepeat"), a = r.get("symbolClip"), s = r.get("symbolPosition") || "start", l = r.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = r.get("symbolPatternSize") || 2, d = r.isAnimationEnabled(), h = {
    dataIndex: t,
    layout: i,
    itemModel: r,
    symbolType: e.getItemVisual(t, "symbol") || "circle",
    style: e.getItemVisual(t, "style"),
    symbolClip: a,
    symbolRepeat: o,
    symbolRepeatDirection: r.get("symbolRepeatDirection"),
    symbolPatternSize: c,
    rotation: u,
    animationModel: d ? r : null,
    hoverScale: d && r.get(["emphasis", "scale"]),
    z2: r.getShallow("z", !0) || 0
  };
  qIe(r, o, i, n, h), XIe(e, t, i, o, a, h.boundingLength, h.pxSign, c, n, h), ZIe(r, h.symbolScale, u, n, h);
  var f = h.symbolSize, p = ud(r.get("symbolOffset"), f);
  return QIe(r, f, i, o, a, p, s, h.valueLineWidth, h.boundingLength, h.repeatCutLength, n, h), h;
}
function qIe(e, t, r, n, i) {
  var o = n.valueDim, a = e.get("symbolBoundingData"), s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(r[o.wh] <= 0), c;
  if (be(a)) {
    var d = [zx(s, a[0]) - l, zx(s, a[1]) - l];
    d[1] < d[0] && d.reverse(), c = d[u];
  } else a != null ? c = zx(s, a) - l : t ? c = n.coordSysExtent[o.index][u] - l : c = r[o.wh];
  i.boundingLength = c, t && (i.repeatCutLength = r[o.wh]), i.pxSign = c > 0 ? 1 : -1;
}
function zx(e, t) {
  return e.toGlobalCoord(e.dataToCoord(e.scale.parse(t)));
}
function XIe(e, t, r, n, i, o, a, s, l, u) {
  var c = l.valueDim, d = l.categoryDim, h = Math.abs(r[d.wh]), f = e.getItemVisual(t, "symbolSize"), p;
  be(f) ? p = f.slice() : f == null ? p = ["100%", "100%"] : p = [f, f], p[d.index] = Be(p[d.index], h), p[c.index] = Be(p[c.index], n ? h : Math.abs(o)), u.symbolSize = p;
  var g = u.symbolScale = [p[0] / s, p[1] / s];
  g[c.index] *= (l.isHorizontal ? -1 : 1) * a;
}
function ZIe(e, t, r, n, i) {
  var o = e.get(KIe) || 0;
  o && (Gx.attr({
    scaleX: t[0],
    scaleY: t[1],
    rotation: r
  }), Gx.updateTransform(), o /= Gx.getLineScale(), o *= t[n.valueDim.index]), i.valueLineWidth = o || 0;
}
function QIe(e, t, r, n, i, o, a, s, l, u, c, d) {
  var h = c.categoryDim, f = c.valueDim, p = d.pxSign, g = Math.max(t[f.index] + s, 0), v = g;
  if (n) {
    var m = Math.abs(l), y = vn(e.get("symbolMargin"), "15%") + "", C = !1;
    y.lastIndexOf("!") === y.length - 1 && (C = !0, y = y.slice(0, y.length - 1));
    var S = Be(y, t[f.index]), b = Math.max(g + S * 2, 0), w = C ? 0 : S * 2, x = ZS(n), R = x ? n : b4((m + w) / b), _ = m - R * g;
    S = _ / 2 / (C ? R : Math.max(R - 1, 1)), b = g + S * 2, w = C ? 0 : S * 2, !x && n !== "fixed" && (R = u ? b4((Math.abs(u) + w) / b) : 0), v = R * b - w, d.repeatTimes = R, d.symbolMargin = S;
  }
  var T = p * (v / 2), P = d.pathPosition = [];
  P[h.index] = r[h.wh] / 2, P[f.index] = a === "start" ? T : a === "end" ? l - T : l / 2, o && (P[0] += o[0], P[1] += o[1]);
  var D = d.bundlePosition = [];
  D[h.index] = r[h.xy], D[f.index] = r[f.xy];
  var O = d.barRectShape = ge({}, r);
  O[f.wh] = p * Math.max(Math.abs(r[f.wh]), Math.abs(P[f.index] + T)), O[h.wh] = r[h.wh];
  var A = d.clipShape = {};
  A[h.xy] = -r[h.xy], A[h.wh] = c.ecSize[h.wh], A[f.xy] = 0, A[f.wh] = r[f.wh];
}
function gK(e) {
  var t = e.symbolPatternSize, r = mn(
    // Consider texture img, make a big size.
    e.symbolType,
    -t / 2,
    -t / 2,
    t,
    t
  );
  return r.attr({
    culling: !0
  }), r.type !== "image" && r.setStyle({
    strokeNoScale: !0
  }), r;
}
function vK(e, t, r, n) {
  var i = e.__pictorialBundle, o = r.symbolSize, a = r.valueLineWidth, s = r.pathPosition, l = t.valueDim, u = r.repeatTimes || 0, c = 0, d = o[t.valueDim.index] + a + r.symbolMargin * 2;
  for (RA(e, function(g) {
    g.__pictorialAnimationIndex = c, g.__pictorialRepeatTimes = u, c < u ? Ih(g, null, p(c), r, n) : Ih(g, null, {
      scaleX: 0,
      scaleY: 0
    }, r, n, function() {
      i.remove(g);
    }), c++;
  }); c < u; c++) {
    var h = gK(r);
    h.__pictorialAnimationIndex = c, h.__pictorialRepeatTimes = u, i.add(h);
    var f = p(c);
    Ih(h, {
      x: f.x,
      y: f.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: f.scaleX,
      scaleY: f.scaleY,
      rotation: f.rotation
    }, r, n);
  }
  function p(g) {
    var v = s.slice(), m = r.pxSign, y = g;
    return (r.symbolRepeatDirection === "start" ? m > 0 : m < 0) && (y = u - 1 - g), v[l.index] = d * (y - u / 2 + 0.5) + s[l.index], {
      x: v[0],
      y: v[1],
      scaleX: r.symbolScale[0],
      scaleY: r.symbolScale[1],
      rotation: r.rotation
    };
  }
}
function mK(e, t, r, n) {
  var i = e.__pictorialBundle, o = e.__pictorialMainPath;
  o ? Ih(o, null, {
    x: r.pathPosition[0],
    y: r.pathPosition[1],
    scaleX: r.symbolScale[0],
    scaleY: r.symbolScale[1],
    rotation: r.rotation
  }, r, n) : (o = e.__pictorialMainPath = gK(r), i.add(o), Ih(o, {
    x: r.pathPosition[0],
    y: r.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: r.rotation
  }, {
    scaleX: r.symbolScale[0],
    scaleY: r.symbolScale[1]
  }, r, n));
}
function yK(e, t, r) {
  var n = ge({}, t.barRectShape), i = e.__pictorialBarRect;
  i ? Ih(i, null, {
    shape: n
  }, t, r) : (i = e.__pictorialBarRect = new or({
    z2: 2,
    shape: n,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), i.disableMorphing = !0, e.add(i));
}
function CK(e, t, r, n) {
  if (r.symbolClip) {
    var i = e.__pictorialClipPath, o = ge({}, r.clipShape), a = t.valueDim, s = r.animationModel, l = r.dataIndex;
    if (i)
      ur(i, {
        shape: o
      }, s, l);
    else {
      o[a.wh] = 0, i = new or({
        shape: o
      }), e.__pictorialBundle.setClipPath(i), e.__pictorialClipPath = i;
      var u = {};
      u[a.wh] = r.clipShape[a.wh], od[n ? "updateProps" : "initProps"](i, {
        shape: u
      }, s, l);
    }
  }
}
function y4(e, t) {
  var r = e.getItemModel(t);
  return r.getAnimationDelayParams = JIe, r.isAnimationEnabled = e2e, r;
}
function JIe(e) {
  return {
    index: e.__pictorialAnimationIndex,
    count: e.__pictorialRepeatTimes
  };
}
function e2e() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function C4(e, t, r, n) {
  var i = new Ct(), o = new Ct();
  return i.add(o), i.__pictorialBundle = o, o.x = r.bundlePosition[0], o.y = r.bundlePosition[1], r.symbolRepeat ? vK(i, t, r) : mK(i, t, r), yK(i, r, n), CK(i, t, r, n), i.__pictorialShapeStr = SK(e, r), i.__pictorialSymbolMeta = r, i;
}
function t2e(e, t, r) {
  var n = r.animationModel, i = r.dataIndex, o = e.__pictorialBundle;
  ur(o, {
    x: r.bundlePosition[0],
    y: r.bundlePosition[1]
  }, n, i), r.symbolRepeat ? vK(e, t, r, !0) : mK(e, t, r, !0), yK(e, r, !0), CK(e, t, r, !0);
}
function S4(e, t, r, n) {
  var i = n.__pictorialBarRect;
  i && i.removeTextContent();
  var o = [];
  RA(n, function(a) {
    o.push(a);
  }), n.__pictorialMainPath && o.push(n.__pictorialMainPath), n.__pictorialClipPath && (r = null), $(o, function(a) {
    au(a, {
      scaleX: 0,
      scaleY: 0
    }, r, t, function() {
      n.parent && n.parent.remove(n);
    });
  }), e.setItemGraphicEl(t, null);
}
function SK(e, t) {
  return [e.getItemVisual(t.dataIndex, "symbol") || "none", !!t.symbolRepeat, !!t.symbolClip].join(":");
}
function RA(e, t, r) {
  $(e.__pictorialBundle.children(), function(n) {
    n !== e.__pictorialBarRect && t.call(r, n);
  });
}
function Ih(e, t, r, n, i, o) {
  t && e.attr(t), n.symbolClip && !i ? r && e.attr(r) : r && od[i ? "updateProps" : "initProps"](e, r, n.animationModel, n.dataIndex, o);
}
function w4(e, t, r) {
  var n = r.dataIndex, i = r.itemModel, o = i.getModel("emphasis"), a = o.getModel("itemStyle").getItemStyle(), s = i.getModel(["blur", "itemStyle"]).getItemStyle(), l = i.getModel(["select", "itemStyle"]).getItemStyle(), u = i.getShallow("cursor"), c = o.get("focus"), d = o.get("blurScope"), h = o.get("scale");
  RA(e, function(g) {
    if (g instanceof qn) {
      var v = g.style;
      g.useStyle(ge({
        // TODO other properties like dx, dy ?
        image: v.image,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      }, r.style));
    } else
      g.useStyle(r.style);
    var m = g.ensureState("emphasis");
    m.style = a, h && (m.scaleX = g.scaleX * 1.1, m.scaleY = g.scaleY * 1.1), g.ensureState("blur").style = s, g.ensureState("select").style = l, u && (g.cursor = u), g.z2 = r.z2;
  });
  var f = t.valueDim.posDesc[+(r.boundingLength > 0)], p = e.__pictorialBarRect;
  p.ignoreClip = !0, ri(p, $n(i), {
    labelFetcher: t.seriesModel,
    labelDataIndex: n,
    defaultText: qh(t.seriesModel.getData(), n),
    inheritColor: r.style.fill,
    defaultOpacity: r.style.opacity,
    defaultOutsidePosition: f
  }), sn(e, c, d, o.get("disabled"));
}
function b4(e) {
  var t = Math.round(e);
  return Math.abs(e - t) < 1e-4 ? t : Math.ceil(e);
}
var r2e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r.defaultSymbol = "roundRect", r;
    }
    return t.prototype.getInitialData = function(r) {
      return r.stack = null, e.prototype.getInitialData.apply(this, arguments);
    }, t.type = "series.pictorialBar", t.dependencies = ["grid"], t.defaultOption = wu(rv.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // Pictorial bar do not clip by default because in many cases
      // xAxis and yAxis are not displayed and it's expected not to clip
      clip: !1,
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), t;
  }(rv)
);
function n2e(e) {
  e.registerChartView(YIe), e.registerSeriesModel(r2e), e.registerLayout(e.PRIORITY.VISUAL.LAYOUT, _t(rj, "pictorialBar")), e.registerLayout(e.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, nj("pictorialBar"));
}
var i2e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._layers = [], r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this, s = this.group, l = r.getLayerSeries(), u = o.getLayout("layoutInfo"), c = u.rect, d = u.boundaryGap;
      s.x = 0, s.y = c.y + d[0];
      function h(v) {
        return v.name;
      }
      var f = new el(this._layersSeries || [], l, h, h), p = [];
      f.add(je(g, this, "add")).update(je(g, this, "update")).remove(je(g, this, "remove")).execute();
      function g(v, m, y) {
        var C = a._layers;
        if (v === "remove") {
          s.remove(C[m]);
          return;
        }
        for (var S = [], b = [], w, x = l[m].indices, R = 0; R < x.length; R++) {
          var _ = o.getItemLayout(x[R]), T = _.x, P = _.y0, D = _.y;
          S.push(T, P), b.push(T, P + D), w = o.getItemVisual(x[R], "style");
        }
        var O, A = o.getItemLayout(x[0]), F = r.getModel("label"), L = F.get("margin"), N = r.getModel("emphasis");
        if (v === "add") {
          var I = p[m] = new Ct();
          O = new jj({
            shape: {
              points: S,
              stackedOnPoints: b,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), I.add(O), s.add(I), r.isAnimationEnabled() && O.setClipPath(o2e(O.getBoundingRect(), r, function() {
            O.removeClipPath();
          }));
        } else {
          var I = C[y];
          O = I.childAt(0), s.add(I), p[m] = I, ur(O, {
            shape: {
              points: S,
              stackedOnPoints: b
            }
          }, r), Fa(O);
        }
        ri(O, $n(r), {
          labelDataIndex: x[R - 1],
          defaultText: o.getName(x[R - 1]),
          inheritColor: w.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), O.setTextConfig({
          position: null,
          local: !0
        });
        var B = O.getTextContent();
        B && (B.x = A.x - L, B.y = A.y0 + A.y / 2), O.useStyle(w), o.setItemGraphicEl(m, O), ti(O, r), sn(O, N.get("focus"), N.get("blurScope"), N.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, t.type = "themeRiver", t;
  }(br)
);
function o2e(e, t, r) {
  var n = new or({
    shape: {
      x: e.x - 10,
      y: e.y - 10,
      width: 0,
      height: e.height + 20
    }
  });
  return jr(n, {
    shape: {
      x: e.x - 50,
      width: e.width + 100,
      height: e.height + 20
    }
  }, t, r), n;
}
var Wx = 2, a2e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments), this.legendVisualProvider = new Xv(je(this.getData, this), je(this.getRawData, this));
    }, t.prototype.fixData = function(r) {
      var n = r.length, i = {}, o = A_(r, function(h) {
        return i.hasOwnProperty(h[0] + "") || (i[h[0] + ""] = -1), h[2];
      }), a = [];
      o.buckets.each(function(h, f) {
        a.push({
          name: f,
          dataList: h
        });
      });
      for (var s = a.length, l = 0; l < s; ++l) {
        for (var u = a[l].name, c = 0; c < a[l].dataList.length; ++c) {
          var d = a[l].dataList[c][0] + "";
          i[d] = l;
        }
        for (var d in i)
          i.hasOwnProperty(d) && i[d] !== l && (i[d] = l, r[n] = [d, 0, u], n++);
      }
      return r;
    }, t.prototype.getInitialData = function(r, n) {
      for (var i = this.getReferringComponents("singleAxis", bn).models[0], o = i.get("type"), a = Sr(r.data, function(p) {
        return p[2] !== void 0;
      }), s = this.fixData(a || []), l = [], u = this.nameMap = nt(), c = 0, d = 0; d < s.length; ++d)
        l.push(s[d][Wx]), u.get(s[d][Wx]) || (u.set(s[d][Wx], c), c++);
      var h = Tf(s, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: _C(o)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, f = new di(h, this);
      return f.initData(s), f;
    }, t.prototype.getLayerSeries = function() {
      for (var r = this.getData(), n = r.count(), i = [], o = 0; o < n; ++o)
        i[o] = o;
      var a = r.mapDimension("single"), s = A_(i, function(u) {
        return r.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, c) {
        u.sort(function(d, h) {
          return r.get(a, d) - r.get(a, h);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, t.prototype.getAxisTooltipData = function(r, n, i) {
      be(r) || (r = r ? [r] : []);
      for (var o = this.getData(), a = this.getLayerSeries(), s = [], l = a.length, u, c = 0; c < l; ++c) {
        for (var d = Number.MAX_VALUE, h = -1, f = a[c].indices.length, p = 0; p < f; ++p) {
          var g = o.get(r[0], a[c].indices[p]), v = Math.abs(g - n);
          v <= d && (u = g, d = v, h = a[c].indices[p]);
        }
        s.push(h);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = o.getName(r), s = o.get(o.mapDimension("value"), r);
      return Hn("nameValue", {
        name: a,
        value: s
      });
    }, t.type = "series.themeRiver", t.dependencies = ["singleAxis"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, t;
  }(Pr)
);
function s2e(e, t) {
  e.eachSeriesByType("themeRiver", function(r) {
    var n = r.getData(), i = r.coordinateSystem, o = {}, a = i.getRect();
    o.rect = a;
    var s = r.get("boundaryGap"), l = i.getAxis();
    if (o.boundaryGap = s, l.orient === "horizontal") {
      s[0] = Be(s[0], a.height), s[1] = Be(s[1], a.height);
      var u = a.height - s[0] - s[1];
      x4(n, r, u);
    } else {
      s[0] = Be(s[0], a.width), s[1] = Be(s[1], a.width);
      var c = a.width - s[0] - s[1];
      x4(n, r, c);
    }
    n.setLayout("layoutInfo", o);
  });
}
function x4(e, t, r) {
  if (e.count())
    for (var n = t.coordinateSystem, i = t.getLayerSeries(), o = e.mapDimension("single"), a = e.mapDimension("value"), s = Ee(i, function(v) {
      return Ee(v.indices, function(m) {
        var y = n.dataToPoint(e.get(o, m));
        return y[1] = e.get(a, m), y;
      });
    }), l = l2e(s), u = l.y0, c = r / l.max, d = i.length, h = i[0].indices.length, f, p = 0; p < h; ++p) {
      f = u[p] * c, e.setItemLayout(i[0].indices[p], {
        layerIndex: 0,
        x: s[0][p][0],
        y0: f,
        y: s[0][p][1] * c
      });
      for (var g = 1; g < d; ++g)
        f += s[g - 1][p][1] * c, e.setItemLayout(i[g].indices[p], {
          layerIndex: g,
          x: s[g][p][0],
          y0: f,
          y: s[g][p][1] * c
        });
    }
}
function l2e(e) {
  for (var t = e.length, r = e[0].length, n = [], i = [], o = 0, a = 0; a < r; ++a) {
    for (var s = 0, l = 0; l < t; ++l)
      s += e[l][a][1];
    s > o && (o = s), n.push(s);
  }
  for (var u = 0; u < r; ++u)
    i[u] = (o - n[u]) / 2;
  o = 0;
  for (var c = 0; c < r; ++c) {
    var d = n[c] + i[c];
    d > o && (o = d);
  }
  return {
    y0: i,
    max: o
  };
}
function u2e(e) {
  e.registerChartView(i2e), e.registerSeriesModel(a2e), e.registerLayout(s2e), e.registerProcessor(qv("themeRiver"));
}
var c2e = 2, d2e = 4, E4 = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i, o) {
      var a = e.call(this) || this;
      a.z2 = c2e, a.textConfig = {
        inside: !0
      }, St(a).seriesIndex = n.seriesIndex;
      var s = new ir({
        z2: d2e,
        silent: r.getModel().get(["label", "silent"])
      });
      return a.setTextContent(s), a.updateData(!0, r, n, i, o), a;
    }
    return t.prototype.updateData = function(r, n, i, o, a) {
      this.node = n, n.piece = this, i = i || this._seriesModel, o = o || this._ecModel;
      var s = this;
      St(s).dataIndex = n.dataIndex;
      var l = n.getModel(), u = l.getModel("emphasis"), c = n.getLayout(), d = ge({}, c);
      d.label = null;
      var h = n.getVisual("style");
      h.lineJoin = "bevel";
      var f = n.getVisual("decal");
      f && (h.decal = Yh(f, a));
      var p = bc(l.getModel("itemStyle"), d, !0);
      ge(d, p), $(Ii, function(y) {
        var C = s.ensureState(y), S = l.getModel([y, "itemStyle"]);
        C.style = S.getItemStyle();
        var b = bc(S, d);
        b && (C.shape = b);
      }), r ? (s.setShape(d), s.shape.r = c.r0, jr(s, {
        shape: {
          r: c.r
        }
      }, i, n.dataIndex)) : (ur(s, {
        shape: d
      }, i), Fa(s)), s.useStyle(h), this._updateLabel(i);
      var g = l.getShallow("cursor");
      g && s.attr("cursor", g), this._seriesModel = i || this._seriesModel, this._ecModel = o || this._ecModel;
      var v = u.get("focus"), m = v === "ancestor" ? n.getAncestorsIndices() : v === "descendant" ? n.getDescendantIndices() : v;
      sn(this, m, u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(r) {
      var n = this, i = this.node.getModel(), o = i.getModel("label"), a = this.node.getLayout(), s = a.endAngle - a.startAngle, l = (a.startAngle + a.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), d = this, h = d.getTextContent(), f = this.node.dataIndex, p = o.get("minAngle") / 180 * Math.PI, g = o.get("show") && !(p != null && Math.abs(s) < p);
      h.ignore = !g, $(jg, function(m) {
        var y = m === "normal" ? i.getModel("label") : i.getModel([m, "label"]), C = m === "normal", S = C ? h : h.ensureState(m), b = r.getFormattedLabel(f, m);
        C && (b = b || n.node.name), S.style = Vr(y, {}, null, m !== "normal", !0), b && (S.style.text = b);
        var w = y.get("show");
        w != null && !C && (S.ignore = !w);
        var x = v(y, "position"), R = C ? d : d.states[m], _ = R.style.fill;
        R.textConfig = {
          outsideFill: y.get("color") === "inherit" ? _ : null,
          inside: x !== "outside"
        };
        var T, P = v(y, "distance") || 0, D = v(y, "align"), O = v(y, "rotate"), A = Math.PI * 0.5, F = Math.PI * 1.5, L = mo(O === "tangential" ? Math.PI / 2 - l : l), N = L > A && !zh(L - A) && L < F;
        x === "outside" ? (T = a.r + P, D = N ? "right" : "left") : !D || D === "center" ? (s === 2 * Math.PI && a.r0 === 0 ? T = 0 : T = (a.r + a.r0) / 2, D = "center") : D === "left" ? (T = a.r0 + P, D = N ? "right" : "left") : D === "right" && (T = a.r - P, D = N ? "left" : "right"), S.style.align = D, S.style.verticalAlign = v(y, "verticalAlign") || "middle", S.x = T * u + a.cx, S.y = T * c + a.cy;
        var I = 0;
        O === "radial" ? I = mo(-l) + (N ? Math.PI : 0) : O === "tangential" ? I = mo(Math.PI / 2 - l) + (N ? Math.PI : 0) : sr(O) && (I = O * Math.PI / 180), S.rotation = mo(I);
      });
      function v(m, y) {
        var C = m.get(y);
        return C ?? o.get(y);
      }
      h.dirtyStyle();
    }, t;
  }(Oi)
), IT = "sunburstRootToNode", R4 = "sunburstHighlight", h2e = "sunburstUnhighlight";
function f2e(e) {
  e.registerAction({
    type: IT,
    update: "updateView"
  }, function(t, r) {
    r.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: t
    }, n);
    function n(i, o) {
      var a = iv(t, [IT], i);
      if (a) {
        var s = i.getViewRoot();
        s && (t.direction = dA(s, a.node) ? "rollUp" : "drillDown"), i.resetViewRoot(a.node);
      }
    }
  }), e.registerAction({
    type: R4,
    update: "none"
  }, function(t, r, n) {
    t = ge({}, t), r.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: t
    }, i);
    function i(o) {
      var a = iv(t, [R4], o);
      a && (t.dataIndex = a.node.dataIndex);
    }
    process.env.NODE_ENV !== "production" && pn("sunburstHighlight", "highlight"), n.dispatchAction(ge(t, {
      type: "highlight"
    }));
  }), e.registerAction({
    type: h2e,
    update: "updateView"
  }, function(t, r, n) {
    t = ge({}, t), process.env.NODE_ENV !== "production" && pn("sunburstUnhighlight", "downplay"), n.dispatchAction(ge(t, {
      type: "downplay"
    }));
  });
}
var p2e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = this;
      this.seriesModel = r, this.api = i, this.ecModel = n;
      var s = r.getData(), l = s.tree.root, u = r.getViewRoot(), c = this.group, d = r.get("renderLabelForZeroData"), h = [];
      u.eachNode(function(y) {
        h.push(y);
      });
      var f = this._oldChildren || [];
      p(h, f), m(l, u), this._initEvents(), this._oldChildren = h;
      function p(y, C) {
        if (y.length === 0 && C.length === 0)
          return;
        new el(C, y, S, S).add(b).update(b).remove(_t(b, null)).execute();
        function S(w) {
          return w.getId();
        }
        function b(w, x) {
          var R = w == null ? null : y[w], _ = x == null ? null : C[x];
          g(R, _);
        }
      }
      function g(y, C) {
        if (!d && y && !y.getValue() && (y = null), y !== l && C !== l) {
          if (C && C.piece)
            y ? (C.piece.updateData(!1, y, r, n, i), s.setItemGraphicEl(y.dataIndex, C.piece)) : v(C);
          else if (y) {
            var S = new E4(y, r, n, i);
            c.add(S), s.setItemGraphicEl(y.dataIndex, S);
          }
        }
      }
      function v(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function m(y, C) {
        C.depth > 0 ? (a.virtualPiece ? a.virtualPiece.updateData(!1, y, r, n, i) : (a.virtualPiece = new E4(y, r, n, i), c.add(a.virtualPiece)), C.piece.off("click"), a.virtualPiece.on("click", function(S) {
          a._rootToNode(C.parentNode);
        })) : a.virtualPiece && (c.remove(a.virtualPiece), a.virtualPiece = null);
      }
    }, t.prototype._initEvents = function() {
      var r = this;
      this.group.off("click"), this.group.on("click", function(n) {
        var i = !1, o = r.seriesModel.getViewRoot();
        o.eachNode(function(a) {
          if (!i && a.piece && a.piece === n.target) {
            var s = a.getModel().get("nodeClick");
            if (s === "rootToNode")
              r._rootToNode(a);
            else if (s === "link") {
              var l = a.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", !0) || "_blank";
                pC(u, c);
              }
            }
            i = !0;
          }
        });
      });
    }, t.prototype._rootToNode = function(r) {
      r !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: IT,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: r
      });
    }, t.prototype.containPoint = function(r, n) {
      var i = n.getData(), o = i.getItemLayout(0);
      if (o) {
        var a = r[0] - o.cx, s = r[1] - o.cy, l = Math.sqrt(a * a + s * s);
        return l <= o.r && l >= o.r0;
      }
    }, t.type = "sunburst", t;
  }(br)
), g2e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.ignoreStyleOnData = !0, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      var i = {
        name: r.name,
        children: r.data
      };
      wK(i);
      var o = this._levelModels = Ee(r.levels || [], function(l) {
        return new _r(l, this, n);
      }, this), a = cA.createTree(i, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var d = a.getNodeByDataIndex(c), h = o[d.depth];
          return h && (u.parentModel = h), u;
        });
      }
      return a.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.getDataParams = function(r) {
      var n = e.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(r);
      return n.treePathInfo = Mw(i, this), n;
    }, t.prototype.getLevelModel = function(r) {
      return this._levelModels && this._levelModels[r.depth];
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(r) {
      r ? this._viewRoot = r : r = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!r || r !== n && !n.contains(r)) && (this._viewRoot = n);
    }, t.prototype.enableAriaDecal = function() {
      _U(this);
    }, t.type = "series.sunburst", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 
      clockwise: !0,
      startAngle: 90,
      // 0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, t;
  }(Pr)
);
function wK(e) {
  var t = 0;
  $(e.children, function(n) {
    wK(n);
    var i = n.value;
    be(i) && (i = i[0]), t += i;
  });
  var r = e.value;
  be(r) && (r = r[0]), (r == null || isNaN(r)) && (r = t), r < 0 && (r = 0), be(e.value) ? e.value[0] = r : e.value = r;
}
var _4 = Math.PI / 180;
function v2e(e, t, r) {
  t.eachSeriesByType(e, function(n) {
    var i = n.get("center"), o = n.get("radius");
    be(o) || (o = [0, o]), be(i) || (i = [i, i]);
    var a = r.getWidth(), s = r.getHeight(), l = Math.min(a, s), u = Be(i[0], a), c = Be(i[1], s), d = Be(o[0], l / 2), h = Be(o[1], l / 2), f = -n.get("startAngle") * _4, p = n.get("minAngle") * _4, g = n.getData().tree.root, v = n.getViewRoot(), m = v.depth, y = n.get("sort");
    y != null && bK(v, y);
    var C = 0;
    $(v.children, function(L) {
      !isNaN(L.getValue()) && C++;
    });
    var S = v.getValue(), b = Math.PI / (S || C) * 2, w = v.depth > 0, x = v.height - (w ? -1 : 1), R = (h - d) / (x || 1), _ = n.get("clockwise"), T = n.get("stillShowZeroSum"), P = _ ? 1 : -1, D = function(L, N) {
      if (L) {
        var I = N;
        if (L !== g) {
          var B = L.getValue(), M = S === 0 && T ? b : B * b;
          M < p && (M = p), I = N + P * M;
          var V = L.depth - m - (w ? -1 : 1), G = d + R * V, k = d + R * (V + 1), z = n.getLevelModel(L);
          if (z) {
            var j = z.get("r0", !0), q = z.get("r", !0), K = z.get("radius", !0);
            K != null && (j = K[0], q = K[1]), j != null && (G = Be(j, l / 2)), q != null && (k = Be(q, l / 2));
          }
          L.setLayout({
            angle: M,
            startAngle: N,
            endAngle: I,
            clockwise: _,
            cx: u,
            cy: c,
            r0: G,
            r: k
          });
        }
        if (L.children && L.children.length) {
          var Z = 0;
          $(L.children, function(re) {
            Z += D(re, N + Z);
          });
        }
        return I - N;
      }
    };
    if (w) {
      var O = d, A = d + R, F = Math.PI * 2;
      g.setLayout({
        angle: F,
        startAngle: f,
        endAngle: f + F,
        clockwise: _,
        cx: u,
        cy: c,
        r0: O,
        r: A
      });
    }
    D(v, f);
  });
}
function bK(e, t) {
  var r = e.children || [];
  e.children = m2e(r, t), r.length && $(e.children, function(n) {
    bK(n, t);
  });
}
function m2e(e, t) {
  if (at(t)) {
    var r = Ee(e, function(i, o) {
      var a = i.getValue();
      return {
        params: {
          depth: i.depth,
          height: i.height,
          dataIndex: i.dataIndex,
          getValue: function() {
            return a;
          }
        },
        index: o
      };
    });
    return r.sort(function(i, o) {
      return t(i.params, o.params);
    }), Ee(r, function(i) {
      return e[i.index];
    });
  } else {
    var n = t === "asc";
    return e.sort(function(i, o) {
      var a = (i.getValue() - o.getValue()) * (n ? 1 : -1);
      return a === 0 ? (i.dataIndex - o.dataIndex) * (n ? -1 : 1) : a;
    });
  }
}
function y2e(e) {
  var t = {};
  function r(n, i, o) {
    for (var a = n; a && a.depth > 1; )
      a = a.parentNode;
    var s = i.getColorFromPalette(a.name || a.dataIndex + "", t);
    return n.depth > 1 && He(s) && (s = tC(s, (n.depth - 1) / (o - 1) * 0.5)), s;
  }
  e.eachSeriesByType("sunburst", function(n) {
    var i = n.getData(), o = i.tree;
    o.eachNode(function(a) {
      var s = a.getModel(), l = s.getModel("itemStyle").getItemStyle();
      l.fill || (l.fill = r(a, n, o.root.height));
      var u = i.ensureUniqueItemVisual(a.dataIndex, "style");
      ge(u, l);
    });
  });
}
function C2e(e) {
  e.registerChartView(p2e), e.registerSeriesModel(g2e), e.registerLayout(_t(v2e, "sunburst")), e.registerProcessor(_t(qv, "sunburst")), e.registerVisual(y2e), f2e(e);
}
var T4 = {
  color: "fill",
  borderColor: "stroke"
}, S2e = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, Ws = ar(), w2e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, t.prototype.getInitialData = function(r, n) {
      return ws(null, this);
    }, t.prototype.getDataParams = function(r, n, i) {
      var o = e.prototype.getDataParams.call(this, r, n);
      return i && (o.info = Ws(i).info), o;
    }, t.type = "series.custom", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, t;
  }(Pr)
);
function b2e(e, t) {
  return t = t || [0, 0], Ee(["x", "y"], function(r, n) {
    var i = this.getAxis(r), o = t[n], a = e[n] / 2;
    return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(o - a) - i.dataToCoord(o + a));
  }, this);
}
function x2e(e) {
  var t = e.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(r) {
        return e.dataToPoint(r);
      },
      size: je(b2e, e)
    }
  };
}
function E2e(e, t) {
  return t = t || [0, 0], Ee([0, 1], function(r) {
    var n = t[r], i = e[r] / 2, o = [], a = [];
    return o[r] = n - i, a[r] = n + i, o[1 - r] = a[1 - r] = t[1 - r], Math.abs(this.dataToPoint(o)[r] - this.dataToPoint(a)[r]);
  }, this);
}
function R2e(e) {
  var t = e.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      zoom: e.getZoom()
    },
    api: {
      coord: function(r) {
        return e.dataToPoint(r);
      },
      size: je(E2e, e)
    }
  };
}
function _2e(e, t) {
  var r = this.getAxis(), n = t instanceof Array ? t[0] : t, i = (e instanceof Array ? e[0] : e) / 2;
  return r.type === "category" ? r.getBandWidth() : Math.abs(r.dataToCoord(n - i) - r.dataToCoord(n + i));
}
function T2e(e) {
  var t = e.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(r) {
        return e.dataToPoint(r);
      },
      size: je(_2e, e)
    }
  };
}
function P2e(e, t) {
  return t = t || [0, 0], Ee(["Radius", "Angle"], function(r, n) {
    var i = "get" + r + "Axis", o = this[i](), a = t[n], s = e[n] / 2, l = o.type === "category" ? o.getBandWidth() : Math.abs(o.dataToCoord(a - s) - o.dataToCoord(a + s));
    return r === "Angle" && (l = l * Math.PI / 180), l;
  }, this);
}
function M2e(e) {
  var t = e.getRadiusAxis(), r = e.getAngleAxis(), n = t.getExtent();
  return n[0] > n[1] && n.reverse(), {
    coordSys: {
      type: "polar",
      cx: e.cx,
      cy: e.cy,
      r: n[1],
      r0: n[0]
    },
    api: {
      coord: function(i) {
        var o = t.dataToRadius(i[0]), a = r.dataToAngle(i[1]), s = e.coordToPoint([o, a]);
        return s.push(o, a * Math.PI / 180), s;
      },
      size: je(P2e, e)
    }
  };
}
function D2e(e) {
  var t = e.getRect(), r = e.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      cellWidth: e.getCellWidth(),
      cellHeight: e.getCellHeight(),
      rangeInfo: {
        start: r.start,
        end: r.end,
        weeks: r.weeks,
        dayCount: r.allDay
      }
    },
    api: {
      coord: function(n, i) {
        return e.dataToPoint(n, i);
      }
    }
  };
}
var P4 = {};
function xK(e, t, r, n) {
  return e && (e.legacy || e.legacy !== !1 && !r && !n && t !== "tspan" && (t === "text" || Ye(e, "text")));
}
function EK(e, t, r) {
  var n = e, i, o, a;
  if (t === "text")
    a = n;
  else {
    a = {}, Ye(n, "text") && (a.text = n.text), Ye(n, "rich") && (a.rich = n.rich), Ye(n, "textFill") && (a.fill = n.textFill), Ye(n, "textStroke") && (a.stroke = n.textStroke), Ye(n, "fontFamily") && (a.fontFamily = n.fontFamily), Ye(n, "fontSize") && (a.fontSize = n.fontSize), Ye(n, "fontStyle") && (a.fontStyle = n.fontStyle), Ye(n, "fontWeight") && (a.fontWeight = n.fontWeight), o = {
      type: "text",
      style: a,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, i = {};
    var s = Ye(n, "textPosition");
    r ? i.position = s ? n.textPosition : "inside" : s && (i.position = n.textPosition), Ye(n, "textPosition") && (i.position = n.textPosition), Ye(n, "textOffset") && (i.offset = n.textOffset), Ye(n, "textRotation") && (i.rotation = n.textRotation), Ye(n, "textDistance") && (i.distance = n.textDistance);
  }
  return M4(a, e), $(a.rich, function(l) {
    M4(l, l);
  }), {
    textConfig: i,
    textContent: o
  };
}
function M4(e, t) {
  t && (t.font = t.textFont || t.font, Ye(t, "textStrokeWidth") && (e.lineWidth = t.textStrokeWidth), Ye(t, "textAlign") && (e.align = t.textAlign), Ye(t, "textVerticalAlign") && (e.verticalAlign = t.textVerticalAlign), Ye(t, "textLineHeight") && (e.lineHeight = t.textLineHeight), Ye(t, "textWidth") && (e.width = t.textWidth), Ye(t, "textHeight") && (e.height = t.textHeight), Ye(t, "textBackgroundColor") && (e.backgroundColor = t.textBackgroundColor), Ye(t, "textPadding") && (e.padding = t.textPadding), Ye(t, "textBorderColor") && (e.borderColor = t.textBorderColor), Ye(t, "textBorderWidth") && (e.borderWidth = t.textBorderWidth), Ye(t, "textBorderRadius") && (e.borderRadius = t.textBorderRadius), Ye(t, "textBoxShadowColor") && (e.shadowColor = t.textBoxShadowColor), Ye(t, "textBoxShadowBlur") && (e.shadowBlur = t.textBoxShadowBlur), Ye(t, "textBoxShadowOffsetX") && (e.shadowOffsetX = t.textBoxShadowOffsetX), Ye(t, "textBoxShadowOffsetY") && (e.shadowOffsetY = t.textBoxShadowOffsetY));
}
function D4(e, t, r) {
  var n = e;
  n.textPosition = n.textPosition || r.position || "inside", r.offset != null && (n.textOffset = r.offset), r.rotation != null && (n.textRotation = r.rotation), r.distance != null && (n.textDistance = r.distance);
  var i = n.textPosition.indexOf("inside") >= 0, o = e.fill || "#000";
  A4(n, t);
  var a = n.textFill == null;
  return i ? a && (n.textFill = r.insideFill || "#fff", !n.textStroke && r.insideStroke && (n.textStroke = r.insideStroke), !n.textStroke && (n.textStroke = o), n.textStrokeWidth == null && (n.textStrokeWidth = 2)) : (a && (n.textFill = e.fill || r.outsideFill || "#000"), !n.textStroke && r.outsideStroke && (n.textStroke = r.outsideStroke)), n.text = t.text, n.rich = t.rich, $(t.rich, function(s) {
    A4(s, s);
  }), n;
}
function A4(e, t) {
  t && (Ye(t, "fill") && (e.textFill = t.fill), Ye(t, "stroke") && (e.textStroke = t.fill), Ye(t, "lineWidth") && (e.textStrokeWidth = t.lineWidth), Ye(t, "font") && (e.font = t.font), Ye(t, "fontStyle") && (e.fontStyle = t.fontStyle), Ye(t, "fontWeight") && (e.fontWeight = t.fontWeight), Ye(t, "fontSize") && (e.fontSize = t.fontSize), Ye(t, "fontFamily") && (e.fontFamily = t.fontFamily), Ye(t, "align") && (e.textAlign = t.align), Ye(t, "verticalAlign") && (e.textVerticalAlign = t.verticalAlign), Ye(t, "lineHeight") && (e.textLineHeight = t.lineHeight), Ye(t, "width") && (e.textWidth = t.width), Ye(t, "height") && (e.textHeight = t.height), Ye(t, "backgroundColor") && (e.textBackgroundColor = t.backgroundColor), Ye(t, "padding") && (e.textPadding = t.padding), Ye(t, "borderColor") && (e.textBorderColor = t.borderColor), Ye(t, "borderWidth") && (e.textBorderWidth = t.borderWidth), Ye(t, "borderRadius") && (e.textBorderRadius = t.borderRadius), Ye(t, "shadowColor") && (e.textBoxShadowColor = t.shadowColor), Ye(t, "shadowBlur") && (e.textBoxShadowBlur = t.shadowBlur), Ye(t, "shadowOffsetX") && (e.textBoxShadowOffsetX = t.shadowOffsetX), Ye(t, "shadowOffsetY") && (e.textBoxShadowOffsetY = t.shadowOffsetY), Ye(t, "textShadowColor") && (e.textShadowColor = t.textShadowColor), Ye(t, "textShadowBlur") && (e.textShadowBlur = t.textShadowBlur), Ye(t, "textShadowOffsetX") && (e.textShadowOffsetX = t.textShadowOffsetX), Ye(t, "textShadowOffsetY") && (e.textShadowOffsetY = t.textShadowOffsetY));
}
function I4(e, t) {
  if (process.env.NODE_ENV !== "production") {
    var r = e + "^_^" + t;
    P4[r] || (console.warn('[ECharts] DEPRECATED: "' + e + '" has been deprecated. ' + t), P4[r] = !0);
  }
}
var RK = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, O4 = jt(RK), VC = Jo(gs, function(e, t) {
  return e[t] = 1, e;
}, {}), L4 = gs.join(", "), BC = ["", "style", "shape", "extra"], Qh = ar();
function _A(e, t, r, n, i) {
  var o = e + "Animation", a = mf(e, n, i) || {}, s = Qh(t).userDuring;
  return a.duration > 0 && (a.during = s ? je(F2e, {
    el: t,
    userDuring: s
  }) : null, a.setToFinal = !0, a.scope = e), ge(a, r[o]), a;
}
function v0(e, t, r, n) {
  n = n || {};
  var i = n.dataIndex, o = n.isInit, a = n.clearStyle, s = r.isAnimationEnabled(), l = Qh(e), u = t.style;
  l.userDuring = t.during;
  var c = {}, d = {};
  if (k2e(e, t, d), N4("shape", t, d), N4("extra", t, d), !o && s && (N2e(e, t, c), F4("shape", e, t, c), F4("extra", e, t, c), V2e(e, t, u, c)), d.style = u, A2e(e, d, a), O2e(e, t), s)
    if (o) {
      var h = {};
      $(BC, function(p) {
        var g = p ? t[p] : t;
        g && g.enterFrom && (p && (h[p] = h[p] || {}), ge(p ? h[p] : h, g.enterFrom));
      });
      var f = _A("enter", e, t, r, i);
      f.duration > 0 && e.animateFrom(h, f);
    } else
      I2e(e, t, i || 0, r, c);
  _K(e, t), u ? e.dirty() : e.markRedraw();
}
function _K(e, t) {
  for (var r = Qh(e).leaveToProps, n = 0; n < BC.length; n++) {
    var i = BC[n], o = i ? t[i] : t;
    o && o.leaveTo && (r || (r = Qh(e).leaveToProps = {}), i && (r[i] = r[i] || {}), ge(i ? r[i] : r, o.leaveTo));
  }
}
function Iw(e, t, r, n) {
  if (e) {
    var i = e.parent, o = Qh(e).leaveToProps;
    if (o) {
      var a = _A("update", e, t, r, 0);
      a.done = function() {
        i.remove(e);
      }, e.animateTo(o, a);
    } else
      i.remove(e);
  }
}
function Ic(e) {
  return e === "all";
}
function A2e(e, t, r) {
  var n = t.style;
  if (!e.isGroup && n) {
    if (r) {
      e.useStyle({});
      for (var i = e.animators, o = 0; o < i.length; o++) {
        var a = i[o];
        a.targetName === "style" && a.changeTarget(e.style);
      }
    }
    e.setStyle(n);
  }
  t && (t.style = null, t && e.attr(t), t.style = n);
}
function I2e(e, t, r, n, i) {
  if (i) {
    var o = _A("update", e, t, n, r);
    o.duration > 0 && e.animateFrom(i, o);
  }
}
function O2e(e, t) {
  Ye(t, "silent") && (e.silent = t.silent), Ye(t, "ignore") && (e.ignore = t.ignore), e instanceof ta && Ye(t, "invisible") && (e.invisible = t.invisible), e instanceof Ht && Ye(t, "autoBatch") && (e.autoBatch = t.autoBatch);
}
var qa = {}, L2e = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(e, t) {
    return process.env.NODE_ENV !== "production" && ct(Ye(VC, e), "Only " + L4 + " available in `setTransform`."), qa.el[e] = t, this;
  },
  getTransform: function(e) {
    return process.env.NODE_ENV !== "production" && ct(Ye(VC, e), "Only " + L4 + " available in `getTransform`."), qa.el[e];
  },
  setShape: function(e, t) {
    process.env.NODE_ENV !== "production" && Yd(e);
    var r = qa.el, n = r.shape || (r.shape = {});
    return n[e] = t, r.dirtyShape && r.dirtyShape(), this;
  },
  getShape: function(e) {
    process.env.NODE_ENV !== "production" && Yd(e);
    var t = qa.el.shape;
    if (t)
      return t[e];
  },
  setStyle: function(e, t) {
    process.env.NODE_ENV !== "production" && Yd(e);
    var r = qa.el, n = r.style;
    return n && (process.env.NODE_ENV !== "production" && nu(t) && nn("style." + e + " must not be assigned with NaN."), n[e] = t, r.dirtyStyle && r.dirtyStyle()), this;
  },
  getStyle: function(e) {
    process.env.NODE_ENV !== "production" && Yd(e);
    var t = qa.el.style;
    if (t)
      return t[e];
  },
  setExtra: function(e, t) {
    process.env.NODE_ENV !== "production" && Yd(e);
    var r = qa.el.extra || (qa.el.extra = {});
    return r[e] = t, this;
  },
  getExtra: function(e) {
    process.env.NODE_ENV !== "production" && Yd(e);
    var t = qa.el.extra;
    if (t)
      return t[e];
  }
};
function Yd(e) {
  if (process.env.NODE_ENV !== "production" && (e === "transition" || e === "enterFrom" || e === "leaveTo"))
    throw new Error('key must not be "' + e + '"');
}
function F2e() {
  var e = this, t = e.el;
  if (t) {
    var r = Qh(t).userDuring, n = e.userDuring;
    if (r !== n) {
      e.el = e.userDuring = null;
      return;
    }
    qa.el = t, n(L2e);
  }
}
function F4(e, t, r, n) {
  var i = r[e];
  if (i) {
    var o = t[e], a;
    if (o) {
      var s = r.transition, l = i.transition;
      if (l)
        if (!a && (a = n[e] = {}), Ic(l))
          ge(a, o);
        else
          for (var u = Tr(l), c = 0; c < u.length; c++) {
            var d = u[c], h = o[d];
            a[d] = h;
          }
      else if (Ic(s) || Ft(s, e) >= 0) {
        !a && (a = n[e] = {});
        for (var f = jt(o), c = 0; c < f.length; c++) {
          var d = f[c], h = o[d];
          B2e(i[d], h) && (a[d] = h);
        }
      }
    }
  }
}
function N4(e, t, r) {
  var n = t[e];
  if (n)
    for (var i = r[e] = {}, o = jt(n), a = 0; a < o.length; a++) {
      var s = o[a];
      i[s] = og(n[s]);
    }
}
function N2e(e, t, r) {
  for (var n = t.transition, i = Ic(n) ? gs : Tr(n || []), o = 0; o < i.length; o++) {
    var a = i[o];
    if (!(a === "style" || a === "shape" || a === "extra")) {
      var s = e[a];
      process.env.NODE_ENV !== "production" && TK(a, "el.transition"), r[a] = s;
    }
  }
}
function k2e(e, t, r) {
  for (var n = 0; n < O4.length; n++) {
    var i = O4[n], o = RK[i], a = t[i];
    a && (r[o[0]] = a[0], r[o[1]] = a[1]);
  }
  for (var n = 0; n < gs.length; n++) {
    var s = gs[n];
    t[s] != null && (r[s] = t[s]);
  }
}
function V2e(e, t, r, n) {
  if (r) {
    var i = e.style, o;
    if (i) {
      var a = r.transition, s = t.transition;
      if (a && !Ic(a)) {
        var l = Tr(a);
        !o && (o = n.style = {});
        for (var u = 0; u < l.length; u++) {
          var c = l[u], d = i[c];
          o[c] = d;
        }
      } else if (e.getAnimationStyleProps && (Ic(s) || Ic(a) || Ft(s, "style") >= 0)) {
        var h = e.getAnimationStyleProps(), f = h ? h.style : null;
        if (f) {
          !o && (o = n.style = {});
          for (var p = jt(r), u = 0; u < p.length; u++) {
            var c = p[u];
            if (f[c]) {
              var d = i[c];
              o[c] = d;
            }
          }
        }
      }
    }
  }
}
function B2e(e, t) {
  return Jn(e) ? e !== t : e != null && isFinite(e);
}
var TK;
process.env.NODE_ENV !== "production" && (TK = function(e, t) {
  Ye(VC, e) || nn("Prop `" + e + "` is not a permitted in `" + t + "`. Only `" + jt(VC).join("`, `") + "` are permitted.");
});
var PK = ar(), $2e = ["percent", "easing", "shape", "style", "extra"];
function MK(e) {
  e.stopAnimation("keyframe"), e.attr(PK(e));
}
function $C(e, t, r) {
  if (!(!r.isAnimationEnabled() || !t)) {
    if (be(t)) {
      $(t, function(s) {
        $C(e, s, r);
      });
      return;
    }
    var n = t.keyframes, i = t.duration;
    if (r && i == null) {
      var o = mf("enter", r, 0);
      i = o && o.duration;
    }
    if (!(!n || !i)) {
      var a = PK(e);
      $(BC, function(s) {
        if (!(s && !e[s])) {
          var l, u = !1;
          n.sort(function(c, d) {
            return c.percent - d.percent;
          }), $(n, function(c) {
            var d = e.animators, h = s ? c[s] : c;
            if (process.env.NODE_ENV !== "production" && c.percent >= 1 && (u = !0), !!h) {
              var f = jt(h);
              if (s || (f = Sr(f, function(v) {
                return Ft($2e, v) < 0;
              })), !!f.length) {
                l || (l = e.animate(s, t.loop, !0), l.scope = "keyframe");
                for (var p = 0; p < d.length; p++)
                  d[p] !== l && d[p].targetName === l.targetName && d[p].stopTracks(f);
                s && (a[s] = a[s] || {});
                var g = s ? a[s] : a;
                $(f, function(v) {
                  g[v] = ((s ? e[s] : e) || {})[v];
                }), l.whenWithKeys(i * c.percent, h, f, c.easing);
              }
            }
          }), l && (process.env.NODE_ENV !== "production" && (u || nn("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), l.delay(t.delay || 0).duration(i).start(t.easing));
        }
      });
    }
  }
}
var js = "emphasis", Vl = "normal", TA = "blur", PA = "select", uu = [Vl, js, TA, PA], jx = {
  normal: ["itemStyle"],
  emphasis: [js, "itemStyle"],
  blur: [TA, "itemStyle"],
  select: [PA, "itemStyle"]
}, Ux = {
  normal: ["label"],
  emphasis: [js, "label"],
  blur: [TA, "label"],
  select: [PA, "label"]
}, H2e = ["x", "y"], G2e = "e\0\0", Oo = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, k4 = {
  cartesian2d: x2e,
  geo: R2e,
  single: T2e,
  polar: M2e,
  calendar: D2e
};
function HC(e) {
  return e instanceof Ht;
}
function OT(e) {
  return e instanceof ta;
}
function z2e(e, t) {
  t.copyTransform(e), OT(t) && OT(e) && (t.setStyle(e.style), t.z = e.z, t.z2 = e.z2, t.zlevel = e.zlevel, t.invisible = e.invisible, t.ignore = e.ignore, HC(t) && HC(e) && t.setShape(e.shape));
}
var W2e = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this._progressiveEls = null;
      var a = this._data, s = r.getData(), l = this.group, u = V4(r, s, n, i);
      a || l.removeAll(), s.diff(a).add(function(d) {
        Kx(i, null, d, u(d, o), r, l, s);
      }).remove(function(d) {
        var h = a.getItemGraphicEl(d);
        h && Iw(h, Ws(h).option, r);
      }).update(function(d, h) {
        var f = a.getItemGraphicEl(h);
        Kx(i, f, d, u(d, o), r, l, s);
      }).execute();
      var c = r.get("clip", !0) ? Kv(r.coordinateSystem, !1, r) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = s;
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      this.group.removeAll(), this._data = null;
    }, t.prototype.incrementalRender = function(r, n, i, o, a) {
      var s = n.getData(), l = V4(n, s, i, o), u = this._progressiveEls = [];
      function c(f) {
        f.isGroup || (f.incremental = !0, f.ensureState("emphasis").hoverLayer = !0);
      }
      for (var d = r.start; d < r.end; d++) {
        var h = Kx(null, null, d, l(d, a), n, this.group, s);
        h && (h.traverse(c), u.push(h));
      }
    }, t.prototype.eachRendered = function(r) {
      Su(this._progressiveEls || this.group, r);
    }, t.prototype.filterForExposedEvent = function(r, n, i, o) {
      var a = n.element;
      if (a == null || i.name === a)
        return !0;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; )
        if (i.name === a)
          return !0;
      return !1;
    }, t.type = "custom", t;
  }(br)
);
function MA(e) {
  var t = e.type, r;
  if (t === "path") {
    var n = e.shape, i = n.width != null && n.height != null ? {
      x: n.x || 0,
      y: n.y || 0,
      width: n.width,
      height: n.height
    } : null, o = IK(n);
    r = $v(o, null, i, n.layout || "center"), Ws(r).customPathData = o;
  } else if (t === "image")
    r = new qn({}), Ws(r).customImagePath = e.style.image;
  else if (t === "text")
    r = new ir({});
  else if (t === "group")
    r = new Ct();
  else {
    if (t === "compoundPath")
      throw new Error('"compoundPath" is not supported yet.');
    var a = lw(t);
    if (!a) {
      var s = "";
      process.env.NODE_ENV !== "production" && (s = 'graphic type "' + t + '" can not be found.'), mr(s);
    }
    r = new a();
  }
  return Ws(r).customGraphicType = t, r.name = e.name, r.z2EmphasisLift = 1, r.z2SelectLift = 1, r;
}
function DA(e, t, r, n, i, o, a) {
  MK(t);
  var s = i && i.normal.cfg;
  s && t.setTextConfig(s), n && n.transition == null && (n.transition = H2e);
  var l = n && n.style;
  if (l) {
    if (t.type === "text") {
      var u = l;
      Ye(u, "textFill") && (u.fill = u.textFill), Ye(u, "textStroke") && (u.stroke = u.textStroke);
    }
    var c = void 0, d = HC(t) ? l.decal : null;
    e && d && (d.dirty = !0, c = Yh(d, e)), l.__decalPattern = c;
  }
  if (OT(t) && l) {
    var c = l.__decalPattern;
    c && (l.decal = c);
  }
  v0(t, n, o, {
    dataIndex: r,
    isInit: a,
    clearStyle: !0
  }), $C(t, n.keyframeAnimation, o);
}
function DK(e, t, r, n, i) {
  var o = t.isGroup ? null : t, a = i && i[e].cfg;
  if (o) {
    var s = o.ensureState(e);
    if (n === !1) {
      var l = o.getState(e);
      l && (l.style = null);
    } else
      s.style = n || null;
    a && (s.textConfig = a), jc(o);
  }
}
function j2e(e, t, r) {
  if (!e.isGroup) {
    var n = e, i = r.currentZ, o = r.currentZLevel;
    n.z = i, n.zlevel = o;
    var a = t.z2;
    a != null && (n.z2 = a || 0);
    for (var s = 0; s < uu.length; s++)
      U2e(n, t, uu[s]);
  }
}
function U2e(e, t, r) {
  var n = r === Vl, i = n ? t : GC(t, r), o = i ? i.z2 : null, a;
  o != null && (a = n ? e : e.ensureState(r), a.z2 = o || 0);
}
function V4(e, t, r, n) {
  var i = e.get("renderItem"), o = e.coordinateSystem, a = {};
  o && (process.env.NODE_ENV !== "production" && (ct(i, "series.render is required."), ct(o.prepareCustoms || k4[o.type], "This coordSys does not support custom series.")), a = o.prepareCustoms ? o.prepareCustoms(o) : k4[o.type](o));
  for (var s = ut({
    getWidth: n.getWidth,
    getHeight: n.getHeight,
    getZr: n.getZr,
    getDevicePixelRatio: n.getDevicePixelRatio,
    value: S,
    style: w,
    ordinalRawValue: b,
    styleEmphasis: x,
    visual: T,
    barLayout: P,
    currentSeriesIndices: D,
    font: O
  }, a.api || {}), l = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: e.id,
    seriesName: e.name,
    seriesIndex: e.seriesIndex,
    coordSys: a.coordSys,
    dataInsideLength: t.count(),
    encode: K2e(e.getData())
  }, u, c, d = {}, h = {}, f = {}, p = {}, g = 0; g < uu.length; g++) {
    var v = uu[g];
    f[v] = e.getModel(jx[v]), p[v] = e.getModel(Ux[v]);
  }
  function m(A) {
    return A === u ? c || (c = t.getItemModel(A)) : t.getItemModel(A);
  }
  function y(A, F) {
    return t.hasItemOption ? A === u ? d[F] || (d[F] = m(A).getModel(jx[F])) : m(A).getModel(jx[F]) : f[F];
  }
  function C(A, F) {
    return t.hasItemOption ? A === u ? h[F] || (h[F] = m(A).getModel(Ux[F])) : m(A).getModel(Ux[F]) : p[F];
  }
  return function(A, F) {
    return u = A, c = null, d = {}, h = {}, i && i(ut({
      dataIndexInside: A,
      dataIndex: t.getRawIndex(A),
      // Can be used for optimization when zoom or roam.
      actionType: F ? F.type : null
    }, l), s);
  };
  function S(A, F) {
    return F == null && (F = u), t.getStore().get(t.getDimensionIndex(A || 0), F);
  }
  function b(A, F) {
    F == null && (F = u), A = A || 0;
    var L = t.getDimensionInfo(A);
    if (!L) {
      var N = t.getDimensionIndex(A);
      return N >= 0 ? t.getStore().get(N, F) : void 0;
    }
    var I = t.get(L.name, F), B = L && L.ordinalMeta;
    return B ? B.categories[I] : I;
  }
  function w(A, F) {
    process.env.NODE_ENV !== "production" && I4("api.style", "Please write literal style directly instead."), F == null && (F = u);
    var L = t.getItemVisual(F, "style"), N = L && L.fill, I = L && L.opacity, B = y(F, Vl).getItemStyle();
    N != null && (B.fill = N), I != null && (B.opacity = I);
    var M = {
      inheritColor: He(N) ? N : "#000"
    }, V = C(F, Vl), G = Vr(V, null, M, !1, !0);
    G.text = V.getShallow("show") ? bt(e.getFormattedLabel(F, Vl), qh(t, F)) : null;
    var k = hC(V, M, !1);
    return _(A, B), B = D4(B, G, k), A && R(B, A), B.legacy = !0, B;
  }
  function x(A, F) {
    process.env.NODE_ENV !== "production" && I4("api.styleEmphasis", "Please write literal style directly instead."), F == null && (F = u);
    var L = y(F, js).getItemStyle(), N = C(F, js), I = Vr(N, null, null, !0, !0);
    I.text = N.getShallow("show") ? So(e.getFormattedLabel(F, js), e.getFormattedLabel(F, Vl), qh(t, F)) : null;
    var B = hC(N, null, !0);
    return _(A, L), L = D4(L, I, B), A && R(L, A), L.legacy = !0, L;
  }
  function R(A, F) {
    for (var L in F)
      Ye(F, L) && (A[L] = F[L]);
  }
  function _(A, F) {
    A && (A.textFill && (F.textFill = A.textFill), A.textPosition && (F.textPosition = A.textPosition));
  }
  function T(A, F) {
    if (F == null && (F = u), Ye(T4, A)) {
      var L = t.getItemVisual(F, "style");
      return L ? L[T4[A]] : null;
    }
    if (Ye(S2e, A))
      return t.getItemVisual(F, A);
  }
  function P(A) {
    if (o.type === "cartesian2d") {
      var F = o.getBaseAxis();
      return bEe(ut({
        axis: F
      }, A));
    }
  }
  function D() {
    return r.getCurrentSeriesIndices();
  }
  function O(A) {
    return cD(A, r);
  }
}
function K2e(e) {
  var t = {};
  return $(e.dimensions, function(r) {
    var n = e.getDimensionInfo(r);
    if (!n.isExtraCoord) {
      var i = n.coordDim, o = t[i] = t[i] || [];
      o[n.coordDimIndex] = e.getDimensionIndex(r);
    }
  }), t;
}
function Kx(e, t, r, n, i, o, a) {
  if (!n) {
    o.remove(t);
    return;
  }
  var s = AA(e, t, r, n, i, o);
  return s && a.setItemGraphicEl(r, s), s && sn(s, n.focus, n.blurScope, n.emphasisDisabled), s;
}
function AA(e, t, r, n, i, o) {
  process.env.NODE_ENV !== "production" && ct(n, "should not have an null/undefined element setting");
  var a = -1, s = t;
  t && AK(t, n, i) && (a = Ft(o.childrenRef(), t), t = null);
  var l = !t, u = t;
  u ? u.clearStates() : (u = MA(n), s && z2e(s, u)), n.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), Oo.normal.cfg = Oo.normal.conOpt = Oo.emphasis.cfg = Oo.emphasis.conOpt = Oo.blur.cfg = Oo.blur.conOpt = Oo.select.cfg = Oo.select.conOpt = null, Oo.isLegacy = !1, q2e(u, r, n, i, l, Oo), Y2e(u, r, n, i, l), DA(e, u, r, n, Oo, i, l), Ye(n, "info") && (Ws(u).info = n.info);
  for (var c = 0; c < uu.length; c++) {
    var d = uu[c];
    if (d !== Vl) {
      var h = GC(n, d), f = IA(n, h, d);
      DK(d, u, h, f, Oo);
    }
  }
  return j2e(u, n, i), n.type === "group" && X2e(e, u, r, n, i), a >= 0 ? o.replaceAt(u, a) : o.add(u), u;
}
function AK(e, t, r) {
  var n = Ws(e), i = t.type, o = t.shape, a = t.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    r.isUniversalTransitionEnabled() || i != null && i !== n.customGraphicType || i === "path" && eOe(o) && IK(o) !== n.customPathData || i === "image" && Ye(a, "image") && a.image !== n.customImagePath
  );
}
function Y2e(e, t, r, n, i) {
  var o = r.clipPath;
  if (o === !1)
    e && e.getClipPath() && e.removeClipPath();
  else if (o) {
    var a = e.getClipPath();
    a && AK(a, o, n) && (a = null), a || (a = MA(o), process.env.NODE_ENV !== "production" && ct(HC(a), "Only any type of `path` can be used in `clipPath`, rather than " + a.type + "."), e.setClipPath(a)), DA(null, a, t, o, null, n, i);
  }
}
function q2e(e, t, r, n, i, o) {
  if (!e.isGroup) {
    B4(r, null, o), B4(r, js, o);
    var a = o.normal.conOpt, s = o.emphasis.conOpt, l = o.blur.conOpt, u = o.select.conOpt;
    if (a != null || s != null || u != null || l != null) {
      var c = e.getTextContent();
      if (a === !1)
        c && e.removeTextContent();
      else {
        a = o.normal.conOpt = a || {
          type: "text"
        }, c ? c.clearStates() : (c = MA(a), e.setTextContent(c)), DA(null, c, t, a, null, n, i);
        for (var d = a && a.style, h = 0; h < uu.length; h++) {
          var f = uu[h];
          if (f !== Vl) {
            var p = o[f].conOpt;
            DK(f, c, p, IA(a, p, f), null);
          }
        }
        d ? c.dirty() : c.markRedraw();
      }
    }
  }
}
function B4(e, t, r) {
  var n = t ? GC(e, t) : e, i = t ? IA(e, n, js) : e.style, o = e.type, a = n ? n.textConfig : null, s = e.textContent, l = s ? t ? GC(s, t) : s : null;
  if (i && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (r.isLegacy || xK(i, o, !!a, !!l))) {
    r.isLegacy = !0;
    var u = EK(i, o, !t);
    !a && u.textConfig && (a = u.textConfig), !l && u.textContent && (l = u.textContent);
  }
  if (!t && l) {
    var c = l;
    !c.type && (c.type = "text"), process.env.NODE_ENV !== "production" && ct(c.type === "text", 'textContent.type must be "text"');
  }
  var d = t ? r[t] : r.normal;
  d.cfg = a, d.conOpt = l;
}
function GC(e, t) {
  return t ? e ? e[t] : null : e;
}
function IA(e, t, r) {
  var n = t && t.style;
  return n == null && r === js && e && (n = e.styleEmphasis), n;
}
function X2e(e, t, r, n, i) {
  var o = n.children, a = o ? o.length : 0, s = n.$mergeChildren, l = s === "byName" || n.diffChildrenByName, u = s === !1;
  if (!(!a && !l && !u)) {
    if (l) {
      Q2e({
        api: e,
        oldChildren: t.children() || [],
        newChildren: o || [],
        dataIndex: r,
        seriesModel: i,
        group: t
      });
      return;
    }
    u && t.removeAll();
    for (var c = 0; c < a; c++) {
      var d = o[c], h = t.childAt(c);
      d ? (d.ignore == null && (d.ignore = !1), AA(e, h, r, d, i, t)) : (process.env.NODE_ENV !== "production" && ct(h, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), h.ignore = !0);
    }
    for (var f = t.childCount() - 1; f >= c; f--) {
      var p = t.childAt(f);
      Z2e(t, p, i);
    }
  }
}
function Z2e(e, t, r) {
  t && Iw(t, Ws(e).option, r);
}
function Q2e(e) {
  new el(e.oldChildren, e.newChildren, $4, $4, e).add(H4).update(H4).remove(J2e).execute();
}
function $4(e, t) {
  var r = e && e.name;
  return r ?? G2e + t;
}
function H4(e, t) {
  var r = this.context, n = e != null ? r.newChildren[e] : null, i = t != null ? r.oldChildren[t] : null;
  AA(r.api, i, r.dataIndex, n, r.seriesModel, r.group);
}
function J2e(e) {
  var t = this.context, r = t.oldChildren[e];
  r && Iw(r, Ws(r).option, t.seriesModel);
}
function IK(e) {
  return e && (e.pathData || e.d);
}
function eOe(e) {
  return e && (Ye(e, "pathData") || Ye(e, "d"));
}
function tOe(e) {
  e.registerChartView(W2e), e.registerSeriesModel(w2e);
}
var uc = ar(), G4 = dt, Yx = je, OA = (
  /** @class */
  function() {
    function e() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return e.prototype.render = function(t, r, n, i) {
      var o = r.get("value"), a = r.get("status");
      if (this._axisModel = t, this._axisPointerModel = r, this._api = n, !(!i && this._lastValue === o && this._lastStatus === a)) {
        this._lastValue = o, this._lastStatus = a;
        var s = this._group, l = this._handle;
        if (!a || a === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, o, t, r, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var d = this._moveAnimation = this.determineAnimation(t, r);
        if (!s)
          s = this._group = new Ct(), this.createPointerEl(s, u, t, r), this.createLabelEl(s, u, t, r), n.getZr().add(s);
        else {
          var h = _t(z4, r, d);
          this.updatePointerEl(s, u, h), this.updateLabelEl(s, u, h, r);
        }
        j4(s, r, !0), this._renderHandle(o);
      }
    }, e.prototype.remove = function(t) {
      this.clear(t);
    }, e.prototype.dispose = function(t) {
      this.clear(t);
    }, e.prototype.determineAnimation = function(t, r) {
      var n = r.get("animation"), i = t.axis, o = i.type === "category", a = r.get("snap");
      if (!a && !o)
        return !1;
      if (n === "auto" || n == null) {
        var s = this.animationThreshold;
        if (o && i.getBandWidth() > s)
          return !0;
        if (a) {
          var l = nA(t).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return n === !0;
    }, e.prototype.makeElOption = function(t, r, n, i, o) {
    }, e.prototype.createPointerEl = function(t, r, n, i) {
      var o = r.pointer;
      if (o) {
        var a = uc(t).pointerEl = new od[o.type](G4(r.pointer));
        t.add(a);
      }
    }, e.prototype.createLabelEl = function(t, r, n, i) {
      if (r.label) {
        var o = uc(t).labelEl = new ir(G4(r.label));
        t.add(o), W4(o, i);
      }
    }, e.prototype.updatePointerEl = function(t, r, n) {
      var i = uc(t).pointerEl;
      i && r.pointer && (i.setStyle(r.pointer.style), n(i, {
        shape: r.pointer.shape
      }));
    }, e.prototype.updateLabelEl = function(t, r, n, i) {
      var o = uc(t).labelEl;
      o && (o.setStyle(r.label.style), n(o, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: r.label.x,
        y: r.label.y
      }), W4(o, i));
    }, e.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var r = this._axisPointerModel, n = this._api.getZr(), i = this._handle, o = r.getModel("handle"), a = r.get("status");
        if (!o.get("show") || !a || a === "hide") {
          i && n.remove(i), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, i = this._handle = yf(o.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Zs(u.event);
          },
          onmousedown: Yx(this._onHandleDragMove, this, 0, 0),
          drift: Yx(this._onHandleDragMove, this),
          ondragend: Yx(this._onHandleDragEnd, this)
        }), n.add(i)), j4(i, r, !1), i.setStyle(o.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = o.get("size");
        be(l) || (l = [l, l]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, Rf(this, "_doDispatchAxisPointer", o.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, s);
      }
    }, e.prototype._moveHandleToValue = function(t, r) {
      z4(this._axisPointerModel, !r && this._moveAnimation, this._handle, qx(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, e.prototype._onHandleDragMove = function(t, r) {
      var n = this._handle;
      if (n) {
        this._dragging = !0;
        var i = this.updateHandleTransform(qx(n), [t, r], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, n.stopAnimation(), n.attr(qx(i)), uc(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, e.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var r = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: r.cursorPoint[0],
          y: r.cursorPoint[1],
          tooltipOption: r.tooltipOption,
          axesInfo: [{
            axisDim: n.axis.dim,
            axisIndex: n.componentIndex
          }]
        });
      }
    }, e.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var t = this._handle;
      if (t) {
        var r = this._axisPointerModel.get("value");
        this._moveHandleToValue(r), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, e.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var r = t.getZr(), n = this._group, i = this._handle;
      r && n && (this._lastGraphicKey = null, n && r.remove(n), i && r.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), Xg(this, "_doDispatchAxisPointer");
    }, e.prototype.doClear = function() {
    }, e.prototype.buildLabel = function(t, r, n) {
      return n = n || 0, {
        x: t[n],
        y: t[1 - n],
        width: r[n],
        height: r[1 - n]
      };
    }, e;
  }()
);
function z4(e, t, r, n) {
  OK(uc(r).lastProp, n) || (uc(r).lastProp = n, t ? ur(r, n, e) : (r.stopAnimation(), r.attr(n)));
}
function OK(e, t) {
  if (lt(e) && lt(t)) {
    var r = !0;
    return $(t, function(n, i) {
      r = r && OK(e[i], n);
    }), !!r;
  } else
    return e === t;
}
function W4(e, t) {
  e[t.get(["label", "show"]) ? "show" : "hide"]();
}
function qx(e) {
  return {
    x: e.x || 0,
    y: e.y || 0,
    rotation: e.rotation || 0
  };
}
function j4(e, t, r) {
  var n = t.get("z"), i = t.get("zlevel");
  e && e.traverse(function(o) {
    o.type !== "group" && (n != null && (o.z = n), i != null && (o.zlevel = i), o.silent = r);
  });
}
function LA(e) {
  var t = e.get("type"), r = e.getModel(t + "Style"), n;
  return t === "line" ? (n = r.getLineStyle(), n.fill = null) : t === "shadow" && (n = r.getAreaStyle(), n.stroke = null), n;
}
function LK(e, t, r, n, i) {
  var o = r.get("value"), a = FK(o, t.axis, t.ecModel, r.get("seriesDataIndices"), {
    precision: r.get(["label", "precision"]),
    formatter: r.get(["label", "formatter"])
  }), s = r.getModel("label"), l = sd(s.get("padding") || 0), u = s.getFont(), c = Lv(a, u), d = i.position, h = c.width + l[1] + l[3], f = c.height + l[0] + l[2], p = i.align;
  p === "right" && (d[0] -= h), p === "center" && (d[0] -= h / 2);
  var g = i.verticalAlign;
  g === "bottom" && (d[1] -= f), g === "middle" && (d[1] -= f / 2), rOe(d, h, f, n);
  var v = s.get("backgroundColor");
  (!v || v === "auto") && (v = t.get(["axisLine", "lineStyle", "color"])), e.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: d[0],
    y: d[1],
    style: Vr(s, {
      text: a,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: v
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function rOe(e, t, r, n) {
  var i = n.getWidth(), o = n.getHeight();
  e[0] = Math.min(e[0] + t, i) - t, e[1] = Math.min(e[1] + r, o) - r, e[0] = Math.max(e[0], 0), e[1] = Math.max(e[1], 0);
}
function FK(e, t, r, n, i) {
  e = t.scale.parse(e);
  var o = t.scale.getLabel({
    value: e
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: i.precision
  }), a = i.formatter;
  if (a) {
    var s = {
      value: UD(t, {
        value: e
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    };
    $(n, function(l) {
      var u = r.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, d = u && u.getDataParams(c);
      d && s.seriesData.push(d);
    }), He(a) ? o = a.replace("{value}", o) : at(a) && (o = a(s));
  }
  return o;
}
function FA(e, t, r) {
  var n = Zi();
  return Cu(n, n, r.rotation), Oa(n, n, r.position), Ma([e.dataToCoord(t), (r.labelOffset || 0) + (r.labelDirection || 1) * (r.labelMargin || 0)], n);
}
function NK(e, t, r, n, i, o) {
  var a = Mi.innerTextLayout(r.rotation, 0, r.labelDirection);
  r.labelMargin = i.get(["label", "margin"]), LK(t, n, i, o, {
    position: FA(n.axis, e, r),
    align: a.textAlign,
    verticalAlign: a.textVerticalAlign
  });
}
function NA(e, t, r) {
  return r = r || 0, {
    x1: e[r],
    y1: e[1 - r],
    x2: t[r],
    y2: t[1 - r]
  };
}
function kK(e, t, r) {
  return r = r || 0, {
    x: e[r],
    y: e[1 - r],
    width: t[r],
    height: t[1 - r]
  };
}
function U4(e, t, r, n, i, o) {
  return {
    cx: e,
    cy: t,
    r0: r,
    r: n,
    startAngle: i,
    endAngle: o,
    clockwise: !0
  };
}
var nOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(r, n, i, o, a) {
      var s = i.axis, l = s.grid, u = o.get("type"), c = K4(l, s).getOtherAxis(s).getGlobalExtent(), d = s.toGlobalCoord(s.dataToCoord(n, !0));
      if (u && u !== "none") {
        var h = LA(o), f = iOe[u](s, d, c);
        f.style = h, r.graphicKey = f.type, r.pointer = f;
      }
      var p = gT(l.model, i);
      NK(
        // @ts-ignore
        n,
        r,
        p,
        i,
        o,
        a
      );
    }, t.prototype.getHandleTransform = function(r, n, i) {
      var o = gT(n.axis.grid.model, n, {
        labelInside: !1
      });
      o.labelMargin = i.get(["handle", "margin"]);
      var a = FA(n.axis, r, o);
      return {
        x: a[0],
        y: a[1],
        rotation: o.rotation + (o.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(r, n, i, o) {
      var a = i.axis, s = a.grid, l = a.getGlobalExtent(!0), u = K4(s, a).getOtherAxis(a).getGlobalExtent(), c = a.dim === "x" ? 0 : 1, d = [r.x, r.y];
      d[c] += n[c], d[c] = Math.min(l[1], d[c]), d[c] = Math.max(l[0], d[c]);
      var h = (u[1] + u[0]) / 2, f = [h, h];
      f[c] = d[c];
      var p = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: d[0],
        y: d[1],
        rotation: r.rotation,
        cursorPoint: f,
        tooltipOption: p[c]
      };
    }, t;
  }(OA)
);
function K4(e, t) {
  var r = {};
  return r[t.dim + "AxisIndex"] = t.index, e.getCartesian(r);
}
var iOe = {
  line: function(e, t, r) {
    var n = NA([t, r[0]], [t, r[1]], Y4(e));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(e, t, r) {
    var n = Math.max(1, e.getBandWidth()), i = r[1] - r[0];
    return {
      type: "Rect",
      shape: kK([t - n / 2, r[0]], [n, i], Y4(e))
    };
  }
};
function Y4(e) {
  return e.dim === "x" ? 0 : 1;
}
var oOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "axisPointer", t.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }, t;
  }(Vt)
), Hs = ar(), aOe = $;
function VK(e, t, r) {
  if (!nr.node) {
    var n = t.getZr();
    Hs(n).records || (Hs(n).records = {}), sOe(n, t);
    var i = Hs(n).records[e] || (Hs(n).records[e] = {});
    i.handler = r;
  }
}
function sOe(e, t) {
  if (Hs(e).initialized)
    return;
  Hs(e).initialized = !0, r("click", _t(q4, "click")), r("mousemove", _t(q4, "mousemove")), r("globalout", uOe);
  function r(n, i) {
    e.on(n, function(o) {
      var a = cOe(t);
      aOe(Hs(e).records, function(s) {
        s && i(s, o, a.dispatchAction);
      }), lOe(a.pendings, t);
    });
  }
}
function lOe(e, t) {
  var r = e.showTip.length, n = e.hideTip.length, i;
  r ? i = e.showTip[r - 1] : n && (i = e.hideTip[n - 1]), i && (i.dispatchAction = null, t.dispatchAction(i));
}
function uOe(e, t, r) {
  e.handler("leave", null, r);
}
function q4(e, t, r, n) {
  t.handler(e, r, n);
}
function cOe(e) {
  var t = {
    showTip: [],
    hideTip: []
  }, r = function(n) {
    var i = t[n.type];
    i ? i.push(n) : (n.dispatchAction = r, e.dispatchAction(n));
  };
  return {
    dispatchAction: r,
    pendings: t
  };
}
function LT(e, t) {
  if (!nr.node) {
    var r = t.getZr(), n = (Hs(r).records || {})[e];
    n && (Hs(r).records[e] = null);
  }
}
var dOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = n.getComponent("tooltip"), a = r.get("triggerOn") || o && o.get("triggerOn") || "mousemove|click";
      VK("axisPointer", i, function(s, l, u) {
        a !== "none" && (s === "leave" || a.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(r, n) {
      LT("axisPointer", n);
    }, t.prototype.dispose = function(r, n) {
      LT("axisPointer", n);
    }, t.type = "axisPointer", t;
  }(zr)
);
function BK(e, t) {
  var r = [], n = e.seriesIndex, i;
  if (n == null || !(i = t.getSeriesByIndex(n)))
    return {
      point: []
    };
  var o = i.getData(), a = zc(o, e);
  if (a == null || a < 0 || be(a))
    return {
      point: []
    };
  var s = o.getItemGraphicEl(a), l = i.coordinateSystem;
  if (i.getTooltipPosition)
    r = i.getTooltipPosition(a) || [];
  else if (l && l.dataToPoint)
    if (e.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), d = c.dim, h = u.dim, f = d === "x" || d === "radius" ? 1 : 0, p = o.mapDimension(h), g = [];
      g[f] = o.get(p, a), g[1 - f] = o.get(o.getCalculationInfo("stackResultDimension"), a), r = l.dataToPoint(g) || [];
    } else
      r = l.dataToPoint(o.getValues(Ee(l.dimensions, function(m) {
        return o.mapDimension(m);
      }), a)) || [];
  else if (s) {
    var v = s.getBoundingRect().clone();
    v.applyTransform(s.transform), r = [v.x + v.width / 2, v.y + v.height / 2];
  }
  return {
    point: r,
    el: s
  };
}
var X4 = ar();
function hOe(e, t, r) {
  var n = e.currTrigger, i = [e.x, e.y], o = e, a = e.dispatchAction || je(r.dispatchAction, r), s = t.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    m0(i) && (i = BK({
      seriesIndex: o.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: o.dataIndex
    }, t).point);
    var l = m0(i), u = o.axesInfo, c = s.axesInfo, d = n === "leave" || m0(i), h = {}, f = {}, p = {
      list: [],
      map: {}
    }, g = {
      showPointer: _t(pOe, f),
      showTooltip: _t(gOe, p)
    };
    $(s.coordSysMap, function(m, y) {
      var C = l || m.containPoint(i);
      $(s.coordSysAxesInfo[y], function(S, b) {
        var w = S.axis, x = COe(u, S);
        if (!d && C && (!u || x)) {
          var R = x && x.value;
          R == null && !l && (R = w.pointToData(i)), R != null && Z4(S, R, g, !1, h);
        }
      });
    });
    var v = {};
    return $(c, function(m, y) {
      var C = m.linkGroup;
      C && !f[y] && $(C.axesInfo, function(S, b) {
        var w = f[b];
        if (S !== m && w) {
          var x = w.value;
          C.mapper && (x = m.axis.scale.parse(C.mapper(x, Q4(S), Q4(m)))), v[m.key] = x;
        }
      });
    }), $(v, function(m, y) {
      Z4(c[y], m, g, !0, h);
    }), vOe(f, c, h), mOe(p, i, e, a), yOe(c, a, r), h;
  }
}
function Z4(e, t, r, n, i) {
  var o = e.axis;
  if (!(o.scale.isBlank() || !o.containData(t))) {
    if (!e.involveSeries) {
      r.showPointer(e, t);
      return;
    }
    var a = fOe(t, e), s = a.payloadBatch, l = a.snapToValue;
    s[0] && i.seriesIndex == null && ge(i, s[0]), !n && e.snap && o.containData(l) && l != null && (t = l), r.showPointer(e, t, s), r.showTooltip(e, a, l);
  }
}
function fOe(e, t) {
  var r = t.axis, n = r.dim, i = e, o = [], a = Number.MAX_VALUE, s = -1;
  return $(t.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(n), d, h;
    if (l.getAxisTooltipData) {
      var f = l.getAxisTooltipData(c, e, r);
      h = f.dataIndices, d = f.nestestValue;
    } else {
      if (h = l.getData().indicesOfNearest(
        c[0],
        e,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        r.type === "category" ? 0.5 : null
      ), !h.length)
        return;
      d = l.getData().get(c[0], h[0]);
    }
    if (!(d == null || !isFinite(d))) {
      var p = e - d, g = Math.abs(p);
      g <= a && ((g < a || p >= 0 && s < 0) && (a = g, s = p, i = d, o.length = 0), $(h, function(v) {
        o.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: v,
          dataIndex: l.getData().getRawIndex(v)
        });
      }));
    }
  }), {
    payloadBatch: o,
    snapToValue: i
  };
}
function pOe(e, t, r, n) {
  e[t.key] = {
    value: r,
    payloadBatch: n
  };
}
function gOe(e, t, r, n) {
  var i = r.payloadBatch, o = t.axis, a = o.model, s = t.axisPointerModel;
  if (!(!t.triggerTooltip || !i.length)) {
    var l = t.coordSys.model, u = nv(l), c = e.map[u];
    c || (c = e.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, e.list.push(c)), c.dataByAxis.push({
      axisDim: o.dim,
      axisIndex: a.componentIndex,
      axisType: a.type,
      axisId: a.id,
      value: n,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: i.slice()
    });
  }
}
function vOe(e, t, r) {
  var n = r.axesInfo = [];
  $(t, function(i, o) {
    var a = i.axisPointerModel.option, s = e[o];
    s ? (!i.useHandle && (a.status = "show"), a.value = s.value, a.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (a.status = "hide"), a.status === "show" && n.push({
      axisDim: i.axis.dim,
      axisIndex: i.axis.model.componentIndex,
      value: a.value
    });
  });
}
function mOe(e, t, r, n) {
  if (m0(t) || !e.list.length) {
    n({
      type: "hideTip"
    });
    return;
  }
  var i = ((e.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  n({
    type: "showTip",
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: r.tooltipOption,
    position: r.position,
    dataIndexInside: i.dataIndexInside,
    dataIndex: i.dataIndex,
    seriesIndex: i.seriesIndex,
    dataByCoordSys: e.list
  });
}
function yOe(e, t, r) {
  var n = r.getZr(), i = "axisPointerLastHighlights", o = X4(n)[i] || {}, a = X4(n)[i] = {};
  $(e, function(u, c) {
    var d = u.axisPointerModel.option;
    d.status === "show" && u.triggerEmphasis && $(d.seriesDataIndices, function(h) {
      var f = h.seriesIndex + " | " + h.dataIndex;
      a[f] = h;
    });
  });
  var s = [], l = [];
  $(o, function(u, c) {
    !a[c] && l.push(u);
  }), $(a, function(u, c) {
    !o[c] && s.push(u);
  }), l.length && r.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && r.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function COe(e, t) {
  for (var r = 0; r < (e || []).length; r++) {
    var n = e[r];
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n;
  }
}
function Q4(e) {
  var t = e.axis.model, r = {}, n = r.axisDim = e.axis.dim;
  return r.axisIndex = r[n + "AxisIndex"] = t.componentIndex, r.axisName = r[n + "AxisName"] = t.name, r.axisId = r[n + "AxisId"] = t.id, r;
}
function m0(e) {
  return !e || e[0] == null || isNaN(e[0]) || e[1] == null || isNaN(e[1]);
}
function Jv(e) {
  dd.registerAxisPointerClass("CartesianAxisPointer", nOe), e.registerComponentModel(oOe), e.registerComponentView(dOe), e.registerPreprocessor(function(t) {
    if (t) {
      (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
      var r = t.axisPointer.link;
      r && !be(r) && (t.axisPointer.link = [r]);
    }
  }), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, function(t, r) {
    t.getComponent("axisPointer").coordSysAxesInfo = DTe(t, r);
  }), e.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, hOe);
}
function SOe(e) {
  Bt(dU), Bt(Jv);
}
var wOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(r, n, i, o, a) {
      var s = i.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), c = u.getExtent(), d = s.dataToCoord(n), h = o.get("type");
      if (h && h !== "none") {
        var f = LA(o), p = xOe[h](s, l, d, c);
        p.style = f, r.graphicKey = p.type, r.pointer = p;
      }
      var g = o.get(["label", "margin"]), v = bOe(n, i, o, l, g);
      LK(r, i, o, a, v);
    }, t;
  }(OA)
);
function bOe(e, t, r, n, i) {
  var o = t.axis, a = o.dataToCoord(e), s = n.getAngleAxis().getExtent()[0];
  s = s / 180 * Math.PI;
  var l = n.getRadiusAxis().getExtent(), u, c, d;
  if (o.dim === "radius") {
    var h = Zi();
    Cu(h, h, s), Oa(h, h, [n.cx, n.cy]), u = Ma([a, -i], h);
    var f = t.getModel("axisLabel").get("rotate") || 0, p = Mi.innerTextLayout(s, f * Math.PI / 180, -1);
    c = p.textAlign, d = p.textVerticalAlign;
  } else {
    var g = l[1];
    u = n.coordToPoint([g + i, a]);
    var v = n.cx, m = n.cy;
    c = Math.abs(u[0] - v) / g < 0.3 ? "center" : u[0] > v ? "left" : "right", d = Math.abs(u[1] - m) / g < 0.3 ? "middle" : u[1] > m ? "top" : "bottom";
  }
  return {
    position: u,
    align: c,
    verticalAlign: d
  };
}
var xOe = {
  line: function(e, t, r, n) {
    return e.dim === "angle" ? {
      type: "Line",
      shape: NA(t.coordToPoint([n[0], r]), t.coordToPoint([n[1], r]))
    } : {
      type: "Circle",
      shape: {
        cx: t.cx,
        cy: t.cy,
        r
      }
    };
  },
  shadow: function(e, t, r, n) {
    var i = Math.max(1, e.getBandWidth()), o = Math.PI / 180;
    return e.dim === "angle" ? {
      type: "Sector",
      shape: U4(
        t.cx,
        t.cy,
        n[0],
        n[1],
        // In ECharts y is negative if angle is positive
        (-r - i / 2) * o,
        (-r + i / 2) * o
      )
    } : {
      type: "Sector",
      shape: U4(t.cx, t.cy, r - i / 2, r + i / 2, 0, Math.PI * 2)
    };
  }
}, EOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.findAxisModel = function(r) {
      var n, i = this.ecModel;
      return i.eachComponent(r, function(o) {
        o.getCoordSysModel() === this && (n = o);
      }, this), n;
    }, t.type = "polar", t.dependencies = ["radiusAxis", "angleAxis"], t.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, t;
  }(Vt)
), kA = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", bn).models[0];
    }, t.type = "polarAxis", t;
  }(Vt)
);
cn(kA, Mf);
var ROe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "angleAxis", t;
  }(kA)
), _Oe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "radiusAxis", t;
  }(kA)
), VA = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n) {
      return e.call(this, "radius", r, n) || this;
    }
    return t.prototype.pointToData = function(r, n) {
      return this.polar.pointToData(r, n)[this.dim === "radius" ? 0 : 1];
    }, t;
  }(sa)
);
VA.prototype.dataToRadius = sa.prototype.dataToCoord;
VA.prototype.radiusToData = sa.prototype.coordToData;
var TOe = ar(), BA = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n) {
      return e.call(this, "angle", r, n || [0, 360]) || this;
    }
    return t.prototype.pointToData = function(r, n) {
      return this.polar.pointToData(r, n)[this.dim === "radius" ? 0 : 1];
    }, t.prototype.calculateCategoryInterval = function() {
      var r = this, n = r.getLabelModel(), i = r.scale, o = i.getExtent(), a = i.count();
      if (o[1] - o[0] < 1)
        return 0;
      var s = o[0], l = r.dataToCoord(s + 1) - r.dataToCoord(s), u = Math.abs(l), c = Lv(s == null ? "" : s + "", n.getFont(), "center", "top"), d = Math.max(c.height, 7), h = d / u;
      isNaN(h) && (h = 1 / 0);
      var f = Math.max(0, Math.floor(h)), p = TOe(r.model), g = p.lastAutoInterval, v = p.lastTickCount;
      return g != null && v != null && Math.abs(g - f) <= 1 && Math.abs(v - a) <= 1 && g > f ? f = g : (p.lastTickCount = a, p.lastAutoInterval = f), f;
    }, t;
  }(sa)
);
BA.prototype.dataToAngle = sa.prototype.dataToCoord;
BA.prototype.angleToData = sa.prototype.coordToData;
var $K = ["radius", "angle"], POe = (
  /** @class */
  function() {
    function e(t) {
      this.dimensions = $K, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new VA(), this._angleAxis = new BA(), this.axisPointerEnabled = !0, this.name = t || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return e.prototype.containPoint = function(t) {
      var r = this.pointToCoord(t);
      return this._radiusAxis.contain(r[0]) && this._angleAxis.contain(r[1]);
    }, e.prototype.containData = function(t) {
      return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
    }, e.prototype.getAxis = function(t) {
      var r = "_" + t + "Axis";
      return this[r];
    }, e.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, e.prototype.getAxesByScale = function(t) {
      var r = [], n = this._angleAxis, i = this._radiusAxis;
      return n.scale.type === t && r.push(n), i.scale.type === t && r.push(i), r;
    }, e.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, e.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, e.prototype.getOtherAxis = function(t) {
      var r = this._angleAxis;
      return t === r ? this._radiusAxis : r;
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, e.prototype.getTooltipAxes = function(t) {
      var r = t != null && t !== "auto" ? this.getAxis(t) : this.getBaseAxis();
      return {
        baseAxes: [r],
        otherAxes: [this.getOtherAxis(r)]
      };
    }, e.prototype.dataToPoint = function(t, r) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], r), this._angleAxis.dataToAngle(t[1], r)]);
    }, e.prototype.pointToData = function(t, r) {
      var n = this.pointToCoord(t);
      return [this._radiusAxis.radiusToData(n[0], r), this._angleAxis.angleToData(n[1], r)];
    }, e.prototype.pointToCoord = function(t) {
      var r = t[0] - this.cx, n = t[1] - this.cy, i = this.getAngleAxis(), o = i.getExtent(), a = Math.min(o[0], o[1]), s = Math.max(o[0], o[1]);
      i.inverse ? a = s - 360 : s = a + 360;
      var l = Math.sqrt(r * r + n * n);
      r /= l, n /= l;
      for (var u = Math.atan2(-n, r) / Math.PI * 180, c = u < a ? 1 : -1; u < a || u > s; )
        u += c * 360;
      return [l, u];
    }, e.prototype.coordToPoint = function(t) {
      var r = t[0], n = t[1] / 180 * Math.PI, i = Math.cos(n) * r + this.cx, o = -Math.sin(n) * r + this.cy;
      return [i, o];
    }, e.prototype.getArea = function() {
      var t = this.getAngleAxis(), r = this.getRadiusAxis(), n = r.getExtent().slice();
      n[0] > n[1] && n.reverse();
      var i = t.getExtent(), o = Math.PI / 180;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: n[0],
        r: n[1],
        startAngle: -i[0] * o,
        endAngle: -i[1] * o,
        clockwise: t.inverse,
        contain: function(a, s) {
          var l = a - this.cx, u = s - this.cy, c = l * l + u * u - 1e-4, d = this.r, h = this.r0;
          return c <= d * d && c >= h * h;
        }
      };
    }, e.prototype.convertToPixel = function(t, r, n) {
      var i = J4(r);
      return i === this ? this.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      var i = J4(r);
      return i === this ? this.pointToData(n) : null;
    }, e;
  }()
);
function J4(e) {
  var t = e.seriesModel, r = e.polarModel;
  return r && r.coordinateSystem || t && t.coordinateSystem;
}
const MOe = POe;
function DOe(e, t, r) {
  var n = t.get("center"), i = r.getWidth(), o = r.getHeight();
  e.cx = Be(n[0], i), e.cy = Be(n[1], o);
  var a = e.getRadiusAxis(), s = Math.min(i, o) / 2, l = t.get("radius");
  l == null ? l = [0, "100%"] : be(l) || (l = [0, l]);
  var u = [Be(l[0], s), Be(l[1], s)];
  a.inverse ? a.setExtent(u[1], u[0]) : a.setExtent(u[0], u[1]);
}
function AOe(e, t) {
  var r = this, n = r.getAngleAxis(), i = r.getRadiusAxis();
  if (n.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), e.eachSeries(function(s) {
    if (s.coordinateSystem === r) {
      var l = s.getData();
      $(TC(l, "radius"), function(u) {
        i.scale.unionExtentFromData(l, u);
      }), $(TC(l, "angle"), function(u) {
        n.scale.unionExtentFromData(l, u);
      });
    }
  }), Kc(n.scale, n.model), Kc(i.scale, i.model), n.type === "category" && !n.onBand) {
    var o = n.getExtent(), a = 360 / n.scale.count();
    n.inverse ? o[1] += a : o[1] -= a, n.setExtent(o[0], o[1]);
  }
}
function IOe(e) {
  return e.mainType === "angleAxis";
}
function e$(e, t) {
  var r;
  if (e.type = t.get("type"), e.scale = Wv(t), e.onBand = t.get("boundaryGap") && e.type === "category", e.inverse = t.get("inverse"), IOe(t)) {
    e.inverse = e.inverse !== t.get("clockwise");
    var n = t.get("startAngle"), i = (r = t.get("endAngle")) !== null && r !== void 0 ? r : n + (e.inverse ? -360 : 360);
    e.setExtent(n, i);
  }
  t.axis = e, e.model = t;
}
var OOe = {
  dimensions: $K,
  create: function(e, t) {
    var r = [];
    return e.eachComponent("polar", function(n, i) {
      var o = new MOe(i + "");
      o.update = AOe;
      var a = o.getRadiusAxis(), s = o.getAngleAxis(), l = n.findAxisModel("radiusAxis"), u = n.findAxisModel("angleAxis");
      e$(a, l), e$(s, u), DOe(o, n, t), r.push(o), n.coordinateSystem = o, o.model = n;
    }), e.eachSeries(function(n) {
      if (n.get("coordinateSystem") === "polar") {
        var i = n.getReferringComponents("polar", bn).models[0];
        if (process.env.NODE_ENV !== "production" && !i)
          throw new Error('Polar "' + vn(n.get("polarIndex"), n.get("polarId"), 0) + '" not found');
        n.coordinateSystem = i.coordinateSystem;
      }
    }), r;
  }
}, LOe = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function Ey(e, t, r) {
  t[1] > t[0] && (t = t.slice().reverse());
  var n = e.coordToPoint([t[0], r]), i = e.coordToPoint([t[1], r]);
  return {
    x1: n[0],
    y1: n[1],
    x2: i[0],
    y2: i[1]
  };
}
function Ry(e) {
  var t = e.getRadiusAxis();
  return t.inverse ? 0 : 1;
}
function t$(e) {
  var t = e[0], r = e[e.length - 1];
  t && r && Math.abs(Math.abs(t.coord - r.coord) - 360) < 1e-4 && e.pop();
}
var FOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.axisPointerClass = "PolarAxisPointer", r;
    }
    return t.prototype.render = function(r, n) {
      if (this.group.removeAll(), !!r.get("show")) {
        var i = r.axis, o = i.polar, a = o.getRadiusAxis().getExtent(), s = i.getTicksCoords(), l = i.getMinorTicksCoords(), u = Ee(i.getViewLabels(), function(c) {
          c = dt(c);
          var d = i.scale, h = d.type === "ordinal" ? d.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(h), c;
        });
        t$(u), t$(s), $(LOe, function(c) {
          r.get([c, "show"]) && (!i.scale.isBlank() || c === "axisLine") && NOe[c](this.group, r, o, s, l, a, u);
        }, this);
      }
    }, t.type = "angleAxis", t;
  }(dd)
), NOe = {
  axisLine: function(e, t, r, n, i, o) {
    var a = t.getModel(["axisLine", "lineStyle"]), s = r.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), c = Ry(r), d = c ? 0 : 1, h, f = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
    o[d] === 0 ? h = new od[f]({
      shape: {
        cx: r.cx,
        cy: r.cy,
        r: o[c],
        startAngle: -u[0] * l,
        endAngle: -u[1] * l,
        clockwise: s.inverse
      },
      style: a.getLineStyle(),
      z2: 1,
      silent: !0
    }) : h = new Vv({
      shape: {
        cx: r.cx,
        cy: r.cy,
        r: o[c],
        r0: o[d]
      },
      style: a.getLineStyle(),
      z2: 1,
      silent: !0
    }), h.style.fill = null, e.add(h);
  },
  axisTick: function(e, t, r, n, i, o) {
    var a = t.getModel("axisTick"), s = (a.get("inside") ? -1 : 1) * a.get("length"), l = o[Ry(r)], u = Ee(n, function(c) {
      return new Nn({
        shape: Ey(r, [l, l + s], c.coord)
      });
    });
    e.add(fo(u, {
      style: ut(a.getModel("lineStyle").getLineStyle(), {
        stroke: t.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(e, t, r, n, i, o) {
    if (i.length) {
      for (var a = t.getModel("axisTick"), s = t.getModel("minorTick"), l = (a.get("inside") ? -1 : 1) * s.get("length"), u = o[Ry(r)], c = [], d = 0; d < i.length; d++)
        for (var h = 0; h < i[d].length; h++)
          c.push(new Nn({
            shape: Ey(r, [u, u + l], i[d][h].coord)
          }));
      e.add(fo(c, {
        style: ut(s.getModel("lineStyle").getLineStyle(), ut(a.getLineStyle(), {
          stroke: t.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(e, t, r, n, i, o, a) {
    var s = t.getCategories(!0), l = t.getModel("axisLabel"), u = l.get("margin"), c = t.get("triggerEvent");
    $(a, function(d, h) {
      var f = l, p = d.tickValue, g = o[Ry(r)], v = r.coordToPoint([g + u, d.coord]), m = r.cx, y = r.cy, C = Math.abs(v[0] - m) / g < 0.3 ? "center" : v[0] > m ? "left" : "right", S = Math.abs(v[1] - y) / g < 0.3 ? "middle" : v[1] > y ? "top" : "bottom";
      if (s && s[p]) {
        var b = s[p];
        lt(b) && b.textStyle && (f = new _r(b.textStyle, l, l.ecModel));
      }
      var w = new ir({
        silent: Mi.isLabelSilent(t),
        style: Vr(f, {
          x: v[0],
          y: v[1],
          fill: f.getTextColor() || t.get(["axisLine", "lineStyle", "color"]),
          text: d.formattedLabel,
          align: C,
          verticalAlign: S
        })
      });
      if (e.add(w), c) {
        var x = Mi.makeAxisEventDataBase(t);
        x.targetType = "axisLabel", x.value = d.rawLabel, St(w).eventData = x;
      }
    }, this);
  },
  splitLine: function(e, t, r, n, i, o) {
    var a = t.getModel("splitLine"), s = a.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var c = [], d = 0; d < n.length; d++) {
      var h = u++ % l.length;
      c[h] = c[h] || [], c[h].push(new Nn({
        shape: Ey(r, o, n[d].coord)
      }));
    }
    for (var d = 0; d < c.length; d++)
      e.add(fo(c[d], {
        style: ut({
          stroke: l[d % l.length]
        }, s.getLineStyle()),
        silent: !0,
        z: t.get("z")
      }));
  },
  minorSplitLine: function(e, t, r, n, i, o) {
    if (i.length) {
      for (var a = t.getModel("minorSplitLine"), s = a.getModel("lineStyle"), l = [], u = 0; u < i.length; u++)
        for (var c = 0; c < i[u].length; c++)
          l.push(new Nn({
            shape: Ey(r, o, i[u][c].coord)
          }));
      e.add(fo(l, {
        style: s.getLineStyle(),
        silent: !0,
        z: t.get("z")
      }));
    }
  },
  splitArea: function(e, t, r, n, i, o) {
    if (n.length) {
      var a = t.getModel("splitArea"), s = a.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], d = Math.PI / 180, h = -n[0].coord * d, f = Math.min(o[0], o[1]), p = Math.max(o[0], o[1]), g = t.get("clockwise"), v = 1, m = n.length; v <= m; v++) {
        var y = v === m ? n[0].coord : n[v].coord, C = u++ % l.length;
        c[C] = c[C] || [], c[C].push(new Oi({
          shape: {
            cx: r.cx,
            cy: r.cy,
            r0: f,
            r: p,
            startAngle: h,
            endAngle: -y * d,
            clockwise: g
          },
          silent: !0
        })), h = -y * d;
      }
      for (var v = 0; v < c.length; v++)
        e.add(fo(c[v], {
          style: ut({
            fill: l[v % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
}, kOe = ["axisLine", "axisTickLabel", "axisName"], VOe = ["splitLine", "splitArea", "minorSplitLine"], BOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.axisPointerClass = "PolarAxisPointer", r;
    }
    return t.prototype.render = function(r, n) {
      if (this.group.removeAll(), !!r.get("show")) {
        var i = this._axisGroup, o = this._axisGroup = new Ct();
        this.group.add(o);
        var a = r.axis, s = a.polar, l = s.getAngleAxis(), u = a.getTicksCoords(), c = a.getMinorTicksCoords(), d = l.getExtent()[0], h = a.getExtent(), f = HOe(s, r, d), p = new Mi(r, f);
        $(kOe, p.add, p), o.add(p.getGroup()), Hv(i, o, r), $(VOe, function(g) {
          r.get([g, "show"]) && !a.scale.isBlank() && $Oe[g](this.group, r, s, d, h, u, c);
        }, this);
      }
    }, t.type = "radiusAxis", t;
  }(dd)
), $Oe = {
  splitLine: function(e, t, r, n, i, o) {
    var a = t.getModel("splitLine"), s = a.getModel("lineStyle"), l = s.get("color"), u = 0, c = r.getAngleAxis(), d = Math.PI / 180, h = c.getExtent(), f = Math.abs(h[1] - h[0]) === 360 ? "Circle" : "Arc";
    l = l instanceof Array ? l : [l];
    for (var p = [], g = 0; g < o.length; g++) {
      var v = u++ % l.length;
      p[v] = p[v] || [], p[v].push(new od[f]({
        shape: {
          cx: r.cx,
          cy: r.cy,
          // ensure circle radius >= 0
          r: Math.max(o[g].coord, 0),
          startAngle: -h[0] * d,
          endAngle: -h[1] * d,
          clockwise: c.inverse
        }
      }));
    }
    for (var g = 0; g < p.length; g++)
      e.add(fo(p[g], {
        style: ut({
          stroke: l[g % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(e, t, r, n, i, o, a) {
    if (a.length) {
      for (var s = t.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], c = 0; c < a.length; c++)
        for (var d = 0; d < a[c].length; d++)
          u.push(new ul({
            shape: {
              cx: r.cx,
              cy: r.cy,
              r: a[c][d].coord
            }
          }));
      e.add(fo(u, {
        style: ut({
          fill: null
        }, l.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(e, t, r, n, i, o) {
    if (o.length) {
      var a = t.getModel("splitArea"), s = a.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], d = o[0].coord, h = 1; h < o.length; h++) {
        var f = u++ % l.length;
        c[f] = c[f] || [], c[f].push(new Oi({
          shape: {
            cx: r.cx,
            cy: r.cy,
            r0: d,
            r: o[h].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), d = o[h].coord;
      }
      for (var h = 0; h < c.length; h++)
        e.add(fo(c[h], {
          style: ut({
            fill: l[h % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function HOe(e, t, r) {
  return {
    position: [e.cx, e.cy],
    rotation: r / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: t.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
function HK(e) {
  return e.get("stack") || "__ec_stack_" + e.seriesIndex;
}
function GK(e, t) {
  return t.dim + e.model.componentIndex;
}
function GOe(e, t, r) {
  var n = {}, i = zOe(Sr(t.getSeriesByType(e), function(o) {
    return !t.isSeriesFiltered(o) && o.coordinateSystem && o.coordinateSystem.type === "polar";
  }));
  t.eachSeriesByType(e, function(o) {
    if (o.coordinateSystem.type === "polar") {
      var a = o.getData(), s = o.coordinateSystem, l = s.getBaseAxis(), u = GK(s, l), c = HK(o), d = i[u][c], h = d.offset, f = d.width, p = s.getOtherAxis(l), g = o.coordinateSystem.cx, v = o.coordinateSystem.cy, m = o.get("barMinHeight") || 0, y = o.get("barMinAngle") || 0;
      n[c] = n[c] || [];
      for (var C = a.mapDimension(p.dim), S = a.mapDimension(l.dim), b = tl(
        a,
        C
        /* , baseDim */
      ), w = l.dim !== "radius" || !o.get("roundCap", !0), x = p.model, R = x.get("startValue"), _ = p.dataToCoord(R || 0), T = 0, P = a.count(); T < P; T++) {
        var D = a.get(C, T), O = a.get(S, T), A = D >= 0 ? "p" : "n", F = _;
        b && (n[c][O] || (n[c][O] = {
          p: _,
          n: _
          // Negative stack
        }), F = n[c][O][A]);
        var L = void 0, N = void 0, I = void 0, B = void 0;
        if (p.dim === "radius") {
          var M = p.dataToCoord(D) - _, V = l.dataToCoord(O);
          Math.abs(M) < m && (M = (M < 0 ? -1 : 1) * m), L = F, N = F + M, I = V - h, B = I - f, b && (n[c][O][A] = N);
        } else {
          var G = p.dataToCoord(D, w) - _, k = l.dataToCoord(O);
          Math.abs(G) < y && (G = (G < 0 ? -1 : 1) * y), L = k + h, N = L + f, I = F, B = F + G, b && (n[c][O][A] = B);
        }
        a.setItemLayout(T, {
          cx: g,
          cy: v,
          r0: L,
          r: N,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -I * Math.PI / 180,
          endAngle: -B * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: I >= B
        });
      }
    }
  });
}
function zOe(e) {
  var t = {};
  $(e, function(n, i) {
    var o = n.getData(), a = n.coordinateSystem, s = a.getBaseAxis(), l = GK(a, s), u = s.getExtent(), c = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / o.count(), d = t[l] || {
      bandWidth: c,
      remainedWidth: c,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, h = d.stacks;
    t[l] = d;
    var f = HK(n);
    h[f] || d.autoWidthCount++, h[f] = h[f] || {
      width: 0,
      maxWidth: 0
    };
    var p = Be(n.get("barWidth"), c), g = Be(n.get("barMaxWidth"), c), v = n.get("barGap"), m = n.get("barCategoryGap");
    p && !h[f].width && (p = Math.min(d.remainedWidth, p), h[f].width = p, d.remainedWidth -= p), g && (h[f].maxWidth = g), v != null && (d.gap = v), m != null && (d.categoryGap = m);
  });
  var r = {};
  return $(t, function(n, i) {
    r[i] = {};
    var o = n.stacks, a = n.bandWidth, s = Be(n.categoryGap, a), l = Be(n.gap, 1), u = n.remainedWidth, c = n.autoWidthCount, d = (u - s) / (c + (c - 1) * l);
    d = Math.max(d, 0), $(o, function(g, v) {
      var m = g.maxWidth;
      m && m < d && (m = Math.min(m, u), g.width && (m = Math.min(m, g.width)), u -= m, g.width = m, c--);
    }), d = (u - s) / (c + (c - 1) * l), d = Math.max(d, 0);
    var h = 0, f;
    $(o, function(g, v) {
      g.width || (g.width = d), f = g, h += g.width * (1 + l);
    }), f && (h -= f.width * l);
    var p = -h / 2;
    $(o, function(g, v) {
      r[i][v] = r[i][v] || {
        offset: p,
        width: g.width
      }, p += g.width * (1 + l);
    });
  }), r;
}
var WOe = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, jOe = {
  splitNumber: 5
}, UOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "polar", t;
  }(zr)
);
function KOe(e) {
  Bt(Jv), dd.registerAxisPointerClass("PolarAxisPointer", wOe), e.registerCoordinateSystem("polar", OOe), e.registerComponentModel(EOe), e.registerComponentView(UOe), Xh(e, "angle", ROe, WOe), Xh(e, "radius", _Oe, jOe), e.registerComponentView(FOe), e.registerComponentView(BOe), e.registerLayout(_t(GOe, "bar"));
}
function FT(e, t) {
  t = t || {};
  var r = e.coordinateSystem, n = e.axis, i = {}, o = n.position, a = n.orient, s = r.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = {
    horizontal: {
      top: l[2],
      bottom: l[3]
    },
    vertical: {
      left: l[0],
      right: l[1]
    }
  };
  i.position = [a === "vertical" ? u.vertical[o] : l[0], a === "horizontal" ? u.horizontal[o] : l[3]];
  var c = {
    horizontal: 0,
    vertical: 1
  };
  i.rotation = Math.PI / 2 * c[a];
  var d = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  i.labelDirection = i.tickDirection = i.nameDirection = d[o], e.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), vn(t.labelInside, e.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection);
  var h = t.rotate;
  return h == null && (h = e.get(["axisLabel", "rotate"])), i.labelRotation = o === "top" ? -h : h, i.z2 = 1, i;
}
var YOe = ["axisLine", "axisTickLabel", "axisName"], qOe = ["splitArea", "splitLine"], XOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.axisPointerClass = "SingleAxisPointer", r;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = this.group;
      a.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new Ct();
      var l = FT(r), u = new Mi(r, l);
      $(YOe, u.add, u), a.add(this._axisGroup), a.add(u.getGroup()), $(qOe, function(c) {
        r.get([c, "show"]) && ZOe[c](this, this.group, this._axisGroup, r);
      }, this), Hv(s, this._axisGroup, r), e.prototype.render.call(this, r, n, i, o);
    }, t.prototype.remove = function() {
      lU(this);
    }, t.type = "singleAxis", t;
  }(dd)
), ZOe = {
  splitLine: function(e, t, r, n) {
    var i = n.axis;
    if (!i.scale.isBlank()) {
      var o = n.getModel("splitLine"), a = o.getModel("lineStyle"), s = a.get("color");
      s = s instanceof Array ? s : [s];
      for (var l = a.get("width"), u = n.coordinateSystem.getRect(), c = i.isHorizontal(), d = [], h = 0, f = i.getTicksCoords({
        tickModel: o
      }), p = [], g = [], v = 0; v < f.length; ++v) {
        var m = i.toGlobalCoord(f[v].coord);
        c ? (p[0] = m, p[1] = u.y, g[0] = m, g[1] = u.y + u.height) : (p[0] = u.x, p[1] = m, g[0] = u.x + u.width, g[1] = m);
        var y = new Nn({
          shape: {
            x1: p[0],
            y1: p[1],
            x2: g[0],
            y2: g[1]
          },
          silent: !0
        });
        Uh(y.shape, l);
        var C = h++ % s.length;
        d[C] = d[C] || [], d[C].push(y);
      }
      for (var S = a.getLineStyle(["color"]), v = 0; v < d.length; ++v)
        t.add(fo(d[v], {
          style: ut({
            stroke: s[v % s.length]
          }, S),
          silent: !0
        }));
    }
  },
  splitArea: function(e, t, r, n) {
    sU(e, r, n, n);
  }
}, y0 = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getCoordSysModel = function() {
      return this;
    }, t.type = "singleAxis", t.layoutMode = "box", t.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, t;
  }(Vt)
);
cn(y0, Mf.prototype);
var QOe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i, o, a) {
      var s = e.call(this, r, n, i) || this;
      return s.type = o || "value", s.position = a || "bottom", s;
    }
    return t.prototype.isHorizontal = function() {
      var r = this.position;
      return r === "top" || r === "bottom";
    }, t.prototype.pointToData = function(r, n) {
      return this.coordinateSystem.pointToData(r)[0];
    }, t;
  }(sa)
), zK = ["single"], JOe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "single", this.dimension = "single", this.dimensions = zK, this.axisPointerEnabled = !0, this.model = t, this._init(t, r, n);
    }
    return e.prototype._init = function(t, r, n) {
      var i = this.dimension, o = new QOe(i, Wv(t), [0, 0], t.get("type"), t.get("position")), a = o.type === "category";
      o.onBand = a && t.get("boundaryGap"), o.inverse = t.get("inverse"), o.orient = t.get("orient"), t.axis = o, o.model = t, o.coordinateSystem = this, this._axis = o;
    }, e.prototype.update = function(t, r) {
      t.eachSeries(function(n) {
        if (n.coordinateSystem === this) {
          var i = n.getData();
          $(i.mapDimensionsAll(this.dimension), function(o) {
            this._axis.scale.unionExtentFromData(i, o);
          }, this), Kc(this._axis.scale, this._axis.model);
        }
      }, this);
    }, e.prototype.resize = function(t, r) {
      this._rect = En({
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      }, {
        width: r.getWidth(),
        height: r.getHeight()
      }), this._adjustAxis();
    }, e.prototype.getRect = function() {
      return this._rect;
    }, e.prototype._adjustAxis = function() {
      var t = this._rect, r = this._axis, n = r.isHorizontal(), i = n ? [0, t.width] : [0, t.height], o = r.inverse ? 1 : 0;
      r.setExtent(i[o], i[1 - o]), this._updateAxisTransform(r, n ? t.x : t.y);
    }, e.prototype._updateAxisTransform = function(t, r) {
      var n = t.getExtent(), i = n[0] + n[1], o = t.isHorizontal();
      t.toGlobalCoord = o ? function(a) {
        return a + r;
      } : function(a) {
        return i - a + r;
      }, t.toLocalCoord = o ? function(a) {
        return a - r;
      } : function(a) {
        return i - a + r;
      };
    }, e.prototype.getAxis = function() {
      return this._axis;
    }, e.prototype.getBaseAxis = function() {
      return this._axis;
    }, e.prototype.getAxes = function() {
      return [this._axis];
    }, e.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, e.prototype.containPoint = function(t) {
      var r = this.getRect(), n = this.getAxis(), i = n.orient;
      return i === "horizontal" ? n.contain(n.toLocalCoord(t[0])) && t[1] >= r.y && t[1] <= r.y + r.height : n.contain(n.toLocalCoord(t[1])) && t[0] >= r.y && t[0] <= r.y + r.height;
    }, e.prototype.pointToData = function(t) {
      var r = this.getAxis();
      return [r.coordToData(r.toLocalCoord(t[r.orient === "horizontal" ? 0 : 1]))];
    }, e.prototype.dataToPoint = function(t) {
      var r = this.getAxis(), n = this.getRect(), i = [], o = r.orient === "horizontal" ? 0 : 1;
      return t instanceof Array && (t = t[0]), i[o] = r.toGlobalCoord(r.dataToCoord(+t)), i[1 - o] = o === 0 ? n.y + n.height / 2 : n.x + n.width / 2, i;
    }, e.prototype.convertToPixel = function(t, r, n) {
      var i = r$(r);
      return i === this ? this.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      var i = r$(r);
      return i === this ? this.pointToData(n) : null;
    }, e;
  }()
);
function r$(e) {
  var t = e.seriesModel, r = e.singleAxisModel;
  return r && r.coordinateSystem || t && t.coordinateSystem;
}
function eLe(e, t) {
  var r = [];
  return e.eachComponent("singleAxis", function(n, i) {
    var o = new JOe(n, e, t);
    o.name = "single_" + i, o.resize(n, t), n.coordinateSystem = o, r.push(o);
  }), e.eachSeries(function(n) {
    if (n.get("coordinateSystem") === "singleAxis") {
      var i = n.getReferringComponents("singleAxis", bn).models[0];
      n.coordinateSystem = i && i.coordinateSystem;
    }
  }), r;
}
var tLe = {
  create: eLe,
  dimensions: zK
}, n$ = ["x", "y"], rLe = ["width", "height"], nLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(r, n, i, o, a) {
      var s = i.axis, l = s.coordinateSystem, u = Xx(l, 1 - zC(s)), c = l.dataToPoint(n)[0], d = o.get("type");
      if (d && d !== "none") {
        var h = LA(o), f = iLe[d](s, c, u);
        f.style = h, r.graphicKey = f.type, r.pointer = f;
      }
      var p = FT(i);
      NK(
        // @ts-ignore
        n,
        r,
        p,
        i,
        o,
        a
      );
    }, t.prototype.getHandleTransform = function(r, n, i) {
      var o = FT(n, {
        labelInside: !1
      });
      o.labelMargin = i.get(["handle", "margin"]);
      var a = FA(n.axis, r, o);
      return {
        x: a[0],
        y: a[1],
        rotation: o.rotation + (o.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(r, n, i, o) {
      var a = i.axis, s = a.coordinateSystem, l = zC(a), u = Xx(s, l), c = [r.x, r.y];
      c[l] += n[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var d = Xx(s, 1 - l), h = (d[1] + d[0]) / 2, f = [h, h];
      return f[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: r.rotation,
        cursorPoint: f,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, t;
  }(OA)
), iLe = {
  line: function(e, t, r) {
    var n = NA([t, r[0]], [t, r[1]], zC(e));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(e, t, r) {
    var n = e.getBandWidth(), i = r[1] - r[0];
    return {
      type: "Rect",
      shape: kK([t - n / 2, r[0]], [n, i], zC(e))
    };
  }
};
function zC(e) {
  return e.isHorizontal() ? 0 : 1;
}
function Xx(e, t) {
  var r = e.getRect();
  return [r[n$[t]], r[n$[t]] + r[rLe[t]]];
}
var oLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "single", t;
  }(zr)
);
function aLe(e) {
  Bt(Jv), dd.registerAxisPointerClass("SingleAxisPointer", nLe), e.registerComponentView(oLe), e.registerComponentView(XOe), e.registerComponentModel(y0), Xh(e, "single", y0, y0.defaultOption), e.registerCoordinateSystem("single", tLe);
}
var sLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n, i) {
      var o = bf(r);
      e.prototype.init.apply(this, arguments), i$(r, o);
    }, t.prototype.mergeOption = function(r) {
      e.prototype.mergeOption.apply(this, arguments), i$(this.option, r);
    }, t.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, t.type = "calendar", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: "50%",
        color: "#000"
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: 5,
        // center or left
        align: "center",
        formatter: null,
        color: "#000"
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, t;
  }(Vt)
);
function i$(e, t) {
  var r = e.cellSize, n;
  be(r) ? n = r : n = e.cellSize = [r, r], n.length === 1 && (n[1] = n[0]);
  var i = Ee([0, 1], function(o) {
    return sbe(t, o) && (n[o] = "auto"), n[o] != null && n[o] !== "auto";
  });
  su(e, t, {
    type: "box",
    ignoreSize: i
  });
}
var lLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = this.group;
      o.removeAll();
      var a = r.coordinateSystem, s = a.getRangeInfo(), l = a.getOrient(), u = n.getLocaleModel();
      this._renderDayRect(r, s, o), this._renderLines(r, s, l, o), this._renderYearText(r, s, l, o), this._renderMonthText(r, u, l, o), this._renderWeekText(r, u, s, l, o);
    }, t.prototype._renderDayRect = function(r, n, i) {
      for (var o = r.coordinateSystem, a = r.getModel("itemStyle").getItemStyle(), s = o.getCellWidth(), l = o.getCellHeight(), u = n.start.time; u <= n.end.time; u = o.getNextNDay(u, 1).time) {
        var c = o.dataToRect([u], !1).tl, d = new or({
          shape: {
            x: c[0],
            y: c[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: a
        });
        i.add(d);
      }
    }, t.prototype._renderLines = function(r, n, i, o) {
      var a = this, s = r.coordinateSystem, l = r.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = r.get(["splitLine", "show"]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var d = n.start, h = 0; d.time <= n.end.time; h++) {
        p(d.formatedDate), h === 0 && (d = s.getDateInfo(n.start.y + "-" + n.start.m));
        var f = d.date;
        f.setMonth(f.getMonth() + 1), d = s.getDateInfo(f);
      }
      p(s.getNextNDay(n.end.time, 1).formatedDate);
      function p(g) {
        a._firstDayOfMonth.push(s.getDateInfo(g)), a._firstDayPoints.push(s.dataToRect([g], !1).tl);
        var v = a._getLinePointsOfOneWeek(r, g, i);
        a._tlpoints.push(v[0]), a._blpoints.push(v[v.length - 1]), u && a._drawSplitline(v, l, o);
      }
      u && this._drawSplitline(a._getEdgesPoints(a._tlpoints, c, i), l, o), u && this._drawSplitline(a._getEdgesPoints(a._blpoints, c, i), l, o);
    }, t.prototype._getEdgesPoints = function(r, n, i) {
      var o = [r[0].slice(), r[r.length - 1].slice()], a = i === "horizontal" ? 0 : 1;
      return o[0][a] = o[0][a] - n / 2, o[1][a] = o[1][a] + n / 2, o;
    }, t.prototype._drawSplitline = function(r, n, i) {
      var o = new Ni({
        z2: 20,
        shape: {
          points: r
        },
        style: n
      });
      i.add(o);
    }, t.prototype._getLinePointsOfOneWeek = function(r, n, i) {
      for (var o = r.coordinateSystem, a = o.getDateInfo(n), s = [], l = 0; l < 7; l++) {
        var u = o.getNextNDay(a.time, l), c = o.dataToRect([u.time], !1);
        s[2 * u.day] = c.tl, s[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, t.prototype._formatterLabel = function(r, n) {
      return He(r) && r ? nbe(r, n) : at(r) ? r(n) : n.nameMap;
    }, t.prototype._yearTextPositionControl = function(r, n, i, o, a) {
      var s = n[0], l = n[1], u = ["center", "bottom"];
      o === "bottom" ? (l += a, u = ["center", "top"]) : o === "left" ? s -= a : o === "right" ? (s += a, u = ["center", "top"]) : l -= a;
      var c = 0;
      return (o === "left" || o === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, t.prototype._renderYearText = function(r, n, i, o) {
      var a = r.getModel("yearLabel");
      if (a.get("show")) {
        var s = a.get("margin"), l = a.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], c = (u[0][0] + u[1][0]) / 2, d = (u[0][1] + u[1][1]) / 2, h = i === "horizontal" ? 0 : 1, f = {
          top: [c, u[h][1]],
          bottom: [c, u[1 - h][1]],
          left: [u[1 - h][0], d],
          right: [u[h][0], d]
        }, p = n.start.y;
        +n.end.y > +n.start.y && (p = p + "-" + n.end.y);
        var g = a.get("formatter"), v = {
          start: n.start.y,
          end: n.end.y,
          nameMap: p
        }, m = this._formatterLabel(g, v), y = new ir({
          z2: 30,
          style: Vr(a, {
            text: m
          })
        });
        y.attr(this._yearTextPositionControl(y, f[l], i, l, s)), o.add(y);
      }
    }, t.prototype._monthTextPositionControl = function(r, n, i, o, a) {
      var s = "left", l = "top", u = r[0], c = r[1];
      return i === "horizontal" ? (c = c + a, n && (s = "center"), o === "start" && (l = "bottom")) : (u = u + a, n && (l = "middle"), o === "start" && (s = "right")), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, t.prototype._renderMonthText = function(r, n, i, o) {
      var a = r.getModel("monthLabel");
      if (a.get("show")) {
        var s = a.get("nameMap"), l = a.get("margin"), u = a.get("position"), c = a.get("align"), d = [this._tlpoints, this._blpoints];
        (!s || He(s)) && (s && (n = z_(s) || n), s = n.get(["time", "monthAbbr"]) || []);
        var h = u === "start" ? 0 : 1, f = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", g = 0; g < d[h].length - 1; g++) {
          var v = d[h][g].slice(), m = this._firstDayOfMonth[g];
          if (p) {
            var y = this._firstDayPoints[g];
            v[f] = (y[f] + d[0][g + 1][f]) / 2;
          }
          var C = a.get("formatter"), S = s[+m.m - 1], b = {
            yyyy: m.y,
            yy: (m.y + "").slice(2),
            MM: m.m,
            M: +m.m,
            nameMap: S
          }, w = this._formatterLabel(C, b), x = new ir({
            z2: 30,
            style: ge(Vr(a, {
              text: w
            }), this._monthTextPositionControl(v, p, i, u, l))
          });
          o.add(x);
        }
      }
    }, t.prototype._weekTextPositionControl = function(r, n, i, o, a) {
      var s = "center", l = "middle", u = r[0], c = r[1], d = i === "start";
      return n === "horizontal" ? (u = u + o + (d ? 1 : -1) * a[0] / 2, s = d ? "right" : "left") : (c = c + o + (d ? 1 : -1) * a[1] / 2, l = d ? "bottom" : "top"), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, t.prototype._renderWeekText = function(r, n, i, o, a) {
      var s = r.getModel("dayLabel");
      if (s.get("show")) {
        var l = r.coordinateSystem, u = s.get("position"), c = s.get("nameMap"), d = s.get("margin"), h = l.getFirstDayOfWeek();
        if (!c || He(c)) {
          c && (n = z_(c) || n);
          var f = n.get(["time", "dayOfWeekShort"]);
          c = f || Ee(n.get(["time", "dayOfWeekAbbr"]), function(b) {
            return b[0];
          });
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, g = [l.getCellWidth(), l.getCellHeight()];
        d = Be(d, Math.min(g[1], g[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, d = -d);
        for (var v = 0; v < 7; v++) {
          var m = l.getNextNDay(p, v), y = l.dataToRect([m.time], !1).center, C = v;
          C = Math.abs((v + h) % 7);
          var S = new ir({
            z2: 30,
            style: ge(Vr(s, {
              text: c[C]
            }), this._weekTextPositionControl(y, o, u, d, g))
          });
          a.add(S);
        }
      }
    }, t.type = "calendar", t;
  }(zr)
), Zx = 864e5, uLe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "calendar", this.dimensions = e.dimensions, this.getDimensionsInfo = e.getDimensionsInfo, this._model = t;
    }
    return e.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, e.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getRect = function() {
      return this._rect;
    }, e.prototype.getCellWidth = function() {
      return this._sw;
    }, e.prototype.getCellHeight = function() {
      return this._sh;
    }, e.prototype.getOrient = function() {
      return this._orient;
    }, e.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, e.prototype.getDateInfo = function(t) {
      t = bo(t);
      var r = t.getFullYear(), n = t.getMonth() + 1, i = n < 10 ? "0" + n : "" + n, o = t.getDate(), a = o < 10 ? "0" + o : "" + o, s = t.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: r + "",
        m: i,
        d: a,
        day: s,
        time: t.getTime(),
        formatedDate: r + "-" + i + "-" + a,
        date: t
      };
    }, e.prototype.getNextNDay = function(t, r) {
      return r = r || 0, r === 0 ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + r), this.getDateInfo(t));
    }, e.prototype.update = function(t, r) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var n = this._rangeInfo.weeks || 1, i = ["width", "height"], o = this._model.getCellSize().slice(), a = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [n, 7] : [7, n];
      $([0, 1], function(d) {
        c(o, d) && (a[i[d]] = o[d] * s[d]);
      });
      var l = {
        width: r.getWidth(),
        height: r.getHeight()
      }, u = this._rect = En(a, l);
      $([0, 1], function(d) {
        c(o, d) || (o[d] = u[i[d]] / s[d]);
      });
      function c(d, h) {
        return d[h] != null && d[h] !== "auto";
      }
      this._sw = o[0], this._sh = o[1];
    }, e.prototype.dataToPoint = function(t, r) {
      be(t) && (t = t[0]), r == null && (r = !0);
      var n = this.getDateInfo(t), i = this._rangeInfo, o = n.formatedDate;
      if (r && !(n.time >= i.start.time && n.time < i.end.time + Zx))
        return [NaN, NaN];
      var a = n.day, s = this._getRangeInfo([i.start.time, o]).nthWeek;
      return this._orient === "vertical" ? [this._rect.x + a * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + a * this._sh + this._sh / 2];
    }, e.prototype.pointToData = function(t) {
      var r = this.pointToDate(t);
      return r && r.time;
    }, e.prototype.dataToRect = function(t, r) {
      var n = this.dataToPoint(t, r);
      return {
        contentShape: {
          x: n[0] - (this._sw - this._lineWidth) / 2,
          y: n[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: n,
        tl: [n[0] - this._sw / 2, n[1] - this._sh / 2],
        tr: [n[0] + this._sw / 2, n[1] - this._sh / 2],
        br: [n[0] + this._sw / 2, n[1] + this._sh / 2],
        bl: [n[0] - this._sw / 2, n[1] + this._sh / 2]
      };
    }, e.prototype.pointToDate = function(t) {
      var r = Math.floor((t[0] - this._rect.x) / this._sw) + 1, n = Math.floor((t[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(n, r - 1, i) : this._getDateByWeeksAndDay(r, n - 1, i);
    }, e.prototype.convertToPixel = function(t, r, n) {
      var i = o$(r);
      return i === this ? i.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      var i = o$(r);
      return i === this ? i.pointToData(n) : null;
    }, e.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), !1;
    }, e.prototype._initRangeOption = function() {
      var t = this._model.get("range"), r;
      if (be(t) && t.length === 1 && (t = t[0]), be(t))
        r = t;
      else {
        var n = t.toString();
        if (/^\d{4}$/.test(n) && (r = [n + "-01-01", n + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(n)) {
          var i = this.getDateInfo(n), o = i.date;
          o.setMonth(o.getMonth() + 1);
          var a = this.getNextNDay(o, -1);
          r = [i.formatedDate, a.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n) && (r = [n, n]);
      }
      if (!r)
        return process.env.NODE_ENV !== "production" && Ko("Invalid date range."), t;
      var s = this._getRangeInfo(r);
      return s.start.time > s.end.time && r.reverse(), r;
    }, e.prototype._getRangeInfo = function(t) {
      var r = [this.getDateInfo(t[0]), this.getDateInfo(t[1])], n;
      r[0].time > r[1].time && (n = !0, r.reverse());
      var i = Math.floor(r[1].time / Zx) - Math.floor(r[0].time / Zx) + 1, o = new Date(r[0].time), a = o.getDate(), s = r[1].date.getDate();
      o.setDate(a + i - 1);
      var l = o.getDate();
      if (l !== s)
        for (var u = o.getTime() - r[1].time > 0 ? 1 : -1; (l = o.getDate()) !== s && (o.getTime() - r[1].time) * u > 0; )
          i -= u, o.setDate(l - u);
      var c = Math.floor((i + r[0].day + 6) / 7), d = n ? -c + 1 : c - 1;
      return n && r.reverse(), {
        range: [r[0].formatedDate, r[1].formatedDate],
        start: r[0],
        end: r[1],
        allDay: i,
        weeks: c,
        // From 0.
        nthWeek: d,
        fweek: r[0].day,
        lweek: r[1].day
      };
    }, e.prototype._getDateByWeeksAndDay = function(t, r, n) {
      var i = this._getRangeInfo(n);
      if (t > i.weeks || t === 0 && r < i.fweek || t === i.weeks && r > i.lweek)
        return null;
      var o = (t - 1) * 7 - i.fweek + r, a = new Date(i.start.time);
      return a.setDate(+i.start.d + o), this.getDateInfo(a);
    }, e.create = function(t, r) {
      var n = [];
      return t.eachComponent("calendar", function(i) {
        var o = new e(i);
        n.push(o), i.coordinateSystem = o;
      }), t.eachSeries(function(i) {
        i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = n[i.get("calendarIndex") || 0]);
      }), n;
    }, e.dimensions = ["time", "value"], e;
  }()
);
function o$(e) {
  var t = e.calendarModel, r = e.seriesModel, n = t ? t.coordinateSystem : r ? r.coordinateSystem : null;
  return n;
}
function cLe(e) {
  e.registerComponentModel(sLe), e.registerComponentView(lLe), e.registerCoordinateSystem("calendar", uLe);
}
function dLe(e, t) {
  var r = e.existing;
  if (t.id = e.keyInfo.id, !t.type && r && (t.type = r.type), t.parentId == null) {
    var n = t.parentOption;
    n ? t.parentId = n.id : r && (t.parentId = r.parentId);
  }
  t.parentOption = null;
}
function a$(e, t) {
  var r;
  return $(t, function(n) {
    e[n] != null && e[n] !== "auto" && (r = !0);
  }), r;
}
function hLe(e, t, r) {
  var n = ge({}, r), i = e[t], o = r.$action || "merge";
  if (o === "merge")
    if (i) {
      if (process.env.NODE_ENV !== "production") {
        var a = r.type;
        ct(!a || i.type === a, 'Please set $action: "replace" to change `type`');
      }
      Mt(i, n, !0), su(i, n, {
        ignoreSize: !0
      }), O7(r, i), _y(r, i), _y(r, i, "shape"), _y(r, i, "style"), _y(r, i, "extra"), r.clipPath = i.clipPath;
    } else
      e[t] = n;
  else o === "replace" ? e[t] = n : o === "remove" && i && (e[t] = null);
}
var WK = ["transition", "enterFrom", "leaveTo"], fLe = WK.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function _y(e, t, r) {
  if (r && (!e[r] && t[r] && (e[r] = {}), e = e[r], t = t[r]), !(!e || !t))
    for (var n = r ? WK : fLe, i = 0; i < n.length; i++) {
      var o = n[i];
      e[o] == null && t[o] != null && (e[o] = t[o]);
    }
}
function pLe(e, t) {
  if (e && (e.hv = t.hv = [
    // Rigid body, don't care about `width`.
    a$(t, ["left", "right"]),
    // Rigid body, don't care about `height`.
    a$(t, ["top", "bottom"])
  ], e.type === "group")) {
    var r = e, n = t;
    r.width == null && (r.width = n.width = 0), r.height == null && (r.height = n.height = 0);
  }
}
var gLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.preventAutoZ = !0, r;
    }
    return t.prototype.mergeOption = function(r, n) {
      var i = this.option.elements;
      this.option.elements = null, e.prototype.mergeOption.call(this, r, n), this.option.elements = i;
    }, t.prototype.optionUpdated = function(r, n) {
      var i = this.option, o = (n ? i : r).elements, a = i.elements = n ? [] : i.elements, s = [];
      this._flatten(o, s, null);
      var l = CW(a, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      $(l, function(c, d) {
        var h = c.newOption;
        process.env.NODE_ENV !== "production" && ct(lt(h) || c.existing, "Empty graphic option definition"), h && (u.push(h), dLe(c, h), hLe(a, d, h), pLe(a[d], h));
      }, this), i.elements = Sr(a, function(c) {
        return c && delete c.$action, c != null;
      });
    }, t.prototype._flatten = function(r, n, i) {
      $(r, function(o) {
        if (o) {
          i && (o.parentOption = i), n.push(o);
          var a = o.children;
          a && a.length && this._flatten(a, n, o), delete o.children;
        }
      }, this);
    }, t.prototype.useElOptionsToUpdate = function() {
      var r = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, r;
    }, t.type = "graphic", t.defaultOption = {
      elements: []
      // parentId: null
    }, t;
  }(Vt)
), s$ = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: Ct,
  image: qn,
  text: ir
}, Bo = ar(), vLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function() {
      this._elMap = nt();
    }, t.prototype.render = function(r, n, i) {
      r !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = r, this._updateElements(r), this._relocate(r, i);
    }, t.prototype._updateElements = function(r) {
      var n = r.useElOptionsToUpdate();
      if (n) {
        var i = this._elMap, o = this.group, a = r.get("z"), s = r.get("zlevel");
        $(n, function(l) {
          var u = In(l.id, null), c = u != null ? i.get(u) : null, d = In(l.parentId, null), h = d != null ? i.get(d) : o, f = l.type, p = l.style;
          f === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var g = l.textContent, v = l.textConfig;
          if (p && xK(p, f, !!v, !!g)) {
            var m = EK(p, f, !0);
            !v && m.textConfig && (v = l.textConfig = m.textConfig), !g && m.textContent && (g = m.textContent);
          }
          var y = mLe(l);
          process.env.NODE_ENV !== "production" && c && ct(h === c.parent, "Changing parent is not supported.");
          var C = l.$action || "merge", S = C === "merge", b = C === "replace";
          if (S) {
            var w = !c, x = c;
            w ? x = l$(u, h, l.type, i) : (x && (Bo(x).isNew = !1), MK(x)), x && (v0(x, y, r, {
              isInit: w
            }), u$(x, l, a, s));
          } else if (b) {
            C0(c, l, i, r);
            var R = l$(u, h, l.type, i);
            R && (v0(R, y, r, {
              isInit: !0
            }), u$(R, l, a, s));
          } else C === "remove" && (_K(c, l), C0(c, l, i, r));
          var _ = i.get(u);
          if (_ && g)
            if (S) {
              var T = _.getTextContent();
              T ? T.attr(g) : _.setTextContent(new ir(g));
            } else b && _.setTextContent(new ir(g));
          if (_) {
            var P = l.clipPath;
            if (P) {
              var D = P.type, O = void 0, w = !1;
              if (S) {
                var A = _.getClipPath();
                w = !A || Bo(A).type !== D, O = w ? NT(D) : A;
              } else b && (w = !0, O = NT(D));
              _.setClipPath(O), v0(O, P, r, {
                isInit: w
              }), $C(O, P.keyframeAnimation, r);
            }
            var F = Bo(_);
            _.setTextConfig(v), F.option = l, yLe(_, r, l), Cf({
              el: _,
              componentModel: r,
              itemName: _.name,
              itemTooltipOption: l.tooltip
            }), $C(_, l.keyframeAnimation, r);
          }
        });
      }
    }, t.prototype._relocate = function(r, n) {
      for (var i = r.option.elements, o = this.group, a = this._elMap, s = n.getWidth(), l = n.getHeight(), u = ["x", "y"], c = 0; c < i.length; c++) {
        var d = i[c], h = In(d.id, null), f = h != null ? a.get(h) : null;
        if (!(!f || !f.isGroup)) {
          var p = f.parent, g = p === o, v = Bo(f), m = Bo(p);
          v.width = Be(v.option.width, g ? s : m.width) || 0, v.height = Be(v.option.height, g ? l : m.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var d = i[c], h = In(d.id, null), f = h != null ? a.get(h) : null;
        if (f) {
          var p = f.parent, m = Bo(p), y = p === o ? {
            width: s,
            height: l
          } : {
            width: m.width,
            height: m.height
          }, C = {}, S = gw(f, d, y, null, {
            hv: d.hv,
            boundingMode: d.bounding
          }, C);
          if (!Bo(f).isNew && S) {
            for (var b = d.transition, w = {}, x = 0; x < u.length; x++) {
              var R = u[x], _ = C[R];
              b && (Ic(b) || Ft(b, R) >= 0) ? w[R] = _ : f[R] = _;
            }
            ur(f, w, r, 0);
          } else
            f.attr(C);
        }
      }
    }, t.prototype._clear = function() {
      var r = this, n = this._elMap;
      n.each(function(i) {
        C0(i, Bo(i).option, n, r._lastGraphicModel);
      }), this._elMap = nt();
    }, t.prototype.dispose = function() {
      this._clear();
    }, t.type = "graphic", t;
  }(zr)
);
function NT(e) {
  process.env.NODE_ENV !== "production" && ct(e, "graphic type MUST be set");
  var t = Ye(s$, e) ? s$[e] : lw(e);
  process.env.NODE_ENV !== "production" && ct(t, "graphic type " + e + " can not be found");
  var r = new t({});
  return Bo(r).type = e, r;
}
function l$(e, t, r, n) {
  var i = NT(r);
  return t.add(i), n.set(e, i), Bo(i).id = e, Bo(i).isNew = !0, i;
}
function C0(e, t, r, n) {
  var i = e && e.parent;
  i && (e.type === "group" && e.traverse(function(o) {
    C0(o, t, r, n);
  }), Iw(e, t, n), r.removeKey(Bo(e).id));
}
function u$(e, t, r, n) {
  e.isGroup || $([
    ["cursor", ta.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", n || 0],
    ["z", r || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(i) {
    var o = i[0];
    Ye(t, o) ? e[o] = bt(t[o], i[1]) : e[o] == null && (e[o] = i[1]);
  }), $(jt(t), function(i) {
    if (i.indexOf("on") === 0) {
      var o = t[i];
      e[i] = at(o) ? o : null;
    }
  }), Ye(t, "draggable") && (e.draggable = t.draggable), t.name != null && (e.name = t.name), t.id != null && (e.id = t.id);
}
function mLe(e) {
  return e = ge({}, e), $(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(I7), function(t) {
    delete e[t];
  }), e;
}
function yLe(e, t, r) {
  var n = St(e).eventData;
  !e.silent && !e.ignore && !n && (n = St(e).eventData = {
    componentType: "graphic",
    componentIndex: t.componentIndex,
    name: e.name
  }), n && (n.info = r.info);
}
function CLe(e) {
  e.registerComponentModel(gLe), e.registerComponentView(vLe), e.registerPreprocessor(function(t) {
    var r = t.graphic;
    be(r) ? !r[0] || !r[0].elements ? t.graphic = [{
      elements: r
    }] : t.graphic = [t.graphic[0]] : r && !r.elements && (t.graphic = [{
      elements: [r]
    }]);
  });
}
var c$ = ["x", "y", "radius", "angle", "single"], SLe = ["cartesian2d", "polar", "singleAxis"];
function wLe(e) {
  var t = e.get("coordinateSystem");
  return Ft(SLe, t) >= 0;
}
function Bl(e) {
  return process.env.NODE_ENV !== "production" && ct(e), e + "Axis";
}
function bLe(e, t) {
  var r = nt(), n = [], i = nt();
  e.eachComponent({
    mainType: "dataZoom",
    query: t
  }, function(c) {
    i.get(c.uid) || s(c);
  });
  var o;
  do
    o = !1, e.eachComponent("dataZoom", a);
  while (o);
  function a(c) {
    !i.get(c.uid) && l(c) && (s(c), o = !0);
  }
  function s(c) {
    i.set(c.uid, !0), n.push(c), u(c);
  }
  function l(c) {
    var d = !1;
    return c.eachTargetAxis(function(h, f) {
      var p = r.get(h);
      p && p[f] && (d = !0);
    }), d;
  }
  function u(c) {
    c.eachTargetAxis(function(d, h) {
      (r.get(d) || r.set(d, []))[h] = !0;
    });
  }
  return n;
}
function jK(e) {
  var t = e.ecModel, r = {
    infoList: [],
    infoMap: nt()
  };
  return e.eachTargetAxis(function(n, i) {
    var o = t.getComponent(Bl(n), i);
    if (o) {
      var a = o.getCoordSysModel();
      if (a) {
        var s = a.uid, l = r.infoMap.get(s);
        l || (l = {
          model: a,
          axisModels: []
        }, r.infoList.push(l), r.infoMap.set(s, l)), l.axisModels.push(o);
      }
    }
  }), r;
}
var Qx = (
  /** @class */
  function() {
    function e() {
      this.indexList = [], this.indexMap = [];
    }
    return e.prototype.add = function(t) {
      this.indexMap[t] || (this.indexList.push(t), this.indexMap[t] = !0);
    }, e;
  }()
), uv = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._autoThrottle = !0, r._noTarget = !0, r._rangePropMode = ["percent", "percent"], r;
    }
    return t.prototype.init = function(r, n, i) {
      var o = d$(r);
      this.settledOption = o, this.mergeDefaultAndTheme(r, i), this._doInit(o);
    }, t.prototype.mergeOption = function(r) {
      var n = d$(r);
      Mt(this.option, r, !0), Mt(this.settledOption, n, !0), this._doInit(n);
    }, t.prototype._doInit = function(r) {
      var n = this.option;
      this._setDefaultThrottle(r), this._updateRangeUse(r);
      var i = this.settledOption;
      $([["start", "startValue"], ["end", "endValue"]], function(o, a) {
        this._rangePropMode[a] === "value" && (n[o[0]] = i[o[0]] = null);
      }, this), this._resetTarget();
    }, t.prototype._resetTarget = function() {
      var r = this.get("orient", !0), n = this._targetAxisInfoMap = nt(), i = this._fillSpecifiedTargetAxis(n);
      i ? this._orient = r || this._makeAutoOrientByTargetAxis() : (this._orient = r || "horizontal", this._fillAutoTargetAxisByOrient(n, this._orient)), this._noTarget = !0, n.each(function(o) {
        o.indexList.length && (this._noTarget = !1);
      }, this);
    }, t.prototype._fillSpecifiedTargetAxis = function(r) {
      var n = !1;
      return $(c$, function(i) {
        var o = this.getReferringComponents(Bl(i), WCe);
        if (o.specified) {
          n = !0;
          var a = new Qx();
          $(o.models, function(s) {
            a.add(s.componentIndex);
          }), r.set(i, a);
        }
      }, this), n;
    }, t.prototype._fillAutoTargetAxisByOrient = function(r, n) {
      var i = this.ecModel, o = !0;
      if (o) {
        var a = n === "vertical" ? "y" : "x", s = i.findComponents({
          mainType: a + "Axis"
        });
        l(s, a);
      }
      if (o) {
        var s = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", !0) === n;
          }
        });
        l(s, "single");
      }
      function l(u, c) {
        var d = u[0];
        if (d) {
          var h = new Qx();
          if (h.add(d.componentIndex), r.set(c, h), o = !1, c === "x" || c === "y") {
            var f = d.getReferringComponents("grid", bn).models[0];
            f && $(u, function(p) {
              d.componentIndex !== p.componentIndex && f === p.getReferringComponents("grid", bn).models[0] && h.add(p.componentIndex);
            });
          }
        }
      }
      o && $(c$, function(u) {
        if (o) {
          var c = i.findComponents({
            mainType: Bl(u),
            filter: function(h) {
              return h.get("type", !0) === "category";
            }
          });
          if (c[0]) {
            var d = new Qx();
            d.add(c[0].componentIndex), r.set(u, d), o = !1;
          }
        }
      }, this);
    }, t.prototype._makeAutoOrientByTargetAxis = function() {
      var r;
      return this.eachTargetAxis(function(n) {
        !r && (r = n);
      }, this), r === "y" ? "vertical" : "horizontal";
    }, t.prototype._setDefaultThrottle = function(r) {
      if (r.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var n = this.ecModel.option;
        this.option.throttle = n.animation && n.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, t.prototype._updateRangeUse = function(r) {
      var n = this._rangePropMode, i = this.get("rangeMode");
      $([["start", "startValue"], ["end", "endValue"]], function(o, a) {
        var s = r[o[0]] != null, l = r[o[1]] != null;
        s && !l ? n[a] = "percent" : !s && l ? n[a] = "value" : i ? n[a] = i[a] : s && (n[a] = "percent");
      });
    }, t.prototype.noTarget = function() {
      return this._noTarget;
    }, t.prototype.getFirstTargetAxisModel = function() {
      var r;
      return this.eachTargetAxis(function(n, i) {
        r == null && (r = this.ecModel.getComponent(Bl(n), i));
      }, this), r;
    }, t.prototype.eachTargetAxis = function(r, n) {
      this._targetAxisInfoMap.each(function(i, o) {
        $(i.indexList, function(a) {
          r.call(n, o, a);
        });
      });
    }, t.prototype.getAxisProxy = function(r, n) {
      var i = this.getAxisModel(r, n);
      if (i)
        return i.__dzAxisProxy;
    }, t.prototype.getAxisModel = function(r, n) {
      process.env.NODE_ENV !== "production" && ct(r && n != null);
      var i = this._targetAxisInfoMap.get(r);
      if (i && i.indexMap[n])
        return this.ecModel.getComponent(Bl(r), n);
    }, t.prototype.setRawRange = function(r) {
      var n = this.option, i = this.settledOption;
      $([["start", "startValue"], ["end", "endValue"]], function(o) {
        (r[o[0]] != null || r[o[1]] != null) && (n[o[0]] = i[o[0]] = r[o[0]], n[o[1]] = i[o[1]] = r[o[1]]);
      }, this), this._updateRangeUse(r);
    }, t.prototype.setCalculatedRange = function(r) {
      var n = this.option;
      $(["start", "startValue", "end", "endValue"], function(i) {
        n[i] = r[i];
      });
    }, t.prototype.getPercentRange = function() {
      var r = this.findRepresentativeAxisProxy();
      if (r)
        return r.getDataPercentWindow();
    }, t.prototype.getValueRange = function(r, n) {
      if (r == null && n == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i)
          return i.getDataValueWindow();
      } else
        return this.getAxisProxy(r, n).getDataValueWindow();
    }, t.prototype.findRepresentativeAxisProxy = function(r) {
      if (r)
        return r.__dzAxisProxy;
      for (var n, i = this._targetAxisInfoMap.keys(), o = 0; o < i.length; o++)
        for (var a = i[o], s = this._targetAxisInfoMap.get(a), l = 0; l < s.indexList.length; l++) {
          var u = this.getAxisProxy(a, s.indexList[l]);
          if (u.hostedBy(this))
            return u;
          n || (n = u);
        }
      return n;
    }, t.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, t.prototype.getOrient = function() {
      return process.env.NODE_ENV !== "production" && ct(this._orient), this._orient;
    }, t.type = "dataZoom", t.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], t.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, t;
  }(Vt)
);
function d$(e) {
  var t = {};
  return $(["start", "end", "startValue", "endValue", "throttle"], function(r) {
    e.hasOwnProperty(r) && (t[r] = e[r]);
  }), t;
}
var xLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "dataZoom.select", t;
  }(uv)
), $A = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this.dataZoomModel = r, this.ecModel = n, this.api = i;
    }, t.type = "dataZoom", t;
  }(zr)
), ELe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "dataZoom.select", t;
  }($A)
), ah = $, h$ = vo, RLe = (
  /** @class */
  function() {
    function e(t, r, n, i) {
      this._dimName = t, this._axisIndex = r, this.ecModel = i, this._dataZoomModel = n;
    }
    return e.prototype.hostedBy = function(t) {
      return this._dataZoomModel === t;
    }, e.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, e.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, e.prototype.getTargetSeriesModels = function() {
      var t = [];
      return this.ecModel.eachSeries(function(r) {
        if (wLe(r)) {
          var n = Bl(this._dimName), i = r.getReferringComponents(n, bn).models[0];
          i && this._axisIndex === i.componentIndex && t.push(r);
        }
      }, this), t;
    }, e.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, e.prototype.getMinMaxSpan = function() {
      return dt(this._minMaxSpan);
    }, e.prototype.calculateDataWindow = function(t) {
      var r = this._dataExtent, n = this.getAxisModel(), i = n.axis.scale, o = this._dataZoomModel.getRangePropMode(), a = [0, 100], s = [], l = [], u;
      ah(["start", "end"], function(h, f) {
        var p = t[h], g = t[h + "Value"];
        o[f] === "percent" ? (p == null && (p = a[f]), g = i.parse(Cr(p, a, r))) : (u = !0, g = g == null ? r[f] : i.parse(g), p = Cr(g, r, a)), l[f] = g == null || isNaN(g) ? r[f] : g, s[f] = p == null || isNaN(p) ? a[f] : p;
      }), h$(l), h$(s);
      var c = this._minMaxSpan;
      u ? d(l, s, r, a, !1) : d(s, l, a, r, !0);
      function d(h, f, p, g, v) {
        var m = v ? "Span" : "ValueSpan";
        hd(0, h, p, "all", c["min" + m], c["max" + m]);
        for (var y = 0; y < 2; y++)
          f[y] = Cr(h[y], p, g, !0), v && (f[y] = i.parse(f[y]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, e.prototype.reset = function(t) {
      if (t === this._dataZoomModel) {
        var r = this.getTargetSeriesModels();
        this._dataExtent = _Le(this, this._dimName, r), this._updateMinMaxSpan();
        var n = this.calculateDataWindow(t.settledOption);
        this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, this._setAxisModel();
      }
    }, e.prototype.filterData = function(t, r) {
      if (t !== this._dataZoomModel)
        return;
      var n = this._dimName, i = this.getTargetSeriesModels(), o = t.get("filterMode"), a = this._valueWindow;
      if (o === "none")
        return;
      ah(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(n);
        if (c.length) {
          if (o === "weakFilter") {
            var d = u.getStore(), h = Ee(c, function(f) {
              return u.getDimensionIndex(f);
            }, u);
            u.filterSelf(function(f) {
              for (var p, g, v, m = 0; m < c.length; m++) {
                var y = d.get(h[m], f), C = !isNaN(y), S = y < a[0], b = y > a[1];
                if (C && !S && !b)
                  return !0;
                C && (v = !0), S && (p = !0), b && (g = !0);
              }
              return v && p && g;
            });
          } else
            ah(c, function(f) {
              if (o === "empty")
                l.setData(u = u.map(f, function(g) {
                  return s(g) ? g : NaN;
                }));
              else {
                var p = {};
                p[f] = a, u.selectRange(p);
              }
            });
          ah(c, function(f) {
            u.setApproximateExtent(a, f);
          });
        }
      });
      function s(l) {
        return l >= a[0] && l <= a[1];
      }
    }, e.prototype._updateMinMaxSpan = function() {
      var t = this._minMaxSpan = {}, r = this._dataZoomModel, n = this._dataExtent;
      ah(["min", "max"], function(i) {
        var o = r.get(i + "Span"), a = r.get(i + "ValueSpan");
        a != null && (a = this.getAxisModel().axis.scale.parse(a)), a != null ? o = Cr(n[0] + a, n, [0, 100], !0) : o != null && (a = Cr(o, [0, 100], n, !0) - n[0]), t[i + "Span"] = o, t[i + "ValueSpan"] = a;
      }, this);
    }, e.prototype._setAxisModel = function() {
      var t = this.getAxisModel(), r = this._percentWindow, n = this._valueWindow;
      if (r) {
        var i = jM(n, [0, 500]);
        i = Math.min(i, 20);
        var o = t.axis.scale.rawExtentInfo;
        r[0] !== 0 && o.setDeterminedMinMax("min", +n[0].toFixed(i)), r[1] !== 100 && o.setDeterminedMinMax("max", +n[1].toFixed(i)), o.freeze();
      }
    }, e;
  }()
);
function _Le(e, t, r) {
  var n = [1 / 0, -1 / 0];
  ah(r, function(a) {
    WEe(n, a.getData(), t);
  });
  var i = e.getAxisModel(), o = sj(i.axis.scale, i, n).calculate();
  return [o.min, o.max];
}
var TLe = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(e) {
    function t(i) {
      e.eachComponent("dataZoom", function(o) {
        o.eachTargetAxis(function(a, s) {
          var l = e.getComponent(Bl(a), s);
          i(a, s, l, o);
        });
      });
    }
    t(function(i, o, a, s) {
      a.__dzAxisProxy = null;
    });
    var r = [];
    t(function(i, o, a, s) {
      a.__dzAxisProxy || (a.__dzAxisProxy = new RLe(i, o, s, e), r.push(a.__dzAxisProxy));
    });
    var n = nt();
    return $(r, function(i) {
      $(i.getTargetSeriesModels(), function(o) {
        n.set(o.uid, o);
      });
    }), n;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(e, t) {
    e.eachComponent("dataZoom", function(r) {
      r.eachTargetAxis(function(n, i) {
        r.getAxisProxy(n, i).reset(r);
      }), r.eachTargetAxis(function(n, i) {
        r.getAxisProxy(n, i).filterData(r, t);
      });
    }), e.eachComponent("dataZoom", function(r) {
      var n = r.findRepresentativeAxisProxy();
      if (n) {
        var i = n.getDataPercentWindow(), o = n.getDataValueWindow();
        r.setCalculatedRange({
          start: i[0],
          end: i[1],
          startValue: o[0],
          endValue: o[1]
        });
      }
    });
  }
};
function PLe(e) {
  e.registerAction("dataZoom", function(t, r) {
    var n = bLe(r, t);
    $(n, function(i) {
      i.setRawRange({
        start: t.start,
        end: t.end,
        startValue: t.startValue,
        endValue: t.endValue
      });
    });
  });
}
var f$ = !1;
function HA(e) {
  f$ || (f$ = !0, e.registerProcessor(e.PRIORITY.PROCESSOR.FILTER, TLe), PLe(e), e.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function MLe(e) {
  e.registerComponentModel(xLe), e.registerComponentView(ELe), HA(e);
}
var Go = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), UK = {};
function sh(e, t) {
  UK[e] = t;
}
function KK(e) {
  return UK[e];
}
var DLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.optionUpdated = function() {
      e.prototype.optionUpdated.apply(this, arguments);
      var r = this.ecModel;
      $(this.option.feature, function(n, i) {
        var o = KK(i);
        o && (o.getDefaultOption && (o.defaultOption = o.getDefaultOption(r)), Mt(n, o.defaultOption));
      });
    }, t.type = "toolbox", t.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, t.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, t;
  }(Vt)
);
function ALe(e, t, r) {
  var n = t.getBoxLayoutParams(), i = t.get("padding"), o = {
    width: r.getWidth(),
    height: r.getHeight()
  }, a = En(n, o, i);
  Mc(t.get("orient"), e, t.get("itemGap"), a.width, a.height), gw(e, n, o, i);
}
function YK(e, t) {
  var r = sd(t.get("padding")), n = t.getItemStyle(["color", "opacity"]);
  return n.fill = t.get("backgroundColor"), e = new or({
    shape: {
      x: e.x - r[3],
      y: e.y - r[0],
      width: e.width + r[1] + r[3],
      height: e.height + r[0] + r[2],
      r: t.get("borderRadius")
    },
    style: n,
    silent: !0,
    z2: -1
  }), e;
}
var ILe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = this.group;
      if (a.removeAll(), !r.get("show"))
        return;
      var s = +r.get("itemSize"), l = r.get("orient") === "vertical", u = r.get("feature") || {}, c = this._features || (this._features = {}), d = [];
      $(u, function(p, g) {
        d.push(g);
      }), new el(this._featureNames || [], d).add(h).update(h).remove(_t(h, null)).execute(), this._featureNames = d;
      function h(p, g) {
        var v = d[p], m = d[g], y = u[v], C = new _r(y, r, r.ecModel), S;
        if (o && o.newTitle != null && o.featureName === v && (y.title = o.newTitle), v && !m) {
          if (OLe(v))
            S = {
              onclick: C.option.onclick,
              featureName: v
            };
          else {
            var b = KK(v);
            if (!b)
              return;
            S = new b();
          }
          c[v] = S;
        } else if (S = c[m], !S)
          return;
        S.uid = wf("toolbox-feature"), S.model = C, S.ecModel = n, S.api = i;
        var w = S instanceof Go;
        if (!v && m) {
          w && S.dispose && S.dispose(n, i);
          return;
        }
        if (!C.get("show") || w && S.unusable) {
          w && S.remove && S.remove(n, i);
          return;
        }
        f(C, S, v), C.setIconStatus = function(x, R) {
          var _ = this.option, T = this.iconPaths;
          _.iconStatus = _.iconStatus || {}, _.iconStatus[x] = R, T[x] && (R === "emphasis" ? Qs : Js)(T[x]);
        }, S instanceof Go && S.render && S.render(C, n, i, o);
      }
      function f(p, g, v) {
        var m = p.getModel("iconStyle"), y = p.getModel(["emphasis", "iconStyle"]), C = g instanceof Go && g.getIcons ? g.getIcons() : p.get("icon"), S = p.get("title") || {}, b, w;
        He(C) ? (b = {}, b[v] = C) : b = C, He(S) ? (w = {}, w[v] = S) : w = S;
        var x = p.iconPaths = {};
        $(b, function(R, _) {
          var T = yf(R, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          T.setStyle(m.getItemStyle());
          var P = T.ensureState("emphasis");
          P.style = y.getItemStyle();
          var D = new ir({
            style: {
              text: w[_],
              align: y.get("textAlign"),
              borderRadius: y.get("textBorderRadius"),
              padding: y.get("textPadding"),
              fill: null,
              font: cD({
                fontStyle: y.get("textFontStyle"),
                fontFamily: y.get("textFontFamily"),
                fontSize: y.get("textFontSize"),
                fontWeight: y.get("textFontWeight")
              }, n)
            },
            ignore: !0
          });
          T.setTextContent(D), Cf({
            el: T,
            componentModel: r,
            itemName: _,
            formatterParamsExtra: {
              title: w[_]
            }
          }), T.__title = w[_], T.on("mouseover", function() {
            var O = y.getItemStyle(), A = l ? r.get("right") == null && r.get("left") !== "right" ? "right" : "left" : r.get("bottom") == null && r.get("top") !== "bottom" ? "bottom" : "top";
            D.setStyle({
              fill: y.get("textFill") || O.fill || O.stroke || "#000",
              backgroundColor: y.get("textBackgroundColor")
            }), T.setTextConfig({
              position: y.get("textPosition") || A
            }), D.ignore = !r.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            p.get(["iconStatus", _]) !== "emphasis" && i.leaveEmphasis(this), D.hide();
          }), (p.get(["iconStatus", _]) === "emphasis" ? Qs : Js)(T), a.add(T), T.on("click", je(g.onclick, g, n, i, _)), x[_] = T;
        });
      }
      ALe(a, r, i), a.add(YK(a.getBoundingRect(), r)), l || a.eachChild(function(p) {
        var g = p.__title, v = p.ensureState("emphasis"), m = v.textConfig || (v.textConfig = {}), y = p.getTextContent(), C = y && y.ensureState("emphasis");
        if (C && !at(C) && g) {
          var S = C.style || (C.style = {}), b = Lv(g, ir.makeFont(S)), w = p.x + a.x, x = p.y + a.y + s, R = !1;
          x + b.height > i.getHeight() && (m.position = "top", R = !0);
          var _ = R ? -5 - b.height : s + 10;
          w + b.width / 2 > i.getWidth() ? (m.position = ["100%", _], S.align = "right") : w - b.width / 2 < 0 && (m.position = [0, _], S.align = "left");
        }
      });
    }, t.prototype.updateView = function(r, n, i, o) {
      $(this._features, function(a) {
        a instanceof Go && a.updateView && a.updateView(a.model, n, i, o);
      });
    }, t.prototype.remove = function(r, n) {
      $(this._features, function(i) {
        i instanceof Go && i.remove && i.remove(r, n);
      }), this.group.removeAll();
    }, t.prototype.dispose = function(r, n) {
      $(this._features, function(i) {
        i instanceof Go && i.dispose && i.dispose(r, n);
      });
    }, t.type = "toolbox", t;
  }(zr)
);
function OLe(e) {
  return e.indexOf("my") === 0;
}
var LLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(r, n) {
      var i = this.model, o = i.get("name") || r.get("title.0.text") || "echarts", a = n.getZr().painter.getType() === "svg", s = a ? "svg" : i.get("type", !0) || "png", l = n.getConnectedDataURL({
        type: s,
        backgroundColor: i.get("backgroundColor", !0) || r.get("backgroundColor") || "#fff",
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = nr.browser;
      if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = o + "." + s, c.target = "_blank", c.href = l;
        var d = new MouseEvent("click", {
          // some micro front-end framework window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        c.dispatchEvent(d);
      } else if (window.navigator.msSaveOrOpenBlob || a) {
        var h = l.split(","), f = h[0].indexOf("base64") > -1, p = a ? decodeURIComponent(h[1]) : h[1];
        f && (p = window.atob(p));
        var g = o + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, m = new Uint8Array(v); v--; )
            m[v] = p.charCodeAt(v);
          var y = new Blob([m]);
          window.navigator.msSaveOrOpenBlob(y, g);
        } else {
          var C = document.createElement("iframe");
          document.body.appendChild(C);
          var S = C.contentWindow, b = S.document;
          b.open("image/svg+xml", "replace"), b.write(p), b.close(), S.focus(), b.execCommand("SaveAs", !0, g), document.body.removeChild(C);
        }
      } else {
        var w = i.get("lang"), x = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (w && w[0] || "") + '" /></body>', R = window.open();
        R.document.write(x), R.document.title = o;
      }
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: r.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: r.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return n;
    }, t;
  }(Go)
), p$ = "__ec_magicType_stack__", FLe = [["line", "bar"], ["stack"]], NLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.getIcons = function() {
      var r = this.model, n = r.get("icon"), i = {};
      return $(r.get("type"), function(o) {
        n[o] && (i[o] = n[o]);
      }), i;
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: r.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return n;
    }, t.prototype.onclick = function(r, n, i) {
      var o = this.model, a = o.get(["seriesIndex", i]);
      if (g$[i]) {
        var s = {
          series: []
        }, l = function(d) {
          var h = d.subType, f = d.id, p = g$[i](h, f, d, o);
          p && (ut(p, d.option), s.series.push(p));
          var g = d.coordinateSystem;
          if (g && g.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var v = g.getAxesByScale("ordinal")[0];
            if (v) {
              var m = v.dim, y = m + "Axis", C = d.getReferringComponents(y, bn).models[0], S = C.componentIndex;
              s[y] = s[y] || [];
              for (var b = 0; b <= S; b++)
                s[y][S] = s[y][S] || {};
              s[y][S].boundaryGap = i === "bar";
            }
          }
        };
        $(FLe, function(d) {
          Ft(d, i) >= 0 && $(d, function(h) {
            o.setIconStatus(h, "normal");
          });
        }), o.setIconStatus(i, "emphasis"), r.eachComponent({
          mainType: "series",
          query: a == null ? null : {
            seriesIndex: a
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = Mt({
          stack: o.option.title.tiled,
          tiled: o.option.title.stack
        }, o.option.title), o.get(["iconStatus", i]) !== "emphasis" && (c = "tiled")), n.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, t;
  }(Go)
), g$ = {
  line: function(e, t, r, n) {
    if (e === "bar")
      return Mt({
        id: t,
        type: "line",
        // Preserve data related option
        data: r.get("data"),
        stack: r.get("stack"),
        markPoint: r.get("markPoint"),
        markLine: r.get("markLine")
      }, n.get(["option", "line"]) || {}, !0);
  },
  bar: function(e, t, r, n) {
    if (e === "line")
      return Mt({
        id: t,
        type: "bar",
        // Preserve data related option
        data: r.get("data"),
        stack: r.get("stack"),
        markPoint: r.get("markPoint"),
        markLine: r.get("markLine")
      }, n.get(["option", "bar"]) || {}, !0);
  },
  stack: function(e, t, r, n) {
    var i = r.get("stack") === p$;
    if (e === "line" || e === "bar")
      return n.setIconStatus("stack", i ? "normal" : "emphasis"), Mt({
        id: t,
        stack: i ? "" : p$
      }, n.get(["option", "stack"]) || {}, !0);
  }
};
Va({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(e, t) {
  t.mergeOption(e.newOption);
});
var Ow = new Array(60).join("-"), Jh = "	";
function kLe(e) {
  var t = {}, r = [], n = [];
  return e.eachRawSeries(function(i) {
    var o = i.coordinateSystem;
    if (o && (o.type === "cartesian2d" || o.type === "polar")) {
      var a = o.getBaseAxis();
      if (a.type === "category") {
        var s = a.dim + "_" + a.index;
        t[s] || (t[s] = {
          categoryAxis: a,
          valueAxis: o.getOtherAxis(a),
          series: []
        }, n.push({
          axisDim: a.dim,
          axisIndex: a.index
        })), t[s].series.push(i);
      } else
        r.push(i);
    } else
      r.push(i);
  }), {
    seriesGroupByCategoryAxis: t,
    other: r,
    meta: n
  };
}
function VLe(e) {
  var t = [];
  return $(e, function(r, n) {
    var i = r.categoryAxis, o = r.valueAxis, a = o.dim, s = [" "].concat(Ee(r.series, function(f) {
      return f.name;
    })), l = [i.model.getCategories()];
    $(r.series, function(f) {
      var p = f.getRawData();
      l.push(f.getRawData().mapArray(p.mapDimension(a), function(g) {
        return g;
      }));
    });
    for (var u = [s.join(Jh)], c = 0; c < l[0].length; c++) {
      for (var d = [], h = 0; h < l.length; h++)
        d.push(l[h][c]);
      u.push(d.join(Jh));
    }
    t.push(u.join(`
`));
  }), t.join(`

` + Ow + `

`);
}
function BLe(e) {
  return Ee(e, function(t) {
    var r = t.getRawData(), n = [t.name], i = [];
    return r.each(r.dimensions, function() {
      for (var o = arguments.length, a = arguments[o - 1], s = r.getName(a), l = 0; l < o - 1; l++)
        i[l] = arguments[l];
      n.push((s ? s + Jh : "") + i.join(Jh));
    }), n.join(`
`);
  }).join(`

` + Ow + `

`);
}
function $Le(e) {
  var t = kLe(e);
  return {
    value: Sr([VLe(t.seriesGroupByCategoryAxis), BLe(t.other)], function(r) {
      return !!r.replace(/[\n\t\s]/g, "");
    }).join(`

` + Ow + `

`),
    meta: t.meta
  };
}
function WC(e) {
  return e.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function HLe(e) {
  var t = e.slice(0, e.indexOf(`
`));
  if (t.indexOf(Jh) >= 0)
    return !0;
}
var kT = new RegExp("[" + Jh + "]+", "g");
function GLe(e) {
  for (var t = e.split(/\n+/g), r = WC(t.shift()).split(kT), n = [], i = Ee(r, function(l) {
    return {
      name: l,
      data: []
    };
  }), o = 0; o < t.length; o++) {
    var a = WC(t[o]).split(kT);
    n.push(a.shift());
    for (var s = 0; s < a.length; s++)
      i[s] && (i[s].data[o] = a[s]);
  }
  return {
    series: i,
    categories: n
  };
}
function zLe(e) {
  for (var t = e.split(/\n+/g), r = WC(t.shift()), n = [], i = 0; i < t.length; i++) {
    var o = WC(t[i]);
    if (o) {
      var a = o.split(kT), s = "", l = void 0, u = !1;
      isNaN(a[0]) ? (u = !0, s = a[0], a = a.slice(1), n[i] = {
        name: s,
        value: []
      }, l = n[i].value) : l = n[i] = [];
      for (var c = 0; c < a.length; c++)
        l.push(+a[c]);
      l.length === 1 && (u ? n[i].value = l[0] : n[i] = l[0]);
    }
  }
  return {
    name: r,
    data: n
  };
}
function WLe(e, t) {
  var r = e.split(new RegExp(`
*` + Ow + `
*`, "g")), n = {
    series: []
  };
  return $(r, function(i, o) {
    if (HLe(i)) {
      var a = GLe(i), s = t[o], l = s.axisDim + "Axis";
      s && (n[l] = n[l] || [], n[l][s.axisIndex] = {
        data: a.categories
      }, n.series = n.series.concat(a.series));
    } else {
      var a = zLe(i);
      n.series.push(a);
    }
  }), n;
}
var jLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(r, n) {
      setTimeout(function() {
        n.dispatchAction({
          type: "hideTip"
        });
      });
      var i = n.getDom(), o = this.model;
      this._dom && i.removeChild(this._dom);
      var a = document.createElement("div");
      a.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", a.style.backgroundColor = o.get("backgroundColor") || "#fff";
      var s = document.createElement("h4"), l = o.get("lang") || [];
      s.innerHTML = l[0] || o.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = o.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var d = o.get("optionToContent"), h = o.get("contentToOption"), f = $Le(r);
      if (at(d)) {
        var p = d(n.getOption());
        He(p) ? u.innerHTML = p : ru(p) && u.appendChild(p);
      } else {
        c.readOnly = o.get("readOnly");
        var g = c.style;
        g.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", g.color = o.get("textColor"), g.borderColor = o.get("textareaBorderColor"), g.backgroundColor = o.get("textareaColor"), c.value = f.value, u.appendChild(c);
      }
      var v = f.meta, m = document.createElement("div");
      m.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", C = document.createElement("div"), S = document.createElement("div");
      y += ";background-color:" + o.get("buttonColor"), y += ";color:" + o.get("buttonTextColor");
      var b = this;
      function w() {
        i.removeChild(a), b._dom = null;
      }
      p_(C, "click", w), p_(S, "click", function() {
        if (h == null && d != null || h != null && d == null) {
          process.env.NODE_ENV !== "production" && nn("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), w();
          return;
        }
        var x;
        try {
          at(h) ? x = h(u, n.getOption()) : x = WLe(c.value, v);
        } catch (R) {
          throw w(), new Error("Data view format error " + R);
        }
        x && n.dispatchAction({
          type: "changeDataView",
          newOption: x
        }), w();
      }), C.innerHTML = l[1], S.innerHTML = l[2], S.style.cssText = C.style.cssText = y, !o.get("readOnly") && m.appendChild(S), m.appendChild(C), a.appendChild(s), a.appendChild(u), a.appendChild(m), u.style.height = i.clientHeight - 80 + "px", i.appendChild(a), this._dom = a;
    }, t.prototype.remove = function(r, n) {
      this._dom && n.getDom().removeChild(this._dom);
    }, t.prototype.dispose = function(r, n) {
      this.remove(r, n);
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: r.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: r.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return n;
    }, t;
  }(Go)
);
function ULe(e, t) {
  return Ee(e, function(r, n) {
    var i = t && t[n];
    if (lt(i) && !be(i)) {
      var o = lt(r) && !be(r);
      o || (r = {
        value: r
      });
      var a = i.name != null && r.name == null;
      return r = ut(r, i), a && delete r.name, r;
    } else
      return r;
  });
}
Va({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(e, t) {
  var r = [];
  $(e.newOption.series, function(n) {
    var i = t.getSeriesByName(n.name)[0];
    if (!i)
      r.push(ge({
        // Default is scatter
        type: "scatter"
      }, n));
    else {
      var o = i.get("data");
      r.push({
        name: n.name,
        data: ULe(n.data, o)
      });
    }
  }), t.mergeOption(ut({
    series: r
  }, e.newOption));
});
var qK = $, XK = ar();
function KLe(e, t) {
  var r = GA(e);
  qK(t, function(n, i) {
    for (var o = r.length - 1; o >= 0; o--) {
      var a = r[o];
      if (a[i])
        break;
    }
    if (o < 0) {
      var s = e.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: i
      })[0];
      if (s) {
        var l = s.getPercentRange();
        r[0][i] = {
          dataZoomId: i,
          start: l[0],
          end: l[1]
        };
      }
    }
  }), r.push(t);
}
function YLe(e) {
  var t = GA(e), r = t[t.length - 1];
  t.length > 1 && t.pop();
  var n = {};
  return qK(r, function(i, o) {
    for (var a = t.length - 1; a >= 0; a--)
      if (i = t[a][o], i) {
        n[o] = i;
        break;
      }
  }), n;
}
function qLe(e) {
  XK(e).snapshots = null;
}
function XLe(e) {
  return GA(e).length;
}
function GA(e) {
  var t = XK(e);
  return t.snapshots || (t.snapshots = [{}]), t.snapshots;
}
var ZLe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(r, n) {
      qLe(r), n.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: r.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return n;
    }, t;
  }(Go)
);
Va({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(e, t) {
  t.resetOption("recreate");
});
var QLe = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], zA = (
  /** @class */
  function() {
    function e(t, r, n) {
      var i = this;
      this._targetInfoList = [];
      var o = v$(r, t);
      $(JLe, function(a, s) {
        (!n || !n.include || Ft(n.include, s) >= 0) && a(o, i._targetInfoList);
      });
    }
    return e.prototype.setOutputRanges = function(t, r) {
      return this.matchOutputRanges(t, r, function(n, i, o) {
        if ((n.coordRanges || (n.coordRanges = [])).push(i), !n.coordRange) {
          n.coordRange = i;
          var a = Jx[n.brushType](0, o, i);
          n.__rangeOffset = {
            offset: S$[n.brushType](a.values, n.range, [1, 1]),
            xyMinMax: a.xyMinMax
          };
        }
      }), t;
    }, e.prototype.matchOutputRanges = function(t, r, n) {
      $(t, function(i) {
        var o = this.findTargetInfo(i, r);
        o && o !== !0 && $(o.coordSyses, function(a) {
          var s = Jx[i.brushType](1, a, i.range, !0);
          n(i, s.values, a, r);
        });
      }, this);
    }, e.prototype.setInputRanges = function(t, r) {
      $(t, function(n) {
        var i = this.findTargetInfo(n, r);
        if (process.env.NODE_ENV !== "production" && (ct(!i || i === !0 || n.coordRange, "coordRange must be specified when coord index specified."), ct(!i || i !== !0 || n.range, "range must be specified in global brush.")), n.range = n.range || [], i && i !== !0) {
          n.panelId = i.panelId;
          var o = Jx[n.brushType](0, i.coordSys, n.coordRange), a = n.__rangeOffset;
          n.range = a ? S$[n.brushType](o.values, a.offset, eFe(o.xyMinMax, a.xyMinMax)) : o.values;
        }
      }, this);
    }, e.prototype.makePanelOpts = function(t, r) {
      return Ee(this._targetInfoList, function(n) {
        var i = n.getPanelRect();
        return {
          panelId: n.panelId,
          defaultBrushType: r ? r(n) : null,
          clipPath: nK(i),
          isTargetByCursor: oK(i, t, n.coordSysModel),
          getLinearBrushOtherExtent: iK(i)
        };
      });
    }, e.prototype.controlSeries = function(t, r, n) {
      var i = this.findTargetInfo(t, n);
      return i === !0 || i && Ft(i.coordSyses, r.coordinateSystem) >= 0;
    }, e.prototype.findTargetInfo = function(t, r) {
      for (var n = this._targetInfoList, i = v$(r, t), o = 0; o < n.length; o++) {
        var a = n[o], s = t.panelId;
        if (s) {
          if (a.panelId === s)
            return a;
        } else
          for (var l = 0; l < m$.length; l++)
            if (m$[l](i, a))
              return a;
      }
      return !0;
    }, e;
  }()
);
function VT(e) {
  return e[0] > e[1] && e.reverse(), e;
}
function v$(e, t) {
  return sg(e, t, {
    includeMainTypes: QLe
  });
}
var JLe = {
  grid: function(e, t) {
    var r = e.xAxisModels, n = e.yAxisModels, i = e.gridModels, o = nt(), a = {}, s = {};
    !r && !n && !i || ($(r, function(l) {
      var u = l.axis.grid.model;
      o.set(u.id, u), a[u.id] = !0;
    }), $(n, function(l) {
      var u = l.axis.grid.model;
      o.set(u.id, u), s[u.id] = !0;
    }), $(i, function(l) {
      o.set(l.id, l), a[l.id] = !0, s[l.id] = !0;
    }), o.each(function(l) {
      var u = l.coordinateSystem, c = [];
      $(u.getCartesians(), function(d, h) {
        (Ft(r, d.getAxis("x").model) >= 0 || Ft(n, d.getAxis("y").model) >= 0) && c.push(d);
      }), t.push({
        panelId: "grid--" + l.id,
        gridModel: l,
        coordSysModel: l,
        // Use the first one as the representitive coordSys.
        coordSys: c[0],
        coordSyses: c,
        getPanelRect: y$.grid,
        xAxisDeclared: a[l.id],
        yAxisDeclared: s[l.id]
      });
    }));
  },
  geo: function(e, t) {
    $(e.geoModels, function(r) {
      var n = r.coordinateSystem;
      t.push({
        panelId: "geo--" + r.id,
        geoModel: r,
        coordSysModel: r,
        coordSys: n,
        coordSyses: [n],
        getPanelRect: y$.geo
      });
    });
  }
}, m$ = [
  // grid
  function(e, t) {
    var r = e.xAxisModel, n = e.yAxisModel, i = e.gridModel;
    return !i && r && (i = r.axis.grid.model), !i && n && (i = n.axis.grid.model), i && i === t.gridModel;
  },
  // geo
  function(e, t) {
    var r = e.geoModel;
    return r && r === t.geoModel;
  }
], y$ = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var e = this.coordSys, t = e.getBoundingRect().clone();
    return t.applyTransform(Wl(e)), t;
  }
}, Jx = {
  lineX: _t(C$, 0),
  lineY: _t(C$, 1),
  rect: function(e, t, r, n) {
    var i = e ? t.pointToData([r[0][0], r[1][0]], n) : t.dataToPoint([r[0][0], r[1][0]], n), o = e ? t.pointToData([r[0][1], r[1][1]], n) : t.dataToPoint([r[0][1], r[1][1]], n), a = [VT([i[0], o[0]]), VT([i[1], o[1]])];
    return {
      values: a,
      xyMinMax: a
    };
  },
  polygon: function(e, t, r, n) {
    var i = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], o = Ee(r, function(a) {
      var s = e ? t.pointToData(a, n) : t.dataToPoint(a, n);
      return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s;
    });
    return {
      values: o,
      xyMinMax: i
    };
  }
};
function C$(e, t, r, n) {
  process.env.NODE_ENV !== "production" && ct(r.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  var i = r.getAxis(["x", "y"][e]), o = VT(Ee([0, 1], function(s) {
    return t ? i.coordToData(i.toLocalCoord(n[s]), !0) : i.toGlobalCoord(i.dataToCoord(n[s]));
  })), a = [];
  return a[e] = o, a[1 - e] = [NaN, NaN], {
    values: o,
    xyMinMax: a
  };
}
var S$ = {
  lineX: _t(w$, 0),
  lineY: _t(w$, 1),
  rect: function(e, t, r) {
    return [[e[0][0] - r[0] * t[0][0], e[0][1] - r[0] * t[0][1]], [e[1][0] - r[1] * t[1][0], e[1][1] - r[1] * t[1][1]]];
  },
  polygon: function(e, t, r) {
    return Ee(e, function(n, i) {
      return [n[0] - r[0] * t[i][0], n[1] - r[1] * t[i][1]];
    });
  }
};
function w$(e, t, r, n) {
  return [t[0] - n[e] * r[0], t[1] - n[e] * r[1]];
}
function eFe(e, t) {
  var r = b$(e), n = b$(t), i = [r[0] / n[0], r[1] / n[1]];
  return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
}
function b$(e) {
  return e ? [e[0][1] - e[0][0], e[1][1] - e[1][0]] : [NaN, NaN];
}
var BT = $, tFe = BCe("toolbox-dataZoom_"), rFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.render = function(r, n, i, o) {
      this._brushController || (this._brushController = new yA(i.getZr()), this._brushController.on("brush", je(this._onBrush, this)).mount()), oFe(r, n, this, o, i), iFe(r, n);
    }, t.prototype.onclick = function(r, n, i) {
      nFe[i].call(this);
    }, t.prototype.remove = function(r, n) {
      this._brushController && this._brushController.unmount();
    }, t.prototype.dispose = function(r, n) {
      this._brushController && this._brushController.dispose();
    }, t.prototype._onBrush = function(r) {
      var n = r.areas;
      if (!r.isEnd || !n.length)
        return;
      var i = {}, o = this.ecModel;
      this._brushController.updateCovers([]);
      var a = new zA(WA(this.model), o, {
        include: ["grid"]
      });
      a.matchOutputRanges(n, o, function(u, c, d) {
        if (d.type === "cartesian2d") {
          var h = u.brushType;
          h === "rect" ? (s("x", d, c[0]), s("y", d, c[1])) : s({
            lineX: "x",
            lineY: "y"
          }[h], d, c);
        }
      }), KLe(o, i), this._dispatchZoomAction(i);
      function s(u, c, d) {
        var h = c.getAxis(u), f = h.model, p = l(u, f, o), g = p.findRepresentativeAxisProxy(f).getMinMaxSpan();
        (g.minValueSpan != null || g.maxValueSpan != null) && (d = hd(0, d.slice(), h.scale.getExtent(), 0, g.minValueSpan, g.maxValueSpan)), p && (i[p.id] = {
          dataZoomId: p.id,
          startValue: d[0],
          endValue: d[1]
        });
      }
      function l(u, c, d) {
        var h;
        return d.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(f) {
          var p = f.getAxisModel(u, c.componentIndex);
          p && (h = f);
        }), h;
      }
    }, t.prototype._dispatchZoomAction = function(r) {
      var n = [];
      BT(r, function(i, o) {
        n.push(dt(i));
      }), n.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: n
      });
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: r.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return n;
    }, t;
  }(Go)
), nFe = {
  zoom: function() {
    var e = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: e
    });
  },
  back: function() {
    this._dispatchZoomAction(YLe(this.ecModel));
  }
};
function WA(e) {
  var t = {
    xAxisIndex: e.get("xAxisIndex", !0),
    yAxisIndex: e.get("yAxisIndex", !0),
    xAxisId: e.get("xAxisId", !0),
    yAxisId: e.get("yAxisId", !0)
  };
  return t.xAxisIndex == null && t.xAxisId == null && (t.xAxisIndex = "all"), t.yAxisIndex == null && t.yAxisId == null && (t.yAxisIndex = "all"), t;
}
function iFe(e, t) {
  e.setIconStatus("back", XLe(t) > 1 ? "emphasis" : "normal");
}
function oFe(e, t, r, n, i) {
  var o = r._isZoomActive;
  n && n.type === "takeGlobalCursor" && (o = n.key === "dataZoomSelect" ? n.dataZoomSelectActive : !1), r._isZoomActive = o, e.setIconStatus("zoom", o ? "emphasis" : "normal");
  var a = new zA(WA(e), t, {
    include: ["grid"]
  }), s = a.makePanelOpts(i, function(l) {
    return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
  });
  r._brushController.setPanels(s).enableBrush(o && s.length ? {
    brushType: "auto",
    brushStyle: e.getModel("brushStyle").getItemStyle()
  } : !1);
}
fbe("dataZoom", function(e) {
  var t = e.getComponent("toolbox", 0), r = ["feature", "dataZoom"];
  if (!t || t.get(r) == null)
    return;
  var n = t.getModel(r), i = [], o = WA(n), a = sg(e, o);
  BT(a.xAxisModels, function(l) {
    return s(l, "xAxis", "xAxisIndex");
  }), BT(a.yAxisModels, function(l) {
    return s(l, "yAxis", "yAxisIndex");
  });
  function s(l, u, c) {
    var d = l.componentIndex, h = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: n.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: tFe + u + d
    };
    h[c] = d, i.push(h);
  }
  return i;
});
function aFe(e) {
  e.registerComponentModel(DLe), e.registerComponentView(ILe), sh("saveAsImage", LLe), sh("magicType", NLe), sh("dataView", jLe), sh("dataZoom", rFe), sh("restore", ZLe), Bt(MLe);
}
var sFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaut false (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "#fff",
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, t;
  }(Vt)
);
function ZK(e) {
  var t = e.get("confine");
  return t != null ? !!t : e.get("renderMode") === "richText";
}
function QK(e) {
  if (nr.domSupported) {
    for (var t = document.documentElement.style, r = 0, n = e.length; r < n; r++)
      if (e[r] in t)
        return e[r];
  }
}
var JK = QK(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), lFe = QK(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function eY(e, t) {
  if (!e)
    return t;
  t = yD(t, !0);
  var r = e.indexOf(t);
  return e = r === -1 ? t : "-" + e.slice(0, r) + "-" + t, e.toLowerCase();
}
function uFe(e, t) {
  var r = e.currentStyle || document.defaultView && document.defaultView.getComputedStyle(e);
  return r ? r[t] : null;
}
var cFe = eY(lFe, "transition"), jA = eY(JK, "transform"), dFe = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (nr.transform3dSupported ? "will-change:transform;" : "");
function hFe(e) {
  return e = e === "left" ? "right" : e === "right" ? "left" : e === "top" ? "bottom" : "top", e;
}
function fFe(e, t, r) {
  if (!He(r) || r === "inside")
    return "";
  var n = e.get("backgroundColor"), i = e.get("borderWidth");
  t = Uc(t);
  var o = hFe(r), a = Math.max(Math.round(i) * 1.5, 6), s = "", l = jA + ":", u;
  Ft(["left", "right"], o) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = o === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = o === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, d = a + i, h = d * Math.abs(Math.cos(c)) + d * Math.abs(Math.sin(c)), f = Math.round(((h - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (h - d) / 2) * 100) / 100;
  s += ";" + o + ":-" + f + "px";
  var p = t + " solid " + i + "px;", g = ["position:absolute;width:" + a + "px;height:" + a + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + p, "border-right:" + p, "background-color:" + n + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function pFe(e, t) {
  var r = "cubic-bezier(0.23,1,0.32,1)", n = " " + e / 2 + "s " + r, i = "opacity" + n + ",visibility" + n;
  return t || (n = " " + e + "s " + r, i += nr.transformSupported ? "," + jA + n : ",left" + n + ",top" + n), cFe + ":" + i;
}
function x$(e, t, r) {
  var n = e.toFixed(0) + "px", i = t.toFixed(0) + "px";
  if (!nr.transformSupported)
    return r ? "top:" + i + ";left:" + n + ";" : [["top", i], ["left", n]];
  var o = nr.transform3dSupported, a = "translate" + (o ? "3d" : "") + "(" + n + "," + i + (o ? ",0" : "") + ")";
  return r ? "top:0;left:0;" + jA + ":" + a + ";" : [["top", 0], ["left", 0], [JK, a]];
}
function gFe(e) {
  var t = [], r = e.get("fontSize"), n = e.getTextColor();
  n && t.push("color:" + n), t.push("font:" + e.getFont()), r && t.push("line-height:" + Math.round(r * 3 / 2) + "px");
  var i = e.get("textShadowColor"), o = e.get("textShadowBlur") || 0, a = e.get("textShadowOffsetX") || 0, s = e.get("textShadowOffsetY") || 0;
  return i && o && t.push("text-shadow:" + a + "px " + s + "px " + o + "px " + i), $(["decoration", "align"], function(l) {
    var u = e.get(l);
    u && t.push("text-" + l + ":" + u);
  }), t.join(";");
}
function vFe(e, t, r) {
  var n = [], i = e.get("transitionDuration"), o = e.get("backgroundColor"), a = e.get("shadowBlur"), s = e.get("shadowColor"), l = e.get("shadowOffsetX"), u = e.get("shadowOffsetY"), c = e.getModel("textStyle"), d = u9(e, "html"), h = l + "px " + u + "px " + a + "px " + s;
  return n.push("box-shadow:" + h), t && i && n.push(pFe(i, r)), o && n.push("background-color:" + o), $(["width", "color", "radius"], function(f) {
    var p = "border-" + f, g = yD(p), v = e.get(g);
    v != null && n.push(p + ":" + v + (f === "color" ? "" : "px"));
  }), n.push(gFe(c)), d != null && n.push("padding:" + sd(d).join("px ") + "px"), n.join(";") + ";";
}
function E$(e, t, r, n, i) {
  var o = t && t.painter;
  if (r) {
    var a = o && o.getViewportRoot();
    a && l0e(e, a, r, n, i);
  } else {
    e[0] = n, e[1] = i;
    var s = o && o.getViewportRootOffset();
    s && (e[0] += s.offsetLeft, e[1] += s.offsetTop);
  }
  e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var mFe = (
  /** @class */
  function() {
    function e(t, r) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, nr.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var i = this._zr = t.getZr(), o = r.appendTo, a = o && (He(o) ? document.querySelector(o) : ru(o) ? o : at(o) && o(t.getDom()));
      E$(this._styleCoord, i, a, t.getWidth() / 2, t.getHeight() / 2), (a || t.getDom()).appendChild(n), this._api = t, this._container = a;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          No(c, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return e.prototype.update = function(t) {
      if (!this._container) {
        var r = this._api.getDom(), n = uFe(r, "position"), i = r.style;
        i.position !== "absolute" && n !== "absolute" && (i.position = "relative");
      }
      var o = t.get("alwaysShowContent");
      o && this._moveIfResized(), this._alwaysShowContent = o, this.el.className = t.get("className") || "";
    }, e.prototype.show = function(t, r) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, i = n.style, o = this._styleCoord;
      n.innerHTML ? i.cssText = dFe + vFe(t, !this._firstShow, this._longHide) + x$(o[0], o[1], !0) + ("border-color:" + Uc(r) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, e.prototype.setContent = function(t, r, n, i, o) {
      var a = this.el;
      if (t == null) {
        a.innerHTML = "";
        return;
      }
      var s = "";
      if (He(o) && n.get("trigger") === "item" && !ZK(n) && (s = fFe(n, i, o)), He(t))
        a.innerHTML = t + s;
      else if (t) {
        a.innerHTML = "", be(t) || (t = [t]);
        for (var l = 0; l < t.length; l++)
          ru(t[l]) && t[l].parentNode !== a && a.appendChild(t[l]);
        if (s && a.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, a.appendChild(u);
        }
      }
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el;
      return [t.offsetWidth, t.offsetHeight];
    }, e.prototype.moveTo = function(t, r) {
      var n = this._styleCoord;
      if (E$(n, this._zr, this._container, t, r), n[0] != null && n[1] != null) {
        var i = this.el.style, o = x$(n[0], n[1]);
        $(o, function(a) {
          i[a[0]] = a[1];
        });
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], r = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), r * this._zr.getHeight());
    }, e.prototype.hide = function() {
      var t = this, r = this.el.style;
      r.visibility = "hidden", r.opacity = "0", nr.transform3dSupported && (r.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return t._longHide = !0;
      }, 500);
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(je(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this.el.parentNode;
      t && t.removeChild(this.el), this.el = this._container = null;
    }, e;
  }()
), yFe = (
  /** @class */
  function() {
    function e(t) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), _$(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return e.prototype.update = function(t) {
      var r = t.get("alwaysShowContent");
      r && this._moveIfResized(), this._alwaysShowContent = r;
    }, e.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, e.prototype.setContent = function(t, r, n, i, o) {
      var a = this;
      lt(t) && mr(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var s = n.getModel("textStyle");
      this.el = new ir({
        style: {
          rich: r.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get("textShadowColor"),
          fill: n.get(["textStyle", "color"]),
          padding: u9(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), $(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        a.el.style[u] = n.get(u);
      }), $(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        a.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el, r = this.el.getBoundingRect(), n = R$(t.style);
      return [r.width + n.left + n.right, r.height + n.top + n.bottom];
    }, e.prototype.moveTo = function(t, r) {
      var n = this.el;
      if (n) {
        var i = this._styleCoord;
        _$(i, this._zr, t, r), t = i[0], r = i[1];
        var o = n.style, a = Tl(o.borderWidth || 0), s = R$(o);
        n.x = t + a + s.left, n.y = r + a + s.top, n.markRedraw();
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], r = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), r * this._zr.getHeight());
    }, e.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(je(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, e;
  }()
);
function Tl(e) {
  return Math.max(0, e);
}
function R$(e) {
  var t = Tl(e.shadowBlur || 0), r = Tl(e.shadowOffsetX || 0), n = Tl(e.shadowOffsetY || 0);
  return {
    left: Tl(t - r),
    right: Tl(t + r),
    top: Tl(t - n),
    bottom: Tl(t + n)
  };
}
function _$(e, t, r, n) {
  e[0] = r, e[1] = n, e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var CFe = new or({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), SFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      if (!(nr.node || !n.getDom())) {
        var i = r.getComponent("tooltip"), o = this._renderMode = UCe(i.get("renderMode"));
        this._tooltipContent = o === "richText" ? new yFe(n) : new mFe(n, {
          appendTo: i.get("appendToBody", !0) ? "body" : i.get("appendTo", !0)
        });
      }
    }, t.prototype.render = function(r, n, i) {
      if (!(nr.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = r, this._ecModel = n, this._api = i;
        var o = this._tooltipContent;
        o.update(r), o.setEnterable(r.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && r.get("transitionDuration") ? Rf(this, "_updatePosition", 50, "fixRate") : Xg(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var r = this._tooltipModel, n = r.get("triggerOn");
      VK("itemTooltip", this._api, je(function(i, o, a) {
        n !== "none" && (n.indexOf(i) >= 0 ? this._tryShow(o, a) : i === "leave" && this._hide(a));
      }, this));
    }, t.prototype._keepShow = function() {
      var r = this._tooltipModel, n = this._ecModel, i = this._api, o = r.get("triggerOn");
      if (this._lastX != null && this._lastY != null && o !== "none" && o !== "click") {
        var a = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && a.manuallyShowTip(r, n, i, {
            x: a._lastX,
            y: a._lastY,
            dataByCoordSys: a._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(r, n, i, o) {
      if (!(o.from === this.uid || nr.node || !i.getDom())) {
        var a = T$(o, i);
        this._ticket = "";
        var s = o.dataByCoordSys, l = EFe(o, n, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: o.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, a);
        } else if (o.tooltip && o.x != null && o.y != null) {
          var c = CFe;
          c.x = o.x, c.y = o.y, c.update(), St(c).tooltipConfig = {
            name: null,
            option: o.tooltip
          }, this._tryShow({
            offsetX: o.x,
            offsetY: o.y,
            target: c
          }, a);
        } else if (s)
          this._tryShow({
            offsetX: o.x,
            offsetY: o.y,
            position: o.position,
            dataByCoordSys: s,
            tooltipOption: o.tooltipOption
          }, a);
        else if (o.seriesIndex != null) {
          if (this._manuallyAxisShowTip(r, n, i, o))
            return;
          var d = BK(o, n), h = d.point[0], f = d.point[1];
          h != null && f != null && this._tryShow({
            offsetX: h,
            offsetY: f,
            target: d.el,
            position: o.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, a);
        } else o.x != null && o.y != null && (i.dispatchAction({
          type: "updateAxisPointer",
          x: o.x,
          y: o.y
        }), this._tryShow({
          offsetX: o.x,
          offsetY: o.y,
          position: o.position,
          target: i.getZr().findHover(o.x, o.y).target
        }, a));
      }
    }, t.prototype.manuallyHideTip = function(r, n, i, o) {
      var a = this._tooltipContent;
      this._tooltipModel && a.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, o.from !== this.uid && this._hide(T$(o, i));
    }, t.prototype._manuallyAxisShowTip = function(r, n, i, o) {
      var a = o.seriesIndex, s = o.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(a == null || s == null || l == null)) {
        var u = n.getSeriesByIndex(a);
        if (u) {
          var c = u.getData(), d = Cp([c.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (d.get("trigger") === "axis")
            return i.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: a,
              dataIndex: s,
              position: o.position
            }), !0;
        }
      }
    }, t.prototype._tryShow = function(r, n) {
      var i = r.target, o = this._tooltipModel;
      if (o) {
        this._lastX = r.offsetX, this._lastY = r.offsetY;
        var a = r.dataByCoordSys;
        if (a && a.length)
          this._showAxisTooltip(a, r);
        else if (i) {
          var s = St(i);
          if (s.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          Cc(i, function(c) {
            if (St(c).dataIndex != null)
              return l = c, !0;
            if (St(c).tooltipConfig != null)
              return u = c, !0;
          }, !0), l ? this._showSeriesItemTooltip(r, l, n) : u ? this._showComponentItemTooltip(r, u, n) : this._hide(n);
        } else
          this._lastDataByCoordSys = null, this._hide(n);
      }
    }, t.prototype._showOrMove = function(r, n) {
      var i = r.get("showDelay");
      n = je(n, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(n, i) : n();
    }, t.prototype._showAxisTooltip = function(r, n) {
      var i = this._ecModel, o = this._tooltipModel, a = [n.offsetX, n.offsetY], s = Cp([n.tooltipOption], o), l = this._renderMode, u = [], c = Hn("section", {
        blocks: [],
        noHeader: !0
      }), d = [], h = new N1();
      $(r, function(y) {
        $(y.dataByAxis, function(C) {
          var S = i.getComponent(C.axisDim + "Axis", C.axisIndex), b = C.value;
          if (!(!S || b == null)) {
            var w = FK(b, S.axis, i, C.seriesDataIndices, C.valueLabelOpt), x = Hn("section", {
              header: w,
              noHeader: !Wo(w),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(x), $(C.seriesDataIndices, function(R) {
              var _ = i.getSeriesByIndex(R.seriesIndex), T = R.dataIndexInside, P = _.getDataParams(T);
              if (!(P.dataIndex < 0)) {
                P.axisDim = C.axisDim, P.axisIndex = C.axisIndex, P.axisType = C.axisType, P.axisId = C.axisId, P.axisValue = UD(S.axis, {
                  value: b
                }), P.axisValueLabel = w, P.marker = h.makeTooltipMarker("item", Uc(P.color), l);
                var D = ck(_.formatTooltip(T, !0, null)), O = D.frag;
                if (O) {
                  var A = Cp([_], o).get("valueFormatter");
                  x.blocks.push(A ? ge({
                    valueFormatter: A
                  }, O) : O);
                }
                D.text && d.push(D.text), u.push(P);
              }
            });
          }
        });
      }), c.blocks.reverse(), d.reverse();
      var f = n.position, p = s.get("order"), g = vk(c, h, l, p, i.get("useUTC"), s.get("textStyle"));
      g && d.unshift(g);
      var v = l === "richText" ? `

` : "<br/>", m = d.join(v);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(r, u) ? this._updatePosition(s, f, a[0], a[1], this._tooltipContent, u) : this._showTooltipContent(s, m, u, Math.random() + "", a[0], a[1], f, null, h);
      });
    }, t.prototype._showSeriesItemTooltip = function(r, n, i) {
      var o = this._ecModel, a = St(n), s = a.seriesIndex, l = o.getSeriesByIndex(s), u = a.dataModel || l, c = a.dataIndex, d = a.dataType, h = u.getData(d), f = this._renderMode, p = r.positionDefault, g = Cp([h.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, p ? {
        position: p
      } : null), v = g.get("trigger");
      if (!(v != null && v !== "item")) {
        var m = u.getDataParams(c, d), y = new N1();
        m.marker = y.makeTooltipMarker("item", Uc(m.color), f);
        var C = ck(u.formatTooltip(c, !1, d)), S = g.get("order"), b = g.get("valueFormatter"), w = C.frag, x = w ? vk(b ? ge({
          valueFormatter: b
        }, w) : w, y, f, S, o.get("useUTC"), g.get("textStyle")) : C.text, R = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, x, m, R, r.offsetX, r.offsetY, r.position, r.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: h.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(r, n, i) {
      var o = this._renderMode === "html", a = St(n), s = a.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
      if (He(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && o && l.content && (l = dt(l), l.content = Ei(l.content));
      var d = [l], h = this._ecModel.getComponent(a.componentMainType, a.componentIndex);
      h && d.push(h), d.push({
        formatter: l.content
      });
      var f = r.positionDefault, p = Cp(d, this._tooltipModel, f ? {
        position: f
      } : null), g = p.get("content"), v = Math.random() + "", m = new N1();
      this._showOrMove(p, function() {
        var y = dt(p.get("formatterParams") || {});
        this._showTooltipContent(p, g, y, v, r.offsetX, r.offsetY, r.position, n, m);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(r, n, i, o, a, s, l, u, c) {
      if (this._ticket = "", !(!r.get("showContent") || !r.get("show"))) {
        var d = this._tooltipContent;
        d.setEnterable(r.get("enterable"));
        var h = r.get("formatter");
        l = l || r.get("position");
        var f = n, p = this._getNearestPoint([a, s], i, r.get("trigger"), r.get("borderColor")), g = p.color;
        if (h)
          if (He(h)) {
            var v = r.ecModel.get("useUTC"), m = be(i) ? i[0] : i, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
            f = h, y && (f = Gv(m.axisValue, f, v)), f = CD(f, i, !0);
          } else if (at(h)) {
            var C = je(function(S, b) {
              S === this._ticket && (d.setContent(b, c, r, g, l), this._updatePosition(r, l, a, s, d, i, u));
            }, this);
            this._ticket = o, f = h(i, o, C);
          } else
            f = h;
        d.setContent(f, c, r, g, l), d.show(r, g), this._updatePosition(r, l, a, s, d, i, u);
      }
    }, t.prototype._getNearestPoint = function(r, n, i, o) {
      if (i === "axis" || be(n))
        return {
          color: o || (this._renderMode === "html" ? "#fff" : "none")
        };
      if (!be(n))
        return {
          color: o || n.color || n.borderColor
        };
    }, t.prototype._updatePosition = function(r, n, i, o, a, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || r.get("position");
      var d = a.getSize(), h = r.get("align"), f = r.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), at(n) && (n = n([i, o], s, a.el, p, {
        viewSize: [u, c],
        contentSize: d.slice()
      })), be(n))
        i = Be(n[0], u), o = Be(n[1], c);
      else if (lt(n)) {
        var g = n;
        g.width = d[0], g.height = d[1];
        var v = En(g, {
          width: u,
          height: c
        });
        i = v.x, o = v.y, h = null, f = null;
      } else if (He(n) && l) {
        var m = xFe(n, p, d, r.get("borderWidth"));
        i = m[0], o = m[1];
      } else {
        var m = wFe(i, o, a, u, c, h ? null : 20, f ? null : 20);
        i = m[0], o = m[1];
      }
      if (h && (i -= P$(h) ? d[0] / 2 : h === "right" ? d[0] : 0), f && (o -= P$(f) ? d[1] / 2 : f === "bottom" ? d[1] : 0), ZK(r)) {
        var m = bFe(i, o, a, u, c);
        i = m[0], o = m[1];
      }
      a.moveTo(i, o);
    }, t.prototype._updateContentNotChangedOnAxis = function(r, n) {
      var i = this._lastDataByCoordSys, o = this._cbParamsList, a = !!i && i.length === r.length;
      return a && $(i, function(s, l) {
        var u = s.dataByAxis || [], c = r[l] || {}, d = c.dataByAxis || [];
        a = a && u.length === d.length, a && $(u, function(h, f) {
          var p = d[f] || {}, g = h.seriesDataIndices || [], v = p.seriesDataIndices || [];
          a = a && h.value === p.value && h.axisType === p.axisType && h.axisId === p.axisId && g.length === v.length, a && $(g, function(m, y) {
            var C = v[y];
            a = a && m.seriesIndex === C.seriesIndex && m.dataIndex === C.dataIndex;
          }), o && $(h.seriesDataIndices, function(m) {
            var y = m.seriesIndex, C = n[y], S = o[y];
            C && S && S.data !== C.data && (a = !1);
          });
        });
      }), this._lastDataByCoordSys = r, this._cbParamsList = n, !!a;
    }, t.prototype._hide = function(r) {
      this._lastDataByCoordSys = null, r({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(r, n) {
      nr.node || !n.getDom() || (Xg(this, "_updatePosition"), this._tooltipContent.dispose(), LT("itemTooltip", n));
    }, t.type = "tooltip", t;
  }(zr)
);
function Cp(e, t, r) {
  var n = t.ecModel, i;
  r ? (i = new _r(r, n, n), i = new _r(t.option, i, n)) : i = t;
  for (var o = e.length - 1; o >= 0; o--) {
    var a = e[o];
    a && (a instanceof _r && (a = a.get("tooltip", !0)), He(a) && (a = {
      formatter: a
    }), a && (i = new _r(a, i, n)));
  }
  return i;
}
function T$(e, t) {
  return e.dispatchAction || je(t.dispatchAction, t);
}
function wFe(e, t, r, n, i, o, a) {
  var s = r.getSize(), l = s[0], u = s[1];
  return o != null && (e + l + o + 2 > n ? e -= l + o : e += o), a != null && (t + u + a > i ? t -= u + a : t += a), [e, t];
}
function bFe(e, t, r, n, i) {
  var o = r.getSize(), a = o[0], s = o[1];
  return e = Math.min(e + a, n) - a, t = Math.min(t + s, i) - s, e = Math.max(e, 0), t = Math.max(t, 0), [e, t];
}
function xFe(e, t, r, n) {
  var i = r[0], o = r[1], a = Math.ceil(Math.SQRT2 * n) + 8, s = 0, l = 0, u = t.width, c = t.height;
  switch (e) {
    case "inside":
      s = t.x + u / 2 - i / 2, l = t.y + c / 2 - o / 2;
      break;
    case "top":
      s = t.x + u / 2 - i / 2, l = t.y - o - a;
      break;
    case "bottom":
      s = t.x + u / 2 - i / 2, l = t.y + c + a;
      break;
    case "left":
      s = t.x - i - a, l = t.y + c / 2 - o / 2;
      break;
    case "right":
      s = t.x + u + a, l = t.y + c / 2 - o / 2;
  }
  return [s, l];
}
function P$(e) {
  return e === "center" || e === "middle";
}
function EFe(e, t, r) {
  var n = qM(e).queryOptionMap, i = n.keys()[0];
  if (!(!i || i === "series")) {
    var o = Nv(t, i, n.get(i), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), a = o.models[0];
    if (a) {
      var s = r.getViewOfComponentModel(a), l;
      if (s.group.traverse(function(u) {
        var c = St(u).tooltipConfig;
        if (c && c.name === e.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: i,
          componentIndex: a.componentIndex,
          el: l
        };
    }
  }
}
function RFe(e) {
  Bt(Jv), e.registerComponentModel(sFe), e.registerComponentView(SFe), e.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, un), e.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, un);
}
var _Fe = ["rect", "polygon", "keep", "clear"];
function TFe(e, t) {
  var r = Tr(e ? e.brush : []);
  if (r.length) {
    var n = [];
    $(r, function(l) {
      var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
      u instanceof Array && (n = n.concat(u));
    });
    var i = e && e.toolbox;
    be(i) && (i = i[0]), i || (i = {
      feature: {}
    }, e.toolbox = [i]);
    var o = i.feature || (i.feature = {}), a = o.brush || (o.brush = {}), s = a.type || (a.type = []);
    s.push.apply(s, n), PFe(s), t && !s.length && s.push.apply(s, _Fe);
  }
}
function PFe(e) {
  var t = {};
  $(e, function(r) {
    t[r] = 1;
  }), e.length = 0, $(t, function(r, n) {
    e.push(n);
  });
}
var M$ = $;
function D$(e) {
  if (e) {
    for (var t in e)
      if (e.hasOwnProperty(t))
        return !0;
  }
}
function $T(e, t, r) {
  var n = {};
  return M$(t, function(o) {
    var a = n[o] = i();
    M$(e[o], function(s, l) {
      if (Vn.isValidType(l)) {
        var u = {
          type: l,
          visual: s
        };
        r && r(u, o), a[l] = new Vn(u), l === "opacity" && (u = dt(u), u.type = "colorAlpha", a.__hidden.__alphaForOpacity = new Vn(u));
      }
    });
  }), n;
  function i() {
    var o = function() {
    };
    o.prototype.__hidden = o.prototype;
    var a = new o();
    return a;
  }
}
function tY(e, t, r) {
  var n;
  $(r, function(i) {
    t.hasOwnProperty(i) && D$(t[i]) && (n = !0);
  }), n && $(r, function(i) {
    t.hasOwnProperty(i) && D$(t[i]) ? e[i] = dt(t[i]) : delete e[i];
  });
}
function MFe(e, t, r, n, i, o) {
  var a = {};
  $(e, function(d) {
    var h = Vn.prepareVisualTypes(t[d]);
    a[d] = h;
  });
  var s;
  function l(d) {
    return MD(r, s, d);
  }
  function u(d, h) {
    C9(r, s, d, h);
  }
  r.each(c);
  function c(d, h) {
    s = d;
    var f = r.getRawDataItem(s);
    if (!(f && f.visualMap === !1))
      for (var p = n.call(i, d), g = t[p], v = a[p], m = 0, y = v.length; m < y; m++) {
        var C = v[m];
        g[C] && g[C].applyVisual(d, l, u);
      }
  }
}
function DFe(e, t, r, n) {
  var i = {};
  return $(e, function(o) {
    var a = Vn.prepareVisualTypes(t[o]);
    i[o] = a;
  }), {
    progress: function(a, s) {
      var l;
      n != null && (l = s.getDimensionIndex(n));
      function u(b) {
        return MD(s, d, b);
      }
      function c(b, w) {
        C9(s, d, b, w);
      }
      for (var d, h = s.getStore(); (d = a.next()) != null; ) {
        var f = s.getRawDataItem(d);
        if (!(f && f.visualMap === !1))
          for (var p = n != null ? h.get(l, d) : d, g = r(p), v = t[g], m = i[g], y = 0, C = m.length; y < C; y++) {
            var S = m[y];
            v[S] && v[S].applyVisual(p, u, c);
          }
      }
    }
  };
}
function AFe(e) {
  var t = e.brushType, r = {
    point: function(n) {
      return A$[t].point(n, r, e);
    },
    rect: function(n) {
      return A$[t].rect(n, r, e);
    }
  };
  return r;
}
var A$ = {
  lineX: I$(0),
  lineY: I$(1),
  rect: {
    point: function(e, t, r) {
      return e && r.boundingRect.contain(e[0], e[1]);
    },
    rect: function(e, t, r) {
      return e && r.boundingRect.intersect(e);
    }
  },
  polygon: {
    point: function(e, t, r) {
      return e && r.boundingRect.contain(e[0], e[1]) && sc(r.range, e[0], e[1]);
    },
    rect: function(e, t, r) {
      var n = r.range;
      if (!e || n.length <= 1)
        return !1;
      var i = e.x, o = e.y, a = e.width, s = e.height, l = n[0];
      if (sc(n, i, o) || sc(n, i + a, o) || sc(n, i, o + s) || sc(n, i + a, o + s) || At.create(e).contain(l[0], l[1]) || Fp(i, o, i + a, o, n) || Fp(i, o, i, o + s, n) || Fp(i + a, o, i + a, o + s, n) || Fp(i, o + s, i + a, o + s, n))
        return !0;
    }
  }
};
function I$(e) {
  var t = ["x", "y"], r = ["width", "height"];
  return {
    point: function(n, i, o) {
      if (n) {
        var a = o.range, s = n[e];
        return Sp(s, a);
      }
    },
    rect: function(n, i, o) {
      if (n) {
        var a = o.range, s = [n[t[e]], n[t[e]] + n[r[e]]];
        return s[1] < s[0] && s.reverse(), Sp(s[0], a) || Sp(s[1], a) || Sp(a[0], s) || Sp(a[1], s);
      }
    }
  };
}
function Sp(e, t) {
  return t[0] <= e && e <= t[1];
}
var O$ = ["inBrush", "outOfBrush"], eE = "__ecBrushSelect", HT = "__ecInBrushSelectEvent";
function rY(e) {
  e.eachComponent({
    mainType: "brush"
  }, function(t) {
    var r = t.brushTargetManager = new zA(t.option, e);
    r.setInputRanges(t.areas, e);
  });
}
function IFe(e, t, r) {
  var n = [], i, o;
  e.eachComponent({
    mainType: "brush"
  }, function(a) {
    r && r.type === "takeGlobalCursor" && a.setBrushOption(r.key === "brush" ? r.brushOption : {
      brushType: !1
    });
  }), rY(e), e.eachComponent({
    mainType: "brush"
  }, function(a, s) {
    var l = {
      brushId: a.id,
      brushIndex: s,
      brushName: a.name,
      areas: dt(a.areas),
      selected: []
    };
    n.push(l);
    var u = a.option, c = u.brushLink, d = [], h = [], f = [], p = !1;
    s || (i = u.throttleType, o = u.throttleDelay);
    var g = Ee(a.areas, function(b) {
      var w = NFe[b.brushType], x = ut({
        boundingRect: w ? w(b) : void 0
      }, b);
      return x.selectors = AFe(x), x;
    }), v = $T(a.option, O$, function(b) {
      b.mappingMethod = "fixed";
    });
    be(c) && $(c, function(b) {
      d[b] = 1;
    });
    function m(b) {
      return c === "all" || !!d[b];
    }
    function y(b) {
      return !!b.length;
    }
    e.eachSeries(function(b, w) {
      var x = f[w] = [];
      b.subType === "parallel" ? C(b, w) : S(b, w, x);
    });
    function C(b, w) {
      var x = b.coordinateSystem;
      p = p || x.hasAxisBrushed(), m(w) && x.eachActiveState(b.getData(), function(R, _) {
        R === "active" && (h[_] = 1);
      });
    }
    function S(b, w, x) {
      if (!(!b.brushSelector || FFe(a, w)) && ($(g, function(_) {
        a.brushTargetManager.controlSeries(_, b, e) && x.push(_), p = p || y(x);
      }), m(w) && y(x))) {
        var R = b.getData();
        R.each(function(_) {
          L$(b, x, R, _) && (h[_] = 1);
        });
      }
    }
    e.eachSeries(function(b, w) {
      var x = {
        seriesId: b.id,
        seriesIndex: w,
        seriesName: b.name,
        dataIndex: []
      };
      l.selected.push(x);
      var R = f[w], _ = b.getData(), T = m(w) ? function(P) {
        return h[P] ? (x.dataIndex.push(_.getRawIndex(P)), "inBrush") : "outOfBrush";
      } : function(P) {
        return L$(b, R, _, P) ? (x.dataIndex.push(_.getRawIndex(P)), "inBrush") : "outOfBrush";
      };
      (m(w) ? p : y(R)) && MFe(O$, v, _, T);
    });
  }), OFe(t, i, o, n, r);
}
function OFe(e, t, r, n, i) {
  if (i) {
    var o = e.getZr();
    if (!o[HT]) {
      o[eE] || (o[eE] = LFe);
      var a = Rf(o, eE, r, t);
      a(e, n);
    }
  }
}
function LFe(e, t) {
  if (!e.isDisposed()) {
    var r = e.getZr();
    r[HT] = !0, e.dispatchAction({
      type: "brushSelect",
      batch: t
    }), r[HT] = !1;
  }
}
function L$(e, t, r, n) {
  for (var i = 0, o = t.length; i < o; i++) {
    var a = t[i];
    if (e.brushSelector(n, r, a.selectors, a))
      return !0;
  }
}
function FFe(e, t) {
  var r = e.option.seriesIndex;
  return r != null && r !== "all" && (be(r) ? Ft(r, t) < 0 : t !== r);
}
var NFe = {
  rect: function(e) {
    return F$(e.range);
  },
  polygon: function(e) {
    for (var t, r = e.range, n = 0, i = r.length; n < i; n++) {
      t = t || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var o = r[n];
      o[0] < t[0][0] && (t[0][0] = o[0]), o[0] > t[0][1] && (t[0][1] = o[0]), o[1] < t[1][0] && (t[1][0] = o[1]), o[1] > t[1][1] && (t[1][1] = o[1]);
    }
    return t && F$(t);
  }
};
function F$(e) {
  return new At(e[0][0], e[1][0], e[0][1] - e[0][0], e[1][1] - e[1][0]);
}
var kFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      this.ecModel = r, this.api = n, this.model, (this._brushController = new yA(n.getZr())).on("brush", je(this._onBrush, this)).mount();
    }, t.prototype.render = function(r, n, i, o) {
      this.model = r, this._updateController(r, n, i, o);
    }, t.prototype.updateTransform = function(r, n, i, o) {
      rY(n), this._updateController(r, n, i, o);
    }, t.prototype.updateVisual = function(r, n, i, o) {
      this.updateTransform(r, n, i, o);
    }, t.prototype.updateView = function(r, n, i, o) {
      this._updateController(r, n, i, o);
    }, t.prototype._updateController = function(r, n, i, o) {
      (!o || o.$from !== r.id) && this._brushController.setPanels(r.brushTargetManager.makePanelOpts(i)).enableBrush(r.brushOption).updateCovers(r.areas.slice());
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.prototype._onBrush = function(r) {
      var n = this.model.id, i = this.model.brushTargetManager.setOutputRanges(r.areas, this.ecModel);
      (!r.isEnd || r.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: n,
        areas: dt(i),
        $from: n
      }), r.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: n,
        areas: dt(i),
        $from: n
      });
    }, t.type = "brush", t;
  }(zr)
), VFe = "#ddd", BFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.areas = [], r.brushOption = {}, r;
    }
    return t.prototype.optionUpdated = function(r, n) {
      var i = this.option;
      !n && tY(i, r, ["inBrush", "outOfBrush"]);
      var o = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: VFe
      }, o.hasOwnProperty("liftZ") || (o.liftZ = 5);
    }, t.prototype.setAreas = function(r) {
      process.env.NODE_ENV !== "production" && (ct(be(r)), $(r, function(n) {
        ct(n.brushType, "Illegal areas");
      })), r && (this.areas = Ee(r, function(n) {
        return N$(this.option, n);
      }, this));
    }, t.prototype.setBrushOption = function(r) {
      this.brushOption = N$(this.option, r), this.brushType = this.brushOption.brushType;
    }, t.type = "brush", t.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], t.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4
    }, t;
  }(Vt)
);
function N$(e, t) {
  return Mt({
    brushType: e.brushType,
    brushMode: e.brushMode,
    transformable: e.transformable,
    brushStyle: new _r(e.brushStyle).getItemStyle(),
    removeOnClick: e.removeOnClick,
    z: e.z
  }, t, !0);
}
var $Fe = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], HFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.render = function(r, n, i) {
      var o, a, s;
      n.eachComponent({
        mainType: "brush"
      }, function(l) {
        o = l.brushType, a = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = o, this._brushMode = a, $(r.get("type", !0), function(l) {
        r.setIconStatus(l, (l === "keep" ? a === "multiple" : l === "clear" ? s : l === o) ? "emphasis" : "normal");
      });
    }, t.prototype.updateView = function(r, n, i) {
      this.render(r, n, i);
    }, t.prototype.getIcons = function() {
      var r = this.model, n = r.get("icon", !0), i = {};
      return $(r.get("type", !0), function(o) {
        n[o] && (i[o] = n[o]);
      }), i;
    }, t.prototype.onclick = function(r, n, i) {
      var o = this._brushType, a = this._brushMode;
      i === "clear" ? (n.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), n.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : n.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? o : o === i ? !1 : i,
          brushMode: i === "keep" ? a === "multiple" ? "single" : "multiple" : a
        }
      });
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        type: $Fe.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: r.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return n;
    }, t;
  }(Go)
);
function GFe(e) {
  e.registerComponentView(kFe), e.registerComponentModel(BFe), e.registerPreprocessor(TFe), e.registerVisual(e.PRIORITY.VISUAL.BRUSH, IFe), e.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(t, r) {
    r.eachComponent({
      mainType: "brush",
      query: t
    }, function(n) {
      n.setAreas(t.areas);
    });
  }), e.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, un), e.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, un), sh("brush", HFe);
}
var zFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, r;
    }
    return t.type = "title", t.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, t;
  }(Vt)
), WFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      if (this.group.removeAll(), !!r.get("show")) {
        var o = this.group, a = r.getModel("textStyle"), s = r.getModel("subtextStyle"), l = r.get("textAlign"), u = bt(r.get("textBaseline"), r.get("textVerticalAlign")), c = new ir({
          style: Vr(a, {
            text: r.get("text"),
            fill: a.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), d = c.getBoundingRect(), h = r.get("subtext"), f = new ir({
          style: Vr(s, {
            text: h,
            fill: s.getTextColor(),
            y: d.height + r.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), p = r.get("link"), g = r.get("sublink"), v = r.get("triggerEvent", !0);
        c.silent = !p && !v, f.silent = !g && !v, p && c.on("click", function() {
          pC(p, "_" + r.get("target"));
        }), g && f.on("click", function() {
          pC(g, "_" + r.get("subtarget"));
        }), St(c).eventData = St(f).eventData = v ? {
          componentType: "title",
          componentIndex: r.componentIndex
        } : null, o.add(c), h && o.add(f);
        var m = o.getBoundingRect(), y = r.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var C = En(y, {
          width: i.getWidth(),
          height: i.getHeight()
        }, r.get("padding"));
        l || (l = r.get("left") || r.get("right"), l === "middle" && (l = "center"), l === "right" ? C.x += C.width : l === "center" && (C.x += C.width / 2)), u || (u = r.get("top") || r.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? C.y += C.height : u === "middle" && (C.y += C.height / 2), u = u || "top"), o.x = C.x, o.y = C.y, o.markRedraw();
        var S = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(S), f.setStyle(S), m = o.getBoundingRect();
        var b = C.margin, w = r.getItemStyle(["color", "opacity"]);
        w.fill = r.get("backgroundColor");
        var x = new or({
          shape: {
            x: m.x - b[3],
            y: m.y - b[0],
            width: m.width + b[1] + b[3],
            height: m.height + b[0] + b[2],
            r: r.get("borderRadius")
          },
          style: w,
          subPixelOptimize: !0,
          silent: !0
        });
        o.add(x);
      }
    }, t.type = "title", t;
  }(zr)
);
function jFe(e) {
  e.registerComponentModel(zFe), e.registerComponentView(WFe);
}
var k$ = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.layoutMode = "box", r;
    }
    return t.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i), this._initData();
    }, t.prototype.mergeOption = function(r) {
      e.prototype.mergeOption.apply(this, arguments), this._initData();
    }, t.prototype.setCurrentIndex = function(r) {
      r == null && (r = this.option.currentIndex);
      var n = this._data.count();
      this.option.loop ? r = (r % n + n) % n : (r >= n && (r = n - 1), r < 0 && (r = 0)), this.option.currentIndex = r;
    }, t.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, t.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, t.prototype.setPlayState = function(r) {
      this.option.autoPlay = !!r;
    }, t.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, t.prototype._initData = function() {
      var r = this.option, n = r.data || [], i = r.axisType, o = this._names = [], a;
      i === "category" ? (a = [], $(n, function(u, c) {
        var d = In(pf(u), ""), h;
        lt(u) ? (h = dt(u), h.value = c) : h = c, a.push(h), o.push(d);
      })) : a = n;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new di([{
        name: "value",
        type: s
      }], this);
      l.initData(a, o);
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, t.type = "timeline", t.defaultOption = {
      // zlevel: 0,                  // 
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, t;
  }(Vt)
), nY = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "timeline.slider", t.defaultOption = wu(k$.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // TEXTSTYLE
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        // eslint-disable-next-line max-len
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        // eslint-disable-next-line max-len
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0,
          // TEXTSTYLE
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), t;
  }(k$)
);
cn(nY, mw.prototype);
var UFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "timeline", t;
  }(zr)
), KFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t(r, n, i, o) {
      var a = e.call(this, r, n, i) || this;
      return a.type = o || "value", a;
    }
    return t.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, t.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, t;
  }(sa)
), tE = Math.PI, V$ = ar(), YFe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      this.api = n;
    }, t.prototype.render = function(r, n, i) {
      if (this.model = r, this.api = i, this.ecModel = n, this.group.removeAll(), r.get("show", !0)) {
        var o = this._layout(r, i), a = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(o, r);
        r.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return Hn("nameValue", {
            noName: !0,
            value: c
          });
        }, $(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
          this["_render" + u](o, a, l, r);
        }, this), this._renderAxisLabel(o, s, l, r), this._position(o, r);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, t.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._clearTimer();
    }, t.prototype._layout = function(r, n) {
      var i = r.get(["label", "position"]), o = r.get("orient"), a = XFe(r, n), s;
      i == null || i === "auto" ? s = o === "horizontal" ? a.y + a.height / 2 < n.getHeight() / 2 ? "-" : "+" : a.x + a.width / 2 < n.getWidth() / 2 ? "+" : "-" : He(i) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[o][i] : s = i;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: tE / 2
      }, d = o === "vertical" ? a.height : a.width, h = r.getModel("controlStyle"), f = h.get("show", !0), p = f ? h.get("itemSize") : 0, g = f ? h.get("itemGap") : 0, v = p + g, m = r.get(["label", "rotate"]) || 0;
      m = m * tE / 180;
      var y, C, S, b = h.get("position", !0), w = f && h.get("showPlayBtn", !0), x = f && h.get("showPrevBtn", !0), R = f && h.get("showNextBtn", !0), _ = 0, T = d;
      b === "left" || b === "bottom" ? (w && (y = [0, 0], _ += v), x && (C = [_, 0], _ += v), R && (S = [T - p, 0], T -= v)) : (w && (y = [T - p, 0], T -= v), x && (C = [0, 0], _ += v), R && (S = [T - p, 0], T -= v));
      var P = [_, T];
      return r.get("inverse") && P.reverse(), {
        viewRect: a,
        mainLength: d,
        orient: o,
        rotation: c[o],
        labelRotation: m,
        labelPosOpt: s,
        labelAlign: r.get(["label", "align"]) || l[o],
        labelBaseline: r.get(["label", "verticalAlign"]) || r.get(["label", "baseline"]) || u[o],
        // Based on mainGroup.
        playPosition: y,
        prevBtnPosition: C,
        nextBtnPosition: S,
        axisExtent: P,
        controlSize: p,
        controlGap: g
      };
    }, t.prototype._position = function(r, n) {
      var i = this._mainGroup, o = this._labelGroup, a = r.viewRect;
      if (r.orient === "vertical") {
        var s = Zi(), l = a.x, u = a.y + a.height;
        Oa(s, s, [-l, -u]), Cu(s, s, -tE / 2), Oa(s, s, [l, u]), a = a.clone(), a.applyTransform(s);
      }
      var c = y(a), d = y(i.getBoundingRect()), h = y(o.getBoundingRect()), f = [i.x, i.y], p = [o.x, o.y];
      p[0] = f[0] = c[0][0];
      var g = r.labelPosOpt;
      if (g == null || He(g)) {
        var v = g === "+" ? 0 : 1;
        C(f, d, c, 1, v), C(p, h, c, 1, 1 - v);
      } else {
        var v = g >= 0 ? 0 : 1;
        C(f, d, c, 1, v), p[1] = f[1] + g;
      }
      i.setPosition(f), o.setPosition(p), i.rotation = o.rotation = r.rotation, m(i), m(o);
      function m(S) {
        S.originX = c[0][0] - S.x, S.originY = c[1][0] - S.y;
      }
      function y(S) {
        return [[S.x, S.x + S.width], [S.y, S.y + S.height]];
      }
      function C(S, b, w, x, R) {
        S[x] += w[x][R] - b[x][R];
      }
    }, t.prototype._createAxis = function(r, n) {
      var i = n.getData(), o = n.get("axisType"), a = qFe(n, o);
      a.getTicks = function() {
        return i.mapArray(["value"], function(u) {
          return {
            value: u
          };
        });
      };
      var s = i.getDataExtent("value");
      a.setExtent(s[0], s[1]), a.calcNiceTicks();
      var l = new KFe("value", a, r.axisExtent, o);
      return l.model = n, l;
    }, t.prototype._createGroup = function(r) {
      var n = this[r] = new Ct();
      return this.group.add(n), n;
    }, t.prototype._renderAxisLine = function(r, n, i, o) {
      var a = i.getExtent();
      if (o.get(["lineStyle", "show"])) {
        var s = new Nn({
          shape: {
            x1: a[0],
            y1: 0,
            x2: a[1],
            y2: 0
          },
          style: ge({
            lineCap: "round"
          }, o.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        n.add(s);
        var l = this._progressLine = new Nn({
          shape: {
            x1: a[0],
            x2: this._currentPointer ? this._currentPointer.x : a[0],
            y1: 0,
            y2: 0
          },
          style: ut({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, o.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        n.add(l);
      }
    }, t.prototype._renderAxisTick = function(r, n, i, o) {
      var a = this, s = o.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], $(l, function(u) {
        var c = i.dataToCoord(u.value), d = s.getItemModel(u.value), h = d.getModel("itemStyle"), f = d.getModel(["emphasis", "itemStyle"]), p = d.getModel(["progress", "itemStyle"]), g = {
          x: c,
          y: 0,
          onclick: je(a._changeTimeline, a, u.value)
        }, v = B$(d, h, n, g);
        v.ensureState("emphasis").style = f.getItemStyle(), v.ensureState("progress").style = p.getItemStyle(), zl(v);
        var m = St(v);
        d.get("tooltip") ? (m.dataIndex = u.value, m.dataModel = o) : m.dataIndex = m.dataModel = null, a._tickSymbols.push(v);
      });
    }, t.prototype._renderAxisLabel = function(r, n, i, o) {
      var a = this, s = i.getLabelModel();
      if (s.get("show")) {
        var l = o.getData(), u = i.getViewLabels();
        this._tickLabels = [], $(u, function(c) {
          var d = c.tickValue, h = l.getItemModel(d), f = h.getModel("label"), p = h.getModel(["emphasis", "label"]), g = h.getModel(["progress", "label"]), v = i.dataToCoord(c.tickValue), m = new ir({
            x: v,
            y: 0,
            rotation: r.labelRotation - r.rotation,
            onclick: je(a._changeTimeline, a, d),
            silent: !1,
            style: Vr(f, {
              text: c.formattedLabel,
              align: r.labelAlign,
              verticalAlign: r.labelBaseline
            })
          });
          m.ensureState("emphasis").style = Vr(p), m.ensureState("progress").style = Vr(g), n.add(m), zl(m), V$(m).dataIndex = d, a._tickLabels.push(m);
        });
      }
    }, t.prototype._renderControl = function(r, n, i, o) {
      var a = r.controlSize, s = r.rotation, l = o.getModel("controlStyle").getItemStyle(), u = o.getModel(["emphasis", "controlStyle"]).getItemStyle(), c = o.getPlayState(), d = o.get("inverse", !0);
      h(r.nextBtnPosition, "next", je(this._changeTimeline, this, d ? "-" : "+")), h(r.prevBtnPosition, "prev", je(this._changeTimeline, this, d ? "+" : "-")), h(r.playPosition, c ? "stop" : "play", je(this._handlePlayClick, this, !c), !0);
      function h(f, p, g, v) {
        if (f) {
          var m = La(bt(o.get(["controlStyle", p + "BtnSize"]), a), a), y = [0, -m / 2, m, m], C = ZFe(o, p + "Icon", y, {
            x: f[0],
            y: f[1],
            originX: a / 2,
            originY: 0,
            rotation: v ? -s : 0,
            rectHover: !0,
            style: l,
            onclick: g
          });
          C.ensureState("emphasis").style = u, n.add(C), zl(C);
        }
      }
    }, t.prototype._renderCurrentPointer = function(r, n, i, o) {
      var a = o.getData(), s = o.getCurrentIndex(), l = a.getItemModel(s).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(d) {
          d.draggable = !0, d.drift = je(u._handlePointerDrag, u), d.ondragend = je(u._handlePointerDragend, u), $$(d, u._progressLine, s, i, o, !0);
        },
        onUpdate: function(d) {
          $$(d, u._progressLine, s, i, o);
        }
      };
      this._currentPointer = B$(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, t.prototype._handlePlayClick = function(r) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: r,
        from: this.uid
      });
    }, t.prototype._handlePointerDrag = function(r, n, i) {
      this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]);
    }, t.prototype._handlePointerDragend = function(r) {
      this._pointerChangeTimeline([r.offsetX, r.offsetY], !0);
    }, t.prototype._pointerChangeTimeline = function(r, n) {
      var i = this._toAxisCoord(r)[0], o = this._axis, a = vo(o.getExtent().slice());
      i > a[1] && (i = a[1]), i < a[0] && (i = a[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = i, s.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (n || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, t.prototype._doPlayStop = function() {
      var r = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var n = r.model;
        r._changeTimeline(n.getCurrentIndex() + (n.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, t.prototype._toAxisCoord = function(r) {
      var n = this._mainGroup.getLocalTransform();
      return Ma(r, n, !0);
    }, t.prototype._findNearestTick = function(r) {
      var n = this.model.getData(), i = 1 / 0, o, a = this._axis;
      return n.each(["value"], function(s, l) {
        var u = a.dataToCoord(s), c = Math.abs(u - r);
        c < i && (i = c, o = l);
      }), o;
    }, t.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, t.prototype._changeTimeline = function(r) {
      var n = this.model.getCurrentIndex();
      r === "+" ? r = n + 1 : r === "-" && (r = n - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: r,
        from: this.uid
      });
    }, t.prototype._updateTicksStatus = function() {
      var r = this.model.getCurrentIndex(), n = this._tickSymbols, i = this._tickLabels;
      if (n)
        for (var o = 0; o < n.length; o++)
          n && n[o] && n[o].toggleState("progress", o < r);
      if (i)
        for (var o = 0; o < i.length; o++)
          i && i[o] && i[o].toggleState("progress", V$(i[o]).dataIndex <= r);
    }, t.type = "timeline.slider", t;
  }(UFe)
);
function qFe(e, t) {
  if (t = t || e.get("type"), t)
    switch (t) {
      case "category":
        return new Rw({
          ordinalMeta: e.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new WD({
          locale: e.ecModel.getLocaleModel(),
          useUTC: e.ecModel.get("useUTC")
        });
      default:
        return new rl();
    }
}
function XFe(e, t) {
  return En(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  }, e.get("padding"));
}
function ZFe(e, t, r, n) {
  var i = n.style, o = yf(e.get(["controlStyle", t]), n || {}, new At(r[0], r[1], r[2], r[3]));
  return i && o.setStyle(i), o;
}
function B$(e, t, r, n, i, o) {
  var a = t.get("color");
  if (i)
    i.setColor(a), r.add(i), o && o.onUpdate(i);
  else {
    var s = e.get("symbol");
    i = mn(s, -1, -1, 2, 2, a), i.setStyle("strokeNoScale", !0), r.add(i), o && o.onCreate(i);
  }
  var l = t.getItemStyle(["color"]);
  i.setStyle(l), n = Mt({
    rectHover: !0,
    z2: 100
  }, n, !0);
  var u = _f(e.get("symbolSize"));
  n.scaleX = u[0] / 2, n.scaleY = u[1] / 2;
  var c = ud(e.get("symbolOffset"), u);
  c && (n.x = (n.x || 0) + c[0], n.y = (n.y || 0) + c[1]);
  var d = e.get("symbolRotate");
  return n.rotation = (d || 0) * Math.PI / 180 || 0, i.attr(n), i.updateTransform(), i;
}
function $$(e, t, r, n, i, o) {
  if (!e.dragging) {
    var a = i.getModel("checkpointStyle"), s = n.dataToCoord(i.getData().get("value", r));
    if (o || !a.get("animation", !0))
      e.attr({
        x: s,
        y: 0
      }), t && t.attr({
        shape: {
          x2: s
        }
      });
    else {
      var l = {
        duration: a.get("animationDuration", !0),
        easing: a.get("animationEasing", !0)
      };
      e.stopAnimation(null, !0), e.animateTo({
        x: s,
        y: 0
      }, l), t && t.animateTo({
        shape: {
          x2: s
        }
      }, l);
    }
  }
}
function QFe(e) {
  e.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(t, r, n) {
    var i = r.getComponent("timeline");
    return i && t.currentIndex != null && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(!1), n.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: t.from
    }))), r.resetOption("timeline", {
      replaceMerge: i.get("replaceMerge", !0)
    }), ut({
      currentIndex: i.option.currentIndex
    }, t);
  }), e.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(t, r) {
    var n = r.getComponent("timeline");
    n && t.playState != null && n.setPlayState(t.playState);
  });
}
function JFe(e) {
  var t = e && e.timeline;
  be(t) || (t = t ? [t] : []), $(t, function(r) {
    r && eNe(r);
  });
}
function eNe(e) {
  var t = e.type, r = {
    number: "value",
    time: "time"
  };
  if (r[t] && (e.axisType = r[t], delete e.type), H$(e), cc(e, "controlPosition")) {
    var n = e.controlStyle || (e.controlStyle = {});
    cc(n, "position") || (n.position = e.controlPosition), n.position === "none" && !cc(n, "show") && (n.show = !1, delete n.position), delete e.controlPosition;
  }
  $(e.data || [], function(i) {
    lt(i) && !be(i) && (!cc(i, "value") && cc(i, "name") && (i.value = i.name), H$(i));
  });
}
function H$(e) {
  var t = e.itemStyle || (e.itemStyle = {}), r = t.emphasis || (t.emphasis = {}), n = e.label || e.label || {}, i = n.normal || (n.normal = {}), o = {
    normal: 1,
    emphasis: 1
  };
  $(n, function(a, s) {
    !o[s] && !cc(i, s) && (i[s] = a);
  }), r.label && !cc(n, "emphasis") && (n.emphasis = r.label, delete r.label);
}
function cc(e, t) {
  return e.hasOwnProperty(t);
}
function tNe(e) {
  e.registerComponentModel(nY), e.registerComponentView(YFe), e.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), QFe(e), e.registerPreprocessor(JFe);
}
function UA(e, t) {
  if (!e)
    return !1;
  for (var r = be(e) ? e : [e], n = 0; n < r.length; n++)
    if (r[n] && r[n][t])
      return !0;
  return !1;
}
function Ty(e) {
  Gc(e, "label", ["show"]);
}
var Py = ar(), il = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.createdBySelf = !1, r;
    }
    return t.prototype.init = function(r, n, i) {
      if (process.env.NODE_ENV !== "production" && this.type === "marker")
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      this.mergeDefaultAndTheme(r, i), this._mergeOption(r, i, !1, !0);
    }, t.prototype.isAnimationEnabled = function() {
      if (nr.node)
        return !1;
      var r = this.__hostSeries;
      return this.getShallow("animation") && r && r.isAnimationEnabled();
    }, t.prototype.mergeOption = function(r, n) {
      this._mergeOption(r, n, !1, !1);
    }, t.prototype._mergeOption = function(r, n, i, o) {
      var a = this.mainType;
      i || n.eachSeries(function(s) {
        var l = s.get(this.mainType, !0), u = Py(s)[a];
        if (!l || !l.data) {
          Py(s)[a] = null;
          return;
        }
        u ? u._mergeOption(l, n, !0) : (o && Ty(l), $(l.data, function(c) {
          c instanceof Array ? (Ty(c[0]), Ty(c[1])) : Ty(c);
        }), u = this.createMarkerModelFromSeries(l, this, n), ge(u, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: !0
        }), u.__hostSeries = s), Py(s)[a] = u;
      }, this);
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = this.getRawValue(r), s = o.getName(r);
      return Hn("section", {
        header: this.name,
        blocks: [Hn("nameValue", {
          name: s,
          value: a,
          noName: !s,
          noValue: a == null
        })]
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.setData = function(r) {
      this._data = r;
    }, t.prototype.getDataParams = function(r, n) {
      var i = mw.prototype.getDataParams.call(this, r, n), o = this.__hostSeries;
      return o && (i.seriesId = o.id, i.seriesName = o.name, i.seriesType = o.subType), i;
    }, t.getMarkerModelFromSeries = function(r, n) {
      return Py(r)[n];
    }, t.type = "marker", t.dependencies = ["series", "grid", "polar", "geo"], t;
  }(Vt)
);
cn(il, mw.prototype);
var rNe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.createMarkerModelFromSeries = function(r, n, i) {
      return new t(r, n, i);
    }, t.type = "markPoint", t.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, t;
  }(il)
);
function GT(e) {
  return !(isNaN(parseFloat(e.x)) && isNaN(parseFloat(e.y)));
}
function nNe(e) {
  return !isNaN(parseFloat(e.x)) && !isNaN(parseFloat(e.y));
}
function My(e, t, r, n, i, o) {
  var a = [], s = tl(
    t,
    n
    /* , otherDataDim */
  ), l = s ? t.getCalculationInfo("stackResultDimension") : n, u = KA(t, l, e), c = t.indicesOfNearest(l, u)[0];
  a[i] = t.get(r, c), a[o] = t.get(l, c);
  var d = t.get(n, c), h = ba(t.get(n, c));
  return h = Math.min(h, 20), h >= 0 && (a[o] = +a[o].toFixed(h)), [a, d];
}
var rE = {
  min: _t(My, "min"),
  max: _t(My, "max"),
  average: _t(My, "average"),
  median: _t(My, "median")
};
function cv(e, t) {
  if (t) {
    var r = e.getData(), n = e.coordinateSystem, i = n && n.dimensions;
    if (!nNe(t) && !be(t.coord) && be(i)) {
      var o = iY(t, r, n, e);
      if (t = dt(t), t.type && rE[t.type] && o.baseAxis && o.valueAxis) {
        var a = Ft(i, o.baseAxis.dim), s = Ft(i, o.valueAxis.dim), l = rE[t.type](r, o.baseDataDim, o.valueDataDim, a, s);
        t.coord = l[0], t.value = l[1];
      } else
        t.coord = [t.xAxis != null ? t.xAxis : t.radiusAxis, t.yAxis != null ? t.yAxis : t.angleAxis];
    }
    if (t.coord == null || !be(i))
      t.coord = [];
    else
      for (var u = t.coord, c = 0; c < 2; c++)
        rE[u[c]] && (u[c] = KA(r, r.mapDimension(i[c]), u[c]));
    return t;
  }
}
function iY(e, t, r, n) {
  var i = {};
  return e.valueIndex != null || e.valueDim != null ? (i.valueDataDim = e.valueIndex != null ? t.getDimension(e.valueIndex) : e.valueDim, i.valueAxis = r.getAxis(iNe(n, i.valueDataDim)), i.baseAxis = r.getOtherAxis(i.valueAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim)) : (i.baseAxis = n.getBaseAxis(), i.valueAxis = r.getOtherAxis(i.baseAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim), i.valueDataDim = t.mapDimension(i.valueAxis.dim)), i;
}
function iNe(e, t) {
  var r = e.getData().getDimensionInfo(t);
  return r && r.coordDim;
}
function dv(e, t) {
  return e && e.containData && t.coord && !GT(t) ? e.containData(t.coord) : !0;
}
function oNe(e, t, r) {
  return e && e.containZone && t.coord && r.coord && !GT(t) && !GT(r) ? e.containZone(t.coord, r.coord) : !0;
}
function oY(e, t) {
  return e ? function(r, n, i, o) {
    var a = o < 2 ? r.coord && r.coord[o] : r.value;
    return jl(a, t[o]);
  } : function(r, n, i, o) {
    return jl(r.value, t[o]);
  };
}
function KA(e, t, r) {
  if (r === "average") {
    var n = 0, i = 0;
    return e.each(t, function(o, a) {
      isNaN(o) || (n += o, i++);
    }), n / i;
  } else return r === "median" ? e.getMedian(t) : e.getDataExtent(t)[r === "max" ? 1 : 0];
}
var nE = ar(), YA = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function() {
      this.markerGroupMap = nt();
    }, t.prototype.render = function(r, n, i) {
      var o = this, a = this.markerGroupMap;
      a.each(function(s) {
        nE(s).keep = !1;
      }), n.eachSeries(function(s) {
        var l = il.getMarkerModelFromSeries(s, o.type);
        l && o.renderSeries(s, l, n, i);
      }), a.each(function(s) {
        !nE(s).keep && o.group.remove(s.group);
      });
    }, t.prototype.markKeep = function(r) {
      nE(r).keep = !0;
    }, t.prototype.toggleBlurSeries = function(r, n) {
      var i = this;
      $(r, function(o) {
        var a = il.getMarkerModelFromSeries(o, i.type);
        if (a) {
          var s = a.getData();
          s.eachItemGraphicEl(function(l) {
            l && (n ? GW(l) : rD(l));
          });
        }
      });
    }, t.type = "marker", t;
  }(zr)
);
function G$(e, t, r) {
  var n = t.coordinateSystem;
  e.each(function(i) {
    var o = e.getItemModel(i), a, s = Be(o.get("x"), r.getWidth()), l = Be(o.get("y"), r.getHeight());
    if (!isNaN(s) && !isNaN(l))
      a = [s, l];
    else if (t.getMarkerPosition)
      a = t.getMarkerPosition(e.getValues(e.dimensions, i));
    else if (n) {
      var u = e.get(n.dimensions[0], i), c = e.get(n.dimensions[1], i);
      a = n.dataToPoint([u, c]);
    }
    isNaN(s) || (a[0] = s), isNaN(l) || (a[1] = l), e.setItemLayout(i, a);
  });
}
var aNe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.updateTransform = function(r, n, i) {
      n.eachSeries(function(o) {
        var a = il.getMarkerModelFromSeries(o, "markPoint");
        a && (G$(a.getData(), o, i), this.markerGroupMap.get(o.id).updateLayout());
      }, this);
    }, t.prototype.renderSeries = function(r, n, i, o) {
      var a = r.coordinateSystem, s = r.id, l = r.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new Uv()), d = sNe(a, r, n);
      n.setData(d), G$(n.getData(), r, o), d.each(function(h) {
        var f = d.getItemModel(h), p = f.getShallow("symbol"), g = f.getShallow("symbolSize"), v = f.getShallow("symbolRotate"), m = f.getShallow("symbolOffset"), y = f.getShallow("symbolKeepAspect");
        if (at(p) || at(g) || at(v) || at(m)) {
          var C = n.getRawValue(h), S = n.getDataParams(h);
          at(p) && (p = p(C, S)), at(g) && (g = g(C, S)), at(v) && (v = v(C, S)), at(m) && (m = m(C, S));
        }
        var b = f.getModel("itemStyle").getItemStyle(), w = zv(l, "color");
        b.fill || (b.fill = w), d.setItemVisual(h, {
          symbol: p,
          symbolSize: g,
          symbolRotate: v,
          symbolOffset: m,
          symbolKeepAspect: y,
          style: b
        });
      }), c.updateData(d), this.group.add(c.group), d.eachItemGraphicEl(function(h) {
        h.traverse(function(f) {
          St(f).dataModel = n;
        });
      }), this.markKeep(c), c.group.silent = n.get("silent") || r.get("silent");
    }, t.type = "markPoint", t;
  }(YA)
);
function sNe(e, t, r) {
  var n;
  e ? n = Ee(e && e.dimensions, function(s) {
    var l = t.getData().getDimensionInfo(t.getData().mapDimension(s)) || {};
    return ge(ge({}, l), {
      name: s,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : n = [{
    name: "value",
    type: "float"
  }];
  var i = new di(n, r), o = Ee(r.get("data"), _t(cv, t));
  e && (o = Sr(o, _t(dv, e)));
  var a = oY(!!e, n);
  return i.initData(o, null, a), i;
}
function lNe(e) {
  e.registerComponentModel(rNe), e.registerComponentView(aNe), e.registerPreprocessor(function(t) {
    UA(t.series, "markPoint") && (t.markPoint = t.markPoint || {});
  });
}
var uNe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.createMarkerModelFromSeries = function(r, n, i) {
      return new t(r, n, i);
    }, t.type = "markLine", t.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, t;
  }(il)
), Dy = ar(), cNe = function(e, t, r, n) {
  var i = e.getData(), o;
  if (be(n))
    o = n;
  else {
    var a = n.type;
    if (a === "min" || a === "max" || a === "average" || a === "median" || n.xAxis != null || n.yAxis != null) {
      var s = void 0, l = void 0;
      if (n.yAxis != null || n.xAxis != null)
        s = t.getAxis(n.yAxis != null ? "y" : "x"), l = vn(n.yAxis, n.xAxis);
      else {
        var u = iY(n, i, t, e);
        s = u.valueAxis;
        var c = HD(i, u.valueDataDim);
        l = KA(i, c, a);
      }
      var d = s.dim === "x" ? 0 : 1, h = 1 - d, f = dt(n), p = {
        coord: []
      };
      f.type = null, f.coord = [], f.coord[h] = -1 / 0, p.coord[h] = 1 / 0;
      var g = r.get("precision");
      g >= 0 && sr(l) && (l = +l.toFixed(Math.min(g, 20))), f.coord[d] = p.coord[d] = l, o = [f, p, {
        type: a,
        valueIndex: n.valueIndex,
        // Force to use the value of calculated value.
        value: l
      }];
    } else
      process.env.NODE_ENV !== "production" && Ko("Invalid markLine data."), o = [];
  }
  var v = [cv(e, o[0]), cv(e, o[1]), ge({}, o[2])];
  return v[2].type = v[2].type || null, Mt(v[2], v[0]), Mt(v[2], v[1]), v;
};
function jC(e) {
  return !isNaN(e) && !isFinite(e);
}
function z$(e, t, r, n) {
  var i = 1 - e, o = n.dimensions[e];
  return jC(t[i]) && jC(r[i]) && t[e] === r[e] && n.getAxis(o).containData(t[e]);
}
function dNe(e, t) {
  if (e.type === "cartesian2d") {
    var r = t[0].coord, n = t[1].coord;
    if (r && n && (z$(1, r, n, e) || z$(0, r, n, e)))
      return !0;
  }
  return dv(e, t[0]) && dv(e, t[1]);
}
function iE(e, t, r, n, i) {
  var o = n.coordinateSystem, a = e.getItemModel(t), s, l = Be(a.get("x"), i.getWidth()), u = Be(a.get("y"), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (n.getMarkerPosition)
      s = n.getMarkerPosition(e.getValues(e.dimensions, t));
    else {
      var c = o.dimensions, d = e.get(c[0], t), h = e.get(c[1], t);
      s = o.dataToPoint([d, h]);
    }
    if (cd(o, "cartesian2d")) {
      var f = o.getAxis("x"), p = o.getAxis("y"), c = o.dimensions;
      jC(e.get(c[0], t)) ? s[0] = f.toGlobalCoord(f.getExtent()[r ? 0 : 1]) : jC(e.get(c[1], t)) && (s[1] = p.toGlobalCoord(p.getExtent()[r ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  e.setItemLayout(t, s);
}
var hNe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.updateTransform = function(r, n, i) {
      n.eachSeries(function(o) {
        var a = il.getMarkerModelFromSeries(o, "markLine");
        if (a) {
          var s = a.getData(), l = Dy(a).from, u = Dy(a).to;
          l.each(function(c) {
            iE(l, c, !0, o, i), iE(u, c, !1, o, i);
          }), s.each(function(c) {
            s.setItemLayout(c, [l.getItemLayout(c), u.getItemLayout(c)]);
          }), this.markerGroupMap.get(o.id).updateLayout();
        }
      }, this);
    }, t.prototype.renderSeries = function(r, n, i, o) {
      var a = r.coordinateSystem, s = r.id, l = r.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new mA());
      this.group.add(c.group);
      var d = fNe(a, r, n), h = d.from, f = d.to, p = d.line;
      Dy(n).from = h, Dy(n).to = f, n.setData(p);
      var g = n.get("symbol"), v = n.get("symbolSize"), m = n.get("symbolRotate"), y = n.get("symbolOffset");
      be(g) || (g = [g, g]), be(v) || (v = [v, v]), be(m) || (m = [m, m]), be(y) || (y = [y, y]), d.from.each(function(S) {
        C(h, S, !0), C(f, S, !1);
      }), p.each(function(S) {
        var b = p.getItemModel(S).getModel("lineStyle").getLineStyle();
        p.setItemLayout(S, [h.getItemLayout(S), f.getItemLayout(S)]), b.stroke == null && (b.stroke = h.getItemVisual(S, "style").fill), p.setItemVisual(S, {
          fromSymbolKeepAspect: h.getItemVisual(S, "symbolKeepAspect"),
          fromSymbolOffset: h.getItemVisual(S, "symbolOffset"),
          fromSymbolRotate: h.getItemVisual(S, "symbolRotate"),
          fromSymbolSize: h.getItemVisual(S, "symbolSize"),
          fromSymbol: h.getItemVisual(S, "symbol"),
          toSymbolKeepAspect: f.getItemVisual(S, "symbolKeepAspect"),
          toSymbolOffset: f.getItemVisual(S, "symbolOffset"),
          toSymbolRotate: f.getItemVisual(S, "symbolRotate"),
          toSymbolSize: f.getItemVisual(S, "symbolSize"),
          toSymbol: f.getItemVisual(S, "symbol"),
          style: b
        });
      }), c.updateData(p), d.line.eachItemGraphicEl(function(S) {
        St(S).dataModel = n, S.traverse(function(b) {
          St(b).dataModel = n;
        });
      });
      function C(S, b, w) {
        var x = S.getItemModel(b);
        iE(S, b, w, r, o);
        var R = x.getModel("itemStyle").getItemStyle();
        R.fill == null && (R.fill = zv(l, "color")), S.setItemVisual(b, {
          symbolKeepAspect: x.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: bt(x.get("symbolOffset", !0), y[w ? 0 : 1]),
          symbolRotate: bt(x.get("symbolRotate", !0), m[w ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: bt(x.get("symbolSize"), v[w ? 0 : 1]),
          symbol: bt(x.get("symbol", !0), g[w ? 0 : 1]),
          style: R
        });
      }
      this.markKeep(c), c.group.silent = n.get("silent") || r.get("silent");
    }, t.type = "markLine", t;
  }(YA)
);
function fNe(e, t, r) {
  var n;
  e ? n = Ee(e && e.dimensions, function(u) {
    var c = t.getData().getDimensionInfo(t.getData().mapDimension(u)) || {};
    return ge(ge({}, c), {
      name: u,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : n = [{
    name: "value",
    type: "float"
  }];
  var i = new di(n, r), o = new di(n, r), a = new di([], r), s = Ee(r.get("data"), _t(cNe, t, e, r));
  e && (s = Sr(s, _t(dNe, e)));
  var l = oY(!!e, n);
  return i.initData(Ee(s, function(u) {
    return u[0];
  }), null, l), o.initData(Ee(s, function(u) {
    return u[1];
  }), null, l), a.initData(Ee(s, function(u) {
    return u[2];
  })), a.hasItemOption = !0, {
    from: i,
    to: o,
    line: a
  };
}
function pNe(e) {
  e.registerComponentModel(uNe), e.registerComponentView(hNe), e.registerPreprocessor(function(t) {
    UA(t.series, "markLine") && (t.markLine = t.markLine || {});
  });
}
var gNe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.createMarkerModelFromSeries = function(r, n, i) {
      return new t(r, n, i);
    }, t.type = "markArea", t.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, t;
  }(il)
), Ay = ar(), vNe = function(e, t, r, n) {
  var i = n[0], o = n[1];
  if (!(!i || !o)) {
    var a = cv(e, i), s = cv(e, o), l = a.coord, u = s.coord;
    l[0] = vn(l[0], -1 / 0), l[1] = vn(l[1], -1 / 0), u[0] = vn(u[0], 1 / 0), u[1] = vn(u[1], 1 / 0);
    var c = zS([{}, a, s]);
    return c.coord = [a.coord, s.coord], c.x0 = a.x, c.y0 = a.y, c.x1 = s.x, c.y1 = s.y, c;
  }
};
function UC(e) {
  return !isNaN(e) && !isFinite(e);
}
function W$(e, t, r, n) {
  var i = 1 - e;
  return UC(t[i]) && UC(r[i]);
}
function mNe(e, t) {
  var r = t.coord[0], n = t.coord[1], i = {
    coord: r,
    x: t.x0,
    y: t.y0
  }, o = {
    coord: n,
    x: t.x1,
    y: t.y1
  };
  return cd(e, "cartesian2d") ? r && n && (W$(1, r, n) || W$(0, r, n)) ? !0 : oNe(e, i, o) : dv(e, i) || dv(e, o);
}
function j$(e, t, r, n, i) {
  var o = n.coordinateSystem, a = e.getItemModel(t), s, l = Be(a.get(r[0]), i.getWidth()), u = Be(a.get(r[1]), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (n.getMarkerPosition) {
      var c = e.getValues(["x0", "y0"], t), d = e.getValues(["x1", "y1"], t), h = o.clampData(c), f = o.clampData(d), p = [];
      r[0] === "x0" ? p[0] = h[0] > f[0] ? d[0] : c[0] : p[0] = h[0] > f[0] ? c[0] : d[0], r[1] === "y0" ? p[1] = h[1] > f[1] ? d[1] : c[1] : p[1] = h[1] > f[1] ? c[1] : d[1], s = n.getMarkerPosition(p, r, !0);
    } else {
      var g = e.get(r[0], t), v = e.get(r[1], t), m = [g, v];
      o.clampData && o.clampData(m, m), s = o.dataToPoint(m, !0);
    }
    if (cd(o, "cartesian2d")) {
      var y = o.getAxis("x"), C = o.getAxis("y"), g = e.get(r[0], t), v = e.get(r[1], t);
      UC(g) ? s[0] = y.toGlobalCoord(y.getExtent()[r[0] === "x0" ? 0 : 1]) : UC(v) && (s[1] = C.toGlobalCoord(C.getExtent()[r[1] === "y0" ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  return s;
}
var U$ = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], yNe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.updateTransform = function(r, n, i) {
      n.eachSeries(function(o) {
        var a = il.getMarkerModelFromSeries(o, "markArea");
        if (a) {
          var s = a.getData();
          s.each(function(l) {
            var u = Ee(U$, function(d) {
              return j$(s, l, d, o, i);
            });
            s.setItemLayout(l, u);
            var c = s.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, t.prototype.renderSeries = function(r, n, i, o) {
      var a = r.coordinateSystem, s = r.id, l = r.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, {
        group: new Ct()
      });
      this.group.add(c.group), this.markKeep(c);
      var d = CNe(a, r, n);
      n.setData(d), d.each(function(h) {
        var f = Ee(U$, function(R) {
          return j$(d, h, R, r, o);
        }), p = a.getAxis("x").scale, g = a.getAxis("y").scale, v = p.getExtent(), m = g.getExtent(), y = [p.parse(d.get("x0", h)), p.parse(d.get("x1", h))], C = [g.parse(d.get("y0", h)), g.parse(d.get("y1", h))];
        vo(y), vo(C);
        var S = !(v[0] > y[1] || v[1] < y[0] || m[0] > C[1] || m[1] < C[0]), b = !S;
        d.setItemLayout(h, {
          points: f,
          allClipped: b
        });
        var w = d.getItemModel(h).getModel("itemStyle").getItemStyle(), x = zv(l, "color");
        w.fill || (w.fill = x, He(w.fill) && (w.fill = Gg(w.fill, 0.4))), w.stroke || (w.stroke = x), d.setItemVisual(h, "style", w);
      }), d.diff(Ay(c).data).add(function(h) {
        var f = d.getItemLayout(h);
        if (!f.allClipped) {
          var p = new Li({
            shape: {
              points: f.points
            }
          });
          d.setItemGraphicEl(h, p), c.group.add(p);
        }
      }).update(function(h, f) {
        var p = Ay(c).data.getItemGraphicEl(f), g = d.getItemLayout(h);
        g.allClipped ? p && c.group.remove(p) : (p ? ur(p, {
          shape: {
            points: g.points
          }
        }, n, h) : p = new Li({
          shape: {
            points: g.points
          }
        }), d.setItemGraphicEl(h, p), c.group.add(p));
      }).remove(function(h) {
        var f = Ay(c).data.getItemGraphicEl(h);
        c.group.remove(f);
      }).execute(), d.eachItemGraphicEl(function(h, f) {
        var p = d.getItemModel(f), g = d.getItemVisual(f, "style");
        h.useStyle(d.getItemVisual(f, "style")), ri(h, $n(p), {
          labelFetcher: n,
          labelDataIndex: f,
          defaultText: d.getName(f) || "",
          inheritColor: He(g.fill) ? Gg(g.fill, 1) : "#000"
        }), ti(h, p), sn(h, null, null, p.get(["emphasis", "disabled"])), St(h).dataModel = n;
      }), Ay(c).data = d, c.group.silent = n.get("silent") || r.get("silent");
    }, t.type = "markArea", t;
  }(YA)
);
function CNe(e, t, r) {
  var n, i, o = ["x0", "y0", "x1", "y1"];
  if (e) {
    var a = Ee(e && e.dimensions, function(u) {
      var c = t.getData(), d = c.getDimensionInfo(c.mapDimension(u)) || {};
      return ge(ge({}, d), {
        name: u,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    i = Ee(o, function(u, c) {
      return {
        name: u,
        type: a[c % 2].type
      };
    }), n = new di(i, r);
  } else
    i = [{
      name: "value",
      type: "float"
    }], n = new di(i, r);
  var s = Ee(r.get("data"), _t(vNe, t, e, r));
  e && (s = Sr(s, _t(mNe, e)));
  var l = e ? function(u, c, d, h) {
    var f = u.coord[Math.floor(h / 2)][h % 2];
    return jl(f, i[h]);
  } : function(u, c, d, h) {
    return jl(u.value, i[h]);
  };
  return n.initData(s, null, l), n.hasItemOption = !0, n;
}
function SNe(e) {
  e.registerComponentModel(gNe), e.registerComponentView(yNe), e.registerPreprocessor(function(t) {
    UA(t.series, "markArea") && (t.markArea = t.markArea || {});
  });
}
var wNe = function(e, t) {
  if (t === "all")
    return {
      type: "all",
      title: e.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (t === "inverse")
    return {
      type: "inverse",
      title: e.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, zT = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, r;
    }
    return t.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i), r.selected = r.selected || {}, this._updateSelector(r);
    }, t.prototype.mergeOption = function(r, n) {
      e.prototype.mergeOption.call(this, r, n), this._updateSelector(r);
    }, t.prototype._updateSelector = function(r) {
      var n = r.selector, i = this.ecModel;
      n === !0 && (n = r.selector = ["all", "inverse"]), be(n) && $(n, function(o, a) {
        He(o) && (o = {
          type: o
        }), n[a] = Mt(o, wNe(i, o.type));
      });
    }, t.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var r = this._data;
      if (r[0] && this.get("selectedMode") === "single") {
        for (var n = !1, i = 0; i < r.length; i++) {
          var o = r[i].get("name");
          if (this.isSelected(o)) {
            this.select(o), n = !0;
            break;
          }
        }
        !n && this.select(r[0].get("name"));
      }
    }, t.prototype._updateData = function(r) {
      var n = [], i = [];
      r.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var d = l.legendVisualProvider, h = d.getAllNames();
          r.isSeriesFiltered(l) || (i = i.concat(h)), h.length ? n = n.concat(h) : c = !0;
        } else
          c = !0;
        c && YM(l) && n.push(l.name);
      }), this._availableNames = i;
      var o = this.get("data") || n, a = nt(), s = Ee(o, function(l) {
        return (He(l) || sr(l)) && (l = {
          name: l
        }), a.get(l.name) ? null : (a.set(l.name, !0), new _r(l, this, this.ecModel));
      }, this);
      this._data = Sr(s, function(l) {
        return !!l;
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.select = function(r) {
      var n = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var o = this._data;
        $(o, function(a) {
          n[a.get("name")] = !1;
        });
      }
      n[r] = !0;
    }, t.prototype.unSelect = function(r) {
      this.get("selectedMode") !== "single" && (this.option.selected[r] = !1);
    }, t.prototype.toggleSelected = function(r) {
      var n = this.option.selected;
      n.hasOwnProperty(r) || (n[r] = !0), this[n[r] ? "unSelect" : "select"](r);
    }, t.prototype.allSelect = function() {
      var r = this._data, n = this.option.selected;
      $(r, function(i) {
        n[i.get("name", !0)] = !0;
      });
    }, t.prototype.inverseSelect = function() {
      var r = this._data, n = this.option.selected;
      $(r, function(i) {
        var o = i.get("name", !0);
        n.hasOwnProperty(o) || (n[o] = !0), n[o] = !n[o];
      });
    }, t.prototype.isSelected = function(r) {
      var n = this.option.selected;
      return !(n.hasOwnProperty(r) && !n[r]) && Ft(this._availableNames, r) >= 0;
    }, t.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, t.type = "legend.plain", t.dependencies = ["series"], t.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      }
    }, t;
  }(Vt)
), qd = _t, WT = $, Iy = Ct, aY = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.newlineDisabled = !1, r;
    }
    return t.prototype.init = function() {
      this.group.add(this._contentGroup = new Iy()), this.group.add(this._selectorGroup = new Iy()), this._isFirstRender = !0;
    }, t.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, t.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, t.prototype.render = function(r, n, i) {
      var o = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!r.get("show", !0)) {
        var a = r.get("align"), s = r.get("orient");
        (!a || a === "auto") && (a = r.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = r.get("selector", !0), u = r.get("selectorPosition", !0);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(a, r, n, i, l, s, u);
        var c = r.getBoxLayoutParams(), d = {
          width: i.getWidth(),
          height: i.getHeight()
        }, h = r.get("padding"), f = En(c, d, h), p = this.layoutInner(r, a, f, o, l, u), g = En(ut({
          width: p.width,
          height: p.height
        }, c), d, h);
        this.group.x = g.x - p.x, this.group.y = g.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = YK(p, r));
      }
    }, t.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, t.prototype.renderInner = function(r, n, i, o, a, s, l) {
      var u = this.getContentGroup(), c = nt(), d = n.get("selectedMode"), h = [];
      i.eachRawSeries(function(f) {
        !f.get("legendHoverLink") && h.push(f.id);
      }), WT(n.getData(), function(f, p) {
        var g = f.get("name");
        if (!this.newlineDisabled && (g === "" || g === `
`)) {
          var v = new Iy();
          v.newline = !0, u.add(v);
          return;
        }
        var m = i.getSeriesByName(g)[0];
        if (!c.get(g)) {
          if (m) {
            var y = m.getData(), C = y.getVisual("legendLineStyle") || {}, S = y.getVisual("legendIcon"), b = y.getVisual("style"), w = this._createItem(m, g, p, f, n, r, C, b, S, d, o);
            w.on("click", qd(K$, g, null, o, h)).on("mouseover", qd(jT, m.name, null, o, h)).on("mouseout", qd(UT, m.name, null, o, h)), i.ssr && w.eachChild(function(x) {
              var R = St(x);
              R.seriesIndex = m.seriesIndex, R.dataIndex = p, R.ssrType = "legend";
            }), c.set(g, !0);
          } else
            i.eachRawSeries(function(x) {
              if (!c.get(g) && x.legendVisualProvider) {
                var R = x.legendVisualProvider;
                if (!R.containName(g))
                  return;
                var _ = R.indexOfName(g), T = R.getItemVisual(_, "style"), P = R.getItemVisual(_, "legendIcon"), D = Pi(T.fill);
                D && D[3] === 0 && (D[3] = 0.2, T = ge(ge({}, T), {
                  fill: Pa(D, "rgba")
                }));
                var O = this._createItem(x, g, p, f, n, r, {}, T, P, d, o);
                O.on("click", qd(K$, null, g, o, h)).on("mouseover", qd(jT, null, g, o, h)).on("mouseout", qd(UT, null, g, o, h)), i.ssr && O.eachChild(function(A) {
                  var F = St(A);
                  F.seriesIndex = x.seriesIndex, F.dataIndex = p, F.ssrType = "legend";
                }), c.set(g, !0);
              }
            }, this);
          process.env.NODE_ENV !== "production" && (c.get(g) || console.warn(g + " series not exists. Legend data should be same with series name or data name."));
        }
      }, this), a && this._createSelector(a, n, o, s, l);
    }, t.prototype._createSelector = function(r, n, i, o, a) {
      var s = this.getSelectorGroup();
      WT(r, function(u) {
        var c = u.type, d = new ir({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect"
            });
          }
        });
        s.add(d);
        var h = n.getModel("selectorLabel"), f = n.getModel(["emphasis", "selectorLabel"]);
        ri(d, {
          normal: h,
          emphasis: f
        }, {
          defaultText: u.title
        }), zl(d);
      });
    }, t.prototype._createItem = function(r, n, i, o, a, s, l, u, c, d, h) {
      var f = r.visualDrawType, p = a.get("itemWidth"), g = a.get("itemHeight"), v = a.isSelected(n), m = o.get("symbolRotate"), y = o.get("symbolKeepAspect"), C = o.get("icon");
      c = C || c || "roundRect";
      var S = bNe(c, o, l, u, f, v, h), b = new Iy(), w = o.getModel("textStyle");
      if (at(r.getLegendIcon) && (!C || C === "inherit"))
        b.add(r.getLegendIcon({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: m,
          itemStyle: S.itemStyle,
          lineStyle: S.lineStyle,
          symbolKeepAspect: y
        }));
      else {
        var x = C === "inherit" && r.getData().getVisual("symbol") ? m === "inherit" ? r.getData().getVisual("symbolRotate") : m : 0;
        b.add(xNe({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: x,
          itemStyle: S.itemStyle,
          lineStyle: S.lineStyle,
          symbolKeepAspect: y
        }));
      }
      var R = s === "left" ? p + 5 : -5, _ = s, T = a.get("formatter"), P = n;
      He(T) && T ? P = T.replace("{name}", n ?? "") : at(T) && (P = T(n));
      var D = v ? w.getTextColor() : o.get("inactiveColor");
      b.add(new ir({
        style: Vr(w, {
          text: P,
          x: R,
          y: g / 2,
          fill: D,
          align: _,
          verticalAlign: "middle"
        }, {
          inheritColor: D
        })
      }));
      var O = new or({
        shape: b.getBoundingRect(),
        style: {
          // Cannot use 'invisible' because SVG SSR will miss the node
          fill: "transparent"
        }
      }), A = o.getModel("tooltip");
      return A.get("show") && Cf({
        el: O,
        componentModel: a,
        itemName: n,
        itemTooltipOption: A.option
      }), b.add(O), b.eachChild(function(F) {
        F.silent = !0;
      }), O.silent = !d, this.getContentGroup().add(b), zl(b), b.__legendDataIndex = i, b;
    }, t.prototype.layoutInner = function(r, n, i, o, a, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      Mc(r.get("orient"), l, r.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), d = [-c.x, -c.y];
      if (u.markRedraw(), l.markRedraw(), a) {
        Mc(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          u,
          r.get("selectorItemGap", !0)
        );
        var h = u.getBoundingRect(), f = [-h.x, -h.y], p = r.get("selectorButtonGap", !0), g = r.getOrient().index, v = g === 0 ? "width" : "height", m = g === 0 ? "height" : "width", y = g === 0 ? "y" : "x";
        s === "end" ? f[g] += c[v] + p : d[g] += h[v] + p, f[1 - g] += c[m] / 2 - h[m] / 2, u.x = f[0], u.y = f[1], l.x = d[0], l.y = d[1];
        var C = {
          x: 0,
          y: 0
        };
        return C[v] = c[v] + p + h[v], C[m] = Math.max(c[m], h[m]), C[y] = Math.min(0, h[y] + f[1 - g]), C;
      } else
        return l.x = d[0], l.y = d[1], this.group.getBoundingRect();
    }, t.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, t.type = "legend.plain", t;
  }(zr)
);
function bNe(e, t, r, n, i, o, a) {
  function s(v, m) {
    v.lineWidth === "auto" && (v.lineWidth = m.lineWidth > 0 ? 2 : 0), WT(v, function(y, C) {
      v[C] === "inherit" && (v[C] = m[C]);
    });
  }
  var l = t.getModel("itemStyle"), u = l.getItemStyle(), c = e.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", d = l.getShallow("decal");
  u.decal = !d || d === "inherit" ? n.decal : Yh(d, a), u.fill === "inherit" && (u.fill = n[i]), u.stroke === "inherit" && (u.stroke = n[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? n : r).opacity), s(u, n);
  var h = t.getModel("lineStyle"), f = h.getLineStyle();
  if (s(f, r), u.fill === "auto" && (u.fill = n.fill), u.stroke === "auto" && (u.stroke = n.fill), f.stroke === "auto" && (f.stroke = n.fill), !o) {
    var p = t.get("inactiveBorderWidth"), g = u[c];
    u.lineWidth = p === "auto" ? n.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = t.get("inactiveColor"), u.stroke = t.get("inactiveBorderColor"), f.stroke = h.get("inactiveColor"), f.lineWidth = h.get("inactiveWidth");
  }
  return {
    itemStyle: u,
    lineStyle: f
  };
}
function xNe(e) {
  var t = e.icon || "roundRect", r = mn(t, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill, e.symbolKeepAspect);
  return r.setStyle(e.itemStyle), r.rotation = (e.iconRotate || 0) * Math.PI / 180, r.setOrigin([e.itemWidth / 2, e.itemHeight / 2]), t.indexOf("empty") > -1 && (r.style.stroke = r.style.fill, r.style.fill = "#fff", r.style.lineWidth = 2), r;
}
function K$(e, t, r, n) {
  UT(e, t, r, n), r.dispatchAction({
    type: "legendToggleSelect",
    name: e ?? t
  }), jT(e, t, r, n);
}
function sY(e) {
  for (var t = e.getZr().storage.getDisplayList(), r, n = 0, i = t.length; n < i && !(r = t[n].states.emphasis); )
    n++;
  return r && r.hoverLayer;
}
function jT(e, t, r, n) {
  sY(r) || r.dispatchAction({
    type: "highlight",
    seriesName: e,
    name: t,
    excludeSeriesId: n
  });
}
function UT(e, t, r, n) {
  sY(r) || r.dispatchAction({
    type: "downplay",
    seriesName: e,
    name: t,
    excludeSeriesId: n
  });
}
function ENe(e) {
  var t = e.findComponents({
    mainType: "legend"
  });
  t && t.length && e.filterSeries(function(r) {
    for (var n = 0; n < t.length; n++)
      if (!t[n].isSelected(r.name))
        return !1;
    return !0;
  });
}
function wp(e, t, r) {
  var n = {}, i = e === "toggleSelected", o;
  return r.eachComponent("legend", function(a) {
    i && o != null ? a[o ? "select" : "unSelect"](t.name) : e === "allSelect" || e === "inverseSelect" ? a[e]() : (a[e](t.name), o = a.isSelected(t.name));
    var s = a.getData();
    $(s, function(l) {
      var u = l.get("name");
      if (!(u === `
` || u === "")) {
        var c = a.isSelected(u);
        n.hasOwnProperty(u) ? n[u] = n[u] && c : n[u] = c;
      }
    });
  }), e === "allSelect" || e === "inverseSelect" ? {
    selected: n
  } : {
    name: t.name,
    selected: n
  };
}
function RNe(e) {
  e.registerAction("legendToggleSelect", "legendselectchanged", _t(wp, "toggleSelected")), e.registerAction("legendAllSelect", "legendselectall", _t(wp, "allSelect")), e.registerAction("legendInverseSelect", "legendinverseselect", _t(wp, "inverseSelect")), e.registerAction("legendSelect", "legendselected", _t(wp, "select")), e.registerAction("legendUnSelect", "legendunselected", _t(wp, "unSelect"));
}
function lY(e) {
  e.registerComponentModel(zT), e.registerComponentView(aY), e.registerProcessor(e.PRIORITY.PROCESSOR.SERIES_FILTER, ENe), e.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), RNe(e);
}
var _Ne = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.setScrollDataIndex = function(r) {
      this.option.scrollDataIndex = r;
    }, t.prototype.init = function(r, n, i) {
      var o = bf(r);
      e.prototype.init.call(this, r, n, i), Y$(this, r, o);
    }, t.prototype.mergeOption = function(r, n) {
      e.prototype.mergeOption.call(this, r, n), Y$(this, this.option, r);
    }, t.type = "legend.scroll", t.defaultOption = wu(zT.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), t;
  }(zT)
);
function Y$(e, t, r) {
  var n = e.getOrient(), i = [1, 1];
  i[n.index] = 0, su(t, r, {
    type: "box",
    ignoreSize: !!i
  });
}
var q$ = Ct, oE = ["width", "height"], aE = ["x", "y"], TNe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.newlineDisabled = !0, r._currentIndex = 0, r;
    }
    return t.prototype.init = function() {
      e.prototype.init.call(this), this.group.add(this._containerGroup = new q$()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new q$());
    }, t.prototype.resetInner = function() {
      e.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, t.prototype.renderInner = function(r, n, i, o, a, s, l) {
      var u = this;
      e.prototype.renderInner.call(this, r, n, i, o, a, s, l);
      var c = this._controllerGroup, d = n.get("pageIconSize", !0), h = be(d) ? d : [d, d];
      p("pagePrev", 0);
      var f = n.getModel("pageTextStyle");
      c.add(new ir({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: f.getTextColor(),
          font: f.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), p("pageNext", 1);
      function p(g, v) {
        var m = g + "DataIndex", y = yf(n.get("pageIcons", !0)[n.getOrient().name][v], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: je(u._pageGo, u, m, n, o)
        }, {
          x: -h[0] / 2,
          y: -h[1] / 2,
          width: h[0],
          height: h[1]
        });
        y.name = g, c.add(y);
      }
    }, t.prototype.layoutInner = function(r, n, i, o, a, s) {
      var l = this.getSelectorGroup(), u = r.getOrient().index, c = oE[u], d = aE[u], h = oE[1 - u], f = aE[1 - u];
      a && Mc(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        l,
        r.get("selectorItemGap", !0)
      );
      var p = r.get("selectorButtonGap", !0), g = l.getBoundingRect(), v = [-g.x, -g.y], m = dt(i);
      a && (m[c] = i[c] - g[c] - p);
      var y = this._layoutContentAndController(r, o, m, u, c, h, f, d);
      if (a) {
        if (s === "end")
          v[u] += y[c] + p;
        else {
          var C = g[c] + p;
          v[u] -= C, y[d] -= C;
        }
        y[c] += g[c] + p, v[1 - u] += y[f] + y[h] / 2 - g[h] / 2, y[h] = Math.max(y[h], g[h]), y[f] = Math.min(y[f], g[f] + v[1 - u]), l.x = v[0], l.y = v[1], l.markRedraw();
      }
      return y;
    }, t.prototype._layoutContentAndController = function(r, n, i, o, a, s, l, u) {
      var c = this.getContentGroup(), d = this._containerGroup, h = this._controllerGroup;
      Mc(r.get("orient"), c, r.get("itemGap"), o ? i.width : null, o ? null : i.height), Mc(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        h,
        r.get("pageButtonItemGap", !0)
      );
      var f = c.getBoundingRect(), p = h.getBoundingRect(), g = this._showController = f[a] > i[a], v = [-f.x, -f.y];
      n || (v[o] = c[u]);
      var m = [0, 0], y = [-p.x, -p.y], C = bt(r.get("pageButtonGap", !0), r.get("itemGap", !0));
      if (g) {
        var S = r.get("pageButtonPosition", !0);
        S === "end" ? y[o] += i[a] - p[a] : m[o] += p[a] + C;
      }
      y[1 - o] += f[s] / 2 - p[s] / 2, c.setPosition(v), d.setPosition(m), h.setPosition(y);
      var b = {
        x: 0,
        y: 0
      };
      if (b[a] = g ? i[a] : f[a], b[s] = Math.max(f[s], p[s]), b[l] = Math.min(0, p[l] + y[1 - o]), d.__rectSize = i[a], g) {
        var w = {
          x: 0,
          y: 0
        };
        w[a] = Math.max(i[a] - p[a] - C, 0), w[s] = b[s], d.setClipPath(new or({
          shape: w
        })), d.__rectSize = w[a];
      } else
        h.eachChild(function(R) {
          R.attr({
            invisible: !0,
            silent: !0
          });
        });
      var x = this._getPageInfo(r);
      return x.pageIndex != null && ur(
        c,
        {
          x: x.contentPosition[0],
          y: x.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        g ? r : null
      ), this._updatePageInfoView(r, x), b;
    }, t.prototype._pageGo = function(r, n, i) {
      var o = this._getPageInfo(n)[r];
      o != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: o,
        legendId: n.id
      });
    }, t.prototype._updatePageInfoView = function(r, n) {
      var i = this._controllerGroup;
      $(["pagePrev", "pageNext"], function(c) {
        var d = c + "DataIndex", h = n[d] != null, f = i.childOfName(c);
        f && (f.setStyle("fill", h ? r.get("pageIconColor", !0) : r.get("pageIconInactiveColor", !0)), f.cursor = h ? "pointer" : "default");
      });
      var o = i.childOfName("pageText"), a = r.get("pageFormatter"), s = n.pageIndex, l = s != null ? s + 1 : 0, u = n.pageCount;
      o && a && o.setStyle("text", He(a) ? a.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : a({
        current: l,
        total: u
      }));
    }, t.prototype._getPageInfo = function(r) {
      var n = r.get("scrollDataIndex", !0), i = this.getContentGroup(), o = this._containerGroup.__rectSize, a = r.getOrient().index, s = oE[a], l = aE[a], u = this._findTargetItemIndex(n), c = i.children(), d = c[u], h = c.length, f = h ? 1 : 0, p = {
        contentPosition: [i.x, i.y],
        pageCount: f,
        pageIndex: f - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!d)
        return p;
      var g = S(d);
      p.contentPosition[a] = -g.s;
      for (var v = u + 1, m = g, y = g, C = null; v <= h; ++v)
        C = S(c[v]), // Half of the last item is out of the window.
        (!C && y.e > m.s + o || C && !b(C, m.s)) && (y.i > m.i ? m = y : m = C, m && (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = C;
      for (var v = u - 1, m = g, y = g, C = null; v >= -1; --v)
        C = S(c[v]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!C || !b(y, C.s)) && m.i < y.i && (y = m, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = C;
      return p;
      function S(w) {
        if (w) {
          var x = w.getBoundingRect(), R = x[l] + w[l];
          return {
            s: R,
            e: R + x[s],
            i: w.__legendDataIndex
          };
        }
      }
      function b(w, x) {
        return w.e >= x && w.s <= x + o;
      }
    }, t.prototype._findTargetItemIndex = function(r) {
      if (!this._showController)
        return 0;
      var n, i = this.getContentGroup(), o;
      return i.eachChild(function(a, s) {
        var l = a.__legendDataIndex;
        o == null && l != null && (o = s), l === r && (n = s);
      }), n ?? o;
    }, t.type = "legend.scroll", t;
  }(aY)
);
function PNe(e) {
  e.registerAction("legendScroll", "legendscroll", function(t, r) {
    var n = t.scrollDataIndex;
    n != null && r.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: t
    }, function(i) {
      i.setScrollDataIndex(n);
    });
  });
}
function MNe(e) {
  Bt(lY), e.registerComponentModel(_Ne), e.registerComponentView(TNe), PNe(e);
}
function DNe(e) {
  Bt(lY), Bt(MNe);
}
var ANe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "dataZoom.inside", t.defaultOption = wu(uv.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), t;
  }(uv)
), qA = ar();
function INe(e, t, r) {
  qA(e).coordSysRecordMap.each(function(n) {
    var i = n.dataZoomInfoMap.get(t.uid);
    i && (i.getRange = r);
  });
}
function ONe(e, t) {
  for (var r = qA(e).coordSysRecordMap, n = r.keys(), i = 0; i < n.length; i++) {
    var o = n[i], a = r.get(o), s = a.dataZoomInfoMap;
    if (s) {
      var l = t.uid, u = s.get(l);
      u && (s.removeKey(l), s.keys().length || uY(r, a));
    }
  }
}
function uY(e, t) {
  if (t) {
    e.removeKey(t.model.uid);
    var r = t.controller;
    r && r.dispose();
  }
}
function LNe(e, t) {
  var r = {
    model: t,
    containsPoint: _t(NNe, t),
    dispatchAction: _t(FNe, e),
    dataZoomInfoMap: null,
    controller: null
  }, n = r.controller = new Zv(e.getZr());
  return $(["pan", "zoom", "scrollMove"], function(i) {
    n.on(i, function(o) {
      var a = [];
      r.dataZoomInfoMap.each(function(s) {
        if (o.isAvailableBehavior(s.model.option)) {
          var l = (s.getRange || {})[i], u = l && l(s.dzReferCoordSysInfo, r.model.mainType, r.controller, o);
          !s.model.get("disabled", !0) && u && a.push({
            dataZoomId: s.model.id,
            start: u[0],
            end: u[1]
          });
        }
      }), a.length && r.dispatchAction(a);
    });
  }), r;
}
function FNe(e, t) {
  e.isDisposed() || e.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: t
  });
}
function NNe(e, t, r, n) {
  return e.coordinateSystem.containPoint([r, n]);
}
function kNe(e) {
  var t, r = "type_", n = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, i = !0;
  return e.each(function(o) {
    var a = o.model, s = a.get("disabled", !0) ? !1 : a.get("zoomLock", !0) ? "move" : !0;
    n[r + s] > n[r + t] && (t = s), i = i && a.get("preventDefaultMouseMove", !0);
  }), {
    controlType: t,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!i
    }
  };
}
function VNe(e) {
  e.registerProcessor(e.PRIORITY.PROCESSOR.FILTER, function(t, r) {
    var n = qA(r), i = n.coordSysRecordMap || (n.coordSysRecordMap = nt());
    i.each(function(o) {
      o.dataZoomInfoMap = null;
    }), t.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(o) {
      var a = jK(o);
      $(a.infoList, function(s) {
        var l = s.model.uid, u = i.get(l) || i.set(l, LNe(r, s.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = nt());
        c.set(o.uid, {
          dzReferCoordSysInfo: s,
          model: o,
          getRange: null
        });
      });
    }), i.each(function(o) {
      var a = o.controller, s, l = o.dataZoomInfoMap;
      if (l) {
        var u = l.keys()[0];
        u != null && (s = l.get(u));
      }
      if (!s) {
        uY(i, o);
        return;
      }
      var c = kNe(l);
      a.enable(c.controlType, c.opt), a.setPointerChecker(o.containsPoint), Rf(o, "dispatchAction", s.model.get("throttle", !0), "fixRate");
    });
  });
}
var BNe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "dataZoom.inside", r;
    }
    return t.prototype.render = function(r, n, i) {
      if (e.prototype.render.apply(this, arguments), r.noTarget()) {
        this._clear();
        return;
      }
      this.range = r.getPercentRange(), INe(i, r, {
        pan: je(sE.pan, this),
        zoom: je(sE.zoom, this),
        scrollMove: je(sE.scrollMove, this)
      });
    }, t.prototype.dispose = function() {
      this._clear(), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      ONe(this.api, this.dataZoomModel), this.range = null;
    }, t.type = "dataZoom.inside", t;
  }($A)
), sE = {
  zoom: function(e, t, r, n) {
    var i = this.range, o = i.slice(), a = e.axisModels[0];
    if (a) {
      var s = lE[t](null, [n.originX, n.originY], a, r, e), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (o[1] - o[0]) + o[0], u = Math.max(1 / n.scale, 0);
      o[0] = (o[0] - l) * u + l, o[1] = (o[1] - l) * u + l;
      var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (hd(0, o, [0, 100], 0, c.minSpan, c.maxSpan), this.range = o, i[0] !== o[0] || i[1] !== o[1])
        return o;
    }
  },
  pan: X$(function(e, t, r, n, i, o) {
    var a = lE[n]([o.oldX, o.oldY], [o.newX, o.newY], t, i, r);
    return a.signal * (e[1] - e[0]) * a.pixel / a.pixelLength;
  }),
  scrollMove: X$(function(e, t, r, n, i, o) {
    var a = lE[n]([0, 0], [o.scrollDelta, o.scrollDelta], t, i, r);
    return a.signal * (e[1] - e[0]) * o.scrollDelta;
  })
};
function X$(e) {
  return function(t, r, n, i) {
    var o = this.range, a = o.slice(), s = t.axisModels[0];
    if (s) {
      var l = e(a, s, t, r, n, i);
      if (hd(l, a, [0, 100], "all"), this.range = a, o[0] !== a[0] || o[1] !== a[1])
        return a;
    }
  };
}
var lE = {
  grid: function(e, t, r, n, i) {
    var o = r.axis, a = {}, s = i.model.coordinateSystem.getRect();
    return e = e || [0, 0], o.dim === "x" ? (a.pixel = t[0] - e[0], a.pixelLength = s.width, a.pixelStart = s.x, a.signal = o.inverse ? 1 : -1) : (a.pixel = t[1] - e[1], a.pixelLength = s.height, a.pixelStart = s.y, a.signal = o.inverse ? -1 : 1), a;
  },
  polar: function(e, t, r, n, i) {
    var o = r.axis, a = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
    return e = e ? s.pointToCoord(e) : [0, 0], t = s.pointToCoord(t), r.mainType === "radiusAxis" ? (a.pixel = t[0] - e[0], a.pixelLength = l[1] - l[0], a.pixelStart = l[0], a.signal = o.inverse ? 1 : -1) : (a.pixel = t[1] - e[1], a.pixelLength = u[1] - u[0], a.pixelStart = u[0], a.signal = o.inverse ? -1 : 1), a;
  },
  singleAxis: function(e, t, r, n, i) {
    var o = r.axis, a = i.model.coordinateSystem.getRect(), s = {};
    return e = e || [0, 0], o.orient === "horizontal" ? (s.pixel = t[0] - e[0], s.pixelLength = a.width, s.pixelStart = a.x, s.signal = o.inverse ? 1 : -1) : (s.pixel = t[1] - e[1], s.pixelLength = a.height, s.pixelStart = a.y, s.signal = o.inverse ? -1 : 1), s;
  }
};
function cY(e) {
  HA(e), e.registerComponentModel(ANe), e.registerComponentView(BNe), VNe(e);
}
var $Ne = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "dataZoom.slider", t.layoutMode = "box", t.defaultOption = wu(uv.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: !0,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), t;
  }(uv)
), bp = or, Z$ = 7, HNe = 1, uE = 30, GNe = 7, xp = "horizontal", Q$ = "vertical", zNe = 5, WNe = ["line", "bar", "candlestick", "scatter"], jNe = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, UNe = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._displayables = {}, r;
    }
    return t.prototype.init = function(r, n) {
      this.api = n, this._onBrush = je(this._onBrush, this), this._onBrushEnd = je(this._onBrushEnd, this);
    }, t.prototype.render = function(r, n, i, o) {
      if (e.prototype.render.apply(this, arguments), Rf(this, "_dispatchZoomAction", r.get("throttle"), "fixRate"), this._orient = r.getOrient(), r.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (r.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!o || o.type !== "dataZoom" || o.from !== this.uid) && this._buildView(), this._updateView();
    }, t.prototype.dispose = function() {
      this._clear(), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      Xg(this, "_dispatchZoomAction");
      var r = this.api.getZr();
      r.off("mousemove", this._onBrush), r.off("mouseup", this._onBrushEnd);
    }, t.prototype._buildView = function() {
      var r = this.group;
      r.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var n = this._displayables.sliderGroup = new Ct();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), r.add(n), this._positionGroup();
    }, t.prototype._resetLocation = function() {
      var r = this.dataZoomModel, n = this.api, i = r.get("brushSelect"), o = i ? GNe : 0, a = this._findCoordRect(), s = {
        width: n.getWidth(),
        height: n.getHeight()
      }, l = this._orient === xp ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: s.width - a.x - a.width,
        top: s.height - uE - Z$ - o,
        width: a.width,
        height: uE
      } : {
        right: Z$,
        top: a.y,
        width: uE,
        height: a.height
      }, u = bf(r.option);
      $(["right", "top", "width", "height"], function(d) {
        u[d] === "ph" && (u[d] = l[d]);
      });
      var c = En(u, s);
      this._location = {
        x: c.x,
        y: c.y
      }, this._size = [c.width, c.height], this._orient === Q$ && this._size.reverse();
    }, t.prototype._positionGroup = function() {
      var r = this.group, n = this._location, i = this._orient, o = this.dataZoomModel.getFirstTargetAxisModel(), a = o && o.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(i === xp && !a ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === xp && a ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === Q$ && !a ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = r.getBoundingRect([s]);
      r.x = n.x - u.x, r.y = n.y - u.y, r.markRedraw();
    }, t.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, t.prototype._renderBackground = function() {
      var r = this.dataZoomModel, n = this._size, i = this._displayables.sliderGroup, o = r.get("brushSelect");
      i.add(new bp({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: r.get("backgroundColor")
        },
        z2: -40
      }));
      var a = new bp({
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: je(this._onClickPanel, this)
      }), s = this.api.getZr();
      o ? (a.on("mousedown", this._onBrushStart, this), a.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(a);
    }, t.prototype._renderDataShadow = function() {
      var r = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !r)
        return;
      var n = this._size, i = this._shadowSize || [], o = r.series, a = o.getRawData(), s = o.getShadowDim && o.getShadowDim(), l = s && a.getDimensionInfo(s) ? o.getShadowDim() : r.otherDim;
      if (l == null)
        return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (a !== this._shadowData || l !== this._shadowDim || n[0] !== i[0] || n[1] !== i[1]) {
        var d = a.getDataExtent(l), h = (d[1] - d[0]) * 0.3;
        d = [d[0] - h, d[1] + h];
        var f = [0, n[1]], p = [0, n[0]], g = [[n[0], 0], [0, 0]], v = [], m = p[1] / (a.count() - 1), y = 0, C = Math.round(a.count() / n[0]), S;
        a.each([l], function(_, T) {
          if (C > 0 && T % C) {
            y += m;
            return;
          }
          var P = _ == null || isNaN(_) || _ === "", D = P ? 0 : Cr(_, d, f, !0);
          P && !S && T ? (g.push([g[g.length - 1][0], 0]), v.push([v[v.length - 1][0], 0])) : !P && S && (g.push([y, 0]), v.push([y, 0])), g.push([y, D]), v.push([y, D]), y += m, S = P;
        }), u = this._shadowPolygonPts = g, c = this._shadowPolylinePts = v;
      }
      this._shadowData = a, this._shadowDim = l, this._shadowSize = [n[0], n[1]];
      var b = this.dataZoomModel;
      function w(_) {
        var T = b.getModel(_ ? "selectedDataBackground" : "dataBackground"), P = new Ct(), D = new Li({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: T.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), O = new Ni({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: T.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return P.add(D), P.add(O), P;
      }
      for (var x = 0; x < 3; x++) {
        var R = w(x === 1);
        this._displayables.sliderGroup.add(R), this._displayables.dataShadowSegs.push(R);
      }
    }, t.prototype._prepareDataShadowInfo = function() {
      var r = this.dataZoomModel, n = r.get("showDataShadow");
      if (n !== !1) {
        var i, o = this.ecModel;
        return r.eachTargetAxis(function(a, s) {
          var l = r.getAxisProxy(a, s).getTargetSeriesModels();
          $(l, function(u) {
            if (!i && !(n !== !0 && Ft(WNe, u.get("type")) < 0)) {
              var c = o.getComponent(Bl(a), s).axis, d = KNe(a), h, f = u.coordinateSystem;
              d != null && f.getOtherAxis && (h = f.getOtherAxis(c).inverse), d = u.getData().mapDimension(d), i = {
                thisAxis: c,
                series: u,
                thisDim: a,
                otherDim: d,
                otherAxisInverse: h
              };
            }
          }, this);
        }, this), i;
      }
    }, t.prototype._renderHandle = function() {
      var r = this.group, n = this._displayables, i = n.handles = [null, null], o = n.handleLabels = [null, null], a = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, d = l.get("brushSelect"), h = n.filler = new bp({
        silent: d,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      a.add(h), a.add(new bp({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: c
        },
        style: {
          // deprecated option
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: HNe,
          fill: "rgba(0,0,0,0)"
        }
      })), $([0, 1], function(C) {
        var S = l.get("handleIcon");
        !yC[S] && S.indexOf("path://") < 0 && S.indexOf("image://") < 0 && (S = "path://" + S, process.env.NODE_ENV !== "production" && ea("handleIcon now needs 'path://' prefix when using a path string"));
        var b = mn(S, -1, 0, 2, 2, null, !0);
        b.attr({
          cursor: J$(this._orient),
          draggable: !0,
          drift: je(this._onDragMove, this, C),
          ondragend: je(this._onDragEnd, this),
          onmouseover: je(this._showDataInfo, this, !0),
          onmouseout: je(this._showDataInfo, this, !1),
          z2: 5
        });
        var w = b.getBoundingRect(), x = l.get("handleSize");
        this._handleHeight = Be(x, this._size[1]), this._handleWidth = w.width / w.height * this._handleHeight, b.setStyle(l.getModel("handleStyle").getItemStyle()), b.style.strokeNoScale = !0, b.rectHover = !0, b.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), zl(b);
        var R = l.get("handleColor");
        R != null && (b.style.fill = R), a.add(i[C] = b);
        var _ = l.getModel("textStyle");
        r.add(o[C] = new ir({
          silent: !0,
          invisible: !0,
          style: Vr(_, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: _.getTextColor(),
            font: _.getFont()
          }),
          z2: 10
        }));
      }, this);
      var f = h;
      if (d) {
        var p = Be(l.get("moveHandleSize"), s[1]), g = n.moveHandle = new or({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: s[1] - 0.5,
            height: p
          }
        }), v = p * 0.8, m = n.moveHandleIcon = mn(l.get("moveHandleIcon"), -v / 2, -v / 2, v, v, "#fff", !0);
        m.silent = !0, m.y = s[1] + p / 2 - 0.5, g.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var y = Math.min(s[1] / 2, Math.max(p, 10));
        f = n.moveZone = new or({
          invisible: !0,
          shape: {
            y: s[1] - y,
            height: p + y
          }
        }), f.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), a.add(g), a.add(m), a.add(f);
      }
      f.attr({
        draggable: !0,
        cursor: J$(this._orient),
        drift: je(this._onDragMove, this, "all"),
        ondragstart: je(this._showDataInfo, this, !0),
        ondragend: je(this._onDragEnd, this),
        onmouseover: je(this._showDataInfo, this, !0),
        onmouseout: je(this._showDataInfo, this, !1)
      });
    }, t.prototype._resetInterval = function() {
      var r = this._range = this.dataZoomModel.getPercentRange(), n = this._getViewExtent();
      this._handleEnds = [Cr(r[0], [0, 100], n, !0), Cr(r[1], [0, 100], n, !0)];
    }, t.prototype._updateInterval = function(r, n) {
      var i = this.dataZoomModel, o = this._handleEnds, a = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
      hd(n, o, a, i.get("zoomLock") ? "all" : r, s.minSpan != null ? Cr(s.minSpan, l, a, !0) : null, s.maxSpan != null ? Cr(s.maxSpan, l, a, !0) : null);
      var u = this._range, c = this._range = vo([Cr(o[0], a, l, !0), Cr(o[1], a, l, !0)]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, t.prototype._updateView = function(r) {
      var n = this._displayables, i = this._handleEnds, o = vo(i.slice()), a = this._size;
      $([0, 1], function(f) {
        var p = n.handles[f], g = this._handleHeight;
        p.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: i[f] + (f ? -1 : 1),
          y: a[1] / 2 - g / 2
        });
      }, this), n.filler.setShape({
        x: o[0],
        y: 0,
        width: o[1] - o[0],
        height: a[1]
      });
      var s = {
        x: o[0],
        width: o[1] - o[0]
      };
      n.moveHandle && (n.moveHandle.setShape(s), n.moveZone.setShape(s), n.moveZone.getBoundingRect(), n.moveHandleIcon && n.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = n.dataShadowSegs, u = [0, o[0], o[1], a[0]], c = 0; c < l.length; c++) {
        var d = l[c], h = d.getClipPath();
        h || (h = new or(), d.setClipPath(h)), h.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: a[1]
        });
      }
      this._updateDataInfo(r);
    }, t.prototype._updateDataInfo = function(r) {
      var n = this.dataZoomModel, i = this._displayables, o = i.handleLabels, a = this._orient, s = ["", ""];
      if (n.get("showDetail")) {
        var l = n.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, d = r ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          s = [this._formatLabel(d[0], u), this._formatLabel(d[1], u)];
        }
      }
      var h = vo(this._handleEnds.slice());
      f.call(this, 0), f.call(this, 1);
      function f(p) {
        var g = Wl(i.handles[p].parent, this.group), v = uw(p === 0 ? "right" : "left", g), m = this._handleWidth / 2 + zNe, y = Ma([h[p] + (p === 0 ? -m : m), this._size[1] / 2], g);
        o[p].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: a === xp ? "middle" : v,
          align: a === xp ? v : "center",
          text: s[p]
        });
      }
    }, t.prototype._formatLabel = function(r, n) {
      var i = this.dataZoomModel, o = i.get("labelFormatter"), a = i.get("labelPrecision");
      (a == null || a === "auto") && (a = n.getPixelPrecision());
      var s = r == null || isNaN(r) ? "" : n.type === "category" || n.type === "time" ? n.scale.getLabel({
        value: Math.round(r)
      }) : r.toFixed(Math.min(a, 20));
      return at(o) ? o(r, s) : He(o) ? o.replace("{value}", s) : s;
    }, t.prototype._showDataInfo = function(r) {
      r = this._dragging || r;
      var n = this._displayables, i = n.handleLabels;
      i[0].attr("invisible", !r), i[1].attr("invisible", !r), n.moveHandle && this.api[r ? "enterEmphasis" : "leaveEmphasis"](n.moveHandle, 1);
    }, t.prototype._onDragMove = function(r, n, i, o) {
      this._dragging = !0, Zs(o.event);
      var a = this._displayables.sliderGroup.getLocalTransform(), s = Ma([n, i], a, !0), l = this._updateInterval(r, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(!0);
    }, t.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var r = this.dataZoomModel.get("realtime");
      !r && this._dispatchZoomAction(!1);
    }, t.prototype._onClickPanel = function(r) {
      var n = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(r.offsetX, r.offsetY);
      if (!(i[0] < 0 || i[0] > n[0] || i[1] < 0 || i[1] > n[1])) {
        var o = this._handleEnds, a = (o[0] + o[1]) / 2, s = this._updateInterval("all", i[0] - a);
        this._updateView(), s && this._dispatchZoomAction(!1);
      }
    }, t.prototype._onBrushStart = function(r) {
      var n = r.offsetX, i = r.offsetY;
      this._brushStart = new Dt(n, i), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, t.prototype._onBrushEnd = function(r) {
      if (this._brushing) {
        var n = this._displayables.brushRect;
        if (this._brushing = !1, !!n) {
          n.attr("ignore", !0);
          var i = n.shape, o = +/* @__PURE__ */ new Date();
          if (!(o - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var a = this._getViewExtent(), s = [0, 100];
            this._range = vo([Cr(i.x, a, s, !0), Cr(i.x + i.width, a, s, !0)]), this._handleEnds = [i.x, i.x + i.width], this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, t.prototype._onBrush = function(r) {
      this._brushing && (Zs(r.event), this._updateBrushRect(r.offsetX, r.offsetY));
    }, t.prototype._updateBrushRect = function(r, n) {
      var i = this._displayables, o = this.dataZoomModel, a = i.brushRect;
      a || (a = i.brushRect = new bp({
        silent: !0,
        style: o.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(a)), a.attr("ignore", !1);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(r, n), c = l.transformCoordToLocal(s.x, s.y), d = this._size;
      u[0] = Math.max(Math.min(d[0], u[0]), 0), a.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: d[1]
      });
    }, t.prototype._dispatchZoomAction = function(r) {
      var n = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: r ? jNe : null,
        start: n[0],
        end: n[1]
      });
    }, t.prototype._findCoordRect = function() {
      var r, n = jK(this.dataZoomModel).infoList;
      if (!r && n.length) {
        var i = n[0].model.coordinateSystem;
        r = i.getRect && i.getRect();
      }
      if (!r) {
        var o = this.api.getWidth(), a = this.api.getHeight();
        r = {
          x: o * 0.2,
          y: a * 0.2,
          width: o * 0.6,
          height: a * 0.6
        };
      }
      return r;
    }, t.type = "dataZoom.slider", t;
  }($A)
);
function KNe(e) {
  var t = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return t[e];
}
function J$(e) {
  return e === "vertical" ? "ns-resize" : "ew-resize";
}
function dY(e) {
  e.registerComponentModel($Ne), e.registerComponentView(UNe), HA(e);
}
function YNe(e) {
  Bt(cY), Bt(dY);
}
var hY = {
  /**
   * @public
   */
  get: function(e, t, r) {
    var n = dt((qNe[e] || {})[t]);
    return r && be(n) ? n[n.length - 1] : n;
  }
}, qNe = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
}, eH = Vn.mapVisual, XNe = Vn.eachVisual, ZNe = be, tH = $, QNe = vo, JNe = Cr, KC = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.stateList = ["inRange", "outOfRange"], r.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], r.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, r.dataBound = [-1 / 0, 1 / 0], r.targetVisuals = {}, r.controllerVisuals = {}, r;
    }
    return t.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i);
    }, t.prototype.optionUpdated = function(r, n) {
      var i = this.option;
      !n && tY(i, r, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, t.prototype.resetVisual = function(r) {
      var n = this.stateList;
      r = je(r, this), this.controllerVisuals = $T(this.option.controller, n, r), this.targetVisuals = $T(this.option.target, n, r);
    }, t.prototype.getItemSymbol = function() {
      return null;
    }, t.prototype.getTargetSeriesIndices = function() {
      var r = this.option.seriesIndex, n = [];
      return r == null || r === "all" ? this.ecModel.eachSeries(function(i, o) {
        n.push(o);
      }) : n = Tr(r), n;
    }, t.prototype.eachTargetSeries = function(r, n) {
      $(this.getTargetSeriesIndices(), function(i) {
        var o = this.ecModel.getSeriesByIndex(i);
        o && r.call(n, o);
      }, this);
    }, t.prototype.isTargetSeries = function(r) {
      var n = !1;
      return this.eachTargetSeries(function(i) {
        i === r && (n = !0);
      }), n;
    }, t.prototype.formatValueText = function(r, n, i) {
      var o = this.option, a = o.precision, s = this.dataBound, l = o.formatter, u;
      i = i || ["<", ">"], be(r) && (r = r.slice(), u = !0);
      var c = n ? r : u ? [d(r[0]), d(r[1])] : d(r);
      if (He(l))
        return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (at(l))
        return u ? l(r[0], r[1]) : l(r);
      if (u)
        return r[0] === s[0] ? i[0] + " " + c[1] : r[1] === s[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function d(h) {
        return h === s[0] ? "min" : h === s[1] ? "max" : (+h).toFixed(Math.min(a, 20));
      }
    }, t.prototype.resetExtent = function() {
      var r = this.option, n = QNe([r.min, r.max]);
      this._dataExtent = n;
    }, t.prototype.getDataDimensionIndex = function(r) {
      var n = this.option.dimension;
      if (n != null)
        return r.getDimensionIndex(n);
      for (var i = r.dimensions, o = i.length - 1; o >= 0; o--) {
        var a = i[o], s = r.getDimensionInfo(a);
        if (!s.isCalculationCoord)
          return s.storeDimIndex;
      }
    }, t.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, t.prototype.completeVisualOption = function() {
      var r = this.ecModel, n = this.option, i = {
        inRange: n.inRange,
        outOfRange: n.outOfRange
      }, o = n.target || (n.target = {}), a = n.controller || (n.controller = {});
      Mt(o, i), Mt(a, i);
      var s = this.isCategory();
      l.call(this, o), l.call(this, a), u.call(this, o, "inRange", "outOfRange"), c.call(this, a);
      function l(d) {
        ZNe(n.color) && !d.inRange && (d.inRange = {
          color: n.color.slice().reverse()
        }), d.inRange = d.inRange || {
          color: r.get("gradientColor")
        };
      }
      function u(d, h, f) {
        var p = d[h], g = d[f];
        p && !g && (g = d[f] = {}, tH(p, function(v, m) {
          if (Vn.isValidType(m)) {
            var y = hY.get(m, "inactive", s);
            y != null && (g[m] = y, m === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [0, 0]));
          }
        }));
      }
      function c(d) {
        var h = (d.inRange || {}).symbol || (d.outOfRange || {}).symbol, f = (d.inRange || {}).symbolSize || (d.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), g = this.getItemSymbol(), v = g || "roundRect";
        tH(this.stateList, function(m) {
          var y = this.itemSize, C = d[m];
          C || (C = d[m] = {
            color: s ? p : [p]
          }), C.symbol == null && (C.symbol = h && dt(h) || (s ? v : [v])), C.symbolSize == null && (C.symbolSize = f && dt(f) || (s ? y[0] : [y[0], y[0]])), C.symbol = eH(C.symbol, function(w) {
            return w === "none" ? v : w;
          });
          var S = C.symbolSize;
          if (S != null) {
            var b = -1 / 0;
            XNe(S, function(w) {
              w > b && (b = w);
            }), C.symbolSize = eH(S, function(w) {
              return JNe(w, [0, b], [0, y[0]], !0);
            });
          }
        }, this);
      }
    }, t.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, t.prototype.isCategory = function() {
      return !!this.option.categories;
    }, t.prototype.setSelected = function(r) {
    }, t.prototype.getSelected = function() {
      return null;
    }, t.prototype.getValueState = function(r) {
      return null;
    }, t.prototype.getVisualMeta = function(r) {
      return null;
    }, t.type = "visualMap", t.dependencies = ["series"], t.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      // css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
        // 
      }
    }, t;
  }(Vt)
), rH = [20, 140], eke = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.optionUpdated = function(r, n) {
      e.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, t.prototype.resetItemSize = function() {
      e.prototype.resetItemSize.apply(this, arguments);
      var r = this.itemSize;
      (r[0] == null || isNaN(r[0])) && (r[0] = rH[0]), (r[1] == null || isNaN(r[1])) && (r[1] = rH[1]);
    }, t.prototype._resetRange = function() {
      var r = this.getExtent(), n = this.option.range;
      !n || n.auto ? (r.auto = 1, this.option.range = r) : be(n) && (n[0] > n[1] && n.reverse(), n[0] = Math.max(n[0], r[0]), n[1] = Math.min(n[1], r[1]));
    }, t.prototype.completeVisualOption = function() {
      e.prototype.completeVisualOption.apply(this, arguments), $(this.stateList, function(r) {
        var n = this.option.controller[r].symbolSize;
        n && n[0] !== n[1] && (n[0] = n[1] / 3);
      }, this);
    }, t.prototype.setSelected = function(r) {
      this.option.range = r.slice(), this._resetRange();
    }, t.prototype.getSelected = function() {
      var r = this.getExtent(), n = vo((this.get("range") || []).slice());
      return n[0] > r[1] && (n[0] = r[1]), n[1] > r[1] && (n[1] = r[1]), n[0] < r[0] && (n[0] = r[0]), n[1] < r[0] && (n[1] = r[0]), n;
    }, t.prototype.getValueState = function(r) {
      var n = this.option.range, i = this.getExtent();
      return (n[0] <= i[0] || n[0] <= r) && (n[1] >= i[1] || r <= n[1]) ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(r) {
      var n = [];
      return this.eachTargetSeries(function(i) {
        var o = [], a = i.getData();
        a.each(this.getDataDimensionIndex(a), function(s, l) {
          r[0] <= s && s <= r[1] && o.push(l);
        }, this), n.push({
          seriesId: i.id,
          dataIndex: o
        });
      }, this), n;
    }, t.prototype.getVisualMeta = function(r) {
      var n = nH(this, "outOfRange", this.getExtent()), i = nH(this, "inRange", this.option.range.slice()), o = [];
      function a(f, p) {
        o.push({
          value: f,
          color: r(f, p)
        });
      }
      for (var s = 0, l = 0, u = i.length, c = n.length; l < c && (!i.length || n[l] <= i[0]); l++)
        n[l] < i[s] && a(n[l], "outOfRange");
      for (var d = 1; s < u; s++, d = 0)
        d && o.length && a(i[s], "outOfRange"), a(i[s], "inRange");
      for (var d = 1; l < c; l++)
        (!i.length || i[i.length - 1] < n[l]) && (d && (o.length && a(o[o.length - 1].value, "outOfRange"), d = 0), a(n[l], "outOfRange"));
      var h = o.length;
      return {
        stops: o,
        outerColors: [h ? o[0].color : "transparent", h ? o[h - 1].color : "transparent"]
      };
    }, t.type = "visualMap.continuous", t.defaultOption = wu(KC.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: 'rgba(0,0,0,0.2)'
      //     }
      // }
    }), t;
  }(KC)
);
function nH(e, t, r) {
  if (r[0] === r[1])
    return r.slice();
  for (var n = 200, i = (r[1] - r[0]) / n, o = r[0], a = [], s = 0; s <= n && o < r[1]; s++)
    a.push(o), o += i;
  return a.push(r[1]), a;
}
var fY = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, r;
    }
    return t.prototype.init = function(r, n) {
      this.ecModel = r, this.api = n;
    }, t.prototype.render = function(r, n, i, o) {
      if (this.visualMapModel = r, r.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(r, n, i, o);
    }, t.prototype.renderBackground = function(r) {
      var n = this.visualMapModel, i = sd(n.get("padding") || 0), o = r.getBoundingRect();
      r.add(new or({
        z2: -1,
        silent: !0,
        shape: {
          x: o.x - i[3],
          y: o.y - i[0],
          width: o.width + i[3] + i[1],
          height: o.height + i[0] + i[2]
        },
        style: {
          fill: n.get("backgroundColor"),
          stroke: n.get("borderColor"),
          lineWidth: n.get("borderWidth")
        }
      }));
    }, t.prototype.getControllerVisual = function(r, n, i) {
      i = i || {};
      var o = i.forceState, a = this.visualMapModel, s = {};
      if (n === "color") {
        var l = a.get("contentColor");
        s.color = l;
      }
      function u(f) {
        return s[f];
      }
      function c(f, p) {
        s[f] = p;
      }
      var d = a.controllerVisuals[o || a.getValueState(r)], h = Vn.prepareVisualTypes(d);
      return $(h, function(f) {
        var p = d[f];
        i.convertOpacityToAlpha && f === "opacity" && (f = "colorAlpha", p = d.__alphaForOpacity), Vn.dependsOn(f, n) && p && p.applyVisual(r, u, c);
      }), s[n];
    }, t.prototype.positionGroup = function(r) {
      var n = this.visualMapModel, i = this.api;
      gw(r, n.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight()
      });
    }, t.prototype.doRender = function(r, n, i, o) {
    }, t.type = "visualMap", t;
  }(zr)
), iH = [["left", "right", "width"], ["top", "bottom", "height"]];
function pY(e, t, r) {
  var n = e.option, i = n.align;
  if (i != null && i !== "auto")
    return i;
  for (var o = {
    width: t.getWidth(),
    height: t.getHeight()
  }, a = n.orient === "horizontal" ? 1 : 0, s = iH[a], l = [0, null, 10], u = {}, c = 0; c < 3; c++)
    u[iH[1 - a][c]] = l[c], u[s[c]] = c === 2 ? r[0] : n[s[c]];
  var d = [["x", "width", 3], ["y", "height", 0]][a], h = En(u, o, n.padding);
  return s[(h.margin[d[2]] || 0) + h[d[0]] + h[d[1]] * 0.5 < o[d[1]] * 0.5 ? 0 : 1];
}
function S0(e, t) {
  return $(e || [], function(r) {
    r.dataIndex != null && (r.dataIndexInside = r.dataIndex, r.dataIndex = null), r.highlightKey = "visualMap" + (t ? t.componentIndex : "");
  }), e;
}
var Xa = Cr, tke = $, oH = Math.min, cE = Math.max, rke = 12, nke = 6, ike = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._shapes = {}, r._dataInterval = [], r._handleEnds = [], r._hoverLinkDataIndices = [], r;
    }
    return t.prototype.init = function(r, n) {
      e.prototype.init.call(this, r, n), this._hoverLinkFromSeriesMouseOver = je(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = je(this._hideIndicator, this);
    }, t.prototype.doRender = function(r, n, i, o) {
      (!o || o.type !== "selectDataRange" || o.from !== this.uid) && this._buildView();
    }, t.prototype._buildView = function() {
      this.group.removeAll();
      var r = this.visualMapModel, n = this.group;
      this._orient = r.get("orient"), this._useHandle = r.get("calculable"), this._resetInterval(), this._renderBar(n);
      var i = r.get("text");
      this._renderEndsText(n, i, 0), this._renderEndsText(n, i, 1), this._updateView(!0), this.renderBackground(n), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(n);
    }, t.prototype._renderEndsText = function(r, n, i) {
      if (n) {
        var o = n[1 - i];
        o = o != null ? o + "" : "";
        var a = this.visualMapModel, s = a.get("textGap"), l = a.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u), d = this._applyTransform(i === 0 ? "bottom" : "top", u), h = this._orient, f = this.visualMapModel.textStyleModel;
        this.group.add(new ir({
          style: Vr(f, {
            x: c[0],
            y: c[1],
            verticalAlign: h === "horizontal" ? "middle" : d,
            align: h === "horizontal" ? d : "center",
            text: o
          })
        }));
      }
    }, t.prototype._renderBar = function(r) {
      var n = this.visualMapModel, i = this._shapes, o = n.itemSize, a = this._orient, s = this._useHandle, l = pY(n, this.api, o), u = i.mainGroup = this._createBarGroup(l), c = new Ct();
      u.add(c), c.add(i.outOfRange = aH()), c.add(i.inRange = aH(null, s ? lH(this._orient) : null, je(this._dragHandle, this, "all", !1), je(this._dragHandle, this, "all", !0))), c.setClipPath(new or({
        shape: {
          x: 0,
          y: 0,
          width: o[0],
          height: o[1],
          r: 3
        }
      }));
      var d = n.textStyleModel.getTextRect(""), h = cE(d.width, d.height);
      s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(n, u, 0, o, h, a), this._createHandle(n, u, 1, o, h, a)), this._createIndicator(n, u, o, h, a), r.add(u);
    }, t.prototype._createHandle = function(r, n, i, o, a, s) {
      var l = je(this._dragHandle, this, i, !1), u = je(this._dragHandle, this, i, !0), c = La(r.get("handleSize"), o[0]), d = mn(r.get("handleIcon"), -c / 2, -c / 2, c, c, null, !0), h = lH(this._orient);
      d.attr({
        cursor: h,
        draggable: !0,
        drift: l,
        ondragend: u,
        onmousemove: function(m) {
          Zs(m.event);
        }
      }), d.x = o[0] / 2, d.useStyle(r.getModel("handleStyle").getItemStyle()), d.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), d.style.lineWidth *= 2, d.ensureState("emphasis").style = r.getModel(["emphasis", "handleStyle"]).getItemStyle(), mc(d, !0), n.add(d);
      var f = this.visualMapModel.textStyleModel, p = new ir({
        cursor: h,
        draggable: !0,
        drift: l,
        onmousemove: function(m) {
          Zs(m.event);
        },
        ondragend: u,
        style: Vr(f, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var g = [c, 0], v = this._shapes;
      v.handleThumbs[i] = d, v.handleLabelPoints[i] = g, v.handleLabels[i] = p;
    }, t.prototype._createIndicator = function(r, n, i, o, a) {
      var s = La(r.get("indicatorSize"), i[0]), l = mn(r.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
      l.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: i[0] / 2
      });
      var u = r.getModel("indicatorStyle").getItemStyle();
      if (l instanceof qn) {
        var c = l.style;
        l.useStyle(ge({
          // TODO other properties like x, y ?
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else
        l.useStyle(u);
      n.add(l);
      var d = this.visualMapModel.textStyleModel, h = new ir({
        silent: !0,
        invisible: !0,
        style: Vr(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(h);
      var f = [(a === "horizontal" ? o / 2 : nke) + i[0] / 2, 0], p = this._shapes;
      p.indicator = l, p.indicatorLabel = h, p.indicatorLabelPoint = f, this._firstShowIndicator = !0;
    }, t.prototype._dragHandle = function(r, n, i, o) {
      if (this._useHandle) {
        if (this._dragging = !n, !n) {
          var a = this._applyTransform([i, o], this._shapes.mainGroup, !0);
          this._updateInterval(r, a[1]), this._hideIndicator(), this._updateView();
        }
        n === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), n ? !this._hovering && this._clearHoverLinkToSeries() : sH(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[r], !1);
      }
    }, t.prototype._resetInterval = function() {
      var r = this.visualMapModel, n = this._dataInterval = r.getSelected(), i = r.getExtent(), o = [0, r.itemSize[1]];
      this._handleEnds = [Xa(n[0], i, o, !0), Xa(n[1], i, o, !0)];
    }, t.prototype._updateInterval = function(r, n) {
      n = n || 0;
      var i = this.visualMapModel, o = this._handleEnds, a = [0, i.itemSize[1]];
      hd(
        n,
        o,
        a,
        r,
        // cross is forbidden
        0
      );
      var s = i.getExtent();
      this._dataInterval = [Xa(o[0], a, s, !0), Xa(o[1], a, s, !0)];
    }, t.prototype._updateView = function(r) {
      var n = this.visualMapModel, i = n.getExtent(), o = this._shapes, a = [0, n.itemSize[1]], s = r ? a : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), u = this._createBarVisual(i, i, a, "outOfRange");
      o.inRange.setStyle({
        fill: l.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", l.barPoints), o.outOfRange.setStyle({
        fill: u.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, t.prototype._createBarVisual = function(r, n, i, o) {
      var a = {
        forceState: o,
        convertOpacityToAlpha: !0
      }, s = this._makeColorGradient(r, a), l = [this.getControllerVisual(r[0], "symbolSize", a), this.getControllerVisual(r[1], "symbolSize", a)], u = this._createBarPoints(i, l);
      return {
        barColor: new vf(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [s[0].color, s[s.length - 1].color]
      };
    }, t.prototype._makeColorGradient = function(r, n) {
      var i = 100, o = [], a = (r[1] - r[0]) / i;
      o.push({
        color: this.getControllerVisual(r[0], "color", n),
        offset: 0
      });
      for (var s = 1; s < i; s++) {
        var l = r[0] + a * s;
        if (l > r[1])
          break;
        o.push({
          color: this.getControllerVisual(l, "color", n),
          offset: s / i
        });
      }
      return o.push({
        color: this.getControllerVisual(r[1], "color", n),
        offset: 1
      }), o;
    }, t.prototype._createBarPoints = function(r, n) {
      var i = this.visualMapModel.itemSize;
      return [[i[0] - n[0], r[0]], [i[0], r[0]], [i[0], r[1]], [i[0] - n[1], r[1]]];
    }, t.prototype._createBarGroup = function(r) {
      var n = this._orient, i = this.visualMapModel.get("inverse");
      return new Ct(n === "horizontal" && !i ? {
        scaleX: r === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : n === "horizontal" && i ? {
        scaleX: r === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : n === "vertical" && !i ? {
        scaleX: r === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: r === "left" ? 1 : -1
      });
    }, t.prototype._updateHandle = function(r, n) {
      if (this._useHandle) {
        var i = this._shapes, o = this.visualMapModel, a = i.handleThumbs, s = i.handleLabels, l = o.itemSize, u = o.getExtent();
        tke([0, 1], function(c) {
          var d = a[c];
          d.setStyle("fill", n.handlesColor[c]), d.y = r[c];
          var h = Xa(r[c], [0, l[1]], u, !0), f = this.getControllerVisual(h, "symbolSize");
          d.scaleX = d.scaleY = f / l[0], d.x = l[0] - f / 2;
          var p = Ma(i.handleLabelPoints[c], Wl(d, this.group));
          s[c].setStyle({
            x: p[0],
            y: p[1],
            text: o.formatValueText(this._dataInterval[c]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, t.prototype._showIndicator = function(r, n, i, o) {
      var a = this.visualMapModel, s = a.getExtent(), l = a.itemSize, u = [0, l[1]], c = this._shapes, d = c.indicator;
      if (d) {
        d.attr("invisible", !1);
        var h = {
          convertOpacityToAlpha: !0
        }, f = this.getControllerVisual(r, "color", h), p = this.getControllerVisual(r, "symbolSize"), g = Xa(r, s, u, !0), v = l[0] - p / 2, m = {
          x: d.x,
          y: d.y
        };
        d.y = g, d.x = v;
        var y = Ma(c.indicatorLabelPoint, Wl(d, this.group)), C = c.indicatorLabel;
        C.attr("invisible", !1);
        var S = this._applyTransform("left", c.mainGroup), b = this._orient, w = b === "horizontal";
        C.setStyle({
          text: (i || "") + a.formatValueText(n),
          verticalAlign: w ? S : "middle",
          align: w ? "center" : S
        });
        var x = {
          x: v,
          y: g,
          style: {
            fill: f
          }
        }, R = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (a.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var _ = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          d.x = m.x, d.y = m.y, d.animateTo(x, _), C.animateTo(R, _);
        } else
          d.attr(x), C.attr(R);
        this._firstShowIndicator = !1;
        var T = this._shapes.handleLabels;
        if (T)
          for (var P = 0; P < T.length; P++)
            this.api.enterBlur(T[P]);
      }
    }, t.prototype._enableHoverLinkToSeries = function() {
      var r = this;
      this._shapes.mainGroup.on("mousemove", function(n) {
        if (r._hovering = !0, !r._dragging) {
          var i = r.visualMapModel.itemSize, o = r._applyTransform([n.offsetX, n.offsetY], r._shapes.mainGroup, !0, !0);
          o[1] = oH(cE(0, o[1]), i[1]), r._doHoverLinkToSeries(o[1], 0 <= o[0] && o[0] <= i[0]);
        }
      }).on("mouseout", function() {
        r._hovering = !1, !r._dragging && r._clearHoverLinkToSeries();
      });
    }, t.prototype._enableHoverLinkFromSeries = function() {
      var r = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (r.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), r.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, t.prototype._doHoverLinkToSeries = function(r, n) {
      var i = this.visualMapModel, o = i.itemSize;
      if (i.option.hoverLink) {
        var a = [0, o[1]], s = i.getExtent();
        r = oH(cE(a[0], r), a[1]);
        var l = oke(i, s, a), u = [r - l, r + l], c = Xa(r, a, s, !0), d = [Xa(u[0], a, s, !0), Xa(u[1], a, s, !0)];
        u[0] < a[0] && (d[0] = -1 / 0), u[1] > a[1] && (d[1] = 1 / 0), n && (d[0] === -1 / 0 ? this._showIndicator(c, d[1], "< ", l) : d[1] === 1 / 0 ? this._showIndicator(c, d[0], "> ", l) : this._showIndicator(c, c, " ", l));
        var h = this._hoverLinkDataIndices, f = [];
        (n || sH(i)) && (f = this._hoverLinkDataIndices = i.findTargetDataIndices(d));
        var p = GCe(h, f);
        this._dispatchHighDown("downplay", S0(p[0], i)), this._dispatchHighDown("highlight", S0(p[1], i));
      }
    }, t.prototype._hoverLinkFromSeriesMouseOver = function(r) {
      var n;
      if (Cc(r.target, function(l) {
        var u = St(l);
        if (u.dataIndex != null)
          return n = u, !0;
      }, !0), !!n) {
        var i = this.ecModel.getSeriesByIndex(n.seriesIndex), o = this.visualMapModel;
        if (o.isTargetSeries(i)) {
          var a = i.getData(n.dataType), s = a.getStore().get(o.getDataDimensionIndex(a), n.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, t.prototype._hideIndicator = function() {
      var r = this._shapes;
      r.indicator && r.indicator.attr("invisible", !0), r.indicatorLabel && r.indicatorLabel.attr("invisible", !0);
      var n = this._shapes.handleLabels;
      if (n)
        for (var i = 0; i < n.length; i++)
          this.api.leaveBlur(n[i]);
    }, t.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var r = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", S0(r, this.visualMapModel)), r.length = 0;
    }, t.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var r = this.api.getZr();
      r.off("mouseover", this._hoverLinkFromSeriesMouseOver), r.off("mouseout", this._hideIndicator);
    }, t.prototype._applyTransform = function(r, n, i, o) {
      var a = Wl(n, o ? null : this.group);
      return be(r) ? Ma(r, a, i) : uw(r, a, i);
    }, t.prototype._dispatchHighDown = function(r, n) {
      n && n.length && this.api.dispatchAction({
        type: r,
        batch: n
      });
    }, t.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, t.type = "visualMap.continuous", t;
  }(fY)
);
function aH(e, t, r, n) {
  return new Li({
    shape: {
      points: e
    },
    draggable: !!r,
    cursor: t,
    drift: r,
    onmousemove: function(i) {
      Zs(i.event);
    },
    ondragend: n
  });
}
function oke(e, t, r) {
  var n = rke / 2, i = e.get("hoverLinkDataSize");
  return i && (n = Xa(i, t, r, !0) / 2), n;
}
function sH(e) {
  var t = e.get("hoverLinkOnHandle");
  return !!(t ?? e.get("realtime"));
}
function lH(e) {
  return e === "vertical" ? "ns-resize" : "ew-resize";
}
var ake = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, ske = function(e, t) {
  t.eachComponent({
    mainType: "visualMap",
    query: e
  }, function(r) {
    r.setSelected(e.selected);
  });
}, lke = [
  {
    createOnAllSeries: !0,
    reset: function(e, t) {
      var r = [];
      return t.eachComponent("visualMap", function(n) {
        var i = e.pipelineContext;
        !n.isTargetSeries(e) || i && i.large || r.push(DFe(n.stateList, n.targetVisuals, je(n.getValueState, n), n.getDataDimensionIndex(e.getData())));
      }), r;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(e, t) {
      var r = e.getData(), n = [];
      t.eachComponent("visualMap", function(i) {
        if (i.isTargetSeries(e)) {
          var o = i.getVisualMeta(je(uke, null, e, i)) || {
            stops: [],
            outerColors: []
          }, a = i.getDataDimensionIndex(r);
          a >= 0 && (o.dimension = a, n.push(o));
        }
      }), e.getData().setVisual("visualMeta", n);
    }
  }
];
function uke(e, t, r, n) {
  for (var i = t.targetVisuals[n], o = Vn.prepareVisualTypes(i), a = {
    color: zv(e.getData(), "color")
    // default color.
  }, s = 0, l = o.length; s < l; s++) {
    var u = o[s], c = i[u === "opacity" ? "__alphaForOpacity" : u];
    c && c.applyVisual(r, d, h);
  }
  return a.color;
  function d(f) {
    return a[f];
  }
  function h(f, p) {
    a[f] = p;
  }
}
var uH = $;
function cke(e) {
  var t = e && e.visualMap;
  be(t) || (t = t ? [t] : []), uH(t, function(r) {
    if (r) {
      Xd(r, "splitList") && !Xd(r, "pieces") && (r.pieces = r.splitList, delete r.splitList);
      var n = r.pieces;
      n && be(n) && uH(n, function(i) {
        lt(i) && (Xd(i, "start") && !Xd(i, "min") && (i.min = i.start), Xd(i, "end") && !Xd(i, "max") && (i.max = i.end));
      });
    }
  });
}
function Xd(e, t) {
  return e && e.hasOwnProperty && e.hasOwnProperty(t);
}
var cH = !1;
function gY(e) {
  cH || (cH = !0, e.registerSubTypeDefaulter("visualMap", function(t) {
    return !t.categories && (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable) ? "continuous" : "piecewise";
  }), e.registerAction(ake, ske), $(lke, function(t) {
    e.registerVisual(e.PRIORITY.VISUAL.COMPONENT, t);
  }), e.registerPreprocessor(cke));
}
function vY(e) {
  e.registerComponentModel(eke), e.registerComponentView(ike), gY(e);
}
var dke = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._pieceList = [], r;
    }
    return t.prototype.optionUpdated = function(r, n) {
      e.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], hke[this._mode].call(this, this._pieceList), this._resetSelected(r, n);
      var o = this.option.categories;
      this.resetVisual(function(a, s) {
        i === "categories" ? (a.mappingMethod = "category", a.categories = dt(o)) : (a.dataExtent = this.getExtent(), a.mappingMethod = "piecewise", a.pieceList = Ee(this._pieceList, function(l) {
          return l = dt(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, t.prototype.completeVisualOption = function() {
      var r = this.option, n = {}, i = Vn.listVisualTypes(), o = this.isCategory();
      $(r.pieces, function(s) {
        $(i, function(l) {
          s.hasOwnProperty(l) && (n[l] = 1);
        });
      }), $(n, function(s, l) {
        var u = !1;
        $(this.stateList, function(c) {
          u = u || a(r, c, l) || a(r.target, c, l);
        }, this), !u && $(this.stateList, function(c) {
          (r[c] || (r[c] = {}))[l] = hY.get(l, c === "inRange" ? "active" : "inactive", o);
        });
      }, this);
      function a(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      e.prototype.completeVisualOption.apply(this, arguments);
    }, t.prototype._resetSelected = function(r, n) {
      var i = this.option, o = this._pieceList, a = (n ? i : r).selected || {};
      if (i.selected = a, $(o, function(l, u) {
        var c = this.getSelectedMapKey(l);
        a.hasOwnProperty(c) || (a[c] = !0);
      }, this), i.selectedMode === "single") {
        var s = !1;
        $(o, function(l, u) {
          var c = this.getSelectedMapKey(l);
          a[c] && (s ? a[c] = !1 : s = !0);
        }, this);
      }
    }, t.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, t.prototype.getSelectedMapKey = function(r) {
      return this._mode === "categories" ? r.value + "" : r.index + "";
    }, t.prototype.getPieceList = function() {
      return this._pieceList;
    }, t.prototype._determineMode = function() {
      var r = this.option;
      return r.pieces && r.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, t.prototype.setSelected = function(r) {
      this.option.selected = dt(r);
    }, t.prototype.getValueState = function(r) {
      var n = Vn.findPieceIndex(r, this._pieceList);
      return n != null && this.option.selected[this.getSelectedMapKey(this._pieceList[n])] ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(r) {
      var n = [], i = this._pieceList;
      return this.eachTargetSeries(function(o) {
        var a = [], s = o.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var c = Vn.findPieceIndex(l, i);
          c === r && a.push(u);
        }, this), n.push({
          seriesId: o.id,
          dataIndex: a
        });
      }, this), n;
    }, t.prototype.getRepresentValue = function(r) {
      var n;
      if (this.isCategory())
        n = r.value;
      else if (r.value != null)
        n = r.value;
      else {
        var i = r.interval || [];
        n = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return n;
    }, t.prototype.getVisualMeta = function(r) {
      if (this.isCategory())
        return;
      var n = [], i = ["", ""], o = this;
      function a(c, d) {
        var h = o.getRepresentValue({
          interval: c
        });
        d || (d = o.getValueState(h));
        var f = r(h, d);
        c[0] === -1 / 0 ? i[0] = f : c[1] === 1 / 0 ? i[1] = f : n.push({
          value: c[0],
          color: f
        }, {
          value: c[1],
          color: f
        });
      }
      var s = this._pieceList.slice();
      if (!s.length)
        s.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [-1 / 0, l]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [l, 1 / 0]
        });
      }
      var u = -1 / 0;
      return $(s, function(c) {
        var d = c.interval;
        d && (d[0] > u && a([u, d[0]], "outOfRange"), a(d.slice()), u = d[1]);
      }, this), {
        stops: n,
        outerColors: i
      };
    }, t.type = "visualMap.piecewise", t.defaultOption = wu(KC.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), t;
  }(KC)
), hke = {
  splitNumber: function(e) {
    var t = this.option, r = Math.min(t.precision, 20), n = this.getExtent(), i = t.splitNumber;
    i = Math.max(parseInt(i, 10), 1), t.splitNumber = i;
    for (var o = (n[1] - n[0]) / i; +o.toFixed(r) !== o && r < 5; )
      r++;
    t.precision = r, o = +o.toFixed(r), t.minOpen && e.push({
      interval: [-1 / 0, n[0]],
      close: [0, 0]
    });
    for (var a = 0, s = n[0]; a < i; s += o, a++) {
      var l = a === i - 1 ? n[1] : s + o;
      e.push({
        interval: [s, l],
        close: [1, 1]
      });
    }
    t.maxOpen && e.push({
      interval: [n[1], 1 / 0],
      close: [0, 0]
    }), D_(e), $(e, function(u, c) {
      u.index = c, u.text = this.formatValueText(u.interval);
    }, this);
  },
  categories: function(e) {
    var t = this.option;
    $(t.categories, function(r) {
      e.push({
        text: this.formatValueText(r, !0),
        value: r
      });
    }, this), dH(t, e);
  },
  pieces: function(e) {
    var t = this.option;
    $(t.pieces, function(r, n) {
      lt(r) || (r = {
        value: r
      });
      var i = {
        text: "",
        index: n
      };
      if (r.label != null && (i.text = r.label), r.hasOwnProperty("value")) {
        var o = i.value = r.value;
        i.interval = [o, o], i.close = [1, 1];
      } else {
        for (var a = i.interval = [], s = i.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], c = [], d = 0; d < 2; d++) {
          for (var h = [["gte", "gt", "min"], ["lte", "lt", "max"]][d], f = 0; f < 3 && a[d] == null; f++)
            a[d] = r[h[f]], s[d] = l[f], c[d] = f === 2;
          a[d] == null && (a[d] = u[d]);
        }
        c[0] && a[1] === 1 / 0 && (s[0] = 0), c[1] && a[0] === -1 / 0 && (s[1] = 0), process.env.NODE_ENV !== "production" && a[0] > a[1] && console.warn("Piece " + n + "is illegal: " + a + " lower bound should not greater then uppper bound."), a[0] === a[1] && s[0] && s[1] && (i.value = a[0]);
      }
      i.visual = Vn.retrieveVisuals(r), e.push(i);
    }, this), dH(t, e), D_(e), $(e, function(r) {
      var n = r.close, i = [["<", ""][n[1]], [">", ""][n[0]]];
      r.text = r.text || this.formatValueText(r.value != null ? r.value : r.interval, !1, i);
    }, this);
  }
};
function dH(e, t) {
  var r = e.inverse;
  (e.orient === "vertical" ? !r : r) && t.reverse();
}
var fke = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.doRender = function() {
      var r = this.group;
      r.removeAll();
      var n = this.visualMapModel, i = n.get("textGap"), o = n.textStyleModel, a = o.getFont(), s = o.getTextColor(), l = this._getItemAlign(), u = n.itemSize, c = this._getViewData(), d = c.endsText, h = vn(n.get("showLabel", !0), !d);
      d && this._renderEndsText(r, d[0], u, h, l), $(c.viewPieceList, function(f) {
        var p = f.piece, g = new Ct();
        g.onclick = je(this._onItemClick, this, p), this._enableHoverLink(g, f.indexInModelPieceList);
        var v = n.getRepresentValue(p);
        if (this._createItemSymbol(g, v, [0, 0, u[0], u[1]]), h) {
          var m = this.visualMapModel.getValueState(v);
          g.add(new ir({
            style: {
              x: l === "right" ? -i : u[0] + i,
              y: u[1] / 2,
              text: p.text,
              verticalAlign: "middle",
              align: l,
              font: a,
              fill: s,
              opacity: m === "outOfRange" ? 0.5 : 1
            }
          }));
        }
        r.add(g);
      }, this), d && this._renderEndsText(r, d[1], u, h, l), Mc(n.get("orient"), r, n.get("itemGap")), this.renderBackground(r), this.positionGroup(r);
    }, t.prototype._enableHoverLink = function(r, n) {
      var i = this;
      r.on("mouseover", function() {
        return o("highlight");
      }).on("mouseout", function() {
        return o("downplay");
      });
      var o = function(a) {
        var s = i.visualMapModel;
        s.option.hoverLink && i.api.dispatchAction({
          type: a,
          batch: S0(s.findTargetDataIndices(n), s)
        });
      };
    }, t.prototype._getItemAlign = function() {
      var r = this.visualMapModel, n = r.option;
      if (n.orient === "vertical")
        return pY(r, this.api, r.itemSize);
      var i = n.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, t.prototype._renderEndsText = function(r, n, i, o, a) {
      if (n) {
        var s = new Ct(), l = this.visualMapModel.textStyleModel;
        s.add(new ir({
          style: Vr(l, {
            x: o ? a === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: o ? a : "center",
            text: n
          })
        })), r.add(s);
      }
    }, t.prototype._getViewData = function() {
      var r = this.visualMapModel, n = Ee(r.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), i = r.get("text"), o = r.get("orient"), a = r.get("inverse");
      return (o === "horizontal" ? a : !a) ? n.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: n,
        endsText: i
      };
    }, t.prototype._createItemSymbol = function(r, n, i) {
      r.add(mn(
        // symbol will be string
        this.getControllerVisual(n, "symbol"),
        i[0],
        i[1],
        i[2],
        i[3],
        // color will be string
        this.getControllerVisual(n, "color")
      ));
    }, t.prototype._onItemClick = function(r) {
      var n = this.visualMapModel, i = n.option, o = i.selectedMode;
      if (o) {
        var a = dt(i.selected), s = n.getSelectedMapKey(r);
        o === "single" || o === !0 ? (a[s] = !0, $(a, function(l, u) {
          a[u] = u === s;
        })) : a[s] = !a[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: a
        });
      }
    }, t.type = "visualMap.piecewise", t;
  }(fY)
);
function mY(e) {
  e.registerComponentModel(dke), e.registerComponentView(fke), gY(e);
}
function pke(e) {
  Bt(vY), Bt(mY);
}
var gke = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, hH = ar(), vke = {};
function mke(e, t) {
  var r = e.getModel("aria");
  if (!r.get("enabled"))
    return;
  var n = dt(gke);
  Mt(n.label, e.getLocaleModel().get("aria"), !1), Mt(r.option, n, !1), i(), o();
  function i() {
    var u = r.getModel("decal"), c = u.get("show");
    if (c) {
      var d = nt();
      e.eachSeries(function(h) {
        if (!h.isColorBySeries()) {
          var f = d.get(h.type);
          f || (f = {}, d.set(h.type, f)), hH(h).scope = f;
        }
      }), e.eachRawSeries(function(h) {
        if (e.isSeriesFiltered(h))
          return;
        if (at(h.enableAriaDecal)) {
          h.enableAriaDecal();
          return;
        }
        var f = h.getData();
        if (h.isColorBySeries()) {
          var y = K_(h.ecModel, h.name, vke, e.getSeriesCount()), C = f.getVisual("decal");
          f.setVisual("decal", S(C, y));
        } else {
          var p = h.getRawData(), g = {}, v = hH(h).scope;
          f.each(function(b) {
            var w = f.getRawIndex(b);
            g[w] = b;
          });
          var m = p.count();
          p.each(function(b) {
            var w = g[b], x = p.getName(b) || b + "", R = K_(h.ecModel, x, v, m), _ = f.getItemVisual(w, "decal");
            f.setItemVisual(w, "decal", S(_, R));
          });
        }
        function S(b, w) {
          var x = b ? ge(ge({}, w), b) : w;
          return x.dirty = !0, x;
        }
      });
    }
  }
  function o() {
    var u = t.getZr().dom;
    if (u) {
      var c = e.getLocaleModel().get("aria"), d = r.getModel("label");
      if (d.option = ut(d.option, c), !!d.get("enabled")) {
        if (d.get("description")) {
          u.setAttribute("aria-label", d.get("description"));
          return;
        }
        var h = e.getSeriesCount(), f = d.get(["data", "maxCount"]) || 10, p = d.get(["series", "maxCount"]) || 10, g = Math.min(h, p), v;
        if (!(h < 1)) {
          var m = s();
          if (m) {
            var y = d.get(["general", "withTitle"]);
            v = a(y, {
              title: m
            });
          } else
            v = d.get(["general", "withoutTitle"]);
          var C = [], S = h > 1 ? d.get(["series", "multiple", "prefix"]) : d.get(["series", "single", "prefix"]);
          v += a(S, {
            seriesCount: h
          }), e.eachSeries(function(R, _) {
            if (_ < g) {
              var T = void 0, P = R.get("name"), D = P ? "withName" : "withoutName";
              T = h > 1 ? d.get(["series", "multiple", D]) : d.get(["series", "single", D]), T = a(T, {
                seriesId: R.seriesIndex,
                seriesName: R.get("name"),
                seriesType: l(R.subType)
              });
              var O = R.getData();
              if (O.count() > f) {
                var A = d.get(["data", "partialData"]);
                T += a(A, {
                  displayCnt: f
                });
              } else
                T += d.get(["data", "allData"]);
              for (var F = d.get(["data", "separator", "middle"]), L = d.get(["data", "separator", "end"]), N = [], I = 0; I < O.count(); I++)
                if (I < f) {
                  var B = O.getName(I), M = O.getValues(I), V = d.get(["data", B ? "withName" : "withoutName"]);
                  N.push(a(V, {
                    name: B,
                    value: M.join(F)
                  }));
                }
              T += N.join(F) + L, C.push(T);
            }
          });
          var b = d.getModel(["series", "multiple", "separator"]), w = b.get("middle"), x = b.get("end");
          v += C.join(w) + x, u.setAttribute("aria-label", v);
        }
      }
    }
  }
  function a(u, c) {
    if (!He(u))
      return u;
    var d = u;
    return $(c, function(h, f) {
      d = d.replace(new RegExp("\\{\\s*" + f + "\\s*\\}", "g"), h);
    }), d;
  }
  function s() {
    var u = e.get("title");
    return u && u.length && (u = u[0]), u && u.text;
  }
  function l(u) {
    var c = e.getLocaleModel().get(["series", "typeNames"]);
    return c[u] || c.chart;
  }
}
function yke(e) {
  if (!(!e || !e.aria)) {
    var t = e.aria;
    t.show != null && (t.enabled = t.show), t.label = t.label || {}, $(["description", "general", "series", "data"], function(r) {
      t[r] != null && (t.label[r] = t[r]);
    });
  }
}
function Cke(e) {
  e.registerPreprocessor(yke), e.registerVisual(e.PRIORITY.VISUAL.ARIA, mke);
}
var fH = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, Ske = (
  /** @class */
  function() {
    function e(t) {
      var r = this._condVal = He(t) ? new RegExp(t) : kM(t) ? t : null;
      if (r == null) {
        var n = "";
        process.env.NODE_ENV !== "production" && (n = Ai("Illegal regexp", t, "in")), mr(n);
      }
    }
    return e.prototype.evaluate = function(t) {
      var r = typeof t;
      return He(r) ? this._condVal.test(t) : sr(r) ? this._condVal.test(t + "") : !1;
    }, e;
  }()
), wke = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      return this.value;
    }, e;
  }()
), bke = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      for (var t = this.children, r = 0; r < t.length; r++)
        if (!t[r].evaluate())
          return !1;
      return !0;
    }, e;
  }()
), xke = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      for (var t = this.children, r = 0; r < t.length; r++)
        if (t[r].evaluate())
          return !0;
      return !1;
    }, e;
  }()
), Eke = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, e;
  }()
), Rke = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      for (var t = !!this.valueParser, r = this.getValue, n = r(this.valueGetterParam), i = t ? this.valueParser(n) : null, o = 0; o < this.subCondList.length; o++)
        if (!this.subCondList[o].evaluate(t ? i : n))
          return !1;
      return !0;
    }, e;
  }()
);
function XA(e, t) {
  if (e === !0 || e === !1) {
    var r = new wke();
    return r.value = e, r;
  }
  var n = "";
  return yY(e) || (process.env.NODE_ENV !== "production" && (n = Ai("Illegal config. Expect a plain object but actually", e)), mr(n)), e.and ? pH("and", e, t) : e.or ? pH("or", e, t) : e.not ? _ke(e, t) : Tke(e, t);
}
function pH(e, t, r) {
  var n = t[e], i = "";
  process.env.NODE_ENV !== "production" && (i = Ai('"and"/"or" condition should only be `' + e + ": [...]` and must not be empty array.", "Illegal condition:", t)), be(n) || mr(i), n.length || mr(i);
  var o = e === "and" ? new bke() : new xke();
  return o.children = Ee(n, function(a) {
    return XA(a, r);
  }), o.children.length || mr(i), o;
}
function _ke(e, t) {
  var r = e.not, n = "";
  process.env.NODE_ENV !== "production" && (n = Ai('"not" condition should only be `not: {}`.', "Illegal condition:", e)), yY(r) || mr(n);
  var i = new Eke();
  return i.child = XA(r, t), i.child || mr(n), i;
}
function Tke(e, t) {
  for (var r = "", n = t.prepareGetValue(e), i = [], o = jt(e), a = e.parser, s = a ? X7(a) : null, l = 0; l < o.length; l++) {
    var u = o[l];
    if (!(u === "parser" || t.valueGetterAttrMap.get(u))) {
      var c = Ye(fH, u) ? fH[u] : u, d = e[u], h = s ? s(d) : d, f = Xbe(c, h) || c === "reg" && new Ske(h);
      f || (process.env.NODE_ENV !== "production" && (r = Ai('Illegal relational operation: "' + u + '" in condition:', e)), mr(r)), i.push(f);
    }
  }
  i.length || (process.env.NODE_ENV !== "production" && (r = Ai("Relational condition must have at least one operator.", "Illegal condition:", e)), mr(r));
  var p = new Rke();
  return p.valueGetterParam = n, p.valueParser = s, p.getValue = t.getValue, p.subCondList = i, p;
}
function yY(e) {
  return lt(e) && !Jn(e);
}
var Pke = (
  /** @class */
  function() {
    function e(t, r) {
      this._cond = XA(t, r);
    }
    return e.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, e;
  }()
);
function Mke(e, t) {
  return new Pke(e, t);
}
var Dke = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(e) {
    for (var t = e.upstream, r, n = Mke(e.config, {
      valueGetterAttrMap: nt({
        dimension: !0
      }),
      prepareGetValue: function(s) {
        var l = "", u = s.dimension;
        Ye(s, "dimension") || (process.env.NODE_ENV !== "production" && (l = Ai('Relation condition must has prop "dimension" specified.', "Illegal condition:", s)), mr(l));
        var c = t.getDimensionInfo(u);
        return c || (process.env.NODE_ENV !== "production" && (l = Ai("Can not find dimension info via: " + u + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal condition:", s, `.
`)), mr(l)), {
          dimIdx: c.index
        };
      },
      getValue: function(s) {
        return t.retrieveValueFromItem(r, s.dimIdx);
      }
    }), i = [], o = 0, a = t.count(); o < a; o++)
      r = t.getRawDataItem(o), n.evaluate() && i.push(r);
    return {
      data: i
    };
  }
}, KT = "";
process.env.NODE_ENV !== "production" && (KT = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" "));
var Ake = {
  type: "echarts:sort",
  transform: function(e) {
    var t = e.upstream, r = e.config, n = "", i = Tr(r);
    i.length || (process.env.NODE_ENV !== "production" && (n = "Empty `config` in sort transform."), mr(n));
    var o = [];
    $(i, function(c) {
      var d = c.dimension, h = c.order, f = c.parser, p = c.incomparable;
      if (d == null && (process.env.NODE_ENV !== "production" && (n = 'Sort transform config must has "dimension" specified.' + KT), mr(n)), h !== "asc" && h !== "desc" && (process.env.NODE_ENV !== "production" && (n = 'Sort transform config must has "order" specified.' + KT), mr(n)), p && p !== "min" && p !== "max") {
        var g = "";
        process.env.NODE_ENV !== "production" && (g = 'incomparable must be "min" or "max" rather than "' + p + '".'), mr(g);
      }
      if (h !== "asc" && h !== "desc") {
        var v = "";
        process.env.NODE_ENV !== "production" && (v = 'order must be "asc" or "desc" rather than "' + h + '".'), mr(v);
      }
      var m = t.getDimensionInfo(d);
      m || (process.env.NODE_ENV !== "production" && (n = Ai("Can not find dimension info via: " + d + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal config:", c, `.
`)), mr(n));
      var y = f ? X7(f) : null;
      f && !y && (process.env.NODE_ENV !== "production" && (n = Ai("Invalid parser name " + f + `.
`, "Illegal config:", c, `.
`)), mr(n)), o.push({
        dimIdx: m.index,
        parser: y,
        comparator: new Q7(h, p)
      });
    });
    var a = t.sourceFormat;
    a !== fi && a !== aa && (process.env.NODE_ENV !== "production" && (n = 'sourceFormat "' + a + '" is not supported yet'), mr(n));
    for (var s = [], l = 0, u = t.count(); l < u; l++)
      s.push(t.getRawDataItem(l));
    return s.sort(function(c, d) {
      for (var h = 0; h < o.length; h++) {
        var f = o[h], p = t.retrieveValueFromItem(c, f.dimIdx), g = t.retrieveValueFromItem(d, f.dimIdx);
        f.parser && (p = f.parser(p), g = f.parser(g));
        var v = f.comparator.evaluate(p, g);
        if (v !== 0)
          return v;
      }
      return 0;
    }), {
      data: s
    };
  }
};
function Ike(e) {
  e.registerTransform(Dke), e.registerTransform(Ake);
}
var Oke = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "dataset", r;
    }
    return t.prototype.init = function(r, n, i) {
      e.prototype.init.call(this, r, n, i), this._sourceManager = new r9(this), pk(this);
    }, t.prototype.mergeOption = function(r, n) {
      e.prototype.mergeOption.call(this, r, n), pk(this);
    }, t.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, t.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, t.type = "dataset", t.defaultOption = {
      seriesLayoutBy: cs
    }, t;
  }(Vt)
), Lke = (
  /** @class */
  function(e) {
    le(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "dataset", r;
    }
    return t.type = "dataset", t;
  }(zr)
);
function Fke(e) {
  e.registerComponentModel(Oke), e.registerComponentView(Lke);
}
var ja = ms.CMD;
function mh(e, t) {
  return Math.abs(e - t) < 1e-5;
}
function YT(e) {
  var t = e.data, r = e.len(), n = [], i, o = 0, a = 0, s = 0, l = 0;
  function u(O, A) {
    i && i.length > 2 && n.push(i), i = [O, A];
  }
  function c(O, A, F, L) {
    mh(O, F) && mh(A, L) || i.push(O, A, F, L, F, L);
  }
  function d(O, A, F, L, N, I) {
    var B = Math.abs(A - O), M = Math.tan(B / 4) * 4 / 3, V = A < O ? -1 : 1, G = Math.cos(O), k = Math.sin(O), z = Math.cos(A), j = Math.sin(A), q = G * N + F, K = k * I + L, Z = z * N + F, re = j * I + L, X = N * M * V, Y = I * M * V;
    i.push(q - X * k, K + Y * G, Z + X * j, re - Y * z, Z, re);
  }
  for (var h, f, p, g, v = 0; v < r; ) {
    var m = t[v++], y = v === 1;
    switch (y && (o = t[v], a = t[v + 1], s = o, l = a, (m === ja.L || m === ja.C || m === ja.Q) && (i = [s, l])), m) {
      case ja.M:
        o = s = t[v++], a = l = t[v++], u(s, l);
        break;
      case ja.L:
        h = t[v++], f = t[v++], c(o, a, h, f), o = h, a = f;
        break;
      case ja.C:
        i.push(t[v++], t[v++], t[v++], t[v++], o = t[v++], a = t[v++]);
        break;
      case ja.Q:
        h = t[v++], f = t[v++], p = t[v++], g = t[v++], i.push(o + 2 / 3 * (h - o), a + 2 / 3 * (f - a), p + 2 / 3 * (h - p), g + 2 / 3 * (f - g), p, g), o = p, a = g;
        break;
      case ja.A:
        var C = t[v++], S = t[v++], b = t[v++], w = t[v++], x = t[v++], R = t[v++] + x;
        v += 1;
        var _ = !t[v++];
        h = Math.cos(x) * b + C, f = Math.sin(x) * w + S, y ? (s = h, l = f, u(s, l)) : c(o, a, h, f), o = Math.cos(R) * b + C, a = Math.sin(R) * w + S;
        for (var T = (_ ? -1 : 1) * Math.PI / 2, P = x; _ ? P > R : P < R; P += T) {
          var D = _ ? Math.max(P + T, R) : Math.min(P + T, R);
          d(P, D, C, S, b, w);
        }
        break;
      case ja.R:
        s = o = t[v++], l = a = t[v++], h = s + t[v++], f = l + t[v++], u(h, l), c(h, l, h, f), c(h, f, s, f), c(s, f, s, l), c(s, l, h, l);
        break;
      case ja.Z:
        i && c(o, a, s, l), o = s, a = l;
        break;
    }
  }
  return i && i.length > 2 && n.push(i), n;
}
function qT(e, t, r, n, i, o, a, s, l, u) {
  if (mh(e, r) && mh(t, n) && mh(i, a) && mh(o, s)) {
    l.push(a, s);
    return;
  }
  var c = 2 / u, d = c * c, h = a - e, f = s - t, p = Math.sqrt(h * h + f * f);
  h /= p, f /= p;
  var g = r - e, v = n - t, m = i - a, y = o - s, C = g * g + v * v, S = m * m + y * y;
  if (C < d && S < d) {
    l.push(a, s);
    return;
  }
  var b = h * g + f * v, w = -h * m - f * y, x = C - b * b, R = S - w * w;
  if (x < d && b >= 0 && R < d && w >= 0) {
    l.push(a, s);
    return;
  }
  var _ = [], T = [];
  iu(e, r, i, a, 0.5, _), iu(t, n, o, s, 0.5, T), qT(_[0], T[0], _[1], T[1], _[2], T[2], _[3], T[3], l, u), qT(_[4], T[4], _[5], T[5], _[6], T[6], _[7], T[7], l, u);
}
function Nke(e, t) {
  var r = YT(e), n = [];
  t = t || 1;
  for (var i = 0; i < r.length; i++) {
    var o = r[i], a = [], s = o[0], l = o[1];
    a.push(s, l);
    for (var u = 2; u < o.length; ) {
      var c = o[u++], d = o[u++], h = o[u++], f = o[u++], p = o[u++], g = o[u++];
      qT(s, l, c, d, h, f, p, g, a, t), s = p, l = g;
    }
    n.push(a);
  }
  return n;
}
function CY(e, t, r) {
  var n = e[t], i = e[1 - t], o = Math.abs(n / i), a = Math.ceil(Math.sqrt(o * r)), s = Math.floor(r / a);
  s === 0 && (s = 1, a = r);
  for (var l = [], u = 0; u < a; u++)
    l.push(s);
  var c = a * s, d = r - c;
  if (d > 0)
    for (var u = 0; u < d; u++)
      l[u % a] += 1;
  return l;
}
function gH(e, t, r) {
  for (var n = e.r0, i = e.r, o = e.startAngle, a = e.endAngle, s = Math.abs(a - o), l = s * i, u = i - n, c = l > Math.abs(u), d = CY([l, u], c ? 0 : 1, t), h = (c ? s : u) / d.length, f = 0; f < d.length; f++)
    for (var p = (c ? u : s) / d[f], g = 0; g < d[f]; g++) {
      var v = {};
      c ? (v.startAngle = o + h * f, v.endAngle = o + h * (f + 1), v.r0 = n + p * g, v.r = n + p * (g + 1)) : (v.startAngle = o + p * g, v.endAngle = o + p * (g + 1), v.r0 = n + h * f, v.r = n + h * (f + 1)), v.clockwise = e.clockwise, v.cx = e.cx, v.cy = e.cy, r.push(v);
    }
}
function kke(e, t, r) {
  for (var n = e.width, i = e.height, o = n > i, a = CY([n, i], o ? 0 : 1, t), s = o ? "width" : "height", l = o ? "height" : "width", u = o ? "x" : "y", c = o ? "y" : "x", d = e[s] / a.length, h = 0; h < a.length; h++)
    for (var f = e[l] / a[h], p = 0; p < a[h]; p++) {
      var g = {};
      g[u] = h * d, g[c] = p * f, g[s] = d, g[l] = f, g.x += e.x, g.y += e.y, r.push(g);
    }
}
function vH(e, t, r, n) {
  return e * n - r * t;
}
function Vke(e, t, r, n, i, o, a, s) {
  var l = r - e, u = n - t, c = a - i, d = s - o, h = vH(c, d, l, u);
  if (Math.abs(h) < 1e-6)
    return null;
  var f = e - i, p = t - o, g = vH(f, p, c, d) / h;
  return g < 0 || g > 1 ? null : new Dt(g * l + e, g * u + t);
}
function Bke(e, t, r) {
  var n = new Dt();
  Dt.sub(n, r, t), n.normalize();
  var i = new Dt();
  Dt.sub(i, e, t);
  var o = i.dot(n);
  return o;
}
function Zd(e, t) {
  var r = e[e.length - 1];
  r && r[0] === t[0] && r[1] === t[1] || e.push(t);
}
function $ke(e, t, r) {
  for (var n = e.length, i = [], o = 0; o < n; o++) {
    var a = e[o], s = e[(o + 1) % n], l = Vke(a[0], a[1], s[0], s[1], t.x, t.y, r.x, r.y);
    l && i.push({
      projPt: Bke(l, t, r),
      pt: l,
      idx: o
    });
  }
  if (i.length < 2)
    return [{ points: e }, { points: e }];
  i.sort(function(v, m) {
    return v.projPt - m.projPt;
  });
  var u = i[0], c = i[i.length - 1];
  if (c.idx < u.idx) {
    var d = u;
    u = c, c = d;
  }
  for (var h = [u.pt.x, u.pt.y], f = [c.pt.x, c.pt.y], p = [h], g = [f], o = u.idx + 1; o <= c.idx; o++)
    Zd(p, e[o].slice());
  Zd(p, f), Zd(p, h);
  for (var o = c.idx + 1; o <= u.idx + n; o++)
    Zd(g, e[o % n].slice());
  return Zd(g, h), Zd(g, f), [{
    points: p
  }, {
    points: g
  }];
}
function mH(e) {
  var t = e.points, r = [], n = [];
  rw(t, r, n);
  var i = new At(r[0], r[1], n[0] - r[0], n[1] - r[1]), o = i.width, a = i.height, s = i.x, l = i.y, u = new Dt(), c = new Dt();
  return o > a ? (u.x = c.x = s + o / 2, u.y = l, c.y = l + a) : (u.y = c.y = l + a / 2, u.x = s, c.x = s + o), $ke(t, u, c);
}
function YC(e, t, r, n) {
  if (r === 1)
    n.push(t);
  else {
    var i = Math.floor(r / 2), o = e(t);
    YC(e, o[0], i, n), YC(e, o[1], r - i, n);
  }
  return n;
}
function Hke(e, t) {
  for (var r = [], n = 0; n < t; n++)
    r.push(iD(e));
  return r;
}
function Gke(e, t) {
  t.setStyle(e.style), t.z = e.z, t.z2 = e.z2, t.zlevel = e.zlevel;
}
function zke(e) {
  for (var t = [], r = 0; r < e.length; )
    t.push([e[r++], e[r++]]);
  return t;
}
function Wke(e, t) {
  var r = [], n = e.shape, i;
  switch (e.type) {
    case "rect":
      kke(n, t, r), i = or;
      break;
    case "sector":
      gH(n, t, r), i = Oi;
      break;
    case "circle":
      gH({
        r0: 0,
        r: n.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: n.cx,
        cy: n.cy
      }, t, r), i = Oi;
      break;
    default:
      var o = e.getComputedTransform(), a = o ? Math.sqrt(Math.max(o[0] * o[0] + o[1] * o[1], o[2] * o[2] + o[3] * o[3])) : 1, s = Ee(Nke(e.getUpdatedPathProxy(), a), function(m) {
        return zke(m);
      }), l = s.length;
      if (l === 0)
        YC(mH, {
          points: s[0]
        }, t, r);
      else if (l === t)
        for (var u = 0; u < l; u++)
          r.push({
            points: s[u]
          });
      else {
        var c = 0, d = Ee(s, function(m) {
          var y = [], C = [];
          rw(m, y, C);
          var S = (C[1] - y[1]) * (C[0] - y[0]);
          return c += S, { poly: m, area: S };
        });
        d.sort(function(m, y) {
          return y.area - m.area;
        });
        for (var h = t, u = 0; u < l; u++) {
          var f = d[u];
          if (h <= 0)
            break;
          var p = u === l - 1 ? h : Math.ceil(f.area / c * t);
          p < 0 || (YC(mH, {
            points: f.poly
          }, p, r), h -= p);
        }
      }
      i = Li;
      break;
  }
  if (!i)
    return Hke(e, t);
  for (var g = [], u = 0; u < r.length; u++) {
    var v = new i();
    v.setShape(r[u]), Gke(e, v), g.push(v);
  }
  return g;
}
function jke(e, t) {
  var r = e.length, n = t.length;
  if (r === n)
    return [e, t];
  for (var i = [], o = [], a = r < n ? e : t, s = Math.min(r, n), l = Math.abs(n - r) / 6, u = (s - 2) / 6, c = Math.ceil(l / u) + 1, d = [a[0], a[1]], h = l, f = 2; f < s; ) {
    var p = a[f - 2], g = a[f - 1], v = a[f++], m = a[f++], y = a[f++], C = a[f++], S = a[f++], b = a[f++];
    if (h <= 0) {
      d.push(v, m, y, C, S, b);
      continue;
    }
    for (var w = Math.min(h, c - 1) + 1, x = 1; x <= w; x++) {
      var R = x / w;
      iu(p, v, y, S, R, i), iu(g, m, C, b, R, o), p = i[3], g = o[3], d.push(i[1], o[1], i[2], o[2], p, g), v = i[5], m = o[5], y = i[6], C = o[6];
    }
    h -= w - 1;
  }
  return a === e ? [d, t] : [e, d];
}
function yH(e, t) {
  for (var r = e.length, n = e[r - 2], i = e[r - 1], o = [], a = 0; a < t.length; )
    o[a++] = n, o[a++] = i;
  return o;
}
function Uke(e, t) {
  for (var r, n, i, o = [], a = [], s = 0; s < Math.max(e.length, t.length); s++) {
    var l = e[s], u = t[s], c = void 0, d = void 0;
    l ? u ? (r = jke(l, u), c = r[0], d = r[1], n = c, i = d) : (d = yH(i || l, l), c = l) : (c = yH(n || u, u), d = u), o.push(c), a.push(d);
  }
  return [o, a];
}
function CH(e) {
  for (var t = 0, r = 0, n = 0, i = e.length, o = 0, a = i - 2; o < i; a = o, o += 2) {
    var s = e[a], l = e[a + 1], u = e[o], c = e[o + 1], d = s * c - u * l;
    t += d, r += (s + u) * d, n += (l + c) * d;
  }
  return t === 0 ? [e[0] || 0, e[1] || 0] : [r / t / 3, n / t / 3, t];
}
function Kke(e, t, r, n) {
  for (var i = (e.length - 2) / 6, o = 1 / 0, a = 0, s = e.length, l = s - 2, u = 0; u < i; u++) {
    for (var c = u * 6, d = 0, h = 0; h < s; h += 2) {
      var f = h === 0 ? c : (c + h - 2) % l + 2, p = e[f] - r[0], g = e[f + 1] - r[1], v = t[h] - n[0], m = t[h + 1] - n[1], y = v - p, C = m - g;
      d += y * y + C * C;
    }
    d < o && (o = d, a = u);
  }
  return a;
}
function Yke(e) {
  for (var t = [], r = e.length, n = 0; n < r; n += 2)
    t[n] = e[r - n - 2], t[n + 1] = e[r - n - 1];
  return t;
}
function qke(e, t, r, n) {
  for (var i = [], o, a = 0; a < e.length; a++) {
    var s = e[a], l = t[a], u = CH(s), c = CH(l);
    o == null && (o = u[2] < 0 != c[2] < 0);
    var d = [], h = [], f = 0, p = 1 / 0, g = [], v = s.length;
    o && (s = Yke(s));
    for (var m = Kke(s, l, u, c) * 6, y = v - 2, C = 0; C < y; C += 2) {
      var S = (m + C) % y + 2;
      d[C + 2] = s[S] - u[0], d[C + 3] = s[S + 1] - u[1];
    }
    d[0] = s[m] - u[0], d[1] = s[m + 1] - u[1];
    for (var b = n / r, w = -n / 2; w <= n / 2; w += b) {
      for (var x = Math.sin(w), R = Math.cos(w), _ = 0, C = 0; C < s.length; C += 2) {
        var T = d[C], P = d[C + 1], D = l[C] - c[0], O = l[C + 1] - c[1], A = D * R - O * x, F = D * x + O * R;
        g[C] = A, g[C + 1] = F;
        var L = A - T, N = F - P;
        _ += L * L + N * N;
      }
      if (_ < p) {
        p = _, f = w;
        for (var I = 0; I < g.length; I++)
          h[I] = g[I];
      }
    }
    i.push({
      from: d,
      to: h,
      fromCp: u,
      toCp: c,
      rotation: -f
    });
  }
  return i;
}
function qC(e) {
  return e.__isCombineMorphing;
}
var SY = "__mOriginal_";
function XC(e, t, r) {
  var n = SY + t, i = e[n] || e[t];
  e[n] || (e[n] = e[t]);
  var o = r.replace, a = r.after, s = r.before;
  e[t] = function() {
    var l = arguments, u;
    return s && s.apply(this, l), o ? u = o.apply(this, l) : u = i.apply(this, l), a && a.apply(this, l), u;
  };
}
function vg(e, t) {
  var r = SY + t;
  e[r] && (e[t] = e[r], e[r] = null);
}
function SH(e, t) {
  for (var r = 0; r < e.length; r++)
    for (var n = e[r], i = 0; i < n.length; ) {
      var o = n[i], a = n[i + 1];
      n[i++] = t[0] * o + t[2] * a + t[4], n[i++] = t[1] * o + t[3] * a + t[5];
    }
}
function wY(e, t) {
  var r = e.getUpdatedPathProxy(), n = t.getUpdatedPathProxy(), i = Uke(YT(r), YT(n)), o = i[0], a = i[1], s = e.getComputedTransform(), l = t.getComputedTransform();
  function u() {
    this.transform = null;
  }
  s && SH(o, s), l && SH(a, l), XC(t, "updateTransform", { replace: u }), t.transform = null;
  var c = qke(o, a, 10, Math.PI), d = [];
  XC(t, "buildPath", { replace: function(h) {
    for (var f = t.__morphT, p = 1 - f, g = [], v = 0; v < c.length; v++) {
      var m = c[v], y = m.from, C = m.to, S = m.rotation * f, b = m.fromCp, w = m.toCp, x = Math.sin(S), R = Math.cos(S);
      rg(g, b, w, f);
      for (var _ = 0; _ < y.length; _ += 2) {
        var T = y[_], P = y[_ + 1], D = C[_], O = C[_ + 1], A = T * p + D * f, F = P * p + O * f;
        d[_] = A * R - F * x + g[0], d[_ + 1] = A * x + F * R + g[1];
      }
      var L = d[0], N = d[1];
      h.moveTo(L, N);
      for (var _ = 2; _ < y.length; ) {
        var D = d[_++], O = d[_++], I = d[_++], B = d[_++], M = d[_++], V = d[_++];
        L === D && N === O && I === M && B === V ? h.lineTo(M, V) : h.bezierCurveTo(D, O, I, B, M, V), L = M, N = V;
      }
    }
  } });
}
function ZA(e, t, r) {
  if (!e || !t)
    return t;
  var n = r.done, i = r.during;
  wY(e, t), t.__morphT = 0;
  function o() {
    vg(t, "buildPath"), vg(t, "updateTransform"), t.__morphT = -1, t.createPathProxy(), t.dirtyShape();
  }
  return t.animateTo({
    __morphT: 1
  }, ut({
    during: function(a) {
      t.dirtyShape(), i && i(a);
    },
    done: function() {
      o(), n && n();
    }
  }, r)), t;
}
function Xke(e, t, r, n, i, o) {
  var a = 16;
  e = i === r ? 0 : Math.round(32767 * (e - r) / (i - r)), t = o === n ? 0 : Math.round(32767 * (t - n) / (o - n));
  for (var s = 0, l, u = (1 << a) / 2; u > 0; u /= 2) {
    var c = 0, d = 0;
    (e & u) > 0 && (c = 1), (t & u) > 0 && (d = 1), s += u * u * (3 * c ^ d), d === 0 && (c === 1 && (e = u - 1 - e, t = u - 1 - t), l = e, e = t, t = l);
  }
  return s;
}
function ZC(e) {
  var t = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, o = Ee(e, function(s) {
    var l = s.getBoundingRect(), u = s.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), d = l.y + l.height / 2 + (u ? u[5] : 0);
    return t = Math.min(c, t), r = Math.min(d, r), n = Math.max(c, n), i = Math.max(d, i), [c, d];
  }), a = Ee(o, function(s, l) {
    return {
      cp: s,
      z: Xke(s[0], s[1], t, r, n, i),
      path: e[l]
    };
  });
  return a.sort(function(s, l) {
    return s.z - l.z;
  }).map(function(s) {
    return s.path;
  });
}
function bY(e) {
  return Wke(e.path, e.count);
}
function XT() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function Zke(e, t, r) {
  var n = [];
  function i(b) {
    for (var w = 0; w < b.length; w++) {
      var x = b[w];
      qC(x) ? i(x.childrenRef()) : x instanceof Ht && n.push(x);
    }
  }
  i(e);
  var o = n.length;
  if (!o)
    return XT();
  var a = r.dividePath || bY, s = a({
    path: t,
    count: o
  });
  if (s.length !== o)
    return console.error("Invalid morphing: unmatched splitted path"), XT();
  n = ZC(n), s = ZC(s);
  for (var l = r.done, u = r.during, c = r.individualDelay, d = new $s(), h = 0; h < o; h++) {
    var f = n[h], p = s[h];
    p.parent = t, p.copyTransform(d), c || wY(f, p);
  }
  t.__isCombineMorphing = !0, t.childrenRef = function() {
    return s;
  };
  function g(b) {
    for (var w = 0; w < s.length; w++)
      s[w].addSelfToZr(b);
  }
  XC(t, "addSelfToZr", {
    after: function(b) {
      g(b);
    }
  }), XC(t, "removeSelfFromZr", {
    after: function(b) {
      for (var w = 0; w < s.length; w++)
        s[w].removeSelfFromZr(b);
    }
  });
  function v() {
    t.__isCombineMorphing = !1, t.__morphT = -1, t.childrenRef = null, vg(t, "addSelfToZr"), vg(t, "removeSelfFromZr");
  }
  var m = s.length;
  if (c)
    for (var y = m, C = function() {
      y--, y === 0 && (v(), l && l());
    }, h = 0; h < m; h++) {
      var S = c ? ut({
        delay: (r.delay || 0) + c(h, m, n[h], s[h]),
        done: C
      }, r) : r;
      ZA(n[h], s[h], S);
    }
  else
    t.__morphT = 0, t.animateTo({
      __morphT: 1
    }, ut({
      during: function(b) {
        for (var w = 0; w < m; w++) {
          var x = s[w];
          x.__morphT = t.__morphT, x.dirtyShape();
        }
        u && u(b);
      },
      done: function() {
        v();
        for (var b = 0; b < e.length; b++)
          vg(e[b], "updateTransform");
        l && l();
      }
    }, r));
  return t.__zr && g(t.__zr), {
    fromIndividuals: n,
    toIndividuals: s,
    count: m
  };
}
function Qke(e, t, r) {
  var n = t.length, i = [], o = r.dividePath || bY;
  function a(f) {
    for (var p = 0; p < f.length; p++) {
      var g = f[p];
      qC(g) ? a(g.childrenRef()) : g instanceof Ht && i.push(g);
    }
  }
  if (qC(e)) {
    a(e.childrenRef());
    var s = i.length;
    if (s < n)
      for (var l = 0, u = s; u < n; u++)
        i.push(iD(i[l++ % s]));
    i.length = n;
  } else {
    i = o({ path: e, count: n });
    for (var c = e.getComputedTransform(), u = 0; u < i.length; u++)
      i[u].setLocalTransform(c);
    if (i.length !== n)
      return console.error("Invalid morphing: unmatched splitted path"), XT();
  }
  i = ZC(i), t = ZC(t);
  for (var d = r.individualDelay, u = 0; u < n; u++) {
    var h = d ? ut({
      delay: (r.delay || 0) + d(u, n, i[u], t[u])
    }, r) : r;
    ZA(i[u], t[u], h);
  }
  return {
    fromIndividuals: i,
    toIndividuals: t,
    count: t.length
  };
}
function wH(e) {
  return be(e[0]);
}
function bH(e, t) {
  for (var r = [], n = e.length, i = 0; i < n; i++)
    r.push({
      one: e[i],
      many: []
    });
  for (var i = 0; i < t.length; i++) {
    var o = t[i].length, a = void 0;
    for (a = 0; a < o; a++)
      r[a % n].many.push(t[i][a]);
  }
  for (var s = 0, i = n - 1; i >= 0; i--)
    if (!r[i].many.length) {
      var l = r[s].many;
      if (l.length <= 1)
        if (s)
          s = 0;
        else
          return r;
      var o = l.length, u = Math.ceil(o / 2);
      r[i].many = l.slice(u, o), r[s].many = l.slice(0, u), s++;
    }
  return r;
}
var Jke = {
  clone: function(e) {
    for (var t = [], r = 1 - Math.pow(1 - e.path.style.opacity, 1 / e.count), n = 0; n < e.count; n++) {
      var i = iD(e.path);
      i.setStyle("opacity", r), t.push(i);
    }
    return t;
  },
  // Use the default divider
  split: null
};
function dE(e, t, r, n, i, o) {
  if (!e.length || !t.length)
    return;
  var a = mf("update", n, i);
  if (!(a && a.duration > 0))
    return;
  var s = n.getModel("universalTransition").get("delay"), l = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, a), u, c;
  wH(e) && (u = e, c = t), wH(t) && (u = t, c = e);
  function d(m, y, C, S, b) {
    var w = m.many, x = m.one;
    if (w.length === 1 && !b) {
      var R = y ? w[0] : x, _ = y ? x : w[0];
      if (qC(R))
        d({
          many: [R],
          one: _
        }, !0, C, S, !0);
      else {
        var T = s ? ut({
          delay: s(C, S)
        }, l) : l;
        ZA(R, _, T), o(R, _, R, _, T);
      }
    } else
      for (var P = ut({
        dividePath: Jke[r],
        individualDelay: s && function(N, I, B, M) {
          return s(N + C, S);
        }
      }, l), D = y ? Zke(w, x, P) : Qke(x, w, P), O = D.fromIndividuals, A = D.toIndividuals, F = O.length, L = 0; L < F; L++) {
        var T = s ? ut({
          delay: s(L, F)
        }, l) : l;
        o(O[L], A[L], y ? w[L] : m.one, y ? m.one : w[L], T);
      }
  }
  for (var h = u ? u === e : e.length > t.length, f = u ? bH(c, u) : bH(h ? t : e, [h ? e : t]), p = 0, g = 0; g < f.length; g++)
    p += f[g].many.length;
  for (var v = 0, g = 0; g < f.length; g++)
    d(f[g], h, v, p), v += f[g].many.length;
}
function nc(e) {
  if (!e)
    return [];
  if (be(e)) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push(nc(e[r]));
    return t;
  }
  var n = [];
  return e.traverse(function(i) {
    i instanceof Ht && !i.disableMorphing && !i.invisible && !i.ignore && n.push(i);
  }), n;
}
var xY = 1e4, eVe = 0, xH = 1, EH = 2, tVe = ar();
function rVe(e, t) {
  for (var r = e.dimensions, n = 0; n < r.length; n++) {
    var i = e.getDimensionInfo(r[n]);
    if (i && i.otherDims[t] === 0)
      return r[n];
  }
}
function nVe(e, t, r) {
  var n = e.getDimensionInfo(r), i = n && n.ordinalMeta;
  if (n) {
    var o = e.get(n.name, t);
    return i && i.categories[o] || o + "";
  }
}
function RH(e, t, r, n) {
  var i = n ? "itemChildGroupId" : "itemGroupId", o = rVe(e, i);
  if (o) {
    var a = nVe(e, t, o);
    return a;
  }
  var s = e.getRawDataItem(t), l = n ? "childGroupId" : "groupId";
  if (s && s[l])
    return s[l] + "";
  if (!n)
    return r || e.getId(t);
}
function _H(e) {
  var t = [];
  return $(e, function(r) {
    var n = r.data, i = r.dataGroupId;
    if (n.count() > xY) {
      process.env.NODE_ENV !== "production" && nn("Universal transition is disabled on large data > 10k.");
      return;
    }
    for (var o = n.getIndices(), a = 0; a < o.length; a++)
      t.push({
        data: n,
        groupId: RH(n, a, i, !1),
        childGroupId: RH(n, a, i, !0),
        divide: r.divide,
        dataIndex: a
      });
  }), t;
}
function hE(e, t, r) {
  e.traverse(function(n) {
    n instanceof Ht && jr(n, {
      style: {
        opacity: 0
      }
    }, t, {
      dataIndex: r,
      isFrom: !0
    });
  });
}
function fE(e) {
  if (e.parent) {
    var t = e.getComputedTransform();
    e.setLocalTransform(t), e.parent.remove(e);
  }
}
function Qd(e) {
  e.stopAnimation(), e.isGroup && e.traverse(function(t) {
    t.stopAnimation();
  });
}
function iVe(e, t, r) {
  var n = mf("update", r, t);
  n && e.traverse(function(i) {
    if (i instanceof ta) {
      var o = Iwe(i);
      o && i.animateFrom({
        style: o
      }, n);
    }
  });
}
function oVe(e, t) {
  var r = e.length;
  if (r !== t.length)
    return !1;
  for (var n = 0; n < r; n++) {
    var i = e[n], o = t[n];
    if (i.data.getId(i.dataIndex) !== o.data.getId(o.dataIndex))
      return !1;
  }
  return !0;
}
function EY(e, t, r) {
  var n = _H(e), i = _H(t);
  function o(C, S, b, w, x) {
    (b || C) && S.animateFrom({
      style: b && b !== C ? ge(ge({}, b.style), C.style) : C.style
    }, x);
  }
  var a = !1, s = eVe, l = nt(), u = nt();
  n.forEach(function(C) {
    C.groupId && l.set(C.groupId, !0), C.childGroupId && u.set(C.childGroupId, !0);
  });
  for (var c = 0; c < i.length; c++) {
    var d = i[c].groupId;
    if (u.get(d)) {
      s = xH;
      break;
    }
    var h = i[c].childGroupId;
    if (h && l.get(h)) {
      s = EH;
      break;
    }
  }
  function f(C, S) {
    return function(b) {
      var w = b.data, x = b.dataIndex;
      return S ? w.getId(x) : C ? s === xH ? b.childGroupId : b.groupId : s === EH ? b.childGroupId : b.groupId;
    };
  }
  var p = oVe(n, i), g = {};
  if (!p)
    for (var c = 0; c < i.length; c++) {
      var v = i[c], m = v.data.getItemGraphicEl(v.dataIndex);
      m && (g[m.id] = !0);
    }
  function y(C, S) {
    var b = n[S], w = i[C], x = w.data.hostModel, R = b.data.getItemGraphicEl(b.dataIndex), _ = w.data.getItemGraphicEl(w.dataIndex);
    if (R === _) {
      _ && iVe(_, w.dataIndex, x);
      return;
    }
    // We can't use the elements that already being morphed
    R && g[R.id] || _ && (Qd(_), R ? (Qd(R), fE(R), a = !0, dE(nc(R), nc(_), w.divide, x, C, o)) : hE(_, x, C));
  }
  new el(n, i, f(!0, p), f(!1, p), null, "multiple").update(y).updateManyToOne(function(C, S) {
    var b = i[C], w = b.data, x = w.hostModel, R = w.getItemGraphicEl(b.dataIndex), _ = Sr(Ee(S, function(T) {
      return n[T].data.getItemGraphicEl(n[T].dataIndex);
    }), function(T) {
      return T && T !== R && !g[T.id];
    });
    R && (Qd(R), _.length ? ($(_, function(T) {
      Qd(T), fE(T);
    }), a = !0, dE(nc(_), nc(R), b.divide, x, C, o)) : hE(R, x, b.dataIndex));
  }).updateOneToMany(function(C, S) {
    var b = n[S], w = b.data.getItemGraphicEl(b.dataIndex);
    if (!(w && g[w.id])) {
      var x = Sr(Ee(C, function(_) {
        return i[_].data.getItemGraphicEl(i[_].dataIndex);
      }), function(_) {
        return _ && _ !== w;
      }), R = i[C[0]].data.hostModel;
      x.length && ($(x, function(_) {
        return Qd(_);
      }), w ? (Qd(w), fE(w), a = !0, dE(
        nc(w),
        nc(x),
        b.divide,
        // Use divide on old.
        R,
        C[0],
        o
      )) : $(x, function(_) {
        return hE(_, R, C[0]);
      }));
    }
  }).updateManyToMany(function(C, S) {
    new el(S, C, function(b) {
      return n[b].data.getId(n[b].dataIndex);
    }, function(b) {
      return i[b].data.getId(i[b].dataIndex);
    }).update(function(b, w) {
      y(C[b], S[w]);
    }).execute();
  }).execute(), a && $(t, function(C) {
    var S = C.data, b = S.hostModel, w = b && r.getViewOfSeriesModel(b), x = mf("update", b, 0);
    w && b.isAnimationEnabled() && x && x.duration > 0 && w.group.traverse(function(R) {
      R instanceof Ht && !R.animators.length && R.animateFrom({
        style: {
          opacity: 0
        }
      }, x);
    });
  });
}
function TH(e) {
  var t = e.getModel("universalTransition").get("seriesKey");
  return t || e.id;
}
function PH(e) {
  return be(e) ? e.sort().join(",") : e;
}
function Ml(e) {
  if (e.hostModel)
    return e.hostModel.getModel("universalTransition").get("divideShape");
}
function aVe(e, t) {
  var r = nt(), n = nt(), i = nt();
  $(e.oldSeries, function(a, s) {
    var l = e.oldDataGroupIds[s], u = e.oldData[s], c = TH(a), d = PH(c);
    n.set(d, {
      dataGroupId: l,
      data: u
    }), be(c) && $(c, function(h) {
      i.set(h, {
        key: d,
        dataGroupId: l,
        data: u
      });
    });
  });
  function o(a) {
    r.get(a) && nn("Duplicated seriesKey in universalTransition " + a);
  }
  return $(t.updatedSeries, function(a) {
    if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
      var s = a.get("dataGroupId"), l = a.getData(), u = TH(a), c = PH(u), d = n.get(c);
      if (d)
        process.env.NODE_ENV !== "production" && o(c), r.set(c, {
          oldSeries: [{
            dataGroupId: d.dataGroupId,
            divide: Ml(d.data),
            data: d.data
          }],
          newSeries: [{
            dataGroupId: s,
            divide: Ml(l),
            data: l
          }]
        });
      else if (be(u)) {
        process.env.NODE_ENV !== "production" && o(c);
        var h = [];
        $(u, function(g) {
          var v = n.get(g);
          v.data && h.push({
            dataGroupId: v.dataGroupId,
            divide: Ml(v.data),
            data: v.data
          });
        }), h.length && r.set(c, {
          oldSeries: h,
          newSeries: [{
            dataGroupId: s,
            data: l,
            divide: Ml(l)
          }]
        });
      } else {
        var f = i.get(u);
        if (f) {
          var p = r.get(f.key);
          p || (p = {
            oldSeries: [{
              dataGroupId: f.dataGroupId,
              data: f.data,
              divide: Ml(f.data)
            }],
            newSeries: []
          }, r.set(f.key, p)), p.newSeries.push({
            dataGroupId: s,
            data: l,
            divide: Ml(l)
          });
        }
      }
    }
  }), r;
}
function MH(e, t) {
  for (var r = 0; r < e.length; r++) {
    var n = t.seriesIndex != null && t.seriesIndex === e[r].seriesIndex || t.seriesId != null && t.seriesId === e[r].id;
    if (n)
      return r;
  }
}
function sVe(e, t, r, n) {
  var i = [], o = [];
  $(Tr(e.from), function(a) {
    var s = MH(t.oldSeries, a);
    s >= 0 && i.push({
      dataGroupId: t.oldDataGroupIds[s],
      data: t.oldData[s],
      // TODO can specify divideShape in transition.
      divide: Ml(t.oldData[s]),
      groupIdDim: a.dimension
    });
  }), $(Tr(e.to), function(a) {
    var s = MH(r.updatedSeries, a);
    if (s >= 0) {
      var l = r.updatedSeries[s].getData();
      o.push({
        dataGroupId: t.oldDataGroupIds[s],
        data: l,
        divide: Ml(l),
        groupIdDim: a.dimension
      });
    }
  }), i.length > 0 && o.length > 0 && EY(i, o, n);
}
function lVe(e) {
  e.registerUpdateLifecycle("series:beforeupdate", function(t, r, n) {
    $(Tr(n.seriesTransition), function(i) {
      $(Tr(i.to), function(o) {
        for (var a = n.updatedSeries, s = 0; s < a.length; s++)
          (o.seriesIndex != null && o.seriesIndex === a[s].seriesIndex || o.seriesId != null && o.seriesId === a[s].id) && (a[s][f0] = !0);
      });
    });
  }), e.registerUpdateLifecycle("series:transition", function(t, r, n) {
    var i = tVe(r);
    if (i.oldSeries && n.updatedSeries && n.optionChanged) {
      var o = n.seriesTransition;
      if (o)
        $(Tr(o), function(f) {
          sVe(f, i, n, r);
        });
      else {
        var a = aVe(i, n);
        $(a.keys(), function(f) {
          var p = a.get(f);
          EY(p.oldSeries, p.newSeries, r);
        });
      }
      $(n.updatedSeries, function(f) {
        f[f0] && (f[f0] = !1);
      });
    }
    for (var s = t.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], d = 0; d < s.length; d++) {
      var h = s[d].getData();
      h.count() < xY && (l.push(s[d]), u.push(s[d].get("dataGroupId")), c.push(h));
    }
  });
}
Bt([y_e]);
Bt([f_e]);
Bt([V_e, J_e, uTe, GTe, JTe, BPe, fMe, XMe, yDe, EDe, ODe, TAe, QAe, uIe, RIe, MIe, BIe, UIe, n2e, u2e, C2e, tOe]);
Bt(SOe);
Bt(KOe);
Bt(wU);
Bt(aLe);
Bt(aK);
Bt(cLe);
Bt(CLe);
Bt(aFe);
Bt(RFe);
Bt(Jv);
Bt(GFe);
Bt(jFe);
Bt(tNe);
Bt(lNe);
Bt(pNe);
Bt(SNe);
Bt(DNe);
Bt(YNe);
Bt(cY);
Bt(dY);
Bt(pke);
Bt(vY);
Bt(mY);
Bt(Cke);
Bt(Ike);
Bt(Fke);
Bt(lVe);
Bt(ORe);
const uVe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axis: sa,
  ChartView: br,
  ComponentModel: Vt,
  ComponentView: zr,
  List: di,
  Model: _r,
  PRIORITY: D9,
  SeriesModel: Pr,
  color: G0e,
  connect: Bxe,
  dataTool: Uxe,
  dependencies: wxe,
  disConnect: $xe,
  disconnect: V9,
  dispose: Hxe,
  env: nr,
  extendChartView: SRe,
  extendComponentModel: mRe,
  extendComponentView: yRe,
  extendSeriesModel: CRe,
  format: oRe,
  getCoordinateSystemDimensions: zxe,
  getInstanceByDom: FD,
  getInstanceById: Gxe,
  getMap: jxe,
  graphic: iRe,
  helper: XEe,
  init: Vxe,
  innerDrawElementOnCanvas: AD,
  matrix: C0e,
  number: rRe,
  parseGeoJSON: lT,
  parseGeoJson: lT,
  registerAction: Va,
  registerCoordinateSystem: H9,
  registerLayout: G9,
  registerLoading: $D,
  registerLocale: fD,
  registerMap: z9,
  registerPostInit: B9,
  registerPostUpdate: $9,
  registerPreprocessor: kD,
  registerProcessor: VD,
  registerTheme: ND,
  registerTransform: W9,
  registerUpdateLifecycle: ww,
  registerVisual: bu,
  setCanvasCreator: Wxe,
  setPlatformAPI: T6,
  throttle: Cw,
  time: nRe,
  use: Bt,
  util: aRe,
  vector: o0e,
  version: Sxe,
  zrUtil: Qye,
  zrender: ECe
}, Symbol.toStringTag, { value: "Module" }));
var Oc = {}, Kl = {}, RY = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = void 0;
  var t = 1, r = function() {
    return "".concat(t++);
  };
  e.default = r;
})(RY);
var Lw = {}, Fw = {}, QA = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = void 0;
  var t = function(n) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 60, o = null;
    return function() {
      for (var a = this, s = arguments.length, l = new Array(s), u = 0; u < s; u++)
        l[u] = arguments[u];
      clearTimeout(o), o = setTimeout(function() {
        n.apply(a, l);
      }, i);
    };
  };
  e.default = t;
})(QA);
var ds = {};
Object.defineProperty(ds, "__esModule", {
  value: !0
});
ds.SizeSensorId = ds.SensorTabIndex = ds.SensorClassName = void 0;
var cVe = "size-sensor-id";
ds.SizeSensorId = cVe;
var dVe = "size-sensor-object";
ds.SensorClassName = dVe;
var hVe = "-1";
ds.SensorTabIndex = hVe;
Object.defineProperty(Fw, "__esModule", {
  value: !0
});
Fw.createSensor = void 0;
var fVe = pVe(QA), pE = ds;
function pVe(e) {
  return e && e.__esModule ? e : { default: e };
}
var gVe = function(t, r) {
  var n = void 0, i = [], o = function() {
    getComputedStyle(t).position === "static" && (t.style.position = "relative");
    var d = document.createElement("object");
    return d.onload = function() {
      d.contentDocument.defaultView.addEventListener("resize", a), a();
    }, d.style.display = "block", d.style.position = "absolute", d.style.top = "0", d.style.left = "0", d.style.height = "100%", d.style.width = "100%", d.style.overflow = "hidden", d.style.pointerEvents = "none", d.style.zIndex = "-1", d.style.opacity = "0", d.setAttribute("class", pE.SensorClassName), d.setAttribute("tabindex", pE.SensorTabIndex), d.type = "text/html", t.appendChild(d), d.data = "about:blank", d;
  }, a = (0, fVe.default)(function() {
    i.forEach(function(c) {
      c(t);
    });
  }), s = function(d) {
    n || (n = o()), i.indexOf(d) === -1 && i.push(d);
  }, l = function() {
    n && n.parentNode && (n.contentDocument && n.contentDocument.defaultView.removeEventListener("resize", a), n.parentNode.removeChild(n), t.removeAttribute(pE.SizeSensorId), n = void 0, i = [], r && r());
  }, u = function(d) {
    var h = i.indexOf(d);
    h !== -1 && i.splice(h, 1), i.length === 0 && n && l();
  };
  return {
    element: t,
    bind: s,
    destroy: l,
    unbind: u
  };
};
Fw.createSensor = gVe;
var Nw = {};
Object.defineProperty(Nw, "__esModule", {
  value: !0
});
Nw.createSensor = void 0;
var vVe = ds, mVe = yVe(QA);
function yVe(e) {
  return e && e.__esModule ? e : { default: e };
}
var CVe = function(t, r) {
  var n = void 0, i = [], o = (0, mVe.default)(function() {
    i.forEach(function(c) {
      c(t);
    });
  }), a = function() {
    var d = new ResizeObserver(o);
    return d.observe(t), o(), d;
  }, s = function(d) {
    n || (n = a()), i.indexOf(d) === -1 && i.push(d);
  }, l = function() {
    n.disconnect(), i = [], n = void 0, t.removeAttribute(vVe.SizeSensorId), r && r();
  }, u = function(d) {
    var h = i.indexOf(d);
    h !== -1 && i.splice(h, 1), i.length === 0 && n && l();
  };
  return {
    element: t,
    bind: s,
    destroy: l,
    unbind: u
  };
};
Nw.createSensor = CVe;
Object.defineProperty(Lw, "__esModule", {
  value: !0
});
Lw.createSensor = void 0;
var SVe = Fw, wVe = Nw, bVe = typeof ResizeObserver < "u" ? wVe.createSensor : SVe.createSensor;
Lw.createSensor = bVe;
Object.defineProperty(Kl, "__esModule", {
  value: !0
});
Kl.removeSensor = Kl.getSensor = Kl.Sensors = void 0;
var xVe = RVe(RY), EVe = Lw, ZT = ds;
function RVe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Oh = {};
Kl.Sensors = Oh;
function _Y(e) {
  e && Oh[e] && delete Oh[e];
}
var _Ve = function(t) {
  var r = t.getAttribute(ZT.SizeSensorId);
  if (r && Oh[r])
    return Oh[r];
  var n = (0, xVe.default)();
  t.setAttribute(ZT.SizeSensorId, n);
  var i = (0, EVe.createSensor)(t, function() {
    return _Y(n);
  });
  return Oh[n] = i, i;
};
Kl.getSensor = _Ve;
var TVe = function(t) {
  var r = t.element.getAttribute(ZT.SizeSensorId);
  t.destroy(), _Y(r);
};
Kl.removeSensor = TVe;
Object.defineProperty(Oc, "__esModule", {
  value: !0
});
Oc.ver = PY = Oc.clear = TY = Oc.bind = void 0;
var QT = Kl, PVe = function(t, r) {
  var n = (0, QT.getSensor)(t);
  return n.bind(r), function() {
    n.unbind(r);
  };
}, TY = Oc.bind = PVe, MVe = function(t) {
  var r = (0, QT.getSensor)(t);
  (0, QT.removeSensor)(r);
}, PY = Oc.clear = MVe, DVe = "1.0.2";
Oc.ver = DVe;
function DH(e, t) {
  var r = {};
  return t.forEach(function(n) {
    r[n] = e[n];
  }), r;
}
function gE(e) {
  return typeof e == "function";
}
function AVe(e) {
  return typeof e == "string";
}
var IVe = function e(t, r) {
  if (t === r) return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor) return !1;
    var n, i, o;
    if (Array.isArray(t)) {
      if (n = t.length, n != r.length) return !1;
      for (i = n; i-- !== 0; )
        if (!e(t[i], r[i])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
    if (o = Object.keys(t), n = o.length, n !== Object.keys(r).length) return !1;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, o[i])) return !1;
    for (i = n; i-- !== 0; ) {
      var a = o[i];
      if (!e(t[a], r[a])) return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
};
const Jd = /* @__PURE__ */ of(IVe);
var OVe = (
  /** @class */
  function(e) {
    R6(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.echarts = r.echarts, n.ele = null, n.isInitialResize = !0, n;
    }
    return t.prototype.componentDidMount = function() {
      this.renderNewEcharts();
    }, t.prototype.componentDidUpdate = function(r) {
      var n = this.props.shouldSetOption;
      if (!(gE(n) && !n(r, this.props))) {
        if (!Jd(r.theme, this.props.theme) || !Jd(r.opts, this.props.opts) || !Jd(r.onEvents, this.props.onEvents)) {
          this.dispose(), this.renderNewEcharts();
          return;
        }
        var i = ["option", "notMerge", "lazyUpdate", "showLoading", "loadingOption"];
        Jd(DH(this.props, i), DH(r, i)) || this.updateEChartsOption(), (!Jd(r.style, this.props.style) || !Jd(r.className, this.props.className)) && this.resize();
      }
    }, t.prototype.componentWillUnmount = function() {
      this.dispose();
    }, t.prototype.getEchartsInstance = function() {
      return this.echarts.getInstanceByDom(this.ele) || this.echarts.init(this.ele, this.props.theme, this.props.opts);
    }, t.prototype.dispose = function() {
      if (this.ele) {
        try {
          PY(this.ele);
        } catch (r) {
          console.warn(r);
        }
        this.echarts.dispose(this.ele);
      }
    }, t.prototype.renderNewEcharts = function() {
      var r = this, n = this.props, i = n.onEvents, o = n.onChartReady, a = this.updateEChartsOption();
      this.bindEvents(a, i || {}), gE(o) && o(a), this.ele && TY(this.ele, function() {
        r.resize();
      });
    }, t.prototype.bindEvents = function(r, n) {
      function i(a, s) {
        AVe(a) && gE(s) && r.on(a, function(l) {
          s(l, r);
        });
      }
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && i(o, n[o]);
    }, t.prototype.updateEChartsOption = function() {
      var r = this.props, n = r.option, i = r.notMerge, o = i === void 0 ? !1 : i, a = r.lazyUpdate, s = a === void 0 ? !1 : a, l = r.showLoading, u = r.loadingOption, c = u === void 0 ? null : u, d = this.getEchartsInstance();
      return d.setOption(n, o, s), l ? d.showLoading(c) : d.hideLoading(), d;
    }, t.prototype.resize = function() {
      var r = this.getEchartsInstance();
      if (!this.isInitialResize)
        try {
          r.resize();
        } catch (n) {
          console.warn(n);
        }
      this.isInitialResize = !1;
    }, t.prototype.render = function() {
      var r = this, n = this.props, i = n.style, o = n.className, a = o === void 0 ? "" : o, s = a_({ height: 300 }, i);
      return H.createElement("div", { ref: function(l) {
        r.ele = l;
      }, style: s, className: "echarts-for-react " + a });
    }, t;
  }($X)
), MY = (
  /** @class */
  function(e) {
    R6(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.echarts = uVe, n;
    }
    return t;
  }(OVe)
);
Yi.extend(V8);
function vE(e, t) {
  var s;
  const r = `Overall Conversion (${((s = t == null ? void 0 : t.conversion) == null ? void 0 : s.criteria) || "Uniques"})`;
  let n = `${e != null && e.cohort ? e != null && e.cohort_value ? `${e.cohort}` : `Not in ${e.cohort}` : (e == null ? void 0 : e.value) === "$all" ? r : e.value}`;
  const i = e != null && e.cohort ? e.cohort_value ? `${e.cohort}` : `Not in ${e.cohort}` : "", o = [...(e == null ? void 0 : e.dimensions) ?? []], a = o != null && o.length ? o.map((l) => `${l.name} is ${l.value}`).join(" & ") : "";
  return (i || a) && (n = `${i}${i && a ? ", " : ""}${a}`), { conversionCriteriaLabel: r, seriesNameToGroupBy: n };
}
const LVe = ({
  eventName: e,
  eventIndex: t,
  columnFields: r,
  funnelsConfiguration: n
}) => {
  var s, l, u, c;
  const i = "////", o = (n == null ? void 0 : n.steps) || [];
  if (r) {
    const d = /* @__PURE__ */ new Set(), h = {};
    return r.forEach((f, p) => {
      const g = o.findIndex(
        (v, m) => !d.has(m) && v.name === f
      );
      g !== -1 && (h[p] = o[g].label, d.add(g));
    }), (s = h[t]) == null ? void 0 : s.split(i)[0];
  }
  return ((l = o[t]) == null ? void 0 : l.name) === e && ((c = (u = o[t]) == null ? void 0 : u.label) == null ? void 0 : c.split(i)[0]) || e;
};
function FVe({
  chartData: e,
  queryConfiguration: t,
  themeColors: r,
  themeMode: n
}) {
  var s;
  const i = t.steps.map((l) => l.name).join(" -> "), o = e.reduce((l, u) => {
    var h;
    let { seriesNameToGroupBy: c, conversionCriteriaLabel: d } = vE(
      u,
      t
    );
    return c === "<nil>" && (c = d), [
      ...l,
      {
        data: [],
        type: "bar",
        zlevel: 1,
        emphasis: {
          focus: "series"
        },
        stack: `conversion_funnel_${c}_${u.value}`,
        name: c,
        label: u.dimension !== "$all" || (h = e[0]) != null && h.cohort ? {} : {
          show: !(u != null && u.dimensions),
          formatter: function({ data: f }) {
            const { conversionNumber: p, conversionPercentage: g } = f || {};
            return [
              `{percentage|${Number(g).toFixed(2)}%}`,
              `{number|${p}}`
            ].join(`
`);
          },
          position: "top",
          align: "center",
          rich: {
            percentage: {
              color: r["--secondary-text"],
              fontWeight: 600,
              lineHeight: 18,
              fontSize: 14
            },
            number: {
              color: r["--secondary-text"],
              fontWeight: 500,
              lineHeight: 14,
              fontSize: 11
            }
          }
        }
      },
      {
        name: c,
        data: [],
        type: "bar",
        stack: `conversion_funnel_${c}_${u.value}`,
        itemStyle: {
          color: "rgba(66,56,202, .1)"
        }
      }
    ];
  }, []), a = {
    grid: {
      left: 50,
      top: 95,
      right: 30,
      bottom: 30
    },
    title: {
      show: !0,
      text: `Funnels: ${i}`,
      left: 20,
      textStyle: {
        fontFamily: "HousewareFont",
        fontSize: 15,
        fontWeight: "bold",
        color: r["--primary-text"]
      }
    },
    xAxis: {
      type: "category",
      data: [],
      axisLabel: {
        interval: 0,
        width: 300,
        align: "center",
        overflow: "break",
        color: r["--secondary-text"],
        hideOverlap: !0,
        formatter: (l) => l.split("_").join(" "),
        fontFamily: "ChartsFont",
        fontSize: 10
      },
      axisLine: {
        lineStyle: {
          color: r["--border"]
        }
      }
    },
    yAxis: {
      type: "value",
      position: "left",
      alignTicks: !0,
      axisLine: {
        show: !0,
        lineStyle: {
          color: r["--border"]
        }
      },
      axisLabel: {
        color: r["--secondary-text"],
        fontFamily: "ChartsFont",
        fontSize: 10
      },
      splitLine: {
        lineStyle: {
          color: r["--border"],
          width: 0.4
        }
      },
      max: 100
    },
    series: o,
    legend: {
      data: o.map((l) => l.name),
      top: 40,
      left: 20,
      color: r["--secondary-text"],
      icon: "circle",
      textStyle: {
        color: r["--primary-text"],
        fontSize: 12,
        fontWeight: "normal",
        fontFamily: "HousewareFont"
      },
      inActiveColor: "red"
    },
    toolbox: {
      feature: {
        saveAsImage: {
          title: "Download chart",
          name: `Funnel Chart - ${i}`,
          show: !0,
          icon: `image://chart-download-${n}-mode.png`
        }
      }
    },
    tooltip: {
      trigger: "item",
      confine: !0,
      order: "valueDesc",
      backgroundColor: r["--foreground"],
      borderColor: r["--border"],
      textStyle: {
        color: r["--secondary-text"],
        fontFamily: "HousewareFont"
      },
      formatter: function({ data: l }) {
        const {
          conversionNumber: u,
          conversionPercentage: c,
          dropOffPercentage: d,
          dropOffNumber: h,
          name: f,
          seriesLabel: p,
          config: g
        } = l || {}, v = (Number(u || h) / Number(c || d) * 100).toLocaleString();
        let m = ` <b>${f}</b>`;
        return g.start_date && (m = `${m} (from ${Yi(g == null ? void 0 : g.start_date).format(
          "Do MMM YY"
        )}`), g.end_date && (m = `${m} to ${Yi(g == null ? void 0 : g.end_date).format(
          "Do MMM YY"
        )})`), `
          ${m}
          </br>
          <br />
          ${p}
          </br>
          ${Number(c).toFixed(
          2
        )}% (${u.toLocaleString()} of ${v}) converted
          </br>
          ${Number(d).toFixed(
          2
        )}% (${h.toLocaleString()} of ${v}) drop-off
          `;
      }
    }
  };
  for (let l = 0; l < e[0].steps.length; l++) {
    e.forEach((c, d) => {
      const h = c.steps[l], f = h.prev_step_conversion_percentage, p = l > 0 ? 100 - f : 0, g = l > 0 ? c.steps[l - 1].value - h.value : 0;
      a.series[2 * d].data.push({
        value: h.value / e[d].steps[0].value * 100,
        name: h.event_name,
        config: t,
        seriesLabel: vE(c, t).seriesNameToGroupBy,
        dimensions: c.dimensions,
        cohort: {
          cohort_uuid: c == null ? void 0 : c.cohort_uuid,
          cohort_value: c == null ? void 0 : c.cohort_value
        },
        conversionNumber: h.value,
        dropOffPercentage: p,
        dropOffNumber: g,
        conversionPercentage: f,
        seriesType: "converted",
        stepIndex: l
      }), a.series[2 * d + 1].data.push({
        value: g / e[d].steps[0].value * 100,
        name: h.event_name,
        config: t,
        seriesLabel: vE(c, t).seriesNameToGroupBy,
        dimensions: c.dimensions,
        dropOffNumber: g,
        dropOffPercentage: p,
        conversionNumber: h.value,
        conversionPercentage: f,
        seriesType: "dropped off",
        stepIndex: l
      });
    });
    const u = LVe({
      eventName: e[0].steps[l].event_name,
      eventIndex: l,
      funnelsConfiguration: t
    });
    (s = a == null ? void 0 : a.xAxis) == null || s.data.push(u);
  }
  return a;
}
function NVe({
  chartResponse: e,
  queryConfiguration: t
}) {
  const { themeColors: r, currentTheme: n } = Tv(), i = FVe({
    chartData: e == null ? void 0 : e.data,
    queryConfiguration: t,
    themeColors: r,
    themeMode: n
  });
  return /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      vertical: !0,
      gap: 16,
      style: {
        width: "100%"
      },
      children: [
        /* @__PURE__ */ ie.jsx(
          Ji,
          {
            size: "small",
            style: {
              backgroundColor: "var(--background)",
              width: "100%"
            },
            children: /* @__PURE__ */ ie.jsx(
              MY,
              {
                style: { height: "40vh", width: "100%" },
                option: i,
                theme: {
                  color: r["--chart-colors"]
                },
                notMerge: !0,
                opts: { renderer: "canvas" }
              }
            )
          }
        ),
        /* @__PURE__ */ ie.jsx(xr, { children: /* @__PURE__ */ ie.jsx(HS, { children: e.summary }) })
      ]
    }
  );
}
Yi.extend(V8);
function kVe({
  chartData: e,
  queryConfiguration: t,
  themeColors: r,
  themeMode: n
}) {
  var g, v;
  const i = t.events.map((m) => m.name).join(" , "), o = t == null ? void 0 : t.breakdown, a = o != null && o.dimension ? {
    name: o.dimension,
    is_event_property: o == null ? void 0 : o.is_event_property,
    type: "dimension"
  } : null, s = {};
  (g = t == null ? void 0 : t.events) == null || g.forEach((m) => {
    s[m.label] = m.measure || "uniques";
  });
  const l = {};
  e.map((m) => {
    l[m.period] = !0;
  });
  const u = Object.keys(l).sort((m, y) => Yi(m).valueOf() - Yi(y).valueOf()).reduce((m, y) => (m[y] = l[y], m), {}), c = {
    data: {},
    type: "line",
    smooth: !0,
    name: ""
  }, d = {};
  (a == null ? void 0 : a.name) === void 0 ? e.forEach((m) => {
    const [y] = typeof (m == null ? void 0 : m.label) == "string" ? m.label.split(":") : [], C = Number(m.measure), S = Number.isInteger(C) ? C : C.toFixed(2), b = m.period;
    if (d[y]) {
      const w = "";
      d[y].data[b] = {
        value: S,
        unit: w
      };
    } else {
      const w = `${y} (${m.label})`, x = "";
      d[y] = {
        ...c,
        lineStyle: {
          type: "solid"
        },
        name: w,
        data: {},
        yAxisIndex: 0,
        unit: x
      }, d[y].data[b] = {
        value: S,
        unit: x
      };
    }
  }) : e.forEach((m) => {
    const y = m.label, C = Number(m.measure), S = Number.isInteger(C) ? C : C.toFixed(2), b = m[a == null ? void 0 : a.name], w = `${y} / ${b}`, x = m.period;
    if (d[w]) {
      let R = "";
      d[w].data[x] = {
        value: S,
        unit: R,
        breakdown: {
          ...a,
          value: b
        }
      };
    } else {
      let R = "";
      const _ = `${w} (${s[y]})`;
      d[w] = {
        ...c,
        lineStyle: {
          type: "solid"
        },
        name: _,
        data: {},
        yAxisIndex: 0
      }, d[w].data[x] = {
        value: S,
        unit: R,
        breakdown: {
          ...a,
          value: a.type === "cohort" ? m.cohort : b
        }
      };
    }
  });
  for (const m in d) {
    const y = d[m], C = (v = Object.keys(u)) == null ? void 0 : v.map(
      (S) => y.data[S] || {
        value: 0,
        unit: "",
        ...y.originalSeriesName && {
          seriesLabel: y.originalSeriesName
        }
      }
    );
    d[m].data = C;
  }
  const h = Object.values(d), f = Object.keys(u);
  return {
    grid: {
      left: 50,
      top: 95,
      right: 30,
      bottom: 30
    },
    title: {
      show: !0,
      text: `Trends: ${i}`,
      left: 20,
      textStyle: {
        fontFamily: "HousewareFont",
        fontSize: 15,
        fontWeight: "bold",
        color: r["--primary-text"]
      }
    },
    xAxis: {
      type: "category",
      data: f,
      axisLabel: {
        width: 200,
        align: "center",
        overflow: "break",
        hideOverlap: !0,
        fontFamily: "ChartsFont",
        fontSize: 10,
        cursor: "pointer",
        color: r["--secondary-text"],
        formatter: (m) => {
          var C;
          return AH(
            m,
            (C = t == null ? void 0 : t.time) == null ? void 0 : C.granularity,
            !1
          );
        }
      },
      axisLine: {
        lineStyle: {
          color: r["--border"]
        }
      }
    },
    yAxis: [
      {
        name: "",
        type: "value",
        position: "left",
        alignTicks: !0,
        nameTextStyle: {
          fontWeight: "bolder"
        },
        axisLine: {
          show: !0,
          lineStyle: {
            color: r["--border"]
          }
        },
        axisLabel: {
          hideOverlap: !0,
          color: r["--secondary-text"],
          fontFamily: "ChartsFont",
          fontSize: 10
        },
        splitLine: {
          lineStyle: {
            color: r["--border"],
            width: 0.4
          }
        }
      }
    ],
    legend: {
      data: h.map((m) => m.name),
      top: 40,
      left: 20,
      color: r["--primary-text"],
      icon: "circle",
      textStyle: {
        color: r["--secondary-text"],
        fontFamily: "HousewareFont",
        fontSize: 12,
        fontWeight: "normal"
      }
    },
    toolbox: {
      feature: {
        saveAsImage: {
          title: "Download chart",
          name: `Trends Chart - ${i}`,
          show: !0,
          icon: `image://chart-download-${n}-mode.png`
        }
      }
    },
    series: [...h],
    tooltip: {
      trigger: "axis",
      confine: !0,
      order: "valueDesc",
      backgroundColor: r["--foreground"],
      borderColor: r["--border"],
      textStyle: {
        color: r["--secondary-text"],
        fontFamily: "HousewareFont"
      },
      formatter: (m) => {
        var S;
        let y = "<div>";
        y += `<div><strong>${VVe(
          m[0].name,
          (S = t == null ? void 0 : t.time) == null ? void 0 : S.granularity
        )}</strong></div><br />`;
        const C = m.filter(
          (b, w, x) => w === x.findIndex(
            (R) => {
              var _, T;
              return R.seriesName === b.seriesName && R.value === b.value && ((_ = R.data) == null ? void 0 : _.period) === ((T = b.data) == null ? void 0 : T.period);
            }
          )
        );
        return y += C.map(
          (b) => {
            var w, x, R;
            return `<div style="display:flex; align-items:center"><div style="height:1rem; width:1rem; border-radius:.5rem; background:${b.color}"></div> &nbsp;${(w = b.data) != null && w.prevPeriod ? `(${AH(
              b.data.prevPeriod,
              ((x = t == null ? void 0 : t.time) == null ? void 0 : x.granularity) === "hour" ? "day" : (R = t == null ? void 0 : t.time) == null ? void 0 : R.granularity,
              !1
            )}):  ${b.data.seriesLabel}` : b.seriesName}:  &nbsp; &nbsp; &nbsp;<strong>${Number(b.value)}${b.data.unit ? b.data.unit : ""}</strong></div>`;
          }
        ).join(""), y += "</div>", y;
      }
    },
    axisPointer: {
      type: "line"
    }
  };
}
const zp = {
  hour: "h:mm A, Do MMM",
  day: "Do MMM",
  week: "Do MMM YYYY",
  month: "MMM YYYY",
  quarter: "[Q]Q-Y",
  year: "YYYY",
  all_time: ""
};
function AH(e, t, r = !0) {
  return t === "week" ? `${Yi(e).format(
    zp[t]
  )} - ${Yi(e).add(6, "day").format(zp[t])}` : r ? Yi(e).format(zp[t]).replace(/ /g, `
`) : Yi(e).format(zp[t]);
}
function VVe(e, t) {
  return t === "week" ? `${Yi(e).format("[Week] WW, Do MMM YYYY")} - ${Yi(e).add(6, "day").format("Do MMM YYYY")}` : t === "day" ? Yi(e).format("Do MMM YYYY") : Yi(e).format(zp[t]);
}
function BVe({
  chartResponse: e,
  queryConfiguration: t
}) {
  const { themeColors: r, currentTheme: n } = Tv(), i = kVe({
    chartData: (e == null ? void 0 : e.data) ?? [],
    queryConfiguration: t ?? {},
    themeColors: r,
    themeMode: n
  });
  return /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      vertical: !0,
      gap: 16,
      style: {
        width: "100%"
      },
      children: [
        /* @__PURE__ */ ie.jsx(
          Ji,
          {
            size: "small",
            style: {
              backgroundColor: "var(--background)",
              width: "100%"
            },
            children: /* @__PURE__ */ ie.jsx(
              MY,
              {
                style: { height: "40vh", width: "100%" },
                option: i,
                theme: {
                  color: r["--chart-colors"]
                },
                notMerge: !0,
                opts: { renderer: "canvas" }
              }
            )
          }
        ),
        /* @__PURE__ */ ie.jsx(xr, { children: /* @__PURE__ */ ie.jsx(HS, { children: e.summary }) })
      ]
    }
  );
}
function $Ve({
  index: e,
  messages: t,
  handleRegenerateResponse: r,
  hideActionCardItems: n = [],
  customMessageActionCardItem: i = []
}) {
  var c;
  const o = (c = t[e]) == null ? void 0 : c.content, [a, s] = Me(!1), l = () => {
    const d = (() => {
      var p, g, v;
      const h = (p = o == null ? void 0 : o.query_response) == null ? void 0 : p.type, f = (g = o == null ? void 0 : o.query_response) == null ? void 0 : g.data;
      switch (h) {
        case "text":
          return f;
        case "trend":
        case "funnel":
          return ((v = o == null ? void 0 : o.query_response) == null ? void 0 : v.summary) || "";
        default:
          return "I am not sure how to respond to that, can you please try again?";
      }
    })();
    navigator.clipboard.writeText(d), s(!0), setTimeout(() => {
      s(!1);
    }, 2e3);
  }, u = Et(
    () => ({
      copy: /* @__PURE__ */ ie.jsx(
        jn,
        {
          size: "small",
          onClick: l,
          type: "text",
          icon: a ? /* @__PURE__ */ ie.jsx(EG, { size: "0.7rem" }) : /* @__PURE__ */ ie.jsx(RG, { size: "0.7rem" }),
          style: {
            fontSize: "0.7rem",
            color: "var(--secondary-text)"
          },
          children: "Copy"
        }
      ),
      regenerate: /* @__PURE__ */ ie.jsx(
        jn,
        {
          size: "small",
          onClick: () => {
            var d;
            r(
              ((d = t[t.length - 2]) == null ? void 0 : d.content) || "",
              !0
            );
          },
          type: "text",
          icon: /* @__PURE__ */ ie.jsx(xG, { size: "0.7rem" }),
          style: {
            fontSize: "0.7rem",
            color: "var(--secondary-text)"
          },
          children: "Regenerate"
        }
      )
    }),
    [a, r, t]
  );
  return /* @__PURE__ */ ie.jsx(
    Ji,
    {
      className: "ai-message-actions",
      size: "small",
      style: {
        width: "max-content",
        backgroundColor: "var(--background)",
        alignSelf: "flex-end"
      },
      styles: {
        body: {
          padding: 3
        }
      },
      children: /* @__PURE__ */ ie.jsxs(Zt, { children: [
        Object.keys(u).map(
          (d) => !n.includes(d) && /* @__PURE__ */ ie.jsx(HX, { children: u[d] }, d)
        ),
        i
      ] })
    }
  );
}
function HVe({
  index: e,
  messages: t,
  showMessageActionCard: r,
  hideActionCardItems: n = [],
  handleRegenerateResponse: i,
  customMessageComponent: o,
  customMessageActionCardItem: a
}) {
  var f;
  const s = (f = t[e]) == null ? void 0 : f.content, u = (t == null ? void 0 : t.length) - 1 === e && r, c = o == null ? void 0 : o.component, d = ({
    messages: p,
    index: g,
    handleRegenerateResponse: v
  }) => c ? /* @__PURE__ */ ie.jsx(
    c,
    {
      messages: p,
      index: g,
      handleSendFollowupMessage: v
    }
  ) : null, h = () => {
    var m, y;
    const p = ((m = s == null ? void 0 : s.query_response) == null ? void 0 : m.type) || (s == null ? void 0 : s.type), g = ((y = s == null ? void 0 : s.query_response) == null ? void 0 : y.data) || (s == null ? void 0 : s.data), v = s == null ? void 0 : s.query_configuration;
    switch (p) {
      case "text":
        return /* @__PURE__ */ ie.jsx(xr, { children: /* @__PURE__ */ ie.jsx(HS, { children: g }) });
      case "trend":
        return /* @__PURE__ */ ie.jsx(
          BVe,
          {
            chartResponse: s.query_response,
            queryConfiguration: v
          }
        );
      case "funnel":
        return /* @__PURE__ */ ie.jsx(
          NVe,
          {
            chartResponse: s.query_response,
            queryConfiguration: v
          }
        );
      default:
        return /* @__PURE__ */ ie.jsx(xr, { children: "I am not sure how to respond to that, can you please try again?" });
    }
  };
  debugger;
  return /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      style: { width: "90%" },
      align: "flex-start",
      gap: 8,
      className: "ai-message-wrapper",
      children: [
        /* @__PURE__ */ ie.jsx(
          _v,
          {
            src: "/ai-icon.svg",
            height: 40,
            width: 40,
            style: {
              height: "2rem",
              width: "2rem"
            },
            preview: !1
          }
        ),
        /* @__PURE__ */ ie.jsxs(
          Zt,
          {
            vertical: !0,
            style: {
              width: "100%"
            },
            gap: 14,
            children: [
              c ? d({
                messages: t,
                index: e,
                handleRegenerateResponse: i
              }) : h(),
              u && /* @__PURE__ */ ie.jsx(
                $Ve,
                {
                  index: e,
                  messages: t,
                  hideActionCardItems: n,
                  handleRegenerateResponse: i,
                  customMessageActionCardItem: a
                },
                e
              )
            ]
          }
        )
      ]
    }
  );
}
function GVe({
  messages: e,
  index: t,
  customMessageComponent: r
}) {
  var o;
  const n = r == null ? void 0 : r.component, i = ({
    messages: a,
    index: s
  }) => n ? /* @__PURE__ */ ie.jsx(n, { messages: a, index: s }) : null;
  return /* @__PURE__ */ ie.jsx(Zt, { style: { width: "100%" }, justify: "flex-end", gap: 12, children: /* @__PURE__ */ ie.jsx(
    Zt,
    {
      vertical: !0,
      style: {
        minWidth: "30%"
      },
      gap: 2,
      align: "flex-end",
      children: /* @__PURE__ */ ie.jsx(
        Ji,
        {
          size: "small",
          style: {
            borderTopRightRadius: 0
          },
          children: n ? i({
            messages: e,
            index: t
          }) : /* @__PURE__ */ ie.jsx(xr, { children: (o = e[t]) == null ? void 0 : o.content })
        }
      )
    }
  ) });
}
function z7e({
  messages: e,
  handleSendFollowupMessage: t,
  isMessageLoading: r,
  setMessages: n,
  showMessageActionCard: i = !0,
  hideActionCardItems: o = [],
  customMessageComponent: a,
  customMessageActionCardItem: s
}) {
  const [l, u] = Me(""), c = se(null);
  Nt(() => {
    const h = c.current;
    h && (h.scrollTop = h.scrollHeight);
  }, [e]);
  const d = e.length > 1 && r || e.length === 1;
  return /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      style: {
        height: "100vh",
        width: "100vw",
        padding: 16,
        overflow: "hidden"
      },
      vertical: !0,
      align: "center",
      justify: "flex-start",
      children: [
        /* @__PURE__ */ ie.jsx(
          LS,
          {
            title: "You'll lose your current chat history.",
            description: "Are you sure you want to start a new chat?",
            placement: "bottomLeft",
            okText: "Yes",
            cancelText: "No",
            onConfirm: () => {
              n([]);
            },
            children: /* @__PURE__ */ ie.jsx(
              jn,
              {
                type: "primary",
                style: {
                  position: "absolute",
                  top: 16,
                  right: 32
                },
                children: "Start new chat"
              }
            )
          }
        ),
        /* @__PURE__ */ ie.jsxs(
          Zt,
          {
            ref: c,
            vertical: !0,
            style: {
              width: "58vw",
              height: "86vh",
              overflowY: "scroll",
              overflowX: "hidden",
              padding: "0 24px 10vh",
              marginTop: "4vh",
              position: "relative"
            },
            align: "flex-start",
            rootClassName: "chat-container",
            gap: 48,
            children: [
              e.filter(Boolean).map((h, f) => h.type === "ai" ? /* @__PURE__ */ ie.jsx(
                HVe,
                {
                  index: f,
                  messages: e,
                  hideActionCardItems: o,
                  showMessageActionCard: i,
                  customMessageComponent: (a == null ? void 0 : a.type) === h.type ? a : void 0,
                  handleRegenerateResponse: t,
                  customMessageActionCardItem: s
                },
                f
              ) : /* @__PURE__ */ ie.jsx(
                GVe,
                {
                  index: f,
                  messages: e,
                  customMessageComponent: (a == null ? void 0 : a.type) === h.type ? a : void 0
                },
                f
              )),
              d && /* @__PURE__ */ ie.jsx(lpe, {})
            ]
          }
        ),
        /* @__PURE__ */ ie.jsx(
          k3,
          {
            inputRef: null,
            userQuery: l,
            setUserQuery: u,
            handleSendMessage: () => {
              t(l), u("");
            },
            placeholder: "Follow up with your question here...",
            isFollowupDisabled: d
          }
        )
      ]
    }
  );
}
const IH = ({
  maxCount: e,
  data: t
}) => /* @__PURE__ */ ie.jsx(
  Zt,
  {
    style: {
      width: "100%",
      marginTop: -4
    },
    justify: "flex-end",
    children: /* @__PURE__ */ ie.jsxs(
      xr.Text,
      {
        type: "secondary",
        style: {
          fontSize: "0.7rem"
        },
        children: [
          t.length,
          " / ",
          e
        ]
      }
    )
  }
);
function W7e({
  messages: e,
  setMessages: t,
  pageHeading: r,
  forecast: n,
  keywords: i,
  headings: o,
  descriptions: a,
  finalURL: s,
  displayLink: l
}) {
  const u = se(null), [c, d] = Me(o), [h, f] = Me(a);
  return Nt(() => {
    const p = u.current;
    p && (p.scrollTop = p.scrollHeight);
  }, [e]), /* @__PURE__ */ ie.jsx(
    Zt,
    {
      style: {
        width: "100vw",
        height: "100vh"
      },
      align: "center",
      justify: "center",
      children: /* @__PURE__ */ ie.jsxs(
        Zt,
        {
          style: {
            height: "100%",
            width: "50vw",
            padding: 16,
            overflow: "hidden"
          },
          vertical: !0,
          align: "center",
          justify: "flex-start",
          gap: 24,
          children: [
            /* @__PURE__ */ ie.jsx(
              xr.Title,
              {
                level: 3,
                style: {
                  width: "30vw",
                  textAlign: "center",
                  fontFamily: "Sedan"
                },
                children: r
              }
            ),
            /* @__PURE__ */ ie.jsx(
              Ji,
              {
                size: "small",
                style: {
                  width: "100%"
                },
                styles: {
                  body: {
                    padding: "16px 24px 4px"
                  }
                },
                children: /* @__PURE__ */ ie.jsxs(Zt, { vertical: !0, gap: 12, children: [
                  /* @__PURE__ */ ie.jsx(
                    G0,
                    {
                      layout: "vertical",
                      column: 6,
                      size: "small",
                      colon: !1,
                      contentStyle: {
                        fontSize: "1.5rem"
                      },
                      title: /* @__PURE__ */ ie.jsxs(xr.Title, { level: 5, children: [
                        "Forecast for ",
                        n.dateRange
                      ] }),
                      items: [
                        {
                          label: "Clicks",
                          children: n.clicks
                        },
                        {
                          label: "Impressions",
                          children: n.impressions
                        },
                        {
                          label: "Cost",
                          children: n.cost
                        },
                        {
                          label: "Avg CPC",
                          children: n.avgCPC
                        },
                        {
                          label: "Daily Budget",
                          children: n.dailyBudget
                        },
                        {
                          label: "CTR",
                          children: n.ctr
                        }
                      ]
                    }
                  ),
                  /* @__PURE__ */ ie.jsx(
                    G0,
                    {
                      colon: !1,
                      size: "small",
                      items: [
                        {
                          label: "Location",
                          children: n.location
                        },
                        {
                          label: "Language",
                          children: n.language
                        }
                      ]
                    }
                  )
                ] })
              }
            ),
            /* @__PURE__ */ ie.jsxs(
              Zt,
              {
                vertical: !0,
                align: "flex-start",
                style: {
                  width: "100%",
                  height: "100%",
                  overflow: "hidden"
                },
                gap: 4,
                children: [
                  /* @__PURE__ */ ie.jsx(xr.Text, { type: "secondary", children: "Your Ad Group" }),
                  /* @__PURE__ */ ie.jsx(
                    Ji,
                    {
                      style: {
                        width: "100%"
                      },
                      children: /* @__PURE__ */ ie.jsxs(Zt, { vertical: !0, gap: 12, children: [
                        /* @__PURE__ */ ie.jsxs(
                          Zt,
                          {
                            style: {
                              width: "100%"
                            },
                            justify: "space-between",
                            children: [
                              /* @__PURE__ */ ie.jsx(xr.Title, { level: 5, children: "Ad Group 1" }),
                              /* @__PURE__ */ ie.jsxs(Zt, { gap: 8, children: [
                                /* @__PURE__ */ ie.jsx(M3, { type: "circle", percent: 75, size: 20 }),
                                /* @__PURE__ */ ie.jsx(xr.Text, { children: "Ad Strength" })
                              ] })
                            ]
                          }
                        ),
                        /* @__PURE__ */ ie.jsx(Zt, { children: i.map((p) => /* @__PURE__ */ ie.jsx(NS, { children: p }, p)) }),
                        /* @__PURE__ */ ie.jsx(
                          t3,
                          {
                            style: {
                              margin: 0
                            }
                          }
                        ),
                        /* @__PURE__ */ ie.jsxs(Zt, { vertical: !0, gap: 8, children: [
                          /* @__PURE__ */ ie.jsx(xr.Text, { children: "Final URL" }),
                          /* @__PURE__ */ ie.jsx(
                            eu,
                            {
                              defaultValue: s,
                              style: {
                                width: "100%"
                              }
                            }
                          )
                        ] }),
                        /* @__PURE__ */ ie.jsxs(Zt, { vertical: !0, gap: 8, children: [
                          /* @__PURE__ */ ie.jsx(xr.Text, { children: "Display Link" }),
                          /* @__PURE__ */ ie.jsx(
                            eu,
                            {
                              defaultValue: l,
                              style: {
                                width: "100%"
                              }
                            }
                          )
                        ] }),
                        /* @__PURE__ */ ie.jsxs(Zt, { vertical: !0, gap: 8, children: [
                          /* @__PURE__ */ ie.jsx(xr.Text, { children: "Headlines" }),
                          /* @__PURE__ */ ie.jsx(
                            Jl,
                            {
                              mode: "tags",
                              maxCount: 15,
                              style: { width: "100%" },
                              value: c,
                              onChange: d,
                              suffixIcon: /* @__PURE__ */ ie.jsx(HE, {}),
                              placeholder: "Choose your headlines",
                              options: o.map((p) => ({
                                label: p,
                                value: p
                              }))
                            }
                          ),
                          /* @__PURE__ */ ie.jsx(IH, { maxCount: 15, data: c })
                        ] }),
                        /* @__PURE__ */ ie.jsxs(Zt, { vertical: !0, gap: 8, children: [
                          /* @__PURE__ */ ie.jsx(xr.Text, { children: "Descriptions" }),
                          /* @__PURE__ */ ie.jsx(
                            Jl,
                            {
                              mode: "tags",
                              maxCount: 4,
                              value: h,
                              onChange: f,
                              suffixIcon: /* @__PURE__ */ ie.jsx(HE, {}),
                              style: { width: "100%" },
                              placeholder: "Choose your descriptions",
                              options: a.map((p) => ({
                                label: p,
                                value: p
                              }))
                            }
                          ),
                          /* @__PURE__ */ ie.jsx(IH, { maxCount: 4, data: h })
                        ] })
                      ] })
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ ie.jsx(
              Zt,
              {
                justify: "flex-end",
                style: {
                  width: "100%"
                },
                children: /* @__PURE__ */ ie.jsx(jn, { type: "primary", children: "Create Campaign" })
              }
            ),
            /* @__PURE__ */ ie.jsx(
              LS,
              {
                title: "You'll lose your current chat history.",
                description: "Are you sure you want to start a new chat?",
                placement: "bottomLeft",
                okText: "Yes",
                cancelText: "No",
                onConfirm: () => {
                  t([]);
                },
                children: /* @__PURE__ */ ie.jsx(
                  jn,
                  {
                    type: "primary",
                    style: {
                      position: "absolute",
                      top: 16,
                      right: 32
                    },
                    children: "Start fresh"
                  }
                )
              }
            )
          ]
        }
      )
    }
  );
}
var Af = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
  }
  setFrameworkOverrides(e) {
    this.frameworkOverrides = e;
  }
  getListeners(e, t, r) {
    const n = t ? this.allAsyncListeners : this.allSyncListeners;
    let i = n.get(e);
    return !i && r && (i = /* @__PURE__ */ new Set(), n.set(e, i)), i;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(e, t, r = !1) {
    this.getListeners(e, r, !0).add(t);
  }
  removeEventListener(e, t, r = !1) {
    const n = this.getListeners(e, r, !1);
    n && (n.delete(t), n.size === 0 && (r ? this.allAsyncListeners : this.allSyncListeners).delete(e));
  }
  addGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e);
  }
  removeGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e);
  }
  dispatchEvent(e) {
    const t = e;
    this.dispatchToListeners(t, !0), this.dispatchToListeners(t, !1), this.firedEvents[t.type] = !0;
  }
  dispatchEventOnce(e) {
    this.firedEvents[e.type] || this.dispatchEvent(e);
  }
  dispatchToListeners(e, t) {
    const r = e.type;
    if (t && "event" in e) {
      const s = e.event;
      s instanceof Event && (e.eventPath = s.composedPath());
    }
    const n = (s, l) => s.forEach((u) => {
      if (!l.has(u))
        return;
      const c = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => u(e)) : () => u(e);
      t ? this.dispatchAsync(c) : c();
    }), i = this.getListeners(r, t, !1) ?? /* @__PURE__ */ new Set(), o = new Set(i);
    o.size > 0 && n(o, i), new Set(
      t ? this.globalAsyncListeners : this.globalSyncListeners
    ).forEach((s) => {
      const l = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => s(r, e)) : () => s(r, e);
      t ? this.dispatchAsync(l) : l();
    });
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(e) {
    if (this.asyncFunctionsQueue.push(e), !this.scheduled) {
      const t = () => {
        window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      };
      this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(t) : t(), this.scheduled = !0;
    }
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = !1;
    const e = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [], e.forEach((t) => t());
  }
};
function gr(e) {
  if (!(!e || !e.length))
    return e[e.length - 1];
}
function fd(e, t, r) {
  return e == null && t == null ? !0 : e != null && t != null && e.length === t.length && e.every((n, i) => r ? r(n, t[i]) : t[i] === n);
}
function zVe(e) {
  return e.sort((t, r) => t - r);
}
function DY(e, t) {
  const r = e.indexOf(t);
  r >= 0 && (e[r] = e[e.length - 1], e.pop());
}
function _i(e, t) {
  const r = e.indexOf(t);
  r >= 0 && e.splice(r, 1);
}
function WVe(e, t) {
  for (let r = 0; r < t.length; r++)
    DY(e, t[r]);
}
function jVe(e, t) {
  for (let r = 0; r < t.length; r++)
    _i(e, t[r]);
}
function QC(e, t, r) {
  e.splice(r, 0, t);
}
function AY(e, t, r) {
  jVe(e, t), t.slice().reverse().forEach((n) => QC(e, n, r));
}
function Lc(e, t) {
  return e.indexOf(t) > -1;
}
function UVe(e) {
  return [].concat.apply([], e);
}
function OH(e, t) {
  t == null || e == null || t.forEach((r) => e.push(r));
}
var IY = "__ag_Grid_Stop_Propagation", KVe = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"], mE = {};
function ef(e) {
  e[IY] = !0;
}
function Yl(e) {
  return e[IY] === !0;
}
var OY = /* @__PURE__ */ (() => {
  const e = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  return (r) => {
    if (typeof mE[r] == "boolean")
      return mE[r];
    const n = document.createElement(e[r] || "div");
    return r = "on" + r, mE[r] = r in n;
  };
})();
function JT(e, t, r) {
  let n = t;
  for (; n; ) {
    const i = e.getDomData(n, r);
    if (i)
      return i;
    n = n.parentElement;
  }
  return null;
}
function YVe(e, t) {
  return !t || !e ? !1 : XVe(t).indexOf(e) >= 0;
}
function qVe(e) {
  const t = [];
  let r = e.target;
  for (; r; )
    t.push(r), r = r.parentElement;
  return t;
}
function XVe(e) {
  const t = e;
  return t.path ? t.path : t.composedPath ? t.composedPath() : qVe(t);
}
function ZVe(e, t, r, n) {
  const o = Lc(KVe, r) ? { passive: !0 } : void 0;
  e && e.addEventListener && e.addEventListener(t, r, n, o);
}
var Se = class {
  constructor() {
    this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.propertyListenerId = 0, this.lastChangeSetIdLookup = {}, this.isAlive = () => !this.destroyed;
  }
  preWireBeans(e) {
    this.gridId = e.context.getGridId(), this.frameworkOverrides = e.frameworkOverrides, this.stubContext = e.context, this.eventService = e.eventService, this.gos = e.gos, this.localeService = e.localeService;
  }
  // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
  // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
  // points to a bean or component that was not properly disposed of.
  // constructor() {
  //     setTimeout(()=> {
  //         if (this.isAlive()) {
  //             let prototype: any = Object.getPrototypeOf(this);
  //             const constructor: any = prototype.constructor;
  //             const constructorString = constructor.toString();
  //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
  //             console.log('is alive ' + beanName);
  //         }
  //     }, 5000);
  // }
  // CellComp and GridComp and override this because they get the FrameworkOverrides from the Beans bean
  getFrameworkOverrides() {
    return this.frameworkOverrides;
  }
  destroy() {
    for (let e = 0; e < this.destroyFunctions.length; e++)
      this.destroyFunctions[e]();
    this.destroyFunctions.length = 0, this.destroyed = !0, this.dispatchLocalEvent({ type: "destroyed" });
  }
  // The typing of AgEventListener<any, any, any> is not ideal, but it's the best we can do at the moment to enable
  // eventService to have the best typing at the expense of BeanStub local events
  /** Add a local event listener against this BeanStub */
  addEventListener(e, t) {
    this.localEventService || (this.localEventService = new Af()), this.localEventService.addEventListener(e, t);
  }
  /** Remove a local event listener from this BeanStub */
  removeEventListener(e, t) {
    this.localEventService && this.localEventService.removeEventListener(e, t);
  }
  dispatchLocalEvent(e) {
    this.localEventService && this.localEventService.dispatchEvent(e);
  }
  addManagedElementListeners(e, t) {
    return this._setupListeners(e, t);
  }
  addManagedEventListeners(e) {
    return this._setupListeners(this.eventService, e);
  }
  addManagedListeners(e, t) {
    return this._setupListeners(e, t);
  }
  _setupListeners(e, t) {
    const r = [];
    for (const n in t) {
      const i = t[n];
      i && r.push(this._setupListener(e, n, i));
    }
    return r;
  }
  _setupListener(e, t, r) {
    if (this.destroyed)
      return () => null;
    e instanceof HTMLElement ? ZVe(this.getFrameworkOverrides(), e, t, r) : e.addEventListener(t, r);
    const n = () => (e.removeEventListener(t, r), null);
    return this.destroyFunctions.push(n), () => (n(), this.destroyFunctions = this.destroyFunctions.filter((i) => i !== n), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * However, stores the destroy function in the beanStub so that if this bean
   * is a component the destroy function will be called when the component is destroyed
   * as opposed to being cleaned up only when the GridOptionsService is destroyed.
   */
  setupGridOptionListener(e, t) {
    this.gos.addPropertyEventListener(e, t);
    const r = () => (this.gos.removePropertyEventListener(e, t), null);
    return this.destroyFunctions.push(r), () => (r(), this.destroyFunctions = this.destroyFunctions.filter((n) => n !== r), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */
  addManagedPropertyListener(e, t) {
    return this.destroyed ? () => null : this.setupGridOptionListener(e, t);
  }
  /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */
  addManagedPropertyListeners(e, t) {
    if (this.destroyed)
      return;
    const r = e.join("-") + this.propertyListenerId++, n = (i) => {
      if (i.changeSet) {
        if (i.changeSet && i.changeSet.id === this.lastChangeSetIdLookup[r])
          return;
        this.lastChangeSetIdLookup[r] = i.changeSet.id;
      }
      const o = {
        type: "gridPropertyChanged",
        changeSet: i.changeSet,
        source: i.source
      };
      t(o);
    };
    e.forEach((i) => this.setupGridOptionListener(i, n));
  }
  addDestroyFunc(e) {
    this.isAlive() ? this.destroyFunctions.push(e) : e();
  }
  createManagedBean(e, t) {
    const r = this.createBean(e, t);
    return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), r;
  }
  createBean(e, t, r) {
    return (t || this.stubContext).createBean(e, r);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e, t) {
    return (t || this.stubContext).destroyBean(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e, t) {
    return (t || this.stubContext).destroyBeans(e);
  }
}, JA = class {
  constructor(e) {
    this.frameworkOverrides = e, this.wrappedListeners = /* @__PURE__ */ new Map(), this.wrappedGlobalListeners = /* @__PURE__ */ new Map();
  }
  wrap(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (r) => {
      this.frameworkOverrides.wrapOutgoing(() => e(r));
    }, this.wrappedListeners.set(e, t)), t;
  }
  wrapGlobal(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (r, n) => {
      this.frameworkOverrides.wrapOutgoing(() => e(r, n));
    }, this.wrappedGlobalListeners.set(e, t)), t;
  }
  unwrap(e) {
    return this.wrappedListeners.get(e) ?? e;
  }
  unwrapGlobal(e) {
    return this.wrappedGlobalListeners.get(e) ?? e;
  }
};
function Fc(e) {
  return e == null || e === "" ? null : e;
}
function ke(e, t = !1) {
  return e != null && (e !== "" || t);
}
function dr(e) {
  return !ke(e);
}
function Wn(e) {
  return e == null || e.length === 0;
}
function eP(e) {
  return e != null && typeof e.toString == "function" ? e.toString() : null;
}
function Nc(e) {
  if (e === void 0)
    return;
  if (e === null || e === "")
    return null;
  if (typeof e == "number")
    return isNaN(e) ? void 0 : e;
  const t = parseInt(e, 10);
  return isNaN(t) ? void 0 : t;
}
function tP(e) {
  if (e !== void 0)
    return e === null || e === "" ? !1 : rP(e);
}
function rP(e) {
  return typeof e == "boolean" ? e : typeof e == "string" ? e.toUpperCase() === "TRUE" || e == "" : !1;
}
function JC(e, t) {
  const r = e ? JSON.stringify(e) : null, n = t ? JSON.stringify(t) : null;
  return r === n;
}
function QVe(e, t, r = !1) {
  const n = e == null, i = t == null;
  if (e && e.toNumber && (e = e.toNumber()), t && t.toNumber && (t = t.toNumber()), n && i)
    return 0;
  if (n)
    return -1;
  if (i)
    return 1;
  function o(a, s) {
    return a > s ? 1 : a < s ? -1 : 0;
  }
  if (typeof e != "string" || !r)
    return o(e, t);
  try {
    return e.localeCompare(t);
  } catch {
    return o(e, t);
  }
}
function w0(e) {
  if (e instanceof Set || e instanceof Map) {
    const t = [];
    return e.forEach((r) => t.push(r)), t;
  }
  return Object.values(e);
}
var eI = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function wa(e, t) {
  if (e != null) {
    if (Array.isArray(e)) {
      for (let r = 0; r < e.length; r++)
        t(r.toString(), e[r]);
      return;
    }
    for (const [r, n] of Object.entries(e))
      t(r, n);
  }
}
function LY(e) {
  const t = {}, r = Object.keys(e);
  for (let n = 0; n < r.length; n++) {
    if (eI.has(r[n]))
      continue;
    const i = r[n], o = e[i];
    t[i] = o;
  }
  return t;
}
function nP(e, t) {
  if (!e)
    return;
  const r = e, n = {};
  return Object.keys(r).forEach((i) => {
    if (t && t.indexOf(i) >= 0 || eI.has(i))
      return;
    const o = r[i];
    oP(o) && o.constructor === Object ? n[i] = nP(o) : n[i] = o;
  }), n;
}
function iP(e) {
  if (!e)
    return [];
  const t = Object;
  if (typeof t.values == "function")
    return t.values(e);
  const r = [];
  for (const n in e)
    e.hasOwnProperty(n) && e.propertyIsEnumerable(n) && r.push(e[n]);
  return r;
}
function jo(e, t, r = !0, n = !1) {
  ke(t) && wa(t, (i, o) => {
    if (eI.has(i))
      return;
    let a = e[i];
    a !== o && (n && a == null && o != null && typeof o == "object" && o.constructor === Object && (a = {}, e[i] = a), oP(o) && oP(a) && !Array.isArray(a) ? jo(a, o, r, n) : (r || o !== void 0) && (e[i] = o));
  });
}
function mg(e, t, r) {
  if (!t || !e)
    return;
  if (!r)
    return e[t];
  const n = t.split(".");
  let i = e;
  for (let o = 0; o < n.length; o++) {
    if (i == null)
      return;
    i = i[n[o]];
  }
  return i;
}
function oP(e) {
  return typeof e == "object" && e !== null;
}
var JVe = {
  resizable: !0,
  sortable: !0
}, eBe = 0;
function FY() {
  return eBe++;
}
function cu(e) {
  return e instanceof kY;
}
var NY = 20, kY = class extends Se {
  constructor(e, t, r, n) {
    super(), this.isColumn = !0, this.instanceId = FY(), this.autoHeaderHeight = null, this.moving = !1, this.menuVisible = !1, this.lastLeftPinned = !1, this.firstRightPinned = !1, this.filterActive = !1, this.columnEventService = new Af(), this.tooltipEnabled = !1, this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.colDef = e, this.userProvidedColDef = t, this.colId = r, this.primary = n, this.setState(e);
  }
  wireBeans(e) {
    this.columnHoverService = e.columnHoverService;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState(e) {
    e.sort !== void 0 ? (e.sort === "asc" || e.sort === "desc") && (this.sort = e.sort) : (e.initialSort === "asc" || e.initialSort === "desc") && (this.sort = e.initialSort);
    const t = e.sortIndex, r = e.initialSortIndex;
    t !== void 0 ? t !== null && (this.sortIndex = t) : r !== null && (this.sortIndex = r);
    const n = e.hide, i = e.initialHide;
    n !== void 0 ? this.visible = !n : this.visible = !i, e.pinned !== void 0 ? this.setPinned(e.pinned) : this.setPinned(e.initialPinned);
    const o = e.flex, a = e.initialFlex;
    o !== void 0 ? this.flex = o : a !== void 0 && (this.flex = a);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(e, t, r) {
    this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation(), this.initTooltip(), this.columnEventService.dispatchEvent(this.createColumnEvent("colDefChanged", r));
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  setParent(e) {
    this.parent = e;
  }
  getParent() {
    return this.parent;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  // this is done after constructor as it uses gridOptionsService
  postConstruct() {
    this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip();
  }
  initDotNotation() {
    const e = this.gos.get("suppressFieldDotNotation");
    this.fieldContainsDots = ke(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !e, this.tooltipFieldContainsDots = ke(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !e;
  }
  initMinAndMaxWidths() {
    const e = this.colDef;
    this.minWidth = e.minWidth ?? NY, this.maxWidth = e.maxWidth ?? Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    this.tooltipEnabled = ke(this.colDef.tooltipField) || ke(this.colDef.tooltipValueGetter) || ke(this.colDef.tooltipComponent);
  }
  resetActualWidth(e) {
    const t = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(t, e, !0);
  }
  calculateColInitialWidth(e) {
    let t;
    const r = Nc(e.width), n = Nc(e.initialWidth);
    return r != null ? t = r : n != null ? t = n : t = 200, Math.max(Math.min(t, this.maxWidth), this.minWidth);
  }
  isEmptyGroup() {
    return !1;
  }
  isRowGroupDisplayed(e) {
    if (dr(this.colDef) || dr(this.colDef.showRowGroup))
      return !1;
    const t = this.colDef.showRowGroup === !0, r = this.colDef.showRowGroup === e;
    return t || r;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    return !!this.colDef.filter;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  addEventListener(e, t) {
    var n;
    this.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.columnEventService.setFrameworkOverrides(this.frameworkOverrides), this.frameworkEventListenerService = new JA(this.frameworkOverrides));
    const r = ((n = this.frameworkEventListenerService) == null ? void 0 : n.wrap(t)) ?? t;
    this.columnEventService.addEventListener(e, r);
  }
  removeEventListener(e, t) {
    var n;
    const r = ((n = this.frameworkEventListenerService) == null ? void 0 : n.unwrap(t)) ?? t;
    this.columnEventService.removeEventListener(e, r);
  }
  createColumnFunctionCallbackParams(e) {
    return this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      column: this,
      colDef: this.colDef
    });
  }
  isSuppressNavigable(e) {
    if (typeof this.colDef.suppressNavigable == "boolean")
      return this.colDef.suppressNavigable;
    if (typeof this.colDef.suppressNavigable == "function") {
      const t = this.createColumnFunctionCallbackParams(e), r = this.colDef.suppressNavigable;
      return r(t);
    }
    return !1;
  }
  isCellEditable(e) {
    return e.group && !this.gos.get("enableGroupEdit") ? !1 : this.isColumnFunc(e, this.colDef.editable);
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(e) {
    return this.isColumnFunc(e, this.colDef.rowDrag);
  }
  isDndSource(e) {
    return this.isColumnFunc(e, this.colDef.dndSource);
  }
  isCellCheckboxSelection(e) {
    return this.isColumnFunc(e, this.colDef.checkboxSelection);
  }
  isSuppressPaste(e) {
    return this.isColumnFunc(e, this.colDef ? this.colDef.suppressPaste : null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  /** Get value from ColDef or default if it exists. */
  getColDefValue(e) {
    return this.colDef[e] ?? JVe[e];
  }
  isColumnFunc(e, t) {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function") {
      const r = this.createColumnFunctionCallbackParams(e);
      return t(r);
    }
    return !1;
  }
  setMoving(e, t) {
    this.moving = e, this.columnEventService.dispatchEvent(this.createColumnEvent("movingChanged", t));
  }
  createColumnEvent(e, t) {
    return this.gos.addGridCommonParams({
      type: e,
      column: this,
      columns: [this],
      source: t
    });
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  setSort(e, t) {
    this.sort !== e && (this.sort = e, this.columnEventService.dispatchEvent(this.createColumnEvent("sortChanged", t))), this.dispatchStateUpdatedEvent("sort");
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  /** @deprecated v32 use col.getSort() === 'asc */
  isSortAscending() {
    return this.sort === "asc";
  }
  /** @deprecated v32 use col.getSort() === 'desc */
  isSortDescending() {
    return this.sort === "desc";
  }
  /** @deprecated v32 use col.getSort() === undefined */
  isSortNone() {
    return dr(this.sort);
  }
  /** @deprecated v32 use col.getSort() !== undefined */
  isSorting() {
    return ke(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  setSortIndex(e) {
    this.sortIndex = e, this.dispatchStateUpdatedEvent("sortIndex");
  }
  setMenuVisible(e, t) {
    this.menuVisible !== e && (this.menuVisible = e, this.columnEventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", t)));
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  setAggFunc(e) {
    this.aggFunc = e, this.dispatchStateUpdatedEvent("aggFunc");
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(e, t) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.columnEventService.dispatchEvent(this.createColumnEvent("leftChanged", t)));
  }
  isFilterActive() {
    return this.filterActive;
  }
  // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
  setFilterActive(e, t, r) {
    this.filterActive !== e && (this.filterActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", t)));
    const n = this.createColumnEvent("filterChanged", t);
    r && jo(n, r), this.columnEventService.dispatchEvent(n);
  }
  isHovered() {
    return this.columnHoverService.isHovered(this);
  }
  setPinned(e) {
    e === !0 || e === "left" ? this.pinned = "left" : e === "right" ? this.pinned = "right" : this.pinned = null, this.dispatchStateUpdatedEvent("pinned");
  }
  setFirstRightPinned(e, t) {
    this.firstRightPinned !== e && (this.firstRightPinned = e, this.columnEventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", t)));
  }
  setLastLeftPinned(e, t) {
    this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.columnEventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", t)));
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(e, t) {
    const r = e === !0;
    this.visible !== r && (this.visible = r, this.columnEventService.dispatchEvent(this.createColumnEvent("visibleChanged", t))), this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    const e = this.getColDef();
    return !e.suppressSpanHeaderHeight && !e.autoHeaderHeight;
  }
  getColumnGroupPaddingInfo() {
    let e = this.getParent();
    if (!e || !e.isPadding())
      return { numberOfParents: 0, isSpanningTotal: !1 };
    const t = e.getPaddingLevel() + 1;
    let r = !0;
    for (; e; ) {
      if (!e.isPadding()) {
        r = !1;
        break;
      }
      e = e.getParent();
    }
    return { numberOfParents: t, isSpanningTotal: r };
  }
  getColDef() {
    return this.colDef;
  }
  getDefinition() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  createBaseColDefParams(e) {
    return this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      colDef: this.colDef,
      column: this
    });
  }
  getColSpan(e) {
    if (dr(this.colDef.colSpan))
      return 1;
    const t = this.createBaseColDefParams(e), r = this.colDef.colSpan(t);
    return Math.max(r, 1);
  }
  getRowSpan(e) {
    if (dr(this.colDef.rowSpan))
      return 1;
    const t = this.createBaseColDefParams(e), r = this.colDef.rowSpan(t);
    return Math.max(r, 1);
  }
  setActualWidth(e, t, r = !1) {
    e = Math.max(e, this.minWidth), e = Math.min(e, this.maxWidth), this.actualWidth !== e && (this.actualWidth = e, this.flex && t !== "flex" && t !== "gridInitializing" && (this.flex = null), r || this.fireColumnWidthChangedEvent(t)), this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(e) {
    this.columnEventService.dispatchEvent(this.createColumnEvent("widthChanged", e));
  }
  isGreaterThanMax(e) {
    return e > this.maxWidth;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex || 0;
  }
  // this method should only be used by the columnModel to
  // change flex when required by the applyColumnState method.
  setFlex(e) {
    this.flex !== e && (this.flex = e), this.dispatchStateUpdatedEvent("flex");
  }
  setMinimum(e) {
    this.setActualWidth(this.minWidth, e);
  }
  setRowGroupActive(e, t) {
    this.rowGroupActive !== e && (this.rowGroupActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", t))), this.dispatchStateUpdatedEvent("rowGroup");
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  setPivotActive(e, t) {
    this.pivotActive !== e && (this.pivotActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", t))), this.dispatchStateUpdatedEvent("pivot");
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  setValueActive(e, t) {
    this.aggregationActive !== e && (this.aggregationActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnValueChanged", t)));
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === !0;
  }
  isAllowValue() {
    return this.colDef.enableValue === !0;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === !0;
  }
  dispatchStateUpdatedEvent(e) {
    this.columnEventService.dispatchEvent({
      type: "columnStateUpdated",
      key: e
    });
  }
};
function Ri(e) {
  return e instanceof b0;
}
var b0 = class extends Se {
  constructor(e, t, r, n) {
    super(), this.isColumn = !1, this.expandable = !1, this.instanceId = FY(), this.expandableListenerRemoveCallback = null, this.colGroupDef = e, this.groupId = t, this.expanded = !!e && !!e.openByDefault, this.padding = r, this.level = n;
  }
  destroy() {
    this.expandableListenerRemoveCallback && this.reset(null, void 0), super.destroy();
  }
  reset(e, t) {
    this.colGroupDef = e, this.level = t, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    return this.children ? this.children.some((e) => e.isVisible()) : !1;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(e) {
    this.expanded = e === void 0 ? !1 : e, this.dispatchLocalEvent({ type: "expandedChanged" });
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(e) {
    this.children = e;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  addLeafColumns(e) {
    this.children && this.children.forEach((t) => {
      cu(t) ? e.push(t) : Ri(t) && t.addLeafColumns(e);
    });
  }
  getColumnGroupShow() {
    const e = this.colGroupDef;
    if (e)
      return e.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
    const e = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((t) => t.addEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((t) => t.removeEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding())
      return;
    let e = !1, t = !1, r = !1;
    const n = this.findChildrenRemovingPadding();
    for (let o = 0, a = n.length; o < a; o++) {
      const s = n[o];
      if (!s.isVisible())
        continue;
      const l = s.getColumnGroupShow();
      l === "open" ? (e = !0, r = !0) : l === "closed" ? (t = !0, r = !0) : (e = !0, t = !0);
    }
    const i = e && t && r;
    this.expandable !== i && (this.expandable = i, this.dispatchLocalEvent({ type: "expandableChanged" }));
  }
  findChildrenRemovingPadding() {
    const e = [], t = (r) => {
      r.forEach((n) => {
        Ri(n) && n.isPadding() ? t(n.children) : e.push(n);
      });
    };
    return t(this.children), e;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
}, tBe = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
}, LH = {};
function tI(e, t) {
  LH[t] || (e(), LH[t] = !0);
}
function Ea(e, ...t) {
  console.log("AG Grid: " + e, ...t);
}
function Te(e, ...t) {
  tI(() => console.warn("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function Er(e, ...t) {
  tI(() => console.error("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function rI(e) {
  return !!(e && e.constructor && e.call && e.apply);
}
function rBe(e) {
  nBe(e, 400);
}
var yE = [], CE = !1;
function FH(e) {
  yE.push(e), !CE && (CE = !0, window.setTimeout(() => {
    const t = yE.slice();
    yE.length = 0, CE = !1, t.forEach((r) => r());
  }, 0));
}
function nBe(e, t = 0) {
  e.length > 0 && window.setTimeout(() => e.forEach((r) => r()), t);
}
function Ti(e, t) {
  let r;
  return function(...n) {
    const i = this;
    window.clearTimeout(r), r = window.setTimeout(function() {
      e.apply(i, n);
    }, t);
  };
}
function NH(e, t) {
  let r = 0;
  return function(...n) {
    const i = this, o = (/* @__PURE__ */ new Date()).getTime();
    o - r < t || (r = o, e.apply(i, n));
  };
}
function iBe(e, t, r = 100, n) {
  const i = (/* @__PURE__ */ new Date()).getTime();
  let o = null, a = !1;
  const s = () => {
    const l = (/* @__PURE__ */ new Date()).getTime() - i > r;
    (e() || l) && (t(), a = !0, o != null && (window.clearInterval(o), o = null), l && n && Te(n));
  };
  s(), a || (o = window.setInterval(s, 10));
}
function oBe(...e) {
  return (t) => e.reduce((r, n) => n(r), t);
}
var aBe = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(e) {
    for (let t = 0; t < e.length; t++)
      this.existingKeys[e[t]] = !0;
  }
  getUniqueKey(e, t) {
    e = eP(e);
    let r = 0;
    for (; ; ) {
      let n;
      if (e ? (n = e, r !== 0 && (n += "_" + r)) : t ? (n = t, r !== 0 && (n += "_" + r)) : n = r, !this.existingKeys[n])
        return this.existingKeys[n] = !0, String(n);
      r++;
    }
  }
}, em = "ag-Grid-AutoColumn";
function nI(e) {
  const t = [], r = (n) => {
    for (let i = 0; i < n.length; i++) {
      const o = n[i];
      cu(o) ? t.push(o) : Ri(o) && r(o.getChildren());
    }
  };
  return r(e), t;
}
function Fs(e) {
  return e.reduce((t, r) => t + r.getActualWidth(), 0);
}
function yh(e, t, r) {
  const n = {};
  if (!t)
    return;
  ol(null, t, (o) => {
    n[o.getInstanceId()] = o;
  }), r && ol(null, r, (o) => {
    n[o.getInstanceId()] = null;
  });
  const i = Object.values(n).filter((o) => o != null);
  e.destroyBeans(i);
}
function kH(e) {
  return e.getId().startsWith(em);
}
function x0(e) {
  let t = [];
  return e instanceof Array ? e.some((n) => typeof n != "string") ? Te("if colDef.type is supplied an array it should be of type 'string[]'") : t = e : typeof e == "string" ? t = e.split(",") : Te("colDef.type should be of type 'string' | 'string[]'"), t;
}
var sBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnFactory";
  }
  wireBeans(e) {
    this.dataTypeService = e.dataTypeService;
  }
  createColumnTree(e, t, r, n) {
    const i = new aBe(), { existingCols: o, existingGroups: a, existingColKeys: s } = this.extractExistingTreeData(r);
    i.addExistingKeys(s);
    const l = this.recursivelyCreateColumns(
      e,
      0,
      t,
      o,
      i,
      a,
      n
    ), u = this.findMaxDept(l, 0), c = this.balanceColumnTree(l, 0, u, i);
    return ol(null, c, (h, f) => {
      Ri(h) && h.setupExpandable(), h.setOriginalParent(f);
    }), {
      columnTree: c,
      treeDept: u
    };
  }
  extractExistingTreeData(e) {
    const t = [], r = [], n = [];
    return e && ol(null, e, (i) => {
      if (Ri(i)) {
        const o = i;
        r.push(o);
      } else {
        const o = i;
        n.push(o.getId()), t.push(o);
      }
    }), { existingCols: t, existingGroups: r, existingColKeys: n };
  }
  createForAutoGroups(e, t) {
    const r = [], n = this.findDepth(t);
    return e.forEach((i) => {
      let o = i;
      for (let a = n - 1; a >= 0; a--) {
        const s = new b0(null, `FAKE_PATH_${i.getId()}}_${a}`, !0, a);
        this.createBean(s), s.setChildren([o]), o.setOriginalParent(s), o = s;
      }
      n === 0 && i.setOriginalParent(null), r.push(o);
    }), [r, n];
  }
  findDepth(e) {
    let t = 0, r = e;
    for (; r && r[0] && Ri(r[0]); )
      t++, r = r[0].getChildren();
    return t;
  }
  balanceColumnTree(e, t, r, n) {
    const i = [];
    for (let o = 0; o < e.length; o++) {
      const a = e[o];
      if (Ri(a)) {
        const s = a, l = this.balanceColumnTree(
          s.getChildren(),
          t + 1,
          r,
          n
        );
        s.setChildren(l), i.push(s);
      } else {
        let s, l;
        for (let u = r - 1; u >= t; u--) {
          const c = n.getUniqueKey(null, null), d = this.createMergedColGroupDef(null), h = new b0(d, c, !0, t);
          this.createBean(h), l && l.setChildren([h]), l = h, s || (s = l);
        }
        if (s && l)
          if (i.push(s), e.some((c) => Ri(c))) {
            l.setChildren([a]);
            continue;
          } else {
            l.setChildren(e);
            break;
          }
        i.push(a);
      }
    }
    return i;
  }
  findMaxDept(e, t) {
    let r = t;
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (Ri(i)) {
        const o = i, a = this.findMaxDept(o.getChildren(), t + 1);
        r < a && (r = a);
      }
    }
    return r;
  }
  recursivelyCreateColumns(e, t, r, n, i, o, a) {
    if (!e)
      return [];
    const s = new Array(e.length);
    for (let l = 0; l < s.length; l++) {
      const u = e[l];
      this.isColumnGroup(u) ? s[l] = this.createColumnGroup(
        r,
        u,
        t,
        n,
        i,
        o,
        a
      ) : s[l] = this.createColumn(
        r,
        u,
        n,
        i,
        a
      );
    }
    return s;
  }
  createColumnGroup(e, t, r, n, i, o, a) {
    const s = this.createMergedColGroupDef(t), l = i.getUniqueKey(s.groupId || null, null), u = new b0(s, l, !1, r);
    this.createBean(u);
    const c = this.findExistingGroup(t, o);
    c && o.splice(c.idx, 1);
    const d = c == null ? void 0 : c.group;
    d && u.setExpanded(d.isExpanded());
    const h = this.recursivelyCreateColumns(
      s.children,
      r + 1,
      e,
      n,
      i,
      o,
      a
    );
    return u.setChildren(h), u;
  }
  createMergedColGroupDef(e) {
    const t = {};
    return Object.assign(t, this.gos.get("defaultColGroupDef")), Object.assign(t, e), t;
  }
  createColumn(e, t, r, n, i) {
    var s;
    const o = this.findExistingColumn(t, r);
    o && (r == null || r.splice(o.idx, 1));
    let a = o == null ? void 0 : o.column;
    if (a) {
      const l = this.addColumnDefaultAndTypes(t, a.getColId());
      a.setColDef(l, t, i), this.applyColumnState(a, l, i);
    } else {
      const l = n.getUniqueKey(t.colId, t.field), u = this.addColumnDefaultAndTypes(t, l);
      a = new kY(u, t, l, e), this.createBean(a);
    }
    return (s = this.dataTypeService) == null || s.addColumnListeners(a), a;
  }
  applyColumnState(e, t, r) {
    const n = Nc(t.flex);
    if (n !== void 0 && e.setFlex(n), e.getFlex() <= 0) {
      const s = Nc(t.width);
      if (s != null)
        e.setActualWidth(s, r);
      else {
        const l = e.getActualWidth();
        e.setActualWidth(l, r);
      }
    }
    t.sort !== void 0 && (t.sort == "asc" || t.sort == "desc" ? e.setSort(t.sort, r) : e.setSort(void 0, r));
    const o = Nc(t.sortIndex);
    o !== void 0 && e.setSortIndex(o);
    const a = tP(t.hide);
    a !== void 0 && e.setVisible(!a, r), t.pinned !== void 0 && e.setPinned(t.pinned);
  }
  findExistingColumn(e, t) {
    if (t)
      for (let r = 0; r < t.length; r++) {
        const n = t[r].getUserProvidedColDef();
        if (!n)
          continue;
        if (e.colId != null) {
          if (t[r].getId() === e.colId)
            return { idx: r, column: t[r] };
          continue;
        }
        if (e.field != null) {
          if (n.field === e.field)
            return { idx: r, column: t[r] };
          continue;
        }
        if (n === e)
          return { idx: r, column: t[r] };
      }
  }
  findExistingGroup(e, t) {
    if (e.groupId != null)
      for (let n = 0; n < t.length; n++) {
        const i = t[n];
        if (i.getColGroupDef() && i.getId() === e.groupId)
          return { idx: n, group: i };
      }
  }
  addColumnDefaultAndTypes(e, t) {
    var s;
    const r = {}, n = this.gos.get("defaultColDef");
    jo(r, n, !1, !0);
    const i = this.updateColDefAndGetColumnType(r, e, t);
    i && this.assignColumnTypes(i, r), jo(r, e, !1, !0);
    const o = this.gos.get("autoGroupColumnDef"), a = this.gos.isColumnsSortingCoupledToGroup();
    return e.rowGroup && o && a && jo(
      r,
      { sort: o.sort, initialSort: o.initialSort },
      !1,
      !0
    ), (s = this.dataTypeService) == null || s.validateColDef(r), r;
  }
  updateColDefAndGetColumnType(e, t, r) {
    var o;
    const n = (o = this.dataTypeService) == null ? void 0 : o.updateColDefAndGetColumnType(
      e,
      t,
      r
    ), i = t.type ?? n ?? e.type;
    return e.type = i, i ? x0(i) : void 0;
  }
  assignColumnTypes(e, t) {
    if (!e.length)
      return;
    const r = Object.assign({}, tBe), n = this.gos.get("columnTypes") || {};
    wa(n, (i, o) => {
      i in r ? Te(`the column type '${i}' is a default column type and cannot be overridden.`) : (o.type && Te(
        "Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type."
      ), r[i] = o);
    }), e.forEach((i) => {
      const o = r[i.trim()];
      o ? jo(t, o, !1, !0) : Te("colDef.type '" + i + "' does not correspond to defined gridOptions.columnTypes");
    });
  }
  // if object has children, we assume it's a group
  isColumnGroup(e) {
    return e.children !== void 0;
  }
};
function ol(e, t, r) {
  if (t)
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      Ri(i) && ol(i, i.getChildren(), r), r(i, e);
    }
}
var lBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnModel", this.pivotMode = !1, this.autoHeightActiveAtLeastOnce = !1, this.ready = !1, this.changeEventsDispatching = !1, this.shouldQueueResizeOperations = !1, this.resizeOperationQueue = [];
  }
  wireBeans(e) {
    this.context = e.context, this.columnFactory = e.columnFactory, this.columnSizeService = e.columnSizeService, this.visibleColsService = e.visibleColsService, this.columnViewportService = e.columnViewportService, this.pivotResultColsService = e.pivotResultColsService, this.columnAnimationService = e.columnAnimationService, this.autoColService = e.autoColService, this.valueCache = e.valueCache, this.columnDefFactory = e.columnDefFactory, this.columnApplyStateService = e.columnApplyStateService, this.columnGroupStateService = e.columnGroupStateService, this.eventDispatcher = e.columnEventDispatcher, this.columnMoveService = e.columnMoveService, this.columnAutosizeService = e.columnAutosizeService, this.funcColsService = e.funcColsService, this.quickFilterService = e.quickFilterService, this.showRowGroupColsService = e.showRowGroupColsService, this.environment = e.environment;
  }
  postConstruct() {
    const e = this.gos.get("pivotMode");
    this.isPivotSettingAllowed(e) && (this.pivotMode = e), this.addManagedPropertyListeners(
      ["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"],
      (t) => this.refreshAll(Ch(t.source))
    ), this.addManagedPropertyListener(
      "autoGroupColumnDef",
      (t) => this.onAutoGroupColumnDefChanged(Ch(t.source))
    ), this.addManagedPropertyListeners(
      ["defaultColDef", "columnTypes", "suppressFieldDotNotation"],
      (t) => this.recreateColumnDefs(Ch(t.source))
    ), this.addManagedPropertyListener(
      "pivotMode",
      (t) => this.setPivotMode(this.gos.get("pivotMode"), Ch(t.source))
    ), this.addManagedEventListeners({ firstDataRendered: () => this.onFirstDataRendered() });
  }
  // called from SyncService, when grid has finished initialising
  createColsFromColDefs(e, t) {
    var d;
    const r = e ? this.columnApplyStateService.compareColumnStatesAndDispatchEvents(t) : void 0;
    this.valueCache.expire();
    const n = this.colDefCols && this.colDefCols.list, i = this.colDefCols && this.colDefCols.tree, o = this.columnFactory.createColumnTree(this.colDefs, !0, i, t);
    yh(this.context, (d = this.colDefCols) == null ? void 0 : d.tree, o.columnTree);
    const a = o.columnTree, s = o.treeDept, l = nI(a), u = {};
    l.forEach((h) => u[h.getId()] = h), this.colDefCols = { tree: a, treeDepth: s, list: l, map: u }, this.funcColsService.extractCols(t, n), this.ready = !0, this.refreshCols(), e && !this.showingPivotResult && !this.gos.get("maintainColumnOrder") && this.orderColsLikeColDefCols(), this.visibleColsService.refresh(t), this.columnViewportService.checkViewportColumns(), this.eventDispatcher.everythingChanged(t), r && (this.changeEventsDispatching = !0, r(), this.changeEventsDispatching = !1), this.eventDispatcher.newColumnsLoaded(t), t === "gridInitializing" && this.columnSizeService.applyAutosizeStrategy();
  }
  // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
  // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
  // setPivotMode, applyColumnState,
  // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
  // pivotResultColsService.setPivotResultCols
  refreshCols() {
    var r, n, i;
    if (!this.colDefCols)
      return;
    const e = (r = this.cols) == null ? void 0 : r.tree;
    this.saveColOrder(), this.selectCols(), this.createAutoCols(), this.addAutoCols(), this.restoreColOrder(), this.positionLockedCols(), (n = this.showRowGroupColsService) == null || n.refresh(), (i = this.quickFilterService) == null || i.refreshQuickFilterCols(), this.setColSpanActive(), this.setAutoHeightActive(), this.visibleColsService.clear(), this.columnViewportService.clear(), !fd(e, this.cols.tree) && this.eventDispatcher.gridColumns();
  }
  selectCols() {
    const e = this.pivotResultColsService.getPivotResultCols();
    if (this.showingPivotResult = e != null, e) {
      const { map: t, list: r, tree: n, treeDepth: i } = e;
      this.cols = {
        list: r.slice(),
        map: { ...t },
        tree: n.slice(),
        treeDepth: i
      }, e.list.some((a) => {
        var s;
        return ((s = this.cols) == null ? void 0 : s.map[a.getColId()]) !== void 0;
      }) || (this.lastPivotOrder = null);
    } else {
      const { map: t, list: r, tree: n, treeDepth: i } = this.colDefCols;
      this.cols = {
        list: r.slice(),
        map: { ...t },
        tree: n.slice(),
        treeDepth: i
      };
    }
  }
  getColsToShow() {
    const e = this.isPivotMode() && !this.isShowingPivotResult(), t = this.funcColsService.getValueColumns();
    return this.cols.list.filter((n) => {
      const i = kH(n);
      if (e) {
        const o = t && Lc(t, n);
        return i || o;
      } else
        return i || n.isVisible();
    });
  }
  addAutoCols() {
    this.autoCols != null && (this.cols.list = this.autoCols.list.concat(this.cols.list), this.cols.tree = this.autoCols.tree.concat(this.cols.tree), uBe(this.cols));
  }
  createAutoCols() {
    var p, g;
    const e = this.gos.isGroupUseEntireRow(this.pivotMode), t = this.pivotMode ? this.gos.get("pivotSuppressAutoColumn") : this.isSuppressAutoCol(), r = this.funcColsService.getRowGroupColumns(), i = !(r.length > 0 || this.gos.get("treeData")) || t || e, o = () => {
      this.autoCols && (yh(this.context, this.autoCols.tree), this.autoCols = null);
    };
    if (i || !this.autoColService) {
      o();
      return;
    }
    const a = this.autoColService.createAutoCols(r) ?? [], s = cBe(a, ((p = this.autoCols) == null ? void 0 : p.list) || null), l = this.cols.treeDepth, c = (this.autoCols ? this.autoCols.treeDepth : -1) == l;
    if (s && c)
      return;
    o();
    const [d, h] = this.columnFactory.createForAutoGroups(a, (g = this.cols) == null ? void 0 : g.tree);
    this.autoCols = {
      list: a,
      tree: d,
      treeDepth: h,
      map: {}
    };
    const f = (v) => {
      if (!v)
        return null;
      const m = v.filter((y) => !kH(y));
      return [...a, ...m];
    };
    this.lastOrder = f(this.lastOrder), this.lastPivotOrder = f(this.lastPivotOrder);
  }
  // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
  refreshAll(e) {
    this.isReady() && (this.refreshCols(), this.visibleColsService.refresh(e));
  }
  setColsVisible(e, t = !1, r) {
    this.columnApplyStateService.applyColumnState(
      {
        state: e.map((n) => ({
          colId: typeof n == "string" ? n : n.getColId(),
          hide: !t
        }))
      },
      r
    );
  }
  setColsPinned(e, t, r) {
    if (!this.cols || Wn(e))
      return;
    if (this.gos.isDomLayout("print")) {
      Te("Changing the column pinning status is not allowed with domLayout='print'");
      return;
    }
    this.columnAnimationService.start();
    let n;
    t === !0 || t === "left" ? n = "left" : t === "right" ? n = "right" : n = null;
    const i = [];
    e.forEach((o) => {
      if (!o)
        return;
      const a = this.getCol(o);
      a && a.getPinned() !== n && (a.setPinned(n), i.push(a));
    }), i.length && (this.visibleColsService.refresh(r), this.eventDispatcher.columnPinned(i, r)), this.columnAnimationService.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(e, t, r) {
    let n;
    Ri(e) ? n = e.getId() : n = e || "", this.columnGroupStateService.setColumnGroupState([{ groupId: n, open: t }], r);
  }
  getProvidedColGroup(e) {
    var r;
    let t = null;
    return ol(null, (r = this.cols) == null ? void 0 : r.tree, (n) => {
      Ri(n) && n.getId() === e && (t = n);
    }), t;
  }
  isColGroupLocked(e) {
    const t = this.gos.get("groupLockGroupColumns");
    if (!e.isRowGroupActive() || t === 0)
      return !1;
    if (t === -1)
      return !0;
    const n = this.funcColsService.getRowGroupColumns().findIndex((i) => i.getColId() === e.getColId());
    return t > n;
  }
  isSuppressAutoCol() {
    return this.gos.get("groupDisplayType") === "custom" ? !0 : this.gos.get("treeDataDisplayType") === "custom";
  }
  setAutoHeightActive() {
    this.autoHeightActive = this.cols.list.some((e) => e.isAutoHeight()), this.autoHeightActive && (this.autoHeightActiveAtLeastOnce = !0, this.gos.isRowModelType("clientSide") || this.gos.isRowModelType("serverSide") || Te("autoHeight columns only work with Client Side Row Model and Server Side Row Model."));
  }
  restoreColOrder() {
    const e = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
    if (!e)
      return;
    const t = new Map(e.map((l, u) => [l, u]));
    if (!this.cols.list.some((l) => t.has(l)))
      return;
    const n = new Map(this.cols.list.map((l) => [l, !0])), i = e.filter((l) => n.has(l)), o = new Map(i.map((l) => [l, !0])), a = this.cols.list.filter((l) => !o.has(l)), s = i.slice();
    a.forEach((l) => {
      let u = l.getOriginalParent();
      if (!u) {
        s.push(l);
        return;
      }
      const c = [];
      for (; !c.length && u; )
        u.getLeafColumns().forEach((p) => {
          const g = s.indexOf(p) >= 0, v = c.indexOf(p) < 0;
          g && v && c.push(p);
        }), u = u.getOriginalParent();
      if (!c.length) {
        s.push(l);
        return;
      }
      const d = c.map((f) => s.indexOf(f)), h = Math.max(...d);
      QC(s, l, h + 1);
    }), this.cols.list = s;
  }
  orderColsLikeColDefCols() {
    if (!this.colDefCols || !this.cols)
      return;
    const e = this.colDefCols.list.filter((r) => this.cols.list.indexOf(r) >= 0), t = this.cols.list.filter((r) => e.indexOf(r) < 0);
    this.cols.list = [...t, ...e], this.cols.list = this.columnMoveService.placeLockedColumns(this.cols.list);
  }
  sortColsLikeKeys(e) {
    if (this.cols == null)
      return;
    let t = [];
    const r = {};
    e.forEach((i) => {
      if (r[i])
        return;
      const o = this.cols.map[i];
      o && (t.push(o), r[i] = !0);
    });
    let n = 0;
    if (this.cols.list.forEach((i) => {
      const o = i.getColId();
      if (r[o] != null)
        return;
      o.startsWith(em) ? QC(t, i, n++) : t.push(i);
    }), t = this.columnMoveService.placeLockedColumns(t), !this.columnMoveService.doesMovePassMarryChildren(t)) {
      Te(
        "Applying column order broke a group where columns should be married together. Applying new order has been discarded."
      );
      return;
    }
    this.cols.list = t;
  }
  // returns the provided cols sorted in same order as they appear in this.cols, eg if this.cols
  // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]
  sortColsLikeCols(e) {
    !e || e.length <= 1 || e.filter((r) => this.cols.list.indexOf(r) < 0).length > 0 || e.sort((r, n) => {
      const i = this.cols.list.indexOf(r), o = this.cols.list.indexOf(n);
      return i - o;
    });
  }
  resetColDefIntoCol(e, t) {
    const r = e.getUserProvidedColDef();
    if (!r)
      return !1;
    const n = this.columnFactory.addColumnDefaultAndTypes(r, e.getColId());
    return e.setColDef(n, r, t), !0;
  }
  queueResizeOperations() {
    this.shouldQueueResizeOperations = !0;
  }
  isShouldQueueResizeOperations() {
    return this.shouldQueueResizeOperations;
  }
  processResizeOperations() {
    this.shouldQueueResizeOperations = !1, this.resizeOperationQueue.forEach((e) => e()), this.resizeOperationQueue = [];
  }
  pushResizeOperation(e) {
    this.resizeOperationQueue.push(e);
  }
  moveInCols(e, t, r) {
    var n;
    AY((n = this.cols) == null ? void 0 : n.list, e, t), this.visibleColsService.refresh(r);
  }
  positionLockedCols() {
    this.cols.list = this.columnMoveService.placeLockedColumns(this.cols.list);
  }
  saveColOrder() {
    var e, t;
    this.showingPivotResult ? this.lastPivotOrder = (e = this.cols) == null ? void 0 : e.list : this.lastOrder = (t = this.cols) == null ? void 0 : t.list;
  }
  getColumnDefs() {
    if (!this.colDefCols)
      return;
    const e = this.colDefCols.list.slice();
    this.showingPivotResult ? e.sort((n, i) => this.lastOrder.indexOf(n) - this.lastOrder.indexOf(i)) : this.lastOrder && e.sort((n, i) => this.cols.list.indexOf(n) - this.cols.list.indexOf(i));
    const t = this.funcColsService.getRowGroupColumns(), r = this.funcColsService.getPivotColumns();
    return this.columnDefFactory.buildColumnDefs(e, t, r);
  }
  isShowingPivotResult() {
    return this.showingPivotResult;
  }
  // called by clientSideRowModel.refreshModel
  isChangeEventsDispatching() {
    return this.changeEventsDispatching;
  }
  isColSpanActive() {
    return this.colSpanActive;
  }
  // used by Column Tool Panel
  isProvidedColGroupsPresent() {
    var e;
    return ((e = this.colDefCols) == null ? void 0 : e.treeDepth) > 0;
  }
  setColSpanActive() {
    this.colSpanActive = this.cols.list.some((e) => e.getColDef().colSpan != null);
  }
  isAutoRowHeightActive() {
    return this.autoHeightActive;
  }
  wasAutoRowHeightEverActive() {
    return this.autoHeightActiveAtLeastOnce;
  }
  // + gridPanel -> for resizing the body and setting top margin
  getHeaderRowCount() {
    return this.cols ? this.cols.treeDepth + 1 : -1;
  }
  isReady() {
    return this.ready;
  }
  isPivotMode() {
    return this.pivotMode;
  }
  setPivotMode(e, t) {
    e === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode) || (this.pivotMode = e, this.ready && (this.refreshCols(), this.visibleColsService.refresh(t), this.eventDispatcher.pivotModeChanged()));
  }
  isPivotSettingAllowed(e) {
    return e && this.gos.get("treeData") ? (Te("Pivot mode not available with treeData."), !1) : !0;
  }
  // + clientSideRowModel
  isPivotActive() {
    const e = this.funcColsService.getPivotColumns();
    return this.pivotMode && !Wn(e);
  }
  // called when dataTypes change
  recreateColumnDefs(e) {
    this.cols && (this.autoCols && this.autoColService.updateAutoCols(this.autoCols.list, e), this.createColsFromColDefs(!0, e));
  }
  setColumnDefs(e, t) {
    const r = !!this.colDefs;
    this.colDefs = e, this.createColsFromColDefs(r, t);
  }
  destroy() {
    var e, t;
    yh(this.context, (e = this.colDefCols) == null ? void 0 : e.tree), yh(this.context, (t = this.autoCols) == null ? void 0 : t.tree), super.destroy();
  }
  getColTree() {
    return this.cols.tree;
  }
  // + columnSelectPanel
  getColDefColTree() {
    return this.colDefCols.tree;
  }
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getColDefCols() {
    var e;
    return (e = this.colDefCols) != null && e.list ? this.colDefCols.list : null;
  }
  // + moveColumnController
  getCols() {
    var e;
    return ((e = this.cols) == null ? void 0 : e.list) ?? [];
  }
  // returns colDefCols, pivotResultCols and autoCols
  getAllCols() {
    var r, n;
    const e = this.pivotResultColsService.getPivotResultCols(), t = e == null ? void 0 : e.list;
    return [].concat(
      ((r = this.colDefCols) == null ? void 0 : r.list) || [],
      ((n = this.autoCols) == null ? void 0 : n.list) || [],
      t || []
    );
  }
  getColsForKeys(e) {
    return e ? e.map((r) => this.getCol(r)).filter((r) => r != null) : [];
  }
  getColDefCol(e) {
    var t;
    return (t = this.colDefCols) != null && t.list ? this.getColFromCollection(e, this.colDefCols) : null;
  }
  getCol(e) {
    return e == null ? null : this.getColFromCollection(e, this.cols);
  }
  getColFromCollection(e, t) {
    if (t == null)
      return null;
    const { map: r, list: n } = t;
    if (typeof e == "string" && r[e])
      return r[e];
    for (let i = 0; i < n.length; i++)
      if (VH(n[i], e))
        return n[i];
    return this.getAutoCol(e);
  }
  getAutoCol(e) {
    return this.autoCols == null ? null : this.autoCols.list.find((t) => VH(t, e)) || null;
  }
  getAutoCols() {
    var e;
    return ((e = this.autoCols) == null ? void 0 : e.list) || null;
  }
  setColHeaderHeight(e, t) {
    e.setAutoHeaderHeight(t) && this.eventDispatcher.headerHeight(e);
  }
  getColumnGroupHeaderRowHeight() {
    return this.isPivotMode() ? this.getPivotGroupHeaderHeight() : this.getGroupHeaderHeight();
  }
  getColumnHeaderRowHeight() {
    const e = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight(), r = this.visibleColsService.getAllCols().filter((n) => n.isAutoHeaderHeight()).map((n) => n.getAutoHeaderHeight() || 0);
    return Math.max(e, ...r);
  }
  getHeaderHeight() {
    return this.gos.get("headerHeight") ?? this.environment.getDefaultHeaderHeight();
  }
  getFloatingFiltersHeight() {
    return this.gos.get("floatingFiltersHeight") ?? this.getHeaderHeight();
  }
  getGroupHeaderHeight() {
    return this.gos.get("groupHeaderHeight") ?? this.getHeaderHeight();
  }
  getPivotHeaderHeight() {
    return this.gos.get("pivotHeaderHeight") ?? this.getHeaderHeight();
  }
  getPivotGroupHeaderHeight() {
    return this.gos.get("pivotGroupHeaderHeight") ?? this.getGroupHeaderHeight();
  }
  onFirstDataRendered() {
    const e = this.gos.get("autoSizeStrategy");
    if ((e == null ? void 0 : e.type) !== "fitCellContents")
      return;
    const { colIds: t, skipHeader: r } = e;
    setTimeout(() => {
      t ? this.columnAutosizeService.autoSizeCols({
        colKeys: t,
        skipHeader: r,
        source: "autosizeColumns"
      }) : this.columnAutosizeService.autoSizeAllColumns("autosizeColumns", r);
    });
  }
  onAutoGroupColumnDefChanged(e) {
    this.autoCols && this.autoColService.updateAutoCols(this.autoCols.list, e);
  }
};
function Ch(e) {
  return e === "gridOptionsUpdated" ? "gridOptionsChanged" : e;
}
function uBe(e) {
  e.map = {}, e.list.forEach((t) => e.map[t.getId()] = t);
}
function VH(e, t) {
  const r = e === t, n = e.getColDef() === t, i = e.getColId() == t;
  return r || n || i;
}
function cBe(e, t) {
  return fd(e, t, (r, n) => r.getColId() === n.getColId());
}
var dBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnAutosizeService", this.timesDelayed = 0;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.animationFrameService = e.animationFrameService, this.autoWidthCalculator = e.autoWidthCalculator, this.eventDispatcher = e.columnEventDispatcher, this.ctrlsService = e.ctrlsService, this.renderStatusService = e.renderStatusService;
  }
  autoSizeCols(e) {
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.autoSizeCols(e));
      return;
    }
    const { colKeys: t, skipHeader: r, skipHeaderGroups: n, stopAtGroup: i, source: o = "api" } = e;
    if (this.animationFrameService.flushAllFrames(), this.timesDelayed < 5 && this.renderStatusService && !this.renderStatusService.areHeaderCellsRendered()) {
      this.timesDelayed++, setTimeout(() => this.autoSizeCols(e));
      return;
    }
    this.timesDelayed = 0;
    const a = [];
    let s = -1;
    const l = r ?? this.gos.get("skipHeaderOnAutoSize"), u = n ?? l;
    for (; s !== 0; ) {
      s = 0;
      const c = [];
      t.forEach((d) => {
        if (!d)
          return;
        const h = this.columnModel.getCol(d);
        if (!h || a.indexOf(h) >= 0)
          return;
        const f = this.autoWidthCalculator.getPreferredWidthForColumn(h, l);
        if (f > 0) {
          const p = this.normaliseColumnWidth(h, f);
          h.setActualWidth(p, o), a.push(h), s++;
        }
        c.push(h);
      }), c.length && this.visibleColsService.refresh(o);
    }
    u || this.autoSizeColumnGroupsByColumns(t, o, i), this.eventDispatcher.columnResized(a, !0, "autosizeColumns");
  }
  autoSizeColumn(e, t, r) {
    e && this.autoSizeCols({ colKeys: [e], skipHeader: r, skipHeaderGroups: !0, source: t });
  }
  autoSizeColumnGroupsByColumns(e, t, r) {
    const n = /* @__PURE__ */ new Set();
    this.columnModel.getColsForKeys(e).forEach((s) => {
      let l = s.getParent();
      for (; l && l != r; )
        l.isPadding() || n.add(l), l = l.getParent();
    });
    let o;
    const a = [];
    for (const s of n) {
      for (const l of this.ctrlsService.getHeaderRowContainerCtrls())
        if (o = l.getHeaderCtrlForColumn(s), o)
          break;
      o && o.resizeLeafColumnsToFit(t);
    }
    return a;
  }
  autoSizeAllColumns(e, t) {
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.autoSizeAllColumns(e, t));
      return;
    }
    const r = this.visibleColsService.getAllCols();
    this.autoSizeCols({ colKeys: r, skipHeader: t, source: e });
  }
  // returns the width we can set to this col, taking into consideration min and max widths
  normaliseColumnWidth(e, t) {
    const r = e.getMinWidth();
    t < r && (t = r);
    const n = e.getMaxWidth();
    return e.isGreaterThanMax(t) && (t = n), t;
  }
}, hBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "funcColsService", this.rowGroupCols = [], this.valueCols = [], this.pivotCols = [];
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher, this.aggFuncService = e.aggFuncService, this.visibleColsService = e.visibleColsService;
  }
  getModifyColumnsNoEventsCallbacks() {
    return {
      addGroupCol: (e) => this.rowGroupCols.push(e),
      removeGroupCol: (e) => _i(this.rowGroupCols, e),
      addPivotCol: (e) => this.pivotCols.push(e),
      removePivotCol: (e) => _i(this.pivotCols, e),
      addValueCol: (e) => this.valueCols.push(e),
      removeValueCol: (e) => _i(this.valueCols, e)
    };
  }
  getSourceColumnsForGroupColumn(e) {
    const t = e.getColDef().showRowGroup;
    if (!t)
      return null;
    if (t === !0)
      return this.rowGroupCols.slice(0);
    const r = this.columnModel.getColDefCol(t);
    return r ? [r] : null;
  }
  sortRowGroupColumns(e) {
    this.rowGroupCols.sort(e);
  }
  sortPivotColumns(e) {
    this.pivotCols.sort(e);
  }
  // + rowController
  getValueColumns() {
    return this.valueCols ? this.valueCols : [];
  }
  // + rowController
  getPivotColumns() {
    return this.pivotCols ? this.pivotCols : [];
  }
  // + toolPanel
  getRowGroupColumns() {
    return this.rowGroupCols ? this.rowGroupCols : [];
  }
  isRowGroupEmpty() {
    return Wn(this.rowGroupCols);
  }
  setColumnAggFunc(e, t, r) {
    if (!e)
      return;
    const n = this.columnModel.getColDefCol(e);
    n && (n.setAggFunc(t), this.eventDispatcher.columnChanged("columnValueChanged", [n], r));
  }
  setRowGroupColumns(e, t) {
    this.setColList(
      e,
      this.rowGroupCols,
      "columnRowGroupChanged",
      !0,
      !0,
      (r, n) => this.setRowGroupActive(r, n, t),
      t
    );
  }
  setRowGroupActive(e, t, r) {
    e !== t.isRowGroupActive() && (t.setRowGroupActive(e, r), e && !this.gos.get("suppressRowGroupHidesColumns") && this.columnModel.setColsVisible([t], !1, r), !e && !this.gos.get("suppressMakeColumnVisibleAfterUnGroup") && this.columnModel.setColsVisible([t], !0, r));
  }
  addRowGroupColumns(e, t) {
    this.updateColList(
      e,
      this.rowGroupCols,
      !0,
      !0,
      (r) => this.setRowGroupActive(!0, r, t),
      "columnRowGroupChanged",
      t
    );
  }
  removeRowGroupColumns(e, t) {
    this.updateColList(
      e,
      this.rowGroupCols,
      !1,
      !0,
      (r) => this.setRowGroupActive(!1, r, t),
      "columnRowGroupChanged",
      t
    );
  }
  addPivotColumns(e, t) {
    this.updateColList(
      e,
      this.pivotCols,
      !0,
      !1,
      (r) => r.setPivotActive(!0, t),
      "columnPivotChanged",
      t
    );
  }
  setPivotColumns(e, t) {
    this.setColList(
      e,
      this.pivotCols,
      "columnPivotChanged",
      !0,
      !1,
      (r, n) => {
        n.setPivotActive(r, t);
      },
      t
    );
  }
  removePivotColumns(e, t) {
    this.updateColList(
      e,
      this.pivotCols,
      !1,
      !1,
      (r) => r.setPivotActive(!1, t),
      "columnPivotChanged",
      t
    );
  }
  setValueColumns(e, t) {
    this.setColList(
      e,
      this.valueCols,
      "columnValueChanged",
      !1,
      !1,
      (r, n) => this.setValueActive(r, n, t),
      t
    );
  }
  setValueActive(e, t, r) {
    if (e !== t.isValueActive() && (t.setValueActive(e, r), e && !t.getAggFunc() && this.aggFuncService)) {
      const n = this.aggFuncService.getDefaultAggFunc(t);
      t.setAggFunc(n);
    }
  }
  addValueColumns(e, t) {
    this.updateColList(
      e,
      this.valueCols,
      !0,
      !1,
      (r) => this.setValueActive(!0, r, t),
      "columnValueChanged",
      t
    );
  }
  removeValueColumns(e, t) {
    this.updateColList(
      e,
      this.valueCols,
      !1,
      !1,
      (r) => this.setValueActive(!1, r, t),
      "columnValueChanged",
      t
    );
  }
  moveRowGroupColumn(e, t, r) {
    if (this.isRowGroupEmpty())
      return;
    const n = this.rowGroupCols[e], i = this.rowGroupCols.slice(e, t);
    this.rowGroupCols.splice(e, 1), this.rowGroupCols.splice(t, 0, n), this.eventDispatcher.rowGroupChanged(i, r);
  }
  setColList(e, t, r, n, i, o, a) {
    const s = this.columnModel.getCols();
    if (Wn(s))
      return;
    const l = /* @__PURE__ */ new Map();
    t.forEach((c, d) => l.set(c, d)), t.length = 0, ke(e) && e.forEach((c) => {
      const d = this.columnModel.getColDefCol(c);
      d && t.push(d);
    }), t.forEach((c, d) => {
      const h = l.get(c);
      if (h === void 0) {
        l.set(c, 0);
        return;
      }
      n && h !== d || l.delete(c);
    }), (this.columnModel.getColDefCols() || []).forEach((c) => {
      const d = t.indexOf(c) >= 0;
      o(d, c);
    }), i && this.columnModel.refreshCols(), this.visibleColsService.refresh(a), this.eventDispatcher.columnChanged(r, [...l.keys()], a);
  }
  updateColList(e, t, r, n, i, o, a) {
    if (!e || Wn(e))
      return;
    let s = !1;
    e.forEach((l) => {
      if (!l)
        return;
      const u = this.columnModel.getColDefCol(l);
      if (u) {
        if (r) {
          if (t.indexOf(u) >= 0)
            return;
          t.push(u);
        } else {
          if (t.indexOf(u) < 0)
            return;
          _i(t, u);
        }
        i(u), s = !0;
      }
    }), s && (n && this.columnModel.refreshCols(), this.visibleColsService.refresh(a), this.eventDispatcher.genericColumnEvent(o, t, a));
  }
  extractCols(e, t) {
    this.extractRowGroupCols(e, t), this.extractPivotCols(e, t), this.extractValueCols(e, t);
  }
  extractValueCols(e, t) {
    this.valueCols = this.extractColsCommon(
      t,
      this.valueCols,
      (r, n) => r.setValueActive(n, e),
      // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null
      () => {
      },
      () => {
      },
      // aggFunc is a string, so return it's existence
      (r) => {
        const n = r.aggFunc;
        if (n === null || n === "")
          return null;
        if (n !== void 0)
          return !!n;
      },
      (r) => r.initialAggFunc != null && r.initialAggFunc != ""
    ), this.valueCols.forEach((r) => {
      const n = r.getColDef();
      n.aggFunc != null && n.aggFunc != "" ? r.setAggFunc(n.aggFunc) : r.getAggFunc() || r.setAggFunc(n.initialAggFunc);
    });
  }
  extractRowGroupCols(e, t) {
    this.rowGroupCols = this.extractColsCommon(
      t,
      this.rowGroupCols,
      (r, n) => r.setRowGroupActive(n, e),
      (r) => r.rowGroupIndex,
      (r) => r.initialRowGroupIndex,
      (r) => r.rowGroup,
      (r) => r.initialRowGroup
    );
  }
  extractPivotCols(e, t) {
    this.pivotCols = this.extractColsCommon(
      t,
      this.pivotCols,
      (r, n) => r.setPivotActive(n, e),
      (r) => r.pivotIndex,
      (r) => r.initialPivotIndex,
      (r) => r.pivot,
      (r) => r.initialPivot
    );
  }
  extractColsCommon(e = [], t = [], r, n, i, o, a) {
    const s = [], l = [];
    (this.columnModel.getColDefCols() || []).forEach((h) => {
      const f = e.indexOf(h) < 0, p = h.getColDef(), g = tP(o(p)), v = tP(a(p)), m = Nc(n(p)), y = Nc(i(p));
      let C;
      g !== void 0 ? C = g : m !== void 0 ? m === null ? C = !1 : C = m >= 0 : f ? v !== void 0 ? C = v : y !== void 0 ? C = y != null && y >= 0 : C = !1 : C = t.indexOf(h) >= 0, C && ((f ? m != null || y != null : m != null) ? s.push(h) : l.push(h));
    });
    const c = (h) => {
      const f = n(h.getColDef()), p = i(h.getColDef());
      return f ?? p;
    };
    s.sort((h, f) => {
      const p = c(h), g = c(f);
      return p === g ? 0 : p < g ? -1 : 1;
    });
    const d = [].concat(s);
    return t.forEach((h) => {
      l.indexOf(h) >= 0 && d.push(h);
    }), l.forEach((h) => {
      d.indexOf(h) < 0 && d.push(h);
    }), t.forEach((h) => {
      d.indexOf(h) < 0 && r(h, !1);
    }), d.forEach((h) => {
      t.indexOf(h) < 0 && r(h, !0);
    }), d;
  }
  generateColumnStateForRowGroupAndPivotIndexes(e, t) {
    const r = {}, n = (i, o, a, s, l, u) => {
      const c = this.columnModel.getColDefCols();
      if (!o.length || !c)
        return [];
      const d = Object.keys(i), h = new Set(d), f = new Set(d), p = new Set(
        o.map((w) => {
          const x = w.getColId();
          return f.delete(x), x;
        }).concat(d)
      ), g = [], v = {};
      let m = 0;
      for (let w = 0; w < c.length; w++) {
        const x = c[w].getColId();
        p.has(x) && (g.push(x), v[x] = m++);
      }
      let y = 1e3, C = !1, S = 0;
      const b = (w) => {
        const x = v[w];
        for (let R = S; R < x; R++) {
          const _ = g[R];
          f.has(_) && (i[_][l] = y++, f.delete(_));
        }
        S = x;
      };
      o.forEach((w) => {
        const x = w.getColId();
        if (h.has(x))
          b(x), i[x][l] = y++;
        else {
          const R = w.getColDef();
          (R[l] === null || R[l] === void 0 && R[u] == null) && (C || (R[a] || R[a] === void 0 && R[s] ? b(x) : (f.forEach((P) => {
            i[P][l] = y + v[P];
          }), y += g.length, C = !0)), r[x] || (r[x] = { colId: x }), r[x][l] = y++);
        }
      });
    };
    return n(
      e,
      this.rowGroupCols,
      "rowGroup",
      "initialRowGroup",
      "rowGroupIndex",
      "initialRowGroupIndex"
    ), n(
      t,
      this.pivotCols,
      "pivot",
      "initialPivot",
      "pivotIndex",
      "initialPivotIndex"
    ), Object.values(r);
  }
}, fBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnApplyStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher, this.sortController = e.sortController, this.columnGetStateService = e.columnGetStateService, this.funcColsService = e.funcColsService, this.visibleColsService = e.visibleColsService, this.columnAnimationService = e.columnAnimationService, this.pivotResultColsService = e.pivotResultColsService;
  }
  applyColumnState(e, t) {
    const r = this.columnModel.getColDefCols() || [];
    if (Wn(r))
      return !1;
    if (e && e.state && !e.state.forEach)
      return Te(
        "applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state."
      ), !1;
    const n = this.funcColsService.getModifyColumnsNoEventsCallbacks(), i = (s, l, u) => {
      const c = this.compareColumnStatesAndDispatchEvents(t), d = l.slice(), h = {}, f = {}, p = [], g = [];
      let v = 0;
      const m = this.funcColsService.getRowGroupColumns().slice(), y = this.funcColsService.getPivotColumns().slice();
      s.forEach((w) => {
        const x = w.colId || "";
        if (x.startsWith(em)) {
          p.push(w), g.push(w);
          return;
        }
        const _ = u(x);
        _ ? (this.syncColumnWithStateItem(
          _,
          w,
          e.defaultState,
          h,
          f,
          !1,
          t,
          n
        ), _i(d, _)) : (g.push(w), v += 1);
      });
      const C = (w) => this.syncColumnWithStateItem(
        w,
        null,
        e.defaultState,
        h,
        f,
        !1,
        t,
        n
      );
      d.forEach(C), this.funcColsService.sortRowGroupColumns(
        BH.bind(this, h, m)
      ), this.funcColsService.sortPivotColumns(BH.bind(this, f, y)), this.columnModel.refreshCols();
      const b = (this.columnModel.getAutoCols() || []).slice();
      return p.forEach((w) => {
        const x = this.columnModel.getAutoCol(w.colId);
        _i(b, x), this.syncColumnWithStateItem(
          x,
          w,
          e.defaultState,
          null,
          null,
          !0,
          t,
          n
        );
      }), b.forEach(C), this.orderLiveColsLikeState(e), this.visibleColsService.refresh(t), this.eventDispatcher.everythingChanged(t), c(), { unmatchedAndAutoStates: g, unmatchedCount: v };
    };
    this.columnAnimationService.start();
    let { unmatchedAndAutoStates: o, unmatchedCount: a } = i(
      e.state || [],
      r,
      (s) => this.columnModel.getColDefCol(s)
    );
    if (o.length > 0 || ke(e.defaultState)) {
      const s = this.pivotResultColsService.getPivotResultCols(), l = s == null ? void 0 : s.list;
      a = i(
        o,
        l || [],
        (u) => this.pivotResultColsService.getPivotResultCol(u)
      ).unmatchedCount;
    }
    return this.columnAnimationService.finish(), a === 0;
  }
  resetColumnState(e) {
    const t = this.columnModel.getColDefCols();
    if (Wn(t))
      return;
    const r = this.columnModel.getColDefColTree(), n = nI(r), i = [];
    let o = 1e3, a = 1e3, s = [];
    const l = this.columnModel.getAutoCols();
    l && (s = s.concat(l)), n && (s = s.concat(n)), s.forEach((u) => {
      const c = this.getColumnStateFromColDef(u);
      dr(c.rowGroupIndex) && c.rowGroup && (c.rowGroupIndex = o++), dr(c.pivotIndex) && c.pivot && (c.pivotIndex = a++), i.push(c);
    }), this.applyColumnState({ state: i, applyOrder: !0 }, e);
  }
  getColumnStateFromColDef(e) {
    const t = (p, g) => p ?? g ?? null, r = e.getColDef(), n = t(r.sort, r.initialSort), i = t(r.sortIndex, r.initialSortIndex), o = t(r.hide, r.initialHide), a = t(r.pinned, r.initialPinned), s = t(r.width, r.initialWidth), l = t(r.flex, r.initialFlex);
    let u = t(
      r.rowGroupIndex,
      r.initialRowGroupIndex
    ), c = t(r.rowGroup, r.initialRowGroup);
    u == null && (c == null || c == !1) && (u = null, c = null);
    let d = t(r.pivotIndex, r.initialPivotIndex), h = t(r.pivot, r.initialPivot);
    d == null && (h == null || h == !1) && (d = null, h = null);
    const f = t(r.aggFunc, r.initialAggFunc);
    return {
      colId: e.getColId(),
      sort: n,
      sortIndex: i,
      hide: o,
      pinned: a,
      width: s,
      flex: l,
      rowGroup: c,
      rowGroupIndex: u,
      pivot: h,
      pivotIndex: d,
      aggFunc: f
    };
  }
  syncColumnWithStateItem(e, t, r, n, i, o, a, s) {
    if (!e)
      return;
    const l = (S, b) => {
      const w = {
        value1: void 0,
        value2: void 0
      };
      let x = !1;
      return t && (t[S] !== void 0 && (w.value1 = t[S], x = !0), ke(b) && t[b] !== void 0 && (w.value2 = t[b], x = !0)), !x && r && (r[S] !== void 0 && (w.value1 = r[S]), ke(b) && r[b] !== void 0 && (w.value2 = r[b])), w;
    }, u = l("hide").value1;
    u !== void 0 && e.setVisible(!u, a);
    const c = l("pinned").value1;
    c !== void 0 && e.setPinned(c);
    const d = e.getColDef().minWidth ?? NY, h = l("flex").value1;
    if (h !== void 0 && e.setFlex(h), h == null) {
      const S = l("width").value1;
      S != null && d != null && S >= d && e.setActualWidth(S, a);
    }
    const f = l("sort").value1;
    f !== void 0 && (f === "desc" || f === "asc" ? e.setSort(f, a) : e.setSort(void 0, a));
    const p = l("sortIndex").value1;
    if (p !== void 0 && e.setSortIndex(p), o || !e.isPrimary())
      return;
    const g = l("aggFunc").value1;
    g !== void 0 && (typeof g == "string" ? (e.setAggFunc(g), e.isValueActive() || (e.setValueActive(!0, a), s.addValueCol(e))) : (ke(g) && Te(
      "stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON."
    ), e.isValueActive() && (e.setValueActive(!1, a), s.removeValueCol(e))));
    const { value1: v, value2: m } = l("rowGroup", "rowGroupIndex");
    (v !== void 0 || m !== void 0) && (typeof m == "number" || v ? (e.isRowGroupActive() || (e.setRowGroupActive(!0, a), s.addGroupCol(e)), n && typeof m == "number" && (n[e.getId()] = m)) : e.isRowGroupActive() && (e.setRowGroupActive(!1, a), s.removeGroupCol(e)));
    const { value1: y, value2: C } = l("pivot", "pivotIndex");
    (y !== void 0 || C !== void 0) && (typeof C == "number" || y ? (e.isPivotActive() || (e.setPivotActive(!0, a), s.addPivotCol(e)), i && typeof C == "number" && (i[e.getId()] = C)) : e.isPivotActive() && (e.setPivotActive(!1, a), s.removePivotCol(e)));
  }
  orderLiveColsLikeState(e) {
    if (!e.applyOrder || !e.state)
      return;
    const t = [];
    e.state.forEach((r) => {
      r.colId != null && t.push(r.colId);
    }), this.columnModel.sortColsLikeKeys(t);
  }
  // calculates what events to fire between column state changes. gets used when:
  // a) apply column state
  // b) apply new column definitions (so changes from old cols)
  compareColumnStatesAndDispatchEvents(e) {
    const t = {
      rowGroupColumns: this.funcColsService.getRowGroupColumns().slice(),
      pivotColumns: this.funcColsService.getPivotColumns().slice(),
      valueColumns: this.funcColsService.getValueColumns().slice()
    }, r = this.columnGetStateService.getColumnState(), n = {};
    return r.forEach((i) => {
      n[i.colId] = i;
    }), () => {
      const i = this.columnModel.getAllCols(), o = (g, v, m, y) => {
        const C = v.map(y), S = m.map(y);
        if (fd(C, S))
          return;
        const w = new Set(v);
        m.forEach((_) => {
          w.delete(_) || w.add(_);
        });
        const x = [...w], R = {
          type: g,
          columns: x,
          column: x.length === 1 ? x[0] : null,
          source: e
        };
        this.eventService.dispatchEvent(R);
      }, a = (g) => {
        const v = [];
        return i.forEach((m) => {
          const y = n[m.getColId()];
          y && g(y, m) && v.push(m);
        }), v;
      }, s = (g) => g.getColId();
      o(
        "columnRowGroupChanged",
        t.rowGroupColumns,
        this.funcColsService.getRowGroupColumns(),
        s
      ), o(
        "columnPivotChanged",
        t.pivotColumns,
        this.funcColsService.getPivotColumns(),
        s
      );
      const u = a((g, v) => {
        const m = g.aggFunc != null, y = m != v.isValueActive(), C = m && g.aggFunc != v.getAggFunc();
        return y || C;
      });
      u.length > 0 && this.eventDispatcher.columnChanged("columnValueChanged", u, e);
      const c = (g, v) => g.width != v.getActualWidth();
      this.eventDispatcher.columnResized(a(c), !0, e);
      const d = (g, v) => g.pinned != v.getPinned();
      this.eventDispatcher.columnPinned(a(d), e);
      const h = (g, v) => g.hide == v.isVisible();
      this.eventDispatcher.columnVisible(a(h), e);
      const p = a((g, v) => g.sort != v.getSort() || g.sortIndex != v.getSortIndex());
      p.length > 0 && this.sortController.dispatchSortChangedEvents(e, p), this.normaliseColumnMovedEventForColumnState(r, e);
    };
  }
  normaliseColumnMovedEventForColumnState(e, t) {
    const r = this.columnGetStateService.getColumnState(), n = {};
    r.forEach((l) => n[l.colId] = l);
    const i = {};
    e.forEach((l) => {
      n[l.colId] && (i[l.colId] = !0);
    });
    const o = e.filter((l) => i[l.colId]), a = r.filter((l) => i[l.colId]), s = [];
    a.forEach((l, u) => {
      const c = o && o[u];
      if (c && c.colId !== l.colId) {
        const d = this.columnModel.getCol(c.colId);
        d && s.push(d);
      }
    }), s.length && this.eventDispatcher.columnMoved({ movedColumns: s, source: t, finished: !0 });
  }
}, BH = (e, t, r, n) => {
  const i = e[r.getId()], o = e[n.getId()], a = i != null, s = o != null;
  if (a && s)
    return i - o;
  if (a)
    return -1;
  if (s)
    return 1;
  const l = t.indexOf(r), u = t.indexOf(n), c = l >= 0, d = u >= 0;
  return c && d ? l - u : c ? -1 : 1;
}, pBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnMoveService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnAnimationService = e.columnAnimationService, this.eventDispatcher = e.columnEventDispatcher;
  }
  moveColumnByIndex(e, t, r) {
    const n = this.columnModel.getCols();
    if (!n)
      return;
    const i = n[e];
    this.moveColumns([i], t, r);
  }
  moveColumns(e, t, r, n = !0) {
    const i = this.columnModel.getCols();
    if (!i)
      return;
    if (this.columnAnimationService.start(), t > i.length - e.length) {
      Te("tried to insert columns in invalid location, toIndex = ", t), Te("remember that you should not count the moving columns when calculating the new index");
      return;
    }
    const o = this.columnModel.getColsForKeys(e);
    this.doesMovePassRules(o, t) && (this.columnModel.moveInCols(o, t, r), this.eventDispatcher.columnMoved({ movedColumns: o, source: r, toIndex: t, finished: n }), this.columnAnimationService.finish());
  }
  doesMovePassRules(e, t) {
    const r = this.getProposedColumnOrder(e, t);
    return this.doesOrderPassRules(r);
  }
  doesOrderPassRules(e) {
    return !(!this.doesMovePassMarryChildren(e) || !this.doesMovePassLockedPositions(e));
  }
  getProposedColumnOrder(e, t) {
    const n = this.columnModel.getCols().slice();
    return AY(n, e, t), n;
  }
  doesMovePassLockedPositions(e) {
    const t = (o) => o ? o === "left" || o === !0 ? -1 : 1 : 0, r = this.gos.get("enableRtl");
    let n = r ? 1 : -1, i = !0;
    return e.forEach((o) => {
      const a = t(o.getColDef().lockPosition);
      r ? a > n && (i = !1) : a < n && (i = !1), n = a;
    }), i;
  }
  doesMovePassMarryChildren(e) {
    let t = !0;
    const r = this.columnModel.getColTree();
    return ol(null, r, (n) => {
      if (!Ri(n))
        return;
      const i = n, o = i.getColGroupDef();
      if (!(o && o.marryChildren))
        return;
      const s = [];
      i.getLeafColumns().forEach((h) => {
        const f = e.indexOf(h);
        s.push(f);
      });
      const l = Math.max.apply(Math, s), u = Math.min.apply(Math, s), c = l - u, d = i.getLeafColumns().length - 1;
      c > d && (t = !1);
    }), t;
  }
  placeLockedColumns(e) {
    const t = [], r = [], n = [];
    return e.forEach((o) => {
      const a = o.getColDef().lockPosition;
      a === "right" ? n.push(o) : a === "left" || a === !0 ? t.push(o) : r.push(o);
    }), this.gos.get("enableRtl") ? [...n, ...r, ...t] : [...t, ...r, ...n];
  }
}, gBe = /[&<>"']/g, vBe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function hs(e, t) {
  if (e == null)
    return null;
  const r = e.toString().toString();
  return t ? r : r.replace(gBe, (n) => vBe[n]);
}
function mBe(e) {
  if (!e || e == null)
    return null;
  const t = /([a-z])([A-Z])/g, r = /([A-Z]+)([A-Z])([a-z])/g;
  return e.replace(t, "$1 $2").replace(r, "$1 $2$3").replace(/\./g, " ").split(" ").map((i) => i.substring(0, 1).toUpperCase() + (i.length > 1 ? i.substring(1, i.length) : "")).join(" ");
}
var yBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnNameService";
  }
  wireBeans(e) {
    this.expressionService = e.expressionService, this.funcColsService = e.funcColsService, this.columnModel = e.columnModel;
  }
  getDisplayNameForColumn(e, t, r = !1) {
    if (!e)
      return null;
    const n = this.getHeaderName(e.getColDef(), e, null, null, t);
    return r ? this.wrapHeaderNameWithAggFunc(e, n) : n;
  }
  getDisplayNameForProvidedColumnGroup(e, t, r) {
    const n = t ? t.getColGroupDef() : null;
    return n ? this.getHeaderName(n, null, e, t, r) : null;
  }
  getDisplayNameForColumnGroup(e, t) {
    return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(e, t, r, n, i) {
    const o = e.headerValueGetter;
    if (o) {
      const a = this.gos.addGridCommonParams({
        colDef: e,
        column: t,
        columnGroup: r,
        providedColumnGroup: n,
        location: i
      });
      return typeof o == "function" ? o(a) : typeof o == "string" ? this.expressionService.evaluate(o, a) : (Te("headerValueGetter must be a function or a string"), "");
    } else {
      if (e.headerName != null)
        return e.headerName;
      if (e.field)
        return mBe(e.field);
    }
    return "";
  }
  wrapHeaderNameWithAggFunc(e, t) {
    if (this.gos.get("suppressAggFuncInHeader"))
      return t;
    const r = e.getColDef().pivotValueColumn, n = ke(r);
    let i = null, o;
    if (n) {
      const a = this.funcColsService.getValueColumns(), s = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && a.length === 1, l = e.getColDef().pivotTotalColumnIds !== void 0;
      if (s && !l)
        return t;
      i = r ? r.getAggFunc() : null, o = !0;
    } else {
      const a = e.isValueActive(), s = this.columnModel.isPivotMode() || !this.funcColsService.isRowGroupEmpty();
      a && s ? (i = e.getAggFunc(), o = !0) : o = !1;
    }
    if (o) {
      const a = typeof i == "string" ? i : "func";
      return `${this.localeService.getLocaleTextFunc()(a, a)}(${t})`;
    }
    return t;
  }
}, CBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "pivotResultColsService";
  }
  wireBeans(e) {
    this.context = e.context, this.columnModel = e.columnModel, this.columnFactory = e.columnFactory, this.visibleColsService = e.visibleColsService;
  }
  destroy() {
    var e;
    yh(this.context, (e = this.pivotResultCols) == null ? void 0 : e.tree), super.destroy();
  }
  isPivotResultColsPresent() {
    return this.pivotResultCols != null;
  }
  lookupPivotResultCol(e, t) {
    if (this.pivotResultCols == null)
      return null;
    const r = this.columnModel.getColDefCol(t);
    let n = null;
    return this.pivotResultCols.list.forEach((i) => {
      const o = i.getColDef().pivotKeys, a = i.getColDef().pivotValueColumn;
      fd(o, e) && a === r && (n = i);
    }), n;
  }
  getPivotResultCols() {
    return this.pivotResultCols;
  }
  getPivotResultCol(e) {
    return this.pivotResultCols ? this.columnModel.getColFromCollection(e, this.pivotResultCols) : null;
  }
  setPivotResultCols(e, t) {
    var r, n;
    if (this.columnModel.isReady() && !(e == null && this.pivotResultCols == null)) {
      if (e) {
        this.processPivotResultColDef(e);
        const i = this.columnFactory.createColumnTree(
          e,
          !1,
          ((r = this.pivotResultCols) == null ? void 0 : r.tree) || this.previousPivotResultCols || void 0,
          t
        );
        yh(this.context, (n = this.pivotResultCols) == null ? void 0 : n.tree, i.columnTree);
        const o = i.columnTree, a = i.treeDept, s = nI(o), l = {};
        this.pivotResultCols = { tree: o, treeDepth: a, list: s, map: l }, this.pivotResultCols.list.forEach((u) => this.pivotResultCols.map[u.getId()] = u), this.previousPivotResultCols = null;
      } else
        this.previousPivotResultCols = this.pivotResultCols ? this.pivotResultCols.tree : null, this.pivotResultCols = null;
      this.columnModel.refreshCols(), this.visibleColsService.refresh(t);
    }
  }
  processPivotResultColDef(e) {
    const t = this.gos.get("processPivotResultColDef"), r = this.gos.get("processPivotResultColGroupDef");
    if (!t && !r)
      return;
    const n = (i) => {
      i.forEach((o) => {
        if (ke(o.children)) {
          const s = o;
          r && r(s), n(s.children);
        } else
          t && t(o);
      });
    };
    e && n(e);
  }
}, SBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnSizeService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnViewportService = e.columnViewportService, this.eventDispatcher = e.columnEventDispatcher, this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService;
  }
  setColumnWidths(e, t, r, n) {
    const i = [];
    e.forEach((o) => {
      const a = this.columnModel.getColDefCol(o.key) || this.columnModel.getCol(o.key);
      if (!a)
        return;
      if (i.push({
        width: o.newWidth,
        ratios: [1],
        columns: [a]
      }), this.gos.get("colResizeDefault") === "shift" && (t = !t), t) {
        const l = this.visibleColsService.getColAfter(a);
        if (!l)
          return;
        const u = a.getActualWidth() - o.newWidth, c = l.getActualWidth() + u;
        i.push({
          width: c,
          ratios: [1],
          columns: [l]
        });
      }
    }), i.length !== 0 && this.resizeColumnSets({
      resizeSets: i,
      finished: r,
      source: n
    });
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(e) {
    const { resizeSets: t, finished: r, source: n } = e;
    if (!(!t || t.every((c) => this.checkMinAndMaxWidthsForSet(c)))) {
      if (r) {
        const c = t && t.length > 0 ? t[0].columns : null;
        this.eventDispatcher.columnResized(c, r, n);
      }
      return;
    }
    const o = [], a = [];
    t.forEach((c) => {
      const { width: d, columns: h, ratios: f } = c, p = {}, g = {};
      h.forEach((y) => a.push(y));
      let v = !0, m = 0;
      for (; v; ) {
        if (m++, m > 1e3) {
          Er("infinite loop in resizeColumnSets");
          break;
        }
        v = !1;
        const y = [];
        let C = 0, S = d;
        h.forEach((w, x) => {
          if (g[w.getId()])
            S -= p[w.getId()];
          else {
            y.push(w);
            const _ = f[x];
            C += _;
          }
        });
        const b = 1 / C;
        y.forEach((w, x) => {
          const R = x === y.length - 1;
          let _;
          R ? _ = S : (_ = Math.round(f[x] * d * b), S -= _);
          const T = w.getMinWidth(), P = w.getMaxWidth();
          _ < T ? (_ = T, g[w.getId()] = !0, v = !0) : P > 0 && _ > P && (_ = P, g[w.getId()] = !0, v = !0), p[w.getId()] = _;
        });
      }
      h.forEach((y) => {
        const C = p[y.getId()];
        y.getActualWidth() !== C && (y.setActualWidth(C, n), o.push(y));
      });
    });
    const s = o.length > 0;
    let l = [];
    s && (l = this.refreshFlexedColumns({ resizingCols: a, skipSetLeft: !0 }), this.visibleColsService.setLeftValues(n), this.visibleColsService.updateBodyWidths(), this.columnViewportService.checkViewportColumns());
    const u = a.concat(l);
    (s || r) && this.eventDispatcher.columnResized(u, r, n, l);
  }
  checkMinAndMaxWidthsForSet(e) {
    const { columns: t, width: r } = e;
    let n = 0, i = 0, o = !0;
    t.forEach((l) => {
      const u = l.getMinWidth();
      n += u || 0;
      const c = l.getMaxWidth();
      c > 0 ? i += c : o = !1;
    });
    const a = r >= n, s = !o || r <= i;
    return a && s;
  }
  refreshFlexedColumns(e = {}) {
    const t = e.source ? e.source : "flex";
    if (e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth), !this.flexViewportWidth)
      return [];
    const r = this.visibleColsService.getCenterCols();
    let n = -1;
    if (e.resizingCols) {
      const h = new Set(e.resizingCols);
      for (let f = r.length - 1; f >= 0; f--)
        if (h.has(r[f])) {
          n = f;
          break;
        }
    }
    let i = 0, o = [], a = 0, s = 0;
    for (let h = 0; h < r.length; h++)
      r[h].getFlex() && h > n ? (o.push(r[h]), s += r[h].getFlex(), a += r[h].getMinWidth()) : i += r[h].getActualWidth();
    if (!o.length)
      return [];
    let l = [];
    i + a > this.flexViewportWidth && (o.forEach((h) => h.setActualWidth(h.getMinWidth(), t)), l = o, o = []);
    const u = [];
    let c;
    e:
      for (; ; ) {
        c = this.flexViewportWidth - i;
        const h = c / s;
        for (let f = 0; f < o.length; f++) {
          const p = o[f], g = h * p.getFlex();
          let v = 0;
          const m = p.getMinWidth(), y = p.getMaxWidth();
          if (g < m ? v = m : g > y && (v = y), v) {
            p.setActualWidth(v, t), DY(o, p), s -= p.getFlex(), l.push(p), i += p.getActualWidth();
            continue e;
          }
          u[f] = Math.round(g);
        }
        break;
      }
    let d = c;
    return o.forEach((h, f) => {
      h.setActualWidth(Math.min(u[f], d), t), l.push(h), d -= u[f];
    }), e.skipSetLeft || this.visibleColsService.setLeftValues(t), e.updateBodyWidths && this.visibleColsService.updateBodyWidths(), e.fireResizedEvent && this.eventDispatcher.columnResized(l, !0, t, o), o;
  }
  // called from api
  sizeColumnsToFit(e, t = "sizeColumnsToFit", r, n) {
    var h;
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.sizeColumnsToFit(e, t, r, n));
      return;
    }
    const i = {};
    n && ((h = n == null ? void 0 : n.columnLimits) == null || h.forEach(({ key: f, ...p }) => {
      i[typeof f == "string" ? f : f.getColId()] = p;
    }));
    const o = this.visibleColsService.getAllCols(), a = e === Fs(o);
    if (e <= 0 || !o.length || a)
      return;
    const s = [], l = [];
    o.forEach((f) => {
      f.getColDef().suppressSizeToFit === !0 ? l.push(f) : s.push(f);
    });
    const u = s.slice(0);
    let c = !1;
    const d = (f) => {
      _i(s, f), l.push(f);
    };
    for (s.forEach((f) => {
      f.resetActualWidth(t);
      const p = i == null ? void 0 : i[f.getId()], g = (p == null ? void 0 : p.minWidth) ?? (n == null ? void 0 : n.defaultMinWidth), v = (p == null ? void 0 : p.maxWidth) ?? (n == null ? void 0 : n.defaultMaxWidth), m = f.getActualWidth();
      typeof g == "number" && m < g ? f.setActualWidth(g, t, !0) : typeof v == "number" && m > v && f.setActualWidth(v, t, !0);
    }); !c; ) {
      c = !0;
      const f = e - Fs(l);
      if (f <= 0)
        s.forEach((p) => {
          var v;
          const g = ((v = i == null ? void 0 : i[p.getId()]) == null ? void 0 : v.minWidth) ?? (n == null ? void 0 : n.defaultMinWidth);
          if (typeof g == "number") {
            p.setActualWidth(g, t, !0);
            return;
          }
          p.setMinimum(t);
        });
      else {
        const p = f / Fs(s);
        let g = f;
        for (let v = s.length - 1; v >= 0; v--) {
          const m = s[v], y = i == null ? void 0 : i[m.getId()], C = (y == null ? void 0 : y.minWidth) ?? (n == null ? void 0 : n.defaultMinWidth), S = (y == null ? void 0 : y.maxWidth) ?? (n == null ? void 0 : n.defaultMaxWidth), b = m.getMinWidth(), w = m.getMaxWidth(), x = typeof C == "number" && C > b ? C : b, R = typeof S == "number" && S < w ? S : w;
          let _ = Math.round(m.getActualWidth() * p);
          _ < x ? (_ = x, d(m), c = !1) : _ > R ? (_ = R, d(m), c = !1) : v === 0 && (_ = g), m.setActualWidth(_, t, !0), g -= _;
        }
      }
    }
    u.forEach((f) => {
      f.fireColumnWidthChangedEvent(t);
    }), this.visibleColsService.setLeftValues(t), this.visibleColsService.updateBodyWidths(), !r && this.eventDispatcher.columnResized(u, !0, t);
  }
  applyAutosizeStrategy() {
    const e = this.gos.get("autoSizeStrategy");
    if (!e)
      return;
    const { type: t } = e;
    setTimeout(() => {
      if (t === "fitGridWidth") {
        const { columnLimits: r, defaultMinWidth: n, defaultMaxWidth: i } = e, o = r == null ? void 0 : r.map(({ colId: a, minWidth: s, maxWidth: l }) => ({
          key: a,
          minWidth: s,
          maxWidth: l
        }));
        this.ctrlsService.getGridBodyCtrl().sizeColumnsToFit({
          defaultMinWidth: n,
          defaultMaxWidth: i,
          columnLimits: o
        });
      } else t === "fitProvidedWidth" && this.sizeColumnsToFit(e.width, "sizeColumnsToFit");
    });
  }
};
function VY(e, t) {
  return e + "_" + t;
}
function Sn(e) {
  return e instanceof BY;
}
var BY = class extends Se {
  constructor(e, t, r, n) {
    super(), this.isColumn = !1, this.displayedChildren = [], this.parent = null, this.groupId = t, this.partId = r, this.providedColumnGroup = e, this.pinned = n;
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null, this.children = null, this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  setParent(e) {
    this.parent = e;
  }
  getUniqueId() {
    return VY(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const e = this.getProvidedColumnGroup().getLeafColumns();
    return !e || e.length === 0 ? !1 : e.every((t) => t.isMoving());
  }
  checkLeft() {
    if (this.displayedChildren.forEach((e) => {
      Sn(e) && e.checkLeft();
    }), this.displayedChildren.length > 0)
      if (this.gos.get("enableRtl")) {
        const t = gr(this.displayedChildren).getLeft();
        this.setLeft(t);
      } else {
        const e = this.displayedChildren[0].getLeft();
        this.setLeft(e);
      }
    else
      this.setLeft(null);
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(e) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchLocalEvent({ type: "leftChanged" }));
  }
  getPinned() {
    return this.pinned;
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  getActualWidth() {
    let e = 0;
    return this.displayedChildren && this.displayedChildren.forEach((t) => {
      e += t.getActualWidth();
    }), e;
  }
  isResizable() {
    if (!this.displayedChildren)
      return !1;
    let e = !1;
    return this.displayedChildren.forEach((t) => {
      t.isResizable() && (e = !0);
    }), e;
  }
  getMinWidth() {
    let e = 0;
    return this.displayedChildren.forEach((t) => {
      e += t.getMinWidth();
    }), e;
  }
  addChild(e) {
    this.children || (this.children = []), this.children.push(e);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  getDisplayedLeafColumns() {
    const e = [];
    return this.addDisplayedLeafColumns(e), e;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(e) {
    this.providedColumnGroup.setExpanded(e);
  }
  addDisplayedLeafColumns(e) {
    this.displayedChildren.forEach((t) => {
      cu(t) ? e.push(t) : Sn(t) && t.addDisplayedLeafColumns(e);
    });
  }
  addLeafColumns(e) {
    this.children.forEach((t) => {
      cu(t) ? e.push(t) : Sn(t) && t.addLeafColumns(e);
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const e = this.getParent();
    return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let e = this;
    for (; e != null && e.isPadding(); )
      e = e.getParent();
    if (!(e ? e.getProvidedColumnGroup().isExpandable() : !1)) {
      this.displayedChildren = this.children, this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
      return;
    }
    this.children.forEach((r) => {
      if (Sn(r) && (!r.displayedChildren || !r.displayedChildren.length))
        return;
      switch (r.getColumnGroupShow()) {
        case "open":
          e.getProvidedColumnGroup().isExpanded() && this.displayedChildren.push(r);
          break;
        case "closed":
          e.getProvidedColumnGroup().isExpanded() || this.displayedChildren.push(r);
          break;
        default:
          this.displayedChildren.push(r);
          break;
      }
    }), this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
  }
}, $Y = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(e) {
    const t = this.existingIds[e];
    let r;
    return typeof t != "number" ? r = 0 : r = t + 1, this.existingIds[e] = r, r;
  }
}, wBe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "visibleColsService", this.colsAndGroupsMap = {}, this.columnsLeft = [], this.columnsRight = [], this.columnsCenter = [], this.columns = [], this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.bodyWidthDirty = !0;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.columnViewportService = e.columnViewportService, this.eventDispatcher = e.columnEventDispatcher;
  }
  refresh(e, t = !1) {
    t || this.buildTrees(), this.updateOpenClosedVisibilityInColumnGroups(), this.columnsLeft = SE(this.treeLeft), this.columnsCenter = SE(this.treeCenter), this.columnsRight = SE(this.treeRight), this.joinColsAriaOrder(), this.joinCols(), this.setLeftValues(e), this.autoHeightCols = this.columns.filter((r) => r.isAutoHeight()), this.columnSizeService.refreshFlexedColumns(), this.updateBodyWidths(), this.columnViewportService.checkViewportColumns(!1), this.setFirstRightAndLastLeftPinned(e), this.eventDispatcher.visibleCols();
  }
  // after setColumnWidth or updateGroupsAndPresentedCols
  updateBodyWidths() {
    const e = Fs(this.columnsCenter), t = Fs(this.columnsLeft), r = Fs(this.columnsRight);
    if (this.bodyWidthDirty = this.bodyWidth !== e, this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== r) {
      this.bodyWidth = e, this.leftWidth = t, this.rightWidth = r;
      const i = {
        type: "columnContainerWidthChanged"
      };
      this.eventService.dispatchEvent(i);
      const o = {
        type: "displayedColumnsWidthChanged"
      };
      this.eventService.dispatchEvent(o);
    }
  }
  // sets the left pixel position of each column
  setLeftValues(e) {
    this.setLeftValuesOfCols(e), this.setLeftValuesOfGroups();
  }
  setFirstRightAndLastLeftPinned(e) {
    let t, r;
    this.gos.get("enableRtl") ? (t = this.columnsLeft ? this.columnsLeft[0] : null, r = this.columnsRight ? gr(this.columnsRight) : null) : (t = this.columnsLeft ? gr(this.columnsLeft) : null, r = this.columnsRight ? this.columnsRight[0] : null), this.columnModel.getCols().forEach((n) => {
      n.setLastLeftPinned(n === t, e), n.setFirstRightPinned(n === r, e);
    });
  }
  buildTrees() {
    const e = this.columnModel.getColsToShow(), t = e.filter((o) => o.getPinned() == "left"), r = e.filter((o) => o.getPinned() == "right"), n = e.filter((o) => o.getPinned() != "left" && o.getPinned() != "right"), i = new $Y();
    this.treeLeft = this.createGroups({
      columns: t,
      idCreator: i,
      pinned: "left",
      oldDisplayedGroups: this.treeLeft
    }), this.treeRight = this.createGroups({
      columns: r,
      idCreator: i,
      pinned: "right",
      oldDisplayedGroups: this.treeRight
    }), this.treeCenter = this.createGroups({
      columns: n,
      idCreator: i,
      pinned: null,
      oldDisplayedGroups: this.treeCenter
    }), this.updateColsAndGroupsMap();
  }
  clear() {
    this.columnsLeft = [], this.columnsRight = [], this.columnsCenter = [], this.columns = [], this.ariaOrderColumns = [];
  }
  joinColsAriaOrder() {
    const e = this.columnModel.getCols(), t = [], r = [], n = [];
    for (const i of e) {
      const o = i.getPinned();
      o ? o === !0 || o === "left" ? t.push(i) : n.push(i) : r.push(i);
    }
    this.ariaOrderColumns = t.concat(r).concat(n);
  }
  getAriaColIndex(e) {
    let t;
    return Sn(e) ? t = e.getLeafColumns()[0] : t = e, this.ariaOrderColumns.indexOf(t) + 1;
  }
  getAllAutoHeightCols() {
    return this.autoHeightCols;
  }
  setLeftValuesOfGroups() {
    [this.treeLeft, this.treeRight, this.treeCenter].forEach((e) => {
      e.forEach((t) => {
        Sn(t) && t.checkLeft();
      });
    });
  }
  setLeftValuesOfCols(e) {
    if (!this.columnModel.getColDefCols())
      return;
    const r = this.columnModel.getCols().slice(0), n = this.gos.get("enableRtl");
    [this.columnsLeft, this.columnsRight, this.columnsCenter].forEach((i) => {
      if (n) {
        let o = Fs(i);
        i.forEach((a) => {
          o -= a.getActualWidth(), a.setLeft(o, e);
        });
      } else {
        let o = 0;
        i.forEach((a) => {
          a.setLeft(o, e), o += a.getActualWidth();
        });
      }
      WVe(r, i);
    }), r.forEach((i) => {
      i.setLeft(null, e);
    });
  }
  joinCols() {
    this.gos.get("enableRtl") ? this.columns = this.columnsRight.concat(this.columnsCenter).concat(this.columnsLeft) : this.columns = this.columnsLeft.concat(this.columnsCenter).concat(this.columnsRight);
  }
  getColsCenter() {
    return this.columnsCenter;
  }
  getAllTrees() {
    return this.treeLeft && this.treeRight && this.treeCenter ? this.treeLeft.concat(this.treeCenter).concat(this.treeRight) : null;
  }
  // + headerRenderer -> setting pinned body width
  getTreeLeft() {
    return this.treeLeft;
  }
  // + headerRenderer -> setting pinned body width
  getTreeRight() {
    return this.treeRight;
  }
  // + headerRenderer -> setting pinned body width
  getTreeCenter() {
    return this.treeCenter;
  }
  // + csvCreator
  getAllCols() {
    return this.columns;
  }
  // gridPanel -> ensureColumnVisible
  isColDisplayed(e) {
    return this.getAllCols().indexOf(e) >= 0;
  }
  getLeftColsForRow(e) {
    return this.columnModel.isColSpanActive() ? this.getColsForRow(e, this.columnsLeft) : this.columnsLeft;
  }
  getRightColsForRow(e) {
    return this.columnModel.isColSpanActive() ? this.getColsForRow(e, this.columnsRight) : this.columnsRight;
  }
  getColsForRow(e, t, r, n) {
    const i = [];
    let o = null;
    for (let a = 0; a < t.length; a++) {
      const s = t[a], l = t.length - a, u = Math.min(s.getColSpan(e), l), c = [s];
      if (u > 1) {
        const h = u - 1;
        for (let f = 1; f <= h; f++)
          c.push(t[a + f]);
        a += h;
      }
      let d;
      r ? (d = !1, c.forEach((h) => {
        r(h) && (d = !0);
      })) : d = !0, d && (i.length === 0 && o && (n && n(s)) && i.push(o), i.push(s)), o = s;
    }
    return i;
  }
  // used by:
  // + angularGrid -> for setting body width
  // + rowController -> setting main row widths (when inserting and resizing)
  // need to cache this
  getBodyContainerWidth() {
    return this.bodyWidth;
  }
  getContainerWidth(e) {
    switch (e) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  // + rowController -> while inserting rows
  getCenterCols() {
    return this.columnsCenter;
  }
  // + rowController -> while inserting rows
  getLeftCols() {
    return this.columnsLeft;
  }
  getRightCols() {
    return this.columnsRight;
  }
  getColBefore(e) {
    const t = this.getAllCols(), r = t.indexOf(e);
    return r > 0 ? t[r - 1] : null;
  }
  getGroupAtDirection(e, t) {
    const r = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(), n = e.getDisplayedLeafColumns(), i = t === "After" ? gr(n) : n[0], o = `getCol${t}`;
    for (; ; ) {
      const a = this[o](i);
      if (!a)
        return null;
      const s = this.getColGroupAtLevel(a, r);
      if (s !== e)
        return s;
    }
  }
  getColGroupAtLevel(e, t) {
    let r = e.getParent(), n, i;
    for (; n = r.getProvidedColumnGroup().getLevel(), i = r.getPaddingLevel(), !(n + i <= t); )
      r = r.getParent();
    return r;
  }
  isPinningLeft() {
    return this.columnsLeft.length > 0;
  }
  isPinningRight() {
    return this.columnsRight.length > 0;
  }
  updateColsAndGroupsMap() {
    this.colsAndGroupsMap = {};
    const e = (t) => {
      this.colsAndGroupsMap[t.getUniqueId()] = t;
    };
    dc(this.treeCenter, !1, e), dc(this.treeLeft, !1, e), dc(this.treeRight, !1, e);
  }
  isVisible(e) {
    return this.colsAndGroupsMap[e.getUniqueId()] === e;
  }
  updateOpenClosedVisibilityInColumnGroups() {
    const e = this.getAllTrees();
    dc(e, !1, (t) => {
      Sn(t) && t.calculateDisplayedColumns();
    });
  }
  getFirstColumn() {
    const e = this.gos.get("enableRtl"), t = [
      "getLeftCols",
      "getCenterCols",
      "getRightCols"
    ];
    e && t.reverse();
    for (let r = 0; r < t.length; r++) {
      const n = this[t[r]]();
      if (n.length)
        return e ? gr(n) : n[0];
    }
    return null;
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(e, t) {
    if (!e)
      return null;
    if (Sn(e))
      return e;
    const r = this.getAllTrees(), n = typeof t == "number";
    let i = null;
    return dc(r, !1, (o) => {
      if (Sn(o)) {
        const a = o;
        let s;
        n ? s = e === a.getGroupId() && t === a.getPartId() : s = e === a.getGroupId(), s && (i = a);
      }
    }), i;
  }
  // used by:
  // + rowRenderer -> for navigation
  getColAfter(e) {
    const t = this.getAllCols(), r = t.indexOf(e);
    return r < t.length - 1 ? t[r + 1] : null;
  }
  isBodyWidthDirty() {
    return this.bodyWidthDirty;
  }
  setBodyWidthDirty() {
    this.bodyWidthDirty = !0;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getColsLeftWidth() {
    return Fs(this.columnsLeft);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return Fs(this.columnsRight);
  }
  isColAtEdge(e, t) {
    const r = this.getAllCols();
    if (!r.length)
      return !1;
    const n = t === "first";
    let i;
    if (Sn(e)) {
      const o = e.getDisplayedLeafColumns();
      if (!o.length)
        return !1;
      i = n ? o[0] : gr(o);
    } else
      i = e;
    return (n ? r[0] : gr(r)) === i;
  }
  createGroups(e) {
    const { columns: t, idCreator: r, pinned: n, oldDisplayedGroups: i, isStandaloneStructure: o } = e, a = this.mapOldGroupsById(i), s = [];
    let l = t;
    for (; l.length; ) {
      const u = l;
      l = [];
      let c = 0;
      const d = (h) => {
        const f = c;
        c = h;
        const p = u[f], v = (Sn(p) ? p.getProvidedColumnGroup() : p).getOriginalParent();
        if (v == null) {
          for (let y = f; y < h; y++)
            s.push(u[y]);
          return;
        }
        const m = this.createColGroup(
          v,
          r,
          a,
          n,
          o
        );
        for (let y = f; y < h; y++)
          m.addChild(u[y]);
        l.push(m);
      };
      for (let h = 1; h < u.length; h++) {
        const f = u[h], g = (Sn(f) ? f.getProvidedColumnGroup() : f).getOriginalParent(), v = u[c], y = (Sn(v) ? v.getProvidedColumnGroup() : v).getOriginalParent();
        g !== y && d(h);
      }
      c < u.length && d(u.length);
    }
    return o || this.setupParentsIntoCols(s, null), s;
  }
  createColGroup(e, t, r, n, i) {
    const o = e.getGroupId(), a = t.getInstanceIdForKey(o), s = VY(o, a);
    let l = r[s];
    return l && l.getProvidedColumnGroup() !== e && (l = null), ke(l) ? l.reset() : (l = new BY(e, o, a, n), i || this.createBean(l)), l;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(e) {
    const t = {}, r = (n) => {
      n.forEach((i) => {
        if (Sn(i)) {
          const o = i;
          t[i.getUniqueId()] = o, r(o.getChildren());
        }
      });
    };
    return e && r(e), t;
  }
  setupParentsIntoCols(e, t) {
    e.forEach((r) => {
      if (r.setParent(t), Sn(r)) {
        const n = r;
        this.setupParentsIntoCols(n.getChildren(), n);
      }
    });
  }
};
function dc(e, t, r) {
  if (e)
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (Sn(i)) {
        const o = t ? i.getDisplayedChildren() : i.getChildren();
        dc(o, t, r);
      }
      r(i);
    }
}
function SE(e) {
  const t = [];
  return dc(e, !0, (r) => {
    cu(r) && t.push(r);
  }), t;
}
var HY = [
  "columnEverythingChanged",
  "newColumnsLoaded",
  "columnPivotModeChanged",
  "pivotMaxColumnsExceeded",
  "columnRowGroupChanged",
  "expandOrCollapseAll",
  "columnPivotChanged",
  "gridColumnsChanged",
  "columnValueChanged",
  "columnMoved",
  "columnVisible",
  "columnPinned",
  "columnGroupOpened",
  "columnResized",
  "displayedColumnsChanged",
  "virtualColumnsChanged",
  "columnHeaderMouseOver",
  "columnHeaderMouseLeave",
  "columnHeaderClicked",
  "columnHeaderContextMenu",
  "asyncTransactionsFlushed",
  "rowGroupOpened",
  "rowDataUpdated",
  "pinnedRowDataChanged",
  "rangeSelectionChanged",
  "chartCreated",
  "chartRangeSelectionChanged",
  "chartOptionsChanged",
  "chartDestroyed",
  "toolPanelVisibleChanged",
  "toolPanelSizeChanged",
  "modelUpdated",
  "cutStart",
  "cutEnd",
  "pasteStart",
  "pasteEnd",
  "fillStart",
  "fillEnd",
  "rangeDeleteStart",
  "rangeDeleteEnd",
  "undoStarted",
  "undoEnded",
  "redoStarted",
  "redoEnded",
  "cellClicked",
  "cellDoubleClicked",
  "cellMouseDown",
  "cellContextMenu",
  "cellValueChanged",
  "cellEditRequest",
  "rowValueChanged",
  "headerFocused",
  "cellFocused",
  "rowSelected",
  "selectionChanged",
  "tooltipShow",
  "tooltipHide",
  "cellKeyDown",
  "cellMouseOver",
  "cellMouseOut",
  "filterChanged",
  "filterModified",
  "filterOpened",
  "advancedFilterBuilderVisibleChanged",
  "sortChanged",
  "virtualRowRemoved",
  "rowClicked",
  "rowDoubleClicked",
  "gridReady",
  "gridPreDestroyed",
  "gridSizeChanged",
  "viewportChanged",
  "firstDataRendered",
  "dragStarted",
  "dragStopped",
  "rowEditingStarted",
  "rowEditingStopped",
  "cellEditingStarted",
  "cellEditingStopped",
  "bodyScroll",
  "bodyScrollEnd",
  "paginationChanged",
  "componentStateChanged",
  "storeRefreshed",
  "stateUpdated",
  "columnMenuVisibleChanged",
  "contextMenuVisibleChanged",
  "rowDragEnter",
  "rowDragMove",
  "rowDragLeave",
  "rowDragEnd"
], bBe = [
  "scrollbarWidthChanged",
  "keyShortcutChangedCellStart",
  "keyShortcutChangedCellEnd",
  "pinnedHeightChanged",
  "cellFocusCleared",
  "fullWidthRowFocused",
  "checkboxChanged",
  "heightScaleChanged",
  "suppressMovableColumns",
  "suppressMenuHide",
  "suppressFieldDotNotation",
  "columnPanelItemDragStart",
  "columnPanelItemDragEnd",
  "bodyHeightChanged",
  "columnContainerWidthChanged",
  "displayedColumnsWidthChanged",
  "scrollVisibilityChanged",
  "columnHoverChanged",
  "flashCells",
  "paginationPixelOffsetChanged",
  "displayedRowsChanged",
  "leftPinnedWidthChanged",
  "rightPinnedWidthChanged",
  "rowContainerHeightChanged",
  "headerHeightChanged",
  "columnHeaderHeightChanged",
  "gridStylesChanged",
  "storeUpdated",
  "filterDestroyed",
  "rowDataUpdateStarted",
  "rowCountReady",
  "advancedFilterEnabledChanged",
  "dataTypesInferred",
  "fieldValueChanged",
  "fieldPickerValueSelected",
  "richSelectListRowSelected",
  "sideBarUpdated",
  "alignedGridScroll",
  "alignedGridColumn",
  "gridOptionsChanged",
  "chartTitleEdit",
  "recalculateRowBounds",
  "stickyTopOffsetChanged"
], xBe = [...HY, ...bBe], EBe = {
  enableBrowserTooltips: !0,
  tooltipTrigger: !0,
  tooltipMouseTrack: !0,
  tooltipShowMode: !0,
  tooltipInteraction: !0,
  defaultColGroupDef: !0,
  suppressAutoSize: !0,
  skipHeaderOnAutoSize: !0,
  autoSizeStrategy: !0,
  components: !0,
  stopEditingWhenCellsLoseFocus: !0,
  undoRedoCellEditing: !0,
  undoRedoCellEditingLimit: !0,
  excelStyles: !0,
  cacheQuickFilter: !0,
  advancedFilterModel: !0,
  customChartThemes: !0,
  chartThemeOverrides: !0,
  chartToolPanelsDef: !0,
  loadingCellRendererSelector: !0,
  localeText: !0,
  keepDetailRows: !0,
  keepDetailRowsCount: !0,
  detailRowHeight: !0,
  detailRowAutoHeight: !0,
  tabIndex: !0,
  valueCache: !0,
  valueCacheNeverExpires: !0,
  enableCellExpressions: !0,
  suppressTouch: !0,
  suppressAsyncEvents: !0,
  suppressBrowserResizeObserver: !0,
  suppressPropertyNamesCheck: !0,
  debug: !0,
  loadingOverlayComponent: !0,
  suppressLoadingOverlay: !0,
  noRowsOverlayComponent: !0,
  paginationPageSizeSelector: !0,
  paginateChildRows: !0,
  pivotPanelShow: !0,
  pivotSuppressAutoColumn: !0,
  suppressExpandablePivotGroups: !0,
  aggFuncs: !0,
  suppressAggFuncInHeader: !0,
  removePivotHeaderRowWhenSingleValueColumn: !0,
  allowShowChangeAfterFilter: !0,
  ensureDomOrder: !0,
  enableRtl: !0,
  suppressColumnVirtualisation: !0,
  suppressMaxRenderedRowRestriction: !0,
  suppressRowVirtualisation: !0,
  rowDragText: !0,
  suppressGroupMaintainValueType: !0,
  groupLockGroupColumns: !0,
  rowGroupPanelSuppressSort: !0,
  suppressGroupRowsSticky: !0,
  rowModelType: !0,
  cacheOverflowSize: !0,
  infiniteInitialRowCount: !0,
  serverSideInitialRowCount: !0,
  suppressServerSideInfiniteScroll: !0,
  maxBlocksInCache: !0,
  maxConcurrentDatasourceRequests: !0,
  blockLoadDebounceMillis: !0,
  serverSideOnlyRefreshFilteredGroups: !0,
  serverSidePivotResultFieldSeparator: !0,
  viewportRowModelPageSize: !0,
  viewportRowModelBufferSize: !0,
  debounceVerticalScrollbar: !0,
  suppressAnimationFrame: !0,
  suppressPreventDefaultOnMouseWheel: !0,
  scrollbarWidth: !0,
  icons: !0,
  suppressRowTransform: !0,
  gridId: !0,
  enableGroupEdit: !0,
  initialState: !0,
  processUnpinnedColumns: !0,
  createChartContainer: !0,
  getLocaleText: !0,
  getRowId: !0,
  reactiveCustomComponents: !0,
  columnMenu: !0
}, ui = class {
};
ui.STRING_PROPERTIES = [
  "rowSelection",
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "groupDisplayType",
  "treeDataDisplayType",
  "colResizeDefault",
  "tooltipTrigger",
  "serverSidePivotResultFieldSeparator",
  "columnMenu",
  "tooltipShowMode",
  "grandTotalRow"
];
ui.OBJECT_PROPERTIES = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "statusBar",
  "sideBar",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions",
  "advancedFilterModel",
  "advancedFilterParent",
  "advancedFilterBuilderParams",
  "initialState",
  "autoSizeStrategy"
];
ui.ARRAY_PROPERTIES = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass",
  "paginationPageSizeSelector"
];
ui.NUMBER_PROPERTIES = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "groupLockGroupColumns",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "pivotDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDelay",
  "cellFadeDelay",
  "cellFlashDuration",
  "cellFadeDuration",
  "tabIndex",
  "pivotMaxGeneratedColumns"
];
ui.BOOLEAN_PROPERTIES = [
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHeaderFocus",
  "suppressHorizontalScroll",
  "groupSelectsChildren",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupIncludeTotalFooter",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressColumnMoveAnimation",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "suppressAsyncEvents",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "enableCellChangeFlash",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "includeHiddenColumnsInAdvancedFilter",
  "suppressMultiRangeSelection",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "tooltipInteraction",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideSortAllLevels",
  "serverSideEnableClientSideSort",
  "serverSideOnlyRefreshFilteredGroups",
  "serverSideSortOnServer",
  "serverSideFilterOnServer",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "maintainColumnOrder",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressCutToClipboard",
  "suppressServerSideInfiniteScroll",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "enableAdvancedFilter",
  "masterDetail",
  "treeData",
  "suppressGroupMaintainValueType",
  "reactiveCustomComponents",
  "applyQuickFilterBeforePivotOrAgg",
  "suppressServerSideFullWidthLoadingRow",
  "suppressAdvancedFilterEval",
  "loading"
];
ui.OTHER_PROPERTIES = ["suppressStickyTotalRow"];
ui.FUNCTION_PROPERTIES = [
  "doesExternalFilterPass",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer",
  "quickFilterParser",
  "quickFilterMatcher",
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "focusGridInnerElement",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processUnpinnedColumns",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "groupIncludeFooter",
  "loadingCellRendererSelector",
  "getRowId",
  "groupAggFiltering",
  "chartMenuItems",
  "groupTotalRow"
];
ui.ALL_PROPERTIES = [
  ...ui.ARRAY_PROPERTIES,
  ...ui.OBJECT_PROPERTIES,
  ...ui.STRING_PROPERTIES,
  ...ui.NUMBER_PROPERTIES,
  ...ui.FUNCTION_PROPERTIES,
  ...ui.BOOLEAN_PROPERTIES,
  ...ui.OTHER_PROPERTIES
];
var hv = ui, qo = class {
  static getCallbackForEvent(t) {
    return !t || t.length < 2 ? t : "on" + t[0].toUpperCase() + t.substring(1);
  }
};
qo.VUE_OMITTED_PROPERTY = "AG-VUE-OMITTED-PROPERTY";
qo.PUBLIC_EVENTS = HY;
qo.EVENT_CALLBACKS = xBe.map((e) => qo.getCallbackForEvent(e));
qo.BOOLEAN_PROPERTIES = hv.BOOLEAN_PROPERTIES;
qo.ALL_PROPERTIES = hv.ALL_PROPERTIES;
qo.ALL_PROPERTIES_AND_CALLBACKS = [...qo.ALL_PROPERTIES, ...qo.EVENT_CALLBACKS];
qo.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set(qo.ALL_PROPERTIES_AND_CALLBACKS);
var fv = qo;
function RBe(e, t) {
  typeof e != "object" && (e = {});
  const r = { ...e };
  return fv.ALL_PROPERTIES_AND_CALLBACKS.forEach((i) => {
    const o = t[i];
    typeof o < "u" && o !== fv.VUE_OMITTED_PROPERTY && (r[i] = o);
  }), r;
}
function _Be(e, t) {
  if (!e)
    return;
  const r = {};
  let n = !1;
  if (Object.keys(e).filter((a) => fv.ALL_PROPERTIES_AND_CALLBACKS_SET.has(a)).forEach((a) => {
    r[a] = e[a], n = !0;
  }), !n)
    return;
  const i = {
    type: "gridOptionsChanged",
    options: r
  };
  t.dispatchEvent(i);
  const o = {
    type: "componentStateChanged"
  };
  wa(r, (a, s) => {
    o[a] = s;
  }), t.dispatchEvent(o);
}
var tm = class {
  constructor(e) {
    this.cssClassStates = {}, this.getGui = e;
  }
  addCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((n) => this.addCssClass(n));
      return;
    }
    if (this.cssClassStates[e] !== !0 && e.length) {
      const n = this.getGui();
      n && n.classList.add(e), this.cssClassStates[e] = !0;
    }
  }
  removeCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((n) => this.removeCssClass(n));
      return;
    }
    if (this.cssClassStates[e] !== !1 && e.length) {
      const n = this.getGui();
      n && n.classList.remove(e), this.cssClassStates[e] = !1;
    }
  }
  containsCssClass(e) {
    const t = this.getGui();
    return t ? t.classList.contains(e) : !1;
  }
  addOrRemoveCssClass(e, t) {
    if (!e)
      return;
    if (e.indexOf(" ") >= 0) {
      const n = (e || "").split(" ");
      if (n.length > 1) {
        n.forEach((i) => this.addOrRemoveCssClass(i, t));
        return;
      }
    }
    if (this.cssClassStates[e] !== t && e.length) {
      const n = this.getGui();
      n && n.classList.toggle(e, t), this.cssClassStates[e] = t;
    }
  }
};
function cl(e, t, r) {
  r == null || typeof r == "string" && r == "" ? GY(e, t) : xs(e, t, r);
}
function xs(e, t, r) {
  e.setAttribute(zY(t), r.toString());
}
function GY(e, t) {
  e.removeAttribute(zY(t));
}
function zY(e) {
  return `aria-${e}`;
}
function Na(e, t) {
  t ? e.setAttribute("role", t) : e.removeAttribute("role");
}
function TBe(e) {
  let t;
  return e === "asc" ? t = "ascending" : e === "desc" ? t = "descending" : e === "mixed" ? t = "other" : t = "none", t;
}
function PBe(e) {
  return e.getAttribute("aria-label");
}
function tf(e, t) {
  cl(e, "label", t);
}
function pv(e, t) {
  cl(e, "labelledby", t);
}
function WY(e, t) {
  cl(e, "live", t);
}
function MBe(e, t) {
  cl(e, "atomic", t);
}
function DBe(e, t) {
  cl(e, "relevant", t);
}
function ABe(e, t) {
  cl(e, "disabled", t);
}
function iI(e, t) {
  cl(e, "hidden", t);
}
function eS(e, t) {
  xs(e, "expanded", t);
}
function IBe(e, t) {
  xs(e, "setsize", t);
}
function OBe(e, t) {
  xs(e, "posinset", t);
}
function LBe(e, t) {
  xs(e, "rowcount", t);
}
function FBe(e, t) {
  xs(e, "rowindex", t);
}
function NBe(e, t) {
  xs(e, "colcount", t);
}
function jY(e, t) {
  xs(e, "colindex", t);
}
function kBe(e, t) {
  xs(e, "colspan", t);
}
function VBe(e, t) {
  xs(e, "sort", t);
}
function BBe(e) {
  GY(e, "sort");
}
function tS(e, t) {
  cl(e, "selected", t);
}
function $Be(e, t) {
  cl(e, "controls", t.id), pv(t, e.id);
}
function oI(e, t) {
  return t === void 0 ? e("ariaIndeterminate", "indeterminate") : t === !0 ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked");
}
var wE, Oy, bE, xE, EE, RE, aP, sP;
function al() {
  return wE === void 0 && (wE = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), wE;
}
function UY() {
  if (Oy === void 0)
    if (al()) {
      const e = navigator.userAgent.match(/version\/(\d+)/i);
      e && (Oy = e[1] != null ? parseFloat(e[1]) : 0);
    } else
      Oy = 0;
  return Oy;
}
function aI() {
  if (bE === void 0) {
    const e = window;
    bE = !!e.chrome && (!!e.chrome.webstore || !!e.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return bE;
}
function KY() {
  return xE === void 0 && (xE = /(firefox)/i.test(navigator.userAgent)), xE;
}
function YY() {
  return EE === void 0 && (EE = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), EE;
}
function xu() {
  return RE === void 0 && (RE = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), RE;
}
function $H() {
  return !al() || UY() >= 15;
}
function lP(e) {
  if (!e)
    return null;
  const t = e.tabIndex, r = e.getAttribute("tabIndex");
  return t === -1 && (r === null || r === "" && !KY()) ? null : t.toString();
}
function HBe() {
  if (!document.body)
    return -1;
  let e = 1e6;
  const t = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9, r = document.createElement("div");
  for (document.body.appendChild(r); ; ) {
    const n = e * 2;
    if (r.style.height = n + "px", n > t || r.clientHeight !== n)
      break;
    e = n;
  }
  return document.body.removeChild(r), e;
}
function GBe() {
  var e, t;
  return ((e = document.body) == null ? void 0 : e.clientWidth) ?? (window.innerHeight || ((t = document.documentElement) == null ? void 0 : t.clientWidth) || -1);
}
function zBe() {
  var e, t;
  return ((e = document.body) == null ? void 0 : e.clientHeight) ?? (window.innerHeight || ((t = document.documentElement) == null ? void 0 : t.clientHeight) || -1);
}
function WBe() {
  return sP == null && qY(), sP;
}
function qY() {
  const e = document.body, t = document.createElement("div");
  t.style.width = t.style.height = "100px", t.style.opacity = "0", t.style.overflow = "scroll", t.style.msOverflowStyle = "scrollbar", t.style.position = "absolute", e.appendChild(t);
  let r = t.offsetWidth - t.clientWidth;
  r === 0 && t.clientWidth === 0 && (r = null), t.parentNode && t.parentNode.removeChild(t), r != null && (sP = r, aP = r === 0);
}
function XY() {
  return aP == null && qY(), aP;
}
var Ly, jBe = "[tabindex], input, select, button, textarea, [href]", ZY = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function sI(e) {
  const t = Element.prototype.matches || Element.prototype.msMatchesSelector, n = t.call(e, "input, select, button, textarea"), i = t.call(e, ZY), o = ys(e);
  return n && !i && o;
}
function ln(e, t, r = {}) {
  const { skipAriaHidden: n } = r;
  e.classList.toggle("ag-hidden", !t), n || iI(e, !t);
}
function UBe(e, t, r = {}) {
  const { skipAriaHidden: n } = r;
  e.classList.toggle("ag-invisible", !t), n || iI(e, !t);
}
function gv(e, t) {
  const r = "disabled", n = t ? (i) => i.setAttribute(r, "") : (i) => i.removeAttribute(r);
  n(e), tq(e.querySelectorAll("input"), (i) => n(i));
}
function Lh(e, t, r) {
  let n = 0;
  for (; e; ) {
    if (e.classList.contains(t))
      return !0;
    if (e = e.parentElement, typeof r == "number") {
      if (++n > r)
        break;
    } else if (e === r)
      break;
  }
  return !1;
}
function pd(e) {
  const {
    height: t,
    width: r,
    borderTopWidth: n,
    borderRightWidth: i,
    borderBottomWidth: o,
    borderLeftWidth: a,
    paddingTop: s,
    paddingRight: l,
    paddingBottom: u,
    paddingLeft: c,
    marginTop: d,
    marginRight: h,
    marginBottom: f,
    marginLeft: p,
    boxSizing: g
  } = window.getComputedStyle(e);
  return {
    height: parseFloat(t || "0"),
    width: parseFloat(r || "0"),
    borderTopWidth: parseFloat(n || "0"),
    borderRightWidth: parseFloat(i || "0"),
    borderBottomWidth: parseFloat(o || "0"),
    borderLeftWidth: parseFloat(a || "0"),
    paddingTop: parseFloat(s || "0"),
    paddingRight: parseFloat(l || "0"),
    paddingBottom: parseFloat(u || "0"),
    paddingLeft: parseFloat(c || "0"),
    marginTop: parseFloat(d || "0"),
    marginRight: parseFloat(h || "0"),
    marginBottom: parseFloat(f || "0"),
    marginLeft: parseFloat(p || "0"),
    boxSizing: g
  };
}
function lI(e) {
  const t = pd(e);
  return t.boxSizing === "border-box" ? t.height - t.paddingTop - t.paddingBottom : t.height;
}
function rm(e) {
  const t = pd(e);
  return t.boxSizing === "border-box" ? t.width - t.paddingLeft - t.paddingRight : t.width;
}
function QY(e) {
  const { height: t, marginBottom: r, marginTop: n } = pd(e);
  return Math.floor(t + r + n);
}
function rS(e) {
  const { width: t, marginLeft: r, marginRight: n } = pd(e);
  return Math.floor(t + r + n);
}
function JY(e) {
  const t = e.getBoundingClientRect(), { borderTopWidth: r, borderLeftWidth: n, borderRightWidth: i, borderBottomWidth: o } = pd(e);
  return {
    top: t.top + (r || 0),
    left: t.left + (n || 0),
    right: t.right + (i || 0),
    bottom: t.bottom + (o || 0)
  };
}
function nS() {
  if (typeof Ly == "boolean")
    return Ly;
  const e = document.createElement("div");
  return e.style.direction = "rtl", e.style.width = "1px", e.style.height = "1px", e.style.position = "fixed", e.style.top = "0px", e.style.overflow = "hidden", e.dir = "rtl", e.innerHTML = /* html */
  `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`, document.body.appendChild(e), e.scrollLeft = 1, Ly = Math.floor(e.scrollLeft) === 0, document.body.removeChild(e), Ly;
}
function iS(e, t) {
  let r = e.scrollLeft;
  return t && (r = Math.abs(r), aI() && !nS() && (r = e.scrollWidth - e.clientWidth - r)), r;
}
function oS(e, t, r) {
  r && (nS() ? t *= -1 : (al() || aI()) && (t = e.scrollWidth - e.clientWidth - t)), e.scrollLeft = t;
}
function xo(e) {
  for (; e && e.firstChild; )
    e.removeChild(e.firstChild);
}
function Xc(e) {
  e && e.parentNode && e.parentNode.removeChild(e);
}
function eq(e) {
  return !!e.offsetParent;
}
function ys(e) {
  const t = e;
  return t.checkVisibility ? t.checkVisibility({ checkVisibilityCSS: !0 }) : !(!eq(e) || window.getComputedStyle(e).visibility !== "visible");
}
function rf(e) {
  const t = document.createElement("div");
  return t.innerHTML = (e || "").trim(), t.firstChild;
}
function KBe(e) {
  return e.clientWidth < e.scrollWidth;
}
function YBe(e) {
  return e.clientHeight < e.scrollHeight;
}
function aS(e, t) {
  t === "flex" ? (e.style.removeProperty("width"), e.style.removeProperty("minWidth"), e.style.removeProperty("maxWidth"), e.style.flex = "1 1 auto") : Da(e, t);
}
function Da(e, t) {
  t = uI(t), e.style.width = t.toString(), e.style.maxWidth = t.toString(), e.style.minWidth = t.toString();
}
function yg(e, t) {
  t = uI(t), e.style.height = t.toString(), e.style.maxHeight = t.toString(), e.style.minHeight = t.toString();
}
function uI(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function cI(e) {
  return e instanceof Node || e instanceof HTMLElement;
}
function qBe(e) {
  if (e == null)
    return [];
  const t = [];
  return tq(e, (r) => t.push(r)), t;
}
function XBe(e, t) {
  if (e)
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      t(n.name, n.value);
    }
}
function Us(e, t, r) {
  r == null ? e.removeAttribute(t) : e.setAttribute(t, r.toString());
}
function tq(e, t) {
  if (e != null)
    for (let r = 0; r < e.length; r++)
      t(e[r]);
}
var nf = class {
  constructor(e = 0, t = 1) {
    this.nextValue = e, this.step = t;
  }
  next() {
    const e = this.nextValue;
    return this.nextValue += this.step, e;
  }
  peek() {
    return this.nextValue;
  }
  skip(e) {
    this.nextValue += e;
  }
}, ZBe = 1e3, QBe = 1e3, HH = 100, rq = class ic extends Se {
  constructor(t, r, n, i) {
    super(), this.parentComp = t, this.tooltipShowDelayOverride = r, this.tooltipHideDelayOverride = n, this.shouldDisplayTooltip = i, this.interactionEnabled = !1, this.isInteractingWithTooltip = !1, this.state = 0, this.tooltipInstanceCount = 0, this.tooltipMouseTrack = !1;
  }
  wireBeans(t) {
    this.popupService = t.popupService, this.userComponentFactory = t.userComponentFactory;
  }
  postConstruct() {
    this.gos.get("tooltipInteraction") && (this.interactionEnabled = !0), this.tooltipTrigger = this.getTooltipTrigger(), this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
    const t = this.parentComp.getGui();
    this.tooltipTrigger === 0 && this.addManagedListeners(t, {
      mouseenter: this.onMouseEnter.bind(this),
      mouseleave: this.onMouseLeave.bind(this)
    }), this.tooltipTrigger === 1 && this.addManagedListeners(t, {
      focusin: this.onFocusIn.bind(this),
      focusout: this.onFocusOut.bind(this)
    }), this.addManagedListeners(t, { mousemove: this.onMouseMove.bind(this) }), this.interactionEnabled || this.addManagedListeners(t, {
      mousedown: this.onMouseDown.bind(this),
      keydown: this.onKeyDown.bind(this)
    });
  }
  getGridOptionsTooltipDelay(t) {
    const r = this.gos.get(t);
    return r < 0 && Te(`${t} should not be lower than 0`), Math.max(200, r);
  }
  getTooltipDelay(t) {
    return t === "show" ? this.tooltipShowDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipShowDelay") : this.tooltipHideDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipHideDelay");
  }
  destroy() {
    this.setToDoNothing(), super.destroy();
  }
  getTooltipTrigger() {
    const t = this.gos.get("tooltipTrigger");
    return !t || t === "hover" ? 0 : 1;
  }
  onMouseEnter(t) {
    this.interactionEnabled && this.interactiveTooltipTimeoutId && (this.unlockService(), this.startHideTimeout()), !xu() && (ic.isLocked ? this.showTooltipTimeoutId = window.setTimeout(() => {
      this.prepareToShowTooltip(t);
    }, HH) : this.prepareToShowTooltip(t));
  }
  onMouseMove(t) {
    this.lastMouseEvent && (this.lastMouseEvent = t), this.tooltipMouseTrack && this.state === 2 && this.tooltipComp && this.positionTooltip();
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  onMouseLeave() {
    this.interactionEnabled ? this.lockService() : this.setToDoNothing();
  }
  onFocusIn() {
    this.prepareToShowTooltip();
  }
  onFocusOut(t) {
    var o;
    const r = t.relatedTarget, n = this.parentComp.getGui(), i = (o = this.tooltipComp) == null ? void 0 : o.getGui();
    this.isInteractingWithTooltip || n.contains(r) || this.interactionEnabled && (i != null && i.contains(r)) || this.setToDoNothing();
  }
  onKeyDown() {
    this.setToDoNothing();
  }
  prepareToShowTooltip(t) {
    if (this.state != 0 || ic.isLocked)
      return;
    let r = 0;
    t && (r = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show")), this.lastMouseEvent = t || null, this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), r), this.state = 1;
  }
  isLastTooltipHiddenRecently() {
    const t = (/* @__PURE__ */ new Date()).getTime(), r = ic.lastTooltipHideTime;
    return t - r < ZBe;
  }
  setToDoNothing() {
    this.state === 2 && this.hideTooltip(), this.onBodyScrollEventCallback && (this.onBodyScrollEventCallback(), this.onBodyScrollEventCallback = void 0), this.onColumnMovedEventCallback && (this.onColumnMovedEventCallback(), this.onColumnMovedEventCallback = void 0), this.clearTimeouts(), this.state = 0, this.lastMouseEvent = null;
  }
  showTooltip() {
    const t = {
      ...this.parentComp.getTooltipParams()
    };
    if (!ke(t.value) || this.shouldDisplayTooltip && !this.shouldDisplayTooltip()) {
      this.setToDoNothing();
      return;
    }
    this.state = 2, this.tooltipInstanceCount++;
    const r = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
    this.userComponentFactory.getTooltipCompDetails(t).newAgStackInstance().then(r);
  }
  hideTooltip(t) {
    if (!t && this.isInteractingWithTooltip)
      return;
    this.tooltipComp && (this.destroyTooltipComp(), ic.lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime());
    const r = {
      type: "tooltipHide",
      parentGui: this.parentComp.getGui()
    };
    this.eventService.dispatchEvent(r), t && (this.isInteractingWithTooltip = !1), this.state = 0;
  }
  newTooltipComponentCallback(t, r) {
    if (this.state !== 2 || this.tooltipInstanceCount !== t) {
      this.destroyBean(r);
      return;
    }
    const i = r.getGui();
    this.tooltipComp = r, i.classList.contains("ag-tooltip") || i.classList.add("ag-tooltip-custom"), this.tooltipTrigger === 0 && i.classList.add("ag-tooltip-animate"), this.interactionEnabled && i.classList.add("ag-tooltip-interactive");
    const o = this.localeService.getLocaleTextFunc(), a = this.popupService.addPopup({
      eChild: i,
      ariaLabel: o("ariaLabelTooltip", "Tooltip")
    });
    if (a && (this.tooltipPopupDestroyFunc = a.hideFunc), this.positionTooltip(), this.tooltipTrigger === 1) {
      const l = this.setToDoNothing.bind(this);
      [this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] = this.addManagedEventListeners({
        bodyScroll: l,
        columnMoved: l
      });
    }
    this.interactionEnabled && (this.tooltipTrigger === 0 ? [this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(
      i,
      {
        mouseenter: this.onTooltipMouseEnter.bind(this),
        mouseleave: this.onTooltipMouseLeave.bind(this)
      }
    ) : [this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(i, {
      focusin: this.onTooltipFocusIn.bind(this),
      focusout: this.onTooltipFocusOut.bind(this)
    }));
    const s = {
      type: "tooltipShow",
      tooltipGui: i,
      parentGui: this.parentComp.getGui()
    };
    this.eventService.dispatchEvent(s), this.startHideTimeout();
  }
  onTooltipMouseEnter() {
    this.isInteractingWithTooltip = !0, this.unlockService();
  }
  onTooltipMouseLeave() {
    this.isInteractingWithTooltip = !1, this.lockService();
  }
  onTooltipFocusIn() {
    this.isInteractingWithTooltip = !0;
  }
  onTooltipFocusOut(t) {
    var o;
    const r = this.parentComp.getGui(), n = (o = this.tooltipComp) == null ? void 0 : o.getGui(), i = t.relatedTarget;
    n != null && n.contains(i) || (this.isInteractingWithTooltip = !1, r.contains(i) ? this.startHideTimeout() : this.hideTooltip());
  }
  positionTooltip() {
    const t = {
      type: "tooltip",
      ePopup: this.tooltipComp.getGui(),
      nudgeY: 18,
      skipObserver: this.tooltipMouseTrack
    };
    this.lastMouseEvent ? this.popupService.positionPopupUnderMouseEvent({
      ...t,
      mouseEvent: this.lastMouseEvent
    }) : this.popupService.positionPopupByComponent({
      ...t,
      eventSource: this.parentComp.getGui(),
      position: "under",
      keepWithinBounds: !0,
      nudgeY: 5
    });
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const t = this.tooltipPopupDestroyFunc, r = this.tooltipComp, n = this.tooltipTrigger === 0 ? QBe : 0;
    window.setTimeout(() => {
      t(), this.destroyBean(r);
    }, n), this.clearTooltipListeners(), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
  }
  clearTooltipListeners() {
    [
      this.tooltipMouseEnterListener,
      this.tooltipMouseLeaveListener,
      this.tooltipFocusInListener,
      this.tooltipFocusOutListener
    ].forEach((t) => {
      t && t();
    }), this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
  }
  lockService() {
    ic.isLocked = !0, this.interactiveTooltipTimeoutId = window.setTimeout(() => {
      this.unlockService(), this.setToDoNothing();
    }, HH);
  }
  unlockService() {
    ic.isLocked = !1, this.clearInteractiveTimeout();
  }
  startHideTimeout() {
    this.clearHideTimeout(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
  }
  clearShowTimeout() {
    this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0);
  }
  clearHideTimeout() {
    this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
  }
  clearInteractiveTimeout() {
    this.interactiveTooltipTimeoutId && (window.clearTimeout(this.interactiveTooltipTimeoutId), this.interactiveTooltipTimeoutId = void 0);
  }
  clearTimeouts() {
    this.clearShowTimeout(), this.clearHideTimeout(), this.clearInteractiveTimeout();
  }
};
rq.isLocked = !1;
var JBe = rq, If = class extends Se {
  constructor(e, t) {
    super(), this.ctrl = e, t && (this.beans = t);
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.refreshToolTip();
  }
  setBrowserTooltip(e) {
    const t = "title", r = this.ctrl.getGui();
    r && (e != null && e != "" ? r.setAttribute(t, e) : r.removeAttribute(t));
  }
  updateTooltipText() {
    this.tooltip = this.ctrl.getTooltipValue();
  }
  createTooltipFeatureIfNeeded() {
    var t, r, n, i;
    if (this.tooltipManager != null)
      return;
    const e = {
      getTooltipParams: () => this.getTooltipParams(),
      getGui: () => this.ctrl.getGui()
    };
    this.tooltipManager = this.createBean(
      new JBe(
        e,
        (r = (t = this.ctrl).getTooltipShowDelayOverride) == null ? void 0 : r.call(t),
        (i = (n = this.ctrl).getTooltipHideDelayOverride) == null ? void 0 : i.call(n),
        this.ctrl.shouldDisplayTooltip
      ),
      this.beans.context
    );
  }
  refreshToolTip() {
    this.browserTooltips = this.beans.gos.get("enableBrowserTooltips"), this.updateTooltipText(), this.browserTooltips ? (this.setBrowserTooltip(this.tooltip), this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context))) : (this.setBrowserTooltip(null), this.createTooltipFeatureIfNeeded());
  }
  getTooltipParams() {
    const e = this.ctrl, t = e.getColumn ? e.getColumn() : void 0, r = e.getColDef ? e.getColDef() : void 0, n = e.getRowNode ? e.getRowNode() : void 0;
    return {
      location: e.getLocation(),
      //'cell',
      colDef: r,
      column: t,
      rowIndex: e.getRowIndex ? e.getRowIndex() : void 0,
      node: n,
      data: n ? n.data : void 0,
      value: this.getTooltipText(),
      valueFormatted: e.getValueFormatted ? e.getValueFormatted() : void 0,
      hideTooltipCallback: () => {
        var i;
        return (i = this.tooltipManager) == null ? void 0 : i.hideTooltip(!0);
      }
    };
  }
  getTooltipText() {
    return this.tooltip;
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context)), super.destroy();
  }
}, e4e = new nf(), Pt = null, tn = class nq extends Se {
  constructor(t, r) {
    super(), this.suppressDataRefValidation = !1, this.displayed = !0, this.visible = !0, this.compId = e4e.next(), this.cssClassManager = new tm(() => this.eGui), this.componentSelectors = new Map((r ?? []).map((n) => [n.selector, n])), t && this.setTemplate(t);
  }
  preWireBeans(t) {
    super.preWireBeans(t);
  }
  preConstruct() {
    this.usingBrowserTooltips = this.gos.get("enableBrowserTooltips"), this.wireTemplate(this.getGui());
  }
  wireTemplate(t, r) {
    t && this.gos && (this.applyElementsToComponent(t), this.createChildComponentsFromTags(t, r));
  }
  getCompId() {
    return this.compId;
  }
  getTooltipParams() {
    return {
      value: this.tooltipText,
      location: "UNKNOWN"
    };
  }
  setTooltip(t) {
    const { newTooltipText: r, showDelayOverride: n, hideDelayOverride: i, location: o, shouldDisplayTooltip: a } = t || {};
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), this.tooltipText !== r && (this.tooltipText = r);
    const s = () => this.tooltipText;
    r != null && (this.tooltipFeature = this.createBean(
      new If({
        getTooltipValue: s,
        getGui: () => this.getGui(),
        getLocation: () => o ?? "UNKNOWN",
        getColDef: t == null ? void 0 : t.getColDef,
        getColumn: t == null ? void 0 : t.getColumn,
        getTooltipShowDelayOverride: n != null ? () => n : void 0,
        getTooltipHideDelayOverride: i != null ? () => i : void 0,
        shouldDisplayTooltip: a
      })
    ));
  }
  getDataRefAttribute(t) {
    return t.getAttribute ? t.getAttribute("data-ref") : null;
  }
  applyElementsToComponent(t, r, n, i = null) {
    if (r === void 0 && (r = this.getDataRefAttribute(t)), r) {
      const o = this[r];
      if (o === Pt)
        this[r] = i ?? t;
      else {
        const a = n && n[r];
        !this.suppressDataRefValidation && !a && Te(`Issue with data-ref: ${r} on ${this.constructor.name} with ${o}`);
      }
    }
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(t, r) {
    qBe(t.childNodes).forEach((i) => {
      if (!(i instanceof HTMLElement))
        return;
      const o = this.createComponentFromElement(
        i,
        (a) => {
          a.getGui() && this.copyAttributesFromNode(i, a.getGui());
        },
        r
      );
      if (o) {
        if (o.addItems && i.children.length) {
          this.createChildComponentsFromTags(i, r);
          const a = Array.prototype.slice.call(i.children);
          o.addItems(a);
        }
        this.swapComponentForNode(o, t, i);
      } else i.childNodes && this.createChildComponentsFromTags(i, r);
    });
  }
  createComponentFromElement(t, r, n) {
    const i = t.nodeName, o = this.getDataRefAttribute(t), a = i.indexOf("AG-") === 0, s = a ? this.componentSelectors.get(i) : null;
    let l = null;
    if (s) {
      nq.elementGettingCreated = t;
      const u = n && o ? n[o] : void 0;
      l = new s.component(u), l.setParentComponent(this), this.createBean(l, null, r);
    } else a && Te(`Missing selector: ${i}`);
    return this.applyElementsToComponent(t, o, n, l), l;
  }
  copyAttributesFromNode(t, r) {
    XBe(t.attributes, (n, i) => r.setAttribute(n, i));
  }
  swapComponentForNode(t, r, n) {
    const i = t.getGui();
    r.replaceChild(i, n), r.insertBefore(document.createComment(n.nodeName), i), this.addDestroyFunc(this.destroyBean.bind(this, t));
  }
  activateTabIndex(t) {
    const r = this.gos.get("tabIndex");
    t || (t = []), t.length || t.push(this.getGui()), t.forEach((n) => n.setAttribute("tabindex", r.toString()));
  }
  setTemplate(t, r, n) {
    const i = rf(t);
    this.setTemplateFromElement(i, r, n);
  }
  setTemplateFromElement(t, r, n, i = !1) {
    if (this.eGui = t, this.suppressDataRefValidation = i, r)
      for (let o = 0; o < r.length; o++) {
        const a = r[o];
        this.componentSelectors.set(a.selector, a);
      }
    this.wireTemplate(t, n);
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(t) {
    this.parentComponent = t;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(t) {
    this.eGui = t;
  }
  queryForHtmlElement(t) {
    return this.eGui.querySelector(t);
  }
  getContainerAndElement(t, r) {
    let n = r;
    return t == null ? null : (n || (n = this.eGui), cI(t) ? {
      element: t,
      parent: n
    } : {
      element: t.getGui(),
      parent: n
    });
  }
  prependChild(t, r) {
    const { element: n, parent: i } = this.getContainerAndElement(t, r) || {};
    !n || !i || i.insertAdjacentElement("afterbegin", n);
  }
  appendChild(t, r) {
    const { element: n, parent: i } = this.getContainerAndElement(t, r) || {};
    !n || !i || i.appendChild(n);
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(t, r = {}) {
    if (t !== this.visible) {
      this.visible = t;
      const { skipAriaHidden: n } = r;
      UBe(this.eGui, t, { skipAriaHidden: n });
    }
  }
  setDisplayed(t, r = {}) {
    if (t !== this.displayed) {
      this.displayed = t;
      const { skipAriaHidden: n } = r;
      ln(this.eGui, t, { skipAriaHidden: n });
      const i = {
        type: "displayChanged",
        visible: this.displayed
      };
      this.dispatchLocalEvent(i);
    }
  }
  destroy() {
    this.parentComponent && (this.parentComponent = void 0), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), super.destroy();
  }
  addGuiEventListener(t, r, n) {
    this.eGui.addEventListener(t, r, n), this.addDestroyFunc(() => this.eGui.removeEventListener(t, r));
  }
  addCssClass(t) {
    this.cssClassManager.addCssClass(t);
  }
  removeCssClass(t) {
    this.cssClassManager.removeCssClass(t);
  }
  containsCssClass(t) {
    return this.cssClassManager.containsCssClass(t);
  }
  addOrRemoveCssClass(t, r) {
    this.cssClassManager.addOrRemoveCssClass(t, r);
  }
}, t4e = {
  // header column group shown when expanded (click to contract)
  columnGroupOpened: "expanded",
  // header column group shown when contracted (click to expand)
  columnGroupClosed: "contracted",
  // tool panel column group contracted (click to expand)
  columnSelectClosed: "tree-closed",
  // tool panel column group expanded (click to contract)
  columnSelectOpen: "tree-open",
  // column tool panel header expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  columnSelectIndeterminate: "tree-indeterminate",
  // shown on ghost icon while dragging column to the side of the grid to pin
  columnMovePin: "pin",
  // shown on ghost icon while dragging over part of the page that is not a drop zone
  columnMoveHide: "eye-slash",
  // shown on ghost icon while dragging columns to reorder
  columnMoveMove: "arrows",
  // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
  columnMoveLeft: "left",
  // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
  columnMoveRight: "right",
  // shown on ghost icon while dragging over Row Groups drop zone
  columnMoveGroup: "group",
  // shown on ghost icon while dragging over Values drop zone
  columnMoveValue: "aggregation",
  // shown on ghost icon while dragging over pivot drop zone
  columnMovePivot: "pivot",
  // shown on ghost icon while dragging over drop zone that doesn't support it, e.g.
  //     string column over aggregation drop zone
  dropNotAllowed: "not-allowed",
  // shown on row group when contracted (click to expand)
  groupContracted: "tree-closed",
  // shown on row group when expanded (click to contract)
  groupExpanded: "tree-open",
  // set filter tree list group contracted (click to expand)
  setFilterGroupClosed: "tree-closed",
  // set filter tree list group expanded (click to contract)
  setFilterGroupOpen: "tree-open",
  // set filter tree list expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  setFilterGroupIndeterminate: "tree-indeterminate",
  // context menu chart item
  chart: "chart",
  // chart window title bar
  close: "cross",
  // X (remove) on column 'pill' after adding it to a drop zone list
  cancel: "cancel",
  // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
  check: "tick",
  // "go to first" button in pagination controls
  first: "first",
  // "go to previous" button in pagination controls
  previous: "previous",
  // "go to next" button in pagination controls
  next: "next",
  // "go to last" button in pagination controls
  last: "last",
  // shown on top right of chart when chart is linked to range data (click to unlink)
  linked: "linked",
  // shown on top right of chart when chart is not linked to range data (click to link)
  unlinked: "unlinked",
  // "Choose colour" button on chart settings tab
  colorPicker: "color-picker",
  // rotating spinner shown by the loading cell renderer
  groupLoading: "loading",
  // button to launch enterprise column menu
  menu: "menu",
  menuAlt: "menu-alt",
  // filter tool panel tab
  filter: "filter",
  // column tool panel tab
  columns: "columns",
  // button in chart regular size window title bar (click to maximise)
  maximize: "maximize",
  // button in chart maximised window title bar (click to make regular size)
  minimize: "minimize",
  // "Pin column" item in column header menu
  menuPin: "pin",
  // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
  menuValue: "aggregation",
  // "Group by {column-name}" item in column header menu
  menuAddRowGroup: "group",
  // "Un-Group by {column-name}" item in column header menu
  menuRemoveRowGroup: "group",
  // context menu copy item
  clipboardCopy: "copy",
  // context menu cut item
  clipboardCut: "cut",
  // context menu paste item
  clipboardPaste: "paste",
  // identifies the pivot drop zone
  pivotPanel: "pivot",
  // "Row groups" drop zone in column tool panel
  rowGroupPanel: "group",
  // columns tool panel Values drop zone
  valuePanel: "aggregation",
  // drag handle used to pick up draggable columns
  columnDrag: "grip",
  // drag handle used to pick up draggable rows
  rowDrag: "grip",
  // context menu export item
  save: "save",
  // csv export
  csvExport: "csv",
  // excel export,
  excelExport: "excel",
  // icon on dropdown editors
  smallDown: "small-down",
  // version of small-right used in RTL mode
  smallLeft: "small-left",
  // separater between column 'pills' when you add multiple columns to the header drop zone
  smallRight: "small-right",
  smallUp: "small-up",
  // show on column header when column is sorted ascending
  sortAscending: "asc",
  // show on column header when column is sorted descending
  sortDescending: "desc",
  // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
  sortUnSort: "none",
  // Builder button in Advanced Filter
  advancedFilterBuilder: "group",
  // drag handle used to pick up Advanced Filter Builder rows
  advancedFilterBuilderDrag: "grip",
  // Advanced Filter Builder row validation error
  advancedFilterBuilderInvalid: "not-allowed",
  // shown on Advanced Filter Builder rows to move them up
  advancedFilterBuilderMoveUp: "up",
  // shown on Advanced Filter Builder rows to move them down
  advancedFilterBuilderMoveDown: "down",
  // shown on Advanced Filter Builder rows to add new rows
  advancedFilterBuilderAdd: "plus",
  // shown on Advanced Filter Builder rows to remove row
  advancedFilterBuilderRemove: "minus",
  // Edit Chart menu item shown in Integrated Charts menu
  chartsMenuEdit: "chart",
  // Advanced Settings menu item shown in Integrated Charts menu
  chartsMenuAdvancedSettings: "settings",
  // shown in Integrated Charts menu add fields
  chartsMenuAdd: "plus",
  // checked checkbox
  checkboxChecked: "checkbox-checked",
  // indeterminate checkbox
  checkboxIndeterminate: "checkbox-indeterminate",
  // unchecked checkbox
  checkboxUnchecked: "checkbox-unchecked",
  // radio button on
  radioButtonOn: "radio-button-on",
  // radio button off
  radioButtonOff: "radio-button-off"
};
function Ms(e, t, r) {
  const n = yo(e, t, r);
  if (n) {
    const { className: o } = n;
    if (typeof o == "string" && o.indexOf("ag-icon") > -1 || typeof o == "object" && o["ag-icon"])
      return n;
  }
  const i = document.createElement("span");
  return i.appendChild(n), i;
}
function yo(e, t, r, n) {
  let i = null;
  const o = r && r.getColDef().icons;
  if (o && (i = o[e]), t && !i) {
    const a = t.get("icons");
    a && (i = a[e]);
  }
  if (i) {
    let a;
    if (typeof i == "function")
      a = i();
    else if (typeof i == "string")
      a = i;
    else
      throw new Error("icon from grid options needs to be a string or a function");
    if (typeof a == "string")
      return rf(a);
    if (cI(a))
      return a;
    Te("iconRenderer should return back a string or a dom object");
  } else {
    const a = document.createElement("span");
    let s = t4e[e];
    return s || (Te(`Did not find icon ${e}`), s = ""), a.setAttribute("class", `ag-icon ag-icon-${s}`), a.setAttribute("unselectable", "on"), Na(a, "presentation"), a;
  }
}
function iq(e, t, r) {
  if (r === 0)
    return !1;
  const n = Math.abs(e.clientX - t.clientX), i = Math.abs(e.clientY - t.clientY);
  return Math.max(n, i) <= r;
}
var ql = class {
  constructor(e, t = !1) {
    this.DOUBLE_TAP_MILLIS = 500, this.destroyFuncs = [], this.touching = !1, this.localEventService = new Af(), this.eElement = e, this.preventMouseClick = t;
    const r = this.onTouchStart.bind(this), n = this.onTouchMove.bind(this), i = this.onTouchEnd.bind(this);
    this.eElement.addEventListener("touchstart", r, { passive: !0 }), this.eElement.addEventListener("touchmove", n, { passive: !0 }), this.eElement.addEventListener("touchend", i, { passive: !1 }), this.destroyFuncs.push(() => {
      this.eElement.removeEventListener("touchstart", r, { passive: !0 }), this.eElement.removeEventListener("touchmove", n, { passive: !0 }), this.eElement.removeEventListener("touchend", i, { passive: !1 });
    });
  }
  getActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
  onTouchStart(e) {
    if (this.touching)
      return;
    this.touchStart = e.touches[0], this.touching = !0, this.moved = !1;
    const t = this.touchStart;
    window.setTimeout(() => {
      const r = this.touchStart === t;
      if (this.touching && r && !this.moved) {
        this.moved = !0;
        const n = {
          type: "longTap",
          touchStart: this.touchStart,
          touchEvent: e
        };
        this.localEventService.dispatchEvent(n);
      }
    }, 500);
  }
  onTouchMove(e) {
    if (!this.touching)
      return;
    const t = this.getActiveTouch(e.touches);
    if (!t)
      return;
    !iq(t, this.touchStart, 4) && (this.moved = !0);
  }
  onTouchEnd(e) {
    if (this.touching) {
      if (!this.moved) {
        const t = {
          type: "tap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(t), this.checkForDoubleTap();
      }
      this.preventMouseClick && e.cancelable && e.preventDefault(), this.touching = !1;
    }
  }
  checkForDoubleTap() {
    const e = (/* @__PURE__ */ new Date()).getTime();
    if (this.lastTapTime && this.lastTapTime > 0)
      if (e - this.lastTapTime > this.DOUBLE_TAP_MILLIS) {
        const r = {
          type: "doubleTap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(r), this.lastTapTime = null;
      } else
        this.lastTapTime = e;
    else
      this.lastTapTime = e;
  }
  destroy() {
    this.destroyFuncs.forEach((e) => e());
  }
}, r4e = (
  /* html */
  `<span class="ag-sort-indicator-container">
        <span data-ref="eSortOrder" class="ag-sort-indicator-icon ag-sort-order ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortAsc" class="ag-sort-indicator-icon ag-sort-ascending-icon ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortDesc" class="ag-sort-indicator-icon ag-sort-descending-icon ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortMixed" class="ag-sort-indicator-icon ag-sort-mixed-icon ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortNone" class="ag-sort-indicator-icon ag-sort-none-icon ag-hidden" aria-hidden="true"></span>
    </span>`
), dI = class extends tn {
  constructor(e) {
    super(), this.eSortOrder = Pt, this.eSortAsc = Pt, this.eSortDesc = Pt, this.eSortMixed = Pt, this.eSortNone = Pt, e || this.setTemplate(r4e);
  }
  wireBeans(e) {
    this.sortController = e.sortController;
  }
  attachCustomElements(e, t, r, n, i) {
    this.eSortOrder = e, this.eSortAsc = t, this.eSortDesc = r, this.eSortMixed = n, this.eSortNone = i;
  }
  setupSort(e, t = !1) {
    this.column = e, this.suppressOrder = t, this.setupMultiSortIndicator(), !(!this.column.isSortable() && !this.column.getColDef().showRowGroup) && (this.addInIcon("sortAscending", this.eSortAsc, e), this.addInIcon("sortDescending", this.eSortDesc, e), this.addInIcon("sortUnSort", this.eSortNone, e), this.addManagedPropertyListener("unSortIcon", () => this.updateIcons()), this.addManagedEventListeners({
      newColumnsLoaded: this.updateIcons.bind(this),
      // Watch global events, as row group columns can effect their display column.
      sortChanged: this.onSortChanged.bind(this),
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: this.onSortChanged.bind(this)
    }), this.onSortChanged());
  }
  addInIcon(e, t, r) {
    if (t == null)
      return;
    const n = yo(e, this.gos, r);
    n && t.appendChild(n);
  }
  onSortChanged() {
    this.updateIcons(), this.suppressOrder || this.updateSortOrder();
  }
  updateIcons() {
    const e = this.sortController.getDisplaySortForColumn(this.column);
    if (this.eSortAsc) {
      const t = e === "asc";
      ln(this.eSortAsc, t, { skipAriaHidden: !0 });
    }
    if (this.eSortDesc) {
      const t = e === "desc";
      ln(this.eSortDesc, t, { skipAriaHidden: !0 });
    }
    if (this.eSortNone) {
      const t = !this.column.getColDef().unSortIcon && !this.gos.get("unSortIcon"), r = e == null;
      ln(this.eSortNone, !t && r, { skipAriaHidden: !0 });
    }
  }
  setupMultiSortIndicator() {
    this.addInIcon("sortUnSort", this.eSortMixed, this.column);
    const e = this.column.getColDef().showRowGroup;
    this.gos.isColumnsSortingCoupledToGroup() && e && (this.addManagedEventListeners({
      // Watch global events, as row group columns can effect their display column.
      sortChanged: this.updateMultiSortIndicator.bind(this),
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
    }), this.updateMultiSortIndicator());
  }
  updateMultiSortIndicator() {
    if (this.eSortMixed) {
      const e = this.sortController.getDisplaySortForColumn(this.column) === "mixed";
      ln(this.eSortMixed, e, { skipAriaHidden: !0 });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    if (!this.eSortOrder)
      return;
    const e = this.sortController.getColumnsWithSortingOrdered(), t = this.sortController.getDisplaySortIndexForColumn(this.column) ?? -1, r = e.some(
      (i) => this.sortController.getDisplaySortIndexForColumn(i) ?? !1
    ), n = t >= 0 && r;
    ln(this.eSortOrder, n, { skipAriaHidden: !0 }), t >= 0 ? this.eSortOrder.textContent = (t + 1).toString() : xo(this.eSortOrder);
  }
}, n4e = {
  selector: "AG-SORT-INDICATOR",
  component: dI
}, i4e = (
  /* html */
  `<div class="ag-cell-label-container" role="presentation">
        <span data-ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
        <span data-ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
        <div data-ref="eLabel" class="ag-header-cell-label" role="presentation">
            <span data-ref="eText" class="ag-header-cell-text"></span>
            <span data-ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
            <ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>
        </div>
    </div>`
), uP = class extends tn {
  constructor() {
    super(...arguments), this.eFilter = Pt, this.eFilterButton = Pt, this.eSortIndicator = Pt, this.eMenu = Pt, this.eLabel = Pt, this.eText = Pt, this.eSortOrder = Pt, this.eSortAsc = Pt, this.eSortDesc = Pt, this.eSortMixed = Pt, this.eSortNone = Pt, this.lastMovingChanged = 0;
  }
  wireBeans(e) {
    this.sortController = e.sortController, this.menuService = e.menuService, this.funcColsService = e.funcColsService;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  refresh(e) {
    const t = this.params;
    return this.params = e, this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort || this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || t.enableFilterButton != e.enableFilterButton || t.enableFilterIcon != e.enableFilterIcon ? !1 : (this.setDisplayName(e), !0);
  }
  workOutTemplate() {
    let e = this.params.template ?? i4e;
    return e = e && e.trim ? e.trim() : e, e;
  }
  init(e) {
    this.params = e, this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate, [n4e]), this.setupTap(), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setupFilterButton(), this.setDisplayName(e);
  }
  setDisplayName(e) {
    if (this.currentDisplayName != e.displayName) {
      this.currentDisplayName = e.displayName;
      const t = hs(this.currentDisplayName, !0);
      this.eText && (this.eText.textContent = t);
    }
  }
  addInIcon(e, t, r) {
    if (t == null)
      return;
    const n = yo(e, this.gos, r);
    n && t.appendChild(n);
  }
  setupTap() {
    const { gos: e } = this;
    if (e.get("suppressTouch"))
      return;
    const t = new ql(this.getGui(), !0), r = this.shouldSuppressMenuHide(), n = r && ke(this.eMenu), i = n ? new ql(this.eMenu, !0) : t;
    if (this.params.enableMenu) {
      const o = n ? "tap" : "longTap", a = (s) => this.params.showColumnMenuAfterMouseClick(s.touchStart);
      this.addManagedListeners(i, { [o]: a });
    }
    if (this.params.enableSorting) {
      const o = (a) => {
        var l, u;
        const s = a.touchStart.target;
        r && ((l = this.eMenu) != null && l.contains(s) || (u = this.eFilterButton) != null && u.contains(s)) || this.sortController.progressSort(this.params.column, !1, "uiColumnSorted");
      };
      this.addManagedListeners(t, { tap: o });
    }
    if (this.params.enableFilterButton) {
      const o = new ql(this.eFilterButton, !0);
      this.addManagedListeners(o, {
        tap: () => this.params.showFilter(this.eFilterButton)
      }), this.addDestroyFunc(() => o.destroy());
    }
    this.addDestroyFunc(() => t.destroy()), n && this.addDestroyFunc(() => i.destroy());
  }
  workOutShowMenu() {
    return this.params.enableMenu && this.menuService.isHeaderMenuButtonEnabled();
  }
  shouldSuppressMenuHide() {
    return this.menuService.isHeaderMenuButtonAlwaysShowEnabled();
  }
  setMenu() {
    if (!this.eMenu)
      return;
    if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
      Xc(this.eMenu), this.eMenu = void 0;
      return;
    }
    const e = this.menuService.isLegacyMenuEnabled();
    this.addInIcon(e ? "menu" : "menuAlt", this.eMenu, this.params.column), this.eMenu.classList.toggle("ag-header-menu-icon", !e), this.currentSuppressMenuHide = this.shouldSuppressMenuHide(), this.addManagedElementListeners(this.eMenu, { click: () => this.params.showColumnMenu(this.eMenu) }), this.eMenu.classList.toggle("ag-header-menu-always-show", this.currentSuppressMenuHide);
  }
  onMenuKeyboardShortcut(e) {
    const t = this.params.column, r = this.menuService.isLegacyMenuEnabled();
    if (e && !r) {
      if (this.menuService.isFilterMenuInHeaderEnabled(t))
        return this.params.showFilter(this.eFilterButton ?? this.eMenu ?? this.getGui()), !0;
    } else if (this.params.enableMenu)
      return this.params.showColumnMenu(this.eMenu ?? this.eFilterButton ?? this.getGui()), !0;
    return !1;
  }
  workOutSort() {
    return this.params.enableSorting;
  }
  setupSort() {
    if (this.currentSort = this.params.enableSorting, this.eSortIndicator || (this.eSortIndicator = this.createBean(new dI(!0)), this.eSortIndicator.attachCustomElements(
      this.eSortOrder,
      this.eSortAsc,
      this.eSortDesc,
      this.eSortMixed,
      this.eSortNone
    )), this.eSortIndicator.setupSort(this.params.column), !this.currentSort)
      return;
    this.addManagedListeners(this.params.column, {
      movingChanged: () => {
        this.lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
      }
    }), this.eLabel && this.addManagedElementListeners(this.eLabel, {
      click: (t) => {
        const r = this.params.column.isMoving(), i = (/* @__PURE__ */ new Date()).getTime() - this.lastMovingChanged < 50;
        if (!(r || i)) {
          const s = this.gos.get("multiSortKey") === "ctrl" ? t.ctrlKey || t.metaKey : t.shiftKey;
          this.params.progressSort(s);
        }
      }
    });
    const e = () => {
      const t = this.params.column.getSort();
      if (this.addOrRemoveCssClass("ag-header-cell-sorted-asc", t === "asc"), this.addOrRemoveCssClass("ag-header-cell-sorted-desc", t === "desc"), this.addOrRemoveCssClass("ag-header-cell-sorted-none", !t), this.params.column.getColDef().showRowGroup) {
        const r = this.funcColsService.getSourceColumnsForGroupColumn(
          this.params.column
        ), i = !(r == null ? void 0 : r.every(
          (o) => this.params.column.getSort() == o.getSort()
        ));
        this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", i);
      }
    };
    this.addManagedEventListeners({
      sortChanged: e,
      columnRowGroupChanged: e
    });
  }
  setupFilterIcon() {
    this.eFilter && this.configureFilter(this.params.enableFilterIcon, this.eFilter, this.onFilterChangedIcon.bind(this));
  }
  setupFilterButton() {
    if (!this.eFilterButton)
      return;
    this.configureFilter(
      this.params.enableFilterButton,
      this.eFilterButton,
      this.onFilterChangedButton.bind(this)
    ) ? this.addManagedElementListeners(this.eFilterButton, {
      click: () => this.params.showFilter(this.eFilterButton)
    }) : this.eFilterButton = void 0;
  }
  configureFilter(e, t, r) {
    if (!e)
      return Xc(t), !1;
    const n = this.params.column;
    return this.addInIcon("filter", t, n), this.addManagedListeners(n, { filterChanged: r }), r(), !0;
  }
  onFilterChangedIcon() {
    const e = this.params.column.isFilterActive();
    ln(this.eFilter, e, { skipAriaHidden: !0 });
  }
  onFilterChangedButton() {
    const e = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", e);
  }
  getAnchorElementForMenu(e) {
    return e ? this.eFilterButton ?? this.eMenu ?? this.getGui() : this.eMenu ?? this.eFilterButton ?? this.getGui();
  }
}, o4e = class extends tn {
  constructor() {
    super(
      /* html */
      `<div class="ag-header-group-cell-label" role="presentation">
            <span data-ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span data-ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span data-ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`
    ), this.agOpened = Pt, this.agClosed = Pt, this.agLabel = Pt;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.checkWarnings(), this.setupLabel(), this.addGroupExpandIcon(), this.setupExpandIcons();
  }
  checkWarnings() {
    this.params.template && Te(
      "A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)"
    );
  }
  setupExpandIcons() {
    this.addInIcon("columnGroupOpened", this.agOpened), this.addInIcon("columnGroupClosed", this.agClosed);
    const e = (i) => {
      if (Yl(i))
        return;
      const o = !this.params.columnGroup.isExpanded();
      this.columnModel.setColumnGroupOpened(
        this.params.columnGroup.getProvidedColumnGroup(),
        o,
        "uiColumnExpanded"
      );
    };
    this.addTouchAndClickListeners(this.agClosed, e), this.addTouchAndClickListeners(this.agOpened, e);
    const t = (i) => {
      ef(i);
    };
    this.addManagedElementListeners(this.agClosed, { dblclick: t }), this.addManagedElementListeners(this.agOpened, { dblclick: t }), this.addManagedElementListeners(this.getGui(), { dblclick: e }), this.updateIconVisibility();
    const r = this.params.columnGroup.getProvidedColumnGroup(), n = this.updateIconVisibility.bind(this);
    this.addManagedListeners(r, {
      expandedChanged: n,
      expandableChanged: n
    });
  }
  addTouchAndClickListeners(e, t) {
    const r = new ql(e, !0);
    this.addManagedListeners(r, { tap: t }), this.addDestroyFunc(() => r.destroy()), this.addManagedElementListeners(e, { click: t });
  }
  updateIconVisibility() {
    if (this.params.columnGroup.isExpandable()) {
      const t = this.params.columnGroup.isExpanded();
      ln(this.agOpened, t), ln(this.agClosed, !t);
    } else
      ln(this.agOpened, !1), ln(this.agClosed, !1);
  }
  addInIcon(e, t) {
    const r = yo(e, this.gos, null);
    r && t.appendChild(r);
  }
  addGroupExpandIcon() {
    if (!this.params.columnGroup.isExpandable()) {
      ln(this.agOpened, !1), ln(this.agClosed, !1);
      return;
    }
  }
  setupLabel() {
    var r;
    const { displayName: e, columnGroup: t } = this.params;
    if (ke(e)) {
      const n = hs(e, !0);
      this.agLabel.textContent = n;
    }
    this.addOrRemoveCssClass("ag-sticky-label", !((r = t.getColGroupDef()) != null && r.suppressStickyLabel));
  }
}, oq = /* @__PURE__ */ ((e) => (e.CommunityCoreModule = "@ag-grid-community/core", e.InfiniteRowModelModule = "@ag-grid-community/infinite-row-model", e.ClientSideRowModelModule = "@ag-grid-community/client-side-row-model", e.CsvExportModule = "@ag-grid-community/csv-export", e.EnterpriseCoreModule = "@ag-grid-enterprise/core", e.RowGroupingModule = "@ag-grid-enterprise/row-grouping", e.ColumnsToolPanelModule = "@ag-grid-enterprise/column-tool-panel", e.FiltersToolPanelModule = "@ag-grid-enterprise/filter-tool-panel", e.MenuModule = "@ag-grid-enterprise/menu", e.SetFilterModule = "@ag-grid-enterprise/set-filter", e.MultiFilterModule = "@ag-grid-enterprise/multi-filter", e.StatusBarModule = "@ag-grid-enterprise/status-bar", e.SideBarModule = "@ag-grid-enterprise/side-bar", e.RangeSelectionModule = "@ag-grid-enterprise/range-selection", e.MasterDetailModule = "@ag-grid-enterprise/master-detail", e.RichSelectModule = "@ag-grid-enterprise/rich-select", e.GridChartsModule = "@ag-grid-enterprise/charts", e.ViewportRowModelModule = "@ag-grid-enterprise/viewport-row-model", e.ServerSideRowModelModule = "@ag-grid-enterprise/server-side-row-model", e.ExcelExportModule = "@ag-grid-enterprise/excel-export", e.ClipboardModule = "@ag-grid-enterprise/clipboard", e.SparklinesModule = "@ag-grid-enterprise/sparklines", e.AdvancedFilterModule = "@ag-grid-enterprise/advanced-filter", e.AngularModule = "@ag-grid-community/angular", e.ReactModule = "@ag-grid-community/react", e.VueModule = "@ag-grid-community/vue", e))(oq || {}), kw = class Rr {
  /**
   * Globally register the given module for all grids.
   * @param module - module to register
   */
  static register(t) {
    Rr.__register(t, !0, void 0);
  }
  /**
   * Globally register the given modules for all grids.
   * @param modules - modules to register
   */
  static registerModules(t) {
    Rr.__registerModules(t, !0, void 0);
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __register(t, r, n) {
    Rr.runVersionChecks(t), n !== void 0 ? (Rr.areGridScopedModules = !0, Rr.gridModulesMap[n] === void 0 && (Rr.gridModulesMap[n] = {}), Rr.gridModulesMap[n][t.moduleName] = t) : Rr.globalModulesMap[t.moduleName] = t, Rr.setModuleBased(r);
  }
  /** AG GRID INTERNAL - Unregister grid scoped module. */
  static __unRegisterGridModules(t) {
    delete Rr.gridModulesMap[t];
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __registerModules(t, r, n) {
    Rr.setModuleBased(r), t && t.forEach((i) => Rr.__register(i, r, n));
  }
  static isValidModuleVersion(t) {
    const [r, n] = t.version.split(".") || [], [i, o] = Rr.currentModuleVersion.split(".") || [];
    return r === i && n === o;
  }
  static runVersionChecks(t) {
    Rr.currentModuleVersion || (Rr.currentModuleVersion = t.version);
    const r = (n) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${n} Please update all modules to the same version.`;
    if (t.version ? Rr.isValidModuleVersion(t) || Er(
      r(
        `'${t.moduleName}' is version ${t.version} but the other modules are version ${Rr.currentModuleVersion}.`
      )
    ) : Er(r(`'${t.moduleName}' is incompatible.`)), t.validate) {
      const n = t.validate();
      n.isValid || Er(`${n.message}`);
    }
  }
  static setModuleBased(t) {
    Rr.moduleBased === void 0 ? Rr.moduleBased = t : Rr.moduleBased !== t && (Er(
      "AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms."
    ), Er("Please see https://www.ag-grid.com/javascript-grid/modules/ for more information."));
  }
  /**
   * AG GRID INTERNAL - Set if files are being served from a single UMD bundle to provide accurate enterprise upgrade steps.
   */
  static __setIsBundled() {
    Rr.isBundled = !0;
  }
  /** AG GRID INTERNAL - Assert a given module has been register, globally or individually with this grid. */
  static __assertRegistered(t, r, n) {
    var o;
    if (this.__isRegistered(t, n))
      return !0;
    let i;
    if (Rr.isBundled)
      i = `AG Grid: unable to use ${r} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
    else if (Rr.moduleBased || Rr.moduleBased === void 0) {
      const a = (o = Object.entries(oq).find(([s, l]) => l === t)) == null ? void 0 : o[0];
      i = `AG Grid: unable to use ${r} as the ${a} is not registered${Rr.areGridScopedModules ? ` for gridId: ${n}` : ""}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${a} } from '${t}';
    
    ModuleRegistry.registerModules([ ${a} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`;
    } else
      i = `AG Grid: unable to use ${r} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';`;
    return Er(i), !1;
  }
  /** AG GRID INTERNAL - Is the given module registered, globally or individually with this grid. */
  static __isRegistered(t, r) {
    var n;
    return !!Rr.globalModulesMap[t] || !!((n = Rr.gridModulesMap[r]) != null && n[t]);
  }
  /** AG GRID INTERNAL - Get all registered modules globally / individually for this grid. */
  static __getRegisteredModules(t) {
    return [...w0(Rr.globalModulesMap), ...w0(Rr.gridModulesMap[t] || {})];
  }
  /** AG GRID INTERNAL - Get the list of modules registered individually for this grid. */
  static __getGridRegisteredModules(t) {
    return w0(Rr.gridModulesMap[t] ?? {}) || [];
  }
  /** INTERNAL */
  static __isPackageBased() {
    return !Rr.moduleBased;
  }
};
kw.globalModulesMap = {};
kw.gridModulesMap = {};
kw.areGridScopedModules = !1;
var ci = kw, a4e = "", s4e = "", l4e = class extends tn {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-change-delta");
    const r = document.createElement("span");
    r.setAttribute("class", "ag-value-change-value"), e.appendChild(t), e.appendChild(r), this.setTemplateFromElement(e);
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  init(e) {
    this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(e, !0);
  }
  showDelta(e, t) {
    const r = Math.abs(t), n = e.formatValue(r), i = ke(n) ? n : r, o = t >= 0;
    o ? this.eDelta.textContent = a4e + i : this.eDelta.textContent = s4e + i, this.eDelta.classList.toggle("ag-value-change-delta-up", o), this.eDelta.classList.toggle("ag-value-change-delta-down", !o);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.hideDeltaValue();
      }, 2e3);
    });
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight"), xo(this.eDelta);
  }
  refresh(e, t = !1) {
    var n;
    const r = e.value;
    if (r === this.lastValue || (ke(e.valueFormatted) ? this.eValue.textContent = e.valueFormatted : ke(e.value) ? this.eValue.textContent = r : xo(this.eValue), (n = this.filterManager) != null && n.isSuppressFlashingCellsBecauseFiltering()))
      return !1;
    if (typeof r == "number" && typeof this.lastValue == "number") {
      const i = r - this.lastValue;
      this.showDelta(e, i);
    }
    return this.lastValue && this.eValue.classList.add("ag-value-change-value-highlight"), t || this.setTimerToRemoveDelta(), this.lastValue = r, !0;
  }
}, u4e = class extends tn {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-current"), e.appendChild(t), this.setTemplateFromElement(e), this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  init(e) {
    this.refresh(e, !0);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.ePrevious && this.getGui().removeChild(this.ePrevious);
    const t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-previous ag-value-slide-out"), this.ePrevious = t, this.ePrevious.textContent = this.eCurrent.textContent, this.getGui().insertBefore(this.ePrevious, this.eCurrent), this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50), window.setTimeout(() => {
        e === this.refreshCount && (this.getGui().removeChild(this.ePrevious), this.ePrevious = null);
      }, 3e3);
    });
  }
  refresh(e, t = !1) {
    var n;
    let r = e.value;
    return dr(r) && (r = ""), r === this.lastValue || (n = this.filterManager) != null && n.isSuppressFlashingCellsBecauseFiltering() ? !1 : (t || this.addSlideAnimation(), this.lastValue = r, ke(e.valueFormatted) ? this.eCurrent.textContent = e.valueFormatted : ke(e.value) ? this.eCurrent.textContent = r : xo(this.eCurrent), !0);
  }
}, pe = class {
};
pe.BACKSPACE = "Backspace";
pe.TAB = "Tab";
pe.ENTER = "Enter";
pe.ESCAPE = "Escape";
pe.SPACE = " ";
pe.LEFT = "ArrowLeft";
pe.UP = "ArrowUp";
pe.RIGHT = "ArrowRight";
pe.DOWN = "ArrowDown";
pe.DELETE = "Delete";
pe.F2 = "F2";
pe.PAGE_UP = "PageUp";
pe.PAGE_DOWN = "PageDown";
pe.PAGE_HOME = "Home";
pe.PAGE_END = "End";
pe.A = "KeyA";
pe.C = "KeyC";
pe.D = "KeyD";
pe.V = "KeyV";
pe.X = "KeyX";
pe.Y = "KeyY";
pe.Z = "KeyZ";
var c4e = class extends tn {
  constructor(e, t, r) {
    super(t, r), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = !1, this.label = "", this.config = e || {};
  }
  postConstruct() {
    this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
    const { labelSeparator: e, label: t, labelWidth: r, labelAlignment: n, disabled: i } = this.config;
    i != null && this.setDisabled(i), e != null && this.setLabelSeparator(e), t != null && this.setLabel(t), r != null && this.setLabelWidth(r), this.setLabelAlignment(n || this.labelAlignment), this.refreshLabel();
  }
  refreshLabel() {
    xo(this.eLabel), typeof this.label == "string" ? this.eLabel.innerText = this.label + this.labelSeparator : this.label && this.eLabel.appendChild(this.label), this.label === "" ? (ln(this.eLabel, !1), Na(this.eLabel, "presentation")) : (ln(this.eLabel, !0), Na(this.eLabel, null));
  }
  setLabelSeparator(e) {
    return this.labelSeparator === e ? this : (this.labelSeparator = e, this.label != null && this.refreshLabel(), this);
  }
  getLabelId() {
    return this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`, this.eLabel.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(e) {
    return this.label === e ? this : (this.label = e, this.refreshLabel(), this);
  }
  setLabelAlignment(e) {
    const r = this.getGui().classList;
    return r.toggle("ag-label-align-left", e === "left"), r.toggle("ag-label-align-right", e === "right"), r.toggle("ag-label-align-top", e === "top"), this;
  }
  setLabelEllipsis(e) {
    return this.eLabel.classList.toggle("ag-label-ellipsis", e), this;
  }
  setLabelWidth(e) {
    return this.label == null ? this : (aS(this.eLabel, e), this);
  }
  setDisabled(e) {
    e = !!e;
    const t = this.getGui();
    return gv(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this;
  }
  isDisabled() {
    return !!this.disabled;
  }
}, aq = class extends c4e {
  constructor(e, t, r, n) {
    super(e, t, r), this.className = n;
  }
  postConstruct() {
    super.postConstruct();
    const { width: e, value: t, onValueChange: r } = this.config;
    e != null && this.setWidth(e), t != null && this.setValue(t), r != null && this.onValueChange(r), this.className && this.addCssClass(this.className), this.refreshAriaLabelledBy();
  }
  setLabel(e) {
    return super.setLabel(e), this.refreshAriaLabelledBy(), this;
  }
  refreshAriaLabelledBy() {
    const e = this.getAriaElement(), t = this.getLabelId(), r = this.getLabel();
    r == null || r == "" || PBe(e) !== null ? pv(e, "") : pv(e, t ?? "");
  }
  setAriaLabel(e) {
    return tf(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this;
  }
  onValueChange(e) {
    return this.addManagedListeners(this, { fieldValueChanged: () => e(this.getValue()) }), this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(e) {
    return Da(this.getGui(), e), this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(e, t) {
    return this.value === e ? this : (this.previousValue = this.value, this.value = e, t || this.dispatchLocalEvent({ type: "fieldValueChanged" }), this);
  }
}, xc = class extends aq {
  constructor(e, t, r = "text", n = "input") {
    super(
      e,
      (e == null ? void 0 : e.template) ?? /* html */
      `
            <div role="presentation">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${n} data-ref="eInput" class="ag-input-field-input"></${n}>
                </div>
            </div>`,
      [],
      t
    ), this.inputType = r, this.displayFieldTag = n, this.eLabel = Pt, this.eWrapper = Pt, this.eInput = Pt;
  }
  postConstruct() {
    super.postConstruct(), this.setInputType(), this.eLabel.classList.add(`${this.className}-label`), this.eWrapper.classList.add(`${this.className}-input-wrapper`), this.eInput.classList.add(`${this.className}-input`), this.addCssClass("ag-input-field"), this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
    const { inputName: e, inputWidth: t } = this.config;
    e != null && this.setInputName(e), t != null && this.setInputWidth(t), this.addInputListeners(), this.activateTabIndex([this.eInput]);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { input: (e) => this.setValue(e.target.value) });
  }
  setInputType() {
    this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(e) {
    return aS(this.eWrapper, e), this;
  }
  setInputName(e) {
    return this.getInputElement().setAttribute("name", e), this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(e) {
    const t = this.eInput;
    return t.maxLength = e, this;
  }
  setInputPlaceholder(e) {
    return Us(this.eInput, "placeholder", e), this;
  }
  setInputAriaLabel(e) {
    return tf(this.eInput, e), this.refreshAriaLabelledBy(), this;
  }
  setDisabled(e) {
    return gv(this.eInput, e), super.setDisabled(e);
  }
  setAutoComplete(e) {
    if (e === !0)
      Us(this.eInput, "autocomplete", null);
    else {
      const t = typeof e == "string" ? e : "off";
      Us(this.eInput, "autocomplete", t);
    }
    return this;
  }
}, hI = class extends xc {
  constructor(e, t = "ag-checkbox", r = "checkbox") {
    super(e, t, r), this.labelAlignment = "right", this.selected = !1, this.readOnly = !1, this.passive = !1;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly: e, passive: t } = this.config;
    typeof e == "boolean" && this.setReadOnly(e), typeof t == "boolean" && this.setPassive(t);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) }), this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
  }
  getNextValue() {
    return this.selected === void 0 ? !0 : !this.selected;
  }
  setPassive(e) {
    this.passive = e;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(e) {
    this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e;
  }
  setDisabled(e) {
    return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e);
  }
  toggle() {
    if (this.eInput.disabled)
      return;
    const e = this.isSelected(), t = this.getNextValue();
    this.passive ? this.dispatchChange(t, e) : this.setValue(t);
  }
  getValue() {
    return this.isSelected();
  }
  setValue(e, t) {
    return this.refreshSelectedClass(e), this.setSelected(e, t), this;
  }
  setName(e) {
    const t = this.getInputElement();
    return t.name = e, this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(e, t) {
    this.isSelected() !== e && (this.previousValue = this.isSelected(), e = this.selected = typeof e == "boolean" ? e : void 0, this.eInput.checked = e, this.eInput.indeterminate = e === void 0, t || this.dispatchChange(this.selected, this.previousValue));
  }
  dispatchChange(e, t, r) {
    this.dispatchLocalEvent({ type: "fieldValueChanged", selected: e, previousValue: t, event: r });
    const n = this.getInputElement(), i = {
      type: "checkboxChanged",
      id: n.id,
      name: n.name,
      selected: e,
      previousValue: t
    };
    this.eventService.dispatchEvent(i);
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled)
      return;
    const t = this.isSelected(), r = this.selected = e.target.checked;
    this.refreshSelectedClass(r), this.dispatchChange(r, t, e);
  }
  refreshSelectedClass(e) {
    this.eWrapper.classList.toggle("ag-checked", e === !0), this.eWrapper.classList.toggle("ag-indeterminate", e == null);
  }
}, fI = {
  selector: "AG-CHECKBOX",
  component: hI
}, d4e = class extends tn {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [fI]
    ), this.eCheckbox = Pt;
  }
  init(e) {
    this.params = e, this.updateCheckbox(e);
    const t = this.eCheckbox.getInputElement();
    t.setAttribute("tabindex", "-1"), WY(t, "polite"), this.addManagedListeners(t, {
      click: (r) => {
        if (ef(r), this.eCheckbox.isDisabled())
          return;
        const n = this.eCheckbox.getValue();
        this.onCheckboxChanged(n);
      },
      dblclick: (r) => {
        ef(r);
      }
    }), this.addManagedElementListeners(this.params.eGridCell, {
      keydown: (r) => {
        if (r.key === pe.SPACE && !this.eCheckbox.isDisabled()) {
          this.params.eGridCell === this.gos.getActiveDomElement() && this.eCheckbox.toggle();
          const n = this.eCheckbox.getValue();
          this.onCheckboxChanged(n), r.preventDefault();
        }
      }
    });
  }
  refresh(e) {
    return this.params = e, this.updateCheckbox(e), !0;
  }
  updateCheckbox(e) {
    var s;
    let t, r = !0;
    if (e.node.group && e.column) {
      const l = e.column.getColId();
      l.startsWith(em) ? t = e.value == null || e.value === "" ? void 0 : e.value === "true" : e.node.aggData && e.node.aggData[l] !== void 0 ? t = e.value ?? void 0 : r = !1;
    } else
      t = e.value ?? void 0;
    if (!r) {
      this.eCheckbox.setDisplayed(!1);
      return;
    }
    this.eCheckbox.setValue(t);
    const n = e.disabled != null ? e.disabled : !((s = e.column) != null && s.isCellEditable(e.node));
    this.eCheckbox.setDisabled(n);
    const i = this.localeService.getLocaleTextFunc(), o = oI(i, t), a = n ? o : `${i("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${o})`;
    this.eCheckbox.setInputAriaLabel(a);
  }
  onCheckboxChanged(e) {
    const { column: t, node: r, value: n } = this.params, i = {
      type: "cellEditingStarted",
      column: t,
      colDef: t == null ? void 0 : t.getColDef(),
      data: r.data,
      node: r,
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      value: n
    };
    this.eventService.dispatchEvent(i);
    const o = this.params.node.setDataValue(this.params.column, e, "edit"), a = {
      type: "cellEditingStopped",
      column: t,
      colDef: t == null ? void 0 : t.getColDef(),
      data: r.data,
      node: r,
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      value: n,
      oldValue: n,
      newValue: e,
      valueChanged: o
    };
    this.eventService.dispatchEvent(a);
  }
}, h4e = class extends tn {
  constructor() {
    super(
      /* html */
      `<div class="ag-loading">
            <span class="ag-loading-icon" data-ref="eLoadingIcon"></span>
            <span class="ag-loading-text" data-ref="eLoadingText"></span>
        </div>`
    ), this.eLoadingIcon = Pt, this.eLoadingText = Pt;
  }
  init(e) {
    e.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    const e = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = e("loadingError", "ERR");
  }
  setupLoading() {
    const e = yo("groupLoading", this.gos, null);
    e && this.eLoadingIcon.appendChild(e);
    const t = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = t("loadingOoo", "Loading");
  }
  refresh(e) {
    return !1;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}, f4e = class extends tn {
  constructor() {
    super(
      /* html */
      '<div class="ag-skeleton-container"></div>'
    );
  }
  init(e) {
    const t = `ag-cell-skeleton-renderer-${this.getCompId()}`;
    this.getGui().setAttribute("id", t), this.addDestroyFunc(() => pv(e.eParentOfValue)), pv(e.eParentOfValue, t), e.node.failedLoad ? this.setupFailed() : this.setupLoading(e);
  }
  setupFailed() {
    const e = this.localeService.getLocaleTextFunc();
    this.getGui().innerText = e("loadingError", "ERR");
    const t = e("ariaSkeletonCellLoadingFailed", "Row failed to load");
    tf(this.getGui(), t);
  }
  setupLoading(e) {
    const r = this.gos.getDocument().createElement("div");
    r.classList.add("ag-skeleton-effect");
    const n = e.node.rowIndex;
    if (n != null) {
      const a = 75 + 25 * (n % 2 === 0 ? Math.sin(n) : Math.cos(n));
      r.style.width = `${a}%`;
    }
    this.getGui().appendChild(r);
    const o = this.localeService.getLocaleTextFunc()("ariaSkeletonCellLoading", "Row data is loading");
    tf(this.getGui(), o);
  }
  refresh(e) {
    return !1;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}, sq = class extends tn {
  constructor() {
    super();
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}, p4e = class extends sq {
  init() {
    const e = this.gos.get("overlayLoadingTemplate");
    if (this.setTemplate(
      e ?? /* html */
      '<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>'
    ), !e) {
      const t = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = t("loadingOoo", "Loading...");
      });
    }
  }
}, g4e = class extends sq {
  init() {
    const e = this.gos.get("overlayNoRowsTemplate");
    if (this.setTemplate(e ?? /* html */
    '<span class="ag-overlay-no-rows-center"></span>'), !e) {
      const t = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = t("noRowsToShow", "No Rows To Show");
      });
    }
  }
}, Of = class extends tn {
  isPopup() {
    return !0;
  }
  setParentComponent(e) {
    e.addCssClass("ag-has-popup"), super.setParentComponent(e);
  }
  destroy() {
    const e = this.parentComponent;
    e && e.isAlive() && e.getGui().classList.remove("ag-has-popup"), super.destroy();
  }
}, v4e = class extends Of {
  constructor() {
    super(
      /* html */
      '<div class="ag-tooltip"></div>'
    );
  }
  // will need to type params
  init(e) {
    const { value: t } = e;
    this.getGui().textContent = hs(t, !0);
  }
};
function m4e(e, t, r) {
  const n = {}, i = e.filter(
    (o) => !t.some((a) => a === o)
  );
  return i.length > 0 && i.forEach(
    (o) => n[o] = lq(o, r).values
  ), n;
}
function lq(e, t, r, n) {
  let i = t.map((s, l) => ({
    value: s,
    relevance: y4e(e.toLowerCase(), s.toLocaleLowerCase()),
    idx: l
  }));
  if (i.sort((s, l) => l.relevance - s.relevance), r && (i = i.filter((s) => s.relevance !== 0)), i.length > 0 && n && n > 0) {
    const l = i[0].relevance * n;
    i = i.filter((u) => l - u.relevance < 0);
  }
  const o = [], a = [];
  for (const s of i)
    o.push(s.value), a.push(s.idx);
  return { values: o, indices: a };
}
function y4e(e, t) {
  const r = e.replace(/\s/g, ""), n = t.replace(/\s/g, "");
  let i = 0, o = -1;
  for (let a = 0; a < r.length; a++) {
    const s = n.indexOf(r[a], o + 1);
    s !== -1 && (o = s, i += 100 - o * 100 / 1e4 * 100);
  }
  return i;
}
var C4e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "userComponentRegistry", this.agGridDefaults = {
      //header
      agColumnHeader: uP,
      agColumnGroupHeader: o4e,
      agSortIndicator: dI,
      // renderers
      agAnimateShowChangeCellRenderer: l4e,
      agAnimateSlideCellRenderer: u4e,
      agLoadingCellRenderer: h4e,
      agSkeletonCellRenderer: f4e,
      agCheckboxCellRenderer: d4e,
      //overlays
      agLoadingOverlay: p4e,
      agNoRowsOverlay: g4e,
      // tooltips
      agTooltipComponent: v4e
    }, this.enterpriseAgDefaultCompsModule = {
      agSetColumnFilter: "@ag-grid-enterprise/set-filter",
      agSetColumnFloatingFilter: "@ag-grid-enterprise/set-filter",
      agMultiColumnFilter: "@ag-grid-enterprise/multi-filter",
      agMultiColumnFloatingFilter: "@ag-grid-enterprise/multi-filter",
      agGroupColumnFilter: "@ag-grid-enterprise/row-grouping",
      agGroupColumnFloatingFilter: "@ag-grid-enterprise/row-grouping",
      agGroupCellRenderer: "@ag-grid-enterprise/row-grouping",
      // Actually in enterprise core as used by MasterDetail too but best guess is they are grouping
      agGroupRowRenderer: "@ag-grid-enterprise/row-grouping",
      // Actually in enterprise core as used by MasterDetail but best guess is they are grouping
      agRichSelect: "@ag-grid-enterprise/rich-select",
      agRichSelectCellEditor: "@ag-grid-enterprise/rich-select",
      agDetailCellRenderer: "@ag-grid-enterprise/master-detail",
      agSparklineCellRenderer: "@ag-grid-enterprise/sparklines"
      /* SparklinesModule */
    }, this.jsComps = {};
  }
  postConstruct() {
    const e = this.gos.get("components");
    e != null && wa(e, (t, r) => this.registerJsComponent(t, r));
  }
  registerDefaultComponent(e, t) {
    this.agGridDefaults[e] = t;
  }
  registerJsComponent(e, t) {
    this.jsComps[e] = t;
  }
  retrieve(e, t) {
    const r = (s, l) => ({
      componentFromFramework: l,
      component: s
    }), n = this.getFrameworkOverrides().frameworkComponent(
      t,
      this.gos.get("components")
    );
    if (n != null)
      return r(n, !0);
    const i = this.jsComps[t];
    if (i) {
      const s = this.getFrameworkOverrides().isFrameworkComponent(i);
      return r(i, s);
    }
    const o = this.agGridDefaults[t];
    if (o)
      return r(o, !1);
    const a = this.enterpriseAgDefaultCompsModule[t];
    return a ? ci.__assertRegistered(
      a,
      `AG Grid '${e}' component: ${t}`,
      this.gridId
    ) : tI(() => {
      this.warnAboutMissingComponent(e, t);
    }, "MissingComp" + t), null;
  }
  warnAboutMissingComponent(e, t) {
    const r = [
      // Don't include the old names / internals in potential suggestions
      ...Object.keys(this.agGridDefaults).filter(
        (i) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(i)
      ),
      ...Object.keys(this.jsComps)
    ], n = lq(t, r, !0, 0.8).values;
    Te(
      `Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.`
    ), n.length > 0 && Te(`         Did you mean: [${n.slice(0, 3)}]?`), Te(
      `If using a custom component check it has been registered as described in: ${this.getFrameworkOverrides().getDocLink("components/")}`
    );
  }
}, gn = class Wp {
  constructor(t) {
    this.status = 0, this.resolution = null, this.waiters = [], t(
      (r) => this.onDone(r),
      (r) => this.onReject(r)
    );
  }
  static all(t) {
    return t.length ? new Wp((r) => {
      let n = t.length;
      const i = new Array(n);
      t.forEach((o, a) => {
        o.then((s) => {
          i[a] = s, n--, n === 0 && r(i);
        });
      });
    }) : Wp.resolve();
  }
  static resolve(t = null) {
    return new Wp((r) => r(t));
  }
  then(t) {
    return new Wp((r) => {
      this.status === 1 ? r(t(this.resolution)) : this.waiters.push((n) => r(t(n)));
    });
  }
  onDone(t) {
    this.status = 1, this.resolution = t, this.waiters.forEach((r) => r(t));
  }
  onReject(t) {
  }
}, S4e = {
  propertyName: "dateComponent",
  cellRenderer: !1
}, w4e = {
  propertyName: "headerComponent",
  cellRenderer: !1
}, b4e = {
  propertyName: "headerGroupComponent",
  cellRenderer: !1
}, GH = {
  propertyName: "cellRenderer",
  cellRenderer: !0
}, x4e = {
  propertyName: "cellRenderer",
  cellRenderer: !1
}, E4e = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, R4e = {
  propertyName: "cellEditor",
  cellRenderer: !1
}, zH = {
  propertyName: "innerRenderer",
  cellRenderer: !0
}, _4e = {
  propertyName: "loadingOverlayComponent",
  cellRenderer: !1
}, T4e = {
  propertyName: "noRowsOverlayComponent",
  cellRenderer: !1
}, P4e = {
  propertyName: "tooltipComponent",
  cellRenderer: !1
}, pI = {
  propertyName: "filter",
  cellRenderer: !1
}, M4e = {
  propertyName: "floatingFilterComponent",
  cellRenderer: !1
}, D4e = {
  propertyName: "toolPanel",
  cellRenderer: !1
}, A4e = {
  propertyName: "statusPanel",
  cellRenderer: !1
}, I4e = {
  propertyName: "fullWidthCellRenderer",
  cellRenderer: !0
}, O4e = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, L4e = {
  propertyName: "groupRowRenderer",
  cellRenderer: !0
}, F4e = {
  propertyName: "detailCellRenderer",
  cellRenderer: !0
}, N4e = {
  propertyName: "menuItem",
  cellRenderer: !1
}, uq = class cq extends Se {
  constructor() {
    super(...arguments), this.beanName = "userComponentFactory";
  }
  wireBeans(t) {
    this.agComponentUtils = t.agComponentUtils, this.componentMetadataProvider = t.componentMetadataProvider, this.userComponentRegistry = t.userComponentRegistry, this.frameworkComponentWrapper = t.frameworkComponentWrapper, this.gridOptions = t.gridOptions;
  }
  getHeaderCompDetails(t, r) {
    return this.getCompDetails(t, w4e, "agColumnHeader", r);
  }
  getHeaderGroupCompDetails(t) {
    const r = t.columnGroup.getColGroupDef();
    return this.getCompDetails(r, b4e, "agColumnGroupHeader", t);
  }
  // this one is unusual, as it can be LoadingCellRenderer, DetailCellRenderer, FullWidthCellRenderer or GroupRowRenderer.
  // so we have to pass the type in.
  getFullWidthCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, I4e, null, t, !0);
  }
  getFullWidthLoadingCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, O4e, "agLoadingCellRenderer", t, !0);
  }
  getFullWidthGroupCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, L4e, "agGroupRowRenderer", t, !0);
  }
  getFullWidthDetailCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, F4e, "agDetailCellRenderer", t, !0);
  }
  // CELL RENDERER
  getInnerRendererDetails(t, r) {
    return this.getCompDetails(t, zH, null, r);
  }
  getFullWidthGroupRowInnerCellRenderer(t, r) {
    return this.getCompDetails(t, zH, null, r);
  }
  getCellRendererDetails(t, r) {
    return this.getCompDetails(t, GH, null, r);
  }
  getEditorRendererDetails(t, r) {
    return this.getCompDetails(t, x4e, null, r);
  }
  getLoadingCellRendererDetails(t, r) {
    return this.getCompDetails(t, E4e, "agSkeletonCellRenderer", r, !0);
  }
  // CELL EDITOR
  getCellEditorDetails(t, r) {
    return this.getCompDetails(t, R4e, "agCellEditor", r, !0);
  }
  // FILTER
  getFilterDetails(t, r, n) {
    return this.getCompDetails(t, pI, n, r, !0);
  }
  getDateCompDetails(t) {
    return this.getCompDetails(this.gridOptions, S4e, "agDateInput", t, !0);
  }
  getLoadingOverlayCompDetails(t) {
    return this.getCompDetails(this.gridOptions, _4e, "agLoadingOverlay", t, !0);
  }
  getNoRowsOverlayCompDetails(t) {
    return this.getCompDetails(this.gridOptions, T4e, "agNoRowsOverlay", t, !0);
  }
  getTooltipCompDetails(t) {
    return this.getCompDetails(t.colDef, P4e, "agTooltipComponent", t, !0);
  }
  getSetFilterCellRendererDetails(t, r) {
    return this.getCompDetails(t, GH, null, r);
  }
  getFloatingFilterCompDetails(t, r, n) {
    return this.getCompDetails(t, M4e, n, r);
  }
  getToolPanelCompDetails(t, r) {
    return this.getCompDetails(t, D4e, null, r, !0);
  }
  getStatusPanelCompDetails(t, r) {
    return this.getCompDetails(t, A4e, null, r, !0);
  }
  getMenuItemCompDetails(t, r) {
    return this.getCompDetails(t, N4e, "agMenuItem", r, !0);
  }
  getCompDetails(t, r, n, i, o = !1) {
    const { propertyName: a, cellRenderer: s } = r;
    let { compName: l, jsComp: u, fwComp: c, paramsFromSelector: d, popupFromSelector: h, popupPositionFromSelector: f } = cq.getCompKeys(this.frameworkOverrides, t, r, i);
    const p = (y) => {
      const C = this.userComponentRegistry.retrieve(a, y);
      C && (u = C.componentFromFramework ? void 0 : C.component, c = C.componentFromFramework ? C.component : void 0);
    };
    if (l != null && p(l), u == null && c == null && n != null && p(n), u && s && !this.agComponentUtils.doesImplementIComponent(u) && (u = this.agComponentUtils.adaptFunction(a, u)), !u && !c) {
      o && Er(`Could not find component ${l}, did you forget to configure this component?`);
      return;
    }
    const g = this.mergeParamsWithApplicationProvidedParams(t, r, i, d), v = u == null, m = u || c;
    return {
      componentFromFramework: v,
      componentClass: m,
      params: g,
      type: r,
      popupFromSelector: h,
      popupPositionFromSelector: f,
      newAgStackInstance: () => this.newAgStackInstance(m, v, g, r)
    };
  }
  static getCompKeys(t, r, n, i) {
    const { propertyName: o } = n;
    let a, s, l, u, c, d;
    if (r) {
      const h = r, f = h[o + "Selector"], p = f ? f(i) : null, g = (v) => {
        typeof v == "string" ? a = v : v != null && v !== !0 && (t.isFrameworkComponent(v) ? l = v : s = v);
      };
      p ? (g(p.component), u = p.params, c = p.popup, d = p.popupPosition) : g(h[o]);
    }
    return { compName: a, jsComp: s, fwComp: l, paramsFromSelector: u, popupFromSelector: c, popupPositionFromSelector: d };
  }
  newAgStackInstance(t, r, n, i) {
    const o = i.propertyName, a = !r;
    let s;
    if (a)
      s = new t();
    else {
      const u = this.componentMetadataProvider.retrieve(o);
      s = this.frameworkComponentWrapper.wrap(
        t,
        u.mandatoryMethodList,
        u.optionalMethodList,
        i
      );
    }
    const l = this.initComponent(s, n);
    return l == null ? gn.resolve(s) : l.then(() => s);
  }
  // used by Floating Filter
  mergeParamsWithApplicationProvidedParams(t, r, n, i = null) {
    const o = this.gos.getGridCommonParams();
    jo(o, n);
    const a = t, s = a && a[r.propertyName + "Params"];
    if (typeof s == "function") {
      const l = s(n);
      jo(o, l);
    } else typeof s == "object" && jo(o, s);
    return jo(o, i), o;
  }
  initComponent(t, r) {
    if (this.createBean(t), t.init != null)
      return t.init(r);
  }
};
function Cg(e) {
  const t = e;
  return t != null && t.getFrameworkComponentInstance != null ? t.getFrameworkComponentInstance() : e;
}
var k4e = class {
  constructor(e) {
    this.beans = {}, this.createdBeans = [], this.destroyed = !1, !(!e || !e.beanClasses) && (this.beanDestroyComparator = e.beanDestroyComparator, this.init(e));
  }
  init(e) {
    var t;
    Object.entries(e.providedBeanInstances).forEach(([r, n]) => {
      this.beans[r] = n;
    }), e.beanClasses.forEach((r) => {
      const n = new r();
      n.beanName ? this.beans[n.beanName] = n : console.error(`Bean ${r.name} is missing beanName`), this.createdBeans.push(n);
    }), (t = e.derivedBeans) == null || t.forEach((r) => {
      const { beanName: n, bean: i } = r(this);
      this.beans[n] = i, this.createdBeans.push(i);
    }), e.beanInitComparator && this.createdBeans.sort(e.beanInitComparator), this.initBeans(this.createdBeans);
  }
  getBeanInstances() {
    return Object.values(this.beans);
  }
  createBean(e, t) {
    if (!e)
      throw Error("Can't wire to bean since it is null");
    return this.initBeans([e], t), e;
  }
  initBeans(e, t) {
    e.forEach((r) => {
      var n, i;
      (n = r.preWireBeans) == null || n.call(r, this.beans), (i = r.wireBeans) == null || i.call(r, this.beans);
    }), e.forEach((r) => {
      var n;
      return (n = r.preConstruct) == null ? void 0 : n.call(r);
    }), t && e.forEach(t), e.forEach((r) => {
      var n;
      return (n = r.postConstruct) == null ? void 0 : n.call(r);
    });
  }
  getBeans() {
    return this.beans;
  }
  getBean(e) {
    return this.beans[e];
  }
  destroy() {
    if (this.destroyed)
      return;
    this.destroyed = !0;
    const e = this.getBeanInstances();
    this.beanDestroyComparator && e.sort(this.beanDestroyComparator), this.destroyBeans(e), this.beans = {}, this.createdBeans = [];
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e) {
    var t;
    (t = e == null ? void 0 : e.destroy) == null || t.call(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e) {
    if (e)
      for (let t = 0; t < e.length; t++)
        this.destroyBean(e[t]);
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
}, V4e = class extends k4e {
  init(e) {
    this.gridId = e.gridId, this.beans.context = this, super.init(e);
  }
  destroy() {
    super.destroy(), ci.__unRegisterGridModules(this.gridId);
  }
  getGridId() {
    return this.gridId;
  }
}, dq = /* @__PURE__ */ ((e) => (e[e.Left = 0] = "Left", e[e.Right = 1] = "Right", e))(dq || {}), B4e = (
  /* html */
  `<div class="ag-dnd-ghost ag-unselectable">
<span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
<div class="ag-dnd-ghost-label"></div>
</div>`
), $4e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "dragAndDropService", this.dragSourceAndParamsList = [], this.dropTargets = [];
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.mouseEventService = e.mouseEventService, this.environment = e.environment;
  }
  postConstruct() {
    this.dropIconMap = {
      pinned: Ms("columnMovePin", this.gos, null),
      hide: Ms("columnMoveHide", this.gos, null),
      move: Ms("columnMoveMove", this.gos, null),
      left: Ms("columnMoveLeft", this.gos, null),
      right: Ms("columnMoveRight", this.gos, null),
      group: Ms("columnMoveGroup", this.gos, null),
      aggregate: Ms("columnMoveValue", this.gos, null),
      pivot: Ms("columnMovePivot", this.gos, null),
      notAllowed: Ms("dropNotAllowed", this.gos, null)
    };
  }
  addDragSource(e, t = !1) {
    const r = {
      eElement: e.eElement,
      dragStartPixels: e.dragStartPixels,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      includeTouch: t
    };
    this.dragSourceAndParamsList.push({ params: r, dragSource: e }), this.dragService.addDragSource(r);
  }
  removeDragSource(e) {
    const t = this.dragSourceAndParamsList.find((r) => r.dragSource === e);
    t && (this.dragService.removeDragSource(t.params), _i(this.dragSourceAndParamsList, t));
  }
  destroy() {
    this.dragSourceAndParamsList.forEach(
      (e) => this.dragService.removeDragSource(e.params)
    ), this.dragSourceAndParamsList.length = 0, this.dropTargets.length = 0, super.destroy();
  }
  nudge() {
    this.dragging && this.onDragging(this.eventLastTime, !0);
  }
  onDragStart(e, t) {
    this.dragging = !0, this.dragSource = e, this.eventLastTime = t, this.dragItem = this.dragSource.getDragItem(), this.dragSource.onDragStarted && this.dragSource.onDragStarted(), this.createGhost();
  }
  onDragStop(e) {
    if (this.eventLastTime = null, this.dragging = !1, this.dragSource.onDragStopped && this.dragSource.onDragStopped(), this.lastDropTarget && this.lastDropTarget.onDragStop) {
      const t = this.createDropTargetEvent(this.lastDropTarget, e, null, null, !1);
      this.lastDropTarget.onDragStop(t);
    }
    this.lastDropTarget = void 0, this.dragItem = null, this.removeGhost();
  }
  onDragging(e, t) {
    var a, s, l, u;
    const r = this.getHorizontalDirection(e), n = this.getVerticalDirection(e);
    this.eventLastTime = e, this.positionGhost(e);
    const i = this.dropTargets.filter((c) => this.isMouseOnDropTarget(e, c)), o = this.findCurrentDropTarget(e, i);
    if (o !== this.lastDropTarget)
      this.leaveLastTargetIfExists(e, r, n, t), this.lastDropTarget !== null && o === null && ((s = (a = this.dragSource).onGridExit) == null || s.call(a, this.dragItem)), this.lastDropTarget === null && o !== null && ((u = (l = this.dragSource).onGridEnter) == null || u.call(l, this.dragItem)), this.enterDragTargetIfExists(o, e, r, n, t), this.lastDropTarget = o;
    else if (o && o.onDragging) {
      const c = this.createDropTargetEvent(o, e, r, n, t);
      o.onDragging(c);
    }
  }
  getAllContainersFromDropTarget(e) {
    const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null, r = [[e.getContainer()]];
    return t ? r.concat(t) : r;
  }
  allContainersIntersect(e, t) {
    for (const r of t) {
      const n = r.getBoundingClientRect();
      if (n.width === 0 || n.height === 0)
        return !1;
      const i = e.clientX >= n.left && e.clientX < n.right, o = e.clientY >= n.top && e.clientY < n.bottom;
      if (!i || !o)
        return !1;
    }
    return !0;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(e, t) {
    const r = this.getAllContainersFromDropTarget(t);
    let n = !1;
    for (const i of r)
      if (this.allContainersIntersect(e, i)) {
        n = !0;
        break;
      }
    return t.targetContainsSource && !t.getContainer().contains(this.dragSource.eElement) ? !1 : n && t.isInterestedIn(this.dragSource.type, this.dragSource.eElement);
  }
  findCurrentDropTarget(e, t) {
    const r = t.length;
    if (r === 0)
      return null;
    if (r === 1)
      return t[0];
    const i = this.gos.getRootNode().elementsFromPoint(e.clientX, e.clientY);
    for (const o of i)
      for (const a of t)
        if (UVe(this.getAllContainersFromDropTarget(a)).indexOf(o) !== -1)
          return a;
    return null;
  }
  enterDragTargetIfExists(e, t, r, n, i) {
    if (e) {
      if (e.onDragEnter) {
        const o = this.createDropTargetEvent(
          e,
          t,
          r,
          n,
          i
        );
        e.onDragEnter(o);
      }
      this.setGhostIcon(e.getIconName ? e.getIconName() : null);
    }
  }
  leaveLastTargetIfExists(e, t, r, n) {
    if (this.lastDropTarget) {
      if (this.lastDropTarget.onDragLeave) {
        const i = this.createDropTargetEvent(
          this.lastDropTarget,
          e,
          t,
          r,
          n
        );
        this.lastDropTarget.onDragLeave(i);
      }
      this.setGhostIcon(null);
    }
  }
  addDropTarget(e) {
    this.dropTargets.push(e);
  }
  removeDropTarget(e) {
    this.dropTargets = this.dropTargets.filter((t) => t.getContainer() !== e.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((e) => e.external);
  }
  findExternalZone(e) {
    return this.dropTargets.filter((r) => r.external).find((r) => r.getContainer() === e.getContainer()) || null;
  }
  getHorizontalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientX, r = e.clientX;
    return t === r ? null : t > r ? 0 : 1;
  }
  getVerticalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientY, r = e.clientY;
    return t === r ? null : t > r ? 0 : 1;
  }
  createDropTargetEvent(e, t, r, n, i) {
    const o = e.getContainer(), a = o.getBoundingClientRect(), { dragItem: s, dragSource: l } = this, u = t.clientX - a.left, c = t.clientY - a.top;
    return this.gos.addGridCommonParams({
      event: t,
      x: u,
      y: c,
      vDirection: n,
      hDirection: r,
      dragSource: l,
      fromNudge: i,
      dragItem: s,
      dropZoneTarget: o
    });
  }
  positionGhost(e) {
    const t = this.eGhost;
    if (!t)
      return;
    const n = t.getBoundingClientRect().height, i = GBe() - 2, o = zBe() - 2, a = JY(t.offsetParent), { clientY: s, clientX: l } = e;
    let u = s - a.top - n / 2, c = l - a.left - 10;
    const d = this.gos.getDocument(), h = d.defaultView || window, f = h.pageYOffset || d.documentElement.scrollTop, p = h.pageXOffset || d.documentElement.scrollLeft;
    i > 0 && c + t.clientWidth > i + p && (c = i + p - t.clientWidth), c < 0 && (c = 0), o > 0 && u + t.clientHeight > o + f && (u = o + f - t.clientHeight), u < 0 && (u = 0), t.style.left = `${c}px`, t.style.top = `${u}px`;
  }
  removeGhost() {
    this.eGhost && this.eGhostParent && this.eGhostParent.removeChild(this.eGhost), this.eGhost = null;
  }
  createGhost() {
    this.eGhost = rf(B4e), this.mouseEventService.stampTopLevelGridCompWithGridInstance(this.eGhost), this.environment.applyThemeClasses(this.eGhost), this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon"), this.setGhostIcon(null);
    const e = this.eGhost.querySelector(".ag-dnd-ghost-label");
    let t = this.dragSource.dragItemName;
    rI(t) && (t = t()), e.innerHTML = hs(t) || "", this.eGhost.style.height = "25px", this.eGhost.style.top = "20px", this.eGhost.style.left = "20px";
    const r = this.gos.getDocument();
    let n = null, i = null;
    try {
      n = r.fullscreenElement;
    } catch {
    } finally {
      n || (n = this.gos.getRootNode());
      const o = n.querySelector("body");
      o ? i = o : n instanceof ShadowRoot ? i = n : n instanceof Document ? i = n == null ? void 0 : n.documentElement : i = n;
    }
    this.eGhostParent = i, this.eGhostParent ? this.eGhostParent.appendChild(this.eGhost) : Te("Could not find document body, it is needed for dragging columns");
  }
  setGhostIcon(e, t = !1) {
    xo(this.eGhostIcon);
    let r = null;
    e || (e = this.dragSource.getDefaultIconName ? this.dragSource.getDefaultIconName() : "notAllowed"), r = this.dropIconMap[e], this.eGhostIcon.classList.toggle("ag-shake-left-to-right", t), !(r === this.dropIconMap.hide && this.gos.get("suppressDragLeaveHidesColumns")) && r && this.eGhostIcon.appendChild(r);
  }
}, H4e = class {
  constructor(e) {
    this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => !1), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => !1);
  }
  check(e, t = !1) {
    const r = t || this.shouldSkipVerticalScroll();
    if (r && this.shouldSkipHorizontalScroll())
      return;
    const n = this.scrollContainer.getBoundingClientRect(), i = this.scrollByTick;
    this.tickLeft = e.clientX < n.left + i, this.tickRight = e.clientX > n.right - i, this.tickUp = e.clientY < n.top + i && !r, this.tickDown = e.clientY > n.bottom - i && !r, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
  }
  ensureTickingStarted() {
    this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
  }
  doTick() {
    this.tickCount++;
    const e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
    if (this.scrollVertically) {
      const t = this.getVerticalPosition();
      this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
    }
    if (this.scrollHorizontally) {
      const t = this.getHorizontalPosition();
      this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e);
    }
    this.onScrollCallback && this.onScrollCallback();
  }
  ensureCleared() {
    this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
  }
}, G4e = class extends Se {
  wireBeans(e) {
    this.dragAndDropService = e.dragAndDropService, this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService, this.focusService = e.focusService, this.sortController = e.sortController, this.filterManager = e.filterManager, this.selectionService = e.selectionService, this.mouseEventService = e.mouseEventService, this.ctrlsService = e.ctrlsService, this.funcColsService = e.funcColsService, this.rangeService = e.rangeService;
  }
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    this.gos.isRowModelType("clientSide") && (this.clientSideRowModel = this.rowModel), this.ctrlsService.whenReady((e) => {
      const t = e.gridBodyCtrl;
      this.autoScrollService = new H4e({
        scrollContainer: t.getBodyViewportElement(),
        scrollAxis: "y",
        getVerticalPosition: () => t.getScrollFeature().getVScrollPosition().top,
        setVerticalPosition: (r) => t.getScrollFeature().setVerticalScrollPosition(r),
        onScrollCallback: () => {
          this.onDragging(this.lastDraggingEvent);
        }
      });
    });
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(e) {
    return e === 2;
  }
  getIconName() {
    return this.gos.get("rowDragManaged") && this.shouldPreventRowMove() ? "notAllowed" : "move";
  }
  shouldPreventRowMove() {
    var n;
    return !!(this.funcColsService.getRowGroupColumns().length || ((n = this.filterManager) == null ? void 0 : n.isAnyFilterPresent()) || this.sortController.isSortActive());
  }
  getRowNodes(e) {
    if (!this.isFromThisGrid(e))
      return e.dragItem.rowNodes || [];
    const t = e.dragItem.rowNode;
    if (this.gos.get("rowDragMultiRow")) {
      const n = [...this.selectionService.getSelectedNodes()].sort((i, o) => i.rowIndex == null || o.rowIndex == null ? 0 : this.getRowIndexNumber(i) - this.getRowIndexNumber(o));
      if (n.indexOf(t) !== -1)
        return n;
    }
    return [t];
  }
  onDragEnter(e) {
    e.dragItem.rowNodes = this.getRowNodes(e), this.dispatchGridEvent("rowDragEnter", e), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!0);
    }), this.onEnterOrDragging(e);
  }
  onDragging(e) {
    this.onEnterOrDragging(e);
  }
  isFromThisGrid(e) {
    const { dragSourceDomDataKey: t } = e.dragSource;
    return t === this.gos.getDomDataKey();
  }
  isDropZoneWithinThisGrid(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getGui(), { dropZoneTarget: n } = e;
    return !r.contains(n);
  }
  onEnterOrDragging(e) {
    this.dispatchGridEvent("rowDragMove", e), this.lastDraggingEvent = e;
    const t = this.mouseEventService.getNormalisedPosition(e).y;
    this.gos.get("rowDragManaged") && this.doManagedDrag(e, t), this.autoScrollService.check(e.event);
  }
  doManagedDrag(e, t) {
    const r = this.isFromThisGrid(e), n = this.gos.get("rowDragManaged"), i = e.dragItem.rowNodes;
    n && this.shouldPreventRowMove() || (this.gos.get("suppressMoveWhenRowDragging") || !r ? this.isDropZoneWithinThisGrid(e) || this.clientSideRowModel.highlightRowAtPixel(i[0], t) : this.moveRows(i, t));
  }
  getRowIndexNumber(e) {
    const t = e.getRowIndexString();
    return parseInt(gr(t.split("-")), 10);
  }
  moveRowAndClearHighlight(e) {
    const t = this.clientSideRowModel.getLastHighlightedRowNode(), r = t && t.highlighted === 1, n = this.mouseEventService.getNormalisedPosition(e).y, i = e.dragItem.rowNodes;
    let o = r ? 1 : 0;
    if (this.isFromThisGrid(e))
      i.forEach((a) => {
        a.rowTop < n && (o -= 1);
      }), this.moveRows(i, n, o);
    else {
      const a = this.gos.getRowIdCallback();
      let s = this.clientSideRowModel.getRowIndexAtPixel(n) + 1;
      this.clientSideRowModel.getHighlightPosition(n) === 0 && s--, this.clientSideRowModel.updateRowData({
        add: i.filter(
          (l) => !this.clientSideRowModel.getRowNode(
            (a == null ? void 0 : a({ data: l.data, level: 0, rowPinned: l.rowPinned })) ?? l.data.id
          )
        ).map((l) => l.data),
        addIndex: s
      });
    }
    this.clearRowHighlight();
  }
  clearRowHighlight() {
    this.clientSideRowModel.highlightRowAtPixel(null);
  }
  moveRows(e, t, r = 0) {
    var i;
    this.clientSideRowModel.ensureRowsAtPixel(e, t, r) && (this.focusService.clearFocusedCell(), (i = this.rangeService) == null || i.removeAllCellRanges());
  }
  addRowDropZone(e) {
    if (!e.getContainer()) {
      Te("addRowDropZone - A container target needs to be provided");
      return;
    }
    if (this.dragAndDropService.findExternalZone(e)) {
      Te(
        "addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again."
      );
      return;
    }
    let t = {
      getContainer: e.getContainer
    };
    e.fromGrid ? t = e : (e.onDragEnter && (t.onDragEnter = (r) => {
      e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", r));
    }), e.onDragLeave && (t.onDragLeave = (r) => {
      e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", r));
    }), e.onDragging && (t.onDragging = (r) => {
      e.onDragging(this.draggingToRowDragEvent("rowDragMove", r));
    }), e.onDragStop && (t.onDragStop = (r) => {
      e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", r));
    })), this.dragAndDropService.addDropTarget({
      isInterestedIn: (r) => r === 2,
      getIconName: () => "move",
      external: !0,
      ...t
    });
  }
  getRowDropZone(e) {
    const t = this.getContainer.bind(this), r = this.onDragEnter.bind(this), n = this.onDragLeave.bind(this), i = this.onDragging.bind(this), o = this.onDragStop.bind(this);
    return e ? {
      getContainer: t,
      onDragEnter: e.onDragEnter ? (a) => {
        r(a), e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", a));
      } : r,
      onDragLeave: e.onDragLeave ? (a) => {
        n(a), e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", a));
      } : n,
      onDragging: e.onDragging ? (a) => {
        i(a), e.onDragging(this.draggingToRowDragEvent("rowDragMove", a));
      } : i,
      onDragStop: e.onDragStop ? (a) => {
        o(a), e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", a));
      } : o,
      fromGrid: !0
    } : {
      getContainer: t,
      onDragEnter: r,
      onDragLeave: n,
      onDragging: i,
      onDragStop: o,
      /* @private */
      fromGrid: !0
    };
  }
  draggingToRowDragEvent(e, t) {
    const r = this.mouseEventService.getNormalisedPosition(t).y, n = r > this.pageBoundsService.getCurrentPageHeight();
    let i = -1, o;
    n || (i = this.rowModel.getRowIndexAtPixel(r), o = this.rowModel.getRow(i));
    let a;
    switch (t.vDirection) {
      case 1:
        a = "down";
        break;
      case 0:
        a = "up";
        break;
      default:
        a = null;
        break;
    }
    return this.gos.addGridCommonParams({
      type: e,
      event: t.event,
      node: t.dragItem.rowNode,
      nodes: t.dragItem.rowNodes,
      overIndex: i,
      overNode: o,
      y: r,
      vDirection: a
    });
  }
  dispatchGridEvent(e, t) {
    const r = this.draggingToRowDragEvent(e, t);
    this.eventService.dispatchEvent(r);
  }
  onDragLeave(e) {
    this.dispatchGridEvent("rowDragLeave", e), this.stopDragging(e), this.gos.get("rowDragManaged") && this.clearRowHighlight();
  }
  onDragStop(e) {
    this.dispatchGridEvent("rowDragEnd", e), this.stopDragging(e), this.gos.get("rowDragManaged") && (this.gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && !this.isDropZoneWithinThisGrid(e) && this.moveRowAndClearHighlight(e);
  }
  stopDragging(e) {
    this.autoScrollService.ensureCleared(), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!1);
    });
  }
}, z4e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "dragService", this.dragEndFunctions = [], this.dragSources = [];
  }
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService;
  }
  destroy() {
    this.dragSources.forEach(this.removeListener.bind(this)), this.dragSources.length = 0, super.destroy();
  }
  removeListener(e) {
    const t = e.dragSource.eElement, r = e.mouseDownListener;
    if (t.removeEventListener("mousedown", r), e.touchEnabled) {
      const n = e.touchStartListener;
      t.removeEventListener("touchstart", n, { passive: !0 });
    }
  }
  removeDragSource(e) {
    const t = this.dragSources.find((r) => r.dragSource === e);
    t && (this.removeListener(t), _i(this.dragSources, t));
  }
  isDragging() {
    return this.dragging;
  }
  addDragSource(e) {
    const t = this.onMouseDown.bind(this, e), { eElement: r, includeTouch: n, stopPropagationForTouch: i } = e;
    r.addEventListener("mousedown", t);
    let o = null;
    const a = this.gos.get("suppressTouch");
    n && !a && (o = (s) => {
      sI(s.target) || (s.cancelable && (s.preventDefault(), i && s.stopPropagation()), this.onTouchStart(e, s));
    }, r.addEventListener("touchstart", o, { passive: !1 })), this.dragSources.push({
      dragSource: e,
      mouseDownListener: t,
      touchStartListener: o,
      touchEnabled: !!n
    });
  }
  getStartTarget() {
    return this.startTarget;
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(e, t) {
    this.currentDragParams = e, this.dragging = !1;
    const r = t.touches[0];
    this.touchLastTime = r, this.touchStart = r;
    const n = (l) => this.onTouchMove(l, e.eElement), i = (l) => this.onTouchUp(l, e.eElement), o = (l) => {
      l.cancelable && l.preventDefault();
    }, a = t.target, s = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      {
        target: this.gos.getRootNode(),
        type: "touchmove",
        listener: o,
        options: { passive: !1 }
      },
      { target: a, type: "touchmove", listener: n, options: { passive: !0 } },
      { target: a, type: "touchend", listener: i, options: { passive: !0 } },
      { target: a, type: "touchcancel", listener: i, options: { passive: !0 } }
    ];
    this.addTemporaryEvents(s), e.dragStartPixels === 0 && this.onCommonMove(r, this.touchStart, e.eElement);
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(e, t) {
    const r = t;
    if (e.skipMouseEvent && e.skipMouseEvent(t) || r._alreadyProcessedByDragService || (r._alreadyProcessedByDragService = !0, t.button !== 0))
      return;
    this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = !1, this.mouseStartEvent = t, this.startTarget = t.target;
    const n = (l) => this.onMouseMove(l, e.eElement), i = (l) => this.onMouseUp(l, e.eElement), o = (l) => l.preventDefault(), a = this.gos.getRootNode(), s = [
      { target: a, type: "mousemove", listener: n },
      { target: a, type: "mouseup", listener: i },
      { target: a, type: "contextmenu", listener: o }
    ];
    this.addTemporaryEvents(s), e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement);
  }
  addTemporaryEvents(e) {
    e.forEach((t) => {
      const { target: r, type: n, listener: i, options: o } = t;
      r.addEventListener(n, i, o);
    }), this.dragEndFunctions.push(() => {
      e.forEach((t) => {
        const { target: r, type: n, listener: i, options: o } = t;
        r.removeEventListener(n, i, o);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(e, t) {
    const { dragStartPixels: r } = this.currentDragParams, n = ke(r) ? r : 4;
    return iq(e, t, n);
  }
  getFirstActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  onCommonMove(e, t, r) {
    if (!this.dragging) {
      if (!this.dragging && this.isEventNearStartEvent(e, t))
        return;
      this.dragging = !0;
      const n = {
        type: "dragStarted",
        target: r
      };
      this.eventService.dispatchEvent(n), this.currentDragParams.onDragStart(t), this.currentDragParams.onDragging(t);
    }
    this.currentDragParams.onDragging(e);
  }
  onTouchMove(e, t) {
    const r = this.getFirstActiveTouch(e.touches);
    r && this.onCommonMove(r, this.touchStart, t);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(e, t) {
    var r;
    al() && ((r = this.gos.getDocument().getSelection()) == null || r.removeAllRanges()), this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t);
  }
  shouldPreventMouseEvent(e) {
    const t = this.gos.get("enableCellTextSelection"), r = e.type === "mousemove";
    return (
      // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
      // to avoid the grid text being selected while dragging components.
      t && r && e.cancelable && this.mouseEventService.isEventFromThisGrid(e) && !this.isOverFormFieldElement(e)
    );
  }
  isOverFormFieldElement(e) {
    const t = e.target, r = t == null ? void 0 : t.tagName.toLocaleLowerCase();
    return !!(r != null && r.match("^a$|textarea|input|select|button"));
  }
  onTouchUp(e, t) {
    let r = this.getFirstActiveTouch(e.changedTouches);
    r || (r = this.touchLastTime), this.onUpCommon(r, t);
  }
  onMouseUp(e, t) {
    this.onUpCommon(e, t);
  }
  onUpCommon(e, t) {
    if (this.dragging) {
      this.dragging = !1, this.currentDragParams.onDragStop(e);
      const r = {
        type: "dragStopped",
        target: t
      };
      this.eventService.dispatchEvent(r);
    }
    this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null, this.dragEndFunctions.forEach((r) => r()), this.dragEndFunctions.length = 0;
  }
}, cP = class extends tn {
  constructor(e, t, r, n, i, o) {
    super(), this.cellValueFn = e, this.rowNode = t, this.column = r, this.customGui = n, this.dragStartPixels = i, this.suppressVisibilityChange = o, this.dragSource = null;
  }
  wireBeans(e) {
    this.beans = e;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'
    ), this.getGui().appendChild(yo("rowDrag", this.gos, null)), this.addDragSource()), this.checkCompatibility(), !this.suppressVisibilityChange) {
      const e = this.gos.get("rowDragManaged") ? new j4e(this, this.beans, this.rowNode, this.column) : new W4e(this, this.beans, this.rowNode, this.column);
      this.createManagedBean(e, this.beans.context);
    }
  }
  setDragElement(e, t) {
    this.setTemplateFromElement(e), this.addDragSource(t);
  }
  getSelectedNodes() {
    if (!this.gos.get("rowDragMultiRow"))
      return [this.rowNode];
    const t = this.beans.selectionService.getSelectedNodes();
    return t.indexOf(this.rowNode) !== -1 ? t : [this.rowNode];
  }
  // returns true if all compatibility items work out
  checkCompatibility() {
    const e = this.gos.get("rowDragManaged");
    this.gos.get("treeData") && e && Te("If using row drag with tree data, you cannot have rowDragManaged=true");
  }
  getDragItem() {
    return {
      rowNode: this.rowNode,
      rowNodes: this.getSelectedNodes(),
      columns: this.column ? [this.column] : void 0,
      defaultTextValue: this.cellValueFn()
    };
  }
  getRowDragText(e) {
    if (e) {
      const t = e.getColDef();
      if (t.rowDragText)
        return t.rowDragText;
    }
    return this.gos.get("rowDragText");
  }
  addDragSource(e = 4) {
    this.dragSource && this.removeDragSource();
    const t = this.getGui();
    this.gos.get("enableCellTextSelection") && (this.removeMouseDownListener(), this.mouseDownListener = this.addManagedElementListeners(t, {
      mousedown: (n) => {
        n == null || n.preventDefault();
      }
    })[0]);
    const r = this.localeService.getLocaleTextFunc();
    this.dragSource = {
      type: 2,
      eElement: t,
      dragItemName: () => {
        var a;
        const n = this.getDragItem(), i = ((a = n.rowNodes) == null ? void 0 : a.length) || 1, o = this.getRowDragText(this.column);
        return o ? o(n, i) : i === 1 ? this.cellValueFn() : `${i} ${r("rowDragRows", "rows")}`;
      },
      getDragItem: () => this.getDragItem(),
      dragStartPixels: e,
      dragSourceDomDataKey: this.gos.getDomDataKey()
    }, this.beans.dragAndDropService.addDragSource(this.dragSource, !0);
  }
  destroy() {
    this.removeDragSource(), this.removeMouseDownListener(), super.destroy();
  }
  removeDragSource() {
    this.dragSource && (this.beans.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null);
  }
  removeMouseDownListener() {
    this.mouseDownListener && (this.mouseDownListener(), this.mouseDownListener = void 0);
  }
}, hq = class extends Se {
  constructor(e, t, r) {
    super(), this.parent = e, this.rowNode = t, this.column = r;
  }
  setDisplayedOrVisible(e) {
    const t = { skipAriaHidden: !0 };
    if (e)
      this.parent.setDisplayed(!1, t);
    else {
      let r = !0, n = !1;
      this.column && (r = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui(), n = rI(this.column.getColDef().rowDrag)), n ? (this.parent.setDisplayed(!0, t), this.parent.setVisible(r, t)) : (this.parent.setDisplayed(r, t), this.parent.setVisible(!0, t));
    }
  }
}, W4e = class extends hq {
  constructor(e, t, r, n) {
    super(e, r, n), this.beans = t;
  }
  postConstruct() {
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.rowNode, {
      dataChanged: e,
      cellChanged: e
    }), this.addManagedListeners(this.beans.eventService, { newColumnsLoaded: e }), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const e = this.gos.get("suppressRowDrag");
    this.setDisplayedOrVisible(e);
  }
}, j4e = class extends hq {
  constructor(e, t, r, n) {
    super(e, r, n), this.beans = t;
  }
  postConstruct() {
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.beans.eventService, {
      sortChanged: e,
      filterChanged: e,
      columnRowGroupChanged: e,
      newColumnsLoaded: e
    }), this.addManagedListeners(this.rowNode, {
      dataChanged: e,
      cellChanged: e
    }), this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const t = this.beans.ctrlsService.getGridBodyCtrl().getRowDragFeature(), r = t && t.shouldPreventRowMove(), n = this.gos.get("suppressRowDrag"), i = this.beans.dragAndDropService.hasExternalDropZones(), o = r && !i || n;
    this.setDisplayedOrVisible(o);
  }
}, nm = class lh {
  constructor(t) {
    this.rowIndex = null, this.key = null, this.childrenMapped = {}, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = lh.OBJECT_ID_SEQUENCE++, this.__autoHeights = {}, this.alreadyRendered = !1, this.highlighted = null, this.hovered = !1, this.selected = !1, this.beans = t;
  }
  /**
   * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  setData(t) {
    this.setDataCommon(t, !1);
  }
  // similar to setRowData, however it is expected that the data is the same data item. this
  // is intended to be used with Redux type stores, where the whole data can be changed. we are
  // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
  // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
  // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
  /**
   * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  updateData(t) {
    this.setDataCommon(t, !0);
  }
  setDataCommon(t, r) {
    var o;
    const n = this.data;
    this.data = t, this.beans.valueCache.onDataChanged(), this.updateDataOnDetailNode(), this.checkRowSelectable(), this.resetQuickFilterAggregateText();
    const i = this.createDataChangedEvent(t, n, r);
    (o = this.localEventService) == null || o.dispatchEvent(i);
  }
  // when we are doing master / detail, the detail node is lazy created, but then kept around.
  // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
  // in sync, otherwise expand/collapse of the detail would still show the old values.
  updateDataOnDetailNode() {
    this.detailNode && (this.detailNode.data = this.data);
  }
  createDataChangedEvent(t, r, n) {
    return {
      type: "dataChanged",
      node: this,
      oldData: r,
      newData: t,
      update: n
    };
  }
  getRowIndexString() {
    return this.rowIndex == null ? (Er(
      "Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid."
    ), null) : this.rowPinned === "top" ? "t-" + this.rowIndex : this.rowPinned === "bottom" ? "b-" + this.rowIndex : this.rowIndex.toString();
  }
  createDaemonNode() {
    const t = new lh(this.beans);
    return t.id = this.id, t.data = this.data, t.__daemon = !0, t.selected = this.selected, t.level = this.level, t;
  }
  setDataAndId(t, r) {
    var a;
    const n = ke(this.id) ? this.createDaemonNode() : null, i = this.data;
    this.data = t, this.updateDataOnDetailNode(), this.setId(r), this.checkRowSelectable(), this.beans.selectionService.syncInRowNode(this, n);
    const o = this.createDataChangedEvent(t, i, !1);
    (a = this.localEventService) == null || a.dispatchEvent(o);
  }
  checkRowSelectable() {
    const t = this.beans.gos.get("isRowSelectable");
    this.setRowSelectable(t ? t(this) : !0);
  }
  setRowSelectable(t, r) {
    if (this.selectable !== t) {
      if (this.selectable = t, this.dispatchRowEvent("selectableChanged"), r)
        return;
      if (this.beans.gos.get("groupSelectsChildren")) {
        const i = this.calculateSelectedFromChildren();
        this.setSelectedParams({
          newValue: i ?? !1,
          source: "selectableChanged"
        });
        return;
      }
      this.isSelected() && !this.selectable && this.setSelectedParams({
        newValue: !1,
        source: "selectableChanged"
      });
    }
  }
  setId(t) {
    const r = this.beans.gos.getRowIdCallback();
    if (r)
      if (this.data) {
        const n = this.getGroupKeys(!0);
        this.id = r({
          data: this.data,
          parentKeys: n.length > 0 ? n : void 0,
          level: this.level,
          rowPinned: this.rowPinned
        }), this.id.startsWith(lh.ID_PREFIX_ROW_GROUP) && Er(
          `Row IDs cannot start with ${lh.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`
        );
      } else
        this.id = void 0;
    else
      this.id = t;
  }
  getGroupKeys(t = !1) {
    const r = [];
    let n = this;
    for (t && (n = n.parent); n && n.level >= 0; )
      r.push(n.key), n = n.parent;
    return r.reverse(), r;
  }
  isPixelInRange(t) {
    return !ke(this.rowTop) || !ke(this.rowHeight) ? !1 : t >= this.rowTop && t < this.rowTop + this.rowHeight;
  }
  updateIfDifferent(t, r, n) {
    this[t] !== r && (this[t] = r, this.dispatchRowEvent(n));
  }
  setFirstChild(t) {
    this.updateIfDifferent("firstChild", t, "firstChildChanged");
  }
  setLastChild(t) {
    this.updateIfDifferent("lastChild", t, "lastChildChanged");
  }
  setChildIndex(t) {
    this.updateIfDifferent("childIndex", t, "childIndexChanged");
  }
  setRowTop(t) {
    this.oldRowTop = this.rowTop, this.rowTop !== t && (this.rowTop = t, this.dispatchRowEvent("topChanged"), this.setDisplayed(t !== null));
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
  }
  setDisplayed(t) {
    this.updateIfDifferent("displayed", t, "displayedChanged");
  }
  setDragging(t) {
    this.updateIfDifferent("dragging", t, "draggingChanged");
  }
  setHighlighted(t) {
    this.updateIfDifferent("highlighted", t, "rowHighlightChanged");
  }
  setHovered(t) {
    this.hovered !== t && (this.hovered = t);
  }
  isHovered() {
    return this.hovered;
  }
  setAllChildrenCount(t) {
    this.updateIfDifferent("allChildrenCount", t, "allChildrenCountChanged");
  }
  setMaster(t) {
    this.master !== t && (this.master && !t && (this.expanded = !1), this.master = t, this.dispatchRowEvent("masterChanged"));
  }
  setGroup(t) {
    this.group !== t && (this.group && !t && (this.expanded = !1), this.group = t, this.updateHasChildren(), this.checkRowSelectable(), this.dispatchRowEvent("groupChanged"));
  }
  /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
  setRowHeight(t, r = !1) {
    this.rowHeight = t, this.rowHeightEstimated = r, this.dispatchRowEvent("heightChanged");
  }
  setRowAutoHeight(t, r) {
    this.__autoHeights || (this.__autoHeights = {}), this.__autoHeights[r.getId()] = t, t != null && (this.checkAutoHeightsDebounced == null && (this.checkAutoHeightsDebounced = Ti(this.checkAutoHeights.bind(this), 1)), this.checkAutoHeightsDebounced());
  }
  checkAutoHeights() {
    let t = !1, r = !0, n = 0;
    const i = this.__autoHeights;
    if (i == null || (this.beans.visibleColsService.getAllAutoHeightCols().forEach((s) => {
      let l = i[s.getId()];
      if (l == null)
        if (this.beans.columnModel.isColSpanActive()) {
          let u = [];
          switch (s.getPinned()) {
            case "left":
              u = this.beans.visibleColsService.getLeftColsForRow(this);
              break;
            case "right":
              u = this.beans.visibleColsService.getRightColsForRow(this);
              break;
            case null:
              u = this.beans.columnViewportService.getColsWithinViewport(this);
              break;
          }
          if (u.includes(s)) {
            t = !0;
            return;
          }
          l = -1;
        } else {
          t = !0;
          return;
        }
      else
        r = !1;
      l > n && (n = l);
    }), t) || ((r || n < 10) && (n = this.beans.gos.getRowHeightForNode(this).height), n == this.rowHeight))
      return;
    this.setRowHeight(n);
    const a = this.beans.rowModel;
    a.onRowHeightChangedDebounced && a.onRowHeightChangedDebounced();
  }
  setRowIndex(t) {
    this.updateIfDifferent("rowIndex", t, "rowIndexChanged");
  }
  setUiLevel(t) {
    this.updateIfDifferent("uiLevel", t, "uiLevelChanged");
  }
  /**
   * Set the expanded state of this rowNode. Pass `true` to expand and `false` to collapse.
   */
  setExpanded(t, r, n) {
    if (this.expanded === t)
      return;
    this.expanded = t, this.dispatchRowEvent("expandedChanged");
    const i = { ...this.createGlobalRowEvent("rowGroupOpened"), expanded: t, event: r || null };
    this.beans.rowNodeEventThrottle.dispatchExpanded(i, n), this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
  }
  createGlobalRowEvent(t) {
    return this.beans.gos.addGridCommonParams({
      type: t,
      node: this,
      data: this.data,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned
    });
  }
  /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid will refresh the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */
  setDataValue(t, r, n) {
    const o = typeof t != "string" ? t : this.beans.columnModel.getCol(t) ?? this.beans.columnModel.getColDefCol(t), a = this.getValueFromValueService(o);
    if (this.beans.gos.get("readOnlyEdit"))
      return this.dispatchEventForSaveValueReadOnly(o, a, r, n), !1;
    const s = this.beans.valueService.setValue(this, o, r, n);
    return this.dispatchCellChangedEvent(o, r, a), this.checkRowSelectable(), s;
  }
  getValueFromValueService(t) {
    const r = this.leafGroup && this.beans.columnModel.isPivotMode(), n = this.group && this.expanded && !this.footer && !r;
    let i = !1;
    const o = this.beans.gos.get("groupTotalRow") ?? this.beans.gos.get("groupIncludeFooter");
    typeof o != "function" ? i = !!o : i = !!(this.beans.gos.getCallback("groupTotalRow") ?? this.beans.gos.getCallback("groupIncludeFooter"))({ node: this });
    const a = this.beans.gos.get("groupSuppressBlankHeader"), s = n && i && !a;
    return this.beans.valueService.getValue(t, this, !1, s);
  }
  dispatchEventForSaveValueReadOnly(t, r, n, i) {
    const o = this.beans.gos.addGridCommonParams({
      type: "cellEditRequest",
      event: null,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned,
      column: t,
      colDef: t.getColDef(),
      data: this.data,
      node: this,
      oldValue: r,
      newValue: n,
      value: n,
      source: i
    });
    this.beans.eventService.dispatchEvent(o);
  }
  setGroupValue(t, r) {
    const n = this.beans.columnModel.getCol(t);
    dr(this.groupData) && (this.groupData = {});
    const i = n.getColId(), o = this.groupData[i];
    o !== r && (this.groupData[i] = r, this.dispatchCellChangedEvent(n, r, o));
  }
  // sets the data for an aggregation
  setAggData(t) {
    const r = this.aggData;
    if (this.aggData = t, this.localEventService) {
      const n = (i) => {
        const o = this.aggData ? this.aggData[i] : void 0, a = r ? r[i] : void 0;
        if (o === a)
          return;
        const s = this.beans.columnModel.getCol(i);
        s && this.dispatchCellChangedEvent(s, o, a);
      };
      for (const i in this.aggData)
        n(i);
      for (const i in t)
        i in this.aggData || n(i);
    }
  }
  updateHasChildren() {
    let t = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    if (this.beans.gos.isRowModelType("serverSide")) {
      const n = this.beans.gos.get("treeData"), i = this.beans.gos.get("isServerSideGroup");
      t = !this.stub && !this.footer && (n ? !!i && i(this.data) : !!this.group);
    }
    t !== this.__hasChildren && (this.__hasChildren = !!t, this.dispatchRowEvent("hasChildrenChanged"));
  }
  hasChildren() {
    return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
  }
  isEmptyRowGroupNode() {
    return (this.group && Wn(this.childrenAfterGroup)) ?? !1;
  }
  dispatchCellChangedEvent(t, r, n) {
    var o;
    const i = {
      type: "cellChanged",
      node: this,
      column: t,
      newValue: r,
      oldValue: n
    };
    (o = this.localEventService) == null || o.dispatchEvent(i);
  }
  /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
   * Otherwise new values will not work with the `quickFilter`. */
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  /** Returns:
   * - `true` if the node can be expanded, i.e it is a group or master row.
   * - `false` if the node cannot be expanded
   */
  isExpandable() {
    return this.footer ? !1 : this.beans.columnModel.isPivotMode() ? this.hasChildren() && !this.leafGroup : this.hasChildren() || !!this.master;
  }
  /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */
  isSelected() {
    return this.footer ? this.sibling.isSelected() : this.selected;
  }
  /** Perform a depth-first search of this node and its children. */
  depthFirstSearch(t) {
    this.childrenAfterGroup && this.childrenAfterGroup.forEach((r) => r.depthFirstSearch(t)), t(this);
  }
  // + selectionController.calculatedSelectedForAllGroupNodes()
  calculateSelectedFromChildren() {
    var i;
    let t = !1, r = !1, n = !1;
    if (!((i = this.childrenAfterGroup) != null && i.length))
      return this.selectable ? this.selected : null;
    for (let o = 0; o < this.childrenAfterGroup.length; o++) {
      const a = this.childrenAfterGroup[o];
      let s = a.isSelected();
      if (!a.selectable) {
        const l = a.calculateSelectedFromChildren();
        if (l === null)
          continue;
        s = l;
      }
      switch (s) {
        case !0:
          t = !0;
          break;
        case !1:
          r = !0;
          break;
        default:
          n = !0;
          break;
      }
    }
    if (!(n || t && r))
      return t ? !0 : r ? !1 : this.selectable ? this.selected : null;
  }
  setSelectedInitialValue(t) {
    this.selected = t;
  }
  dispatchRowEvent(t) {
    var n;
    const r = {
      type: t,
      node: this
    };
    (n = this.localEventService) == null || n.dispatchEvent(r);
  }
  selectThisNode(t, r, n = "api") {
    const i = !this.selectable && t, o = this.selected === t;
    if (i || o)
      return !1;
    this.selected = t, this.dispatchRowEvent("rowSelected");
    const a = this.sibling;
    a && a.footer && a.localEventService && a.dispatchRowEvent("rowSelected");
    const s = {
      ...this.createGlobalRowEvent("rowSelected"),
      event: r || null,
      source: n
    };
    return this.beans.eventService.dispatchEvent(s), !0;
  }
  /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that will appear in the `selectionChanged` event.
   */
  setSelected(t, r = !1, n = "api") {
    if (typeof n == "boolean") {
      Te(
        "since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead."
      );
      return;
    }
    this.setSelectedParams({
      newValue: t,
      clearSelection: r,
      rangeSelect: !1,
      source: n
    });
  }
  // this is for internal use only. To make calling code more readable, this is the same method as setSelected except it takes names parameters
  setSelectedParams(t) {
    return this.rowPinned ? (Te("cannot select pinned rows"), 0) : this.id === void 0 ? (Te("cannot select node until id for node is known"), 0) : this.beans.selectionService.setNodesSelected({ ...t, nodes: [this.footer ? this.sibling : this] });
  }
  /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */
  isRowPinned() {
    return this.rowPinned === "top" || this.rowPinned === "bottom";
  }
  isParentOfNode(t) {
    let r = this.parent;
    for (; r; ) {
      if (r === t)
        return !0;
      r = r.parent;
    }
    return !1;
  }
  /** Add an event listener. */
  addEventListener(t, r) {
    var i;
    this.localEventService || (this.localEventService = new Af()), this.beans.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.localEventService.setFrameworkOverrides(this.beans.frameworkOverrides), this.frameworkEventListenerService = new JA(this.beans.frameworkOverrides));
    const n = ((i = this.frameworkEventListenerService) == null ? void 0 : i.wrap(r)) ?? r;
    this.localEventService.addEventListener(t, n);
  }
  /** Remove event listener. */
  removeEventListener(t, r) {
    var i;
    if (!this.localEventService)
      return;
    const n = ((i = this.frameworkEventListenerService) == null ? void 0 : i.unwrap(r)) ?? r;
    this.localEventService.removeEventListener(t, n), this.localEventService.noRegisteredListenersExist() && (this.localEventService = null);
  }
  onMouseEnter() {
    this.dispatchRowEvent("mouseEnter");
  }
  onMouseLeave() {
    this.dispatchRowEvent("mouseLeave");
  }
  getFirstChildOfFirstChild(t) {
    let r = this, n = !0, i = !1, o = null;
    for (; n && !i; ) {
      const a = r.parent;
      ke(a) && r.firstChild ? a.rowGroupColumn === t && (i = !0, o = a) : n = !1, r = a;
    }
    return i ? o : null;
  }
  /**
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */
  isFullWidthCell() {
    if (this.detail)
      return !0;
    const t = this.beans.gos.getCallback("isFullWidthRow");
    return t ? t({ rowNode: this }) : !1;
  }
  /**
   * Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.
   * If the Row Node is not a group, it returns `undefined`.
   */
  getRoute() {
    if (this.key == null)
      return;
    const t = [];
    let r = this;
    for (; r && r.key != null; )
      t.push(r.key), r = r.parent;
    return t.reverse();
  }
  createFooter() {
    if (this.sibling)
      return;
    const t = /* @__PURE__ */ new Set(["eventService", "__objectId", "sticky"]), r = new lh(this.beans);
    Object.keys(this).forEach((n) => {
      t.has(n) || (r[n] = this[n]);
    }), r.footer = !0, r.setRowTop(null), r.setRowIndex(null), r.oldRowTop = null, r.id = "rowGroupFooter_" + this.id, r.sibling = this, this.sibling = r;
  }
  // Only used by SSRM. In CSRM this is never used as footers should always be present for
  // the purpose of exporting collapsed groups. In SSRM it is not possible to export collapsed
  // groups anyway, so can destroy footers.
  destroyFooter() {
    this.sibling && (this.sibling.setRowTop(null), this.sibling.setRowIndex(null), this.sibling = void 0);
  }
};
nm.ID_PREFIX_ROW_GROUP = "row-group-";
nm.ID_PREFIX_TOP_PINNED = "t-";
nm.ID_PREFIX_BOTTOM_PINNED = "b-";
nm.OBJECT_ID_SEQUENCE = 0;
var Ks = nm, U4e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "filterManager", this.advancedFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.dataTypeService = e.dataTypeService, this.quickFilterService = e.quickFilterService, this.advancedFilterService = e.advancedFilterService, this.columnFilterService = e.columnFilterService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      columnValueChanged: this.refreshFiltersForAggregations.bind(this),
      columnPivotChanged: this.refreshFiltersForAggregations.bind(this),
      columnPivotModeChanged: this.refreshFiltersForAggregations.bind(this),
      newColumnsLoaded: this.updateAdvancedFilterColumns.bind(this),
      columnVisible: this.updateAdvancedFilterColumns.bind(this),
      advancedFilterEnabledChanged: ({ enabled: e }) => this.onAdvancedFilterEnabledChanged(e),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
      this.onFilterChanged({ source: "api" });
    }), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => {
      this.updateAggFiltering(), this.onFilterChanged();
    }), this.addManagedPropertyListener(
      "advancedFilterModel",
      (e) => this.setAdvancedFilterModel(e.currentValue)
    ), this.quickFilterService && this.addManagedListeners(this.quickFilterService, {
      quickFilterChanged: () => this.onFilterChanged({ source: "quickFilter" })
    });
  }
  isExternalFilterPresentCallback() {
    const e = this.gos.getCallback("isExternalFilterPresent");
    return typeof e == "function" ? e({}) : !1;
  }
  doesExternalFilterPass(e) {
    const t = this.gos.get("doesExternalFilterPass");
    return typeof t == "function" ? t(e) : !1;
  }
  setFilterModel(e, t = "api") {
    var r;
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    (r = this.columnFilterService) == null || r.setFilterModel(e, t);
  }
  getFilterModel() {
    var e;
    return ((e = this.columnFilterService) == null ? void 0 : e.getFilterModel()) ?? {};
  }
  isColumnFilterPresent() {
    var e;
    return !!((e = this.columnFilterService) != null && e.isColumnFilterPresent());
  }
  isAggregateFilterPresent() {
    var e;
    return !!((e = this.columnFilterService) != null && e.isAggregateFilterPresent());
  }
  isExternalFilterPresent() {
    return this.externalFilterPresent;
  }
  isChildFilterPresent() {
    return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  isAdvancedFilterPresent() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isFilterPresent();
  }
  onAdvancedFilterEnabledChanged(e) {
    var t, r;
    e ? (t = this.columnFilterService) != null && t.disableColumnFilters() && this.onFilterChanged({ source: "advancedFilter" }) : (r = this.advancedFilterService) != null && r.isFilterPresent() && (this.advancedFilterService.setModel(null), this.onFilterChanged({ source: "advancedFilter" }));
  }
  isAdvancedFilterEnabled() {
    var e;
    return !!((e = this.advancedFilterService) != null && e.isEnabled());
  }
  isAdvancedFilterHeaderActive() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isHeaderActive();
  }
  isAnyFilterPresent() {
    return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  resetQuickFilterCache() {
    var e;
    (e = this.quickFilterService) == null || e.resetQuickFilterCache();
  }
  refreshFiltersForAggregations() {
    this.gos.getGroupAggFiltering() && this.onFilterChanged();
  }
  onFilterChanged(e = {}) {
    const { source: t, additionalEventAttributes: r, columns: n = [] } = e;
    this.externalFilterPresent = this.isExternalFilterPresentCallback(), (this.columnFilterService ? this.columnFilterService.updateBeforeFilterChanged(e) : gn.resolve()).then(() => {
      var o;
      const i = {
        source: t,
        type: "filterChanged",
        columns: n
      };
      r && jo(i, r), this.eventService.dispatchEvent(i), (o = this.columnFilterService) == null || o.updateAfterFilterChanged();
    });
  }
  isSuppressFlashingCellsBecauseFiltering() {
    var e;
    return !!((e = this.columnFilterService) != null && e.isSuppressFlashingCellsBecauseFiltering());
  }
  isQuickFilterPresent() {
    var e;
    return !!((e = this.quickFilterService) != null && e.isQuickFilterPresent());
  }
  updateAggFiltering() {
    this.aggFiltering = !!this.gos.getGroupAggFiltering();
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
  }
  shouldApplyQuickFilterAfterAgg() {
    return (this.aggFiltering || this.columnModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
  }
  doesRowPassOtherFilters(e, t) {
    return this.doesRowPassFilter({ rowNode: t, filterInstanceToSkip: e });
  }
  doesRowPassAggregateFilters(e) {
    return !(this.isAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isAggregateFilterPresent() && !this.columnFilterService.doAggregateFiltersPass(e.rowNode, e.filterInstanceToSkip));
  }
  doesRowPassFilter(e) {
    return !(this.isNonAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isExternalFilterPresent() && !this.doesExternalFilterPass(e.rowNode) || this.isColumnFilterPresent() && !this.columnFilterService.doColumnFiltersPass(e.rowNode, e.filterInstanceToSkip) || this.isAdvancedFilterPresent() && !this.advancedFilterService.doesFilterPass(e.rowNode));
  }
  isFilterActive(e) {
    var t;
    return !!((t = this.columnFilterService) != null && t.isFilterActive(e));
  }
  getOrCreateFilterWrapper(e) {
    var t;
    return ((t = this.columnFilterService) == null ? void 0 : t.getOrCreateFilterWrapper(e)) ?? null;
  }
  getDefaultFloatingFilter(e) {
    return this.columnFilterService.getDefaultFloatingFilter(e);
  }
  createFilterParams(e, t) {
    return this.columnFilterService.createFilterParams(e, t);
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    var t;
    return this.isAdvancedFilterEnabled() ? !1 : !!((t = this.columnFilterService) != null && t.isFilterAllowed(e));
  }
  getFloatingFilterCompDetails(e, t) {
    var r;
    return (r = this.columnFilterService) == null ? void 0 : r.getFloatingFilterCompDetails(e, t);
  }
  getCurrentFloatingFilterParentModel(e) {
    var t;
    return (t = this.columnFilterService) == null ? void 0 : t.getCurrentFloatingFilterParentModel(e);
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    var r;
    (r = this.columnFilterService) == null || r.destroyFilter(e, t);
  }
  areFilterCompsDifferent(e, t) {
    var r;
    return !!((r = this.columnFilterService) != null && r.areFilterCompsDifferent(e, t));
  }
  getAdvancedFilterModel() {
    return this.isAdvancedFilterEnabled() ? this.advancedFilterService.getModel() : null;
  }
  setAdvancedFilterModel(e) {
    var t;
    if (this.isAdvancedFilterEnabled()) {
      if ((t = this.dataTypeService) != null && t.isPendingInference()) {
        this.advancedFilterModelUpdateQueue.push(e);
        return;
      }
      this.advancedFilterService.setModel(e ?? null), this.onFilterChanged({ source: "advancedFilter" });
    }
  }
  toggleAdvancedFilterBuilder(e, t) {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.getCtrl().toggleFilterBuilder(t, e);
  }
  updateAdvancedFilterColumns() {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.updateValidity() && this.onFilterChanged({ source: "advancedFilter" });
  }
  hasFloatingFilters() {
    var e;
    return this.isAdvancedFilterEnabled() ? !1 : !!((e = this.columnFilterService) != null && e.hasFloatingFilters());
  }
  getFilterInstance(e, t) {
    var r;
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    return (r = this.columnFilterService) == null ? void 0 : r.getFilterInstance(e, t);
  }
  getColumnFilterInstance(e) {
    var t;
    return this.isAdvancedFilterEnabled() ? (this.warnAdvancedFilters(), Promise.resolve(void 0)) : ((t = this.columnFilterService) == null ? void 0 : t.getColumnFilterInstance(e)) ?? Promise.resolve(void 0);
  }
  warnAdvancedFilters() {
    Te("Column Filter API methods have been disabled as Advanced Filters are enabled.");
  }
  setupAdvancedFilterHeaderComp(e) {
    var t;
    (t = this.advancedFilterService) == null || t.getCtrl().setupHeaderComp(e);
  }
  getHeaderRowCount() {
    return this.isAdvancedFilterHeaderActive() ? 1 : 0;
  }
  getHeaderHeight() {
    return this.isAdvancedFilterHeaderActive() ? this.advancedFilterService.getCtrl().getHeaderHeight() : 0;
  }
  processFilterModelUpdateQueue() {
    this.advancedFilterModelUpdateQueue.forEach((e) => this.setAdvancedFilterModel(e)), this.advancedFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    var t;
    return (t = this.columnFilterService) == null ? void 0 : t.getColumnFilterModel(e);
  }
  setColumnFilterModel(e, t) {
    var r;
    return this.isAdvancedFilterEnabled() ? (this.warnAdvancedFilters(), Promise.resolve()) : ((r = this.columnFilterService) == null ? void 0 : r.setColumnFilterModel(e, t)) ?? Promise.resolve();
  }
}, K4e = class extends tn {
  constructor(e, t) {
    super(
      /* html */
      '<div class="ag-filter"></div>'
    ), this.column = e, this.source = t, this.filterWrapper = null;
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.columnModel = e.columnModel;
  }
  postConstruct() {
    this.createFilter(!0), this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
  }
  hasFilter() {
    return !!this.filterWrapper;
  }
  getFilter() {
    var e;
    return ((e = this.filterWrapper) == null ? void 0 : e.filterPromise) ?? null;
  }
  afterInit() {
    var e, t;
    return ((t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null ? void 0 : t.then(() => {
    })) ?? gn.resolve();
  }
  afterGuiAttached(e) {
    var t, r;
    (r = (t = this.filterWrapper) == null ? void 0 : t.filterPromise) == null || r.then((n) => {
      var i;
      (i = n == null ? void 0 : n.afterGuiAttached) == null || i.call(n, e);
    });
  }
  afterGuiDetached() {
    var e, t;
    (t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null || t.then((r) => {
      var n;
      (n = r == null ? void 0 : r.afterGuiDetached) == null || n.call(r);
    });
  }
  createFilter(e) {
    var n, i;
    const { column: t, source: r } = this;
    this.filterWrapper = ((n = this.filterManager) == null ? void 0 : n.getOrCreateFilterWrapper(t)) ?? null, (i = this.filterWrapper) != null && i.filterPromise && this.filterWrapper.filterPromise.then((o) => {
      const a = o.getGui();
      if (ke(a) || Te(`getGui method from filter returned ${a}; it should be a DOM element.`), this.appendChild(a), e) {
        const s = {
          type: "filterOpened",
          column: t,
          source: r,
          eGui: this.getGui()
        };
        this.eventService.dispatchEvent(s);
      }
    });
  }
  onFilterDestroyed(e) {
    (e.source === "api" || e.source === "paramsUpdated") && e.column.getId() === this.column.getId() && this.columnModel.getColDefCol(this.column) && (xo(this.getGui()), this.createFilter());
  }
  destroy() {
    this.filterWrapper = null, super.destroy();
  }
}, fq = "ag-resizer-wrapper", Y4e = (
  /* html */
  `<div class="${fq}">
        <div data-ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>
        <div data-ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>
        <div data-ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>
        <div data-ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>
        <div data-ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>
        <div data-ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>
        <div data-ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>
        <div data-ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>
    </div>`
), q4e = class extends Se {
  constructor(e, t) {
    super(), this.element = e, this.dragStartPosition = {
      x: 0,
      y: 0
    }, this.position = {
      x: 0,
      y: 0
    }, this.lastSize = {
      width: -1,
      height: -1
    }, this.positioned = !1, this.resizersAdded = !1, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = !1, this.isMoving = !1, this.resizable = {}, this.movable = !1, this.currentResizer = null, this.config = Object.assign({}, { popup: !1 }, t);
  }
  wireBeans(e) {
    this.popupService = e.popupService, this.resizeObserverService = e.resizeObserverService, this.dragService = e.dragService;
  }
  center() {
    const { clientHeight: e, clientWidth: t } = this.offsetParent, r = t / 2 - this.getWidth() / 2, n = e / 2 - this.getHeight() / 2;
    this.offsetElement(r, n);
  }
  initialisePosition() {
    if (this.positioned)
      return;
    const { centered: e, forcePopupParentAsOffsetParent: t, minWidth: r, width: n, minHeight: i, height: o, x: a, y: s } = this.config;
    this.offsetParent || this.setOffsetParent();
    let l = 0, u = 0;
    const c = ys(this.element);
    if (c) {
      const d = this.findBoundaryElement(), h = window.getComputedStyle(d);
      if (h.minWidth != null) {
        const f = d.offsetWidth - this.element.offsetWidth;
        u = parseInt(h.minWidth, 10) - f;
      }
      if (h.minHeight != null) {
        const f = d.offsetHeight - this.element.offsetHeight;
        l = parseInt(h.minHeight, 10) - f;
      }
    }
    if (this.minHeight = i || l, this.minWidth = r || u, n && this.setWidth(n), o && this.setHeight(o), (!n || !o) && this.refreshSize(), e)
      this.center();
    else if (a || s)
      this.offsetElement(a, s);
    else if (c && t) {
      let d = this.boundaryEl, h = !0;
      if (d || (d = this.findBoundaryElement(), h = !1), d) {
        const f = parseFloat(d.style.top), p = parseFloat(d.style.left);
        h ? this.offsetElement(isNaN(p) ? 0 : p, isNaN(f) ? 0 : f) : this.setPosition(p, f);
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(e, t) {
    if (!this.config.popup || e === this.movable)
      return;
    this.movable = e;
    const r = this.moveElementDragListener || {
      eElement: t,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    e ? (this.dragService.addDragSource(r), this.moveElementDragListener = r) : (this.dragService.removeDragSource(r), this.moveElementDragListener = void 0);
  }
  setResizable(e) {
    if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), typeof e == "boolean") {
      if (e === !1)
        return;
      e = {
        topLeft: e,
        top: e,
        topRight: e,
        right: e,
        bottomRight: e,
        bottom: e,
        bottomLeft: e,
        left: e
      };
    }
    Object.keys(e).forEach((t) => {
      const n = !!e[t], i = this.getResizerElement(t), o = {
        dragStartPixels: 0,
        eElement: i,
        onDragStart: (a) => this.onResizeStart(a, t),
        onDragging: this.onResize.bind(this),
        onDragStop: (a) => this.onResizeEnd(a, t)
      };
      (n || !this.isAlive() && !n) && (n ? (this.dragService.addDragSource(o), this.resizeListeners.push(o), i.style.pointerEvents = "all") : i.style.pointerEvents = "none", this.resizable[t] = n);
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height: e, width: t } = this.lastSize;
    t !== -1 && (this.element.style.width = `${t}px`), e !== -1 && (this.element.style.height = `${e}px`);
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(e) {
    const { popup: t } = this.config, r = this.element;
    let n = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      yg(r, e), e = QY(r), n = !0;
    else if (e = Math.max(this.minHeight, e), this.positioned) {
      const i = this.getAvailableHeight();
      i && e > i && (e = i);
    }
    this.getHeight() !== e && (n ? (r.style.maxHeight = "unset", r.style.minHeight = "unset") : t ? yg(r, e) : (r.style.height = `${e}px`, r.style.flex = "0 0 auto", this.lastSize.height = typeof e == "number" ? e : parseFloat(e)));
  }
  getAvailableHeight() {
    const { popup: e, forcePopupParentAsOffsetParent: t } = this.config;
    this.positioned || this.initialisePosition();
    const { clientHeight: r } = this.offsetParent;
    if (!r)
      return null;
    const n = this.element.getBoundingClientRect(), i = this.offsetParent.getBoundingClientRect(), o = e ? this.position.y : n.top, a = e ? 0 : i.top;
    let s = 0;
    if (t) {
      const u = this.element.parentElement;
      if (u) {
        const { bottom: c } = u.getBoundingClientRect();
        s = c - n.bottom;
      }
    }
    return r + a - o - s;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(e) {
    const t = this.element, { popup: r } = this.config;
    let n = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      Da(t, e), e = rS(t), n = !0;
    else if (this.positioned) {
      e = Math.max(this.minWidth, e);
      const { clientWidth: i } = this.offsetParent, o = r ? this.position.x : this.element.getBoundingClientRect().left;
      i && e + o > i && (e = i - o);
    }
    this.getWidth() !== e && (n ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? Da(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = typeof e == "number" ? e : parseFloat(e)));
  }
  offsetElement(e = 0, t = 0) {
    const { forcePopupParentAsOffsetParent: r } = this.config, n = r ? this.boundaryEl : this.element;
    n && (this.popupService.positionPopup({
      ePopup: n,
      keepWithinBounds: !0,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x: e, y: t })
    }), this.setPosition(parseFloat(n.style.left), parseFloat(n.style.top)));
  }
  constrainSizeToAvailableHeight(e) {
    if (!this.config.forcePopupParentAsOffsetParent)
      return;
    const t = () => {
      const r = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${r}px`);
    };
    e ? this.resizeObserverSubscriber = this.resizeObserverService.observeResize(
      this.popupService.getPopupParent(),
      t
    ) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0));
  }
  setPosition(e, t) {
    this.position.x = e, this.position.y = t;
  }
  updateDragStartPosition(e, t) {
    this.dragStartPosition = { x: e, y: t };
  }
  calculateMouseMovement(e) {
    const { e: t, isLeft: r, isTop: n, anywhereWithin: i, topBuffer: o } = e, a = t.clientX - this.dragStartPosition.x, s = t.clientY - this.dragStartPosition.y, l = this.shouldSkipX(t, !!r, !!i, a) ? 0 : a, u = this.shouldSkipY(t, !!n, o, s) ? 0 : s;
    return { movementX: l, movementY: u };
  }
  shouldSkipX(e, t, r, n) {
    const i = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), a = this.boundaryEl.getBoundingClientRect(), s = this.config.popup ? this.position.x : i.left;
    let l = s <= 0 && o.left >= e.clientX || o.right <= e.clientX && o.right <= a.right;
    return l ? !0 : (t ? l = // skip if we are moving to the left and the cursor
    // is positioned to the right of the left side anchor
    n < 0 && e.clientX > s + o.left || // skip if we are moving to the right and the cursor
    // is positioned to the left of the dialog
    n > 0 && e.clientX < s + o.left : r ? l = n < 0 && e.clientX > a.right || n > 0 && e.clientX < s + o.left : l = // if the movement is bound to the right side of the dialog
    // we skip if we are moving to the left and the cursor
    // is to the right of the dialog
    n < 0 && e.clientX > a.right || // or skip if we are moving to the right and the cursor
    // is to the left of the right side anchor
    n > 0 && e.clientX < a.right, l);
  }
  shouldSkipY(e, t, r = 0, n) {
    const i = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), a = this.boundaryEl.getBoundingClientRect(), s = this.config.popup ? this.position.y : i.top;
    let l = s <= 0 && o.top >= e.clientY || o.bottom <= e.clientY && o.bottom <= a.bottom;
    return l ? !0 : (t ? l = // skip if we are moving to towards top and the cursor is
    // below the top anchor + topBuffer
    // note: topBuffer is used when moving the dialog using the title bar
    n < 0 && e.clientY > s + o.top + r || // skip if we are moving to the bottom and the cursor is
    // above the top anchor
    n > 0 && e.clientY < s + o.top : l = // skip if we are moving towards the top and the cursor
    // is below the bottom anchor
    n < 0 && e.clientY > a.bottom || // skip if we are moving towards the bottom and the cursor
    // is above the bottom anchor
    n > 0 && e.clientY < a.bottom, l);
  }
  createResizeMap() {
    const e = this.element;
    this.resizerMap = {
      topLeft: { element: e.querySelector("[data-ref=eTopLeftResizer]") },
      top: { element: e.querySelector("[data-ref=eTopResizer]") },
      topRight: { element: e.querySelector("[data-ref=eTopRightResizer]") },
      right: { element: e.querySelector("[data-ref=eRightResizer]") },
      bottomRight: { element: e.querySelector("[data-ref=eBottomRightResizer]") },
      bottom: { element: e.querySelector("[data-ref=eBottomResizer]") },
      bottomLeft: { element: e.querySelector("[data-ref=eBottomLeftResizer]") },
      left: { element: e.querySelector("[data-ref=eLeftResizer]") }
    };
  }
  addResizers() {
    if (this.resizersAdded)
      return;
    const e = this.element;
    if (!e)
      return;
    const r = new DOMParser().parseFromString(Y4e, "text/html").body;
    e.appendChild(r.firstChild), this.createResizeMap(), this.resizersAdded = !0;
  }
  removeResizers() {
    this.resizerMap = void 0;
    const e = this.element.querySelector(`.${fq}`);
    e && this.element.removeChild(e), this.resizersAdded = !1;
  }
  getResizerElement(e) {
    return this.resizerMap[e].element;
  }
  onResizeStart(e, t) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
      isTop: !!t.match(/top/i),
      isRight: !!t.match(/right/i),
      isBottom: !!t.match(/bottom/i),
      isLeft: !!t.match(/left/i)
    }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
    const { popup: r, forcePopupParentAsOffsetParent: n } = this.config;
    !r && !n && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const t = this.element.parentElement;
    return t ? Array.prototype.slice.call(t.children).filter((r) => !r.classList.contains("ag-hidden")) : null;
  }
  getMinSizeOfSiblings() {
    const e = this.getSiblings() || [];
    let t = 0, r = 0;
    for (let n = 0; n < e.length; n++) {
      const i = e[n], o = !!i.style.flex && i.style.flex !== "0 0 auto";
      if (i === this.element)
        continue;
      let a = this.minHeight || 0, s = this.minWidth || 0;
      if (o) {
        const l = window.getComputedStyle(i);
        l.minHeight && (a = parseInt(l.minHeight, 10)), l.minWidth && (s = parseInt(l.minWidth, 10));
      } else
        a = i.offsetHeight, s = i.offsetWidth;
      t += a, r += s;
    }
    return { height: t, width: r };
  }
  applySizeToSiblings(e) {
    let t = null;
    const r = this.getSiblings();
    if (r) {
      for (let n = 0; n < r.length; n++) {
        const i = r[n];
        i !== t && (e ? i.style.height = `${i.offsetHeight}px` : i.style.width = `${i.offsetWidth}px`, i.style.flex = "0 0 auto", i === this.element && (t = r[n + 1]));
      }
      t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto");
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((e) => e);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer)
      return;
    const { popup: t, forcePopupParentAsOffsetParent: r } = this.config, { isTop: n, isRight: i, isBottom: o, isLeft: a } = this.currentResizer, s = i || a, l = o || n, { movementX: u, movementY: c } = this.calculateMouseMovement({ e, isLeft: a, isTop: n }), d = this.position.x, h = this.position.y;
    let f = 0, p = 0;
    if (s && u) {
      const g = a ? -1 : 1, v = this.getWidth(), m = v + u * g;
      let y = !1;
      a && (f = v - m, (d + f <= 0 || m <= this.minWidth) && (y = !0, f = 0)), y || this.setWidth(m);
    }
    if (l && c) {
      const g = n ? -1 : 1, v = this.getHeight(), m = v + c * g;
      let y = !1;
      n ? (p = v - m, (h + p <= 0 || m <= this.minHeight) && (y = !0, p = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && v < m && this.getMinSizeOfSiblings().height + m > this.element.parentElement.offsetHeight && (y = !0), y || this.setHeight(m);
    }
    this.updateDragStartPosition(e.clientX, e.clientY), ((t || r) && f || p) && this.offsetElement(d + f, h + p);
  }
  onResizeEnd(e, t) {
    this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null, this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchLocalEvent({ type: "resize" });
  }
  refreshSize() {
    const e = this.element;
    this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight));
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving)
      return;
    const { x: t, y: r } = this.position;
    let n;
    this.config.calculateTopBuffer && (n = this.config.calculateTopBuffer());
    const { movementX: i, movementY: o } = this.calculateMouseMovement({
      e,
      isTop: !0,
      anywhereWithin: !0,
      topBuffer: n
    });
    this.offsetElement(t + i, r + o), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    this.config.forcePopupParentAsOffsetParent ? this.offsetParent = this.popupService.getPopupParent() : this.offsetParent = this.element.offsetParent;
  }
  findBoundaryElement() {
    let e = this.element;
    for (; e; ) {
      if (window.getComputedStyle(e).position !== "static")
        return e;
      e = e.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    for (; this.resizeListeners.length; ) {
      const e = this.resizeListeners.pop();
      this.dragService.removeDragSource(e);
    }
  }
  destroy() {
    super.destroy(), this.moveElementDragListener && this.dragService.removeDragSource(this.moveElementDragListener), this.constrainSizeToAvailableHeight(!1), this.clearResizeListeners(), this.removeResizers();
  }
}, pq = class gq extends Se {
  constructor(t, r = {}) {
    super(), this.eFocusableElement = t, this.callbacks = r, this.callbacks = {
      shouldStopEventPropagation: () => !1,
      onTabKeyDown: (n) => {
        if (n.defaultPrevented)
          return;
        const i = this.focusService.findNextFocusableElement(this.eFocusableElement, !1, n.shiftKey);
        i && (i.focus(), n.preventDefault());
      },
      ...r
    };
  }
  wireBeans(t) {
    this.focusService = t.focusService;
  }
  postConstruct() {
    this.eFocusableElement.classList.add(gq.FOCUS_MANAGED_CLASS), this.addKeyDownListeners(this.eFocusableElement), this.callbacks.onFocusIn && this.addManagedElementListeners(this.eFocusableElement, { focusin: this.callbacks.onFocusIn }), this.callbacks.onFocusOut && this.addManagedElementListeners(this.eFocusableElement, { focusout: this.callbacks.onFocusOut });
  }
  addKeyDownListeners(t) {
    this.addManagedElementListeners(t, {
      keydown: (r) => {
        if (!(r.defaultPrevented || Yl(r))) {
          if (this.callbacks.shouldStopEventPropagation(r)) {
            ef(r);
            return;
          }
          r.key === pe.TAB ? this.callbacks.onTabKeyDown(r) : this.callbacks.handleKeyDown && this.callbacks.handleKeyDown(r);
        }
      }
    });
  }
};
pq.FOCUS_MANAGED_CLASS = "ag-focus-managed";
var gd = pq, vq = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose one",
  equals: "Equals",
  notEqual: "Does not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "Between",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equal to",
  greaterThanOrEqual: "Greater than or equal to",
  contains: "Contains",
  notContains: "Does not contain",
  startsWith: "Begins with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  before: "Before",
  after: "After",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};
function gI(e, t) {
  return sS(e) ? (e.debounceMs != null && Te("debounceMs is ignored when apply button is present"), 0) : e.debounceMs != null ? e.debounceMs : t;
}
function sS(e) {
  return !!e.buttons && e.buttons.indexOf("apply") >= 0;
}
var X4e = class extends tn {
  constructor(e) {
    super(), this.filterNameKey = e, this.applyActive = !1, this.hidePopup = null, this.debouncePending = !1, this.appliedModel = null, this.eFilterBody = Pt, this.buttonListeners = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.resetTemplate(), this.createManagedBean(
      new gd(this.getFocusableElement(), {
        handleKeyDown: this.handleKeyDown.bind(this)
      })
    ), this.positionableFeature = new q4e(this.getPositionableElement(), {
      forcePopupParentAsOffsetParent: !0
    }), this.createBean(this.positionableFeature);
  }
  // override
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleKeyDown(e) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(e) {
    let t = this.getGui();
    t && t.removeEventListener("submit", this.onFormSubmit);
    const r = (
      /* html */
      `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" data-ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`
    );
    this.setTemplate(r, this.getAgComponents(), e), t = this.getGui(), t && t.addEventListener("submit", this.onFormSubmit);
  }
  isReadOnly() {
    return !!this.providedFilterParams.readOnly;
  }
  init(e) {
    this.setParams(e), this.resetUiToDefaults(!0).then(() => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  setParams(e) {
    this.providedFilterParams = e, this.applyActive = sS(e), this.resetButtonsPanel();
  }
  updateParams(e) {
    this.providedFilterParams = e, this.applyActive = sS(e), this.resetUiToActiveModel(this.getModel(), () => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  resetButtonsPanel() {
    const { buttons: e } = this.providedFilterParams, t = e && e.length > 0 && !this.isReadOnly();
    if (this.eButtonsPanel ? (xo(this.eButtonsPanel), this.buttonListeners.forEach((i) => i()), this.buttonListeners = []) : t && (this.eButtonsPanel = document.createElement("div"), this.eButtonsPanel.classList.add("ag-filter-apply-panel")), !t) {
      this.eButtonsPanel && Xc(this.eButtonsPanel);
      return;
    }
    const r = document.createDocumentFragment(), n = (i) => {
      let o, a;
      switch (i) {
        case "apply":
          o = this.translate("applyFilter"), a = (u) => this.onBtApply(!1, !1, u);
          break;
        case "clear":
          o = this.translate("clearFilter"), a = () => this.onBtClear();
          break;
        case "reset":
          o = this.translate("resetFilter"), a = () => this.onBtReset();
          break;
        case "cancel":
          o = this.translate("cancelFilter"), a = (u) => {
            this.onBtCancel(u);
          };
          break;
        default:
          Te("Unknown button type specified");
          return;
      }
      const l = rf(
        /* html */
        `<button
                    type="${i === "apply" ? "submit" : "button"}"
                    data-ref="${i}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${o}
                </button>`
      );
      this.buttonListeners.push(...this.addManagedElementListeners(l, { click: a })), r.append(l);
    };
    e.forEach((i) => n(i)), this.eButtonsPanel.append(r), this.getGui().appendChild(this.eButtonsPanel);
  }
  // subclasses can override this to provide alternative debounce defaults
  getDefaultDebounceMs() {
    return 0;
  }
  setupOnBtApplyDebounce() {
    const e = gI(this.providedFilterParams, this.getDefaultDebounceMs()), t = Ti(this.checkApplyDebounce.bind(this), e);
    this.onBtApplyDebounce = () => {
      this.debouncePending = !0, t();
    };
  }
  checkApplyDebounce() {
    this.debouncePending && (this.debouncePending = !1, this.onBtApply());
  }
  getModel() {
    return this.appliedModel ? this.appliedModel : null;
  }
  setModel(e) {
    return (e != null ? this.setModelIntoUi(e) : this.resetUiToDefaults()).then(() => {
      this.updateUiVisibility(), this.applyModel("api");
    });
  }
  onBtCancel(e) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(e);
    });
  }
  handleCancelEnd(e) {
    this.providedFilterParams.closeOnApply && this.close(e);
  }
  resetUiToActiveModel(e, t) {
    const r = () => {
      this.onUiChanged(!1, "prevent"), t == null || t();
    };
    e != null ? this.setModelIntoUi(e).then(r) : this.resetUiToDefaults().then(r);
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear(), this.onBtApply();
  }
  /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  applyModel(e = "api") {
    const t = this.getModelFromUi();
    if (!this.isModelValid(t))
      return !1;
    const r = this.appliedModel;
    return this.appliedModel = t, !this.areModelsEqual(r, t);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isModelValid(e) {
    return !0;
  }
  onFormSubmit(e) {
    e.preventDefault();
  }
  onBtApply(e = !1, t = !1, r) {
    r && r.preventDefault(), this.applyModel(t ? "rowDataUpdated" : "ui") && this.providedFilterParams.filterChangedCallback({ afterFloatingFilter: e, afterDataChange: t, source: "columnFilter" });
    const { closeOnApply: n } = this.providedFilterParams;
    n && this.applyActive && !e && !t && this.close(r);
  }
  onNewRowsLoaded() {
  }
  close(e) {
    if (!this.hidePopup)
      return;
    const t = e, r = t && t.key;
    let n;
    (r === "Enter" || r === "Space") && (n = { keyboardEvent: t }), this.hidePopup(n), this.hidePopup = null;
  }
  /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */
  onUiChanged(e = !1, t) {
    if (this.updateUiVisibility(), this.providedFilterParams.filterModifiedCallback(), this.applyActive && !this.isReadOnly()) {
      const r = this.isModelValid(this.getModelFromUi()), n = this.queryForHtmlElement('[data-ref="applyFilterButton"]');
      n && gv(n, !r);
    }
    e && !t || t === "immediately" ? this.onBtApply(e) : (!this.applyActive && !t || t === "debounce") && this.onBtApplyDebounce();
  }
  afterGuiAttached(e) {
    e && (this.hidePopup = e.hidePopup), this.refreshFilterResizer(e == null ? void 0 : e.container);
  }
  refreshFilterResizer(e) {
    if (!this.positionableFeature || e === "toolPanel")
      return;
    const t = e === "floatingFilter" || e === "columnFilter", { positionableFeature: r, gos: n } = this;
    t ? (r.restoreLastSize(), r.setResizable(
      n.get("enableRtl") ? { bottom: !0, bottomLeft: !0, left: !0 } : { bottom: !0, bottomRight: !0, right: !0 }
    )) : (this.positionableFeature.removeSizeFromEl(), this.positionableFeature.setResizable(!1)), this.positionableFeature.constrainSizeToAvailableHeight(!0);
  }
  afterGuiDetached() {
    this.checkApplyDebounce(), this.positionableFeature && this.positionableFeature.constrainSizeToAvailableHeight(!1);
  }
  refresh(e) {
    return this.providedFilterParams = e, !0;
  }
  destroy() {
    const e = this.getGui();
    e && e.removeEventListener("submit", this.onFormSubmit), this.hidePopup = null, this.positionableFeature && (this.positionableFeature = this.destroyBean(this.positionableFeature)), this.appliedModel = null, super.destroy();
  }
  translate(e) {
    return this.localeService.getLocaleTextFunc()(e, vq[e]);
  }
  getCellValue(e) {
    return this.providedFilterParams.getValue(e);
  }
  // override to control positionable feature
  getPositionableElement() {
    return this.eFilterBody;
  }
}, Z4e = class extends hI {
  constructor(e) {
    super(e, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    this.eInput.disabled || this.isSelected() || this.setValue(!0);
  }
  addInputListeners() {
    super.addInputListeners(), this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
  }
  /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */
  onChange(e) {
    e.selected && e.name && this.eInput.name && this.eInput.name === e.name && e.id && this.eInput.id !== e.id && this.setValue(!1, !0);
  }
}, Q4e = class extends tn {
  constructor(e = "default", t = !1) {
    super(
      /* html */
      `<div class="ag-list ag-${e}-list" role="listbox"></div>`
    ), this.cssIdentifier = e, this.unFocusable = t, this.activeClass = "ag-active-item", this.options = [], this.itemEls = [];
  }
  postConstruct() {
    const e = this.getGui();
    this.addManagedElementListeners(e, { mouseleave: () => this.clearHighlighted() }), !this.unFocusable && this.addManagedElementListeners(e, { keydown: this.handleKeyDown.bind(this) });
  }
  handleKeyDown(e) {
    const t = e.key;
    switch (t) {
      case pe.ENTER:
        if (!this.highlightedEl)
          this.setValue(this.getValue());
        else {
          const r = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(r);
        }
        break;
      case pe.DOWN:
      case pe.UP:
        e.preventDefault(), this.navigate(t);
        break;
      case pe.PAGE_DOWN:
      case pe.PAGE_UP:
      case pe.PAGE_HOME:
      case pe.PAGE_END:
        e.preventDefault(), this.navigateToPage(t);
        break;
    }
  }
  navigate(e) {
    const t = e === pe.DOWN;
    let r;
    if (!this.highlightedEl)
      r = this.itemEls[t ? 0 : this.itemEls.length - 1];
    else {
      let i = this.itemEls.indexOf(this.highlightedEl) + (t ? 1 : -1);
      i = Math.min(Math.max(i, 0), this.itemEls.length - 1), r = this.itemEls[i];
    }
    this.highlightItem(r);
  }
  navigateToPage(e) {
    if (!this.highlightedEl || this.itemEls.length === 0)
      return;
    const t = this.itemEls.indexOf(this.highlightedEl), r = this.options.length - 1, n = this.itemEls[0].clientHeight, i = Math.floor(this.getGui().clientHeight / n);
    let o = -1;
    e === pe.PAGE_HOME ? o = 0 : e === pe.PAGE_END ? o = r : e === pe.PAGE_DOWN ? o = Math.min(t + i, r) : e === pe.PAGE_UP && (o = Math.max(t - i, 0)), o !== -1 && this.highlightItem(this.itemEls[o]);
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    const { value: t, text: r } = e, n = r || t;
    return this.options.push({ value: t, text: n }), this.renderOption(t, n), this.updateIndices(), this;
  }
  clearOptions() {
    this.options = [], this.reset(!0), this.itemEls.forEach((e) => {
      Xc(e);
    }), this.itemEls = [];
  }
  updateIndices() {
    const e = this.getGui().querySelectorAll(".ag-list-item");
    e.forEach((t, r) => {
      OBe(t, r + 1), IBe(t, e.length);
    });
  }
  renderOption(e, t) {
    const r = this.gos.getDocument(), n = r.createElement("div");
    Na(n, "option"), n.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
    const i = r.createElement("span");
    n.appendChild(i), i.textContent = t, this.unFocusable || (n.tabIndex = -1), this.itemEls.push(n), this.addManagedListeners(n, {
      mouseover: () => this.highlightItem(n),
      mousedown: (o) => {
        o.preventDefault(), o.stopPropagation(), this.setValue(e);
      }
    }), this.createManagedBean(
      new If({
        getTooltipValue: () => t,
        getGui: () => n,
        getLocation: () => "UNKNOWN",
        // only show tooltips for items where the text cannot be fully displayed
        shouldDisplayTooltip: () => i.scrollWidth > i.clientWidth
      })
    ), this.getGui().appendChild(n);
  }
  setValue(e, t) {
    if (this.value === e)
      return this.fireItemSelected(), this;
    if (e == null)
      return this.reset(t), this;
    const r = this.options.findIndex((n) => n.value === e);
    if (r !== -1) {
      const n = this.options[r];
      this.value = n.value, this.displayValue = n.text, this.highlightItem(this.itemEls[r]), t || this.fireChangeEvent();
    }
    return this;
  }
  setValueByIndex(e) {
    return this.setValue(this.options[e].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const e = this.options.findIndex((t) => t.value === this.value);
    e !== -1 && this.highlightItem(this.itemEls[e]);
  }
  reset(e) {
    this.value = null, this.displayValue = null, this.clearHighlighted(), e || this.fireChangeEvent();
  }
  highlightItem(e) {
    if (!ys(e))
      return;
    this.clearHighlighted(), this.highlightedEl = e, this.highlightedEl.classList.add(this.activeClass), tS(this.highlightedEl, !0);
    const t = this.getGui(), { scrollTop: r, clientHeight: n } = t, { offsetTop: i, offsetHeight: o } = e;
    (i + o > r + n || i < r) && this.highlightedEl.scrollIntoView({ block: "nearest" }), this.unFocusable || this.highlightedEl.focus();
  }
  clearHighlighted() {
    !this.highlightedEl || !ys(this.highlightedEl) || (this.highlightedEl.classList.remove(this.activeClass), tS(this.highlightedEl, !1), this.highlightedEl = null);
  }
  fireChangeEvent() {
    this.dispatchLocalEvent({ type: "fieldValueChanged" }), this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchLocalEvent({ type: "selectedItem" });
  }
}, J4e = class extends aq {
  constructor(e) {
    if (super(
      e,
      (e == null ? void 0 : e.template) || /* html */
      `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                    <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
                    <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
      (e == null ? void 0 : e.agComponents) || [],
      e == null ? void 0 : e.className
    ), this.isPickerDisplayed = !1, this.skipClick = !1, this.pickerGap = 4, this.hideCurrentPicker = null, this.eLabel = Pt, this.eWrapper = Pt, this.eDisplayField = Pt, this.eIcon = Pt, this.ariaRole = e == null ? void 0 : e.ariaRole, this.onPickerFocusIn = this.onPickerFocusIn.bind(this), this.onPickerFocusOut = this.onPickerFocusOut.bind(this), !e)
      return;
    const { pickerGap: t, maxPickerHeight: r, variableWidth: n, minPickerWidth: i, maxPickerWidth: o } = e;
    t != null && (this.pickerGap = t), this.variableWidth = !!n, r != null && this.setPickerMaxHeight(r), i != null && this.setPickerMinWidth(i), o != null && this.setPickerMaxWidth(o);
  }
  wireBeans(e) {
    this.popupService = e.popupService;
  }
  postConstruct() {
    super.postConstruct(), this.setupAria();
    const e = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", e);
    const t = this.getAriaElement();
    this.addManagedElementListeners(t, { keydown: this.onKeyDown.bind(this) }), this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) }), this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
    const { pickerIcon: r, inputWidth: n } = this.config;
    if (r) {
      const i = yo(r, this.gos);
      i && this.eIcon.appendChild(i);
    }
    n != null && this.setInputWidth(n);
  }
  setupAria() {
    const e = this.getAriaElement();
    e.setAttribute("tabindex", this.gos.get("tabIndex").toString()), eS(e, !1), this.ariaRole && Na(e, this.ariaRole);
  }
  onLabelOrWrapperMouseDown(e) {
    if (e) {
      const t = this.getFocusableElement();
      if (t !== this.eWrapper && (e == null ? void 0 : e.target) === t)
        return;
      e.preventDefault(), this.getFocusableElement().focus();
    }
    if (this.skipClick) {
      this.skipClick = !1;
      return;
    }
    this.isDisabled() || (this.isPickerDisplayed ? this.hidePicker() : this.showPicker());
  }
  onKeyDown(e) {
    switch (e.key) {
      case pe.UP:
      case pe.DOWN:
      case pe.ENTER:
      case pe.SPACE:
        e.preventDefault(), this.onLabelOrWrapperMouseDown();
        break;
      case pe.ESCAPE:
        this.isPickerDisplayed && (e.preventDefault(), e.stopPropagation(), this.hideCurrentPicker && this.hideCurrentPicker());
        break;
    }
  }
  showPicker() {
    this.isPickerDisplayed = !0, this.pickerComponent || (this.pickerComponent = this.createPickerComponent());
    const e = this.pickerComponent.getGui();
    e.addEventListener("focusin", this.onPickerFocusIn), e.addEventListener("focusout", this.onPickerFocusOut), this.hideCurrentPicker = this.renderAndPositionPicker(), this.toggleExpandedStyles(!0);
  }
  renderAndPositionPicker() {
    const e = this.gos.getDocument(), t = this.pickerComponent.getGui();
    this.gos.get("suppressScrollWhenPopupsAreOpen") || ([this.destroyMouseWheelFunc] = this.addManagedEventListeners({
      bodyScroll: () => {
        this.hidePicker();
      }
    }));
    const r = this.localeService.getLocaleTextFunc(), { pickerAriaLabelKey: n, pickerAriaLabelValue: i, modalPicker: o = !0 } = this.config, a = {
      modal: o,
      eChild: t,
      closeOnEsc: !0,
      closedCallback: () => {
        const f = this.gos.getActiveDomElement(), p = !f || f === e.body;
        this.beforeHidePicker(), p && this.isAlive() && this.getFocusableElement().focus();
      },
      ariaLabel: r(n, i)
    }, s = this.popupService.addPopup(a), { maxPickerHeight: l, minPickerWidth: u, maxPickerWidth: c, variableWidth: d } = this;
    d ? (u && (t.style.minWidth = u), t.style.width = uI(rS(this.eWrapper)), c && (t.style.maxWidth = c)) : aS(t, c ?? rS(this.eWrapper));
    const h = l ?? `${lI(this.popupService.getPopupParent())}px`;
    return t.style.setProperty("max-height", h), t.style.position = "absolute", this.alignPickerToComponent(), s.hideFunc;
  }
  alignPickerToComponent() {
    if (!this.pickerComponent)
      return;
    const { pickerType: e } = this.config, { pickerGap: t } = this, r = this.gos.get("enableRtl") ? "right" : "left";
    this.popupService.positionPopupByComponent({
      type: e,
      eventSource: this.eWrapper,
      ePopup: this.pickerComponent.getGui(),
      position: "under",
      alignSide: r,
      keepWithinBounds: !0,
      nudgeY: t
    });
  }
  beforeHidePicker() {
    this.destroyMouseWheelFunc && (this.destroyMouseWheelFunc(), this.destroyMouseWheelFunc = void 0), this.toggleExpandedStyles(!1);
    const e = this.pickerComponent.getGui();
    e.removeEventListener("focusin", this.onPickerFocusIn), e.removeEventListener("focusout", this.onPickerFocusOut), this.isPickerDisplayed = !1, this.pickerComponent = void 0, this.hideCurrentPicker = null;
  }
  toggleExpandedStyles(e) {
    if (!this.isAlive())
      return;
    const t = this.getAriaElement();
    eS(t, e), this.eWrapper.classList.toggle("ag-picker-expanded", e), this.eWrapper.classList.toggle("ag-picker-collapsed", !e);
  }
  onPickerFocusIn() {
    this.togglePickerHasFocus(!0);
  }
  onPickerFocusOut(e) {
    var t;
    (t = this.pickerComponent) != null && t.getGui().contains(e.relatedTarget) || this.togglePickerHasFocus(!1);
  }
  togglePickerHasFocus(e) {
    this.pickerComponent && this.eWrapper.classList.toggle("ag-picker-has-focus", e);
  }
  hidePicker() {
    this.hideCurrentPicker && this.hideCurrentPicker();
  }
  setInputWidth(e) {
    return aS(this.eWrapper, e), this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  setPickerGap(e) {
    return this.pickerGap = e, this;
  }
  setPickerMinWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.minPickerWidth = e ?? void 0, this;
  }
  setPickerMaxWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerWidth = e ?? void 0, this;
  }
  setPickerMaxHeight(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerHeight = e ?? void 0, this;
  }
  destroy() {
    this.hidePicker(), super.destroy();
  }
}, vI = class extends J4e {
  constructor(e) {
    super({
      pickerAriaLabelKey: "ariaLabelSelectField",
      pickerAriaLabelValue: "Select Field",
      pickerType: "ag-list",
      className: "ag-select",
      pickerIcon: "smallDown",
      ariaRole: "combobox",
      ...e
    });
  }
  postConstruct() {
    super.postConstruct(), this.createListComponent(), this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { options: e, value: t, placeholder: r } = this.config;
    e != null && this.addOptions(e), t != null && this.setValue(t, !0), r && t == null && (this.eDisplayField.textContent = r), this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
  }
  onWrapperFocusOut(e) {
    this.eWrapper.contains(e.relatedTarget) || this.hidePicker();
  }
  createListComponent() {
    this.listComponent = this.createBean(new Q4e("select", !0)), this.listComponent.setParentComponent(this);
    const e = this.listComponent.getAriaElement(), t = `ag-select-list-${this.listComponent.getCompId()}`;
    e.setAttribute("id", t), $Be(this.getAriaElement(), e), this.listComponent.addManagedListeners(this.listComponent, {
      selectedItem: () => {
        this.hidePicker(), this.dispatchLocalEvent({ type: "selectedItem" });
      }
    }), this.listComponent.addManagedListeners(this.listComponent, {
      fieldValueChanged: () => {
        this.listComponent && (this.setValue(this.listComponent.getValue(), !1, !0), this.hidePicker());
      }
    });
  }
  createPickerComponent() {
    return this.listComponent;
  }
  onKeyDown(e) {
    var r;
    const { key: t } = e;
    switch (t === pe.TAB && this.hidePicker(), t) {
      case pe.ENTER:
      case pe.UP:
      case pe.DOWN:
      case pe.PAGE_UP:
      case pe.PAGE_DOWN:
      case pe.PAGE_HOME:
      case pe.PAGE_END:
        e.preventDefault(), this.isPickerDisplayed ? (r = this.listComponent) == null || r.handleKeyDown(e) : super.onKeyDown(e);
        break;
      case pe.ESCAPE:
        super.onKeyDown(e);
        break;
    }
  }
  showPicker() {
    this.listComponent && (super.showPicker(), this.listComponent.refreshHighlighted());
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    return this.listComponent.addOption(e), this;
  }
  clearOptions() {
    var e;
    return (e = this.listComponent) == null || e.clearOptions(), this;
  }
  setValue(e, t, r) {
    if (this.value === e || !this.listComponent)
      return this;
    if (r || this.listComponent.setValue(e, !0), this.listComponent.getValue() === this.getValue())
      return this;
    let i = this.listComponent.getDisplayValue();
    return i == null && this.config.placeholder && (i = this.config.placeholder), this.eDisplayField.textContent = i, this.setTooltip({
      newTooltipText: i ?? null,
      shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
    }), super.setValue(e, t);
  }
  destroy() {
    this.listComponent && (this.listComponent = this.destroyBean(this.listComponent)), super.destroy();
  }
}, e$e = {
  selector: "AG-SELECT",
  component: vI
}, mq = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(e, t) {
    this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e);
  }
  getFilterOptions() {
    return this.filterOptions;
  }
  mapCustomOptions() {
    this.filterOptions && this.filterOptions.forEach((e) => {
      if (typeof e == "string")
        return;
      const t = [["displayKey"], ["displayName"], ["predicate", "test"]], r = (n) => n.some((i) => e[i] != null) ? !0 : (Te(`ignoring FilterOptionDef as it doesn't contain one of '${n}'`), !1);
      if (!t.every(r)) {
        this.filterOptions = this.filterOptions.filter((n) => n === e) || [];
        return;
      }
      this.customFilterOptions[e.displayKey] = e;
    });
  }
  selectDefaultItem(e) {
    if (e.defaultOption)
      this.defaultOption = e.defaultOption;
    else if (this.filterOptions.length >= 1) {
      const t = this.filterOptions[0];
      typeof t == "string" ? this.defaultOption = t : t.displayKey ? this.defaultOption = t.displayKey : Te("invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'");
    } else
      Te("no filter options for filter");
  }
  getDefaultOption() {
    return this.defaultOption;
  }
  getCustomOption(e) {
    return this.customFilterOptions[e];
  }
}, yq = class extends X4e {
  constructor() {
    super(...arguments), this.eTypes = [], this.eJoinOperatorPanels = [], this.eJoinOperatorsAnd = [], this.eJoinOperatorsOr = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0;
  }
  getNumberOfInputs(e) {
    const t = this.optionsFactory.getCustomOption(e);
    if (t) {
      const { numberOfInputs: n } = t;
      return n ?? 1;
    }
    return e && ["empty", "notBlank", "blank"].indexOf(e) >= 0 ? 0 : e === "inRange" ? 2 : 1;
  }
  // floating filter calls this when user applies filter from floating filter
  onFloatingFilterChanged(e, t) {
    this.setTypeFromFloatingFilter(e), this.setValueFromFloatingFilter(t), this.onUiChanged(!0);
  }
  setTypeFromFloatingFilter(e) {
    this.eTypes.forEach((t, r) => {
      r === 0 ? t.setValue(e, !0) : t.setValue(this.optionsFactory.getDefaultOption(), !0);
    });
  }
  getModelFromUi() {
    const e = this.getUiCompleteConditions();
    return e.length === 0 ? null : this.maxNumConditions > 1 && e.length > 1 ? {
      filterType: this.getFilterType(),
      operator: this.getJoinOperator(),
      conditions: e
    } : e[0];
  }
  getConditionTypes() {
    return this.eTypes.map((e) => e.getValue());
  }
  getConditionType(e) {
    return this.eTypes[e].getValue();
  }
  getJoinOperator() {
    return this.eJoinOperatorsOr.length === 0 ? this.defaultJoinOperator : this.eJoinOperatorsOr[0].getValue() === !0 ? "OR" : "AND";
  }
  areModelsEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e && t || e && !t)
      return !1;
    const r = !e.operator, n = !t.operator;
    if (!r && n || r && !n)
      return !1;
    let o;
    if (r) {
      const a = e, s = t;
      o = this.areSimpleModelsEqual(a, s);
    } else {
      const a = e, s = t;
      o = a.operator === s.operator && fd(
        a.conditions,
        s.conditions,
        (l, u) => this.areSimpleModelsEqual(l, u)
      );
    }
    return o;
  }
  shouldRefresh(e) {
    var o;
    const t = this.getModel(), r = t ? t.conditions ?? [t] : null, n = ((o = e.filterOptions) == null ? void 0 : o.map((a) => typeof a == "string" ? a : a.displayKey)) ?? this.getDefaultFilterOptions();
    return !(!(!r || r.every((a) => n.find((s) => s === a.type) !== void 0)) || typeof e.maxNumConditions == "number" && r && r.length > e.maxNumConditions);
  }
  refresh(e) {
    return !this.shouldRefresh(e) || !super.refresh(e) ? !1 : (this.setParams(e), this.removeConditionsAndOperators(0), this.createOption(), this.setModel(this.getModel()), !0);
  }
  setModelIntoUi(e) {
    if (e.operator) {
      const r = e;
      let n = r.conditions;
      n == null && (n = [], Te("Filter model is missing 'conditions'"));
      const i = this.validateAndUpdateConditions(n), o = this.getNumConditions();
      if (i < o)
        this.removeConditionsAndOperators(i);
      else if (i > o)
        for (let s = o; s < i; s++)
          this.createJoinOperatorPanel(), this.createOption();
      const a = r.operator === "OR";
      this.eJoinOperatorsAnd.forEach((s) => s.setValue(!a, !0)), this.eJoinOperatorsOr.forEach((s) => s.setValue(a, !0)), n.forEach((s, l) => {
        this.eTypes[l].setValue(s.type, !0), this.setConditionIntoUi(s, l);
      });
    } else {
      const r = e;
      this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(r.type, !0), this.setConditionIntoUi(r, 0);
    }
    return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.onUiChanged(), gn.resolve();
  }
  validateAndUpdateConditions(e) {
    let t = e.length;
    return t > this.maxNumConditions && (e.splice(this.maxNumConditions), Te(
      'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.'
    ), t = this.maxNumConditions), t;
  }
  doesFilterPass(e) {
    const t = this.getModel();
    if (t == null)
      return !0;
    const { operator: r } = t, n = [];
    if (r) {
      const o = t;
      n.push(...o.conditions ?? []);
    } else
      n.push(t);
    return n[r && r === "OR" ? "some" : "every"]((o) => this.individualConditionPasses(e, o));
  }
  setParams(e) {
    super.setParams(e), this.setNumConditions(e), this.defaultJoinOperator = this.getDefaultJoinOperator(e.defaultJoinOperator), this.filterPlaceholder = e.filterPlaceholder, this.optionsFactory = new mq(), this.optionsFactory.init(e, this.getDefaultFilterOptions()), this.createFilterListOptions(), this.createOption(), this.createMissingConditionsAndOperators(), this.isReadOnly() && this.eFilterBody.setAttribute("tabindex", "-1");
  }
  setNumConditions(e) {
    this.maxNumConditions = e.maxNumConditions ?? 2, this.maxNumConditions < 1 && (Te('"filterParams.maxNumConditions" must be greater than or equal to zero.'), this.maxNumConditions = 1), this.numAlwaysVisibleConditions = e.numAlwaysVisibleConditions ?? 1, this.numAlwaysVisibleConditions < 1 && (Te('"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.'), this.numAlwaysVisibleConditions = 1), this.numAlwaysVisibleConditions > this.maxNumConditions && (Te(
      '"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".'
    ), this.numAlwaysVisibleConditions = this.maxNumConditions);
  }
  createOption() {
    const e = this.createManagedBean(new vI());
    this.eTypes.push(e), e.addCssClass("ag-filter-select"), this.eFilterBody.appendChild(e.getGui());
    const t = this.createValueElement();
    this.eConditionBodies.push(t), this.eFilterBody.appendChild(t), this.putOptionsIntoDropdown(e), this.resetType(e);
    const r = this.getNumConditions() - 1;
    this.forEachPositionInput(r, (n) => this.resetInput(n)), this.addChangedListeners(e, r);
  }
  createJoinOperatorPanel() {
    const e = document.createElement("div");
    this.eJoinOperatorPanels.push(e), e.classList.add("ag-filter-condition");
    const t = this.createJoinOperator(this.eJoinOperatorsAnd, e, "and"), r = this.createJoinOperator(this.eJoinOperatorsOr, e, "or");
    this.eFilterBody.appendChild(e);
    const n = this.eJoinOperatorPanels.length - 1, i = this.joinOperatorId++;
    this.resetJoinOperatorAnd(t, n, i), this.resetJoinOperatorOr(r, n, i), this.isReadOnly() || (t.onValueChange(this.listener), r.onValueChange(this.listener));
  }
  createJoinOperator(e, t, r) {
    const n = this.createManagedBean(new Z4e());
    return e.push(n), n.addCssClass("ag-filter-condition-operator"), n.addCssClass(`ag-filter-condition-operator-${r}`), t.appendChild(n.getGui()), n;
  }
  getDefaultJoinOperator(e) {
    return e === "AND" || e === "OR" ? e : "AND";
  }
  createFilterListOptions() {
    const e = this.optionsFactory.getFilterOptions();
    this.filterListOptions = e.map(
      (t) => typeof t == "string" ? this.createBoilerplateListOption(t) : this.createCustomListOption(t)
    );
  }
  putOptionsIntoDropdown(e) {
    this.filterListOptions.forEach((t) => {
      e.addOption(t);
    }), e.setDisabled(this.filterListOptions.length <= 1);
  }
  createBoilerplateListOption(e) {
    return { value: e, text: this.translate(e) };
  }
  createCustomListOption(e) {
    const { displayKey: t } = e, r = this.optionsFactory.getCustomOption(e.displayKey);
    return {
      value: t,
      text: r ? this.localeService.getLocaleTextFunc()(r.displayKey, r.displayName) : this.translate(t)
    };
  }
  createBodyTemplate() {
    return "";
  }
  getAgComponents() {
    return [];
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const e = this.getJoinOperator();
    this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e);
  }
  updateNumConditions() {
    let e = -1, t = !0;
    for (let r = 0; r < this.getNumConditions(); r++)
      this.isConditionUiComplete(r) ? e = r : t = !1;
    if (this.shouldAddNewConditionAtEnd(t))
      this.createJoinOperatorPanel(), this.createOption();
    else {
      const r = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
      if (e < r) {
        this.removeConditionsAndOperators(r + 1);
        const n = e + 1, i = r - n;
        i > 0 && this.removeConditionsAndOperators(n, i), this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = e;
  }
  updateConditionStatusesAndValues(e, t) {
    this.eTypes.forEach((n, i) => {
      const o = this.isConditionDisabled(i, e);
      n.setDisabled(o || this.filterListOptions.length <= 1), i === 1 && (gv(this.eJoinOperatorPanels[0], o), this.eJoinOperatorsAnd[0].setDisabled(o), this.eJoinOperatorsOr[0].setDisabled(o));
    }), this.eConditionBodies.forEach((n, i) => {
      ln(n, this.isConditionBodyVisible(i));
    });
    const r = (t ?? this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((n) => {
      n.setValue(!r, !0);
    }), this.eJoinOperatorsOr.forEach((n) => {
      n.setValue(r, !0);
    }), this.forEachInput((n, i, o, a) => {
      this.setElementDisplayed(n, i < a), this.setElementDisabled(n, this.isConditionDisabled(o, e));
    }), this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(e) {
    return e && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(e, t) {
    if (e >= this.getNumConditions())
      return;
    this.removeComponents(this.eTypes, e, t), this.removeElements(this.eConditionBodies, e, t), this.removeValueElements(e, t);
    const r = Math.max(e - 1, 0);
    this.removeElements(this.eJoinOperatorPanels, r, t), this.removeComponents(this.eJoinOperatorsAnd, r, t), this.removeComponents(this.eJoinOperatorsOr, r, t);
  }
  removeElements(e, t, r) {
    this.removeItems(e, t, r).forEach((i) => Xc(i));
  }
  removeComponents(e, t, r) {
    this.removeItems(e, t, r).forEach((i) => {
      Xc(i.getGui()), this.destroyBean(i);
    });
  }
  removeItems(e, t, r) {
    return r == null ? e.splice(t) : e.splice(t, r);
  }
  afterGuiAttached(e) {
    if (super.afterGuiAttached(e), this.resetPlaceholder(), !(e != null && e.suppressFocus))
      if (this.isReadOnly())
        this.eFilterBody.focus();
      else {
        const t = this.getInputs(0)[0];
        if (!t)
          return;
        t instanceof xc && t.getInputElement().focus();
      }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const e = this.getModel();
    this.resetUiToActiveModel(e);
    let t = -1, r = -1, n = !1;
    const i = this.getJoinOperator();
    for (let a = this.getNumConditions() - 1; a >= 0; a--)
      if (this.isConditionUiComplete(a))
        t === -1 && (t = a, r = a);
      else {
        const s = a >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(a - 1), l = a < t;
        (s || l) && (this.removeConditionsAndOperators(a, 1), n = !0, l && r--);
      }
    let o = !1;
    this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), o = !0), this.shouldAddNewConditionAtEnd(r === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), o = !0), o && this.updateConditionStatusesAndValues(r, i), n && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = r;
  }
  getPlaceholderText(e, t) {
    let r = this.translate(e);
    if (rI(this.filterPlaceholder)) {
      const n = this.filterPlaceholder, i = this.eTypes[t].getValue(), o = this.translate(i);
      r = n({
        filterOptionKey: i,
        filterOption: o,
        placeholder: r
      });
    } else typeof this.filterPlaceholder == "string" && (r = this.filterPlaceholder);
    return r;
  }
  // allow sub-classes to reset HTML placeholders after UI update.
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc();
    this.forEachInput((t, r, n, i) => {
      if (!(t instanceof xc))
        return;
      const o = r === 0 && i > 1 ? "inRangeStart" : r === 0 ? "filterOoo" : "inRangeEnd", a = r === 0 && i > 1 ? e("ariaFilterFromValue", "Filter from value") : r === 0 ? e("ariaFilterValue", "Filter Value") : e("ariaFilterToValue", "Filter to Value");
      t.setInputPlaceholder(this.getPlaceholderText(o, n)), t.setInputAriaLabel(a);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setElementValue(e, t, r) {
    e instanceof xc && e.setValue(t != null ? String(t) : null, !0);
  }
  setElementDisplayed(e, t) {
    e instanceof tn && ln(e.getGui(), t);
  }
  setElementDisabled(e, t) {
    e instanceof tn && gv(e.getGui(), t);
  }
  attachElementOnChange(e, t) {
    e instanceof xc && e.onValueChange(t);
  }
  forEachInput(e) {
    this.getConditionTypes().forEach((t, r) => {
      this.forEachPositionTypeInput(r, t, e);
    });
  }
  forEachPositionInput(e, t) {
    const r = this.getConditionType(e);
    this.forEachPositionTypeInput(e, r, t);
  }
  forEachPositionTypeInput(e, t, r) {
    const n = this.getNumberOfInputs(t), i = this.getInputs(e);
    for (let o = 0; o < i.length; o++) {
      const a = i[o];
      a != null && r(a, o, e, n);
    }
  }
  isConditionDisabled(e, t) {
    return this.isReadOnly() ? !0 : e === 0 ? !1 : e > t + 1;
  }
  isConditionBodyVisible(e) {
    const t = this.getConditionType(e);
    return this.getNumberOfInputs(t) > 0;
  }
  // returns true if the UI represents a working filter, eg all parts are filled out.
  // eg if text filter and textfield blank then returns false.
  isConditionUiComplete(e) {
    return !(e >= this.getNumConditions() || this.getConditionType(e) === "empty" || this.getValues(e).some((r) => r == null));
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const e = [];
    for (let t = 0; t < this.getNumConditions(); t++)
      this.isConditionUiComplete(t) && e.push(this.createCondition(t));
    return e;
  }
  createMissingConditionsAndOperators() {
    if (!this.isReadOnly())
      for (let e = this.getNumConditions(); e < this.numAlwaysVisibleConditions; e++)
        this.createJoinOperatorPanel(), this.createOption();
  }
  resetUiToDefaults(e) {
    return this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach((t) => this.resetType(t)), this.eJoinOperatorsAnd.forEach(
      (t, r) => this.resetJoinOperatorAnd(t, r, this.joinOperatorId + r)
    ), this.eJoinOperatorsOr.forEach(
      (t, r) => this.resetJoinOperatorOr(t, r, this.joinOperatorId + r)
    ), this.joinOperatorId++, this.forEachInput((t) => this.resetInput(t)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, e || this.onUiChanged(), gn.resolve();
  }
  resetType(e) {
    const r = this.localeService.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
    e.setValue(this.optionsFactory.getDefaultOption(), !0).setAriaLabel(r).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(e, t, r) {
    this.resetJoinOperator(
      e,
      t,
      this.isDefaultOperator("AND"),
      this.translate("andCondition"),
      r
    );
  }
  resetJoinOperatorOr(e, t, r) {
    this.resetJoinOperator(
      e,
      t,
      this.isDefaultOperator("OR"),
      this.translate("orCondition"),
      r
    );
  }
  resetJoinOperator(e, t, r, n, i) {
    this.updateJoinOperatorDisabled(
      e.setValue(r, !0).setName(`ag-simple-filter-and-or-${this.getCompId()}-${i}`).setLabel(n),
      t
    );
  }
  updateJoinOperatorsDisabled() {
    this.eJoinOperatorsAnd.forEach((e, t) => this.updateJoinOperatorDisabled(e, t)), this.eJoinOperatorsOr.forEach((e, t) => this.updateJoinOperatorDisabled(e, t));
  }
  updateJoinOperatorDisabled(e, t) {
    e.setDisabled(this.isReadOnly() || t > 0);
  }
  resetInput(e) {
    this.setElementValue(e, null), this.setElementDisabled(e, this.isReadOnly());
  }
  // puts model values into the UI
  setConditionIntoUi(e, t) {
    const r = this.mapValuesFromModel(e);
    this.forEachInput((n, i, o) => {
      o === t && this.setElementValue(n, r[i] != null ? r[i] : null);
    });
  }
  // after floating filter changes, this sets the 'value' section. this is implemented by the base class
  // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
  setValueFromFloatingFilter(e) {
    this.forEachInput((t, r, n) => {
      this.setElementValue(t, r === 0 && n === 0 ? e : null, !0);
    });
  }
  isDefaultOperator(e) {
    return e === this.defaultJoinOperator;
  }
  addChangedListeners(e, t) {
    this.isReadOnly() || (e.onValueChange(this.listener), this.forEachPositionInput(t, (r) => {
      this.attachElementOnChange(r, this.listener);
    }));
  }
  /** returns true if the row passes the said condition */
  individualConditionPasses(e, t) {
    const r = this.getCellValue(e.node), n = this.mapValuesFromModel(t), i = this.optionsFactory.getCustomOption(t.type), o = this.evaluateCustomFilter(i, n, r);
    return o ?? (r == null ? this.evaluateNullValue(t.type) : this.evaluateNonNullValue(n, r, t, e));
  }
  evaluateCustomFilter(e, t, r) {
    if (e == null)
      return;
    const { predicate: n } = e;
    if (n != null && !t.some((i) => i == null))
      return n(t, r);
  }
  isBlank(e) {
    return e == null || typeof e == "string" && e.trim().length === 0;
  }
  hasInvalidInputs() {
    return !1;
  }
}, Cq = class extends yq {
  setParams(e) {
    super.setParams(e), this.scalarFilterParams = e;
  }
  evaluateNullValue(e) {
    switch (e) {
      case "equals":
      case "notEqual":
        if (this.scalarFilterParams.includeBlanksInEquals)
          return !0;
        break;
      case "greaterThan":
      case "greaterThanOrEqual":
        if (this.scalarFilterParams.includeBlanksInGreaterThan)
          return !0;
        break;
      case "lessThan":
      case "lessThanOrEqual":
        if (this.scalarFilterParams.includeBlanksInLessThan)
          return !0;
        break;
      case "inRange":
        if (this.scalarFilterParams.includeBlanksInRange)
          return !0;
        break;
      case "blank":
        return !0;
      case "notBlank":
        return !1;
    }
    return !1;
  }
  evaluateNonNullValue(e, t, r) {
    const n = this.comparator(), i = e[0] != null ? n(e[0], t) : 0;
    switch (r.type) {
      case "equals":
        return i === 0;
      case "notEqual":
        return i !== 0;
      case "greaterThan":
        return i > 0;
      case "greaterThanOrEqual":
        return i >= 0;
      case "lessThan":
        return i < 0;
      case "lessThanOrEqual":
        return i <= 0;
      case "inRange": {
        const o = n(e[1], t);
        return this.scalarFilterParams.inRangeInclusive ? i >= 0 && o <= 0 : i > 0 && o < 0;
      }
      case "blank":
        return this.isBlank(t);
      case "notBlank":
        return !this.isBlank(t);
      default:
        return Te(
          'Unexpected type of filter "' + r.type + '", it looks like the filter was configured with incorrect Filter Options'
        ), !0;
    }
  }
}, t$e = 65, r$e = 67, n$e = 86, i$e = 68, o$e = 90, a$e = 89;
function Sq(e) {
  return e.altKey || e.ctrlKey || e.metaKey ? !1 : e.key.length === 1;
}
function dP(e, t, r, n, i) {
  const o = n ? n.getColDef().suppressKeyboardEvent : void 0;
  if (!o)
    return !1;
  const a = e.addGridCommonParams({
    event: t,
    editing: i,
    column: n,
    node: r,
    data: r.data,
    colDef: n.getColDef()
  });
  return !!(o && o(a));
}
function s$e(e, t, r, n) {
  const i = n.getDefinition(), o = i && i.suppressHeaderKeyboardEvent;
  if (!ke(o))
    return !1;
  const a = e.addGridCommonParams({
    colDef: i,
    column: n,
    headerRowIndex: r,
    event: t
  });
  return !!o(a);
}
function l$e(e) {
  const { keyCode: t } = e;
  let r;
  switch (t) {
    case t$e:
      r = pe.A;
      break;
    case r$e:
      r = pe.C;
      break;
    case n$e:
      r = pe.V;
      break;
    case i$e:
      r = pe.D;
      break;
    case o$e:
      r = pe.Z;
      break;
    case a$e:
      r = pe.Y;
      break;
    default:
      r = e.code;
  }
  return r;
}
function u$e(e, t = !1) {
  return e === pe.DELETE ? !0 : !t && e === pe.BACKSPACE ? YY() : !1;
}
var vd = class extends xc {
  constructor(e, t = "ag-text-field", r = "text") {
    super(e, t, r);
  }
  postConstruct() {
    super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters();
  }
  setValue(e, t) {
    return this.eInput.value !== e && (this.eInput.value = ke(e) ? e : ""), super.setValue(e, t);
  }
  /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
  setStartValue(e) {
    this.setValue(e, !0);
  }
  preventDisallowedCharacters() {
    const e = new RegExp(`[${this.config.allowedCharPattern}]`), t = (r) => {
      Sq(r) && r.key && !e.test(r.key) && r.preventDefault();
    };
    this.addManagedListeners(this.eInput, {
      keydown: t,
      paste: (r) => {
        var i;
        const n = (i = r.clipboardData) == null ? void 0 : i.getData("text");
        n && n.split("").some((o) => !e.test(o)) && r.preventDefault();
      }
    });
  }
}, Vw = {
  selector: "AG-INPUT-TEXT-FIELD",
  component: vd
}, mI = class extends vd {
  constructor(e) {
    super(e, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct(), this.addManagedListeners(this.eInput, {
      blur: () => {
        const i = parseFloat(this.eInput.value), o = isNaN(i) ? "" : this.normalizeValue(i.toString());
        this.value !== o && this.setValue(o);
      },
      wheel: this.onWheel.bind(this)
    }), this.eInput.step = "any";
    const { precision: e, min: t, max: r, step: n } = this.config;
    typeof e == "number" && this.setPrecision(e), typeof t == "number" && this.setMin(t), typeof r == "number" && this.setMax(r), typeof n == "number" && this.setStep(n);
  }
  onWheel(e) {
    this.gos.getActiveDomElement() === this.eInput && e.preventDefault();
  }
  normalizeValue(e) {
    if (e === "")
      return "";
    this.precision != null && (e = this.adjustPrecision(e));
    const t = parseFloat(e);
    return this.min != null && t < this.min ? e = this.min.toString() : this.max != null && t > this.max && (e = this.max.toString()), e;
  }
  adjustPrecision(e, t) {
    if (this.precision == null)
      return e;
    if (t) {
      const n = parseFloat(e).toFixed(this.precision);
      return parseFloat(n).toString();
    }
    const r = String(e).split(".");
    if (r.length > 1) {
      if (r[1].length <= this.precision)
        return e;
      if (this.precision > 0)
        return `${r[0]}.${r[1].slice(0, this.precision)}`;
    }
    return r[0];
  }
  setMin(e) {
    return this.min === e ? this : (this.min = e, Us(this.eInput, "min", e), this);
  }
  setMax(e) {
    return this.max === e ? this : (this.max = e, Us(this.eInput, "max", e), this);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Us(this.eInput, "step", e), this);
  }
  setValue(e, t) {
    return this.setValueOrInputValue(
      (r) => super.setValue(r, t),
      () => this,
      e
    );
  }
  setStartValue(e) {
    return this.setValueOrInputValue(
      (t) => super.setValue(t, !0),
      (t) => {
        this.eInput.value = t;
      },
      e
    );
  }
  setValueOrInputValue(e, t, r) {
    if (ke(r)) {
      let n = this.isScientificNotation(r);
      if (n && this.eInput.validity.valid)
        return e(r);
      if (!n) {
        r = this.adjustPrecision(r);
        const i = this.normalizeValue(r);
        n = r != i;
      }
      if (n)
        return t(r);
    }
    return e(r);
  }
  getValue() {
    if (!this.eInput.validity.valid)
      return;
    const e = this.eInput.value;
    return this.isScientificNotation(e) ? this.adjustPrecision(e, !0) : super.getValue();
  }
  isScientificNotation(e) {
    return typeof e == "string" && e.includes("e");
  }
}, c$e = {
  selector: "AG-INPUT-NUMBER-FIELD",
  component: mI
}, wq = [
  "equals",
  "notEqual",
  "greaterThan",
  "greaterThanOrEqual",
  "lessThan",
  "lessThanOrEqual",
  "inRange",
  "blank",
  "notBlank"
], yI = class {
  constructor(e, t, r) {
    this.localeService = e, this.optionsFactory = t, this.valueFormatter = r;
  }
  // used by:
  // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
  // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
  getModelAsString(e) {
    if (!e)
      return null;
    const t = e.operator != null, r = this.localeService.getLocaleTextFunc();
    if (t) {
      const n = e, o = (n.conditions ?? []).map((s) => this.getModelAsString(s)), a = n.operator === "AND" ? "andCondition" : "orCondition";
      return o.join(
        ` ${r(a, vq[a])} `
      );
    } else {
      if (e.type === "blank" || e.type === "notBlank")
        return r(e.type, e.type);
      {
        const n = e, i = this.optionsFactory.getCustomOption(n.type), { displayKey: o, displayName: a, numberOfInputs: s } = i || {};
        return o && a && s === 0 ? (r(o, a), a) : this.conditionToString(n, i);
      }
    }
  }
  updateParams(e) {
    this.optionsFactory = e.optionsFactory;
  }
  formatValue(e) {
    return this.valueFormatter ? this.valueFormatter(e ?? null) ?? "" : String(e);
  }
}, bq = class extends yI {
  conditionToString(e, t) {
    const { numberOfInputs: r } = t || {};
    return e.type == "inRange" || r === 2 ? `${this.formatValue(e.filter)}-${this.formatValue(e.filterTo)}` : e.filter != null ? this.formatValue(e.filter) : `${e.type}`;
  }
};
function hP(e) {
  const { allowedCharPattern: t } = e ?? {};
  return t ?? null;
}
var d$e = class extends Cq {
  constructor() {
    super("numberFilter"), this.eValuesFrom = [], this.eValuesTo = [];
  }
  refresh(e) {
    return this.numberFilterParams.allowedCharPattern !== e.allowedCharPattern ? !1 : super.refresh(e);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: r, type: n } = e || {};
    return [this.processValue(t), this.processValue(r)].slice(0, this.getNumberOfInputs(n));
  }
  getDefaultDebounceMs() {
    return 500;
  }
  comparator() {
    return (e, t) => e === t ? 0 : e < t ? 1 : -1;
  }
  setParams(e) {
    this.numberFilterParams = e, super.setParams(e), this.filterModelFormatter = new bq(
      this.localeService,
      this.optionsFactory,
      this.numberFilterParams.numberFormatter
    );
  }
  getDefaultFilterOptions() {
    return wq;
  }
  setElementValue(e, t, r) {
    const n = !r && this.numberFilterParams.numberFormatter ? this.numberFilterParams.numberFormatter(t ?? null) : t;
    super.setElementValue(e, n);
  }
  createValueElement() {
    const e = hP(this.numberFilterParams), t = document.createElement("div");
    return t.classList.add("ag-filter-body"), Na(t, "presentation"), this.createFromToElement(t, this.eValuesFrom, "from", e), this.createFromToElement(t, this.eValuesTo, "to", e), t;
  }
  createFromToElement(e, t, r, n) {
    const i = this.createManagedBean(
      n ? new vd({ allowedCharPattern: n }) : new mI()
    );
    i.addCssClass(`ag-filter-${r}`), i.addCssClass("ag-filter-filter"), t.push(i), e.appendChild(i.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (r, n, i, o) => {
      n < o && t.push(this.processValue(this.stringToFloat(r.getValue())));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getFilterType() {
    return "number";
  }
  processValue(e) {
    return e == null || isNaN(e) ? null : e;
  }
  stringToFloat(e) {
    if (typeof e == "number")
      return e;
    let t = Fc(e);
    return t != null && t.trim() === "" && (t = null), this.numberFilterParams.numberParser ? this.numberFilterParams.numberParser(t) : t == null || t.trim() === "-" ? null : parseFloat(t);
  }
  createCondition(e) {
    const t = this.getConditionType(e), r = {
      filterType: this.getFilterType(),
      type: t
    }, n = this.getValues(e);
    return n.length > 0 && (r.filter = n[0]), n.length > 1 && (r.filterTo = n[1]), r;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
  hasInvalidInputs() {
    let e = !1;
    return this.forEachInput((t) => {
      if (!t.getInputElement().validity.valid) {
        e = !0;
        return;
      }
    }), e;
  }
}, xq = [
  "contains",
  "notContains",
  "equals",
  "notEqual",
  "startsWith",
  "endsWith",
  "blank",
  "notBlank"
], Eq = class extends yI {
  conditionToString(e, t) {
    const { numberOfInputs: r } = t || {};
    return e.type == "inRange" || r === 2 ? `${e.filter}-${e.filterTo}` : e.filter != null ? `${e.filter}` : `${e.type}`;
  }
};
function Rq(e) {
  const t = e && e.trim();
  return t === "" ? e : t;
}
var h$e = class extends yq {
  constructor() {
    super("textFilter"), this.defaultFormatter = (e) => e, this.defaultLowercaseFormatter = (e) => e == null ? null : e.toString().toLowerCase(), this.defaultMatcher = ({ filterOption: e, value: t, filterText: r }) => {
      if (r == null)
        return !1;
      switch (e) {
        case "contains":
          return t.indexOf(r) >= 0;
        case "notContains":
          return t.indexOf(r) < 0;
        case "equals":
          return t === r;
        case "notEqual":
          return t != r;
        case "startsWith":
          return t.indexOf(r) === 0;
        case "endsWith": {
          const n = t.lastIndexOf(r);
          return n >= 0 && n === t.length - r.length;
        }
        default:
          return !1;
      }
    }, this.eValuesFrom = [], this.eValuesTo = [];
  }
  getDefaultDebounceMs() {
    return 500;
  }
  setParams(e) {
    this.textFilterParams = e, super.setParams(e), this.matcher = this.getTextMatcher(), this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? this.defaultFormatter : this.defaultLowercaseFormatter), this.filterModelFormatter = new Eq(this.localeService, this.optionsFactory);
  }
  getTextMatcher() {
    const e = this.textFilterParams.textCustomComparator;
    return e ? (Te("textCustomComparator is deprecated, use textMatcher instead."), ({ filterOption: t, value: r, filterText: n }) => e(t, r, n)) : this.textFilterParams.textMatcher || this.defaultMatcher;
  }
  createCondition(e) {
    const t = this.getConditionType(e), r = {
      filterType: this.getFilterType(),
      type: t
    }, n = this.getValuesWithSideEffects(e, !0);
    return n.length > 0 && (r.filter = n[0]), n.length > 1 && (r.filterTo = n[1]), r;
  }
  getFilterType() {
    return "text";
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getValues(e) {
    return this.getValuesWithSideEffects(e, !1);
  }
  getValuesWithSideEffects(e, t) {
    const r = [];
    return this.forEachPositionInput(e, (n, i, o, a) => {
      if (i < a) {
        let s = Fc(n.getValue());
        t && this.textFilterParams.trimInput && (s = Rq(s) ?? null, n.setValue(s, !0)), r.push(s);
      }
    }), r;
  }
  getDefaultFilterOptions() {
    return xq;
  }
  createValueElement() {
    const e = document.createElement("div");
    return e.classList.add("ag-filter-body"), Na(e, "presentation"), this.createFromToElement(e, this.eValuesFrom, "from"), this.createFromToElement(e, this.eValuesTo, "to"), e;
  }
  createFromToElement(e, t, r) {
    const n = this.createManagedBean(new vd());
    n.addCssClass(`ag-filter-${r}`), n.addCssClass("ag-filter-filter"), t.push(n), e.appendChild(n.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: r, type: n } = e || {};
    return [t || null, r || null].slice(0, this.getNumberOfInputs(n));
  }
  evaluateNullValue(e) {
    return e ? ["notEqual", "notContains", "blank"].indexOf(e) >= 0 : !1;
  }
  evaluateNonNullValue(e, t, r, n) {
    const i = e.map((h) => this.formatter(h)) || [], o = this.formatter(t), { api: a, colDef: s, column: l, context: u, textFormatter: c } = this.textFilterParams;
    if (r.type === "blank")
      return this.isBlank(t);
    if (r.type === "notBlank")
      return !this.isBlank(t);
    const d = {
      api: a,
      colDef: s,
      column: l,
      context: u,
      node: n.node,
      data: n.data,
      filterOption: r.type,
      value: o,
      textFormatter: c
    };
    return i.some((h) => this.matcher({ ...d, filterText: h }));
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
};
function _q(e) {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = parseInt(e);
    return isNaN(t) ? void 0 : t;
  }
}
function Ua(e, t = Number.MAX_VALUE) {
  return (r) => {
    const n = _q(r);
    if (!(n == null || n < e || n > t))
      return n;
  };
}
function Sg(e, t) {
  return e.toString().padStart(t, "0");
}
function f$e(e, t) {
  const r = [];
  for (let n = e; n <= t; n++)
    r.push(n);
  return r;
}
function p$e(e, t, r) {
  return typeof e != "number" ? "" : e.toString().replace(".", r).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${t}`);
}
function Xo(e, t = !0, r = "-") {
  if (!e)
    return null;
  let n = [e.getFullYear(), e.getMonth() + 1, e.getDate()].map((i) => Sg(i, 2)).join(r);
  return t && (n += " " + [e.getHours(), e.getMinutes(), e.getSeconds()].map((i) => Sg(i, 2)).join(":")), n;
}
var _E = (e) => {
  if (e > 3 && e < 21)
    return "th";
  switch (e % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
};
function wg(e, t = "YYYY-MM-DD") {
  const r = Sg(e.getFullYear(), 4), n = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ], i = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], o = {
    YYYY: () => r.slice(r.length - 4, r.length),
    YY: () => r.slice(r.length - 2, r.length),
    Y: () => `${e.getFullYear()}`,
    MMMM: () => n[e.getMonth()],
    MMM: () => n[e.getMonth()].slice(0, 3),
    MM: () => Sg(e.getMonth() + 1, 2),
    Mo: () => `${e.getMonth() + 1}${_E(e.getMonth() + 1)}`,
    M: () => `${e.getMonth() + 1}`,
    Do: () => `${e.getDate()}${_E(e.getDate())}`,
    DD: () => Sg(e.getDate(), 2),
    D: () => `${e.getDate()}`,
    dddd: () => i[e.getDay()],
    ddd: () => i[e.getDay()].slice(0, 3),
    dd: () => i[e.getDay()].slice(0, 2),
    do: () => `${e.getDay()}${_E(e.getDay())}`,
    d: () => `${e.getDay()}`
  }, a = new RegExp(Object.keys(o).join("|"), "g");
  return t.replace(a, (s) => s in o ? o[s]() : s);
}
function qi(e) {
  if (!e)
    return null;
  const [t, r] = e.split(" ");
  if (!t)
    return null;
  const n = t.split("-").map((d) => parseInt(d, 10));
  if (n.filter((d) => !isNaN(d)).length !== 3)
    return null;
  const [i, o, a] = n, s = new Date(i, o - 1, a);
  if (s.getFullYear() !== i || s.getMonth() !== o - 1 || s.getDate() !== a)
    return null;
  if (!r || r === "00:00:00")
    return s;
  const [l, u, c] = r.split(":").map((d) => parseInt(d, 10));
  return l >= 0 && l < 24 && s.setHours(l), u >= 0 && u < 60 && s.setMinutes(u), c >= 0 && c < 60 && s.setSeconds(c), s;
}
var Tq = class {
  constructor(e, t, r, n, i) {
    this.alive = !0, this.context = e, this.eParent = n, t.getDateCompDetails(r).newAgStackInstance().then((s) => {
      if (!this.alive) {
        e.destroyBean(s);
        return;
      }
      this.dateComp = s, s && (n.appendChild(s.getGui()), s.afterGuiAttached && s.afterGuiAttached(), this.tempValue && s.setDate(this.tempValue), this.disabled != null && this.setDateCompDisabled(this.disabled), i == null || i(this));
    });
  }
  destroy() {
    this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(e) {
    this.dateComp ? this.dateComp.setDate(e) : this.tempValue = e;
  }
  setDisabled(e) {
    this.dateComp ? this.setDateCompDisabled(e) : this.disabled = e;
  }
  setDisplayed(e) {
    ln(this.eParent, e);
  }
  setInputPlaceholder(e) {
    this.dateComp && this.dateComp.setInputPlaceholder && this.dateComp.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.dateComp && this.dateComp.setInputAriaLabel && this.dateComp.setInputAriaLabel(e);
  }
  afterGuiAttached(e) {
    this.dateComp && typeof this.dateComp.afterGuiAttached == "function" && this.dateComp.afterGuiAttached(e);
  }
  updateParams(e) {
    var r, n;
    let t = !1;
    (r = this.dateComp) != null && r.refresh && typeof this.dateComp.refresh == "function" && this.dateComp.refresh(e) !== null && (t = !0), !t && ((n = this.dateComp) != null && n.onParamsUpdated) && typeof this.dateComp.onParamsUpdated == "function" && this.dateComp.onParamsUpdated(e) !== null && Te("Custom date component method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
  }
  setDateCompDisabled(e) {
    this.dateComp != null && this.dateComp.setDisabled != null && this.dateComp.setDisabled(e);
  }
}, Pq = [
  "equals",
  "notEqual",
  "lessThan",
  "greaterThan",
  "inRange",
  "blank",
  "notBlank"
], Mq = class extends yI {
  constructor(e, t, r) {
    super(t, r), this.dateFilterParams = e;
  }
  conditionToString(e, t) {
    const { type: r } = e, { numberOfInputs: n } = t || {}, i = r == "inRange" || n === 2, o = qi(e.dateFrom), a = qi(e.dateTo), s = this.dateFilterParams.inRangeFloatingFilterDateFormat;
    if (i) {
      const l = o !== null ? wg(o, s) : "null", u = a !== null ? wg(a, s) : "null";
      return `${l}-${u}`;
    }
    return o != null ? wg(o, s) : `${r}`;
  }
  updateParams(e) {
    super.updateParams(e), this.dateFilterParams = e.dateFilterParams;
  }
}, WH = 1e3, jH = 1 / 0, g$e = class extends Cq {
  constructor() {
    super("dateFilter"), this.eConditionPanelsFrom = [], this.eConditionPanelsTo = [], this.dateConditionFromComps = [], this.dateConditionToComps = [], this.minValidYear = WH, this.maxValidYear = jH, this.minValidDate = null, this.maxValidDate = null;
  }
  wireBeans(e) {
    super.wireBeans(e), this.context = e.context, this.userComponentFactory = e.userComponentFactory;
  }
  afterGuiAttached(e) {
    super.afterGuiAttached(e), this.dateConditionFromComps[0].afterGuiAttached(e);
  }
  mapValuesFromModel(e) {
    const { dateFrom: t, dateTo: r, type: n } = e || {};
    return [
      t && qi(t) || null,
      r && qi(r) || null
    ].slice(0, this.getNumberOfInputs(n));
  }
  comparator() {
    return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
  }
  defaultComparator(e, t) {
    const r = t;
    return t == null || r < e ? -1 : r > e ? 1 : 0;
  }
  setParams(e) {
    this.dateFilterParams = e, super.setParams(e);
    const t = (r, n) => {
      if (e[r] != null)
        if (isNaN(e[r]))
          Te(`DateFilter ${r} is not a number`);
        else
          return e[r] == null ? n : Number(e[r]);
      return n;
    };
    this.minValidYear = t("minValidYear", WH), this.maxValidYear = t("maxValidYear", jH), this.minValidYear > this.maxValidYear && Te("DateFilter minValidYear should be <= maxValidYear"), e.minValidDate ? this.minValidDate = e.minValidDate instanceof Date ? e.minValidDate : qi(e.minValidDate) : this.minValidDate = null, e.maxValidDate ? this.maxValidDate = e.maxValidDate instanceof Date ? e.maxValidDate : qi(e.maxValidDate) : this.maxValidDate = null, this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate && Te("DateFilter minValidDate should be <= maxValidDate"), this.filterModelFormatter = new Mq(
      this.dateFilterParams,
      this.localeService,
      this.optionsFactory
    );
  }
  createDateCompWrapper(e) {
    const t = new Tq(
      this.context,
      this.userComponentFactory,
      {
        onDateChanged: () => this.onUiChanged(),
        filterParams: this.dateFilterParams
      },
      e
    );
    return this.addDestroyFunc(() => t.destroy()), t;
  }
  setElementValue(e, t) {
    e.setDate(t);
  }
  setElementDisplayed(e, t) {
    e.setDisplayed(t);
  }
  setElementDisabled(e, t) {
    e.setDisabled(t);
  }
  getDefaultFilterOptions() {
    return Pq;
  }
  createValueElement() {
    const t = this.gos.getDocument().createElement("div");
    return t.classList.add("ag-filter-body"), this.createFromToElement(t, this.eConditionPanelsFrom, this.dateConditionFromComps, "from"), this.createFromToElement(t, this.eConditionPanelsTo, this.dateConditionToComps, "to"), t;
  }
  createFromToElement(e, t, r, n) {
    const o = this.gos.getDocument().createElement("div");
    o.classList.add(`ag-filter-${n}`), o.classList.add(`ag-filter-date-${n}`), t.push(o), e.appendChild(o), r.push(this.createDateCompWrapper(o));
  }
  removeValueElements(e, t) {
    this.removeDateComps(this.dateConditionFromComps, e, t), this.removeDateComps(this.dateConditionToComps, e, t), this.removeItems(this.eConditionPanelsFrom, e, t), this.removeItems(this.eConditionPanelsTo, e, t);
  }
  removeDateComps(e, t, r) {
    this.removeItems(e, t, r).forEach((i) => i.destroy());
  }
  isValidDateValue(e) {
    if (e === null)
      return !1;
    if (this.minValidDate) {
      if (e < this.minValidDate)
        return !1;
    } else if (e.getUTCFullYear() < this.minValidYear)
      return !1;
    if (this.maxValidDate) {
      if (e > this.maxValidDate)
        return !1;
    } else if (e.getUTCFullYear() > this.maxValidYear)
      return !1;
    return !0;
  }
  isConditionUiComplete(e) {
    if (!super.isConditionUiComplete(e))
      return !1;
    let t = !0;
    return this.forEachInput((r, n, i, o) => {
      i !== e || !t || n >= o || (t = t && this.isValidDateValue(r.getDate()));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.dateFrom === t.dateFrom && e.dateTo === t.dateTo && e.type === t.type;
  }
  getFilterType() {
    return "date";
  }
  createCondition(e) {
    const t = this.getConditionType(e), r = {}, n = this.getValues(e);
    return n.length > 0 && (r.dateFrom = Xo(n[0])), n.length > 1 && (r.dateTo = Xo(n[1])), {
      dateFrom: null,
      dateTo: null,
      filterType: this.getFilterType(),
      type: t,
      ...r
    };
  }
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc(), t = this.translate("dateFormatOoo"), r = e("ariaFilterValue", "Filter Value");
    this.forEachInput((n) => {
      n.setInputPlaceholder(t), n.setInputAriaLabel(r);
    });
  }
  getInputs(e) {
    return e >= this.dateConditionFromComps.length ? [null, null] : [this.dateConditionFromComps[e], this.dateConditionToComps[e]];
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (r, n, i, o) => {
      n < o && t.push(r.getDate());
    }), t;
  }
  translate(e) {
    return e === "lessThan" ? super.translate("before") : e === "greaterThan" ? super.translate("after") : super.translate(e);
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
}, CI = class extends Se {
  constructor(e, t, r, n) {
    super(), this.columnOrGroup = e, this.columnOrGroup = e, this.eCell = t, this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell, this.colsSpanning = n, this.beans = r;
  }
  setColsSpanning(e) {
    this.colsSpanning = e, this.onLeftChanged();
  }
  getColumnOrGroup() {
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? gr(this.colsSpanning) : this.columnOrGroup;
  }
  postConstruct() {
    const e = this.onLeftChanged.bind(this);
    this.addManagedListeners(this.columnOrGroup, { leftChanged: e }), this.setLeftFirstTime(), this.addManagedEventListeners({ displayedColumnsWidthChanged: e }), this.addManagedPropertyListener("domLayout", e);
  }
  setLeftFirstTime() {
    const e = this.beans.gos.get("suppressColumnMoveAnimation"), t = ke(this.columnOrGroup.getOldLeft());
    this.beans.columnAnimationService.isActive() && t && !e ? this.animateInLeft() : this.onLeftChanged();
  }
  animateInLeft() {
    const e = this.getColumnOrGroup(), t = e.getLeft(), r = e.getOldLeft(), n = this.modifyLeftForPrintLayout(e, r), i = this.modifyLeftForPrintLayout(e, t);
    this.setLeft(n), this.actualLeft = i, this.beans.columnAnimationService.executeNextVMTurn(() => {
      this.actualLeft === i && this.setLeft(i);
    });
  }
  onLeftChanged() {
    const e = this.getColumnOrGroup(), t = e.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(e, t) {
    if (!this.beans.gos.isDomLayout("print") || e.getPinned() === "left")
      return t;
    const n = this.beans.visibleColsService.getColsLeftWidth();
    if (e.getPinned() === "right") {
      const i = this.beans.visibleColsService.getBodyContainerWidth();
      return n + i + t;
    }
    return n + t;
  }
  setLeft(e) {
    if (ke(e) && (this.eCell.style.left = `${e}px`), Sn(this.columnOrGroup)) {
      const t = this.columnOrGroup.getLeafColumns();
      if (!t.length)
        return;
      t.length > 1 && kBe(this.ariaEl, t.length);
    }
  }
}, v$e = "ag-column-first", m$e = "ag-column-last";
function Dq(e, t, r, n) {
  return dr(e) ? [] : C$e(e.headerClass, e, t, r, n);
}
function Aq(e, t, r) {
  e.addOrRemoveCssClass(v$e, r.isColAtEdge(t, "first")), e.addOrRemoveCssClass(m$e, r.isColAtEdge(t, "last"));
}
function y$e(e, t, r, n) {
  return t.addGridCommonParams({
    // bad naming, as colDef here can be a group or a column,
    // however most people won't appreciate the difference,
    // so keeping it as colDef to avoid confusion.
    colDef: e,
    column: r,
    columnGroup: n
  });
}
function C$e(e, t, r, n, i) {
  if (dr(e))
    return [];
  let o;
  if (typeof e == "function") {
    const a = y$e(t, r, n, i);
    o = e(a);
  } else
    o = e;
  return typeof o == "string" ? [o] : Array.isArray(o) ? [...o] : [];
}
var S$e = 0, Iq = class Oq extends Se {
  constructor(t, r, n) {
    super(), this.resizeToggleTimeout = 0, this.resizeMultiplier = 1, this.resizeFeature = null, this.lastFocusEvent = null, this.dragSource = null, this.columnGroupChild = t, this.parentRowCtrl = n, this.beans = r, this.instanceId = t.getUniqueId() + "-" + S$e++;
  }
  wireBeans(t) {
    this.pinnedWidthService = t.pinnedWidthService, this.focusService = t.focusService, this.userComponentFactory = t.userComponentFactory, this.ctrlsService = t.ctrlsService, this.dragAndDropService = t.dragAndDropService, this.menuService = t.menuService;
  }
  postConstruct() {
    this.addManagedPropertyListeners(["suppressHeaderFocus"], () => this.refreshTabIndex());
  }
  shouldStopEventPropagation(t) {
    const { headerRowIndex: r, column: n } = this.focusService.getFocusedHeader();
    return s$e(this.gos, t, r, n);
  }
  getWrapperHasFocus() {
    return this.gos.getActiveDomElement() === this.eGui;
  }
  setGui(t) {
    this.eGui = t, this.addDomData(), this.addManagedListeners(this.beans.eventService, {
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    }), this.addManagedElementListeners(this.eGui, {
      focus: this.onGuiFocus.bind(this)
    }), this.onDisplayedColumnsChanged(), this.refreshTabIndex();
  }
  onGuiFocus() {
    const t = {
      type: "headerFocused",
      column: this.column
    };
    this.eventService.dispatchEvent(t);
  }
  onDisplayedColumnsChanged() {
    !this.comp || !this.column || (this.refreshFirstAndLastStyles(), this.refreshAriaColIndex());
  }
  refreshFirstAndLastStyles() {
    const { comp: t, column: r, beans: n } = this;
    Aq(t, r, n.visibleColsService);
  }
  refreshAriaColIndex() {
    const { beans: t, column: r } = this, n = t.visibleColsService.getAriaColIndex(r);
    jY(this.eGui, n);
  }
  addResizeAndMoveKeyboardListeners() {
    this.resizeFeature && this.addManagedListeners(this.eGui, {
      keydown: this.onGuiKeyDown.bind(this),
      keyup: this.onGuiKeyUp.bind(this)
    });
  }
  refreshTabIndex() {
    this.gos.get("suppressHeaderFocus") ? this.eGui.removeAttribute("tabindex") : this.eGui.setAttribute("tabindex", "-1");
  }
  onGuiKeyDown(t) {
    var a;
    const r = this.gos.getActiveDomElement(), n = t.key === pe.LEFT || t.key === pe.RIGHT;
    if (this.isResizing && (t.preventDefault(), t.stopImmediatePropagation()), // if elements within the header are focused, we don't process the event
    r !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
    !t.shiftKey && !t.altKey || ((this.isResizing || n) && (t.preventDefault(), t.stopImmediatePropagation()), !n))
      return;
    const i = t.key === pe.LEFT !== this.gos.get("enableRtl"), o = dq[i ? "Left" : "Right"];
    if (t.altKey) {
      this.isResizing = !0, this.resizeMultiplier += 1;
      const s = this.getViewportAdjustedResizeDiff(t);
      this.resizeHeader(s, t.shiftKey), (a = this.resizeFeature) == null || a.toggleColumnResizing(!0);
    } else
      this.moveHeader(o);
  }
  getViewportAdjustedResizeDiff(t) {
    let r = this.getResizeDiff(t);
    if (this.column.getPinned()) {
      const i = this.pinnedWidthService.getPinnedLeftWidth(), o = this.pinnedWidthService.getPinnedRightWidth(), a = rm(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (i + o + r > a)
        if (a > i + o)
          r = a - i - o;
        else
          return 0;
    }
    return r;
  }
  getResizeDiff(t) {
    let r = t.key === pe.LEFT !== this.gos.get("enableRtl");
    const n = this.column.getPinned(), i = this.gos.get("enableRtl");
    return n && i !== (n === "right") && (r = !r), (r ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    this.isResizing && (this.resizeToggleTimeout && (window.clearTimeout(this.resizeToggleTimeout), this.resizeToggleTimeout = 0), this.isResizing = !1, this.resizeMultiplier = 1, this.resizeToggleTimeout = window.setTimeout(() => {
      var t;
      (t = this.resizeFeature) == null || t.toggleColumnResizing(!1);
    }, 150));
  }
  handleKeyDown(t) {
    const r = this.getWrapperHasFocus();
    switch (t.key) {
      case pe.PAGE_DOWN:
      case pe.PAGE_UP:
      case pe.PAGE_HOME:
      case pe.PAGE_END:
        r && t.preventDefault();
    }
  }
  addDomData() {
    const t = Oq.DOM_DATA_KEY_HEADER_CTRL;
    this.gos.setDomData(this.eGui, t, this), this.addDestroyFunc(() => this.gos.setDomData(this.eGui, t, null));
  }
  getGui() {
    return this.eGui;
  }
  focus(t) {
    return this.eGui ? (this.lastFocusEvent = t || null, this.eGui.focus(), !0) : !1;
  }
  getRowIndex() {
    return this.parentRowCtrl.getRowIndex();
  }
  getParentRowCtrl() {
    return this.parentRowCtrl;
  }
  getPinned() {
    return this.parentRowCtrl.getPinned();
  }
  getInstanceId() {
    return this.instanceId;
  }
  getColumnGroupChild() {
    return this.columnGroupChild;
  }
  removeDragSource() {
    this.dragSource && (this.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null);
  }
  handleContextMenuMouseEvent(t, r, n) {
    const i = t ?? r;
    this.gos.get("preventDefaultOnContextMenu") && i.preventDefault();
    const o = cu(n) ? n : void 0;
    this.menuService.isHeaderContextMenuEnabled(o) && this.menuService.showHeaderContextMenu(o, t, r), this.dispatchColumnMouseEvent("columnHeaderContextMenu", n);
  }
  dispatchColumnMouseEvent(t, r) {
    const n = {
      type: t,
      column: r
    };
    this.eventService.dispatchEvent(n);
  }
  destroy() {
    super.destroy(), this.removeDragSource(), this.comp = null, this.column = null, this.resizeFeature = null, this.lastFocusEvent = null, this.columnGroupChild = null, this.parentRowCtrl = null, this.eGui = null;
  }
};
Iq.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
var Bw = Iq, SI = class extends Se {
  wireBeans(e) {
    this.columnHoverService = e.columnHoverService;
  }
  constructor(e, t) {
    super(), this.columns = e, this.element = t;
  }
  postConstruct() {
    this.gos.get("columnHoverHighlight") && this.addMouseHoverListeners();
  }
  addMouseHoverListeners() {
    this.addManagedListeners(this.element, {
      mouseout: this.onMouseOut.bind(this),
      mouseover: this.onMouseOver.bind(this)
    });
  }
  onMouseOut() {
    this.columnHoverService.clearMouseOver();
  }
  onMouseOver() {
    this.columnHoverService.setMouseOver(this.columns);
  }
}, w$e = class extends Bw {
  constructor(e, t, r) {
    super(e, t, r), this.iconCreated = !1, this.column = e;
  }
  setComp(e, t, r, n) {
    this.comp = e, this.eButtonShowMainFilter = r, this.eFloatingFilterBody = n, this.setGui(t), this.setupActive(), this.setupWidth(), this.setupLeft(), this.setupHover(), this.setupFocus(), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(), this.setupUi(), this.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) }), this.setupFilterChangedListener(), this.addManagedListeners(this.column, { colDefChanged: this.onColDefChanged.bind(this) });
  }
  // empty abstract method
  resizeHeader() {
  }
  // empty abstract method
  moveHeader() {
  }
  setupActive() {
    const e = this.column.getColDef(), t = !!e.filter, r = !!e.floatingFilter;
    this.active = t && r;
  }
  setupUi() {
    if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated)
      return;
    const e = yo("filter", this.gos, this.column);
    e && (this.iconCreated = !0, this.eButtonShowMainFilter.appendChild(e));
  }
  setupFocus() {
    this.createManagedBean(
      new gd(this.eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    );
  }
  setupAria() {
    const e = this.localeService.getLocaleTextFunc();
    tf(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    if (this.gos.getActiveDomElement() === this.eGui)
      return;
    const n = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
    if (n) {
      this.beans.headerNavigationService.scrollToColumn(this.column), e.preventDefault(), n.focus();
      return;
    }
    const i = this.findNextColumnWithFloatingFilter(e.shiftKey);
    i && this.focusService.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.getParentRowCtrl().getRowIndex(),
        column: i
      },
      event: e
    }) && e.preventDefault();
  }
  findNextColumnWithFloatingFilter(e) {
    const t = this.beans.visibleColsService;
    let r = this.column;
    do
      if (r = e ? t.getColBefore(r) : t.getColAfter(r), !r)
        break;
    while (!r.getColDef().filter || !r.getColDef().floatingFilter);
    return r;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case pe.UP:
      case pe.DOWN:
        t || e.preventDefault();
      case pe.LEFT:
      case pe.RIGHT:
        if (t)
          return;
        e.stopPropagation();
      case pe.ENTER:
        t && this.focusService.focusInto(this.eGui) && e.preventDefault();
        break;
      case pe.ESCAPE:
        t || this.eGui.focus();
    }
  }
  onFocusIn(e) {
    if (this.eGui.contains(e.relatedTarget))
      return;
    const r = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"), n = !!e.relatedTarget && Lh(e.relatedTarget, "ag-floating-filter");
    if (r && n && e.target === this.eGui) {
      const o = this.lastFocusEvent, a = !!(o && o.key === pe.TAB);
      if (o && a) {
        const s = o.shiftKey;
        this.focusService.focusInto(this.eGui, s);
      }
    }
    const i = this.getRowIndex();
    this.beans.focusService.setFocusedHeader(i, this.column);
  }
  setupHover() {
    this.createManagedBean(new SI([this.column], this.eGui));
    const e = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const t = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", t);
    };
    this.addManagedEventListeners({ columnHoverChanged: e }), e();
  }
  setupLeft() {
    const e = new CI(this.column, this.eGui, this.beans);
    this.createManagedBean(e);
  }
  setupFilterButton() {
    this.suppressFilterButton = !this.menuService.isFloatingFilterButtonEnabled(this.column), this.highlightFilterButtonWhenActive = !this.menuService.isLegacyMenuEnabled();
  }
  setupUserComp() {
    var t;
    if (!this.active)
      return;
    const e = (t = this.beans.filterManager) == null ? void 0 : t.getFloatingFilterCompDetails(
      this.column,
      () => this.showParentFilter()
    );
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setCompDetails(e);
  }
  showParentFilter() {
    const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    this.menuService.showFilterMenu({
      column: this.column,
      buttonElement: e,
      containerType: "floatingFilter",
      positionBy: "button"
    });
  }
  setupSyncWithFilter() {
    if (!this.active)
      return;
    const { filterManager: e } = this.beans, t = (r) => {
      if ((r == null ? void 0 : r.source) === "filterDestroyed" && !this.isAlive())
        return;
      const n = this.comp.getFloatingFilterComp();
      n && n.then((i) => {
        if (i) {
          const o = e == null ? void 0 : e.getCurrentFloatingFilterParentModel(this.column), a = r ? {
            // event can have additional params like `afterDataChange` which need to be passed through
            ...r,
            columns: r.columns ?? [],
            source: r.source === "api" ? "api" : "columnFilter"
          } : null;
          i.onParentModelChanged(o, a);
        }
      });
    };
    [this.destroySyncListener] = this.addManagedListeners(this.column, { filterChanged: t }), e != null && e.isFilterActive(this.column) && t(null);
  }
  setupWidth() {
    const e = () => {
      const t = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(t);
    };
    this.addManagedListeners(this.column, { widthChanged: e }), e();
  }
  setupFilterChangedListener() {
    this.active && ([this.destroyFilterChangedListener] = this.addManagedListeners(this.column, {
      filterChanged: this.updateFilterButton.bind(this)
    }), this.updateFilterButton());
  }
  updateFilterButton() {
    var e;
    if (!this.suppressFilterButton && this.comp) {
      const t = !!((e = this.beans.filterManager) != null && e.isFilterAllowed(this.column));
      this.comp.setButtonWrapperDisplayed(t), this.highlightFilterButtonWhenActive && t && this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
    }
  }
  onColDefChanged() {
    var i;
    const e = this.active;
    this.setupActive();
    const t = !e && this.active;
    e && !this.active && (this.destroySyncListener(), this.destroyFilterChangedListener());
    const r = this.active ? (i = this.beans.filterManager) == null ? void 0 : i.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null, n = this.comp.getFloatingFilterComp();
    !n || !r ? this.updateCompDetails(r, t) : n.then((o) => {
      var a;
      !o || (a = this.beans.filterManager) != null && a.areFilterCompsDifferent(this.userCompDetails ?? null, r) ? this.updateCompDetails(r, t) : this.updateFloatingFilterParams(r);
    });
  }
  updateCompDetails(e, t) {
    this.isAlive() && (this.setCompDetails(e), this.setupFilterButton(), this.setupUi(), t && (this.setupSyncWithFilter(), this.setupFilterChangedListener()));
  }
  updateFloatingFilterParams(e) {
    var r;
    if (!e)
      return;
    const t = e.params;
    (r = this.comp.getFloatingFilterComp()) == null || r.then((n) => {
      let i = !1;
      n != null && n.refresh && typeof n.refresh == "function" && n.refresh(t) !== null && (i = !0), !i && (n != null && n.onParamsUpdated) && typeof n.onParamsUpdated == "function" && n.onParamsUpdated(t) !== null && Te("Custom floating filter method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
    });
  }
  destroy() {
    super.destroy(), this.eButtonShowMainFilter = null, this.eFloatingFilterBody = null, this.userCompDetails = null, this.destroySyncListener = null, this.destroyFilterChangedListener = null;
  }
}, kt = "32.0.1";
function b$e(e) {
  var t, r;
  return !!((t = e.filterManager) != null && t.isColumnFilterPresent()) || !!((r = e.filterManager) != null && r.isAggregateFilterPresent());
}
function x$e(e, t, r) {
  var n;
  return (n = e.filterManager) == null ? void 0 : n.getFilterInstance(t, r);
}
function E$e(e, t) {
  var r;
  return ((r = e.filterManager) == null ? void 0 : r.getColumnFilterInstance(t)) ?? Promise.resolve(void 0);
}
function R$e(e, t) {
  var n;
  const r = e.columnModel.getColDefCol(t);
  if (r)
    return (n = e.filterManager) == null ? void 0 : n.destroyFilter(r, "api");
}
function _$e(e, t) {
  e.frameworkOverrides.wrapIncoming(() => {
    var r;
    return (r = e.filterManager) == null ? void 0 : r.setFilterModel(t);
  });
}
function T$e(e) {
  var t;
  return ((t = e.filterManager) == null ? void 0 : t.getFilterModel()) ?? {};
}
function P$e(e, t) {
  var r;
  return ((r = e.filterManager) == null ? void 0 : r.getColumnFilterModel(t)) ?? null;
}
function M$e(e, t, r) {
  var n;
  return ((n = e.filterManager) == null ? void 0 : n.setColumnFilterModel(t, r)) ?? Promise.resolve();
}
function D$e(e, t) {
  const r = e.columnModel.getCol(t);
  if (!r) {
    Er(`column '${t}' not found`);
    return;
  }
  e.menuService.showFilterMenu({
    column: r,
    containerType: "columnFilter",
    positionBy: "auto"
  });
}
function A$e(e, t, r) {
  if (t == null)
    return null;
  let n = null;
  const { compName: i, jsComp: o, fwComp: a } = uq.getCompKeys(e, t, pI);
  return i ? n = {
    set: "agSetColumnFloatingFilter",
    agSetColumnFilter: "agSetColumnFloatingFilter",
    multi: "agMultiColumnFloatingFilter",
    agMultiColumnFilter: "agMultiColumnFloatingFilter",
    group: "agGroupColumnFloatingFilter",
    agGroupColumnFilter: "agGroupColumnFloatingFilter",
    number: "agNumberColumnFloatingFilter",
    agNumberColumnFilter: "agNumberColumnFloatingFilter",
    date: "agDateColumnFloatingFilter",
    agDateColumnFilter: "agDateColumnFloatingFilter",
    text: "agTextColumnFloatingFilter",
    agTextColumnFilter: "agTextColumnFloatingFilter"
  }[i] : o == null && a == null && t.filter === !0 && (n = r()), n;
}
var I$e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnFilterService", this.allColumnFilters = /* @__PURE__ */ new Map(), this.allColumnListeners = /* @__PURE__ */ new Map(), this.activeAggregateFilters = [], this.activeColumnFilters = [], this.processingFilterChange = !1, this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.rowModel = e.rowModel, this.userComponentFactory = e.userComponentFactory, this.rowRenderer = e.rowRenderer, this.dataTypeService = e.dataTypeService, this.filterManager = e.filterManager;
  }
  postConstruct() {
    var e, t;
    this.addManagedEventListeners({
      gridColumnsChanged: this.onColumnsChanged.bind(this),
      rowDataUpdated: () => this.onNewRowsLoaded("rowDataUpdated"),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.initialFilterModel = {
      ...((t = (e = this.gos.get("initialState")) == null ? void 0 : e.filter) == null ? void 0 : t.filterModel) ?? {}
    };
  }
  setFilterModel(e, t = "api") {
    var i;
    if ((i = this.dataTypeService) != null && i.isPendingInference()) {
      this.filterModelUpdateQueue.push({ model: e, source: t });
      return;
    }
    const r = [], n = this.getFilterModel();
    if (e) {
      const o = new Set(Object.keys(e));
      this.allColumnFilters.forEach((a, s) => {
        const l = e[s];
        r.push(this.setModelOnFilterWrapper(a.filterPromise, l)), o.delete(s);
      }), o.forEach((a) => {
        const s = this.columnModel.getColDefCol(a) || this.columnModel.getCol(a);
        if (!s) {
          Te("setFilterModel() - no column found for colId: " + a);
          return;
        }
        if (!s.isFilterAllowed()) {
          Te("setFilterModel() - unable to fully apply model, filtering disabled for colId: " + a);
          return;
        }
        const l = this.getOrCreateFilterWrapper(s);
        if (!l) {
          Te(
            "setFilterModel() - unable to fully apply model, unable to create filter for colId: " + a
          );
          return;
        }
        r.push(this.setModelOnFilterWrapper(l.filterPromise, e[a]));
      });
    } else
      this.allColumnFilters.forEach((o) => {
        r.push(this.setModelOnFilterWrapper(o.filterPromise, null));
      });
    gn.all(r).then(() => {
      var s;
      const o = this.getFilterModel(), a = [];
      this.allColumnFilters.forEach((l, u) => {
        const c = n ? n[u] : null, d = o ? o[u] : null;
        JC(c, d) || a.push(l.column);
      }), a.length > 0 && ((s = this.filterManager) == null || s.onFilterChanged({ columns: a, source: t }));
    });
  }
  setModelOnFilterWrapper(e, t) {
    return new gn((r) => {
      e.then((n) => {
        typeof n.setModel != "function" && (Te("filter missing setModel method, which is needed for setFilterModel"), r()), (n.setModel(t) || gn.resolve()).then(() => r());
      });
    });
  }
  getFilterModel() {
    const e = {};
    return this.allColumnFilters.forEach((t, r) => {
      const n = this.getModelFromFilterWrapper(t);
      ke(n) && (e[r] = n);
    }), e;
  }
  getModelFromFilterWrapper(e) {
    const { filter: t } = e;
    return t ? typeof t.getModel != "function" ? (Te("filter API missing getModel method, which is needed for getFilterModel"), null) : t.getModel() : this.getModelFromInitialState(e.column);
  }
  getModelFromInitialState(e) {
    return this.initialFilterModel[e.getColId()] ?? null;
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  disableColumnFilters() {
    return this.allColumnFilters.size ? (this.allColumnFilters.forEach(
      (e) => this.disposeFilterWrapper(e, "advancedFilterEnabled")
    ), !0) : !1;
  }
  doAggregateFiltersPass(e, t) {
    return this.doColumnFiltersPass(e, t, !0);
  }
  updateActiveFilters() {
    const e = (o) => o ? o.isFilterActive ? o.isFilterActive() : (Te("Filter is missing isFilterActive() method"), !1) : !1, t = !!this.gos.getGroupAggFiltering(), r = (o) => {
      if (!o.isPrimary())
        return !0;
      const s = !this.columnModel.isPivotActive();
      return !o.isValueActive() || !s ? !1 : this.columnModel.isPivotMode() ? !0 : t;
    }, n = [], i = [];
    return this.forEachColumnFilter((o, a) => {
      e(o) && (r(a.column) ? n.push(o) : i.push(o));
    }).then(() => {
      this.activeAggregateFilters = n, this.activeColumnFilters = i;
    });
  }
  updateFilterFlagInColumns(e, t) {
    return this.forEachColumnFilter(
      (r, n) => n.column.setFilterActive(r.isFilterActive(), e, t)
    );
  }
  forEachColumnFilter(e) {
    return gn.all(
      Array.from(this.allColumnFilters.values()).map(
        (t) => t.filterPromise.then((r) => e(r, t))
      )
    );
  }
  doColumnFiltersPass(e, t, r) {
    const { data: n, aggData: i } = e, o = r ? this.activeAggregateFilters : this.activeColumnFilters, a = r ? i : n;
    for (let s = 0; s < o.length; s++) {
      const l = o[s];
      if (!(l == null || l === t)) {
        if (typeof l.doesFilterPass != "function")
          throw new Error("Filter is missing method doesFilterPass");
        if (!l.doesFilterPass({ node: e, data: a }))
          return !1;
      }
    }
    return !0;
  }
  // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
  // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
  // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
  // which results in React State getting applied in the main application, triggering a useEffect() to
  // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
  // getting it's useEffect() triggered in this way.
  callOnFilterChangedOutsideRenderCycle(e) {
    const t = () => {
      var r;
      return (r = this.filterManager) == null ? void 0 : r.onFilterChanged(e);
    };
    this.rowRenderer.isRefreshInProgress() ? setTimeout(t, 0) : t();
  }
  updateBeforeFilterChanged(e = {}) {
    const { filterInstance: t, additionalEventAttributes: r } = e;
    return this.updateDependentFilters(), this.updateActiveFilters().then(
      () => this.updateFilterFlagInColumns("filterChanged", r).then(() => {
        this.allColumnFilters.forEach((n) => {
          n.filterPromise && n.filterPromise.then((i) => {
            i && i !== t && i.onAnyFilterChanged && i.onAnyFilterChanged();
          });
        }), this.processingFilterChange = !0;
      })
    );
  }
  updateAfterFilterChanged() {
    this.processingFilterChange = !1;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !(this.gos.get("allowShowChangeAfterFilter") ?? !1) && this.processingFilterChange;
  }
  onNewRowsLoaded(e) {
    this.forEachColumnFilter((t) => {
      t.onNewRowsLoaded && t.onNewRowsLoaded();
    }).then(() => this.updateFilterFlagInColumns(e, { afterDataChange: !0 })).then(() => this.updateActiveFilters());
  }
  createValueGetter(e) {
    return ({ node: t }) => this.valueService.getValue(e, t, !0);
  }
  createGetValue(e) {
    return (t, r) => {
      const n = r ? this.columnModel.getCol(r) : e;
      return n ? this.valueService.getValue(n, t, !0) : void 0;
    };
  }
  isFilterActive(e) {
    const { filter: t } = this.cachedFilter(e) ?? {};
    return t ? t.isFilterActive() : this.getModelFromInitialState(e) != null;
  }
  getOrCreateFilterWrapper(e) {
    if (!e.isFilterAllowed())
      return null;
    let t = this.cachedFilter(e);
    return t || (t = this.createFilterWrapper(e), this.setColumnFilterWrapper(e, t)), t;
  }
  cachedFilter(e) {
    return this.allColumnFilters.get(e.getColId());
  }
  getDefaultFilter(e) {
    var r;
    let t;
    if (ci.__isRegistered("@ag-grid-enterprise/set-filter", this.gridId))
      t = "agSetColumnFilter";
    else {
      const n = (r = this.dataTypeService) == null ? void 0 : r.getBaseDataType(e);
      n === "number" ? t = "agNumberColumnFilter" : n === "date" || n === "dateString" ? t = "agDateColumnFilter" : t = "agTextColumnFilter";
    }
    return t;
  }
  getDefaultFloatingFilter(e) {
    var r;
    let t;
    if (ci.__isRegistered("@ag-grid-enterprise/set-filter", this.gridId))
      t = "agSetColumnFloatingFilter";
    else {
      const n = (r = this.dataTypeService) == null ? void 0 : r.getBaseDataType(e);
      n === "number" ? t = "agNumberColumnFloatingFilter" : n === "date" || n === "dateString" ? t = "agDateColumnFloatingFilter" : t = "agTextColumnFloatingFilter";
    }
    return t;
  }
  createFilterInstance(e, t) {
    const r = this.getDefaultFilter(e), n = e.getColDef();
    let i;
    const o = {
      ...this.createFilterParams(e, n),
      filterModifiedCallback: () => this.filterModifiedCallbackFactory(i, e)(),
      filterChangedCallback: (s) => this.filterChangedCallbackFactory(i, e)(s),
      doesRowPassOtherFilter: (s) => this.filterManager ? this.filterManager.doesRowPassOtherFilters(i, s) : !0
    }, a = this.userComponentFactory.getFilterDetails(n, o, r);
    return a ? {
      filterPromise: () => {
        const s = a.newAgStackInstance();
        return s != null && s.then((l) => {
          i = l, t && (t.filter = l);
        }), s;
      },
      compDetails: a
    } : { filterPromise: null, compDetails: null };
  }
  createFilterParams(e, t) {
    return this.gos.addGridCommonParams({
      column: e,
      colDef: LY(t),
      rowModel: this.rowModel,
      filterChangedCallback: () => {
      },
      filterModifiedCallback: () => {
      },
      valueGetter: this.createValueGetter(e),
      getValue: this.createGetValue(e),
      doesRowPassOtherFilter: () => !0
    });
  }
  createFilterWrapper(e) {
    const t = {
      column: e,
      filterPromise: null,
      compiledElement: null,
      compDetails: null
    }, { filterPromise: r, compDetails: n } = this.createFilterInstance(e, t);
    return t.filterPromise = (r == null ? void 0 : r()) ?? null, t.compDetails = n, t;
  }
  onColumnsChanged() {
    var t;
    const e = [];
    this.allColumnFilters.forEach((r, n) => {
      let i;
      r.column.isPrimary() ? i = this.columnModel.getColDefCol(n) : i = this.columnModel.getCol(n), !(i && i === r.column) && (e.push(r.column), this.disposeFilterWrapper(r, "columnChanged"), this.disposeColumnListener(n));
    }), e.length > 0 ? (t = this.filterManager) == null || t.onFilterChanged({ columns: e, source: "api" }) : this.updateDependentFilters();
  }
  updateDependentFilters() {
    const e = this.columnModel.getAutoCols();
    e == null || e.forEach((t) => {
      t.getColDef().filter === "agGroupColumnFilter" && this.getOrCreateFilterWrapper(t);
    });
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    if (!e.isFilterAllowed())
      return !1;
    const { filter: r } = this.allColumnFilters.get(e.getColId()) ?? {};
    return r && typeof (r == null ? void 0 : r.isFilterAllowed) == "function" ? r.isFilterAllowed() : !0;
  }
  getFloatingFilterCompDetails(e, t) {
    const r = (l) => {
      var c;
      const u = (c = this.getOrCreateFilterWrapper(e)) == null ? void 0 : c.filterPromise;
      u != null && u.then((d) => {
        l(Cg(d));
      });
    }, n = e.getColDef(), i = {
      ...this.createFilterParams(e, n),
      filterChangedCallback: () => r(
        (l) => this.filterChangedCallbackFactory(l, e)()
      )
    }, o = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(
      n,
      pI,
      i
    );
    let a = A$e(
      this.frameworkOverrides,
      n,
      () => this.getDefaultFloatingFilter(e)
    );
    a == null && (a = "agReadOnlyFloatingFilter");
    const s = {
      column: e,
      filterParams: o,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
      parentFilterInstance: r,
      showParentFilter: t,
      suppressFilterButton: !1
      // This one might be overridden from the colDef
    };
    return this.userComponentFactory.getFloatingFilterCompDetails(n, s, a);
  }
  getCurrentFloatingFilterParentModel(e) {
    return this.getModelFromFilterWrapper(this.cachedFilter(e) ?? { column: e });
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    var i;
    const r = e.getColId(), n = this.allColumnFilters.get(r);
    this.disposeColumnListener(r), delete this.initialFilterModel[r], n && (this.disposeFilterWrapper(n, t), (i = this.filterManager) == null || i.onFilterChanged({
      columns: [e],
      source: "api"
    }));
  }
  disposeColumnListener(e) {
    const t = this.allColumnListeners.get(e);
    t && (this.allColumnListeners.delete(e), t());
  }
  disposeFilterWrapper(e, t) {
    e.filterPromise.then((r) => {
      this.destroyBean(r), e.column.setFilterActive(!1, "filterDestroyed"), this.allColumnFilters.delete(e.column.getColId());
      const n = {
        type: "filterDestroyed",
        source: t,
        column: e.column
      };
      this.eventService.dispatchEvent(n);
    });
  }
  filterModifiedCallbackFactory(e, t) {
    return () => {
      const r = {
        type: "filterModified",
        column: t,
        filterInstance: e
      };
      this.eventService.dispatchEvent(r);
    };
  }
  filterChangedCallbackFactory(e, t) {
    return (r) => {
      const n = (r == null ? void 0 : r.source) ?? "columnFilter", i = {
        filter: e,
        additionalEventAttributes: r,
        columns: [t],
        source: n
      };
      this.callOnFilterChangedOutsideRenderCycle(i);
    };
  }
  checkDestroyFilter(e) {
    const t = this.allColumnFilters.get(e);
    if (!t)
      return;
    const r = t.column, { compDetails: n } = r.isFilterAllowed() ? this.createFilterInstance(r) : { compDetails: null };
    if (this.areFilterCompsDifferent(t.compDetails, n)) {
      this.destroyFilter(r, "paramsUpdated");
      return;
    }
    const i = r.getColDef().filterParams;
    if (!t.filterPromise) {
      this.destroyFilter(r, "paramsUpdated");
      return;
    }
    t.filterPromise.then((o) => {
      (o != null && o.refresh ? o.refresh({
        ...this.createFilterParams(r, r.getColDef()),
        filterModifiedCallback: this.filterModifiedCallbackFactory(o, r),
        filterChangedCallback: this.filterChangedCallbackFactory(o, r),
        doesRowPassOtherFilter: (s) => this.filterManager ? this.filterManager.doesRowPassOtherFilters(o, s) : !0,
        ...i
      }) : !0) === !1 && this.destroyFilter(r, "paramsUpdated");
    });
  }
  setColumnFilterWrapper(e, t) {
    const r = e.getColId();
    this.allColumnFilters.set(r, t), this.allColumnListeners.set(
      r,
      this.addManagedListeners(e, { colDefChanged: () => this.checkDestroyFilter(r) })[0]
    );
  }
  areFilterCompsDifferent(e, t) {
    if (!t || !e)
      return !0;
    const { componentClass: r } = e, { componentClass: n } = t;
    return !(r === n || // react hooks returns new wrappers, so check nested render method
    (r == null ? void 0 : r.render) && (n == null ? void 0 : n.render) && r.render === n.render);
  }
  hasFloatingFilters() {
    return this.columnModel.getCols().some((t) => t.getColDef().floatingFilter);
  }
  getFilterInstance(e, t) {
    t && this.getFilterInstanceImpl(e).then((r) => {
      const n = Cg(r);
      t(n);
    });
  }
  getColumnFilterInstance(e) {
    return new Promise((t) => {
      this.getFilterInstanceImpl(e).then((r) => {
        t(Cg(r));
      });
    });
  }
  getFilterInstanceImpl(e) {
    var n;
    const t = this.columnModel.getColDefCol(e);
    return t ? ((n = this.getOrCreateFilterWrapper(t)) == null ? void 0 : n.filterPromise) ?? gn.resolve(null) : gn.resolve(void 0);
  }
  processFilterModelUpdateQueue() {
    this.filterModelUpdateQueue.forEach(({ model: e, source: t }) => this.setFilterModel(e, t)), this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue.forEach(({ key: e, model: t, resolve: r }) => {
      this.setColumnFilterModel(e, t).then(() => r());
    }), this.columnFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    const t = this.getFilterWrapper(e);
    return t ? this.getModelFromFilterWrapper(t) : null;
  }
  setColumnFilterModel(e, t) {
    var o;
    if ((o = this.dataTypeService) != null && o.isPendingInference()) {
      let a = () => {
      };
      const s = new Promise((l) => {
        a = l;
      });
      return this.columnFilterModelUpdateQueue.push({ key: e, model: t, resolve: a }), s;
    }
    const r = this.columnModel.getColDefCol(e), n = r ? this.getOrCreateFilterWrapper(r) : null;
    return n ? ((a) => new Promise((s) => {
      a.then((l) => s(l));
    }))(this.setModelOnFilterWrapper(n.filterPromise, t)) : Promise.resolve();
  }
  getFilterWrapper(e) {
    const t = this.columnModel.getColDefCol(e);
    return t ? this.cachedFilter(t) ?? null : null;
  }
  destroy() {
    super.destroy(), this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear();
  }
};
function O$e(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isAnyFilterPresent());
}
function L$e(e, t = "api") {
  var r;
  (r = e.filterManager) == null || r.onFilterChanged({ source: t });
}
var F$e = class extends tn {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`,
      [Vw]
    ), this.eFloatingFilterText = Pt;
  }
  wireBeans(e) {
    this.columnNameService = e.columnNameService;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e;
    const t = this.columnNameService.getDisplayNameForColumn(e.column, "header", !0), r = this.localeService.getLocaleTextFunc();
    this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${t} ${r("ariaFilterInput", "Filter Input")}`);
  }
  onParentModelChanged(e) {
    if (e == null) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((t) => {
      if (t.getModelAsString) {
        const r = t.getModelAsString(e);
        this.eFloatingFilterText.setValue(r);
      }
    });
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.init(e);
  }
}, Lq = class extends tn {
  wireBeans(e) {
    this.columnNameService = e.columnNameService;
  }
  getDefaultDebounceMs() {
    return 0;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  isEventFromFloatingFilter(e) {
    return e && e.afterFloatingFilter;
  }
  isEventFromDataChange(e) {
    return e == null ? void 0 : e.afterDataChange;
  }
  getLastType() {
    return this.lastType;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setLastTypeFromModel(e) {
    if (!e) {
      this.lastType = this.optionsFactory.getDefaultOption();
      return;
    }
    const t = e.operator;
    let r;
    t ? r = e.conditions[0] : r = e, this.lastType = r.type;
  }
  canWeEditAfterModelFromParentFilter(e) {
    if (!e)
      return this.isTypeEditable(this.lastType);
    if (e.operator)
      return !1;
    const r = e;
    return this.isTypeEditable(r.type);
  }
  init(e) {
    this.setSimpleParams(e, !1);
  }
  setSimpleParams(e, t = !0) {
    this.optionsFactory = new mq(), this.optionsFactory.init(e.filterParams, this.getDefaultFilterOptions()), t || (this.lastType = this.optionsFactory.getDefaultOption()), this.readOnly = !!e.filterParams.readOnly;
    const r = this.isTypeEditable(this.optionsFactory.getDefaultOption());
    this.setEditable(r);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.setSimpleParams(e);
  }
  doesFilterHaveSingleInput(e) {
    const t = this.optionsFactory.getCustomOption(e), { numberOfInputs: r } = t || {};
    return r == null || r == 1;
  }
  isTypeEditable(e) {
    const t = ["inRange", "empty", "blank", "notBlank"];
    return !!e && !this.isReadOnly() && this.doesFilterHaveSingleInput(e) && t.indexOf(e) < 0;
  }
  getAriaLabel(e) {
    const t = this.columnNameService.getDisplayNameForColumn(e.column, "header", !0), r = this.localeService.getLocaleTextFunc();
    return `${t} ${r("ariaFilterInput", "Filter Input")}`;
  }
}, N$e = class extends Lq {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eReadOnlyText"></ag-input-text-field>
                <div data-ref="eDateWrapper" style="display: flex;"></div>
            </div>`,
      [Vw]
    ), this.eReadOnlyText = Pt, this.eDateWrapper = Pt;
  }
  wireBeans(e) {
    super.wireBeans(e), this.context = e.context, this.userComponentFactory = e.userComponentFactory;
  }
  getDefaultFilterOptions() {
    return Pq;
  }
  init(e) {
    super.init(e), this.params = e, this.filterParams = e.filterParams, this.createDateComponent(), this.filterModelFormatter = new Mq(
      this.filterParams,
      this.localeService,
      this.optionsFactory
    );
    const t = this.localeService.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(t("ariaDateFilterInput", "Date Filter Input"));
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.params = e, this.filterParams = e.filterParams, this.updateDateComponent(), this.filterModelFormatter.updateParams({
      optionsFactory: this.optionsFactory,
      dateFilterParams: this.filterParams
    }), this.updateCompOnModelChange(e.currentParentModel());
  }
  updateCompOnModelChange(e) {
    const t = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(e);
    if (this.setEditable(t), t) {
      if (e) {
        const r = e;
        this.dateComp.setDate(qi(r.dateFrom));
      } else
        this.dateComp.setDate(null);
      this.eReadOnlyText.setValue("");
    } else
      this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(e)), this.dateComp.setDate(null);
  }
  setEditable(e) {
    ln(this.eDateWrapper, e), ln(this.eReadOnlyText.getGui(), !e);
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (super.setLastTypeFromModel(e), this.updateCompOnModelChange(e));
  }
  onDateChanged() {
    const e = this.dateComp.getDate(), t = Xo(e);
    this.params.parentFilterInstance((r) => {
      if (r) {
        const n = qi(t);
        r.onFloatingFilterChanged(this.getLastType() || null, n);
      }
    });
  }
  getDateComponentParams() {
    const e = gI(this.params.filterParams, this.getDefaultDebounceMs());
    return {
      onDateChanged: Ti(this.onDateChanged.bind(this), e),
      filterParams: this.params.column.getColDef().filterParams
    };
  }
  createDateComponent() {
    this.dateComp = new Tq(
      this.context,
      this.userComponentFactory,
      this.getDateComponentParams(),
      this.eDateWrapper,
      (e) => {
        e.setInputAriaLabel(this.getAriaLabel(this.params));
      }
    ), this.addDestroyFunc(() => this.dateComp.destroy());
  }
  updateDateComponent() {
    const e = this.gos.addGridCommonParams(this.getDateComponentParams());
    this.dateComp.updateParams(e);
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
}, k$e = class extends tn {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" data-ref="eDateInput"></ag-input-text-field>
            </div>`,
      [Vw]
    ), this.eDateInput = Pt;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.setParams(e);
    const t = this.eDateInput.getInputElement();
    this.addManagedListeners(t, {
      // ensures that the input element is focussed when a clear button is clicked,
      // unless using safari as there is no clear button and focus does not work properly
      mouseDown: () => {
        this.eDateInput.isDisabled() || this.usingSafariDatePicker || t.focus();
      },
      input: (r) => {
        r.target === this.gos.getActiveDomElement() && (this.eDateInput.isDisabled() || this.params.onDateChanged());
      }
    });
  }
  setParams(e) {
    const t = this.eDateInput.getInputElement(), r = this.shouldUseBrowserDatePicker(e);
    this.usingSafariDatePicker = r && al(), t.type = r ? "date" : "text";
    const { minValidYear: n, maxValidYear: i, minValidDate: o, maxValidDate: a } = e.filterParams || {};
    if (o && n && Te(
      "DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored."
    ), a && i && Te(
      "DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored."
    ), o && a) {
      const [s, l] = [o, a].map(
        (u) => u instanceof Date ? u : qi(u)
      );
      s && l && s.getTime() > l.getTime() && Te(
        "DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate."
      );
    }
    o ? o instanceof Date ? t.min = wg(o) : t.min = o : n && (t.min = `${n}-01-01`), a ? a instanceof Date ? t.max = wg(a) : t.max = a : i && (t.max = `${i}-12-31`);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.params = e, this.setParams(e);
  }
  getDate() {
    return qi(this.eDateInput.getValue());
  }
  setDate(e) {
    this.eDateInput.setValue(Xo(e, !1));
  }
  setInputPlaceholder(e) {
    this.eDateInput.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.eDateInput.setAriaLabel(e);
  }
  setDisabled(e) {
    this.eDateInput.setDisabled(e);
  }
  afterGuiAttached(e) {
    (!e || !e.suppressFocus) && this.eDateInput.getInputElement().focus();
  }
  shouldUseBrowserDatePicker(e) {
    return e.filterParams && e.filterParams.browserDatePicker != null ? e.filterParams.browserDatePicker : aI() || KY() || al() && UY() >= 14.1;
  }
}, Fq = class extends Se {
  constructor(e) {
    super(), this.params = e, this.eFloatingFilterTextInput = Pt, this.valueChangedListener = () => {
    };
  }
  setupGui(e) {
    var n;
    this.eFloatingFilterTextInput = this.createManagedBean(new vd((n = this.params) == null ? void 0 : n.config));
    const t = this.eFloatingFilterTextInput.getGui();
    e.appendChild(t);
    const r = (i) => this.valueChangedListener(i);
    this.addManagedListeners(t, {
      input: r,
      keydown: r
    });
  }
  setEditable(e) {
    this.eFloatingFilterTextInput.setDisabled(!e);
  }
  setAutoComplete(e) {
    this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.eFloatingFilterTextInput.getValue();
  }
  setValue(e, t) {
    this.eFloatingFilterTextInput.setValue(e, t);
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, Nq = class extends Lq {
  constructor() {
    super(...arguments), this.eFloatingFilterInputContainer = Pt;
  }
  postConstruct() {
    this.setTemplate(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation" data-ref="eFloatingFilterInputContainer"></div>
        `
    );
  }
  getDefaultDebounceMs() {
    return 500;
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(e)));
  }
  init(e) {
    this.setupFloatingFilterInputService(e), super.init(e), this.setTextInputParams(e);
  }
  setupFloatingFilterInputService(e) {
    this.floatingFilterInputService = this.createFloatingFilterInputService(e), this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer);
  }
  setTextInputParams(e) {
    this.params = e;
    const t = e.browserAutoComplete ?? !1;
    if (this.floatingFilterInputService.setParams({
      ariaLabel: this.getAriaLabel(e),
      autoComplete: t
    }), this.applyActive = sS(this.params.filterParams), !this.isReadOnly()) {
      const r = gI(this.params.filterParams, this.getDefaultDebounceMs()), n = Ti(
        this.syncUpWithParentFilter.bind(this),
        r
      );
      this.floatingFilterInputService.setValueChangedListener(n);
    }
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.setTextInputParams(e);
  }
  recreateFloatingFilterInputService(e) {
    const t = this.floatingFilterInputService.getValue();
    xo(this.eFloatingFilterInputContainer), this.destroyBean(this.floatingFilterInputService), this.setupFloatingFilterInputService(e), this.floatingFilterInputService.setValue(t, !0);
  }
  syncUpWithParentFilter(e) {
    const t = e.key === pe.ENTER;
    if (this.applyActive && !t)
      return;
    let r = this.floatingFilterInputService.getValue();
    this.params.filterParams.trimInput && (r = Rq(r), this.floatingFilterInputService.setValue(r, !0)), this.params.parentFilterInstance((n) => {
      n && n.onFloatingFilterChanged(this.getLastType() || null, r || null);
    });
  }
  setEditable(e) {
    this.floatingFilterInputService.setEditable(e);
  }
}, V$e = class extends Se {
  constructor() {
    super(...arguments), this.valueChangedListener = () => {
    }, this.numberInputActive = !0;
  }
  setupGui(e) {
    this.eFloatingFilterNumberInput = this.createManagedBean(new mI()), this.eFloatingFilterTextInput = this.createManagedBean(new vd()), this.eFloatingFilterTextInput.setDisabled(!0);
    const t = this.eFloatingFilterNumberInput.getGui(), r = this.eFloatingFilterTextInput.getGui();
    e.appendChild(t), e.appendChild(r), this.setupListeners(t, (n) => this.valueChangedListener(n)), this.setupListeners(r, (n) => this.valueChangedListener(n));
  }
  setEditable(e) {
    this.numberInputActive = e, this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive), this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive);
  }
  setAutoComplete(e) {
    this.eFloatingFilterNumberInput.setAutoComplete(e), this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(e, t) {
    this.getActiveInputElement().setValue(e, t);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput;
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setupListeners(e, t) {
    this.addManagedListeners(e, {
      input: t,
      keydown: t
    });
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterNumberInput.setInputAriaLabel(e), this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, B$e = class extends Nq {
  init(e) {
    var t;
    super.init(e), this.filterModelFormatter = new bq(
      this.localeService,
      this.optionsFactory,
      (t = e.filterParams) == null ? void 0 : t.numberFormatter
    );
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    hP(e.filterParams) !== this.allowedCharPattern && this.recreateFloatingFilterInputService(e), super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return wq;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService(e) {
    return this.allowedCharPattern = hP(e.filterParams), this.allowedCharPattern ? this.createManagedBean(
      new Fq({
        config: { allowedCharPattern: this.allowedCharPattern }
      })
    ) : this.createManagedBean(new V$e());
  }
}, $$e = class extends Nq {
  init(e) {
    super.init(e), this.filterModelFormatter = new Eq(this.localeService, this.optionsFactory);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return xq;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService() {
    return this.createManagedBean(new Fq());
  }
};
function H$e(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isQuickFilterPresent());
}
function G$e(e) {
  return e.gos.get("quickFilterText");
}
function z$e(e) {
  var t;
  (t = e.filterManager) == null || t.resetQuickFilterCache();
}
var W$e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "quickFilterService", this.quickFilter = null, this.quickFilterParts = null;
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.rowModel = e.rowModel, this.pivotResultColsService = e.pivotResultColsService;
  }
  postConstruct() {
    const e = this.resetQuickFilterCache.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: e,
      newColumnsLoaded: e,
      columnRowGroupChanged: e,
      columnVisible: () => {
        this.gos.get("includeHiddenColumnsInQuickFilter") || this.resetQuickFilterCache();
      }
    }), this.addManagedPropertyListener("quickFilterText", (t) => this.setQuickFilter(t.currentValue)), this.addManagedPropertyListeners(
      ["includeHiddenColumnsInQuickFilter", "applyQuickFilterBeforePivotOrAgg"],
      () => this.onQuickFilterColumnConfigChanged()
    ), this.quickFilter = this.parseQuickFilter(this.gos.get("quickFilterText")), this.parser = this.gos.get("quickFilterParser"), this.matcher = this.gos.get("quickFilterMatcher"), this.setQuickFilterParts(), this.addManagedPropertyListeners(
      ["quickFilterMatcher", "quickFilterParser"],
      () => this.setQuickFilterParserAndMatcher()
    );
  }
  // if we are using autoGroupCols, then they should be included for quick filter. this covers the
  // following scenarios:
  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
  refreshQuickFilterCols() {
    var i;
    const e = this.columnModel.isPivotMode(), t = this.columnModel.getAutoCols(), r = this.columnModel.getColDefCols();
    let n = (e && !this.gos.get("applyQuickFilterBeforePivotOrAgg") ? (i = this.pivotResultColsService.getPivotResultCols()) == null ? void 0 : i.list : r) ?? [];
    t && (n = n.concat(t)), this.colsForQuickFilter = this.gos.get("includeHiddenColumnsInQuickFilter") ? n : n.filter((o) => o.isVisible() || o.isRowGroupActive());
  }
  isQuickFilterPresent() {
    return this.quickFilter !== null;
  }
  doesRowPassQuickFilter(e) {
    const t = this.gos.get("cacheQuickFilter");
    return this.matcher ? this.doesRowPassQuickFilterMatcher(t, e) : this.quickFilterParts.every(
      (r) => t ? this.doesRowPassQuickFilterCache(e, r) : this.doesRowPassQuickFilterNoCache(e, r)
    );
  }
  resetQuickFilterCache() {
    this.rowModel.forEachNode((e) => e.quickFilterAggregateText = null);
  }
  setQuickFilterParts() {
    const { quickFilter: e, parser: t } = this;
    e ? this.quickFilterParts = t ? t(e) : e.split(" ") : this.quickFilterParts = null;
  }
  parseQuickFilter(e) {
    return ke(e) ? this.gos.isRowModelType("clientSide") ? e.toUpperCase() : (Te("Quick filtering only works with the Client-Side Row Model"), null) : null;
  }
  setQuickFilter(e) {
    if (e != null && typeof e != "string") {
      Te(`Grid option quickFilterText only supports string inputs, received: ${typeof e}`);
      return;
    }
    const t = this.parseQuickFilter(e);
    this.quickFilter !== t && (this.quickFilter = t, this.setQuickFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  setQuickFilterParserAndMatcher() {
    const e = this.gos.get("quickFilterParser"), t = this.gos.get("quickFilterMatcher"), r = e !== this.parser || t !== this.matcher;
    this.parser = e, this.matcher = t, r && (this.setQuickFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  onQuickFilterColumnConfigChanged() {
    this.refreshQuickFilterCols(), this.resetQuickFilterCache(), this.isQuickFilterPresent() && this.dispatchLocalEvent({ type: "quickFilterChanged" });
  }
  doesRowPassQuickFilterNoCache(e, t) {
    return this.colsForQuickFilter.some((r) => {
      const n = this.getQuickFilterTextForColumn(r, e);
      return ke(n) && n.indexOf(t) >= 0;
    });
  }
  doesRowPassQuickFilterCache(e, t) {
    return this.checkGenerateQuickFilterAggregateText(e), e.quickFilterAggregateText.indexOf(t) >= 0;
  }
  doesRowPassQuickFilterMatcher(e, t) {
    let r;
    e ? (this.checkGenerateQuickFilterAggregateText(t), r = t.quickFilterAggregateText) : r = this.getQuickFilterAggregateText(t);
    const { quickFilterParts: n, matcher: i } = this;
    return i(n, r);
  }
  checkGenerateQuickFilterAggregateText(e) {
    e.quickFilterAggregateText || (e.quickFilterAggregateText = this.getQuickFilterAggregateText(e));
  }
  getQuickFilterTextForColumn(e, t) {
    let r = this.valueService.getValue(e, t, !0);
    const n = e.getColDef();
    if (n.getQuickFilterText) {
      const i = this.gos.addGridCommonParams({
        value: r,
        node: t,
        data: t.data,
        column: e,
        colDef: n
      });
      r = n.getQuickFilterText(i);
    }
    return ke(r) ? r.toString().toUpperCase() : null;
  }
  getQuickFilterAggregateText(e) {
    const t = [];
    return this.colsForQuickFilter.forEach((r) => {
      const n = this.getQuickFilterTextForColumn(r, e);
      ke(n) && t.push(n);
    }), t.join(`
`);
  }
}, wI = {
  version: kt,
  moduleName: "@ag-grid-community/filter-core",
  beans: [U4e]
}, j$e = {
  version: kt,
  moduleName: "@ag-grid-community/filter-api",
  apiFunctions: {
    isAnyFilterPresent: O$e,
    onFilterChanged: L$e
  },
  dependantModules: [wI]
}, bI = {
  version: kt,
  moduleName: "@ag-grid-community/column-filter",
  beans: [I$e],
  dependantModules: [wI]
}, U$e = {
  version: kt,
  moduleName: "@ag-grid-community/column-filter-api",
  apiFunctions: {
    isColumnFilterPresent: b$e,
    getFilterInstance: x$e,
    getColumnFilterInstance: E$e,
    destroyFilter: R$e,
    setFilterModel: _$e,
    getFilterModel: T$e,
    getColumnFilterModel: P$e,
    setColumnFilterModel: M$e,
    showColumnFilter: D$e
  },
  dependantModules: [bI, j$e]
}, kq = {
  version: kt,
  moduleName: "@ag-grid-community/floating-filter-core",
  controllers: [{ name: "headerFilterCell", classImp: w$e }],
  dependantModules: [bI]
}, K$e = {
  version: kt,
  moduleName: "@ag-grid-community/read-only-floating-filter",
  userComponents: [{ name: "agReadOnlyFloatingFilter", classImp: F$e }],
  dependantModules: [kq]
}, Y$e = {
  version: kt,
  moduleName: "@ag-grid-community/simple-filter",
  dependantModules: [bI],
  userComponents: [
    { name: "agTextColumnFilter", classImp: h$e },
    { name: "agNumberColumnFilter", classImp: d$e },
    { name: "agDateColumnFilter", classImp: g$e },
    { name: "agDateInput", classImp: k$e }
  ]
}, q$e = {
  version: kt,
  moduleName: "@ag-grid-community/simple-floating-filter",
  dependantModules: [Y$e, kq],
  userComponents: [
    { name: "agTextColumnFloatingFilter", classImp: $$e },
    { name: "agNumberColumnFloatingFilter", classImp: B$e },
    { name: "agDateColumnFloatingFilter", classImp: N$e }
  ]
}, Vq = {
  version: kt,
  moduleName: "@ag-grid-community/quick-filter-core",
  beans: [W$e],
  dependantModules: [wI]
}, X$e = {
  version: kt,
  moduleName: "@ag-grid-community/quick-filter-api",
  apiFunctions: {
    isQuickFilterPresent: H$e,
    getQuickFilter: G$e,
    resetQuickFilter: z$e
  },
  dependantModules: [Vq]
}, Z$e = {
  version: kt,
  moduleName: "@ag-grid-community/quick-filter",
  dependantModules: [Vq, X$e]
}, Q$e = {
  version: kt,
  moduleName: "@ag-grid-community/filter",
  dependantModules: [
    q$e,
    K$e,
    Z$e,
    U$e
  ]
}, fP = /* @__PURE__ */ ((e) => (e.COLUMN_GROUP = "group", e.COLUMN = "column", e.FLOATING_FILTER = "filter", e))(fP || {}), J$e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "headerNavigationService", this.currentHeaderRowWithoutSpan = -1;
  }
  wireBeans(e) {
    this.focusService = e.focusService, this.headerPositionUtils = e.headerPositionUtils, this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.visibleColService = e.visibleColsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((t) => {
      this.gridBodyCon = t.gridBodyCtrl;
    });
    const e = this.gos.getDocument();
    this.addManagedElementListeners(e, { mousedown: () => this.setCurrentHeaderRowWithoutSpan(-1) });
  }
  getHeaderRowCount() {
    const e = this.ctrlsService.getHeaderRowContainerCtrl();
    return e ? e.getRowCount() : 0;
  }
  getHeaderPositionForColumn(e, t) {
    let r;
    if (typeof e == "string" ? (r = this.columnModel.getCol(e), r || (r = this.visibleColService.getColumnGroup(e))) : r = e, !r)
      return null;
    const i = this.ctrlsService.getHeaderRowContainerCtrl().getAllCtrls(), o = gr(i).getType() === "filter", a = this.getHeaderRowCount() - 1;
    let s = -1, l = r;
    for (; l; )
      s++, l = l.getParent();
    let u = s;
    return t && o && u === a - 1 && u++, u === -1 ? null : {
      headerRowIndex: u,
      column: r
    };
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(e, t, r) {
    if (t || (t = this.focusService.getFocusedHeader()), !t)
      return !1;
    const { headerRowIndex: n } = t, i = t.column, o = this.getHeaderRowCount(), a = e === 0;
    let {
      headerRowIndex: s,
      column: l,
      // eslint-disable-next-line prefer-const
      headerRowIndexWithoutSpan: u
    } = a ? this.headerPositionUtils.getColumnVisibleParent(i, n) : this.headerPositionUtils.getColumnVisibleChild(i, n), c = !1;
    return s < 0 && (s = 0, l = i, c = !0), s >= o ? (s = -1, this.setCurrentHeaderRowWithoutSpan(-1)) : u !== void 0 && (this.currentHeaderRowWithoutSpan = u), !c && !l ? !1 : this.focusService.focusHeaderPosition({
      headerPosition: { headerRowIndex: s, column: l },
      allowUserOverride: !0,
      event: r
    });
  }
  setCurrentHeaderRowWithoutSpan(e) {
    this.currentHeaderRowWithoutSpan = e;
  }
  /*
   * This method navigates grid header horizontally
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(e, t = !1, r) {
    const n = this.focusService.getFocusedHeader(), i = e === 2, o = this.gos.get("enableRtl");
    let a, s;
    if (this.currentHeaderRowWithoutSpan !== -1 ? n.headerRowIndex = this.currentHeaderRowWithoutSpan : this.currentHeaderRowWithoutSpan = n.headerRowIndex, i !== o ? (s = "Before", a = this.headerPositionUtils.findHeader(n, s)) : (s = "After", a = this.headerPositionUtils.findHeader(n, s)), a || !t)
      return this.focusService.focusHeaderPosition({
        headerPosition: a,
        direction: s,
        fromTab: t,
        allowUserOverride: !0,
        event: r
      });
    if (t) {
      const l = this.gos.getCallback("tabToNextHeader");
      if (l)
        return this.focusService.focusHeaderPositionFromUserFunc({
          userFunc: l,
          headerPosition: a,
          direction: s
        });
    }
    return this.focusNextHeaderRow(n, s, r);
  }
  focusNextHeaderRow(e, t, r) {
    const n = e.headerRowIndex;
    let i = null, o;
    if (t === "Before" ? n > 0 && (o = n - 1, this.currentHeaderRowWithoutSpan -= 1, i = this.headerPositionUtils.findColAtEdgeForHeaderRow(o, "end")) : (o = n + 1, this.currentHeaderRowWithoutSpan < this.getHeaderRowCount() ? this.currentHeaderRowWithoutSpan += 1 : this.setCurrentHeaderRowWithoutSpan(-1), i = this.headerPositionUtils.findColAtEdgeForHeaderRow(o, "start")), !i)
      return !1;
    const { column: a, headerRowIndex: s } = this.headerPositionUtils.getHeaderIndexToFocus(
      i.column,
      i == null ? void 0 : i.headerRowIndex
    );
    return this.focusService.focusHeaderPosition({
      headerPosition: { column: a, headerRowIndex: s },
      direction: t,
      fromTab: !0,
      allowUserOverride: !0,
      event: r
    });
  }
  scrollToColumn(e, t = "After") {
    if (e.getPinned())
      return;
    let r;
    if (Sn(e)) {
      const n = e.getDisplayedLeafColumns();
      r = t === "Before" ? gr(n) : n[0];
    } else
      r = e;
    this.gridBodyCon.getScrollFeature().ensureColumnVisible(r);
  }
}, eHe = class extends Se {
  wireBeans(e) {
    this.headerNavigationService = e.headerNavigationService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService, this.filterManager = e.filterManager, this.menuService = e.menuService;
  }
  setComp(e, t, r) {
    this.comp = e, this.eGui = t, this.createManagedBean(
      new gd(r, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addManagedEventListeners({
      columnPivotModeChanged: this.onPivotModeChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    }), this.onPivotModeChanged(), this.setupHeaderHeight();
    const n = this.onHeaderContextMenu.bind(this);
    this.addManagedElementListeners(this.eGui, { contextmenu: n }), this.mockContextMenuForIPad(n), this.ctrlsService.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const e = this.setHeaderHeight.bind(this);
    e(), this.addManagedPropertyListener("headerHeight", e), this.addManagedPropertyListener("pivotHeaderHeight", e), this.addManagedPropertyListener("groupHeaderHeight", e), this.addManagedPropertyListener("pivotGroupHeaderHeight", e), this.addManagedPropertyListener("floatingFiltersHeight", e), this.addManagedEventListeners({
      displayedColumnsChanged: e,
      columnHeaderHeightChanged: e,
      gridStylesChanged: e,
      advancedFilterEnabledChanged: e
    });
  }
  getHeaderHeight() {
    return this.headerHeight;
  }
  setHeaderHeight() {
    var c;
    const { columnModel: e } = this;
    let t = 0, r = e.getHeaderRowCount(), n;
    ((c = this.filterManager) == null ? void 0 : c.hasFloatingFilters()) && (r++, t = 1);
    const o = this.columnModel.getColumnGroupHeaderRowHeight(), a = this.columnModel.getColumnHeaderRowHeight(), s = 1 + t, l = r - s;
    if (n = t * e.getFloatingFiltersHeight(), n += l * o, n += a, this.headerHeight === n)
      return;
    this.headerHeight = n;
    const u = `${n + 1}px`;
    this.comp.setHeightAndMinHeight(u), this.eventService.dispatchEvent({
      type: "headerHeightChanged"
    });
  }
  onPivotModeChanged() {
    const e = this.columnModel.isPivotMode();
    this.comp.addOrRemoveCssClass("ag-pivot-on", e), this.comp.addOrRemoveCssClass("ag-pivot-off", !e);
  }
  onDisplayedColumnsChanged() {
    const t = this.visibleColsService.getAllCols().some((r) => r.isSpanHeaderHeight());
    this.comp.addOrRemoveCssClass("ag-header-allow-overflow", t);
  }
  onTabKeyDown(e) {
    const t = this.gos.get("enableRtl"), r = e.shiftKey !== t ? 2 : 3;
    (this.headerNavigationService.navigateHorizontally(r, !0, e) || this.focusService.focusNextGridCoreContainer(e.shiftKey)) && e.preventDefault();
  }
  handleKeyDown(e) {
    let t = null;
    switch (e.key) {
      case pe.LEFT:
        t = 2;
      case pe.RIGHT: {
        ke(t) || (t = 3), this.headerNavigationService.navigateHorizontally(t, !1, e);
        break;
      }
      case pe.UP:
        t = 0;
      case pe.DOWN: {
        ke(t) || (t = 1), this.headerNavigationService.navigateVertically(t, null, e) && e.preventDefault();
        break;
      }
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget: t } = e;
    !t && this.eGui.contains(this.gos.getActiveDomElement()) || this.eGui.contains(t) || this.focusService.clearFocusedHeader();
  }
  onHeaderContextMenu(e, t, r) {
    if (!e && !r || !this.menuService.isHeaderContextMenuEnabled())
      return;
    const { target: n } = e ?? t;
    (n === this.eGui || n === this.ctrlsService.getHeaderRowContainerCtrl().getViewport()) && this.menuService.showHeaderContextMenu(void 0, e, r);
  }
  mockContextMenuForIPad(e) {
    if (!xu())
      return;
    const t = new ql(this.eGui), r = (n) => {
      e(void 0, n.touchStart, n.touchEvent);
    };
    this.addManagedListeners(t, { longTap: r }), this.addDestroyFunc(() => t.destroy());
  }
}, xI = class extends Se {
  constructor(e, t = !1) {
    super(), this.callback = e, this.addSpacer = t;
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  postConstruct() {
    const e = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", e), this.addManagedEventListeners({
      columnContainerWidthChanged: e,
      displayedColumnsChanged: e,
      leftPinnedWidthChanged: e
    }), this.addSpacer && this.addManagedEventListeners({
      rightPinnedWidthChanged: e,
      scrollVisibilityChanged: e,
      scrollbarWidthChanged: e
    }), this.setWidth();
  }
  setWidth() {
    const e = this.gos.isDomLayout("print"), t = this.visibleColsService.getBodyContainerWidth(), r = this.visibleColsService.getColsLeftWidth(), n = this.visibleColsService.getDisplayedColumnsRightWidth();
    let i;
    e ? i = t + r + n : (i = t, this.addSpacer && (this.gos.get("enableRtl") ? r : n) === 0 && this.scrollVisibleService.isVerticalScrollShowing() && (i += this.gos.getScrollbarWidth())), this.callback(i);
  }
}, tHe = class extends Se {
  constructor(e) {
    super(), this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [], this.pinned = e;
  }
  wireBeans(e) {
    this.funcColsService = e.funcColsService;
  }
  /** Callback for when drag enters */
  onDragEnter(e) {
    if (this.clearColumnsList(), this.gos.get("functionsReadOnly"))
      return;
    const t = e.dragItem.columns;
    t && t.forEach((r) => {
      r.isPrimary() && (r.isAnyFunctionActive() || (r.isAllowValue() ? this.columnsToAggregate.push(r) : r.isAllowRowGroup() ? this.columnsToGroup.push(r) : r.isAllowPivot() && this.columnsToPivot.push(r)));
    });
  }
  getIconName() {
    return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? "pinned" : "move" : null;
  }
  /** Callback for when drag leaves */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragLeave(e) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragging(e) {
  }
  /** Callback for when drag stops */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragStop(e) {
    this.columnsToAggregate.length > 0 && this.funcColsService.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop"), this.columnsToGroup.length > 0 && this.funcColsService.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop"), this.columnsToPivot.length > 0 && this.funcColsService.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
  }
};
function EI(e) {
  const {
    isFromHeader: t,
    hDirection: r,
    xPosition: n,
    fromEnter: i,
    fakeEvent: o,
    pinned: a,
    gos: s,
    columnModel: l,
    columnMoveService: u,
    presentedColsService: c
  } = e, d = r === 0, h = r === 1;
  let { allMovingColumns: f } = e;
  if (t) {
    const w = [];
    f.forEach((x) => {
      var T;
      let R = null, _ = x.getParent();
      for (; _ != null && _.getDisplayedLeafColumns().length === 1; )
        R = _, _ = _.getParent();
      R != null ? (!!((T = R.getColGroupDef()) != null && T.marryChildren) ? (
        // when marry children is true, we also have to move hidden
        // columns within the group, so grab them from the `providedColumnGroup`
        R.getProvidedColumnGroup().getLeafColumns()
      ) : R.getLeafColumns()).forEach((O) => {
        w.includes(O) || w.push(O);
      }) : w.includes(x) || w.push(x);
    }), f = w;
  }
  const p = f.slice();
  l.sortColsLikeCols(p);
  const g = oHe({
    movingCols: p,
    draggingRight: h,
    xPosition: n,
    pinned: a,
    gos: s,
    columnModel: l,
    presentedColsService: c
  }), v = rHe(p, l);
  if (g.length === 0)
    return;
  const m = g[0];
  let y = v !== null && !i;
  if (t && (y = v !== null), y && !o && (d && m >= v || h && m <= v))
    return;
  const C = c.getAllCols(), S = [];
  let b = null;
  for (let w = 0; w < g.length; w++) {
    const x = g[w], R = u.getProposedColumnOrder(p, x);
    if (!u.doesOrderPassRules(R))
      continue;
    const _ = R.filter((P) => C.includes(P));
    if (b === null)
      b = _;
    else if (!fd(_, b))
      break;
    const T = nHe(R);
    S.push({ move: x, fragCount: T });
  }
  if (S.length !== 0)
    return S.sort((w, x) => w.fragCount - x.fragCount), Bq(f, S[0].move, "uiColumnMoved", !1, u);
}
function Bq(e, t, r, n, i) {
  return i.moveColumns(e, t, r, n), n ? null : { columns: e, toIndex: t };
}
function rHe(e, t) {
  const r = t.getCols(), n = zVe(e.map((l) => r.indexOf(l))), i = n[0];
  return gr(n) - i !== n.length - 1 ? null : i;
}
function nHe(e) {
  function t(n) {
    const i = [];
    let o = n.getOriginalParent();
    for (; o != null; )
      i.push(o), o = o.getOriginalParent();
    return i;
  }
  let r = 0;
  for (let n = 0; n < e.length - 1; n++) {
    let i = t(e[n]), o = t(e[n + 1]);
    [i, o] = i.length > o.length ? [i, o] : [o, i], i.forEach((a) => {
      o.indexOf(a) === -1 && r++;
    });
  }
  return r;
}
function iHe(e, t) {
  switch (t) {
    case "left":
      return e.getLeftCols();
    case "right":
      return e.getRightCols();
    default:
      return e.getCenterCols();
  }
}
function oHe(e) {
  const { movingCols: t, draggingRight: r, xPosition: n, pinned: i, gos: o, columnModel: a, presentedColsService: s } = e;
  if (o.get("suppressMovableColumns") || t.some((C) => C.getColDef().suppressMovable))
    return [];
  const u = iHe(s, i), c = a.getCols(), d = u.filter((C) => Lc(t, C)), h = u.filter((C) => !Lc(t, C)), f = c.filter((C) => !Lc(t, C));
  let p = 0, g = n;
  if (r) {
    let C = 0;
    d.forEach((S) => C += S.getActualWidth()), g -= C;
  }
  if (g > 0) {
    for (let C = 0; C < h.length; C++) {
      const S = h[C];
      if (g -= S.getActualWidth(), g < 0)
        break;
      p++;
    }
    r && p++;
  }
  let v;
  if (p > 0) {
    const C = h[p - 1];
    v = f.indexOf(C) + 1;
  } else
    v = f.indexOf(h[0]), v === -1 && (v = 0);
  const m = [v], y = (C, S) => C - S;
  if (r) {
    let C = v + 1;
    const S = c.length - 1;
    for (; C <= S; )
      m.push(C), C++;
    m.sort(y);
  } else {
    let C = v;
    const S = c.length - 1;
    let b = c[C];
    for (; C <= S && u.indexOf(b) < 0; )
      C++, m.push(C), b = c[C];
    C = v - 1;
    const w = 0;
    for (; C >= w; )
      m.push(C), C--;
    m.sort(y).reverse();
  }
  return m;
}
function RI(e, t, r, n, i) {
  const o = i.getHeaderRowContainerCtrl(t).getViewport();
  return r && (e -= o.getBoundingClientRect().left), n.get("enableRtl") && (e = o.clientWidth - e), t == null && (e += i.get("center").getCenterViewportScrollLeft()), e;
}
var aHe = class extends Se {
  constructor(e) {
    super(), this.needToMoveLeft = !1, this.needToMoveRight = !1, this.lastMovedInfo = null, this.pinned = e, this.isCenterContainer = !ke(e);
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnMoveService = e.columnMoveService, this.dragAndDropService = e.dragAndDropService, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  getIconName() {
    return this.pinned ? "pinned" : "move";
  }
  onDragEnter(e) {
    const t = e.dragItem.columns;
    if (e.dragSource.type === 0)
      this.setColumnsVisible(t, !0, "uiColumnDragged");
    else {
      const n = e.dragItem.visibleState, i = (t || []).filter((o) => n[o.getId()]);
      this.setColumnsVisible(i, !0, "uiColumnDragged");
    }
    this.setColumnsPinned(t, this.pinned, "uiColumnDragged"), this.onDragging(e, !0, !0);
  }
  onDragLeave() {
    this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  setColumnsVisible(e, t, r) {
    if (e) {
      const n = e.filter((i) => !i.getColDef().lockVisible);
      this.columnModel.setColsVisible(n, t, r);
    }
  }
  setColumnsPinned(e, t, r) {
    if (e) {
      const n = e.filter((i) => !i.getColDef().lockPinned);
      this.columnModel.setColsPinned(n, t, r);
    }
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, !1, !0, !0), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  checkCenterForScrolling(e) {
    if (this.isCenterContainer) {
      const t = this.ctrlsService.get("center"), r = t.getCenterViewportScrollLeft(), n = r + t.getCenterWidth();
      this.gos.get("enableRtl") ? (this.needToMoveRight = e < r + 50, this.needToMoveLeft = e > n - 50) : (this.needToMoveLeft = e < r + 50, this.needToMoveRight = e > n - 50), this.needToMoveLeft || this.needToMoveRight ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
    }
  }
  onDragging(e = this.lastDraggingEvent, t = !1, r = !1, n = !1) {
    var u;
    if (n) {
      if (this.lastMovedInfo) {
        const { columns: c, toIndex: d } = this.lastMovedInfo;
        Bq(c, d, "uiColumnMoved", !0, this.columnMoveService);
      }
      return;
    }
    if (this.lastDraggingEvent = e, dr(e.hDirection))
      return;
    const i = RI(e.x, this.pinned, !1, this.gos, this.ctrlsService);
    t || this.checkCenterForScrolling(i);
    const o = this.normaliseDirection(e.hDirection), a = e.dragSource.type, s = ((u = e.dragSource.getDragItem().columns) == null ? void 0 : u.filter((c) => c.getColDef().lockPinned ? c.getPinned() == this.pinned : !0)) || [], l = EI({
      allMovingColumns: s,
      isFromHeader: a === 1,
      hDirection: o,
      xPosition: i,
      pinned: this.pinned,
      fromEnter: t,
      fakeEvent: r,
      gos: this.gos,
      columnModel: this.columnModel,
      columnMoveService: this.columnMoveService,
      presentedColsService: this.visibleColsService
    });
    l && (this.lastMovedInfo = l);
  }
  normaliseDirection(e) {
    if (this.gos.get("enableRtl"))
      switch (e) {
        case 0:
          return 1;
        case 1:
          return 0;
        default:
          Er(`Unknown direction ${e}`);
      }
    else
      return e;
  }
  ensureIntervalStarted() {
    this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100), this.dragAndDropService.setGhostIcon(this.needToMoveLeft ? "left" : "right", !0));
  }
  ensureIntervalCleared() {
    this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.dragAndDropService.setGhostIcon("move"));
  }
  moveInterval() {
    let e;
    this.intervalCount++, e = 10 + this.intervalCount * 5, e > 100 && (e = 100);
    let t = null;
    const r = this.gridBodyCon.getScrollFeature();
    if (this.needToMoveLeft ? t = r.scrollHorizontally(-e) : this.needToMoveRight && (t = r.scrollHorizontally(e)), t !== 0)
      this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
    else {
      this.failedMoveAttempts++;
      const i = this.lastDraggingEvent.dragItem.columns.filter((o) => !o.getColDef().lockPinned);
      if (i.length > 0 && (this.dragAndDropService.setGhostIcon("pinned"), this.failedMoveAttempts > 7)) {
        const o = this.needToMoveLeft ? "left" : "right";
        this.setColumnsPinned(i, o, "uiColumnDragged"), this.dragAndDropService.nudge();
      }
    }
  }
}, sHe = class extends Se {
  wireBeans(e) {
    this.dragAndDropService = e.dragAndDropService, this.columnModel = e.columnModel, this.ctrlsService = e.ctrlsService;
  }
  constructor(e, t) {
    super(), this.pinned = e, this.eContainer = t;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      switch (this.pinned) {
        case "left":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.left.getContainerElement()],
            [e.bottomLeft.getContainerElement()],
            [e.topLeft.getContainerElement()]
          ];
          break;
        case "right":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.right.getContainerElement()],
            [e.bottomRight.getContainerElement()],
            [e.topRight.getContainerElement()]
          ];
          break;
        default:
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.center.getViewportElement()],
            [e.bottomCenter.getViewportElement()],
            [e.topCenter.getViewportElement()]
          ];
          break;
      }
    }), this.moveColumnFeature = this.createManagedBean(new aHe(this.pinned)), this.bodyDropPivotTarget = this.createManagedBean(new tHe(this.pinned)), this.dragAndDropService.addDropTarget(this);
  }
  isInterestedIn(e) {
    return e === 1 || e === 0 && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(e) {
    return this.columnModel.isPivotMode() && e.dragSource.type === 0;
  }
  onDragEnter(e) {
    this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e);
  }
  onDragLeave(e) {
    this.currentDropListener.onDragLeave(e);
  }
  onDragging(e) {
    this.currentDropListener.onDragging(e);
  }
  onDragStop(e) {
    this.currentDropListener.onDragStop(e);
  }
}, lHe = class extends Se {
  wireBeans(e) {
    this.horizontalResizeService = e.horizontalResizeService, this.pinnedWidthService = e.pinnedWidthService, this.ctrlsService = e.ctrlsService, this.columnSizeService = e.columnSizeService, this.columnAutosizeService = e.columnAutosizeService;
  }
  constructor(e, t, r, n, i) {
    super(), this.pinned = e, this.column = t, this.eResize = r, this.comp = n, this.ctrl = i;
  }
  postConstruct() {
    const e = [];
    let t, r;
    const n = () => {
      if (ln(this.eResize, t), !t)
        return;
      const a = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      if (e.push(a), r) {
        const s = this.gos.get("skipHeaderOnAutoSize"), l = () => {
          this.columnAutosizeService.autoSizeColumn(this.column, "uiColumnResized", s);
        };
        this.eResize.addEventListener("dblclick", l);
        const u = new ql(this.eResize);
        u.addEventListener("doubleTap", l), e.push(() => {
          this.eResize.removeEventListener("dblclick", l), u.removeEventListener("doubleTap", l), u.destroy();
        });
      }
    }, i = () => {
      e.forEach((a) => a()), e.length = 0;
    }, o = () => {
      const a = this.column.isResizable(), s = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      (a !== t || s !== r) && (t = a, r = s, i(), n());
    };
    o(), this.addDestroyFunc(i), this.ctrl.addRefreshFunction(o);
  }
  onResizing(e, t) {
    const { column: r, lastResizeAmount: n, resizeStartWidth: i } = this, o = this.normaliseResizeAmount(t), a = i + o, s = [{ key: r, newWidth: a }];
    if (this.column.getPinned()) {
      const l = this.pinnedWidthService.getPinnedLeftWidth(), u = this.pinnedWidthService.getPinnedRightWidth(), c = rm(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (l + u + (o - n) > c)
        return;
    }
    this.lastResizeAmount = o, this.columnSizeService.setColumnWidths(s, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.toggleColumnResizing(!1);
  }
  onResizeStart(e) {
    this.resizeStartWidth = this.column.getActualWidth(), this.lastResizeAmount = 0, this.resizeWithShiftKey = e, this.toggleColumnResizing(!0);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(e) {
    let t = e;
    const r = this.pinned !== "left", n = this.pinned === "right";
    return this.gos.get("enableRtl") ? r && (t *= -1) : n && (t *= -1), t;
  }
}, uHe = class extends Se {
  constructor(e) {
    super(), this.cbSelectAllVisible = !1, this.processingEventFromCheckbox = !1, this.column = e;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  onSpaceKeyDown(e) {
    const t = this.cbSelectAll;
    t.isDisplayed() && !t.getGui().contains(this.gos.getActiveDomElement()) && (e.preventDefault(), t.setValue(!t.getValue()));
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(e) {
    this.headerCellCtrl = e, this.cbSelectAll = this.createManagedBean(new hI()), this.cbSelectAll.addCssClass("ag-header-select-all"), Na(this.cbSelectAll.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedEventListeners({
      newColumnsLoaded: this.onNewColumnsLoaded.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      selectionChanged: this.onSelectionChanged.bind(this),
      paginationChanged: this.onSelectionChanged.bind(this),
      modelUpdated: this.onModelChanged.bind(this)
    }), this.addManagedListeners(this.cbSelectAll, { fieldValueChanged: this.onCbSelectAll.bind(this) }), iI(this.cbSelectAll.getGui(), !0), this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
  }
  onNewColumnsLoaded() {
    this.showOrHideSelectAll();
  }
  onDisplayedColumnsChanged() {
    this.isAlive() && this.showOrHideSelectAll();
  }
  showOrHideSelectAll() {
    this.cbSelectAllVisible = this.isCheckboxSelection(), this.cbSelectAll.setDisplayed(this.cbSelectAllVisible, { skipAriaHidden: !0 }), this.cbSelectAllVisible && (this.checkRightRowModelType("selectAllCheckbox"), this.checkSelectionType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel();
  }
  onModelChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  onSelectionChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  updateStateOfCheckbox() {
    if (this.processingEventFromCheckbox)
      return;
    this.processingEventFromCheckbox = !0;
    const e = this.selectionService.getSelectAllState(this.isFilteredOnly(), this.isCurrentPageOnly());
    this.cbSelectAll.setValue(e);
    const t = this.selectionService.hasNodesToSelect(
      this.isFilteredOnly(),
      this.isCurrentPageOnly()
    );
    this.cbSelectAll.setDisabled(!t), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
  }
  refreshSelectAllLabel() {
    const e = this.localeService.getLocaleTextFunc(), r = this.cbSelectAll.getValue() ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked"), n = e("ariaRowSelectAll", "Press Space to toggle all rows selection");
    this.cbSelectAllVisible ? this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${n} (${r})`) : this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null), this.cbSelectAll.setInputAriaLabel(`${n} (${r})`), this.headerCellCtrl.announceAriaDescription();
  }
  checkSelectionType(e) {
    return this.gos.get("rowSelection") === "multiple" ? !0 : (Te(`${e} is only available if using 'multiple' rowSelection.`), !1);
  }
  checkRightRowModelType(e) {
    const t = this.rowModel.getType();
    return t === "clientSide" || t === "serverSide" ? !0 : (Te(
      `${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${t}.`
    ), !1);
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox || !this.cbSelectAllVisible)
      return;
    const e = this.cbSelectAll.getValue(), t = this.isFilteredOnly(), r = this.isCurrentPageOnly();
    let n = "uiSelectAll";
    r ? n = "uiSelectAllCurrentPage" : t && (n = "uiSelectAllFiltered");
    const i = {
      source: n,
      justFiltered: t,
      justCurrentPage: r
    };
    e ? this.selectionService.selectAllRowNodes(i) : this.selectionService.deselectAllRowNodes(i);
  }
  isCheckboxSelection() {
    let e = this.column.getColDef().headerCheckboxSelection;
    if (typeof e == "function") {
      const t = e, r = this.gos.addGridCommonParams({
        column: this.column,
        colDef: this.column.getColDef()
      });
      e = t(r);
    }
    return e ? this.checkRightRowModelType("headerCheckboxSelection") && this.checkSelectionType("headerCheckboxSelection") : !1;
  }
  isFilteredOnly() {
    return !!this.column.getColDef().headerCheckboxSelectionFilteredOnly;
  }
  isCurrentPageOnly() {
    return !!this.column.getColDef().headerCheckboxSelectionCurrentPageOnly;
  }
}, cHe = class extends Bw {
  constructor(e, t, r) {
    super(e, t, r), this.refreshFunctions = [], this.userHeaderClasses = /* @__PURE__ */ new Set(), this.ariaDescriptionProperties = /* @__PURE__ */ new Map(), this.column = e;
  }
  setComp(e, t, r, n) {
    this.comp = e, this.setGui(t), this.updateState(), this.setupWidth(), this.setupMovingCss(), this.setupMenuClass(), this.setupSortableClass(), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight(n), this.addColumnHoverListener(), this.setupFilterClass(), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(), this.setupSelectAll(), this.setupUserComp(), this.refreshAria(), this.resizeFeature = this.createManagedBean(
      new lHe(this.getPinned(), this.column, r, e, this)
    ), this.createManagedBean(new SI([this.column], t)), this.createManagedBean(new CI(this.column, t, this.beans)), this.createManagedBean(
      new gd(t, {
        shouldStopEventPropagation: (i) => this.shouldStopEventPropagation(i),
        onTabKeyDown: () => null,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addResizeAndMoveKeyboardListeners(), this.addManagedPropertyListeners(
      ["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader"],
      this.refresh.bind(this)
    ), this.addManagedListeners(this.column, { colDefChanged: this.refresh.bind(this) }), this.addManagedEventListeners({
      columnValueChanged: this.onColumnValueChanged.bind(this),
      columnRowGroupChanged: this.onColumnRowGroupChanged.bind(this),
      columnPivotChanged: this.onColumnPivotChanged.bind(this),
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    });
  }
  resizeHeader(e, t) {
    if (!this.column.isResizable())
      return;
    const r = this.column.getActualWidth(), n = this.column.getMinWidth(), i = this.column.getMaxWidth(), o = Math.min(Math.max(r + e, n), i);
    this.beans.columnSizeService.setColumnWidths(
      [{ key: this.column, newWidth: o }],
      t,
      !0,
      "uiColumnResized"
    );
  }
  moveHeader(e) {
    const { eGui: t, column: r, gos: n, ctrlsService: i } = this, o = this.getPinned(), a = t.getBoundingClientRect().left, s = r.getActualWidth(), l = n.get("enableRtl"), c = RI(e === 0 !== l ? a - 20 : a + s + 20, o, !0, n, i);
    EI({
      allMovingColumns: [r],
      isFromHeader: !0,
      hDirection: e,
      xPosition: c,
      pinned: o,
      fromEnter: !1,
      fakeEvent: !1,
      gos: n,
      columnModel: this.beans.columnModel,
      columnMoveService: this.beans.columnMoveService,
      presentedColsService: this.beans.visibleColsService
    }), i.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(r, "auto");
  }
  setupUserComp() {
    const e = this.lookupUserCompDetails();
    this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setUserCompDetails(e);
  }
  lookupUserCompDetails() {
    const e = this.createParams(), t = this.column.getColDef();
    return this.userComponentFactory.getHeaderCompDetails(t, e);
  }
  createParams() {
    return this.gos.addGridCommonParams({
      column: this.column,
      displayName: this.displayName,
      enableSorting: this.column.isSortable(),
      enableMenu: this.menuEnabled,
      enableFilterButton: this.openFilterEnabled && this.menuService.isHeaderFilterButtonEnabled(this.column),
      enableFilterIcon: !this.openFilterEnabled || this.menuService.isLegacyMenuEnabled(),
      showColumnMenu: (t) => {
        this.menuService.showColumnMenu({
          column: this.column,
          buttonElement: t,
          positionBy: "button"
        });
      },
      showColumnMenuAfterMouseClick: (t) => {
        this.menuService.showColumnMenu({
          column: this.column,
          mouseEvent: t,
          positionBy: "mouse"
        });
      },
      showFilter: (t) => {
        this.menuService.showFilterMenu({
          column: this.column,
          buttonElement: t,
          containerType: "columnFilter",
          positionBy: "button"
        });
      },
      progressSort: (t) => {
        this.beans.sortController.progressSort(this.column, !!t, "uiColumnSorted");
      },
      setSort: (t, r) => {
        this.beans.sortController.setSortForColumn(this.column, t, !!r, "uiColumnSorted");
      },
      eGridHeader: this.getGui(),
      setTooltip: (t, r) => {
        this.setupTooltip(t, r);
      }
    });
  }
  setupSelectAll() {
    this.selectAllFeature = this.createManagedBean(new uHe(this.column)), this.selectAllFeature.setComp(this);
  }
  getSelectAllGui() {
    return this.selectAllFeature.getCheckboxGui();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e), e.key === pe.SPACE && this.selectAllFeature.onSpaceKeyDown(e), e.key === pe.ENTER && this.onEnterKeyDown(e), e.key === pe.DOWN && e.altKey && this.showMenuOnKeyPress(e, !1);
  }
  onEnterKeyDown(e) {
    if (e.ctrlKey || e.metaKey)
      this.showMenuOnKeyPress(e, !0);
    else if (this.sortable) {
      const t = e.shiftKey;
      this.beans.sortController.progressSort(this.column, t, "uiColumnSorted");
    }
  }
  showMenuOnKeyPress(e, t) {
    const r = this.comp.getUserCompInstance();
    !r || !(r instanceof uP) || r.onMenuKeyboardShortcut(t) && e.preventDefault();
  }
  onFocusIn(e) {
    if (!this.getGui().contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.focusService.setFocusedHeader(t, this.column), this.announceAriaDescription();
    }
    this.focusService.isKeyboardMode() && this.setActiveHeader(!0);
  }
  onFocusOut(e) {
    this.getGui().contains(e.relatedTarget) || this.setActiveHeader(!1);
  }
  setupTooltip(e, t) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const r = this.gos.get("tooltipShowMode") === "whenTruncated", n = this.eGui, i = this.column.getColDef();
    !t && r && !i.headerComponent && (t = () => {
      const s = n.querySelector(".ag-header-cell-text");
      return s ? s.scrollWidth > s.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getGui: () => n,
      getLocation: () => "header",
      getTooltipValue: () => e ?? this.column.getColDef().headerTooltip,
      shouldDisplayTooltip: t
    }, a = this.createManagedBean(new If(o));
    this.refreshFunctions.push(() => a.refreshToolTip());
  }
  setupClassesFromColDef() {
    const e = () => {
      const t = this.column.getColDef(), r = Dq(t, this.gos, this.column, null), n = this.userHeaderClasses;
      this.userHeaderClasses = new Set(r), r.forEach((i) => {
        n.has(i) ? n.delete(i) : this.comp.addOrRemoveCssClass(i, !0);
      }), n.forEach((i) => this.comp.addOrRemoveCssClass(i, !1));
    };
    this.refreshFunctions.push(e), e();
  }
  setDragSource(e) {
    if (this.dragSourceElement = e, this.removeDragSource(), !e || !this.draggable)
      return;
    const { column: t, beans: r, displayName: n, dragAndDropService: i, gos: o } = this, { columnModel: a } = r;
    let s = !this.gos.get("suppressDragLeaveHidesColumns");
    const l = this.dragSource = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => s ? "hide" : "notAllowed",
      getDragItem: () => this.createDragItem(t),
      dragItemName: n,
      onDragStarted: () => {
        s = !o.get("suppressDragLeaveHidesColumns"), t.setMoving(!0, "uiColumnMoved");
      },
      onDragStopped: () => t.setMoving(!1, "uiColumnMoved"),
      onGridEnter: (u) => {
        var c;
        if (s) {
          const d = ((c = u == null ? void 0 : u.columns) == null ? void 0 : c.filter((h) => !h.getColDef().lockVisible)) || [];
          a.setColsVisible(d, !0, "uiColumnMoved");
        }
      },
      onGridExit: (u) => {
        var c;
        if (s) {
          const d = ((c = u == null ? void 0 : u.columns) == null ? void 0 : c.filter((h) => !h.getColDef().lockVisible)) || [];
          a.setColsVisible(d, !1, "uiColumnMoved");
        }
      }
    };
    i.addDragSource(l, !0);
  }
  createDragItem(e) {
    const t = {};
    return t[e.getId()] = e.isVisible(), {
      columns: [e],
      visibleState: t
    };
  }
  updateState() {
    this.menuEnabled = this.menuService.isColumnMenuInHeaderEnabled(this.column), this.openFilterEnabled = this.menuService.isFilterMenuInHeaderEnabled(this.column), this.sortable = this.column.isSortable(), this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
  }
  addRefreshFunction(e) {
    this.refreshFunctions.push(e);
  }
  refresh() {
    this.updateState(), this.refreshHeaderComp(), this.refreshAria(), this.refreshFunctions.forEach((e) => e());
  }
  refreshHeaderComp() {
    const e = this.lookupUserCompDetails();
    (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == e.componentClass ? this.attemptHeaderCompRefresh(e.params) : !1) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(e);
  }
  attemptHeaderCompRefresh(e) {
    const t = this.comp.getUserCompInstance();
    return !t || !t.refresh ? !1 : t.refresh(e);
  }
  calculateDisplayName() {
    return this.beans.columnNameService.getDisplayNameForColumn(this.column, "header", !0);
  }
  checkDisplayName() {
    this.displayName !== this.calculateDisplayName() && this.refresh();
  }
  workOutDraggable() {
    const e = this.column.getColDef();
    return !!(!this.gos.get("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot;
  }
  onColumnRowGroupChanged() {
    this.checkDisplayName();
  }
  onColumnPivotChanged() {
    this.checkDisplayName();
  }
  onColumnValueChanged() {
    this.checkDisplayName();
  }
  setupWidth() {
    const e = () => {
      const t = this.column.getActualWidth();
      this.comp.setWidth(`${t}px`);
    };
    this.addManagedListeners(this.column, { widthChanged: e }), e();
  }
  setupMovingCss() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    };
    this.addManagedListeners(this.column, { movingChanged: e }), e();
  }
  setupMenuClass() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
    };
    this.addManagedListeners(this.column, { menuVisibleChanged: e }), e();
  }
  setupSortableClass() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
    };
    e(), this.addRefreshFunction(e), this.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
  }
  setupFilterClass() {
    const e = () => {
      const t = this.column.isFilterActive();
      this.comp.addOrRemoveCssClass("ag-header-cell-filtered", t), this.refreshAria();
    };
    this.addManagedListeners(this.column, { filterActiveChanged: e }), e();
  }
  setupWrapTextClass() {
    const e = () => {
      const t = !!this.column.getColDef().wrapHeaderText;
      this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", t);
    };
    e(), this.addRefreshFunction(e);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged(), this.isAlive() && this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui: e, column: t, comp: r, beans: n } = this;
    if (!t.isSpanHeaderHeight()) {
      e.style.removeProperty("top"), e.style.removeProperty("height"), r.addOrRemoveCssClass("ag-header-span-height", !1), r.addOrRemoveCssClass("ag-header-span-total", !1);
      return;
    }
    const { numberOfParents: i, isSpanningTotal: o } = this.column.getColumnGroupPaddingInfo();
    r.addOrRemoveCssClass("ag-header-span-height", i > 0);
    const { columnModel: a } = n, s = a.getColumnHeaderRowHeight();
    if (i === 0) {
      r.addOrRemoveCssClass("ag-header-span-total", !1), e.style.setProperty("top", "0px"), e.style.setProperty("height", `${s}px`);
      return;
    }
    r.addOrRemoveCssClass("ag-header-span-total", o);
    const u = a.isPivotMode() ? a.getPivotGroupHeaderHeight() : a.getGroupHeaderHeight(), c = i * u;
    e.style.setProperty("top", `${-c}px`), e.style.setProperty("height", `${s + c}px`);
  }
  setupAutoHeight(e) {
    const { columnModel: t, resizeObserverService: r } = this.beans, n = (u) => {
      if (!this.isAlive())
        return;
      const { paddingTop: c, paddingBottom: d, borderBottomWidth: h, borderTopWidth: f } = pd(this.getGui()), p = c + d + h + f, v = e.offsetHeight + p;
      if (u < 5) {
        const m = this.beans.gos.getDocument(), y = !m || !m.contains(e), C = v == 0;
        if (y || C) {
          window.setTimeout(() => n(u + 1), 0);
          return;
        }
      }
      t.setColHeaderHeight(this.column, v);
    };
    let i = !1, o;
    const a = () => {
      const u = this.column.isAutoHeaderHeight();
      u && !i && s(), !u && i && l();
    }, s = () => {
      i = !0, n(0), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !0), o = r.observeResize(e, () => n(0));
    }, l = () => {
      i = !1, o && o(), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !1), o = void 0;
    };
    a(), this.addDestroyFunc(() => l()), this.addManagedListeners(this.column, { widthChanged: () => i && n(0) }), this.addManagedEventListeners({
      sortChanged: () => {
        i && window.setTimeout(() => n(0));
      }
    }), this.addRefreshFunction(a);
  }
  refreshAriaSort() {
    if (this.sortable) {
      const e = this.localeService.getLocaleTextFunc(), t = this.beans.sortController.getDisplaySortForColumn(this.column) || null;
      this.comp.setAriaSort(TBe(t)), this.setAriaDescriptionProperty("sort", e("ariaSortableColumn", "Press ENTER to sort"));
    } else
      this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null);
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else
      this.setAriaDescriptionProperty("menu", null);
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !this.menuService.isLegacyMenuEnabled()) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty(
        "filterButton",
        e("ariaFilterColumn", "Press CTRL ENTER to open filter")
      );
    } else
      this.setAriaDescriptionProperty("filterButton", null);
  }
  refreshAriaFiltered() {
    const e = this.localeService.getLocaleTextFunc();
    this.column.isFilterActive() ? this.setAriaDescriptionProperty("filter", e("ariaColumnFiltered", "Column Filtered")) : this.setAriaDescriptionProperty("filter", null);
  }
  setAriaDescriptionProperty(e, t) {
    t != null ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e);
  }
  announceAriaDescription() {
    if (!this.eGui.contains(this.beans.gos.getActiveDomElement()))
      return;
    const e = Array.from(this.ariaDescriptionProperties.keys()).sort((t, r) => t === "filter" ? -1 : r.charCodeAt(0) - t.charCodeAt(0)).map((t) => this.ariaDescriptionProperties.get(t)).join(". ");
    this.beans.ariaAnnouncementService.announceValue(e);
  }
  refreshAria() {
    this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaFilterButton(), this.refreshAriaFiltered();
  }
  addColumnHoverListener() {
    const e = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const t = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", t);
    };
    this.addManagedEventListeners({ columnHoverChanged: e }), e();
  }
  getColId() {
    return this.column.getColId();
  }
  addActiveHeaderMouseListeners() {
    const e = (n) => this.handleMouseOverChange(n.type === "mouseenter"), t = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column), r = (n) => this.handleContextMenuMouseEvent(n, void 0, this.column);
    this.addManagedListeners(this.getGui(), {
      mouseenter: e,
      mouseleave: e,
      click: t,
      contextmenu: r
    });
  }
  handleMouseOverChange(e) {
    this.setActiveHeader(e);
    const r = {
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column
    };
    this.eventService.dispatchEvent(r);
  }
  setActiveHeader(e) {
    this.comp.addOrRemoveCssClass("ag-header-active", e);
  }
  getAnchorElementForMenu(e) {
    const t = this.comp.getUserCompInstance();
    return t instanceof uP ? t.getAnchorElementForMenu(e) : this.getGui();
  }
  destroy() {
    super.destroy(), this.refreshFunctions = null, this.selectAllFeature = null, this.dragSourceElement = null, this.userCompDetails = null, this.userHeaderClasses = null, this.ariaDescriptionProperties = null;
  }
}, dHe = class extends Se {
  wireBeans(e) {
    this.horizontalResizeService = e.horizontalResizeService, this.autoWidthCalculator = e.autoWidthCalculator, this.visibleColsService = e.visibleColsService, this.columnSizeService = e.columnSizeService, this.columnAutosizeService = e.columnAutosizeService;
  }
  constructor(e, t, r, n) {
    super(), this.eResize = t, this.comp = e, this.pinned = r, this.columnGroup = n;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(!1);
      return;
    }
    const e = this.horizontalResizeService.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, !1),
      onResizeEnd: this.onResizing.bind(this, !0)
    });
    if (this.addDestroyFunc(e), !this.gos.get("suppressAutoSize")) {
      const t = this.gos.get("skipHeaderOnAutoSize");
      this.eResize.addEventListener("dblclick", () => {
        const r = [];
        this.columnGroup.getDisplayedLeafColumns().forEach((i) => {
          i.getColDef().suppressAutoSize || r.push(i.getColId());
        }), r.length > 0 && this.columnAutosizeService.autoSizeCols({
          colKeys: r,
          skipHeader: t,
          stopAtGroup: this.columnGroup,
          source: "uiColumnResized"
        }), this.resizeLeafColumnsToFit("uiColumnResized");
      });
    }
  }
  onResizeStart(e) {
    const t = this.getInitialValues(e);
    this.storeLocalValues(t), this.toggleColumnResizing(!0);
  }
  onResizing(e, t, r = "uiColumnResized") {
    const n = this.normaliseDragChange(t), i = this.resizeStartWidth + n;
    this.resizeColumnsFromLocalValues(i, r, e);
  }
  getInitialValues(e) {
    const t = this.getColumnsToResize(), r = this.getInitialSizeOfColumns(t), n = this.getSizeRatiosOfColumns(t, r), i = {
      columnsToResize: t,
      resizeStartWidth: r,
      resizeRatios: n
    };
    let o = null;
    if (e && (o = this.visibleColsService.getGroupAtDirection(this.columnGroup, "After")), o) {
      const a = o.getDisplayedLeafColumns(), s = i.groupAfterColumns = a.filter(
        (u) => u.isResizable()
      ), l = i.groupAfterStartWidth = this.getInitialSizeOfColumns(s);
      i.groupAfterRatios = this.getSizeRatiosOfColumns(s, l);
    } else
      i.groupAfterColumns = void 0, i.groupAfterStartWidth = void 0, i.groupAfterRatios = void 0;
    return i;
  }
  storeLocalValues(e) {
    const {
      columnsToResize: t,
      resizeStartWidth: r,
      resizeRatios: n,
      groupAfterColumns: i,
      groupAfterStartWidth: o,
      groupAfterRatios: a
    } = e;
    this.resizeCols = t, this.resizeStartWidth = r, this.resizeRatios = n, this.resizeTakeFromCols = i, this.resizeTakeFromStartWidth = o, this.resizeTakeFromRatios = a;
  }
  clearLocalValues() {
    this.resizeCols = void 0, this.resizeRatios = void 0, this.resizeTakeFromCols = void 0, this.resizeTakeFromRatios = void 0;
  }
  resizeLeafColumnsToFit(e) {
    const t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup), r = this.getInitialValues();
    t > r.resizeStartWidth && this.resizeColumns(r, t, e, !0);
  }
  resizeColumnsFromLocalValues(e, t, r = !0) {
    if (!this.resizeCols || !this.resizeRatios)
      return;
    const n = {
      columnsToResize: this.resizeCols,
      resizeStartWidth: this.resizeStartWidth,
      resizeRatios: this.resizeRatios,
      groupAfterColumns: this.resizeTakeFromCols ?? void 0,
      groupAfterStartWidth: this.resizeTakeFromStartWidth ?? void 0,
      groupAfterRatios: this.resizeTakeFromRatios ?? void 0
    };
    this.resizeColumns(n, e, t, r);
  }
  resizeColumns(e, t, r, n = !0) {
    const {
      columnsToResize: i,
      resizeStartWidth: o,
      resizeRatios: a,
      groupAfterColumns: s,
      groupAfterStartWidth: l,
      groupAfterRatios: u
    } = e, c = [];
    if (c.push({
      columns: i,
      ratios: a,
      width: t
    }), s) {
      const d = t - o;
      c.push({
        columns: s,
        ratios: u,
        width: l - d
      });
    }
    this.columnSizeService.resizeColumnSets({
      resizeSets: c,
      finished: n,
      source: r
    }), n && this.toggleColumnResizing(!1);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  getColumnsToResize() {
    return this.columnGroup.getDisplayedLeafColumns().filter((t) => t.isResizable());
  }
  getInitialSizeOfColumns(e) {
    return e.reduce((t, r) => t + r.getActualWidth(), 0);
  }
  getSizeRatiosOfColumns(e, t) {
    return e.map((r) => r.getActualWidth() / t);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(e) {
    let t = e;
    return this.gos.get("enableRtl") ? this.pinned !== "left" && (t *= -1) : this.pinned === "right" && (t *= -1), t;
  }
  destroy() {
    super.destroy(), this.clearLocalValues();
  }
}, hHe = class extends Se {
  constructor(e, t) {
    super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e;
  }
  postConstruct() {
    this.addListenersToChildrenColumns(), this.addManagedListeners(this.columnGroup, {
      displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this)
    }), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const e = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      t.addEventListener("widthChanged", e), t.addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
        t.removeEventListener("widthChanged", e), t.removeEventListener("visibleChanged", e);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((e) => e()), this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns(), this.onWidthChanged();
  }
  onWidthChanged() {
    const e = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${e}px`), this.comp.addOrRemoveCssClass("ag-hidden", e === 0);
  }
}, fHe = class extends Bw {
  constructor(e, t, r) {
    super(e, t, r), this.onSuppressColMoveChange = () => {
      if (!this.isAlive() || this.isSuppressMoving())
        this.removeDragSource();
      else if (!this.dragSource) {
        const n = this.getGui();
        this.setDragSource(n);
      }
    }, this.column = e;
  }
  setComp(e, t, r) {
    this.comp = e, this.setGui(t), this.displayName = this.beans.columnNameService.getDisplayNameForColumnGroup(this.column, "header"), this.addClasses(), this.setupMovingCss(), this.setupExpandable(), this.setupTooltip(), this.addDestroyFunc(() => {
      this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    }), this.setupUserComp(), this.addHeaderMouseListeners();
    const n = this.getParentRowCtrl().getPinned(), i = this.column.getProvidedColumnGroup().getLeafColumns();
    this.createManagedBean(new SI(i, t)), this.createManagedBean(new CI(this.column, t, this.beans)), this.createManagedBean(new hHe(e, this.column)), this.resizeFeature = this.createManagedBean(new dHe(e, r, n, this.column)), this.createManagedBean(
      new gd(t, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: () => {
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    ), this.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange), this.addResizeAndMoveKeyboardListeners();
  }
  resizeHeader(e, t) {
    if (!this.resizeFeature)
      return;
    const r = this.resizeFeature.getInitialValues(t);
    this.resizeFeature.resizeColumns(
      r,
      r.resizeStartWidth + e,
      "uiColumnResized",
      !0
    );
  }
  moveHeader(e) {
    const { beans: t, eGui: r, column: n, gos: i, ctrlsService: o } = this, a = i.get("enableRtl"), s = e === 0, l = this.getPinned(), u = r.getBoundingClientRect(), c = u.left, d = u.width, h = RI(s !== a ? c - 20 : c + d + 20, l, !0, i, o), f = n.getGroupId(), p = this.focusService.getFocusedHeader();
    EI({
      allMovingColumns: this.column.getLeafColumns(),
      isFromHeader: !0,
      hDirection: e,
      xPosition: h,
      pinned: l,
      fromEnter: !1,
      fakeEvent: !1,
      gos: i,
      columnModel: t.columnModel,
      columnMoveService: t.columnMoveService,
      presentedColsService: t.visibleColsService
    });
    const g = n.getDisplayedLeafColumns(), v = s ? g[0] : gr(g);
    this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(v, "auto"), !this.isAlive() && p && this.restoreFocus(f, n, p);
  }
  restoreFocus(e, t, r) {
    const n = t.getLeafColumns();
    if (!n.length)
      return;
    const i = n[0].getParent();
    if (!i)
      return;
    const o = this.findGroupWidthId(i, e);
    o && this.focusService.focusHeaderPosition({
      headerPosition: {
        ...r,
        column: o
      }
    });
  }
  findGroupWidthId(e, t) {
    for (; e; ) {
      if (e.getGroupId() === t)
        return e;
      e = e.getParent();
    }
    return null;
  }
  resizeLeafColumnsToFit(e) {
    this.resizeFeature && this.resizeFeature.resizeLeafColumnsToFit(e);
  }
  setupUserComp() {
    const e = this.gos.addGridCommonParams({
      displayName: this.displayName,
      columnGroup: this.column,
      setExpanded: (r) => {
        this.beans.columnModel.setColumnGroupOpened(
          this.column.getProvidedColumnGroup(),
          r,
          "gridInitializing"
        );
      },
      setTooltip: (r, n) => {
        this.setupTooltip(r, n);
      }
    }), t = this.userComponentFactory.getHeaderGroupCompDetails(e);
    this.comp.setUserCompDetails(t);
  }
  addHeaderMouseListeners() {
    const e = (n) => this.handleMouseOverChange(n.type === "mouseenter"), t = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup()), r = (n) => this.handleContextMenuMouseEvent(n, void 0, this.column.getProvidedColumnGroup());
    this.addManagedListeners(this.getGui(), {
      mouseenter: e,
      mouseleave: e,
      click: t,
      contextmenu: r
    });
  }
  handleMouseOverChange(e) {
    const r = {
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column.getProvidedColumnGroup()
    };
    this.eventService.dispatchEvent(r);
  }
  setupTooltip(e, t) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const r = this.column.getColGroupDef(), n = this.gos.get("tooltipShowMode") === "whenTruncated", i = this.eGui;
    !t && n && !(r != null && r.headerGroupComponent) && (t = () => {
      const a = i.querySelector(".ag-header-group-text");
      return a ? a.scrollWidth > a.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getGui: () => i,
      getLocation: () => "headerGroup",
      getTooltipValue: () => e ?? (r && r.headerTooltip),
      shouldDisplayTooltip: t
    };
    r && (o.getColDef = () => r), this.createManagedBean(new If(o));
  }
  setupExpandable() {
    const e = this.column.getProvidedColumnGroup();
    this.refreshExpanded();
    const t = this.refreshExpanded.bind(this);
    this.addManagedListeners(e, {
      expandedChanged: t,
      expandableChanged: t
    });
  }
  refreshExpanded() {
    const { column: e } = this;
    this.expandable = e.isExpandable();
    const t = e.isExpanded();
    this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0);
  }
  getColId() {
    return this.column.getUniqueId();
  }
  addClasses() {
    const e = this.column.getColGroupDef(), t = Dq(e, this.gos, null, this.column);
    this.column.isPadding() ? (t.push("ag-header-group-cell-no-group"), this.column.getLeafColumns().every((n) => n.isSpanHeaderHeight()) && t.push("ag-header-span-height")) : t.push("ag-header-group-cell-with-group"), t.forEach((r) => this.comp.addOrRemoveCssClass(r, !0));
  }
  setupMovingCss() {
    const t = this.column.getProvidedColumnGroup().getLeafColumns(), r = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    t.forEach((n) => {
      this.addManagedListeners(n, { movingChanged: r });
    }), r();
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.beans.focusService.setFocusedHeader(t, this.column);
    }
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    if (!(!this.expandable || !t) && e.key === pe.ENTER) {
      const r = this.column, n = !r.isExpanded();
      this.beans.columnModel.setColumnGroupOpened(
        r.getProvidedColumnGroup(),
        n,
        "uiColumnExpanded"
      );
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(e) {
    if (!this.isAlive() || this.isSuppressMoving() || (this.removeDragSource(), !e))
      return;
    const { beans: t, column: r, displayName: n, gos: i, dragAndDropService: o } = this, { columnModel: a } = t, s = r.getProvidedColumnGroup().getLeafColumns();
    let l = !i.get("suppressDragLeaveHidesColumns");
    const u = this.dragSource = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => l ? "hide" : "notAllowed",
      dragItemName: n,
      // we add in the original group leaf columns, so we move both visible and non-visible items
      getDragItem: () => this.getDragItemForGroup(r),
      onDragStarted: () => {
        l = !i.get("suppressDragLeaveHidesColumns"), s.forEach((c) => c.setMoving(!0, "uiColumnDragged"));
      },
      onDragStopped: () => s.forEach((c) => c.setMoving(!1, "uiColumnDragged")),
      onGridEnter: (c) => {
        var d;
        if (l) {
          const h = ((d = c == null ? void 0 : c.columns) == null ? void 0 : d.filter((f) => !f.getColDef().lockVisible)) || [];
          a.setColsVisible(h, !0, "uiColumnMoved");
        }
      },
      onGridExit: (c) => {
        var d;
        if (l) {
          const h = ((d = c == null ? void 0 : c.columns) == null ? void 0 : d.filter((f) => !f.getColDef().lockVisible)) || [];
          a.setColsVisible(h, !1, "uiColumnMoved");
        }
      }
    };
    o.addDragSource(u, !0);
  }
  // when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,
  // and in the order they are currently in the screen.
  getDragItemForGroup(e) {
    const t = e.getProvidedColumnGroup().getLeafColumns(), r = {};
    t.forEach((i) => r[i.getId()] = i.isVisible());
    const n = [];
    return this.beans.visibleColsService.getAllCols().forEach((i) => {
      t.indexOf(i) >= 0 && (n.push(i), _i(t, i));
    }), t.forEach((i) => n.push(i)), {
      columns: n,
      visibleState: r
    };
  }
  isSuppressMoving() {
    let e = !1;
    return this.column.getLeafColumns().forEach((r) => {
      (r.getColDef().suppressMovable || r.getColDef().lockPosition) && (e = !0);
    }), e || this.gos.get("suppressMovableColumns");
  }
}, pHe = 0, TE = class extends Se {
  constructor(e, t, r) {
    super(), this.instanceId = pHe++, this.rowIndex = e, this.pinned = t, this.type = r;
    const n = r == "group" ? "ag-header-row-column-group" : r == "filter" ? "ag-header-row-column-filter" : "ag-header-row-column";
    this.headerRowClass = `ag-header-row ${n}`;
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.isPrintLayout = this.gos.isDomLayout("print"), this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  getInstanceId() {
    return this.instanceId;
  }
  /** Checks that every header cell that is currently visible has been rendered.
   * Can only be false under some circumstances when using React
   */
  areCellsRendered() {
    return this.comp ? this.getHeaderCellCtrls().every((e) => e.getGui() != null) : !1;
  }
  /**
   *
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */
  setComp(e, t = !0) {
    this.comp = e, t && (this.onRowHeightChanged(), this.onVirtualColumnsChanged()), this.setWidth(), this.addEventListeners();
  }
  getHeaderRowClass() {
    return this.headerRowClass;
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners() {
    const e = this.onRowHeightChanged.bind(this);
    this.addManagedEventListeners({
      columnResized: this.onColumnResized.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: (t) => this.onVirtualColumnsChanged(t.afterScroll),
      columnHeaderHeightChanged: e,
      gridStylesChanged: e,
      advancedFilterEnabledChanged: e
    }), this.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this)), this.addManagedPropertyListener("ensureDomOrder", (t) => this.isEnsureDomOrder = t.currentValue), this.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      e
    );
  }
  getHeaderCellCtrl(e) {
    if (this.headerCellCtrls)
      return w0(this.headerCellCtrls).find((t) => t.getColumnGroupChild() === e);
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = this.gos.isDomLayout("print"), this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged();
  }
  getType() {
    return this.type;
  }
  onColumnResized() {
    this.setWidth();
  }
  setWidth() {
    const e = this.getWidthForRow();
    this.comp.setWidth(`${e}px`);
  }
  getWidthForRow() {
    const { visibleColsService: e } = this.beans;
    return this.isPrintLayout ? this.pinned != null ? 0 : e.getContainerWidth("right") + e.getContainerWidth("left") + e.getContainerWidth(null) : e.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    const { topOffset: e, rowHeight: t } = this.getTopAndHeight();
    this.comp.setTop(e + "px"), this.comp.setHeight(t + "px");
  }
  getTopAndHeight() {
    const { columnModel: e, filterManager: t } = this.beans;
    let r = e.getHeaderRowCount();
    const n = [];
    let i = 0;
    t != null && t.hasFloatingFilters() && (r++, i = 1);
    const o = e.getColumnGroupHeaderRowHeight(), a = e.getColumnHeaderRowHeight(), s = 1 + i, l = r - s;
    for (let d = 0; d < l; d++)
      n.push(o);
    n.push(a);
    for (let d = 0; d < i; d++)
      n.push(e.getFloatingFiltersHeight());
    let u = 0;
    for (let d = 0; d < this.rowIndex; d++)
      u += n[d];
    const c = n[this.rowIndex];
    return { topOffset: u, rowHeight: c };
  }
  getPinned() {
    return this.pinned;
  }
  getRowIndex() {
    return this.rowIndex;
  }
  onVirtualColumnsChanged(e = !1) {
    const t = this.getHeaderCtrls(), r = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(t, r, e);
  }
  getHeaderCtrls() {
    const e = this.headerCellCtrls;
    this.headerCellCtrls = /* @__PURE__ */ new Map();
    const t = this.getColumnsInViewport();
    for (const n of t)
      this.recycleAndCreateHeaderCtrls(n, e);
    const r = (n) => {
      const { focusService: i, visibleColsService: o } = this.beans;
      return i.isHeaderWrapperFocused(n) ? o.isVisible(n.getColumnGroupChild()) : !1;
    };
    if (e)
      for (const [n, i] of e)
        r(i) ? this.headerCellCtrls.set(n, i) : this.destroyBean(i);
    return this.getHeaderCellCtrls();
  }
  getHeaderCellCtrls() {
    var e;
    return Array.from(((e = this.headerCellCtrls) == null ? void 0 : e.values()) ?? []);
  }
  recycleAndCreateHeaderCtrls(e, t) {
    if (!this.headerCellCtrls || e.isEmptyGroup())
      return;
    const r = e.getUniqueId();
    let n;
    if (t && (n = t.get(r), t.delete(r)), n && n.getColumnGroupChild() != e && (this.destroyBean(n), n = void 0), n == null)
      switch (this.type) {
        case "filter": {
          n = this.createBean(
            this.beans.ctrlsFactory.getInstance(
              "headerFilterCell",
              e,
              this.beans,
              this
            )
          );
          break;
        }
        case "group":
          n = this.createBean(
            new fHe(e, this.beans, this)
          );
          break;
        default:
          n = this.createBean(new cHe(e, this.beans, this));
          break;
      }
    this.headerCellCtrls.set(r, n);
  }
  getColumnsInViewport() {
    return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null)
      return [];
    let e = [];
    const t = this.getActualDepth(), { columnViewportService: r } = this.beans;
    return ["left", null, "right"].forEach((n) => {
      const i = r.getHeadersToRender(n, t);
      e = e.concat(i);
    }), e;
  }
  getActualDepth() {
    return this.type == "filter" ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.beans.columnViewportService.getHeadersToRender(this.pinned, this.getActualDepth());
  }
  findHeaderCellCtrl(e) {
    return this.headerCellCtrls ? this.getHeaderCellCtrls().find((n) => n.getColumnGroupChild() == e) : void 0;
  }
  focusHeader(e, t) {
    const r = this.findHeaderCellCtrl(e);
    return r ? r.focus(t) : !1;
  }
  destroy() {
    this.headerCellCtrls && this.headerCellCtrls.forEach((e) => {
      this.destroyBean(e);
    }), this.headerCellCtrls = void 0, super.destroy();
  }
}, gHe = class extends Se {
  constructor(e) {
    super(), this.hidden = !1, this.includeFloatingFilter = !1, this.groupsRowCtrls = [], this.pinned = e;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService, this.pinnedWidthService = e.pinnedWidthService, this.columnModel = e.columnModel, this.focusService = e.focusService, this.filterManager = e.filterManager;
  }
  setComp(e, t) {
    this.comp = e, this.eViewport = t, this.setupCenterWidth(), this.setupPinnedWidth(), this.setupDragAndDrop(this.eViewport);
    const r = this.onDisplayedColumnsChanged.bind(this);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      displayedColumnsChanged: r,
      advancedFilterEnabledChanged: r
    }), this.ctrlsService.registerHeaderContainer(this, this.pinned), this.columnModel.isReady() && this.refresh();
  }
  getAllCtrls() {
    const e = [...this.groupsRowCtrls];
    return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e;
  }
  refresh(e = !1) {
    const t = new nf(), r = this.focusService.getFocusHeaderToUseAfterRefresh(), n = () => {
      const s = this.columnModel.getHeaderRowCount() - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let l = 0; l < s; l++) {
        const u = this.createBean(
          new TE(
            t.next(),
            this.pinned,
            "group"
            /* COLUMN_GROUP */
          )
        );
        this.groupsRowCtrls.push(u);
      }
    }, i = () => {
      const s = t.next(), l = !this.hidden && (this.columnsRowCtrl == null || !e || this.columnsRowCtrl.getRowIndex() !== s);
      (l || this.hidden) && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), l && (this.columnsRowCtrl = this.createBean(new TE(
        s,
        this.pinned,
        "column"
        /* COLUMN */
      )));
    }, o = () => {
      var u;
      this.includeFloatingFilter = !!((u = this.filterManager) != null && u.hasFloatingFilters()) && !this.hidden;
      const s = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        s();
        return;
      }
      const l = t.next();
      if (this.filtersRowCtrl) {
        const c = this.filtersRowCtrl.getRowIndex() !== l;
        (!e || c) && s();
      }
      this.filtersRowCtrl || (this.filtersRowCtrl = this.createBean(
        new TE(
          l,
          this.pinned,
          "filter"
          /* FLOATING_FILTER */
        )
      ));
    };
    n(), i(), o();
    const a = this.getAllCtrls();
    this.comp.setCtrls(a), this.restoreFocusOnHeader(r);
  }
  getHeaderCtrlForColumn(e) {
    if (cu(e))
      return this.columnsRowCtrl ? this.columnsRowCtrl.getHeaderCellCtrl(e) : void 0;
    if (this.groupsRowCtrls.length !== 0)
      for (let t = 0; t < this.groupsRowCtrls.length; t++) {
        const r = this.groupsRowCtrls[t].getHeaderCellCtrl(e);
        if (r)
          return r;
      }
  }
  getHtmlElementForColumnHeader(e) {
    const t = this.getHeaderCtrlForColumn(e);
    return t ? t.getGui() : null;
  }
  getRowType(e) {
    const r = this.getAllCtrls()[e];
    return r ? r.getType() : void 0;
  }
  focusHeader(e, t, r) {
    const i = this.getAllCtrls()[e];
    return i ? i.focusHeader(t, r) : !1;
  }
  getViewport() {
    return this.eViewport;
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  setHorizontalScroll(e) {
    this.comp.setViewportScrollLeft(e);
  }
  destroy() {
    this.filtersRowCtrl && (this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)), this.columnsRowCtrl && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), this.groupsRowCtrls && this.groupsRowCtrls.length && (this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls)), super.destroy();
  }
  setupDragAndDrop(e) {
    const t = new sHe(this.pinned, e);
    this.createManagedBean(t);
  }
  restoreFocusOnHeader(e) {
    if (!e)
      return;
    const { column: t } = e;
    t.getPinned() == this.pinned && this.focusService.focusHeaderPosition({ headerPosition: e });
  }
  // grid cols have changed - this also means the number of rows in the header can have
  // changed. so we remove all the old rows and insert new ones for a complete refresh
  onGridColumnsChanged() {
    this.refresh(!0);
  }
  onDisplayedColumnsChanged() {
    var t;
    const e = ((t = this.filterManager) == null ? void 0 : t.hasFloatingFilters()) && !this.hidden;
    this.includeFloatingFilter !== e && this.refresh(!0);
  }
  setupCenterWidth() {
    this.pinned == null && this.createManagedBean(new xI((e) => this.comp.setCenterWidth(`${e}px`), !0));
  }
  setupPinnedWidth() {
    if (this.pinned == null)
      return;
    const e = this.pinned === "left", t = this.pinned === "right";
    this.hidden = !0;
    const r = () => {
      const n = e ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
      if (n == null)
        return;
      const i = n == 0, o = this.hidden !== i, a = this.gos.get("enableRtl"), s = this.gos.getScrollbarWidth(), u = this.scrollVisibleService.isVerticalScrollShowing() && (a && e || !a && t) ? n + s : n;
      this.comp.setPinnedContainerWidth(`${u}px`), this.comp.setDisplayed(!i), o && (this.hidden = i, this.refresh());
    };
    this.addManagedEventListeners({
      leftPinnedWidthChanged: r,
      rightPinnedWidthChanged: r,
      scrollVisibilityChanged: r,
      scrollbarWidthChanged: r
    });
  }
}, _I = class extends Se {
  constructor(e) {
    super(), this.view = e;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const e = this.getDomLayout(), t = {
      autoHeight: e === "autoHeight",
      normal: e === "normal",
      print: e === "print"
    }, r = t.autoHeight ? "ag-layout-auto-height" : t.print ? "ag-layout-print" : "ag-layout-normal";
    this.view.updateLayoutClasses(r, t);
  }
  // returns either 'print', 'autoHeight' or 'normal' (normal is the default)
  getDomLayout() {
    const e = this.gos.get("domLayout") ?? "normal";
    return ["normal", "print", "autoHeight"].indexOf(e) === -1 ? (Te(`${e} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`), "normal") : e;
  }
}, vHe = class extends tn {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-overlay" role="presentation">
                <div class="ag-overlay-panel" role="presentation">
                    <div class="ag-overlay-wrapper" data-ref="eOverlayWrapper" role="presentation"></div>
                </div>
            </div>`
    ), this.eOverlayWrapper = Pt, this.activePromise = null, this.activeOverlay = null, this.updateListenerDestroyFunc = null, this.activeOverlayWrapperCssClass = null;
  }
  wireBeans(e) {
    this.overlayService = e.overlayService;
  }
  updateLayoutClasses(e, t) {
    const r = this.eOverlayWrapper.classList;
    r.toggle("ag-layout-auto-height", t.autoHeight), r.toggle("ag-layout-normal", t.normal), r.toggle("ag-layout-print", t.print);
  }
  postConstruct() {
    this.createManagedBean(new _I(this)), this.setDisplayed(!1, { skipAriaHidden: !0 }), this.overlayService.registerOverlayWrapperComp(this);
  }
  setWrapperTypeClass(e) {
    const t = this.eOverlayWrapper.classList;
    this.activeOverlayWrapperCssClass && t.toggle(this.activeOverlayWrapperCssClass, !1), this.activeOverlayWrapperCssClass = e, t.toggle(e, !0);
  }
  showOverlay(e, t, r) {
    this.setWrapperTypeClass(t), this.destroyActiveOverlay(), this.activePromise = e, e == null || e.then((n) => {
      if (this.activePromise !== e) {
        this.activeOverlay !== n && (this.destroyBean(n), n = null);
        return;
      }
      if (this.activePromise = null, !!n && this.activeOverlay != n && (this.eOverlayWrapper.appendChild(n.getGui()), this.activeOverlay = n, r)) {
        const i = n;
        this.updateListenerDestroyFunc = this.addManagedPropertyListener(r, ({ currentValue: o }) => {
          var a;
          (a = i.refresh) == null || a.call(i, this.gos.addGridCommonParams({ ...o ?? {} }));
        });
      }
    }), this.setDisplayed(!0, { skipAriaHidden: !0 });
  }
  destroyActiveOverlay() {
    this.activePromise = null;
    const e = this.activeOverlay;
    if (!e)
      return;
    this.activeOverlay = null;
    const t = this.updateListenerDestroyFunc;
    t && (t(), this.updateListenerDestroyFunc = null), this.destroyBean(e), xo(this.eOverlayWrapper);
  }
  hideOverlay() {
    this.destroyActiveOverlay(), this.setDisplayed(!1, { skipAriaHidden: !0 });
  }
  destroy() {
    this.destroyActiveOverlay(), super.destroy();
  }
}, $q = class extends tn {
  constructor(e, t) {
    super(), this.direction = t, this.eViewport = Pt, this.eContainer = Pt, this.hideTimeout = null, this.setTemplate(e);
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this)
    }), this.onScrollVisibilityChanged(), this.addOrRemoveCssClass("ag-apple-scrollbar", YY() || xu());
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.invisibleScrollbar = XY(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()));
  }
  addActiveListenerToggles() {
    const e = this.getGui(), t = () => this.addOrRemoveCssClass("ag-scrollbar-active", !0), r = () => this.addOrRemoveCssClass("ag-scrollbar-active", !1);
    this.addManagedListeners(e, {
      mouseenter: t,
      mousedown: t,
      touchstart: t,
      mouseleave: r,
      touchend: r
    });
  }
  onScrollVisibilityChanged() {
    this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(), this.animationFrameService.requestAnimationFrame(() => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedEventListeners({
      bodyScroll: (e) => {
        e.direction === this.direction && (this.hideTimeout !== null && (window.clearTimeout(this.hideTimeout), this.hideTimeout = null), this.addOrRemoveCssClass("ag-scrollbar-scrolling", !0));
      },
      bodyScrollEnd: () => {
        this.hideTimeout = window.setTimeout(() => {
          this.addOrRemoveCssClass("ag-scrollbar-scrolling", !1), this.hideTimeout = null;
        }, 400);
      }
    });
  }
  attemptSettingScrollPosition(e) {
    const t = this.getViewport();
    iBe(
      () => ys(t),
      () => this.setScrollPosition(e),
      100
    );
  }
  getViewport() {
    return this.eViewport;
  }
  getContainer() {
    return this.eContainer;
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.getViewport(), { scroll: e });
  }
}, mHe = class extends $q {
  constructor() {
    super(
      /* html */
      `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" data-ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" data-ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" data-ref="eRightSpacer"></div>
        </div>`,
      "horizontal"
    ), this.eLeftSpacer = Pt, this.eRightSpacer = Pt;
  }
  wireBeans(e) {
    super.wireBeans(e), this.visibleColsService = e.visibleColsService, this.pinnedRowModel = e.pinnedRowModel, this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  postConstruct() {
    super.postConstruct();
    const e = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e,
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this)
    }), this.addManagedPropertyListener("domLayout", e), this.ctrlsService.register("fakeHScrollComp", this), this.createManagedBean(new xI((t) => this.eContainer.style.width = `${t}px`)), this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.enableRtl = this.gos.get("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom());
  }
  onPinnedRowDataChanged() {
    this.refreshCompBottom();
  }
  refreshCompBottom() {
    if (!this.invisibleScrollbar)
      return;
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight();
    this.getGui().style.bottom = `${e}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    let t = this.visibleColsService.getDisplayedColumnsRightWidth();
    const r = !this.enableRtl && e, n = this.gos.getScrollbarWidth();
    r && (t += n), Da(this.eRightSpacer, t), this.eRightSpacer.classList.toggle("ag-scroller-corner", t <= n);
    let i = this.visibleColsService.getColsLeftWidth();
    this.enableRtl && e && (i += n), Da(this.eLeftSpacer, i), this.eLeftSpacer.classList.toggle("ag-scroller-corner", i <= n);
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isHorizontalScrollShowing(), t = this.invisibleScrollbar, r = this.gos.get("suppressHorizontalScroll"), n = e && this.gos.getScrollbarWidth() || 0, o = r ? 0 : n === 0 && t ? 16 : n;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), yg(this.getGui(), o), yg(this.eViewport, o), yg(this.eContainer, o), this.setDisplayed(e, { skipAriaHidden: !0 });
  }
  getScrollPosition() {
    return iS(this.getViewport(), this.enableRtl);
  }
  setScrollPosition(e) {
    ys(this.getViewport()) || this.attemptSettingScrollPosition(e), oS(this.getViewport(), e, this.enableRtl);
  }
}, Hq = class extends Se {
  wireBeans(e) {
    this.maxDivHeightScaler = e.rowContainerHeightService;
  }
  constructor(e, t) {
    super(), this.eContainer = e, this.eViewport = t;
  }
  postConstruct() {
    this.addManagedEventListeners({ rowContainerHeightChanged: this.onHeightChanged.bind(this) });
  }
  onHeightChanged() {
    const e = this.maxDivHeightScaler.getUiContainerHeight(), t = e != null ? `${e}px` : "";
    this.eContainer.style.height = t, this.eViewport && (this.eViewport.style.height = t);
  }
}, yHe = class extends $q {
  wireBeans(e) {
    super.wireBeans(e), this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  constructor() {
    super(
      /* html */
      `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-vertical-scroll-container" data-ref="eContainer"></div>
            </div>
        </div>`,
      "vertical"
    );
  }
  postConstruct() {
    super.postConstruct(), this.createManagedBean(new Hq(this.eContainer)), this.ctrlsService.register("fakeVScrollComp", this), this.addManagedEventListeners({ rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this) });
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isVerticalScrollShowing(), t = this.invisibleScrollbar, r = e && this.gos.getScrollbarWidth() || 0, n = r === 0 && t ? 16 : r;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), Da(this.getGui(), n), Da(this.eViewport, n), Da(this.eContainer, n), this.setDisplayed(e, { skipAriaHidden: !0 });
  }
  onRowContainerHeightChanged() {
    const { ctrlsService: e } = this, r = e.getGridBodyCtrl().getBodyViewportElement(), n = this.getScrollPosition(), i = r.scrollTop;
    n != i && this.setScrollPosition(i, !0);
  }
  getScrollPosition() {
    return this.getViewport().scrollTop;
  }
  setScrollPosition(e, t) {
    !t && !ys(this.getViewport()) && this.attemptSettingScrollPosition(e), this.getViewport().scrollTop = e;
  }
}, CHe = class extends Se {
  constructor(e) {
    super(), this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.lastOffsetHeight = -1, this.lastScrollTop = -1, this.eBodyViewport = e, this.resetLastHScrollDebounced = Ti(
      () => this.lastScrollSource[
        1
        /* Horizontal */
      ] = null,
      500
    ), this.resetLastVScrollDebounced = Ti(() => this.lastScrollSource[
      0
      /* Vertical */
    ] = null, 500);
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.animationFrameService = e.animationFrameService, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService, this.rowModel = e.rowModel, this.heightScaler = e.rowContainerHeightService, this.rowRenderer = e.rowRenderer, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService;
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.addManagedEventListeners({
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this)
    }), this.ctrlsService.whenReady((e) => {
      this.centerRowsCtrl = e.center, this.onDisplayedColumnsWidthChanged(), this.addScrollListener();
    });
  }
  addScrollListener() {
    const { fakeHScrollComp: e, fakeVScrollComp: t } = this.ctrlsService.getParams();
    this.addManagedElementListeners(this.centerRowsCtrl.getViewportElement(), {
      scroll: this.onHScroll.bind(this)
    }), e.onScrollCallback(this.onFakeHScroll.bind(this));
    const r = this.gos.get("debounceVerticalScrollbar"), n = r ? Ti(this.onVScroll.bind(this), 100) : this.onVScroll.bind(this), i = r ? Ti(this.onFakeVScroll.bind(this), 100) : this.onFakeVScroll.bind(this);
    this.addManagedElementListeners(this.eBodyViewport, { scroll: n }), t.onScrollCallback(i);
  }
  onDisplayedColumnsWidthChanged() {
    this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(e) {
    if (this.centerRowsCtrl == null)
      return;
    e === void 0 && (e = this.centerRowsCtrl.getCenterViewportScrollLeft());
    const r = this.enableRtl ? e : -e, { topCenter: n, stickyTopCenter: i, stickyBottomCenter: o, centerHeader: a, bottomCenter: s, fakeHScrollComp: l } = this.ctrlsService.getParams();
    a.setHorizontalScroll(-r), s.setContainerTranslateX(r), n.setContainerTranslateX(r), i.setContainerTranslateX(r), o.setContainerTranslateX(r);
    const u = this.centerRowsCtrl.getViewportElement(), c = this.lastScrollSource[
      1
      /* Horizontal */
    ] === 0;
    e = Math.abs(e), c ? l.setScrollPosition(e) : oS(u, e, this.enableRtl);
  }
  isControllingScroll(e, t) {
    return this.lastScrollSource[t] == null ? (this.lastScrollSource[t] = e, !0) : this.lastScrollSource[t] === e;
  }
  onFakeHScroll() {
    this.isControllingScroll(
      1,
      1
      /* Horizontal */
    ) && this.onHScrollCommon(
      1
      /* FakeContainer */
    );
  }
  onHScroll() {
    this.isControllingScroll(
      0,
      1
      /* Horizontal */
    ) && this.onHScrollCommon(
      0
      /* Container */
    );
  }
  onHScrollCommon(e) {
    const t = this.centerRowsCtrl.getViewportElement(), { scrollLeft: r } = t;
    if (this.shouldBlockScrollUpdate(1, r, !0))
      return;
    let n;
    e === 0 ? n = iS(t, this.enableRtl) : n = this.ctrlsService.get("fakeHScrollComp").getScrollPosition(), this.doHorizontalScroll(Math.round(n)), this.resetLastHScrollDebounced();
  }
  onFakeVScroll() {
    this.isControllingScroll(
      1,
      0
      /* Vertical */
    ) && this.onVScrollCommon(
      1
      /* FakeContainer */
    );
  }
  onVScroll() {
    this.isControllingScroll(
      0,
      0
      /* Vertical */
    ) && this.onVScrollCommon(
      0
      /* Container */
    );
  }
  onVScrollCommon(e) {
    let t;
    e === 0 ? t = this.eBodyViewport.scrollTop : t = this.ctrlsService.get("fakeVScrollComp").getScrollPosition(), !this.shouldBlockScrollUpdate(0, t, !0) && (this.animationFrameService.setScrollTop(t), this.nextScrollTop = t, e === 0 ? this.ctrlsService.get("fakeVScrollComp").setScrollPosition(t) : this.eBodyViewport.scrollTop = t, this.gos.get("suppressAnimationFrame") ? this.scrollGridIfNeeded() : this.animationFrameService.schedule(), this.resetLastVScrollDebounced());
  }
  doHorizontalScroll(e) {
    const t = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
    this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(
      1
      /* Horizontal */
    ), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.centerRowsCtrl.onHorizontalViewportChanged(!0));
  }
  fireScrollEvent(e) {
    const t = {
      type: "bodyScroll",
      direction: e === 1 ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.eventService.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = void 0, this.scrollTimer = window.setTimeout(() => {
      const r = {
        ...t,
        type: "bodyScrollEnd"
      };
      this.eventService.dispatchEvent(r);
    }, 100);
  }
  shouldBlockScrollUpdate(e, t, r = !1) {
    return r && !xu() ? !1 : e === 0 ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t);
  }
  shouldBlockVerticalScroll(e) {
    const t = lI(this.eBodyViewport), { scrollHeight: r } = this.eBodyViewport;
    return e < 0 || e + t > r;
  }
  shouldBlockHorizontalScroll(e) {
    const t = this.centerRowsCtrl.getCenterWidth(), { scrollWidth: r } = this.centerRowsCtrl.getViewportElement();
    if (this.enableRtl && nS()) {
      if (e > 0)
        return !0;
    } else if (e < 0)
      return !0;
    return Math.abs(e) + t > r;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(
      0
      /* Vertical */
    );
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft() && this.onHScrollCommon(
      0
      /* Container */
    );
  }
  scrollGridIfNeeded() {
    const e = this.scrollTop != this.nextScrollTop;
    return e && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), e;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(e, t = !1) {
    const n = this.centerRowsCtrl.getViewportElement().scrollWidth - this.centerRowsCtrl.getCenterWidth();
    !t && this.shouldBlockScrollUpdate(1, e) && (this.enableRtl && nS() ? e = e > 0 ? 0 : n : e = Math.min(Math.max(e, 0), n)), oS(this.centerRowsCtrl.getViewportElement(), Math.abs(e), this.enableRtl), this.doHorizontalScroll(e);
  }
  setVerticalScrollPosition(e) {
    this.eBodyViewport.scrollTop = e;
  }
  getVScrollPosition() {
    return this.lastScrollTop = this.eBodyViewport.scrollTop, this.lastOffsetHeight = this.eBodyViewport.offsetHeight, {
      top: this.lastScrollTop,
      bottom: this.lastScrollTop + this.lastOffsetHeight
    };
  }
  /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */
  getApproximateVScollPosition() {
    return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0 ? {
      top: this.scrollTop,
      bottom: this.scrollTop + this.lastOffsetHeight
    } : this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.centerRowsCtrl.isHorizontalScrollShowing();
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(e) {
    const t = this.centerRowsCtrl.getViewportElement().scrollLeft;
    return this.setHorizontalScrollPosition(t + e), this.centerRowsCtrl.getViewportElement().scrollLeft - t;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(e, t = null) {
    const r = this.rowModel.getRowCount();
    let n = -1;
    for (let i = 0; i < r; i++) {
      const o = this.rowModel.getRow(i);
      if (typeof e == "function") {
        if (o && e(o)) {
          n = i;
          break;
        }
      } else if (e === o || e === o.data) {
        n = i;
        break;
      }
    }
    n >= 0 && this.ensureIndexVisible(n, t);
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(e, t) {
    if (this.gos.isDomLayout("print"))
      return;
    const r = this.rowModel.getRowCount();
    if (typeof e != "number" || e < 0 || e >= r) {
      Te("Invalid row index for ensureIndexVisible: " + e);
      return;
    }
    const i = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.getFrameworkOverrides().wrapIncoming(() => {
      var c;
      i || (c = this.paginationService) == null || c.goToPageWithIndex(e);
      const o = this.ctrlsService.getGridBodyCtrl(), a = o.getStickyTopHeight(), s = o.getStickyBottomHeight(), l = this.rowModel.getRow(e);
      let u;
      do {
        const d = l.rowTop, h = l.rowHeight, f = this.pageBoundsService.getPixelOffset(), p = l.rowTop - f, g = p + l.rowHeight, v = this.getVScrollPosition(), m = this.heightScaler.getDivStretchOffset(), y = v.top + m, C = v.bottom + m, S = C - y, b = this.heightScaler.getScrollPositionForPixel(p), w = this.heightScaler.getScrollPositionForPixel(g - S), x = Math.min((b + w) / 2, p), R = y + a > p, _ = C - s < g;
        let T = null;
        t === "top" ? T = b : t === "bottom" ? T = w : t === "middle" ? T = x : R ? T = b - a : _ && (T = w + s), T !== null && (this.setVerticalScrollPosition(T), this.rowRenderer.redraw({ afterScroll: !0 })), u = d !== l.rowTop || h !== l.rowHeight;
      } while (u);
      this.animationFrameService.flushAllFrames();
    });
  }
  ensureColumnVisible(e, t = "auto") {
    const r = this.columnModel.getCol(e);
    if (!r || r.isPinned() || !this.visibleColsService.isColDisplayed(r))
      return;
    const n = this.getPositionedHorizontalScroll(r, t);
    this.getFrameworkOverrides().wrapIncoming(() => {
      n !== null && this.centerRowsCtrl.setCenterViewportScrollLeft(n), this.centerRowsCtrl.onHorizontalViewportChanged(), this.animationFrameService.flushAllFrames();
    });
  }
  setScrollPosition(e, t) {
    this.getFrameworkOverrides().wrapIncoming(() => {
      this.centerRowsCtrl.setCenterViewportScrollLeft(t), this.setVerticalScrollPosition(e), this.rowRenderer.redraw({ afterScroll: !0 }), this.animationFrameService.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(e, t) {
    const { columnBeforeStart: r, columnAfterEnd: n } = this.isColumnOutsideViewport(e), i = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(), o = this.centerRowsCtrl.getCenterWidth(), a = this.enableRtl;
    let s = (a ? r : n) || i, l = a ? n : r;
    t !== "auto" && (s = t === "start", l = t === "end");
    const u = t === "middle";
    if (s || l || u) {
      const { colLeft: c, colMiddle: d, colRight: h } = this.getColumnBounds(e);
      return u ? d - o / 2 : s ? a ? h : c : a ? c - o : h - o;
    }
    return null;
  }
  isColumnOutsideViewport(e) {
    const { start: t, end: r } = this.getViewportBounds(), { colLeft: n, colRight: i } = this.getColumnBounds(e), o = this.enableRtl, a = o ? t > i : r < i, s = o ? r < n : t > n;
    return { columnBeforeStart: a, columnAfterEnd: s };
  }
  getColumnBounds(e) {
    const t = this.enableRtl, r = this.visibleColsService.getBodyContainerWidth(), n = e.getActualWidth(), i = e.getLeft(), o = t ? -1 : 1, a = t ? r - i : i, s = a + n * o, l = a + n / 2 * o;
    return { colLeft: a, colMiddle: l, colRight: s };
  }
  getViewportBounds() {
    const e = this.centerRowsCtrl.getCenterWidth(), t = this.centerRowsCtrl.getCenterViewportScrollLeft(), r = t, n = e + t;
    return { start: r, end: n, width: e };
  }
}, SHe = "ag-force-vertical-scroll", wHe = "ag-selectable", bHe = "ag-column-moving", xHe = class extends Se {
  constructor() {
    super(...arguments), this.stickyTopHeight = 0, this.stickyBottomHeight = 0;
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.rowContainerHeightService = e.rowContainerHeightService, this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.scrollVisibleService = e.scrollVisibleService, this.menuService = e.menuService, this.headerNavigationService = e.headerNavigationService, this.dragAndDropService = e.dragAndDropService, this.pinnedRowModel = e.pinnedRowModel, this.rowRenderer = e.rowRenderer, this.popupService = e.popupService, this.mouseEventService = e.mouseEventService, this.rowModel = e.rowModel, this.filterManager = e.filterManager, this.environment = e.environment;
  }
  getScrollFeature() {
    return this.bodyScrollFeature;
  }
  getBodyViewportElement() {
    return this.eBodyViewport;
  }
  setComp(e, t, r, n, i, o, a) {
    var s;
    this.comp = e, this.eGridBody = t, this.eBodyViewport = r, this.eTop = n, this.eBottom = i, this.eStickyTop = o, this.eStickyBottom = a, this.setCellTextSelection(this.gos.get("enableCellTextSelection")), this.addManagedPropertyListener(
      "enableCellTextSelection",
      (l) => this.setCellTextSelection(l.currentValue)
    ), this.createManagedBean(new _I(this.comp)), this.bodyScrollFeature = this.createManagedBean(new CHe(this.eBodyViewport)), this.addRowDragListener(), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([n, r, i, o, a]), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), (s = this.filterManager) == null || s.setupAdvancedFilterHeaderComp(n), this.ctrlsService.register("gridBodyCtrl", this);
  }
  getComp() {
    return this.comp;
  }
  addEventListeners() {
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
      pinnedRowDataChanged: this.setFloatingHeights.bind(this),
      pinnedHeightChanged: this.setFloatingHeights.bind(this),
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    });
  }
  addFocusListeners(e) {
    e.forEach((t) => {
      this.addManagedElementListeners(t, {
        focusin: (r) => {
          const { target: n } = r, i = Lh(n, "ag-root", t);
          t.classList.toggle("ag-has-focus", !i);
        },
        focusout: (r) => {
          const { target: n, relatedTarget: i } = r, o = t.contains(i), a = Lh(
            i,
            "ag-root",
            t
          );
          Lh(n, "ag-root", t) || (!o || a) && t.classList.remove("ag-has-focus");
        }
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(e) {
    this.comp.setColumnMovingCss(bHe, e);
  }
  setCellTextSelection(e = !1) {
    this.comp.setCellSelectableCss(wHe, e);
  }
  onScrollVisibilityChanged() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    this.setVerticalScrollPaddingVisible(e), this.setStickyWidth(e), this.setStickyBottomOffsetBottom();
    const t = e && this.gos.getScrollbarWidth() || 0, r = XY() ? 16 : 0, n = `calc(100% + ${t + r}px)`;
    this.animationFrameService.requestAnimationFrame(() => this.comp.setBodyViewportWidth(n));
  }
  onGridColumnsChanged() {
    const e = this.columnModel.getCols();
    this.comp.setColumnCount(e.length);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedElementListeners(this.eGridBody, {
      dragstart: (e) => {
        if (e.target instanceof HTMLImageElement)
          return e.preventDefault(), !1;
      }
    });
  }
  addStopEditingWhenGridLosesFocus() {
    if (!this.gos.get("stopEditingWhenCellsLoseFocus"))
      return;
    const e = (r) => {
      const n = r.relatedTarget;
      if (lP(n) === null) {
        this.rowRenderer.stopEditing();
        return;
      }
      let i = (
        // see if click came from inside the viewports
        t.some((o) => o.contains(n)) && // and also that it's not from a detail grid
        this.mouseEventService.isElementInThisGrid(n)
      );
      if (!i) {
        const o = this.popupService;
        i = o.getActivePopups().some((a) => a.contains(n)) || o.isElementWithinCustomPopup(n);
      }
      i || this.rowRenderer.stopEditing();
    }, t = [this.eBodyViewport, this.eBottom, this.eTop, this.eStickyTop, this.eStickyBottom];
    t.forEach((r) => this.addManagedElementListeners(r, { focusout: e }));
  }
  updateRowCount() {
    var n;
    const e = this.headerNavigationService.getHeaderRowCount() + (((n = this.filterManager) == null ? void 0 : n.getHeaderRowCount()) ?? 0), t = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1, r = t === -1 ? -1 : e + t;
    this.comp.setRowCount(r);
  }
  registerBodyViewportResizeListener(e) {
    this.comp.registerBodyViewportResizeListener(e);
  }
  setVerticalScrollPaddingVisible(e) {
    const t = e ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(t);
  }
  isVerticalScrollShowing() {
    const e = this.gos.get("alwaysShowVerticalScroll"), t = e ? SHe : null, r = this.gos.isDomLayout("normal");
    return this.comp.setAlwaysVerticalScrollClass(t, e), e || r && YBe(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    let e = this.environment.hasMeasuredSizes();
    const t = () => {
      const r = e && this.gos.isAnimateRows() && !this.rowContainerHeightService.isStretching(), n = r ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(n, r);
    };
    t(), this.addManagedEventListeners({ heightScaleChanged: t }), this.addManagedPropertyListener("animateRows", t), this.addManagedEventListeners({
      gridStylesChanged: () => {
        !e && this.environment.hasMeasuredSizes() && (e = !0, t());
      }
    });
  }
  getGridBodyElement() {
    return this.eGridBody;
  }
  addBodyViewportListener() {
    const e = this.onBodyViewportContextMenu.bind(this);
    this.addManagedElementListeners(this.eBodyViewport, { contextmenu: e }), this.mockContextMenuForIPad(e), this.addManagedElementListeners(this.eBodyViewport, { wheel: this.onBodyViewportWheel.bind(this) }), this.addManagedElementListeners(this.eStickyTop, { wheel: this.onStickyWheel.bind(this) }), this.addManagedElementListeners(this.eStickyBottom, { wheel: this.onStickyWheel.bind(this) }), this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    const e = this.eBodyViewport.querySelector(".ag-full-width-container"), t = this.eBodyViewport.querySelector(".ag-center-cols-viewport");
    e && t && this.addManagedElementListeners(e, {
      wheel: (r) => this.onFullWidthContainerWheel(r, t)
    });
  }
  onFullWidthContainerWheel(e, t) {
    !e.deltaX || Math.abs(e.deltaY) > Math.abs(e.deltaX) || !this.mouseEventService.isEventFromThisGrid(e) || (e.preventDefault(), t.scrollBy({ left: e.deltaX }));
  }
  onBodyViewportContextMenu(e, t, r) {
    if (!e && !r)
      return;
    this.gos.get("preventDefaultOnContextMenu") && (e || r).preventDefault();
    const { target: n } = e || t;
    (n === this.eBodyViewport || n === this.ctrlsService.get("center").getViewportElement()) && this.menuService.showContextMenu({
      mouseEvent: e,
      touchEvent: r,
      value: null,
      anchorToElement: this.eGridBody
    });
  }
  mockContextMenuForIPad(e) {
    if (!xu())
      return;
    const t = new ql(this.eBodyViewport), r = (n) => {
      e(void 0, n.touchStart, n.touchEvent);
    };
    this.addManagedListeners(t, { longTap: r }), this.addDestroyFunc(() => t.destroy());
  }
  onBodyViewportWheel(e) {
    this.gos.get("suppressScrollWhenPopupsAreOpen") && this.popupService.hasAnchoredPopup() && e.preventDefault();
  }
  onStickyWheel(e) {
    e.preventDefault(), e.offsetY && this.scrollVertically(e.deltaY);
  }
  getGui() {
    return this.eGridBody;
  }
  // called by rowDragFeature
  scrollVertically(e) {
    const t = this.eBodyViewport.scrollTop;
    return this.bodyScrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t;
  }
  addRowDragListener() {
    this.rowDragFeature = this.createManagedBean(new G4e(this.eBodyViewport)), this.dragAndDropService.addDropTarget(this.rowDragFeature);
  }
  getRowDragFeature() {
    return this.rowDragFeature;
  }
  setFloatingHeights() {
    const { pinnedRowModel: e } = this, t = e.getPinnedTopTotalHeight(), r = e.getPinnedBottomTotalHeight();
    this.comp.setTopHeight(t), this.comp.setBottomHeight(r), this.comp.setTopDisplay(t ? "inherit" : "none"), this.comp.setBottomDisplay(r ? "inherit" : "none"), this.setStickyTopOffsetTop(), this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(e = 0) {
    this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e;
  }
  getStickyTopHeight() {
    return this.stickyTopHeight;
  }
  setStickyBottomHeight(e = 0) {
    this.comp.setStickyBottomHeight(`${e}px`), this.stickyBottomHeight = e;
  }
  getStickyBottomHeight() {
    return this.stickyBottomHeight;
  }
  setStickyWidth(e) {
    if (!e)
      this.comp.setStickyTopWidth("100%"), this.comp.setStickyBottomWidth("100%");
    else {
      const t = this.gos.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${t}px)`), this.comp.setStickyBottomWidth(`calc(100% - ${t}px)`);
    }
  }
  onHeaderHeightChanged() {
    this.setStickyTopOffsetTop();
  }
  setStickyTopOffsetTop() {
    var i;
    const t = this.ctrlsService.get("gridHeaderCtrl").getHeaderHeight() + (((i = this.filterManager) == null ? void 0 : i.getHeaderHeight()) ?? 0), r = this.pinnedRowModel.getPinnedTopTotalHeight();
    let n = 0;
    t > 0 && (n += t), r > 0 && (n += r), n > 0 && (n += 1), this.comp.setStickyTopTop(`${n}px`);
  }
  setStickyBottomOffsetBottom() {
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight(), r = this.scrollVisibleService.isHorizontalScrollShowing() && this.gos.getScrollbarWidth() || 0, n = e + r;
    this.comp.setStickyBottomBottom(`${n}px`);
  }
  // method will call itself if no available width. this covers if the grid
  // isn't visible, but is just about to be visible.
  sizeColumnsToFit(e, t) {
    const n = this.isVerticalScrollShowing() ? this.gos.getScrollbarWidth() : 0, o = rm(this.eGridBody) - n;
    if (o > 0) {
      this.columnSizeService.sizeColumnsToFit(o, "sizeColumnsToFit", !1, e);
      return;
    }
    t === void 0 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 100);
    }, 0) : t === 100 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 500);
    }, 100) : t === 500 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, -1);
    }, 500) : Te(
      "tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?"
    );
  }
  // + rangeService
  addScrollEventListener(e) {
    this.eBodyViewport.addEventListener("scroll", e, { passive: !0 });
  }
  // + focusService
  removeScrollEventListener(e) {
    this.eBodyViewport.removeEventListener("scroll", e);
  }
}, EHe = class extends Se {
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.pinnedWidthService = e.pinnedWidthService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnSizeService = e.columnSizeService, this.scrollVisibleService = e.scrollVisibleService, this.columnViewportService = e.columnViewportService;
  }
  constructor(e) {
    super(), this.centerContainerCtrl = e;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.listenForResize();
    }), this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) }), this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const e = () => this.onCenterViewportResized();
    this.centerContainerCtrl.registerViewportResizeListener(e), this.gridBodyCtrl.registerBodyViewportResizeListener(e);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
      this.keepPinnedColumnsNarrowerThanViewport(), this.checkViewportAndScrolls();
      const e = this.centerContainerCtrl.getCenterWidth();
      e !== this.centerWidth && (this.centerWidth = e, this.columnSizeService.refreshFlexedColumns({
        viewportWidth: this.centerWidth,
        updateBodyWidths: !0,
        fireResizedEvent: !0
      }));
    } else
      this.bodyHeight = 0;
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = rm(e);
    if (t <= 50)
      return;
    let r = this.getPinnedColumnsOverflowingViewport(t - 50);
    const n = this.gos.getCallback("processUnpinnedColumns");
    r.length && (n && (r = n({
      columns: r,
      viewportWidth: t
    })), this.columnModel.setColsPinned(r, null, "viewportSizeFeature"));
  }
  getPinnedColumnsOverflowingViewport(e) {
    const t = this.pinnedWidthService.getPinnedRightWidth(), r = this.pinnedWidthService.getPinnedLeftWidth(), n = t + r;
    if (n < e)
      return [];
    const i = [...this.visibleColsService.getLeftCols()], o = [...this.visibleColsService.getRightCols()];
    let a = 0, s = 0;
    const l = 0, u = [];
    let c = n - l - e;
    for (; (s < i.length || a < o.length) && c > 0; ) {
      if (a < o.length) {
        const d = o[a++];
        c -= d.getActualWidth(), u.push(d);
      }
      if (s < i.length && c > 0) {
        const d = i[s++];
        c -= d.getActualWidth(), u.push(d);
      }
    }
    return u;
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.getScrollFeature().checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = lI(e);
    if (this.bodyHeight !== t) {
      this.bodyHeight = t;
      const r = {
        type: "bodyHeightChanged"
      };
      this.eventService.dispatchEvent(r);
    }
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const e = {
      horizontalScrollShowing: this.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleService.setScrollsVisible(e);
  }
  isHorizontalScrollShowing() {
    return this.centerContainerCtrl.isHorizontalScrollShowing();
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const e = this.centerContainerCtrl.getCenterWidth(), t = this.centerContainerCtrl.getViewportScrollLeft();
    this.columnViewportService.setScrollPosition(e, t);
  }
}, RHe = class extends Se {
  wireBeans(e) {
    this.dragService = e.dragService, this.rangeService = e.rangeService;
  }
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    if (!this.rangeService)
      return;
    this.params = {
      eElement: this.eContainer,
      onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
      onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
      onDragging: this.rangeService.onDragging.bind(this.rangeService)
    }, this.addManagedPropertyListener("enableRangeSelection", (t) => {
      if (t.currentValue) {
        this.enableFeature();
        return;
      }
      this.disableFeature();
    }), this.addDestroyFunc(() => this.disableFeature()), this.gos.get("enableRangeSelection") && this.enableFeature();
  }
  enableFeature() {
    this.dragService.addDragSource(this.params);
  }
  disableFeature() {
    this.dragService.removeDragSource(this.params);
  }
}, _He = class extends tn {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [fI]
    ), this.eCheckbox = Pt;
  }
  postConstruct() {
    this.eCheckbox.setPassive(!0);
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const e = this.localeService.getLocaleTextFunc(), t = this.rowNode.isSelected(), r = oI(e, t), [n, i] = this.rowNode.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"], o = e(n, i);
    this.eCheckbox.setValue(t, !0), this.eCheckbox.setInputAriaLabel(`${o} (${r})`);
  }
  onClicked(e, t, r) {
    return this.rowNode.setSelectedParams({
      newValue: e,
      rangeSelect: r.shiftKey,
      groupSelectsFiltered: t,
      event: r,
      source: "checkboxSelected"
    });
  }
  init(e) {
    if (this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListeners(this.eCheckbox.getInputElement(), {
      // we don't want double click on this icon to open a group
      dblclick: (n) => ef(n),
      click: (n) => {
        ef(n);
        const i = this.gos.get("groupSelectsFiltered"), o = this.eCheckbox.getValue();
        this.shouldHandleIndeterminateState(o, i) ? this.onClicked(!0, i, n || {}) === 0 && this.onClicked(!1, i, n) : o ? this.onClicked(!1, i, n) : this.onClicked(!0, i, n || {});
      }
    }), this.addManagedListeners(this.rowNode, {
      rowSelected: this.onSelectionChanged.bind(this),
      dataChanged: this.onDataChanged.bind(this),
      selectableChanged: this.onSelectableChanged.bind(this)
    }), this.gos.get("isRowSelectable") || typeof this.getIsVisible() == "function") {
      const n = this.showOrHideSelect.bind(this);
      this.addManagedEventListeners({ displayedColumnsChanged: n }), this.addManagedListeners(this.rowNode, {
        dataChanged: n,
        cellChanged: n
      }), this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  shouldHandleIndeterminateState(e, t) {
    return t && (this.eCheckbox.getPreviousValue() === void 0 || e === void 0) && this.gos.isRowModelType("clientSide");
  }
  showOrHideSelect() {
    var n, i, o;
    let e = this.rowNode.selectable;
    const t = this.getIsVisible();
    if (e)
      if (typeof t == "function") {
        const a = (n = this.overrides) == null ? void 0 : n.callbackParams;
        if (!this.column)
          e = t({ ...a, node: this.rowNode, data: this.rowNode.data });
        else {
          const s = this.column.createColumnFunctionCallbackParams(this.rowNode);
          e = t({ ...a, ...s });
        }
      } else
        e = t ?? !1;
    if ((i = this.column) == null ? void 0 : i.getColDef().showDisabledCheckboxes) {
      this.eCheckbox.setDisabled(!e), this.setVisible(!0), this.setDisplayed(!0);
      return;
    }
    if ((o = this.overrides) != null && o.removeHidden) {
      this.setDisplayed(e);
      return;
    }
    this.setVisible(e);
  }
  getIsVisible() {
    var e, t;
    return this.overrides ? this.overrides.isVisible : (t = (e = this.column) == null ? void 0 : e.getColDef()) == null ? void 0 : t.checkboxSelection;
  }
}, THe = class extends tn {
  constructor(e, t, r) {
    super(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" draggable="true"></div>'
    ), this.rowNode = e, this.column = t, this.eCell = r;
  }
  postConstruct() {
    this.getGui().appendChild(yo("rowDrag", this.gos, null)), this.addGuiEventListener("mousedown", (t) => {
      t.stopPropagation();
    }), this.addDragSource(), this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(e) {
    const t = this.column.getColDef().dndSourceOnRowDrag;
    e.dataTransfer.setDragImage(this.eCell, 0, 0);
    const r = () => {
      try {
        const n = JSON.stringify(this.rowNode.data);
        e.dataTransfer.setData("application/json", n), e.dataTransfer.setData("text/plain", n);
      } catch {
      }
    };
    if (t) {
      const n = this.gos.addGridCommonParams({
        rowNode: this.rowNode,
        dragEvent: e
      });
      t(n);
    } else
      r();
  }
  checkVisibility() {
    const e = this.column.isDndSource(this.rowNode);
    this.setDisplayed(e);
  }
}, PHe = class extends Se {
  constructor(e, t) {
    super(), this.staticClasses = [], this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setComp(e) {
    this.cellComp = e, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const e = this.column.getColDef(), { cellClassRules: t } = e, r = this.beans.gos.addGridCommonParams({
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      colDef: e,
      column: this.column,
      rowIndex: this.rowNode.rowIndex
    });
    this.beans.stylingService.processClassRules(
      // if current was previous, skip
      t === this.cellClassRules ? void 0 : this.cellClassRules,
      t,
      r,
      (n) => this.cellComp.addOrRemoveCssClass(n, !0),
      (n) => this.cellComp.addOrRemoveCssClass(n, !1)
    ), this.cellClassRules = t;
  }
  applyUserStyles() {
    const e = this.column.getColDef();
    if (!e.cellStyle)
      return;
    let t;
    if (typeof e.cellStyle == "function") {
      const r = this.beans.gos.addGridCommonParams({
        column: this.column,
        value: this.cellCtrl.getValue(),
        colDef: e,
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      }), n = e.cellStyle;
      t = n(r);
    } else
      t = e.cellStyle;
    t && this.cellComp.setUserStyles(t);
  }
  applyClassesFromColDef() {
    const e = this.column.getColDef(), t = this.beans.gos.addGridCommonParams({
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      column: this.column,
      colDef: e,
      rowIndex: this.rowNode.rowIndex
    });
    this.staticClasses.length && this.staticClasses.forEach((r) => this.cellComp.addOrRemoveCssClass(r, !1)), this.staticClasses = this.beans.stylingService.getStaticCellClasses(e, t), this.staticClasses.length && this.staticClasses.forEach((r) => this.cellComp.addOrRemoveCssClass(r, !0));
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, MHe = class extends Se {
  constructor(e, t, r, n, i) {
    super(), this.cellCtrl = e, this.beans = t, this.rowNode = n, this.rowCtrl = i;
  }
  setComp(e) {
    this.eGui = e;
  }
  onKeyDown(e) {
    const t = e.key;
    switch (t) {
      case pe.ENTER:
        this.onEnterKeyDown(e);
        break;
      case pe.F2:
        this.onF2KeyDown(e);
        break;
      case pe.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case pe.TAB:
        this.onTabKeyDown(e);
        break;
      case pe.BACKSPACE:
      case pe.DELETE:
        this.onBackspaceOrDeleteKeyDown(t, e);
        break;
      case pe.DOWN:
      case pe.UP:
      case pe.RIGHT:
      case pe.LEFT:
        this.onNavigationKeyDown(e, t);
        break;
    }
  }
  onNavigationKeyDown(e, t) {
    this.cellCtrl.isEditing() || (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(e) : this.beans.navigationService.navigateToNextCell(e, t, this.cellCtrl.getCellPosition(), !0), e.preventDefault());
  }
  onShiftRangeSelect(e) {
    if (!this.beans.rangeService)
      return;
    const t = this.beans.rangeService.extendLatestRangeInDirection(e);
    t && this.beans.navigationService.ensureCellVisible(t);
  }
  onTabKeyDown(e) {
    this.beans.navigationService.onTabKeyDown(this.cellCtrl, e);
  }
  onBackspaceOrDeleteKeyDown(e, t) {
    const { cellCtrl: r, beans: n, rowNode: i } = this, { gos: o, rangeService: a, eventService: s } = n;
    if (!r.isEditing()) {
      if (s.dispatchEvent({ type: "keyShortcutChangedCellStart" }), u$e(e, o.get("enableCellEditingOnBackspace"))) {
        if (a && o.get("enableRangeSelection"))
          a.clearCellRangeCellValues({ dispatchWrapperEvents: !0, wrapperEventSource: "deleteKey" });
        else if (r.isCellEditable()) {
          const l = r.getColumn(), u = this.beans.valueService.parseValue(l, i, "", i.getValueFromValueService(l)) ?? null;
          i.setDataValue(l, u, "cellClear");
        }
      } else
        r.startRowOrCellEdit(e, t);
      s.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
    }
  }
  onEnterKeyDown(e) {
    if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing())
      this.cellCtrl.stopEditingAndFocus(!1, e.shiftKey);
    else if (this.beans.gos.get("enterNavigatesVertically")) {
      const t = e.shiftKey ? pe.UP : pe.DOWN;
      this.beans.navigationService.navigateToNextCell(null, t, this.cellCtrl.getCellPosition(), !1);
    } else
      this.cellCtrl.startRowOrCellEdit(pe.ENTER, e), this.cellCtrl.isEditing() && e.preventDefault();
  }
  onF2KeyDown(e) {
    this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(pe.F2, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onEscapeKeyDown(e) {
    this.cellCtrl.isEditing() && (this.cellCtrl.stopRowOrCellEdit(!0), this.cellCtrl.focusCell(!0));
  }
  processCharacter(e) {
    if (e.target !== this.eGui || this.cellCtrl.isEditing())
      return;
    const n = e.key;
    n === " " ? this.onSpaceKeyDown(e) : (this.cellCtrl.startRowOrCellEdit(n, e), e.preventDefault());
  }
  onSpaceKeyDown(e) {
    const { gos: t } = this.beans;
    if (!this.cellCtrl.isEditing() && t.isRowSelection()) {
      const r = this.rowNode.isSelected(), n = !r;
      if (n || !t.get("suppressRowDeselection")) {
        const i = this.beans.gos.get("groupSelectsFiltered"), o = this.rowNode.setSelectedParams({
          newValue: n,
          rangeSelect: e.shiftKey,
          groupSelectsFiltered: i,
          event: e,
          source: "spaceKey"
        });
        r === void 0 && o === 0 && this.rowNode.setSelectedParams({
          newValue: !1,
          rangeSelect: e.shiftKey,
          groupSelectsFiltered: i,
          event: e,
          source: "spaceKey"
        });
      }
    }
    e.preventDefault();
  }
  destroy() {
    super.destroy();
  }
}, DHe = class extends Se {
  constructor(e, t, r) {
    super(), this.cellCtrl = e, this.beans = t, this.column = r;
  }
  onMouseEvent(e, t) {
    if (!Yl(t))
      switch (e) {
        case "click":
          this.onCellClicked(t);
          break;
        case "mousedown":
        case "touchstart":
          this.onMouseDown(t);
          break;
        case "dblclick":
          this.onCellDoubleClicked(t);
          break;
        case "mouseout":
          this.onMouseOut(t);
          break;
        case "mouseover":
          this.onMouseOver(t);
          break;
      }
  }
  onCellClicked(e) {
    if (this.isDoubleClickOnIPad()) {
      this.onCellDoubleClicked(e), e.preventDefault();
      return;
    }
    const { eventService: t, rangeService: r, gos: n } = this.beans, i = e.ctrlKey || e.metaKey;
    r && i && r.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1 && r.intersectLastRange(!0);
    const o = this.cellCtrl.createEvent(e, "cellClicked");
    t.dispatchEvent(o);
    const a = this.column.getColDef();
    a.onCellClicked && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        a.onCellClicked(o);
      });
    }, 0), (n.get("singleClickEdit") || a.singleClickEdit) && !n.get("suppressClickEdit") && !(e.shiftKey && (r == null ? void 0 : r.getCellRanges().length) != 0) && this.cellCtrl.startRowOrCellEdit();
  }
  // returns true if on iPad and this is second 'click' event in 200ms
  isDoubleClickOnIPad() {
    if (!xu() || OY("dblclick"))
      return !1;
    const e = (/* @__PURE__ */ new Date()).getTime(), t = e - this.lastIPadMouseClickEvent < 200;
    return this.lastIPadMouseClickEvent = e, t;
  }
  onCellDoubleClicked(e) {
    const { column: t, beans: r, cellCtrl: n } = this, { eventService: i, frameworkOverrides: o, gos: a } = r, s = t.getColDef(), l = n.createEvent(e, "cellDoubleClicked");
    i.dispatchEvent(l), typeof s.onCellDoubleClicked == "function" && window.setTimeout(() => {
      o.wrapOutgoing(() => {
        s.onCellDoubleClicked(l);
      });
    }, 0), !a.get("singleClickEdit") && !a.get("suppressClickEdit") && n.startRowOrCellEdit(null, e);
  }
  onMouseDown(e) {
    const { ctrlKey: t, metaKey: r, shiftKey: n } = e, i = e.target, { cellCtrl: o, beans: a } = this, { eventService: s, rangeService: l, focusService: u, gos: c } = a;
    if (this.isRightClickInExistingRange(e))
      return;
    const d = l && l.getCellRanges().length != 0;
    if (!n || !d) {
      const f = c.get("enableCellTextSelection") && e.defaultPrevented, p = (al() || f) && !o.isEditing() && !sI(i);
      o.focusCell(p);
    }
    if (n && d && !u.isCellFocused(o.getCellPosition())) {
      e.preventDefault();
      const h = u.getFocusedCell();
      if (h) {
        const { column: f, rowIndex: p, rowPinned: g } = h, v = a.rowRenderer.getRowByPosition({ rowIndex: p, rowPinned: g }), m = v == null ? void 0 : v.getCellCtrl(f);
        m != null && m.isEditing() && m.stopEditing(), u.setFocusedCell({
          column: f,
          rowIndex: p,
          rowPinned: g,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0
        });
      }
    }
    if (!this.containsWidget(i)) {
      if (l) {
        const h = this.cellCtrl.getCellPosition();
        if (n)
          l.extendLatestRangeToCell(h);
        else {
          const f = t || r;
          l.setRangeToCell(h, f);
        }
      }
      s.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseDown"));
    }
  }
  isRightClickInExistingRange(e) {
    const { rangeService: t } = this.beans;
    if (t) {
      const r = t.isCellInAnyRange(this.cellCtrl.getCellPosition()), n = e.button === 2 || e.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
      if (r && n)
        return !0;
    }
    return !1;
  }
  containsWidget(e) {
    return Lh(e, "ag-selection-checkbox", 3);
  }
  onMouseOut(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const t = this.cellCtrl.createEvent(e, "cellMouseOut");
    this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.clearMouseOver();
  }
  onMouseOver(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const t = this.cellCtrl.createEvent(e, "cellMouseOver");
    this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget)
      return !1;
    const t = this.cellCtrl.getGui(), r = t.contains(e.target), n = t.contains(e.relatedTarget);
    return r && n;
  }
  destroy() {
    super.destroy();
  }
}, AHe = class extends Se {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode), this.addManagedListeners(this.beans.eventService, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
  }
  setComp(e) {
    this.eGui = e, this.setupColSpan(), this.setupRowSpan(), this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan();
  }
  onNewColumnsLoaded() {
    const e = this.column.getRowSpan(this.rowNode);
    this.rowSpan !== e && (this.rowSpan = e, this.applyRowSpan(!0));
  }
  onDisplayColumnsChanged() {
    const e = this.getColSpanningList();
    fd(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged());
  }
  setupColSpan() {
    this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListeners(this.beans.eventService, {
      // because we are col spanning, a reorder of the cols can change what cols we are spanning over
      displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
      // because we are spanning over multiple cols, we check for width any time any cols width changes.
      // this is expensive - really we should be explicitly checking only the cols we are spanning over
      // instead of every col, however it would be tricky code to track the cols we are spanning over, so
      // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
      displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
    }));
  }
  onWidthChanged() {
    if (!this.eGui)
      return;
    const e = this.getCellWidth();
    this.eGui.style.width = `${e}px`;
  }
  getCellWidth() {
    return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth();
  }
  getColSpanningList() {
    const e = this.column.getColSpan(this.rowNode), t = [];
    if (e === 1)
      t.push(this.column);
    else {
      let r = this.column;
      const n = this.column.getPinned();
      for (let i = 0; r && i < e && (t.push(r), r = this.beans.visibleColsService.getColAfter(r), !(!r || dr(r) || n !== r.getPinned())); i++)
        ;
    }
    return t;
  }
  onLeftChanged() {
    if (!this.eGui)
      return;
    const e = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eGui.style.left = e + "px";
  }
  getCellLeft() {
    let e;
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? e = gr(this.colsSpanning) : e = this.column, e.getLeft();
  }
  modifyLeftForPrintLayout(e) {
    if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === "left")
      return e;
    const t = this.beans.visibleColsService.getColsLeftWidth();
    if (this.column.getPinned() === "right") {
      const r = this.beans.visibleColsService.getBodyContainerWidth();
      return t + r + (e || 0);
    }
    return t + (e || 0);
  }
  applyRowSpan(e) {
    if (this.rowSpan === 1 && !e)
      return;
    const r = this.beans.gos.getRowHeightAsNumber() * this.rowSpan;
    this.eGui.style.height = `${r}px`, this.eGui.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, Ep = "ag-cell-range-selected", IHe = "ag-cell-range-chart", OHe = "ag-cell-range-single-cell", LHe = "ag-cell-range-chart-category", FHe = "ag-cell-range-handle", NHe = "ag-cell-range-top", kHe = "ag-cell-range-right", VHe = "ag-cell-range-bottom", BHe = "ag-cell-range-left", $He = class {
  constructor(e, t) {
    this.beans = e, this.rangeService = e.rangeService, this.selectionHandleFactory = e.selectionHandleFactory, this.cellCtrl = t;
  }
  setComp(e, t) {
    this.cellComp = e, this.eGui = t, this.onRangeSelectionChanged();
  }
  onRangeSelectionChanged() {
    this.cellComp && (this.rangeCount = this.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()), this.hasChartRange = this.getHasChartRange(), this.cellComp.addOrRemoveCssClass(Ep, this.rangeCount !== 0), this.cellComp.addOrRemoveCssClass(`${Ep}-1`, this.rangeCount === 1), this.cellComp.addOrRemoveCssClass(`${Ep}-2`, this.rangeCount === 2), this.cellComp.addOrRemoveCssClass(`${Ep}-3`, this.rangeCount === 3), this.cellComp.addOrRemoveCssClass(`${Ep}-4`, this.rangeCount >= 4), this.cellComp.addOrRemoveCssClass(IHe, this.hasChartRange), tS(this.eGui, this.rangeCount > 0 ? !0 : void 0), this.cellComp.addOrRemoveCssClass(OHe, this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle());
  }
  updateRangeBorders() {
    const e = this.getRangeBorders(), t = this.isSingleCell(), r = !t && e.top, n = !t && e.right, i = !t && e.bottom, o = !t && e.left;
    this.cellComp.addOrRemoveCssClass(NHe, r), this.cellComp.addOrRemoveCssClass(kHe, n), this.cellComp.addOrRemoveCssClass(VHe, i), this.cellComp.addOrRemoveCssClass(BHe, o);
  }
  isSingleCell() {
    const { rangeService: e } = this.beans;
    return this.rangeCount === 1 && !!e && !e.isMoreThanOneCell();
  }
  getHasChartRange() {
    const { rangeService: e } = this.beans;
    if (!this.rangeCount || !e)
      return !1;
    const t = e.getCellRanges();
    return t.length > 0 && t.every((r) => Lc([
      1,
      0
      /* VALUE */
    ], r.type));
  }
  updateRangeBordersIfRangeCount() {
    this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle());
  }
  getRangeBorders() {
    const e = this.beans.gos.get("enableRtl");
    let t = !1, r = !1, n = !1, i = !1;
    const o = this.cellCtrl.getCellPosition().column, a = this.beans.visibleColsService;
    let s, l;
    e ? (s = a.getColAfter(o), l = a.getColBefore(o)) : (s = a.getColBefore(o), l = a.getColAfter(o));
    const u = this.rangeService.getCellRanges().filter((c) => this.rangeService.isCellInSpecificRange(this.cellCtrl.getCellPosition(), c));
    s || (i = !0), l || (r = !0);
    for (let c = 0; c < u.length && !(t && r && n && i); c++) {
      const d = u[c], h = this.rangeService.getRangeStartRow(d), f = this.rangeService.getRangeEndRow(d);
      !t && this.beans.rowPositionUtils.sameRow(h, this.cellCtrl.getCellPosition()) && (t = !0), !n && this.beans.rowPositionUtils.sameRow(f, this.cellCtrl.getCellPosition()) && (n = !0), !i && s && d.columns.indexOf(s) < 0 && (i = !0), !r && l && d.columns.indexOf(l) < 0 && (r = !0);
    }
    return { top: t, right: r, bottom: n, left: i };
  }
  refreshHandle() {
    if (this.beans.context.isDestroyed())
      return;
    const e = this.shouldHaveSelectionHandle();
    this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass(FHe, !!this.selectionHandle);
  }
  shouldHaveSelectionHandle() {
    const e = this.beans.gos, t = this.rangeService.getCellRanges(), r = t.length;
    if (this.rangeCount < 1 || r < 1)
      return !1;
    const n = gr(t), i = this.cellCtrl.getCellPosition(), o = e.get("enableFillHandle") && !this.cellCtrl.isSuppressFillHandle(), a = e.get("enableRangeHandle");
    let s = r === 1 && !this.cellCtrl.isEditing() && (o || a);
    if (this.hasChartRange) {
      const u = t[0].type === 1 && this.rangeService.isCellInSpecificRange(i, t[0]);
      this.cellComp.addOrRemoveCssClass(LHe, u), s = n.type === 0;
    }
    return s && n.endRow != null && this.rangeService.isContiguousRange(n) && this.rangeService.isBottomRightCell(n, i);
  }
  addSelectionHandle() {
    const e = this.beans.gos, t = gr(this.rangeService.getCellRanges()).type, n = e.get("enableFillHandle") && dr(t) ? 0 : 1;
    this.selectionHandle && this.selectionHandle.getType() !== n && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), this.selectionHandle || (this.selectionHandle = this.selectionHandleFactory.createSelectionHandle(n)), this.selectionHandle.refresh(this.cellCtrl);
  }
  destroy() {
    this.beans.context.destroyBean(this.selectionHandle);
  }
}, HHe = "ag-cell", GHe = "ag-cell-auto-height", zHe = "ag-cell-normal-height", WHe = "ag-cell-focus", jHe = "ag-cell-first-right-pinned", UHe = "ag-cell-last-left-pinned", KHe = "ag-cell-not-inline-editing", YHe = "ag-column-hover", qHe = "ag-cell-wrap-text", XHe = 0, Gq = class pP extends Se {
  constructor(t, r, n, i) {
    super(), this.column = t, this.rowNode = r, this.beans = n, this.rowCtrl = i, this.cellRangeFeature = null, this.cellPositionFeature = null, this.cellCustomStyleFeature = null, this.tooltipFeature = null, this.cellMouseListenerFeature = null, this.cellKeyboardListenerFeature = null, this.suppressRefreshCell = !1, this.onCellCompAttachedFuncs = [], this.instanceId = t.getId() + "-" + XHe++, this.colIdSanitised = hs(this.column.getId()), n.gos.get("suppressCellFocus") || (this.tabIndex = -1), this.createCellPosition(), this.addFeatures(), this.updateAndFormatValue(!1);
  }
  shouldRestoreFocus() {
    return this.beans.focusService.shouldRestoreFocus(this.cellPosition);
  }
  addFeatures() {
    this.cellPositionFeature = new AHe(this, this.beans), this.addDestroyFunc(() => {
      var r;
      (r = this.cellPositionFeature) == null || r.destroy(), this.cellPositionFeature = null;
    }), this.cellCustomStyleFeature = new PHe(this, this.beans), this.addDestroyFunc(() => {
      var r;
      (r = this.cellCustomStyleFeature) == null || r.destroy(), this.cellCustomStyleFeature = null;
    }), this.cellMouseListenerFeature = new DHe(this, this.beans, this.column), this.addDestroyFunc(() => {
      var r;
      (r = this.cellMouseListenerFeature) == null || r.destroy(), this.cellMouseListenerFeature = null;
    }), this.cellKeyboardListenerFeature = new MHe(
      this,
      this.beans,
      this.column,
      this.rowNode,
      this.rowCtrl
    ), this.addDestroyFunc(() => {
      var r;
      (r = this.cellKeyboardListenerFeature) == null || r.destroy(), this.cellKeyboardListenerFeature = null;
    }), this.column.isTooltipEnabled() && (this.enableTooltipFeature(), this.addDestroyFunc(() => {
      this.disableTooltipFeature();
    })), this.beans.rangeService && this.beans.gos.get("enableRangeSelection") && (this.cellRangeFeature = new $He(this.beans, this), this.addDestroyFunc(() => {
      var r;
      (r = this.cellRangeFeature) == null || r.destroy(), this.cellRangeFeature = null;
    }));
  }
  enableTooltipFeature(t, r) {
    const n = () => {
      const a = this.column.getColDef(), s = this.rowNode.data;
      if (a.tooltipField && ke(s))
        return mg(s, a.tooltipField, this.column.isTooltipFieldContainsDots());
      const l = a.tooltipValueGetter;
      return l ? l(
        this.beans.gos.addGridCommonParams({
          location: "cell",
          colDef: this.column.getColDef(),
          column: this.column,
          rowIndex: this.cellPosition.rowIndex,
          node: this.rowNode,
          data: this.rowNode.data,
          value: this.value,
          valueFormatted: this.valueFormatted
        })
      ) : null;
    }, i = this.beans.gos.get("tooltipShowMode") === "whenTruncated";
    !r && i && !this.isCellRenderer() && (r = () => {
      const a = this.getGui(), s = a.children.length === 0 ? a : a.querySelector(".ag-cell-value");
      return s ? s.scrollWidth > s.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getRowIndex: () => this.cellPosition.rowIndex,
      getRowNode: () => this.rowNode,
      getGui: () => this.getGui(),
      getLocation: () => "cell",
      getTooltipValue: t != null ? () => t : n,
      // this makes no sense, why is the cell formatted value passed to the tooltip???
      getValueFormatted: () => this.valueFormatted,
      shouldDisplayTooltip: r
    };
    this.tooltipFeature = new If(o, this.beans);
  }
  disableTooltipFeature() {
    this.tooltipFeature && (this.tooltipFeature.destroy(), this.tooltipFeature = null);
  }
  setComp(t, r, n, i, o) {
    var a, s, l, u;
    this.cellComp = t, this.eGui = r, this.printLayout = i, this.addDomData(), this.onCellFocused(this.focusEventToRestore), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAutoHeight(n), this.refreshFirstAndLastStyles(), this.refreshAriaColIndex(), (a = this.cellPositionFeature) == null || a.setComp(r), (s = this.cellCustomStyleFeature) == null || s.setComp(t), (l = this.tooltipFeature) == null || l.refreshToolTip(), (u = this.cellKeyboardListenerFeature) == null || u.setComp(this.eGui), this.cellRangeFeature && this.cellRangeFeature.setComp(t, r), o && this.isCellEditable() ? this.startEditing() : this.showValue(), this.onCellCompAttachedFuncs.length && (this.onCellCompAttachedFuncs.forEach((c) => c()), this.onCellCompAttachedFuncs = []);
  }
  setupAutoHeight(t) {
    if (this.isAutoHeight = this.column.isAutoHeight(), !this.isAutoHeight || !t)
      return;
    const r = t.parentElement, n = this.beans.gos.getRowHeightForNode(this.rowNode).height, i = (s) => {
      if (this.editing || !this.isAlive())
        return;
      const { paddingTop: l, paddingBottom: u, borderBottomWidth: c, borderTopWidth: d } = pd(r), h = l + u + c + d, p = t.offsetHeight + h;
      if (s < 5) {
        const v = this.beans.gos.getDocument(), m = !v || !v.contains(t), y = p == 0;
        if (m || y) {
          window.setTimeout(() => i(s + 1), 0);
          return;
        }
      }
      const g = Math.max(p, n);
      this.rowNode.setRowAutoHeight(g, this.column);
    }, o = () => i(0);
    o();
    const a = this.beans.resizeObserverService.observeResize(t, o);
    this.addDestroyFunc(() => {
      a(), this.rowNode.setRowAutoHeight(void 0, this.column);
    });
  }
  getCellAriaRole() {
    return this.column.getColDef().cellAriaRole ?? "gridcell";
  }
  getInstanceId() {
    return this.instanceId;
  }
  getColumnIdSanitised() {
    return this.colIdSanitised;
  }
  getTabIndex() {
    return this.tabIndex;
  }
  isCellRenderer() {
    const t = this.column.getColDef();
    return t.cellRenderer != null || t.cellRendererSelector != null;
  }
  getValueToDisplay() {
    return this.valueFormatted ?? this.value;
  }
  showValue(t = !1) {
    var i;
    const r = this.getValueToDisplay();
    let n;
    if (this.rowNode.stub) {
      const o = this.createCellRendererParams();
      n = this.beans.userComponentFactory.getLoadingCellRendererDetails(
        this.column.getColDef(),
        o
      );
    } else if (this.isCellRenderer()) {
      const o = this.createCellRendererParams();
      n = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), o);
    }
    this.cellComp.setRenderDetails(n, r, t), (i = this.cellRangeFeature) == null || i.refreshHandle();
  }
  setupControlComps() {
    const t = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(t.checkboxSelection), this.includeRowDrag = this.isIncludeControl(t.rowDrag), this.includeDndSource = this.isIncludeControl(t.dndSource), this.cellComp.setIncludeSelection(this.includeSelection), this.cellComp.setIncludeDndSource(this.includeDndSource), this.cellComp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  isIncludeControl(t) {
    return this.rowNode.rowPinned != null ? !1 : typeof t == "function" || t === !0;
  }
  refreshShouldDestroy() {
    const t = this.column.getColDef(), r = this.includeSelection != this.isIncludeControl(t.checkboxSelection), n = this.includeRowDrag != this.isIncludeControl(t.rowDrag), i = this.includeDndSource != this.isIncludeControl(t.dndSource), o = this.isAutoHeight != this.column.isAutoHeight();
    return r || n || i || o;
  }
  // either called internally if single cell editing, or called by rowRenderer if row editing
  startEditing(t = null, r = !1, n = null) {
    const { editService: i } = this.beans;
    if (!(!this.isCellEditable() || this.editing || !i)) {
      if (!this.cellComp) {
        this.onCellCompAttachedFuncs.push(() => {
          this.startEditing(t, r, n);
        });
        return;
      }
      i.startEditing(this, t, r, n);
    }
  }
  setEditing(t, r) {
    var n;
    this.editCompDetails = r, this.editing !== t && (this.editing = t, (n = this.cellRangeFeature) == null || n.refreshHandle());
  }
  // pass in 'true' to cancel the editing.
  stopRowOrCellEdit(t = !1) {
    this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.stopEditing(t) : this.stopEditing(t);
  }
  onPopupEditorClosed() {
    this.editing && this.stopEditingAndFocus();
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(t = !1) {
    const { editService: r } = this.beans;
    return !this.editing || !r ? !1 : r.stopEditing(this, t);
  }
  createCellRendererParams() {
    return this.beans.gos.addGridCommonParams({
      value: this.value,
      valueFormatted: this.valueFormatted,
      getValue: () => this.rowNode.getValueFromValueService(this.column),
      setValue: (r) => this.beans.valueService.setValue(this.rowNode, this.column, r),
      formatValue: this.formatValue.bind(this),
      data: this.rowNode.data,
      node: this.rowNode,
      pinned: this.column.getPinned(),
      colDef: this.column.getColDef(),
      column: this.column,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: this.getGui(),
      eParentOfValue: this.cellComp.getParentOfValue(),
      registerRowDragger: (r, n, i, o) => this.registerRowDragger(r, n, o),
      setTooltip: (r, n) => {
        var i;
        this.tooltipFeature && this.disableTooltipFeature(), this.enableTooltipFeature(r, n), (i = this.tooltipFeature) == null || i.refreshToolTip();
      }
    });
  }
  setFocusOutOnEditor() {
    var t;
    this.editing && ((t = this.beans.editService) == null || t.setFocusOutOnEditor(this));
  }
  setFocusInOnEditor() {
    var t;
    this.editing && ((t = this.beans.editService) == null || t.setFocusInOnEditor(this));
  }
  onCellChanged(t) {
    t.column === this.column && this.refreshCell({});
  }
  refreshOrDestroyCell(t) {
    var r;
    this.refreshShouldDestroy() ? (r = this.rowCtrl) == null || r.recreateCell(this) : this.refreshCell(t);
  }
  // + stop editing {forceRefresh: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell(t) {
    var c, d, h, f, p;
    if (this.suppressRefreshCell || this.editing)
      return;
    const r = this.column.getColDef(), n = t != null && !!t.newData, i = t != null && !!t.suppressFlash || !!r.suppressCellFlash, o = r.field == null && r.valueGetter == null && r.showRowGroup == null, a = t && t.forceRefresh || o || n, s = !!this.cellComp, l = this.updateAndFormatValue(s), u = a || l;
    if (s) {
      if (u) {
        this.showValue(n);
        const g = (c = this.beans.filterManager) == null ? void 0 : c.isSuppressFlashingCellsBecauseFiltering();
        !i && !g && (this.beans.gos.get("enableCellChangeFlash") || r.enableCellChangeFlash) && this.flashCell(), (d = this.cellCustomStyleFeature) == null || d.applyUserStyles(), (h = this.cellCustomStyleFeature) == null || h.applyClassesFromColDef();
      }
      (f = this.tooltipFeature) == null || f.refreshToolTip(), (p = this.cellCustomStyleFeature) == null || p.applyCellClassRules();
    }
  }
  // cell editors call this, when they want to stop for reasons other
  // than what we pick up on. eg selecting from a dropdown ends editing.
  stopEditingAndFocus(t = !1, r = !1) {
    var n;
    (n = this.beans.editService) == null || n.stopEditingAndFocus(this, t, r);
  }
  // user can also call this via API
  flashCell(t) {
    const r = (t == null ? void 0 : t.flashDuration) ?? (t == null ? void 0 : t.flashDelay), n = (t == null ? void 0 : t.fadeDuration) ?? (t == null ? void 0 : t.fadeDelay);
    this.animateCell("data-changed", r, n);
  }
  animateCell(t, r, n) {
    if (!this.cellComp)
      return;
    const i = `ag-cell-${t}`, o = `ag-cell-${t}-animation`, { gos: a } = this.beans;
    r || (r = a.get("cellFlashDuration")), ke(n) || (n = a.get("cellFadeDuration")), this.cellComp.addOrRemoveCssClass(i, !0), this.cellComp.addOrRemoveCssClass(o, !1), this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        this.isAlive() && (this.cellComp.addOrRemoveCssClass(i, !1), this.cellComp.addOrRemoveCssClass(o, !0), this.eGui.style.transition = `background-color ${n}ms`, window.setTimeout(() => {
          this.isAlive() && (this.cellComp.addOrRemoveCssClass(o, !1), this.eGui.style.transition = "");
        }, n));
      }, r);
    });
  }
  onFlashCells(t) {
    if (!this.cellComp)
      return;
    const r = this.beans.cellPositionUtils.createId(this.getCellPosition());
    t.cells[r] && this.animateCell("highlight");
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  isSuppressFillHandle() {
    return this.column.isSuppressFillHandle();
  }
  formatValue(t) {
    return this.callValueFormatter(t) ?? t;
  }
  callValueFormatter(t) {
    return this.beans.valueService.formatValue(this.column, this.rowNode, t);
  }
  updateAndFormatValue(t) {
    const r = this.value, n = this.valueFormatted;
    return this.value = this.rowNode.getValueFromValueService(this.column), this.valueFormatted = this.callValueFormatter(this.value), t ? !this.valuesAreEqual(r, this.value) || this.valueFormatted != n : !0;
  }
  valuesAreEqual(t, r) {
    const n = this.column.getColDef();
    return n.equals ? n.equals(t, r) : t === r;
  }
  getComp() {
    return this.cellComp;
  }
  getValue() {
    return this.value;
  }
  addDomData() {
    const t = this.getGui();
    this.beans.gos.setDomData(t, pP.DOM_DATA_KEY_CELL_CTRL, this), this.addDestroyFunc(() => this.beans.gos.setDomData(t, pP.DOM_DATA_KEY_CELL_CTRL, null));
  }
  createEvent(t, r) {
    return this.beans.gos.addGridCommonParams({
      type: r,
      node: this.rowNode,
      data: this.rowNode.data,
      value: this.value,
      column: this.column,
      colDef: this.column.getColDef(),
      rowPinned: this.rowNode.rowPinned,
      event: t,
      rowIndex: this.rowNode.rowIndex
    });
  }
  processCharacter(t) {
    var r;
    (r = this.cellKeyboardListenerFeature) == null || r.processCharacter(t);
  }
  onKeyDown(t) {
    var r;
    (r = this.cellKeyboardListenerFeature) == null || r.onKeyDown(t);
  }
  onMouseEvent(t, r) {
    var n;
    (n = this.cellMouseListenerFeature) == null || n.onMouseEvent(t, r);
  }
  getGui() {
    return this.eGui;
  }
  getColSpanningList() {
    return this.cellPositionFeature.getColSpanningList();
  }
  onLeftChanged() {
    var t;
    this.cellComp && ((t = this.cellPositionFeature) == null || t.onLeftChanged());
  }
  onDisplayedColumnsChanged() {
    this.eGui && (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles());
  }
  refreshFirstAndLastStyles() {
    const { cellComp: t, column: r, beans: n } = this;
    Aq(t, r, n.visibleColsService);
  }
  refreshAriaColIndex() {
    const t = this.beans.visibleColsService.getAriaColIndex(this.column);
    jY(this.getGui(), t);
  }
  isSuppressNavigable() {
    return this.column.isSuppressNavigable(this.rowNode);
  }
  onWidthChanged() {
    var t;
    return (t = this.cellPositionFeature) == null ? void 0 : t.onWidthChanged();
  }
  getColumn() {
    return this.column;
  }
  getRowNode() {
    return this.rowNode;
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getCellPosition() {
    return this.cellPosition;
  }
  isEditing() {
    return this.editing;
  }
  // called by rowRenderer when user navigates via tab key
  startRowOrCellEdit(t, r = null) {
    if (!this.cellComp) {
      this.onCellCompAttachedFuncs.push(() => {
        this.startRowOrCellEdit(t, r);
      });
      return;
    }
    this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.startRowEditing(t, this) : this.startEditing(t, !0, r);
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getRowPosition() {
    return {
      rowIndex: this.cellPosition.rowIndex,
      rowPinned: this.cellPosition.rowPinned
    };
  }
  updateRangeBordersIfRangeCount() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.updateRangeBordersIfRangeCount();
  }
  onRangeSelectionChanged() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
  }
  isRangeSelectionEnabled() {
    return this.cellRangeFeature != null;
  }
  focusCell(t = !1) {
    this.beans.focusService.setFocusedCell({
      rowIndex: this.getCellPosition().rowIndex,
      column: this.column,
      rowPinned: this.rowNode.rowPinned,
      forceBrowserFocus: t
    });
  }
  onRowIndexChanged() {
    this.createCellPosition(), this.onCellFocused(), this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
  }
  onFirstRightPinnedChanged() {
    if (!this.cellComp)
      return;
    const t = this.column.isFirstRightPinned();
    this.cellComp.addOrRemoveCssClass(jHe, t);
  }
  onLastLeftPinnedChanged() {
    if (!this.cellComp)
      return;
    const t = this.column.isLastLeftPinned();
    this.cellComp.addOrRemoveCssClass(UHe, t);
  }
  onCellFocused(t) {
    if (this.beans.gos.get("suppressCellFocus"))
      return;
    const r = this.beans.focusService.isCellFocused(this.cellPosition);
    if (!this.cellComp) {
      r && (t != null && t.forceBrowserFocus) && (this.focusEventToRestore = t);
      return;
    }
    if (this.focusEventToRestore = void 0, this.cellComp.addOrRemoveCssClass(WHe, r), r && t && t.forceBrowserFocus) {
      let i = this.cellComp.getFocusableElement();
      if (this.editing) {
        const o = this.beans.focusService.findFocusableElements(i, null, !0);
        o.length && (i = o[0]);
      }
      i.focus({ preventScroll: !!t.preventScrollOnBrowserFocus });
    }
    const n = this.beans.gos.get("editType") === "fullRow";
    !r && !n && this.editing && this.stopRowOrCellEdit(), r && this.rowCtrl.announceDescription();
  }
  createCellPosition() {
    this.cellPosition = {
      rowIndex: this.rowNode.rowIndex,
      rowPinned: Fc(this.rowNode.rowPinned),
      column: this.column
    };
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    this.cellComp.addOrRemoveCssClass(HHe, !0), this.cellComp.addOrRemoveCssClass(KHe, !0);
    const t = this.column.isAutoHeight() == !0;
    this.cellComp.addOrRemoveCssClass(GHe, t), this.cellComp.addOrRemoveCssClass(zHe, !t);
  }
  onColumnHover() {
    if (!this.cellComp || !this.beans.gos.get("columnHoverHighlight"))
      return;
    const t = this.beans.columnHoverService.isHovered(this.column);
    this.cellComp.addOrRemoveCssClass(YHe, t);
  }
  onColDefChanged() {
    var r;
    if (!this.cellComp)
      return;
    this.column.isTooltipEnabled() ? (this.disableTooltipFeature(), this.enableTooltipFeature()) : this.disableTooltipFeature(), this.setWrapText(), this.editing ? (r = this.beans.editService) == null || r.handleColDefChanged(this) : this.refreshOrDestroyCell({ forceRefresh: !0, suppressFlash: !0 });
  }
  setWrapText() {
    const t = this.column.getColDef().wrapText == !0;
    this.cellComp.addOrRemoveCssClass(qHe, t);
  }
  dispatchCellContextMenuEvent(t) {
    const r = this.column.getColDef(), n = this.createEvent(t, "cellContextMenu");
    this.beans.eventService.dispatchEvent(n), r.onCellContextMenu && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        r.onCellContextMenu(n);
      });
    }, 0);
  }
  getCellRenderer() {
    return this.cellComp ? this.cellComp.getCellRenderer() : null;
  }
  getCellEditor() {
    return this.cellComp ? this.cellComp.getCellEditor() : null;
  }
  destroy() {
    this.onCellCompAttachedFuncs = [], super.destroy();
  }
  createSelectionCheckbox() {
    const t = new _He();
    return this.beans.context.createBean(t), t.init({ rowNode: this.rowNode, column: this.column }), t;
  }
  createDndSource() {
    const t = new THe(this.rowNode, this.column, this.eGui);
    return this.beans.context.createBean(t), t;
  }
  registerRowDragger(t, r, n) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(t, r);
      return;
    }
    const i = this.createRowDragComp(t, r, n);
    i && (this.customRowDragComp = i, this.addDestroyFunc(() => {
      this.beans.context.destroyBean(i), this.customRowDragComp = null;
    }));
  }
  createRowDragComp(t, r, n) {
    const i = this.beans.gos.get("pagination"), o = this.beans.gos.get("rowDragManaged"), a = this.beans.gos.isRowModelType("clientSide");
    if (o) {
      if (!a) {
        Te("managed row dragging is only allowed in the Client Side Row Model");
        return;
      }
      if (i) {
        Te("managed row dragging is not possible when doing pagination");
        return;
      }
    }
    const s = new cP(
      () => this.value,
      this.rowNode,
      this.column,
      t,
      r,
      n
    );
    return this.beans.context.createBean(s), s;
  }
  setSuppressRefreshCell(t) {
    this.suppressRefreshCell = t;
  }
  getEditCompDetails() {
    return this.editCompDetails;
  }
};
Gq.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
var kc = Gq, ZHe = 0, zq = class gP extends Se {
  constructor(t, r, n, i, o) {
    var a;
    super(), this.allRowGuis = [], this.active = !0, this.centerCellCtrls = { list: [], map: {} }, this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} }, this.slideInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.fadeInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.rowDragComps = [], this.lastMouseDownOnDragger = !1, this.emptyStyle = {}, this.updateColumnListsPending = !1, this.rowId = null, this.businessKeySanitised = null, this.beans = r, this.gos = r.gos, this.rowNode = t, this.paginationPage = ((a = r.paginationService) == null ? void 0 : a.getCurrentPage()) ?? 0, this.useAnimationFrameForCreate = i, this.printLayout = o, this.suppressRowTransform = this.gos.get("suppressRowTransform"), this.instanceId = t.id + "-" + ZHe++, this.rowId = hs(t.id), this.initRowBusinessKey(), this.rowFocused = r.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = r.rowCssClassCalculator.calculateRowLevel(this.rowNode), this.setRowType(), this.setAnimateFlags(n), this.rowStyles = this.processStylesFromGridOptions(), this.isFullWidth() && !this.gos.get("suppressCellFocus") && (this.tabIndex = -1), this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode"), this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc != "function")
      return;
    const t = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKeySanitised = hs(t);
  }
  getRowId() {
    return this.rowId;
  }
  getRowStyles() {
    return this.rowStyles;
  }
  getTabIndex() {
    return this.tabIndex;
  }
  isSticky() {
    return this.rowNode.sticky;
  }
  getInstanceId() {
    return this.instanceId;
  }
  updateGui(t, r) {
    t === "left" ? this.leftGui = r : t === "right" ? this.rightGui = r : t === "fullWidth" ? this.fullWidthGui = r : this.centerGui = r;
  }
  setComp(t, r, n) {
    const i = { rowComp: t, element: r, containerType: n };
    this.allRowGuis.push(i), this.updateGui(n, i), this.initialiseRowComp(i), this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned && this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
  }
  unsetComp(t) {
    this.allRowGuis = this.allRowGuis.filter((r) => r.containerType !== t), this.updateGui(t, void 0);
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(t) {
    const r = t ? "none" : "";
    this.allRowGuis.forEach((n) => n.element.style.display = r);
  }
  initialiseRowComp(t) {
    const r = this.gos;
    this.listenOnDomOrder(t), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights(), this.onRowHeightChanged(t), this.updateRowIndexes(t), this.setFocusedClasses(t), this.setStylesFromGridOptions(!1, t), r.isRowSelection() && this.rowNode.selectable && this.onRowSelected(t), this.updateColumnLists(!this.useAnimationFrameForCreate);
    const n = t.rowComp;
    this.getInitialRowClasses(t.containerType).forEach((o) => n.addOrRemoveCssClass(o, !0)), this.executeSlideAndFadeAnimations(t), this.rowNode.group && eS(t.element, this.rowNode.expanded == !0), this.setRowCompRowId(n), this.setRowCompRowBusinessKey(n), r.setDomData(t.element, gP.DOM_DATA_KEY_ROW_CTRL, this), this.addDestroyFunc(() => r.setDomData(t.element, gP.DOM_DATA_KEY_ROW_CTRL, null)), this.useAnimationFrameForCreate ? this.beans.animationFrameService.createTask(
      this.addHoverFunctionality.bind(this, t.element),
      this.rowNode.rowIndex,
      "createTasksP2"
    ) : this.addHoverFunctionality(t.element), this.isFullWidth() && this.setupFullWidth(t), r.get("rowDragEntireRow") && this.addRowDraggerToRow(t), this.useAnimationFrameForCreate && this.beans.animationFrameService.addDestroyTask(() => {
      this.isAlive() && t.rowComp.addOrRemoveCssClass("ag-after-created", !0);
    }), this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(t) {
    this.businessKeySanitised != null && t.setRowBusinessKey(this.businessKeySanitised);
  }
  getBusinessKey() {
    return this.businessKeySanitised;
  }
  setRowCompRowId(t) {
    this.rowId = hs(this.rowNode.id), this.rowId != null && t.setRowId(this.rowId);
  }
  executeSlideAndFadeAnimations(t) {
    const { containerType: r } = t;
    this.slideInAnimation[r] && (FH(() => {
      this.onTopChanged();
    }), this.slideInAnimation[r] = !1), this.fadeInAnimation[r] && (FH(() => {
      t.rowComp.addOrRemoveCssClass("ag-opacity-zero", !1);
    }), this.fadeInAnimation[r] = !1);
  }
  addRowDraggerToRow(t) {
    if (this.gos.get("enableRangeSelection")) {
      Te(
        "Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`"
      );
      return;
    }
    const r = this.beans.localeService.getLocaleTextFunc(), n = new cP(
      () => `1 ${r("rowDragRow", "row")}`,
      this.rowNode,
      void 0,
      t.element,
      void 0,
      !0
    ), i = this.createBean(n, this.beans.context);
    this.rowDragComps.push(i);
  }
  setupFullWidth(t) {
    const r = this.getPinnedForContainer(t.containerType);
    if (this.rowType == "FullWidthDetail" && !ci.__assertRegistered(
      "@ag-grid-enterprise/master-detail",
      "cell renderer 'agDetailCellRenderer' (for master detail)",
      this.beans.context.getGridId()
    ))
      return;
    const n = this.createFullWidthCompDetails(t.element, r);
    t.rowComp.showFullWidth(n);
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getFullWidthCellRenderers() {
    var t, r;
    return this.gos.get("embedFullWidthRows") ? this.allRowGuis.map((n) => {
      var i;
      return (i = n == null ? void 0 : n.rowComp) == null ? void 0 : i.getFullWidthCellRenderer();
    }) : [(r = (t = this.fullWidthGui) == null ? void 0 : t.rowComp) == null ? void 0 : r.getFullWidthCellRenderer()];
  }
  // use by autoWidthCalculator, as it clones the elements
  getCellElement(t) {
    const r = this.getCellCtrl(t);
    return r ? r.getGui() : null;
  }
  executeProcessRowPostCreateFunc() {
    const t = this.gos.getCallback("processRowPostCreate");
    if (!t || !this.areAllContainersReady())
      return;
    const r = {
      // areAllContainersReady asserts that centerGui is not null
      eRow: this.centerGui.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    t(r);
  }
  areAllContainersReady() {
    const t = !!this.leftGui || !this.beans.visibleColsService.isPinningLeft(), r = !!this.centerGui, n = !!this.rightGui || !this.beans.visibleColsService.isPinningRight();
    return t && r && n;
  }
  setRowType() {
    const t = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow"), r = this.rowNode.isFullWidthCell(), n = this.gos.get("masterDetail") && this.rowNode.detail, i = this.beans.columnModel.isPivotMode(), a = !!this.rowNode.group && !this.rowNode.footer && this.gos.isGroupUseEntireRow(i);
    t ? this.rowType = "FullWidthLoading" : n ? this.rowType = "FullWidthDetail" : r ? this.rowType = "FullWidth" : a ? this.rowType = "FullWidthGroup" : this.rowType = "Normal";
  }
  updateColumnLists(t = !1, r = !1) {
    if (this.isFullWidth())
      return;
    if (t || this.gos.get("suppressAnimationFrame") || this.printLayout) {
      this.updateColumnListsImpl(r);
      return;
    }
    this.updateColumnListsPending || (this.beans.animationFrameService.createTask(
      () => {
        this.active && this.updateColumnListsImpl(!0);
      },
      this.rowNode.rowIndex,
      "createTasksP1"
    ), this.updateColumnListsPending = !0);
  }
  createCellCtrls(t, r, n = null) {
    const i = {
      list: [],
      map: {}
    }, o = (a, s) => {
      i.list.push(s), i.map[a] = s;
    };
    return r.forEach((a) => {
      const s = a.getInstanceId();
      let l = t.map[s];
      l || (l = new kc(a, this.rowNode, this.beans, this)), o(s, l);
    }), t.list.forEach((a) => {
      if (i.map[a.getColumn().getInstanceId()] != null)
        return;
      if (!this.isCellEligibleToBeRemoved(a, n)) {
        o(a.getColumn().getInstanceId(), a);
        return;
      }
      a.destroy();
    }), i;
  }
  updateColumnListsImpl(t) {
    this.updateColumnListsPending = !1, this.createAllCellCtrls(), this.setCellCtrls(t);
  }
  setCellCtrls(t) {
    this.allRowGuis.forEach((r) => {
      const n = this.getCellCtrlsForContainer(r.containerType);
      r.rowComp.setCellCtrls(n, t);
    });
  }
  getCellCtrlsForContainer(t) {
    switch (t) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
    }
  }
  createAllCellCtrls() {
    const t = this.beans.columnViewportService, r = this.beans.visibleColsService;
    if (this.printLayout)
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, r.getAllCols()), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
    else {
      const n = t.getColsWithinViewport(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, n);
      const i = r.getLeftColsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, i, "left");
      const o = r.getRightColsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, o, "right");
    }
  }
  isCellEligibleToBeRemoved(t, r) {
    if (t.getColumn().getPinned() != r)
      return !0;
    const a = t.isEditing(), s = this.beans.focusService.isCellFocused(t.getCellPosition());
    if (a || s) {
      const u = t.getColumn();
      return !(this.beans.visibleColsService.getAllCols().indexOf(u) >= 0);
    }
    return !0;
  }
  getDomOrder() {
    return this.gos.get("ensureDomOrder") || this.gos.isDomLayout("print");
  }
  listenOnDomOrder(t) {
    const r = () => {
      t.rowComp.setDomOrder(this.getDomOrder());
    };
    this.addManagedPropertyListener("domLayout", r), this.addManagedPropertyListener("ensureDomOrder", r);
  }
  setAnimateFlags(t) {
    if (this.isSticky() || !t)
      return;
    const r = ke(this.rowNode.oldRowTop), n = this.beans.visibleColsService.isPinningLeft(), i = this.beans.visibleColsService.isPinningRight();
    if (r) {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.slideInAnimation.fullWidth = !0;
        return;
      }
      this.slideInAnimation.center = !0, this.slideInAnimation.left = n, this.slideInAnimation.right = i;
    } else {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.fadeInAnimation.fullWidth = !0;
        return;
      }
      this.fadeInAnimation.center = !0, this.fadeInAnimation.left = n, this.fadeInAnimation.right = i;
    }
  }
  isEditing() {
    return this.editingRow;
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const t = (s, l) => s ? s.rowComp.refreshFullWidth(() => this.createFullWidthCompDetails(s.element, l).params) : !0, r = t(this.fullWidthGui, null), n = t(this.centerGui, null), i = t(this.leftGui, "left"), o = t(this.rightGui, "right");
    return r && n && i && o;
  }
  addListeners() {
    this.addManagedListeners(this.rowNode, {
      heightChanged: () => this.onRowHeightChanged(),
      rowSelected: () => this.onRowSelected(),
      rowIndexChanged: this.onRowIndexChanged.bind(this),
      topChanged: this.onTopChanged.bind(this),
      expandedChanged: this.updateExpandedCss.bind(this),
      hasChildrenChanged: this.updateExpandedCss.bind(this)
    }), this.rowNode.detail && this.addManagedListeners(this.rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) }), this.addManagedListeners(this.rowNode, {
      dataChanged: this.onRowNodeDataChanged.bind(this),
      cellChanged: this.postProcessCss.bind(this),
      rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
      draggingChanged: this.postProcessRowDragging.bind(this),
      uiLevelChanged: this.onUiLevelChanged.bind(this)
    }), this.addManagedListeners(this.beans.eventService, {
      paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
      heightScaleChanged: this.onTopChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
      cellFocused: this.onCellFocusChanged.bind(this),
      cellFocusCleared: this.onCellFocusChanged.bind(this),
      paginationChanged: this.onPaginationChanged.bind(this),
      modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
      columnMoved: () => this.updateColumnLists()
    }), this.addDestroyFunc(() => {
      this.destroyBeans(this.rowDragComps, this.beans.context), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context));
    }), this.addManagedPropertyListeners(["rowDragEntireRow"], () => {
      if (this.gos.get("rowDragEntireRow")) {
        this.allRowGuis.forEach((r) => {
          this.addRowDraggerToRow(r);
        });
        return;
      }
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context);
    }), this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListeners(this.rowNode, {
      rowIndexChanged: () => {
        this.getAllCellCtrls().forEach((t) => t.onRowIndexChanged());
      },
      cellChanged: (t) => {
        this.getAllCellCtrls().forEach((r) => r.onCellChanged(t));
      }
    });
  }
  onRowNodeDataChanged(t) {
    if (this.isFullWidth() !== !!this.rowNode.isFullWidthCell()) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      this.refreshFullWidth() || this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach(
      (n) => n.refreshCell({
        suppressFlash: !t.update,
        newData: !t.update
      })
    ), this.allRowGuis.forEach((n) => {
      this.setRowCompRowId(n.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(n.rowComp);
    }), this.onRowSelected(), this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions(!0), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const t = this.rowNode.highlighted;
    this.allRowGuis.forEach((r) => {
      const n = t === 0, i = t === 1;
      r.rowComp.addOrRemoveCssClass("ag-row-highlight-above", n), r.rowComp.addOrRemoveCssClass("ag-row-highlight-below", i);
    });
  }
  postProcessRowDragging() {
    const t = this.rowNode.dragging;
    this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass("ag-row-dragging", t));
  }
  updateExpandedCss() {
    const t = this.rowNode.isExpandable(), r = this.rowNode.expanded == !0;
    this.allRowGuis.forEach((n) => {
      n.rowComp.addOrRemoveCssClass("ag-row-group", t), n.rowComp.addOrRemoveCssClass("ag-row-group-expanded", t && r), n.rowComp.addOrRemoveCssClass("ag-row-group-contracted", t && !r), eS(n.element, t && r);
    });
  }
  onDisplayedColumnsChanged() {
    this.updateColumnLists(!0), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights();
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(!1, !0);
  }
  getRowPosition() {
    return {
      rowPinned: Fc(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  onKeyboardNavigate(t) {
    const r = this.allRowGuis.find(
      (l) => l.element.contains(t.target)
    );
    if (!((r ? r.element : null) === t.target))
      return;
    const o = this.rowNode, a = this.beans.focusService.getFocusedCell(), s = {
      rowIndex: o.rowIndex,
      rowPinned: o.rowPinned,
      column: a && a.column
    };
    this.beans.navigationService.navigateToNextCell(t, t.key, s, !0), t.preventDefault();
  }
  onTabKeyDown(t) {
    if (t.defaultPrevented || Yl(t))
      return;
    const r = this.allRowGuis.find(
      (a) => a.element.contains(t.target)
    ), n = r ? r.element : null, i = n === t.target;
    let o = null;
    i || (o = this.beans.focusService.findNextFocusableElement(
      n,
      !1,
      t.shiftKey
    )), (this.isFullWidth() && i || !o) && this.beans.navigationService.onTabKeyDown(this, t);
  }
  getFullWidthElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : null;
  }
  getRowYPosition() {
    var r;
    const t = (r = this.allRowGuis.find((n) => ys(n.element))) == null ? void 0 : r.element;
    return t ? t.getBoundingClientRect().top : 0;
  }
  onFullWidthRowFocused(t) {
    var o;
    const r = this.rowNode, n = t ? this.isFullWidth() && t.rowIndex === r.rowIndex && t.rowPinned == r.rowPinned : !1, i = this.fullWidthGui ? this.fullWidthGui.element : (o = this.centerGui) == null ? void 0 : o.element;
    i && (i.classList.toggle("ag-full-width-focus", n), n && (t != null && t.forceBrowserFocus) && i.focus({ preventScroll: !0 }));
  }
  recreateCell(t) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, t), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, t), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, t), t.destroy(), this.updateColumnLists();
  }
  removeCellCtrl(t, r) {
    const n = {
      list: [],
      map: {}
    };
    return t.list.forEach((i) => {
      i !== r && (n.list.push(i), n.map[i.getColumn().getInstanceId()] = i);
    }), n;
  }
  onMouseEvent(t, r) {
    switch (t) {
      case "dblclick":
        this.onRowDblClick(r);
        break;
      case "click":
        this.onRowClick(r);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(r);
        break;
    }
  }
  createRowEvent(t, r) {
    return this.gos.addGridCommonParams({
      type: t,
      node: this.rowNode,
      data: this.rowNode.data,
      rowIndex: this.rowNode.rowIndex,
      rowPinned: this.rowNode.rowPinned,
      event: r
    });
  }
  createRowEventWithSource(t, r) {
    const n = this.createRowEvent(t, r);
    return n.source = this, n;
  }
  onRowDblClick(t) {
    if (Yl(t))
      return;
    const r = this.createRowEventWithSource("rowDoubleClicked", t);
    this.beans.eventService.dispatchEvent(r);
  }
  onRowMouseDown(t) {
    if (this.lastMouseDownOnDragger = Lh(t.target, "ag-row-drag", 3), !this.isFullWidth())
      return;
    const r = this.rowNode, n = this.beans.visibleColsService;
    this.beans.rangeService && this.beans.rangeService.removeAllCellRanges();
    const i = this.getFullWidthElement(), o = t.target;
    let a = !0;
    i && i.contains(o) && sI(o) && (a = !1), this.beans.focusService.setFocusedCell({
      rowIndex: r.rowIndex,
      column: n.getAllCols()[0],
      rowPinned: r.rowPinned,
      forceBrowserFocus: a
    });
  }
  onRowClick(t) {
    if (Yl(t) || this.lastMouseDownOnDragger)
      return;
    const n = this.createRowEventWithSource("rowClicked", t);
    this.beans.eventService.dispatchEvent(n);
    const i = t.ctrlKey || t.metaKey, o = t.shiftKey;
    if (
      // we do not allow selecting groups by clicking (as the click here expands the group), or if it's a detail row,
      // so return if it's a group row
      this.gos.get("groupSelectsChildren") && this.rowNode.group || this.isRowSelectionBlocked() || // if click selection suppressed, do nothing
      this.gos.get("suppressRowClickSelection")
    )
      return;
    const s = this.gos.get("rowMultiSelectWithClick"), l = !this.gos.get("suppressRowDeselection"), u = "rowClicked";
    if (this.rowNode.isSelected())
      s ? this.rowNode.setSelectedParams({ newValue: !1, event: t, source: u }) : i ? l && this.rowNode.setSelectedParams({ newValue: !1, event: t, source: u }) : this.rowNode.setSelectedParams({
        newValue: !0,
        clearSelection: !o,
        rangeSelect: o,
        event: t,
        source: u
      });
    else {
      const c = s ? !1 : !i;
      this.rowNode.setSelectedParams({
        newValue: !0,
        clearSelection: c,
        rangeSelect: o,
        event: t,
        source: u
      });
    }
  }
  isRowSelectionBlocked() {
    return !this.rowNode.selectable || !!this.rowNode.rowPinned || !this.gos.isRowSelection();
  }
  setupDetailRowAutoHeight(t) {
    if (this.rowType !== "FullWidthDetail" || !this.gos.get("detailRowAutoHeight"))
      return;
    const r = () => {
      const i = t.clientHeight;
      if (i != null && i > 0) {
        const o = () => {
          this.rowNode.setRowHeight(i), this.beans.rowModel.getType() === "clientSide" ? this.beans.rowModel.onRowHeightChanged() : this.beans.rowModel.getType() === "serverSide" && this.beans.rowModel.onRowHeightChanged();
        };
        window.setTimeout(o, 0);
      }
    }, n = this.beans.resizeObserverService.observeResize(t, r);
    this.addDestroyFunc(n), r();
  }
  createFullWidthCompDetails(t, r) {
    const { gos: n, rowNode: i } = this, o = n.addGridCommonParams({
      fullWidth: !0,
      data: i.data,
      node: i,
      value: i.key,
      valueFormatted: i.key,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: t,
      eParentOfValue: t,
      pinned: r,
      addRenderedRowListener: this.addEventListener.bind(this),
      registerRowDragger: (s, l, u, c) => this.addFullWidthRowDragging(s, l, u, c),
      setTooltip: (s, l) => this.refreshRowTooltip(s, l)
    }), a = this.beans.userComponentFactory;
    switch (this.rowType) {
      case "FullWidthDetail":
        return a.getFullWidthDetailCellRendererDetails(o);
      case "FullWidthGroup":
        return a.getFullWidthGroupCellRendererDetails(o);
      case "FullWidthLoading":
        return a.getFullWidthLoadingCellRendererDetails(o);
      default:
        return a.getFullWidthCellRendererDetails(o);
    }
  }
  refreshRowTooltip(t, r) {
    if (!this.fullWidthGui)
      return;
    const n = {
      getGui: () => this.fullWidthGui.element,
      getTooltipValue: () => t,
      getLocation: () => "fullWidthRow",
      shouldDisplayTooltip: r
    };
    this.tooltipFeature && this.destroyBean(this.tooltipFeature, this.beans.context), this.tooltipFeature = this.createBean(new If(n, this.beans));
  }
  addFullWidthRowDragging(t, r, n = "", i) {
    if (!this.isFullWidth())
      return;
    const o = new cP(
      () => n,
      this.rowNode,
      void 0,
      t,
      r,
      i
    );
    this.createBean(o, this.beans.context), this.addDestroyFunc(() => {
      this.destroyBean(o, this.beans.context);
    });
  }
  onUiLevelChanged() {
    const t = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
    if (this.rowLevel != t) {
      const r = "ag-row-level-" + t, n = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((i) => {
        i.rowComp.addOrRemoveCssClass(r, !0), i.rowComp.addOrRemoveCssClass(n, !1);
      });
    }
    this.rowLevel = t;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBoundsService.getFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBoundsService.getLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const t = this.isFirstRowOnPage(), r = this.isLastRowOnPage();
    this.firstRowOnPage !== t && (this.firstRowOnPage = t, this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass("ag-row-first", t))), this.lastRowOnPage !== r && (this.lastRowOnPage = r, this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass("ag-row-last", r)));
  }
  stopEditing(t = !1) {
    var r;
    this.stoppingRowEdit || (r = this.beans.rowEditService) == null || r.stopEditing(this, t);
  }
  setInlineEditingCss(t) {
    this.allRowGuis.forEach((r) => {
      r.rowComp.addOrRemoveCssClass("ag-row-inline-editing", t), r.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !t);
    });
  }
  setEditingRow(t) {
    this.editingRow = t;
  }
  startRowEditing(t = null, r = null, n = null) {
    var i;
    this.editingRow || (i = this.beans.rowEditService) == null || i.startEditing(this, t, r, n);
  }
  getAllCellCtrls() {
    return this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0 ? this.centerCellCtrls.list : [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
  }
  postProcessClassesFromGridOptions() {
    const t = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
    !t || !t.length || t.forEach((r) => {
      this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass(r, !0));
    });
  }
  postProcessRowClassRules() {
    this.beans.rowCssClassCalculator.processRowClassRules(
      this.rowNode,
      (t) => {
        this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass(t, !0));
      },
      (t) => {
        this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass(t, !1));
      }
    );
  }
  setStylesFromGridOptions(t, r) {
    t && (this.rowStyles = this.processStylesFromGridOptions()), this.forEachGui(r, (n) => n.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(t) {
    return t === "left" || t === "right" ? t : null;
  }
  getInitialRowClasses(t) {
    const r = this.getPinnedForContainer(t), n = {
      rowNode: this.rowNode,
      rowFocused: this.rowFocused,
      fadeRowIn: this.fadeInAnimation[t],
      rowIsEven: this.rowNode.rowIndex % 2 === 0,
      rowLevel: this.rowLevel,
      fullWidthRow: this.isFullWidth(),
      firstRowOnPage: this.isFirstRowOnPage(),
      lastRowOnPage: this.isLastRowOnPage(),
      printLayout: this.printLayout,
      expandable: this.rowNode.isExpandable(),
      pinned: r
    };
    return this.beans.rowCssClassCalculator.getInitialRowClasses(n);
  }
  processStylesFromGridOptions() {
    const t = this.gos.get("rowStyle");
    if (t && typeof t == "function") {
      Te("rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
      return;
    }
    const r = this.gos.getCallback("getRowStyle");
    let n;
    if (r) {
      const i = {
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      };
      n = r(i);
    }
    return n || t ? Object.assign({}, t, n) : this.emptyStyle;
  }
  onRowSelected(t) {
    const r = !!this.rowNode.isSelected();
    this.forEachGui(t, (n) => {
      n.rowComp.addOrRemoveCssClass("ag-row-selected", r), tS(n.element, r), n.element.contains(this.gos.getActiveDomElement()) && (n === this.centerGui || n === this.fullWidthGui) && this.announceDescription();
    });
  }
  announceDescription() {
    if (this.isRowSelectionBlocked())
      return;
    const t = this.rowNode.isSelected();
    if (t && this.gos.get("suppressRowDeselection"))
      return;
    const n = this.beans.localeService.getLocaleTextFunc()(
      t ? "ariaRowDeselect" : "ariaRowSelect",
      `Press SPACE to ${t ? "deselect" : "select"} this row.`
    );
    this.beans.ariaAnnouncementService.announceValue(n);
  }
  addHoverFunctionality(t) {
    if (!this.active)
      return;
    const { rowNode: r, beans: n, gos: i } = this;
    this.addManagedListeners(t, {
      mouseenter: () => r.onMouseEnter(),
      mouseleave: () => r.onMouseLeave()
    }), this.addManagedListeners(r, {
      mouseEnter: () => {
        !n.dragService.isDragging() && !i.get("suppressRowHoverHighlight") && (t.classList.add("ag-row-hover"), r.setHovered(!0));
      },
      mouseLeave: () => {
        t.classList.remove("ag-row-hover"), r.setHovered(!1);
      }
    });
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(t) {
    const r = this.beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getApproximateVScollPosition(), n = this.applyPaginationOffset(r.top, !0) - 100, i = this.applyPaginationOffset(r.bottom, !0) + 100;
    return Math.min(Math.max(n, t), i);
  }
  getFrameworkOverrides() {
    return this.beans.frameworkOverrides;
  }
  forEachGui(t, r) {
    t ? r(t) : this.allRowGuis.forEach(r);
  }
  onRowHeightChanged(t) {
    if (this.rowNode.rowHeight == null)
      return;
    const r = this.rowNode.rowHeight, n = this.beans.environment.getDefaultRowHeight(), o = this.gos.isGetRowHeightFunction() ? this.gos.getRowHeightForNode(this.rowNode).height : void 0, a = o ? `${Math.min(n, o) - 2}px` : void 0;
    this.forEachGui(t, (s) => {
      s.element.style.height = `${r}px`, a && s.element.style.setProperty("--ag-line-height", a);
    });
  }
  addEventListener(t, r) {
    super.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    super.removeEventListener(t, r);
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass(t = !1) {
    if (this.active = !1, !t && this.gos.isAnimateRows() && !this.isSticky())
      if (this.rowNode.rowTop != null) {
        const i = this.roundRowTopToBounds(this.rowNode.rowTop);
        this.setRowTop(i);
      } else
        this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-opacity-zero", !0));
    this.rowNode.setHovered(!1);
    const r = this.createRowEvent("virtualRowRemoved");
    this.dispatchLocalEvent(r), this.beans.eventService.dispatchEvent(r), super.destroy();
  }
  destroySecondPass() {
    this.allRowGuis.length = 0, this.stopEditing();
    const t = (r) => (r.list.forEach((n) => n.destroy()), { list: [], map: {} });
    this.centerCellCtrls = t(this.centerCellCtrls), this.leftCellCtrls = t(this.leftCellCtrls), this.rightCellCtrls = t(this.rightCellCtrls);
  }
  setFocusedClasses(t) {
    this.forEachGui(t, (r) => {
      r.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused), r.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const t = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    t !== this.rowFocused && (this.rowFocused = t, this.setFocusedClasses()), !t && this.editingRow && this.stopEditing(!1);
  }
  onPaginationChanged() {
    var r;
    const t = ((r = this.beans.paginationService) == null ? void 0 : r.getCurrentPage()) ?? 0;
    this.paginationPage !== t && (this.paginationPage = t, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(t, r = !1) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky)
      return t;
    const n = this.beans.pageBoundsService.getPixelOffset();
    return t + n * (r ? 1 : -1);
  }
  setRowTop(t) {
    if (!this.printLayout && ke(t)) {
      const r = this.applyPaginationOffset(t), o = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? r : this.beans.rowContainerHeightService.getRealPixelPosition(r)}px`;
      this.setRowTopStyle(o);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(t) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(t) : void 0;
  }
  getInitialTransform(t) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(t)})`;
  }
  getInitialRowTopShared(t) {
    if (this.printLayout)
      return "";
    const r = this.rowNode;
    let n;
    if (this.isSticky())
      n = r.stickyRowTop;
    else {
      const i = this.slideInAnimation[t] ? this.roundRowTopToBounds(r.oldRowTop) : r.rowTop, o = this.applyPaginationOffset(i);
      n = r.isRowPinned() ? o : this.beans.rowContainerHeightService.getRealPixelPosition(o);
    }
    return n + "px";
  }
  setRowTopStyle(t) {
    this.allRowGuis.forEach(
      (r) => this.suppressRowTransform ? r.rowComp.setTop(t) : r.rowComp.setTransform(`translateY(${t})`)
    );
  }
  getRowNode() {
    return this.rowNode;
  }
  getCellCtrl(t) {
    let r = null;
    return this.getAllCellCtrls().forEach((n) => {
      n.getColumn() == t && (r = n);
    }), r != null || this.getAllCellCtrls().forEach((n) => {
      n.getColSpanningList().indexOf(t) >= 0 && (r = n);
    }), r;
  }
  onRowIndexChanged() {
    this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
  }
  getRowIndex() {
    return this.rowNode.getRowIndexString();
  }
  updateRowIndexes(t) {
    var a;
    const r = this.rowNode.getRowIndexString();
    if (r === null)
      return;
    const n = this.beans.headerNavigationService.getHeaderRowCount() + (((a = this.beans.filterManager) == null ? void 0 : a.getHeaderRowCount()) ?? 0), i = this.rowNode.rowIndex % 2 === 0, o = n + this.rowNode.rowIndex + 1;
    this.forEachGui(t, (s) => {
      s.rowComp.setRowIndex(r), s.rowComp.addOrRemoveCssClass("ag-row-even", i), s.rowComp.addOrRemoveCssClass("ag-row-odd", !i), FBe(s.element, o);
    });
  }
  setStoppingRowEdit(t) {
    this.stoppingRowEdit = t;
  }
};
zq.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var Vc = zq, QHe = class extends Se {
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService, this.valueService = e.valueService, this.menuService = e.menuService, this.ctrlsService = e.ctrlsService, this.navigationService = e.navigationService, this.focusService = e.focusService, this.undoRedoService = e.undoRedoService, this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.rangeService = e.rangeService, this.clipboardService = e.clipboardService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addKeyboardListeners(), this.addMouseListeners(), this.mockContextMenuForIPad();
  }
  addKeyboardListeners() {
    const e = "keydown", t = this.processKeyboardEvent.bind(this, e);
    this.addManagedElementListeners(this.element, { [e]: t });
  }
  addMouseListeners() {
    ["dblclick", "contextmenu", "mouseover", "mouseout", "click", OY("touchstart") ? "touchstart" : "mousedown"].forEach((r) => {
      const n = this.processMouseEvent.bind(this, r);
      this.addManagedElementListeners(this.element, { [r]: n });
    });
  }
  processMouseEvent(e, t) {
    if (!this.mouseEventService.isEventFromThisGrid(t) || Yl(t))
      return;
    const r = this.getRowForEvent(t), n = this.mouseEventService.getRenderedCellForEvent(t);
    e === "contextmenu" ? this.handleContextMenuMouseEvent(t, void 0, r, n) : (n && n.onMouseEvent(e, t), r && r.onMouseEvent(e, t));
  }
  mockContextMenuForIPad() {
    if (!xu())
      return;
    const e = new ql(this.element), t = (r) => {
      const n = this.getRowForEvent(r.touchEvent), i = this.mouseEventService.getRenderedCellForEvent(r.touchEvent);
      this.handleContextMenuMouseEvent(void 0, r.touchEvent, n, i);
    };
    this.addManagedListeners(e, { longTap: t }), this.addDestroyFunc(() => e.destroy());
  }
  getRowForEvent(e) {
    let t = e.target;
    for (; t; ) {
      const r = this.gos.getDomData(t, Vc.DOM_DATA_KEY_ROW_CTRL);
      if (r)
        return r;
      t = t.parentElement;
    }
    return null;
  }
  handleContextMenuMouseEvent(e, t, r, n) {
    const i = r ? r.getRowNode() : null, o = n ? n.getColumn() : null;
    let a = null;
    if (o) {
      const u = e || t;
      n.dispatchCellContextMenuEvent(u ?? null), a = this.valueService.getValue(o, i);
    }
    const s = this.ctrlsService.getGridBodyCtrl(), l = n ? n.getGui() : s.getGridBodyElement();
    this.menuService.showContextMenu({
      mouseEvent: e,
      touchEvent: t,
      rowNode: i,
      column: o,
      value: a,
      anchorToElement: l
    });
  }
  getControlsForEventTarget(e) {
    return {
      cellCtrl: JT(this.gos, e, kc.DOM_DATA_KEY_CELL_CTRL),
      rowCtrl: JT(this.gos, e, Vc.DOM_DATA_KEY_ROW_CTRL)
    };
  }
  processKeyboardEvent(e, t) {
    const { cellCtrl: r, rowCtrl: n } = this.getControlsForEventTarget(t.target);
    t.defaultPrevented || (r ? this.processCellKeyboardEvent(r, e, t) : n && n.isFullWidth() && this.processFullWidthRowKeyboardEvent(n, e, t));
  }
  processCellKeyboardEvent(e, t, r) {
    const n = e.getRowNode(), i = e.getColumn(), o = e.isEditing();
    if (!dP(
      this.gos,
      r,
      n,
      i,
      o
    ) && t === "keydown" && (!o && this.navigationService.handlePageScrollingKey(r) || e.onKeyDown(r), this.doGridOperations(r, e.isEditing()), Sq(r) && e.processCharacter(r)), t === "keydown") {
      const s = e.createEvent(r, "cellKeyDown");
      this.eventService.dispatchEvent(s);
    }
  }
  processFullWidthRowKeyboardEvent(e, t, r) {
    const n = e.getRowNode(), i = this.focusService.getFocusedCell(), o = i && i.column;
    if (!dP(this.gos, r, n, o, !1)) {
      const s = r.key;
      if (t === "keydown")
        switch (s) {
          case pe.PAGE_HOME:
          case pe.PAGE_END:
          case pe.PAGE_UP:
          case pe.PAGE_DOWN:
            this.navigationService.handlePageScrollingKey(r, !0);
            break;
          case pe.UP:
          case pe.DOWN:
            e.onKeyboardNavigate(r);
            break;
          case pe.TAB:
            e.onTabKeyDown(r);
            break;
        }
    }
    if (t === "keydown") {
      const s = e.createRowEvent("cellKeyDown", r);
      this.eventService.dispatchEvent(s);
    }
  }
  doGridOperations(e, t) {
    if (!e.ctrlKey && !e.metaKey || t || !this.mouseEventService.isEventFromThisGrid(e))
      return;
    const r = l$e(e);
    if (r === pe.A)
      return this.onCtrlAndA(e);
    if (r === pe.C)
      return this.onCtrlAndC(e);
    if (r === pe.D)
      return this.onCtrlAndD(e);
    if (r === pe.V)
      return this.onCtrlAndV(e);
    if (r === pe.X)
      return this.onCtrlAndX(e);
    if (r === pe.Y)
      return this.onCtrlAndY();
    if (r === pe.Z)
      return this.onCtrlAndZ(e);
  }
  onCtrlAndA(e) {
    const { pinnedRowModel: t, rowModel: r, rangeService: n } = this;
    if (n && r.isRowsToRender()) {
      const [i, o] = [
        t.isEmpty("top"),
        t.isEmpty("bottom")
      ], a = i ? null : "top";
      let s, l;
      o ? (s = null, l = r.getRowCount() - 1) : (s = "bottom", l = t.getPinnedBottomRowNodes().length - 1);
      const u = this.visibleColsService.getAllCols();
      if (Wn(u))
        return;
      n.setCellRange({
        rowStartIndex: 0,
        rowStartPinned: a,
        rowEndIndex: l,
        rowEndPinned: s,
        columnStart: u[0],
        columnEnd: gr(u)
      });
    }
    e.preventDefault();
  }
  onCtrlAndC(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection"))
      return;
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || (e.preventDefault(), this.clipboardService.copyToClipboard());
  }
  onCtrlAndX(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard"))
      return;
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || (e.preventDefault(), this.clipboardService.cutToClipboard(void 0, "ui"));
  }
  onCtrlAndV(e) {
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.pasteFromClipboard();
  }
  onCtrlAndD(e) {
    this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.copyRangeDown(), e.preventDefault();
  }
  onCtrlAndZ(e) {
    !this.gos.get("undoRedoCellEditing") || !this.undoRedoService || (e.preventDefault(), e.shiftKey ? this.undoRedoService.redo("ui") : this.undoRedoService.undo("ui"));
  }
  onCtrlAndY() {
    var e;
    (e = this.undoRedoService) == null || e.redo("ui");
  }
}, JHe = class extends Se {
  wireBeans(e) {
    this.pinnedWidthService = e.pinnedWidthService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedEventListeners({ leftPinnedWidthChanged: this.onPinnedLeftWidthChanged.bind(this) });
  }
  onPinnedLeftWidthChanged() {
    const e = this.pinnedWidthService.getPinnedLeftWidth(), t = e > 0;
    ln(this.element, t), Da(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedLeftWidth();
  }
}, eGe = class extends Se {
  wireBeans(e) {
    this.pinnedWidthService = e.pinnedWidthService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedEventListeners({
      rightPinnedWidthChanged: this.onPinnedRightWidthChanged.bind(this)
    });
  }
  onPinnedRightWidthChanged() {
    const e = this.pinnedWidthService.getPinnedRightWidth(), t = e > 0;
    ln(this.element, t), Da(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedRightWidth();
  }
}, Fy = (e) => e.getTopRowCtrls(), Ny = (e) => e.getStickyTopRowCtrls(), ky = (e) => e.getStickyBottomRowCtrls(), Vy = (e) => e.getBottomRowCtrls(), By = (e) => e.getCentreRowCtrls(), tGe = {
  center: {
    type: "center",
    container: "ag-center-cols-container",
    viewport: "ag-center-cols-viewport",
    getRowCtrls: By
  },
  left: {
    type: "left",
    container: "ag-pinned-left-cols-container",
    pinnedType: "left",
    getRowCtrls: By
  },
  right: {
    type: "right",
    container: "ag-pinned-right-cols-container",
    pinnedType: "right",
    getRowCtrls: By
  },
  fullWidth: {
    type: "fullWidth",
    container: "ag-full-width-container",
    fullWidth: !0,
    getRowCtrls: By
  },
  topCenter: {
    type: "center",
    container: "ag-floating-top-container",
    viewport: "ag-floating-top-viewport",
    getRowCtrls: Fy
  },
  topLeft: {
    type: "left",
    container: "ag-pinned-left-floating-top",
    pinnedType: "left",
    getRowCtrls: Fy
  },
  topRight: {
    type: "right",
    container: "ag-pinned-right-floating-top",
    pinnedType: "right",
    getRowCtrls: Fy
  },
  topFullWidth: {
    type: "fullWidth",
    container: "ag-floating-top-full-width-container",
    fullWidth: !0,
    getRowCtrls: Fy
  },
  stickyTopCenter: {
    type: "center",
    container: "ag-sticky-top-container",
    viewport: "ag-sticky-top-viewport",
    getRowCtrls: Ny
  },
  stickyTopLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-top",
    pinnedType: "left",
    getRowCtrls: Ny
  },
  stickyTopRight: {
    type: "right",
    container: "ag-pinned-right-sticky-top",
    pinnedType: "right",
    getRowCtrls: Ny
  },
  stickyTopFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-top-full-width-container",
    fullWidth: !0,
    getRowCtrls: Ny
  },
  stickyBottomCenter: {
    type: "center",
    container: "ag-sticky-bottom-container",
    viewport: "ag-sticky-bottom-viewport",
    getRowCtrls: ky
  },
  stickyBottomLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-bottom",
    pinnedType: "left",
    getRowCtrls: ky
  },
  stickyBottomRight: {
    type: "right",
    container: "ag-pinned-right-sticky-bottom",
    pinnedType: "right",
    getRowCtrls: ky
  },
  stickyBottomFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-bottom-full-width-container",
    fullWidth: !0,
    getRowCtrls: ky
  },
  bottomCenter: {
    type: "center",
    container: "ag-floating-bottom-container",
    viewport: "ag-floating-bottom-viewport",
    getRowCtrls: Vy
  },
  bottomLeft: {
    type: "left",
    container: "ag-pinned-left-floating-bottom",
    pinnedType: "left",
    getRowCtrls: Vy
  },
  bottomRight: {
    type: "right",
    container: "ag-pinned-right-floating-bottom",
    pinnedType: "right",
    getRowCtrls: Vy
  },
  bottomFullWidth: {
    type: "fullWidth",
    container: "ag-floating-bottom-full-width-container",
    fullWidth: !0,
    getRowCtrls: Vy
  }
};
function Wq(e) {
  return tGe[e];
}
var rGe = ["topCenter", "topLeft", "topRight"], nGe = ["bottomCenter", "bottomLeft", "bottomRight"], iGe = ["center", "left", "right"], oGe = ["center", "left", "right", "fullWidth"], aGe = ["stickyTopCenter", "stickyBottomCenter", "center", "topCenter", "bottomCenter"], sGe = ["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"], lGe = ["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"], jq = ["stickyTopCenter", "stickyTopLeft", "stickyTopRight"], Uq = ["stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"], uGe = [
  ...jq,
  "stickyTopFullWidth",
  ...Uq,
  "stickyBottomFullWidth"
], cGe = [
  ...rGe,
  ...nGe,
  ...iGe,
  ...jq,
  ...Uq
], dGe = class extends Se {
  constructor(e) {
    super(), this.visible = !0, this.EMPTY_CTRLS = [], this.name = e, this.options = Wq(e);
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.ctrlsService = e.ctrlsService, this.columnViewportService = e.columnViewportService, this.resizeObserverService = e.resizeObserverService, this.rowRenderer = e.rowRenderer;
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.forContainers(["center"], () => {
      this.viewportSizeFeature = this.createManagedBean(new EHe(this)), this.addManagedEventListeners({
        stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this)
      });
    });
  }
  onStickyTopOffsetChanged(e) {
    this.comp.setOffsetTop(`${e.offset}px`);
  }
  registerWithCtrlsService() {
    this.options.fullWidth || this.ctrlsService.register(this.name, this);
  }
  forContainers(e, t) {
    e.indexOf(this.name) >= 0 && t();
  }
  getContainerElement() {
    return this.eContainer;
  }
  getViewportSizeFeature() {
    return this.viewportSizeFeature;
  }
  setComp(e, t, r) {
    this.comp = e, this.eContainer = t, this.eViewport = r, this.createManagedBean(new QHe(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder(), this.stopHScrollOnPinnedRows(), this.forContainers(sGe, () => {
      this.pinnedWidthFeature = this.createManagedBean(new JHe(this.eContainer)), this.addManagedEventListeners({ leftPinnedWidthChanged: () => this.onPinnedWidthChanged() });
    }), this.forContainers(lGe, () => {
      this.pinnedWidthFeature = this.createManagedBean(new eGe(this.eContainer)), this.addManagedEventListeners({ rightPinnedWidthChanged: () => this.onPinnedWidthChanged() });
    }), this.forContainers(
      oGe,
      () => this.createManagedBean(
        new Hq(this.eContainer, this.name === "center" ? r : void 0)
      )
    ), this.forContainers(cGe, () => this.createManagedBean(new RHe(this.eContainer))), this.forContainers(
      aGe,
      () => this.createManagedBean(new xI((n) => this.comp.setContainerWidth(`${n}px`)))
    ), this.addListeners(), this.registerWithCtrlsService();
  }
  addListeners() {
    this.addManagedEventListeners({
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
      displayedRowsChanged: (e) => this.onDisplayedRowsChanged(e.afterScroll)
    }), this.onDisplayedColumnsChanged(), this.onDisplayedColumnsWidthChanged(), this.onDisplayedRowsChanged();
  }
  listenOnDomOrder() {
    if (uGe.indexOf(this.name) >= 0) {
      this.comp.setDomOrder(!0);
      return;
    }
    const t = () => {
      const r = this.gos.get("ensureDomOrder"), n = this.gos.isDomLayout("print");
      this.comp.setDomOrder(r || n);
    };
    this.addManagedPropertyListener("domLayout", t), t();
  }
  // when editing a pinned row, if the cell is half outside the scrollable area, the browser can
  // scroll the column into view. we do not want this, the pinned sections should never scroll.
  // so we listen to scrolls on these containers and reset the scroll if we find one.
  stopHScrollOnPinnedRows() {
    this.forContainers(["topCenter", "stickyTopCenter", "bottomCenter", "stickyBottomCenter"], () => {
      const e = () => this.eViewport.scrollLeft = 0;
      this.addManagedElementListeners(this.eViewport, { scroll: e });
    });
  }
  onDisplayedColumnsChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  onDisplayedColumnsWidthChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const e = (t) => {
      this.dragService.isDragging() && t.cancelable && t.preventDefault();
    };
    this.eContainer.addEventListener("touchmove", e, { passive: !1 }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", e));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged(e = !1) {
    const t = this.getCenterWidth(), r = this.getCenterViewportScrollLeft();
    this.columnViewportService.setScrollPosition(t, r, e);
  }
  getCenterWidth() {
    return rm(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return iS(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(e) {
    const t = this.resizeObserverService.observeResize(this.eViewport, e);
    this.addDestroyFunc(() => t());
  }
  isViewportInTheDOMTree() {
    return eq(this.eViewport);
  }
  getViewportScrollLeft() {
    return iS(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    return this.gos.get("alwaysShowHorizontalScroll") || KBe(this.eViewport);
  }
  getViewportElement() {
    return this.eViewport;
  }
  setContainerTranslateX(e) {
    this.eContainer.style.transform = `translateX(${e}px)`;
  }
  getHScrollPosition() {
    return {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
  }
  setCenterViewportScrollLeft(e) {
    oS(this.eViewport, e, this.enableRtl);
  }
  isContainerVisible() {
    return !(this.options.pinnedType != null) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const e = this.isContainerVisible();
    this.visible != e && (this.visible = e, this.onDisplayedRowsChanged());
  }
  onDisplayedRowsChanged(e = !1) {
    const t = this.options.getRowCtrls(this.rowRenderer);
    if (!this.visible || t.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const r = this.gos.isDomLayout("print"), i = this.gos.get("embedFullWidthRows") || r, o = t.filter((a) => {
      const s = a.isFullWidth();
      return this.options.fullWidth ? !i && s : i || !s;
    });
    this.comp.setRowCtrls({ rowCtrls: o, useFlushSync: e });
  }
};
function Rp(e) {
  return e.map((t) => `<ag-row-container name="${t}"></ag-row-container>`).join("");
}
`${Rp(["topLeft", "topCenter", "topRight", "topFullWidth"])}${Rp(["left", "center", "right", "fullWidth"])}${Rp(["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"])}${Rp(["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"])}${Rp(["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"])}`;
var hGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "scrollVisibleService";
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.columnAnimationService = e.columnAnimationService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this)
    });
  }
  onDisplayedColumnsChanged() {
    this.update();
  }
  onDisplayedColumnsWidthChanged() {
    this.update();
  }
  update() {
    this.columnAnimationService.isActive() ? this.columnAnimationService.executeLaterVMTurn(() => {
      this.columnAnimationService.executeLaterVMTurn(() => this.updateImpl());
    }) : this.updateImpl();
  }
  updateImpl() {
    const e = this.ctrlsService.get("center");
    if (!e || this.columnAnimationService.isActive())
      return;
    const t = {
      horizontalScrollShowing: e.isHorizontalScrollShowing(),
      verticalScrollShowing: this.isVerticalScrollShowing()
    };
    this.setScrollsVisible(t);
  }
  setScrollsVisible(e) {
    if (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) {
      this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing;
      const r = {
        type: "scrollVisibilityChanged"
      };
      this.eventService.dispatchEvent(r);
    }
  }
  // used by pagination service - to know page height
  isHorizontalScrollShowing() {
    return this.horizontalScrollShowing;
  }
  // used by header container
  isVerticalScrollShowing() {
    return this.verticalScrollShowing;
  }
}, UH = "__ag_grid_instance", Kq = class Yq extends Se {
  constructor() {
    super(...arguments), this.beanName = "mouseEventService", this.gridInstanceId = Yq.gridInstanceSequence.next();
  }
  wireBeans(t) {
    this.ctrlsService = t.ctrlsService;
  }
  // we put the instance id onto the main DOM element. this is used for events, when grids are inside grids,
  // so the grid can work out if the even came from this grid or a grid inside this one. see the ctrl+v logic
  // for where this is used.
  stampTopLevelGridCompWithGridInstance(t) {
    t[UH] = this.gridInstanceId;
  }
  getRenderedCellForEvent(t) {
    return JT(this.gos, t.target, kc.DOM_DATA_KEY_CELL_CTRL);
  }
  // walks the path of the event, and returns true if this grid is the first one that it finds. if doing
  // master / detail grids, and a child grid is found, then it returns false. this stops things like copy/paste
  // getting executed on many grids at the same time.
  isEventFromThisGrid(t) {
    return this.isElementInThisGrid(t.target);
  }
  isElementInThisGrid(t) {
    let r = t;
    for (; r; ) {
      const n = r[UH];
      if (ke(n))
        return n === this.gridInstanceId;
      r = r.parentElement;
    }
    return !1;
  }
  getCellPositionForEvent(t) {
    const r = this.getRenderedCellForEvent(t);
    return r ? r.getCellPosition() : null;
  }
  getNormalisedPosition(t) {
    const r = this.gos.isDomLayout("normal"), n = t;
    let i, o;
    if (n.clientX != null || n.clientY != null ? (i = n.clientX, o = n.clientY) : (i = n.x, o = n.y), r) {
      const a = this.ctrlsService.getGridBodyCtrl(), s = a.getScrollFeature().getVScrollPosition(), l = a.getScrollFeature().getHScrollPosition();
      i += l.left, o += s.top;
    }
    return { x: i, y: o };
  }
};
Kq.gridInstanceSequence = new nf();
var fGe = Kq, pGe = class extends Se {
  constructor() {
    super(), this.beanName = "navigationService", this.onPageDown = NH(this.onPageDown, 100), this.onPageUp = NH(this.onPageUp, 100);
  }
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService, this.pageBoundsService = e.pageBoundsService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.ctrlsService = e.ctrlsService, this.rowRenderer = e.rowRenderer, this.headerNavigationService = e.headerNavigationService, this.rowPositionUtils = e.rowPositionUtils, this.cellNavigationService = e.cellNavigationService, this.pinnedRowModel = e.pinnedRowModel, this.rangeService = e.rangeService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(e, t = !1) {
    const r = e.key, n = e.altKey, i = e.ctrlKey || e.metaKey, o = !!this.rangeService && e.shiftKey, a = this.mouseEventService.getCellPositionForEvent(e);
    let s = !1;
    switch (r) {
      case pe.PAGE_HOME:
      case pe.PAGE_END:
        !i && !n && (this.onHomeOrEndKey(r), s = !0);
        break;
      case pe.LEFT:
      case pe.RIGHT:
      case pe.UP:
      case pe.DOWN:
        if (!a)
          return !1;
        i && !n && !o && (this.onCtrlUpDownLeftRight(r, a), s = !0);
        break;
      case pe.PAGE_DOWN:
      case pe.PAGE_UP:
        !i && !n && (s = this.handlePageUpDown(r, a, t));
        break;
    }
    return s && e.preventDefault(), s;
  }
  handlePageUpDown(e, t, r) {
    return r && (t = this.focusService.getFocusedCell()), t ? (e === pe.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0) : !1;
  }
  navigateTo(e) {
    var a;
    const { scrollIndex: t, scrollType: r, scrollColumn: n, focusIndex: i, focusColumn: o } = e;
    ke(n) && !n.isPinned() && this.gridBodyCon.getScrollFeature().ensureColumnVisible(n), ke(t) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(t, r), e.isAsync || this.gridBodyCon.getScrollFeature().ensureIndexVisible(i), this.focusService.setFocusedCell({
      rowIndex: i,
      column: o,
      rowPinned: null,
      forceBrowserFocus: !0
    }), (a = this.rangeService) == null || a.setRangeToCell({ rowIndex: i, rowPinned: null, column: o });
  }
  // this method is throttled, see the `constructor`
  onPageDown(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), n = this.getViewportHeight(), i = this.pageBoundsService.getPixelOffset(), o = r.top + n, a = this.rowModel.getRowIndexAtPixel(o + i);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, a) : this.navigateToNextPage(e, a);
  }
  // this method is throttled, see the `constructor`
  onPageUp(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), n = this.pageBoundsService.getPixelOffset(), i = r.top, o = this.rowModel.getRowIndexAtPixel(i + n);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, o, !0) : this.navigateToNextPage(e, o, !0);
  }
  navigateToNextPage(e, t, r = !1) {
    const n = this.getViewportHeight(), i = this.pageBoundsService.getFirstRow(), o = this.pageBoundsService.getLastRow(), a = this.pageBoundsService.getPixelOffset(), s = this.rowModel.getRow(e.rowIndex), l = r ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
      (s == null ? void 0 : s.rowHeight) - n - a
    ) : n - a, u = (s == null ? void 0 : s.rowTop) + l;
    let c = this.rowModel.getRowIndexAtPixel(u + a);
    if (c === e.rowIndex) {
      const h = r ? -1 : 1;
      t = c = e.rowIndex + h;
    }
    let d;
    r ? (d = "bottom", c < i && (c = i), t < i && (t = i)) : (d = "top", c > o && (c = o), t > o && (t = o)), this.isRowTallerThanView(c) && (t = c, d = "top"), this.navigateTo({
      scrollIndex: t,
      scrollType: d,
      scrollColumn: null,
      focusIndex: c,
      focusColumn: e.column
    });
  }
  navigateToNextPageWithAutoHeight(e, t, r = !1) {
    this.navigateTo({
      scrollIndex: t,
      scrollType: r ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: t,
      focusColumn: e.column
    }), setTimeout(() => {
      const n = this.getNextFocusIndexForAutoHeight(e, r);
      this.navigateTo({
        scrollIndex: t,
        scrollType: r ? "bottom" : "top",
        scrollColumn: null,
        focusIndex: n,
        focusColumn: e.column,
        isAsync: !0
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(e, t = !1) {
    const r = t ? -1 : 1, n = this.getViewportHeight(), i = this.pageBoundsService.getLastRow();
    let o = 0, a = e.rowIndex;
    for (; a >= 0 && a <= i; ) {
      const s = this.rowModel.getRow(a);
      if (s) {
        const l = s.rowHeight ?? 0;
        if (o + l > n)
          break;
        o += l;
      }
      a += r;
    }
    return Math.max(0, Math.min(a, i));
  }
  getViewportHeight() {
    const { gridBodyCtrl: e, center: t } = this.ctrlsService.getParams(), r = e.getScrollFeature().getVScrollPosition(), n = this.gos.getScrollbarWidth();
    let i = r.bottom - r.top;
    return t.isHorizontalScrollShowing() && (i -= n), i;
  }
  isRowTallerThanView(e) {
    const t = this.rowModel.getRow(e);
    if (!t)
      return !1;
    const r = t.rowHeight;
    return typeof r != "number" ? !1 : r > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(e, t) {
    const r = this.cellNavigationService.getNextCellToFocus(e, t, !0), { rowIndex: n } = r, i = r.column;
    this.navigateTo({
      scrollIndex: n,
      scrollType: null,
      scrollColumn: i,
      focusIndex: n,
      focusColumn: i
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(e) {
    const t = e === pe.PAGE_HOME, r = this.visibleColsService.getAllCols(), n = t ? r[0] : gr(r), i = t ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow();
    this.navigateTo({
      scrollIndex: i,
      scrollType: null,
      scrollColumn: n,
      focusIndex: i,
      focusColumn: n
    });
  }
  // result of keyboard event
  onTabKeyDown(e, t) {
    const r = t.shiftKey, n = this.tabToNextCellCommon(e, r, t);
    if (n !== !1) {
      n && t.preventDefault();
      return;
    }
    if (r) {
      const { rowIndex: i, rowPinned: o } = e.getRowPosition();
      (o ? i === 0 : i === this.pageBoundsService.getFirstRow()) && (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus") ? this.focusService.focusNextGridCoreContainer(!0, !0) : (t.preventDefault(), this.focusService.focusPreviousFromFirstCell(t)));
    } else
      e instanceof kc && e.focusCell(!0), this.focusService.focusNextGridCoreContainer(r) && t.preventDefault();
  }
  // comes from API
  tabToNextCell(e, t) {
    const r = this.focusService.getFocusedCell();
    if (!r)
      return !1;
    let n = this.getCellByPosition(r);
    return !n && (n = this.rowRenderer.getRowByPosition(r), !n || !n.isFullWidth()) ? !1 : !!this.tabToNextCellCommon(n, e, t);
  }
  tabToNextCellCommon(e, t, r) {
    let n = e.isEditing();
    if (!n && e instanceof kc) {
      const a = e.getRowCtrl();
      a && (n = a.isEditing());
    }
    let i;
    return n ? this.gos.get("editType") === "fullRow" ? i = this.moveToNextEditingRow(e, t, r) : i = this.moveToNextEditingCell(e, t, r) : i = this.moveToNextCellNotEditing(e, t), i === null ? i : i || !!this.focusService.getFocusedHeader();
  }
  // returns null if no navigation should be performed
  moveToNextEditingCell(e, t, r = null) {
    const n = e.getCellPosition();
    e.getGui().focus(), e.stopEditing();
    const i = this.findNextCellToFocusOn(n, t, !0);
    return i === !1 ? null : i == null ? !1 : (i.startEditing(null, !0, r), i.focusCell(!1), !0);
  }
  // returns null if no navigation should be performed
  moveToNextEditingRow(e, t, r = null) {
    const n = e.getCellPosition(), i = this.findNextCellToFocusOn(n, t, !0);
    if (i === !1)
      return null;
    if (i == null)
      return !1;
    const o = i.getCellPosition(), a = this.isCellEditable(n), s = this.isCellEditable(o), l = o && n.rowIndex === o.rowIndex && n.rowPinned === o.rowPinned;
    return a && e.setFocusOutOnEditor(), l || (e.getRowCtrl().stopEditing(), i.getRowCtrl().startRowEditing(void 0, void 0, r)), s ? (i.setFocusInOnEditor(), i.focusCell()) : i.focusCell(!0), !0;
  }
  // returns null if no navigation should be performed
  moveToNextCellNotEditing(e, t) {
    const r = this.visibleColsService.getAllCols();
    let n;
    e instanceof Vc ? n = {
      ...e.getRowPosition(),
      column: t ? r[0] : gr(r)
    } : n = e.getCellPosition();
    const i = this.findNextCellToFocusOn(n, t, !1);
    if (i === !1)
      return null;
    if (i instanceof kc)
      i.focusCell(!0);
    else if (i)
      return this.tryToFocusFullWidthRow(i.getRowPosition(), t);
    return ke(i);
  }
  /**
   * called by the cell, when tab is pressed while editing.
   * @return: RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */
  findNextCellToFocusOn(e, t, r) {
    var i;
    let n = e;
    for (; ; ) {
      e !== n && (e = n), t || (n = this.getLastCellOfColSpan(n)), n = this.cellNavigationService.getNextTabbedCell(n, t);
      const o = this.gos.getCallback("tabToNextCell");
      if (ke(o)) {
        const u = o({
          backwards: t,
          editing: r,
          previousCellPosition: e,
          nextCellPosition: n || null
        });
        if (u === !0 || u === null)
          u === null && Te(
            "Returning `null` from tabToNextCell is deprecated. Return `true` to stay on the current cell, or `false` to let the browser handle the tab behaviour."
          ), n = e;
        else {
          if (u === !1)
            return !1;
          n = {
            rowIndex: u.rowIndex,
            column: u.column,
            rowPinned: u.rowPinned
          };
        }
      }
      if (!n)
        return null;
      if (n.rowIndex < 0) {
        const l = this.headerNavigationService.getHeaderRowCount();
        return this.focusService.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: l + n.rowIndex,
            column: n.column
          },
          fromCell: !0
        }), null;
      }
      const a = this.gos.get("editType") === "fullRow";
      if (r && !a && !this.isCellEditable(n))
        continue;
      this.ensureCellVisible(n);
      const s = this.getCellByPosition(n);
      if (!s) {
        const l = this.rowRenderer.getRowByPosition(n);
        if (!l || !l.isFullWidth() || r)
          continue;
        return l;
      }
      if (!s.isSuppressNavigable())
        return (i = this.rangeService) == null || i.setRangeToCell(n), s;
    }
  }
  isCellEditable(e) {
    const t = this.lookupRowNodeForCell(e);
    return t ? e.column.isCellEditable(t) : !1;
  }
  getCellByPosition(e) {
    const t = this.rowRenderer.getRowByPosition(e);
    return t ? t.getCellCtrl(e.column) : null;
  }
  lookupRowNodeForCell(e) {
    return e.rowPinned === "top" ? this.pinnedRowModel.getPinnedTopRow(e.rowIndex) : e.rowPinned === "bottom" ? this.pinnedRowModel.getPinnedBottomRow(e.rowIndex) : this.rowModel.getRow(e.rowIndex);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(e, t, r, n) {
    let i = r, o = !1;
    for (; i && (i === r || !this.isValidNavigateCell(i)); )
      this.gos.get("enableRtl") ? t === pe.LEFT && (i = this.getLastCellOfColSpan(i)) : t === pe.RIGHT && (i = this.getLastCellOfColSpan(i)), i = this.cellNavigationService.getNextCellToFocus(t, i), o = dr(i);
    if (o && e && e.key === pe.UP && (i = {
      rowIndex: -1,
      rowPinned: null,
      column: r.column
    }), n) {
      const s = this.gos.getCallback("navigateToNextCell");
      if (ke(s)) {
        const u = s({
          key: t,
          previousCellPosition: r,
          nextCellPosition: i || null,
          event: e
        });
        ke(u) ? i = {
          rowPinned: u.rowPinned,
          rowIndex: u.rowIndex,
          column: u.column
        } : i = null;
      }
    }
    if (!i)
      return;
    if (i.rowIndex < 0) {
      const s = this.headerNavigationService.getHeaderRowCount();
      this.focusService.focusHeaderPosition({
        headerPosition: { headerRowIndex: s + i.rowIndex, column: r.column },
        event: e || void 0,
        fromCell: !0
      });
      return;
    }
    const a = this.getNormalisedPosition(i);
    a ? this.focusPosition(a) : this.tryToFocusFullWidthRow(i);
  }
  getNormalisedPosition(e) {
    this.ensureCellVisible(e);
    const t = this.getCellByPosition(e);
    return t ? (e = t.getCellPosition(), this.ensureCellVisible(e), e) : null;
  }
  tryToFocusFullWidthRow(e, t = !1) {
    const r = this.visibleColsService.getAllCols(), n = this.rowRenderer.getRowByPosition(e);
    if (!n || !n.isFullWidth())
      return !1;
    const i = this.focusService.getFocusedCell(), o = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: e.column || (t ? gr(r) : r[0])
    };
    this.focusPosition(o);
    const a = i != null ? this.rowPositionUtils.before(o, i) : !1, s = {
      type: "fullWidthRowFocused",
      rowIndex: o.rowIndex,
      rowPinned: o.rowPinned,
      column: o.column,
      isFullWidthCell: !0,
      fromBelow: a
    };
    return this.eventService.dispatchEvent(s), !0;
  }
  focusPosition(e) {
    var t;
    this.focusService.setFocusedCell({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0
    }), (t = this.rangeService) == null || t.setRangeToCell(e);
  }
  isValidNavigateCell(e) {
    return !!this.rowPositionUtils.getRowNode(e);
  }
  getLastCellOfColSpan(e) {
    const t = this.getCellByPosition(e);
    if (!t)
      return e;
    const r = t.getColSpanningList();
    return r.length === 1 ? e : {
      rowIndex: e.rowIndex,
      column: gr(r),
      rowPinned: e.rowPinned
    };
  }
  ensureCellVisible(e) {
    const t = this.gos.isGroupRowsSticky(), r = this.rowModel.getRow(e.rowIndex);
    !(t && (r == null ? void 0 : r.sticky)) && dr(e.rowPinned) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex), e.column.isPinned() || this.gridBodyCon.getScrollFeature().ensureColumnVisible(e.column);
  }
}, gGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "horizontalResizeService";
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.ctrlsService = e.ctrlsService;
  }
  addResizeBar(e) {
    const t = {
      dragStartPixels: e.dragStartPixels || 0,
      eElement: e.eResizeBar,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this, e),
      onDragging: this.onDragging.bind(this, e),
      includeTouch: !0,
      stopPropagationForTouch: !0
    };
    return this.dragService.addDragSource(t), () => this.dragService.removeDragSource(t);
  }
  onDragStart(e, t) {
    this.dragStartX = t.clientX, this.setResizeIcons();
    const r = t instanceof MouseEvent && t.shiftKey === !0;
    e.onResizeStart(r);
  }
  setResizeIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(!0), e.disableUserSelect(!0);
  }
  onDragStop(e, t) {
    e.onResizeEnd(this.resizeAmount), this.resetIcons();
  }
  resetIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(!1), e.disableUserSelect(!1);
  }
  onDragging(e, t) {
    this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount);
  }
}, vGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "filterMenuFactory";
  }
  wireBeans(e) {
    this.popupService = e.popupService, this.focusService = e.focusService, this.ctrlsService = e.ctrlsService, this.menuService = e.menuService;
  }
  hideActiveMenu() {
    this.hidePopup && this.hidePopup();
  }
  showMenuAfterMouseEvent(e, t, r) {
    this.showPopup(
      e,
      (n) => {
        this.popupService.positionPopupUnderMouseEvent({
          column: e,
          type: r,
          mouseEvent: t,
          ePopup: n
        });
      },
      r,
      t.target,
      this.menuService.isLegacyMenuEnabled()
    );
  }
  showMenuAfterButtonClick(e, t, r) {
    let n = -1, i = "left";
    const o = this.menuService.isLegacyMenuEnabled();
    !o && this.gos.get("enableRtl") && (n = 1, i = "right");
    const a = o ? void 0 : 4 * n, s = o ? void 0 : 4;
    this.showPopup(
      e,
      (l) => {
        this.popupService.positionPopupByComponent({
          type: r,
          eventSource: t,
          ePopup: l,
          nudgeX: a,
          nudgeY: s,
          alignSide: i,
          keepWithinBounds: !0,
          position: "under",
          column: e
        });
      },
      r,
      t,
      o
    );
  }
  showPopup(e, t, r, n, i) {
    const o = e ? this.createBean(new K4e(e, "COLUMN_MENU")) : void 0;
    if (this.activeMenu = o, !(o != null && o.hasFilter()) || !e)
      throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
    const a = document.createElement("div");
    Na(a, "presentation"), a.classList.add("ag-menu"), i || a.classList.add("ag-filter-menu"), [this.tabListener] = this.addManagedElementListeners(a, {
      keydown: (p) => this.trapFocusWithin(p, a)
    }), a.appendChild(o == null ? void 0 : o.getGui());
    let s;
    const l = () => o == null ? void 0 : o.afterGuiDetached(), u = this.menuService.isColumnMenuAnchoringEnabled() ? n ?? this.ctrlsService.getGridBodyCtrl().getGui() : void 0, c = (p) => {
      e.setMenuVisible(!1, "contextMenu");
      const g = p instanceof KeyboardEvent;
      if (this.tabListener && (this.tabListener = this.tabListener()), g && n && ys(n)) {
        const v = this.focusService.findTabbableParent(n);
        v && v.focus();
      }
      l(), this.destroyBean(this.activeMenu), this.dispatchVisibleChangedEvent(!1, r, e);
    }, d = this.localeService.getLocaleTextFunc(), h = i && r !== "columnFilter" ? d("ariaLabelColumnMenu", "Column Menu") : d("ariaLabelColumnFilter", "Column Filter"), f = this.popupService.addPopup({
      modal: !0,
      eChild: a,
      closeOnEsc: !0,
      closedCallback: c,
      positionCallback: () => t(a),
      anchorToElement: u,
      ariaLabel: h
    });
    f && (this.hidePopup = s = f.hideFunc), o.afterInit().then(() => {
      t(a), o.afterGuiAttached({ container: r, hidePopup: s });
    }), e.setMenuVisible(!0, "contextMenu"), this.dispatchVisibleChangedEvent(!0, r, e);
  }
  trapFocusWithin(e, t) {
    e.key !== pe.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(t, !1, e.shiftKey) || (e.preventDefault(), this.focusService.focusInto(t, e.shiftKey));
  }
  dispatchVisibleChangedEvent(e, t, r) {
    const n = {
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: !1,
      key: t,
      column: r ?? null
    };
    this.eventService.dispatchEvent(n);
  }
  isMenuEnabled(e) {
    return e.isFilterAllowed() && (e.getColDef().menuTabs ?? ["filterMenuTab"]).includes("filterMenuTab");
  }
  showMenuAfterContextMenuEvent() {
  }
  destroy() {
    this.destroyBean(this.activeMenu), super.destroy();
  }
}, mGe = 50, yGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "resizeObserverService", this.polyfillFunctions = [];
  }
  observeResize(e, t) {
    const r = this.gos.getWindow(), n = () => {
      const s = new r.ResizeObserver(t);
      return s.observe(e), () => s.disconnect();
    }, i = () => {
      let s = (e == null ? void 0 : e.clientWidth) ?? 0, l = (e == null ? void 0 : e.clientHeight) ?? 0, u = !0;
      const c = () => {
        if (u) {
          const d = (e == null ? void 0 : e.clientWidth) ?? 0, h = (e == null ? void 0 : e.clientHeight) ?? 0;
          (d !== s || h !== l) && (s = d, l = h, t()), this.doNextPolyfillTurn(c);
        }
      };
      return c(), () => u = !1;
    }, o = this.gos.get("suppressBrowserResizeObserver");
    return !!r.ResizeObserver && !o ? n() : this.getFrameworkOverrides().wrapIncoming(() => i(), "resize-observer");
  }
  doNextPolyfillTurn(e) {
    this.polyfillFunctions.push(e), this.schedulePolyfill();
  }
  schedulePolyfill() {
    if (this.polyfillScheduled)
      return;
    const e = () => {
      const t = this.polyfillFunctions;
      this.polyfillScheduled = !1, this.polyfillFunctions = [], t.forEach((r) => r());
    };
    this.polyfillScheduled = !0, window.setTimeout(e, mGe);
  }
}, CGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "animationFrameService", this.createTasksP1 = { list: [], sorted: !1 }, this.createTasksP2 = { list: [], sorted: !1 }, this.destroyTasks = [], this.ticking = !1, this.scrollGoingDown = !0, this.lastPage = 0, this.lastScrollTop = 0, this.taskCount = 0, this.cancelledTasks = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.paginationService = e.paginationService;
  }
  setScrollTop(e) {
    var r;
    const t = this.gos.get("pagination");
    if (this.scrollGoingDown = e >= this.lastScrollTop, t && e === 0) {
      const n = ((r = this.paginationService) == null ? void 0 : r.getCurrentPage()) ?? 0;
      n !== this.lastPage && (this.lastPage = n, this.scrollGoingDown = !0);
    }
    this.lastScrollTop = e;
  }
  postConstruct() {
    this.useAnimationFrame = !this.gos.get("suppressAnimationFrame");
  }
  isOn() {
    return this.useAnimationFrame;
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verifyAnimationFrameOn(e) {
    this.useAnimationFrame === !1 && Te(`AnimationFrameService.${e} called but animation frames are off`);
  }
  createTask(e, t, r) {
    this.verifyAnimationFrameOn(r);
    const n = { task: e, index: t, createOrder: ++this.taskCount };
    this.addTaskToList(this[r], n), this.schedule();
  }
  cancelTask(e) {
    this.cancelledTasks.add(e);
  }
  addTaskToList(e, t) {
    e.list.push(t), e.sorted = !1;
  }
  sortTaskList(e) {
    if (e.sorted)
      return;
    const t = this.scrollGoingDown ? 1 : -1;
    e.list.sort(
      (r, n) => r.index !== n.index ? t * (n.index - r.index) : n.createOrder - r.createOrder
    ), e.sorted = !0;
  }
  addDestroyTask(e) {
    this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(e), this.schedule();
  }
  executeFrame(e) {
    this.verifyAnimationFrameOn("executeFrame");
    const t = this.createTasksP1, r = t.list, n = this.createTasksP2, i = n.list, o = this.destroyTasks, a = (/* @__PURE__ */ new Date()).getTime();
    let s = (/* @__PURE__ */ new Date()).getTime() - a;
    const l = e <= 0, u = this.ctrlsService.getGridBodyCtrl();
    for (; l || s < e; ) {
      if (!u.getScrollFeature().scrollGridIfNeeded()) {
        let d;
        if (r.length)
          this.sortTaskList(t), d = r.pop().task;
        else if (i.length)
          this.sortTaskList(n), d = i.pop().task;
        else if (o.length)
          d = o.pop();
        else {
          this.cancelledTasks.clear();
          break;
        }
        this.cancelledTasks.has(d) || d();
      }
      s = (/* @__PURE__ */ new Date()).getTime() - a;
    }
    r.length || i.length || o.length ? this.requestFrame() : this.stopTicking();
  }
  stopTicking() {
    this.ticking = !1;
  }
  flushAllFrames() {
    this.useAnimationFrame && this.executeFrame(-1);
  }
  schedule() {
    this.useAnimationFrame && (this.ticking || (this.ticking = !0, this.requestFrame()));
  }
  requestFrame() {
    const e = this.executeFrame.bind(this, 60);
    this.requestAnimationFrame(e);
  }
  requestAnimationFrame(e) {
    const t = this.gos.getWindow();
    t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.setTimeout(e, 0);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
  // a debounce utility used for parts of the app involved with rendering.
  // the advantage over normal debounce is the client can call flushAllFrames()
  // to make sure all rendering is complete. we don't wait any milliseconds,
  // as this is intended to batch calls in one VM turn.
  debounce(e) {
    let t = !1;
    return () => {
      if (!this.isOn()) {
        window.setTimeout(e, 0);
        return;
      }
      t || (t = !0, this.addDestroyTask(() => {
        t = !1, e();
      }));
    };
  }
}, SGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "expansionService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.isClientSideRowModel = this.rowModel.getType() === "clientSide";
  }
  expandRows(e) {
    if (!this.isClientSideRowModel)
      return;
    const t = new Set(e);
    this.rowModel.forEachNode((r) => {
      r.id && t.has(r.id) && (r.expanded = !0);
    }), this.onGroupExpandedOrCollapsed();
  }
  getExpandedRows() {
    const e = [];
    return this.rowModel.forEachNode(({ expanded: t, id: r }) => {
      t && r && e.push(r);
    }), e;
  }
  expandAll(e) {
    this.isClientSideRowModel && this.rowModel.expandOrCollapseAll(e);
  }
  setRowNodeExpanded(e, t, r, n) {
    e && (r && e.parent && e.parent.level !== -1 && this.setRowNodeExpanded(e.parent, t, r, n), e.setExpanded(t, void 0, n));
  }
  onGroupExpandedOrCollapsed() {
    this.isClientSideRowModel && this.rowModel.refreshModel({
      step: "map"
      /* MAP */
    });
  }
}, wGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "menuService";
  }
  wireBeans(e) {
    this.filterMenuFactory = e.filterMenuFactory, this.ctrlsService = e.ctrlsService, this.animationFrameService = e.animationFrameService, this.filterManager = e.filterManager, this.rowRenderer = e.rowRenderer, this.columnChooserFactory = e.columnChooserFactory, this.contextMenuFactory = e.contextMenuFactory, this.enterpriseMenuFactory = e.enterpriseMenuFactory;
  }
  postConstruct() {
    this.activeMenuFactory = this.enterpriseMenuFactory ?? this.filterMenuFactory;
  }
  showColumnMenu(e) {
    this.showColumnMenuCommon(this.activeMenuFactory, e, "columnMenu");
  }
  showFilterMenu(e) {
    const t = this.enterpriseMenuFactory && this.isLegacyMenuEnabled() ? this.enterpriseMenuFactory : this.filterMenuFactory;
    this.showColumnMenuCommon(t, e, e.containerType, !0);
  }
  showHeaderContextMenu(e, t, r) {
    this.activeMenuFactory.showMenuAfterContextMenuEvent(e, t, r);
  }
  getContextMenuPosition(e, t) {
    const r = this.getRowCtrl(e), n = this.getCellGui(r, t);
    if (!n)
      return r ? { x: 0, y: r.getRowYPosition() } : { x: 0, y: 0 };
    const i = n.getBoundingClientRect();
    return {
      x: i.x + i.width / 2,
      y: i.y + i.height / 2
    };
  }
  showContextMenu(e) {
    var o;
    const { rowNode: t } = e, r = e.column;
    let { anchorToElement: n, value: i } = e;
    t && r && i == null && (i = t.getValueFromValueService(r)), n == null && (n = this.getContextMenuAnchorElement(t, r)), (o = this.contextMenuFactory) == null || o.onContextMenu(
      e.mouseEvent ?? null,
      e.touchEvent ?? null,
      t ?? null,
      r ?? null,
      i,
      n
    );
  }
  showColumnChooser(e) {
    var t;
    (t = this.columnChooserFactory) == null || t.showColumnChooser(e);
  }
  hidePopupMenu() {
    var e;
    (e = this.contextMenuFactory) == null || e.hideActiveMenu(), this.activeMenuFactory.hideActiveMenu();
  }
  hideColumnChooser() {
    var e;
    (e = this.columnChooserFactory) == null || e.hideActiveColumnChooser();
  }
  isColumnMenuInHeaderEnabled(e) {
    const { suppressMenu: t, suppressHeaderMenuButton: r } = e.getColDef();
    return !(r ?? t) && this.activeMenuFactory.isMenuEnabled(e) && (this.isLegacyMenuEnabled() || !!this.enterpriseMenuFactory);
  }
  isFilterMenuInHeaderEnabled(e) {
    var t;
    return !e.getColDef().suppressHeaderFilterButton && !!((t = this.filterManager) != null && t.isFilterAllowed(e));
  }
  isHeaderContextMenuEnabled(e) {
    return !(e != null && e.getColDef().suppressHeaderContextMenu) && this.getColumnMenuType() === "new";
  }
  isHeaderMenuButtonAlwaysShowEnabled() {
    return this.isSuppressMenuHide();
  }
  isHeaderMenuButtonEnabled() {
    const e = !this.isSuppressMenuHide();
    return !(xu() && e);
  }
  isHeaderFilterButtonEnabled(e) {
    return this.isFilterMenuInHeaderEnabled(e) && !this.isLegacyMenuEnabled() && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFilterMenuItemEnabled(e) {
    var t;
    return !!((t = this.filterManager) != null && t.isFilterAllowed(e)) && !this.isLegacyMenuEnabled() && !this.isFilterMenuInHeaderEnabled(e) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isColumnMenuAnchoringEnabled() {
    return !this.isLegacyMenuEnabled();
  }
  areAdditionalColumnMenuItemsEnabled() {
    return this.getColumnMenuType() === "new";
  }
  isLegacyMenuEnabled() {
    return this.getColumnMenuType() === "legacy";
  }
  isFloatingFilterButtonEnabled(e) {
    var n;
    const t = e.getColDef(), r = (n = t.floatingFilterComponentParams) == null ? void 0 : n.suppressFilterButton;
    return r != null && Te(
      "As of v31.1, 'colDef.floatingFilterComponentParams.suppressFilterButton' is deprecated. Use 'colDef.suppressFloatingFilterButton' instead."
    ), t.suppressFloatingFilterButton == null ? !r : !t.suppressFloatingFilterButton;
  }
  getColumnMenuType() {
    return this.gos.get("columnMenu");
  }
  isFloatingFilterButtonDisplayed(e) {
    return !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e);
  }
  isSuppressMenuHide() {
    const e = this.gos.get("suppressMenuHide");
    return this.isLegacyMenuEnabled() ? this.gos.exists("suppressMenuHide") ? e : !1 : e;
  }
  showColumnMenuCommon(e, t, r, n) {
    const { positionBy: i } = t, o = t.column;
    if (i === "button") {
      const { buttonElement: a } = t;
      e.showMenuAfterButtonClick(o, a, r, n);
    } else if (i === "mouse") {
      const { mouseEvent: a } = t;
      e.showMenuAfterMouseEvent(o, a, r, n);
    } else o && (this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(o, "auto"), this.animationFrameService.requestAnimationFrame(() => {
      const a = this.ctrlsService.getHeaderRowContainerCtrl(o.getPinned()).getHeaderCtrlForColumn(o);
      e.showMenuAfterButtonClick(
        o,
        a.getAnchorElementForMenu(n),
        r,
        !0
      );
    }));
  }
  getRowCtrl(e) {
    const { rowIndex: t, rowPinned: r } = e || {};
    if (t != null)
      return this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: r }) || void 0;
  }
  getCellGui(e, t) {
    if (!e || !t)
      return;
    const r = e.getCellCtrl(t);
    return (r == null ? void 0 : r.getGui()) || void 0;
  }
  getContextMenuAnchorElement(e, t) {
    const r = this.ctrlsService.getGridBodyCtrl().getGridBodyElement(), n = this.getRowCtrl(e);
    if (!n)
      return r;
    const i = this.getCellGui(n, t);
    return i || (n.isFullWidth() ? n.getFullWidthElement() : r);
  }
}, bGe = class extends xc {
  constructor(e) {
    super(e, "ag-text-area", null, "textarea");
  }
  setValue(e, t) {
    const r = super.setValue(e, t);
    return this.eInput.value = e, r;
  }
  setCols(e) {
    return this.eInput.cols = e, this;
  }
  setRows(e) {
    return this.eInput.rows = e, this;
  }
}, xGe = {
  selector: "AG-INPUT-TEXT-AREA",
  component: bGe
}, EGe = class extends Of {
  constructor() {
    super(
      /* html */
      `<div class="ag-large-text">
        <ag-input-text-area data-ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`,
      [xGe]
    ), this.eTextArea = Pt;
  }
  init(e) {
    this.params = e, this.focusAfterAttached = e.cellStartedEdit, this.eTextArea.setMaxLength(e.maxLength || 200).setCols(e.cols || 60).setRows(e.rows || 10), ke(e.value, !0) && this.eTextArea.setValue(e.value.toString(), !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.activateTabIndex();
  }
  onKeyDown(e) {
    const t = e.key;
    (t === pe.LEFT || t === pe.UP || t === pe.RIGHT || t === pe.DOWN || e.shiftKey && t === pe.ENTER) && e.stopPropagation();
  }
  afterGuiAttached() {
    const e = this.localeService.getLocaleTextFunc();
    this.eTextArea.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus();
  }
  getValue() {
    const e = this.eTextArea.getValue();
    return !ke(e) && !ke(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
}, RGe = class extends Of {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-popup-editor" tabindex="-1"/>'
    ), this.params = e;
  }
  postConstruct() {
    this.gos.setDomData(this.getGui(), "popupEditorWrapper", !0), this.addKeyDownListener();
  }
  addKeyDownListener() {
    const e = this.getGui(), t = this.params, r = (n) => {
      dP(this.gos, n, t.node, t.column, !0) || t.onKeyDown(n);
    };
    this.addManagedElementListeners(e, { keydown: r });
  }
}, _Ge = class extends Of {
  constructor() {
    super(
      /* html */
      `<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" data-ref="eSelect"></ag-select>
            </div>`,
      [e$e]
    ), this.eSelect = Pt, this.startedByEnter = !1;
  }
  wireBeans(e) {
    this.valueService = e.valueService;
  }
  init(e) {
    this.focusAfterAttached = e.cellStartedEdit;
    const { eSelect: t, valueService: r, gos: n } = this, { values: i, value: o, eventKey: a } = e;
    if (dr(i)) {
      Te("no values found for select cellEditor");
      return;
    }
    this.startedByEnter = a != null ? a === pe.ENTER : !1;
    let s = !1;
    i.forEach((d) => {
      const h = { value: d }, f = r.formatValue(e.column, null, d), p = f != null;
      h.text = p ? f : d, t.addOption(h), s = s || o === d;
    }), s ? t.setValue(e.value, !0) : e.values.length && t.setValue(e.values[0], !0);
    const { valueListGap: l, valueListMaxWidth: u, valueListMaxHeight: c } = e;
    l != null && t.setPickerGap(l), c != null && t.setPickerMaxHeight(c), u != null && t.setPickerMaxWidth(u), n.get("editType") !== "fullRow" && this.addManagedListeners(this.eSelect, { selectedItem: () => e.stopEditing() });
  }
  afterGuiAttached() {
    this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && setTimeout(() => {
      this.isAlive() && this.eSelect.showPicker();
    });
  }
  focusIn() {
    this.eSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.eSelect.getValue();
  }
  isPopup() {
    return !1;
  }
}, $w = class extends Of {
  constructor(e) {
    super(
      /* html */
      `
            <div class="ag-cell-edit-wrapper">
                ${e.getTemplate()}
            </div>`,
      e.getAgComponents()
    ), this.cellEditorInput = e, this.eInput = Pt;
  }
  init(e) {
    this.params = e;
    const t = this.eInput;
    this.cellEditorInput.init(t, e);
    let r;
    if (e.cellStartedEdit) {
      this.focusAfterAttached = !0;
      const n = e.eventKey;
      n === pe.BACKSPACE || e.eventKey === pe.DELETE ? r = "" : n && n.length === 1 ? r = n : (r = this.cellEditorInput.getStartValue(), n !== pe.F2 && (this.highlightAllOnFocus = !0));
    } else
      this.focusAfterAttached = !1, r = this.cellEditorInput.getStartValue();
    r != null && t.setStartValue(r), this.addManagedElementListeners(t.getGui(), {
      keydown: (n) => {
        const { key: i } = n;
        (i === pe.PAGE_UP || i === pe.PAGE_DOWN) && n.preventDefault();
      }
    });
  }
  afterGuiAttached() {
    var n, i;
    const e = this.localeService.getLocaleTextFunc(), t = this.eInput;
    if (t.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), !this.focusAfterAttached)
      return;
    al() || t.getFocusableElement().focus();
    const r = t.getInputElement();
    this.highlightAllOnFocus ? r.select() : (i = (n = this.cellEditorInput).setCaret) == null || i.call(n);
  }
  // gets called when tabbing through cells and in full row edit mode
  focusIn() {
    const e = this.eInput, t = e.getFocusableElement(), r = e.getInputElement();
    t.focus(), r.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return !1;
  }
}, TGe = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-text-field class="ag-cell-editor" data-ref="eInput"></ag-input-text-field>'
    );
  }
  getAgComponents() {
    return [Vw];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.maxLength != null && e.setMaxLength(t.maxLength);
  }
  getValue() {
    const e = this.eInput.getValue();
    return !ke(e) && !ke(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
  getStartValue() {
    return this.params.useFormatter || this.params.column.getColDef().refData ? this.params.formatValue(this.params.value) : this.params.value;
  }
  setCaret() {
    const e = this.eInput.getValue(), t = ke(e) && e.length || 0;
    t && this.eInput.getInputElement().setSelectionRange(t, t);
  }
}, qq = class extends $w {
  constructor() {
    super(new TGe());
  }
}, PGe = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-number-field class="ag-cell-editor" data-ref="eInput"></ag-input-number-field>'
    );
  }
  getAgComponents() {
    return [c$e];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.max != null && e.setMax(t.max), t.min != null && e.setMin(t.min), t.precision != null && e.setPrecision(t.precision), t.step != null && e.setStep(t.step);
    const r = e.getInputElement();
    t.preventStepping ? e.addManagedElementListeners(r, { keydown: this.preventStepping }) : t.showStepperButtons && r.classList.add("ag-number-field-input-stepper");
  }
  preventStepping(e) {
    (e.key === pe.UP || e.key === pe.DOWN) && e.preventDefault();
  }
  getValue() {
    const e = this.eInput.getValue();
    if (!ke(e) && !ke(this.params.value))
      return this.params.value;
    let t = this.params.parseValue(e);
    if (t == null)
      return t;
    if (typeof t == "string") {
      if (t === "")
        return null;
      t = Number(t);
    }
    return isNaN(t) ? null : t;
  }
  getStartValue() {
    return this.params.value;
  }
}, MGe = class extends $w {
  constructor() {
    super(new PGe());
  }
}, DGe = class extends vd {
  constructor(e) {
    super(e, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct();
    const e = al();
    this.addManagedListeners(this.eInput, {
      wheel: this.onWheel.bind(this),
      mousedown: () => {
        this.isDisabled() || e || this.eInput.focus();
      }
    }), this.eInput.step = "any";
  }
  onWheel(e) {
    this.gos.getActiveDomElement() === this.eInput && e.preventDefault();
  }
  setMin(e) {
    const t = e instanceof Date ? Xo(e ?? null, !1) ?? void 0 : e;
    return this.min === t ? this : (this.min = t, Us(this.eInput, "min", t), this);
  }
  setMax(e) {
    const t = e instanceof Date ? Xo(e ?? null, !1) ?? void 0 : e;
    return this.max === t ? this : (this.max = t, Us(this.eInput, "max", t), this);
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Us(this.eInput, "step", e), this);
  }
  getDate() {
    if (this.eInput.validity.valid)
      return qi(this.getValue()) ?? void 0;
  }
  setDate(e, t) {
    this.setValue(Xo(e ?? null, !1), t);
  }
}, Xq = {
  selector: "AG-INPUT-DATE-FIELD",
  component: DGe
}, AGe = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    );
  }
  getAgComponents() {
    return [Xq];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.eInput.getDate();
    return !ke(e) && !ke(this.params.value) ? this.params.value : e ?? null;
  }
  getStartValue() {
    const { value: e } = this.params;
    if (e instanceof Date)
      return Xo(e, !1);
  }
}, IGe = class extends $w {
  constructor() {
    super(new AGe());
  }
}, OGe = class {
  constructor(e) {
    this.getDataTypeService = e;
  }
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    );
  }
  getAgComponents() {
    return [Xq];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.formatDate(this.eInput.getDate());
    return !ke(e) && !ke(this.params.value) ? this.params.value : this.params.parseValue(e ?? "");
  }
  getStartValue() {
    return Xo(this.parseDate(this.params.value ?? void 0) ?? null, !1);
  }
  parseDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateParserFunction(this.params.column)(e) : qi(e) ?? void 0;
  }
  formatDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateFormatterFunction(this.params.column)(e) : Xo(e ?? null, !1) ?? void 0;
  }
}, LGe = class extends $w {
  wireBeans(e) {
    this.dataTypeService = e.dataTypeService;
  }
  constructor() {
    super(new OGe(() => this.dataTypeService));
  }
}, FGe = class extends Of {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [fI]
    ), this.eCheckbox = Pt;
  }
  init(e) {
    this.params = e;
    const t = e.value ?? void 0;
    this.eCheckbox.setValue(t), this.eCheckbox.getInputElement().setAttribute("tabindex", "-1"), this.setAriaLabel(t), this.addManagedListeners(this.eCheckbox, {
      fieldValueChanged: (n) => this.setAriaLabel(n.selected)
    });
  }
  getValue() {
    return this.eCheckbox.getValue();
  }
  focusIn() {
    this.eCheckbox.getFocusableElement().focus();
  }
  afterGuiAttached() {
    this.params.cellStartedEdit && this.focusIn();
  }
  isPopup() {
    return !1;
  }
  setAriaLabel(e) {
    const t = this.localeService.getLocaleTextFunc(), r = oI(t, e), n = t("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eCheckbox.setInputAriaLabel(`${n} (${r})`);
  }
}, jp = class {
  constructor(e) {
    this.cellValueChanges = e;
  }
}, PE = class extends jp {
  constructor(e, t, r, n) {
    super(e), this.initialRange = t, this.finalRange = r, this.ranges = n;
  }
}, NGe = 10, KH = class {
  constructor(e) {
    this.actionStack = [], this.maxStackSize = e || NGe, this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(e) {
    e.cellValueChanges && e.cellValueChanges.length > 0 && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e));
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
}, kGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "undoRedoService", this.cellValueChanges = [], this.activeCellEdit = null, this.activeRowEdit = null, this.isPasting = !1, this.isRangeInAction = !1, this.onCellValueChanged = (e) => {
      const t = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned }, r = this.activeCellEdit !== null && this.cellPositionUtils.equals(this.activeCellEdit, t), n = this.activeRowEdit !== null && this.rowPositionUtils.sameRow(this.activeRowEdit, t);
      if (!(r || n || this.isPasting || this.isRangeInAction))
        return;
      const { rowPinned: o, rowIndex: a, column: s, oldValue: l, value: u } = e, c = {
        rowPinned: o,
        rowIndex: a,
        columnId: s.getColId(),
        newValue: u,
        oldValue: l
      };
      this.cellValueChanges.push(c);
    }, this.clearStacks = () => {
      this.undoStack.clear(), this.redoStack.clear();
    };
  }
  wireBeans(e) {
    this.focusService = e.focusService, this.ctrlsService = e.ctrlsService, this.cellPositionUtils = e.cellPositionUtils, this.rowPositionUtils = e.rowPositionUtils, this.columnModel = e.columnModel, this.rangeService = e.rangeService;
  }
  postConstruct() {
    if (!this.gos.get("undoRedoCellEditing"))
      return;
    const e = this.gos.get("undoRedoCellEditingLimit");
    if (e <= 0)
      return;
    this.undoStack = new KH(e), this.redoStack = new KH(e), this.addListeners();
    const t = this.clearStacks.bind(this);
    this.addManagedEventListeners({
      cellValueChanged: this.onCellValueChanged.bind(this),
      // undo / redo is restricted to actual editing so we clear the stacks when other operations are
      // performed that change the order of the row / cols.
      modelUpdated: (r) => {
        r.keepUndoRedoStack || this.clearStacks();
      },
      columnPivotModeChanged: t,
      newColumnsLoaded: t,
      columnGroupOpened: t,
      columnRowGroupChanged: t,
      columnMoved: t,
      columnPinned: t,
      columnVisible: t,
      rowDragEnd: t
    }), this.ctrlsService.whenReady((r) => {
      this.gridBodyCtrl = r.gridBodyCtrl;
    });
  }
  getCurrentUndoStackSize() {
    return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
  }
  getCurrentRedoStackSize() {
    return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
  }
  undo(e) {
    const t = {
      type: "undoStarted",
      source: e
    };
    this.eventService.dispatchEvent(t);
    const r = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo"), n = {
      type: "undoEnded",
      source: e,
      operationPerformed: r
    };
    this.eventService.dispatchEvent(n);
  }
  redo(e) {
    const t = {
      type: "redoStarted",
      source: e
    };
    this.eventService.dispatchEvent(t);
    const r = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo"), n = {
      type: "redoEnded",
      source: e,
      operationPerformed: r
    };
    this.eventService.dispatchEvent(n);
  }
  undoRedo(e, t, r, n, i) {
    if (!e)
      return !1;
    const o = e.pop();
    return !o || !o.cellValueChanges ? !1 : (this.processAction(
      o,
      (a) => a[n],
      i
    ), o instanceof PE ? this.processRange(this.rangeService, o.ranges || [o[r]]) : this.processCell(o.cellValueChanges), t.push(o), !0);
  }
  processAction(e, t, r) {
    e.cellValueChanges.forEach((n) => {
      const { rowIndex: i, rowPinned: o, columnId: a } = n, s = { rowIndex: i, rowPinned: o }, l = this.rowPositionUtils.getRowNode(s);
      l.displayed && l.setDataValue(a, t(n), r);
    });
  }
  processRange(e, t) {
    let r;
    e.removeAllCellRanges(!0), t.forEach((n, i) => {
      if (!n)
        return;
      const o = n.startRow, a = n.endRow;
      i === t.length - 1 && (r = {
        rowPinned: o.rowPinned,
        rowIndex: o.rowIndex,
        columnId: n.startColumn.getColId()
      }, this.setLastFocusedCell(r));
      const s = {
        rowStartIndex: o.rowIndex,
        rowStartPinned: o.rowPinned,
        rowEndIndex: a.rowIndex,
        rowEndPinned: a.rowPinned,
        columnStart: n.startColumn,
        columns: n.columns
      };
      e.addCellRange(s);
    });
  }
  processCell(e) {
    const t = e[0], { rowIndex: r, rowPinned: n } = t, i = { rowIndex: r, rowPinned: n }, o = this.rowPositionUtils.getRowNode(i), a = {
      rowPinned: t.rowPinned,
      rowIndex: o.rowIndex,
      columnId: t.columnId
    };
    this.setLastFocusedCell(a, this.rangeService);
  }
  setLastFocusedCell(e, t) {
    const { rowIndex: r, columnId: n, rowPinned: i } = e, o = this.gridBodyCtrl.getScrollFeature(), a = this.columnModel.getCol(n);
    if (!a)
      return;
    o.ensureIndexVisible(r), o.ensureColumnVisible(a);
    const s = { rowIndex: r, column: a, rowPinned: i };
    this.focusService.setFocusedCell({ ...s, forceBrowserFocus: !0 }), t == null || t.setRangeToCell(s);
  }
  addListeners() {
    this.addManagedEventListeners({
      rowEditingStarted: (e) => {
        this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      rowEditingStopped: () => {
        const e = new jp(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.activeRowEdit = null;
      },
      cellEditingStarted: (e) => {
        this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      cellEditingStopped: (e) => {
        if (this.activeCellEdit = null, e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
          const r = new jp(this.cellValueChanges);
          this.pushActionsToUndoStack(r);
        }
      },
      pasteStart: () => {
        this.isPasting = !0;
      },
      pasteEnd: () => {
        const e = new jp(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.isPasting = !1;
      },
      fillStart: () => {
        this.isRangeInAction = !0;
      },
      fillEnd: (e) => {
        const t = new PE(this.cellValueChanges, e.initialRange, e.finalRange);
        this.pushActionsToUndoStack(t), this.isRangeInAction = !1;
      },
      keyShortcutChangedCellStart: () => {
        this.isRangeInAction = !0;
      },
      keyShortcutChangedCellEnd: () => {
        let e;
        this.rangeService && this.gos.get("enableRangeSelection") ? e = new PE(this.cellValueChanges, void 0, void 0, [
          ...this.rangeService.getCellRanges()
        ]) : e = new jp(this.cellValueChanges), this.pushActionsToUndoStack(e), this.isRangeInAction = !1;
      }
    });
  }
  pushActionsToUndoStack(e) {
    this.undoStack.push(e), this.cellValueChanges = [], this.redoStack.clear();
  }
};
function VGe(e) {
  return e.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
}
function BGe(e) {
  return e.ctrlsService.getGridBodyCtrl().getScrollFeature().getHScrollPosition();
}
function Zq(e, t, r = "auto") {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(t, r),
    "ensureVisible"
  );
}
function Qq(e, t, r) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureIndexVisible(t, r),
    "ensureVisible"
  );
}
function $Ge(e, t, r = null) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureNodeVisible(t, r),
    "ensureVisible"
  );
}
function HGe(e) {
  var t;
  (t = e.undoRedoService) == null || t.undo("api");
}
function GGe(e) {
  var t;
  (t = e.undoRedoService) == null || t.redo("api");
}
function zGe(e, t = {}) {
  return e.rowRenderer.getCellEditorInstances(t).map(Cg);
}
function WGe(e) {
  return e.rowRenderer.getEditingCells();
}
function jGe(e, t = !1) {
  e.rowRenderer.stopEditing(t);
}
function UGe(e, t) {
  const r = e.columnModel.getCol(t.colKey);
  if (!r) {
    Te(`no column found for ${t.colKey}`);
    return;
  }
  const n = {
    rowIndex: t.rowIndex,
    rowPinned: t.rowPinned || null,
    column: r
  };
  t.rowPinned == null && Qq(e, t.rowIndex), Zq(e, t.colKey);
  const o = e.navigationService.getCellByPosition(n);
  o && (e.focusService.isCellFocused(n) || e.focusService.setFocusedCell(n), o.startRowOrCellEdit(t.key));
}
function KGe(e) {
  var t;
  return ((t = e.undoRedoService) == null ? void 0 : t.getCurrentUndoStackSize()) ?? 0;
}
function YGe(e) {
  var t;
  return ((t = e.undoRedoService) == null ? void 0 : t.getCurrentRedoStackSize()) ?? 0;
}
var qGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "editService";
  }
  wireBeans(e) {
    this.navigationService = e.navigationService, this.userComponentFactory = e.userComponentFactory, this.valueService = e.valueService;
  }
  startEditing(e, t = null, r = !1, n = null) {
    const i = this.createCellEditorParams(e, t, r), o = e.getColumn().getColDef(), a = this.userComponentFactory.getCellEditorDetails(o, i), s = (a == null ? void 0 : a.popupFromSelector) != null ? a.popupFromSelector : !!o.cellEditorPopup, l = (a == null ? void 0 : a.popupPositionFromSelector) != null ? a.popupPositionFromSelector : o.cellEditorPopupPosition;
    e.setEditing(!0, a), e.getComp().setEditDetails(a, s, l, this.gos.get("reactiveCustomComponents"));
    const u = e.createEvent(n, "cellEditingStarted");
    this.eventService.dispatchEvent(u);
  }
  stopEditing(e, t) {
    const r = e.getComp(), { newValue: n, newValueExists: i } = this.takeValueFromCellEditor(t, r), o = e.getRowNode(), a = e.getColumn(), s = o.getValueFromValueService(a);
    let l = !1;
    i && (l = this.saveNewValue(e, s, n, o, a)), e.setEditing(!1, void 0), r.setEditDetails(), e.updateAndFormatValue(!1), e.refreshCell({ forceRefresh: !0, suppressFlash: !0 });
    const u = {
      ...e.createEvent(null, "cellEditingStopped"),
      oldValue: s,
      newValue: n,
      valueChanged: l
    };
    return this.eventService.dispatchEvent(u), l;
  }
  handleColDefChanged(e) {
    const t = e.getCellEditor();
    if (t != null && t.refresh) {
      const { eventKey: r, cellStartedEdit: n } = e.getEditCompDetails().params, i = this.createCellEditorParams(e, r, n), o = e.getColumn().getColDef(), a = this.userComponentFactory.getCellEditorDetails(o, i);
      t.refresh(a.params);
    }
  }
  setFocusOutOnEditor(e) {
    const t = e.getComp().getCellEditor();
    t && t.focusOut && t.focusOut();
  }
  setFocusInOnEditor(e) {
    const t = e.getComp().getCellEditor();
    t && t.focusIn ? t.focusIn() : e.focusCell(!0);
  }
  stopEditingAndFocus(e, t = !1, r = !1) {
    e.stopRowOrCellEdit(), e.focusCell(!0), t || this.navigateAfterEdit(r, e.getCellPosition());
  }
  createPopupEditorWrapper(e) {
    return new RGe(e);
  }
  takeValueFromCellEditor(e, t) {
    const r = { newValueExists: !1 };
    if (e)
      return r;
    const n = t.getCellEditor();
    return !n || n.isCancelAfterEnd && n.isCancelAfterEnd() ? r : {
      newValue: n.getValue(),
      newValueExists: !0
    };
  }
  /**
   * @returns `True` if the value changes, otherwise `False`.
   */
  saveNewValue(e, t, r, n, i) {
    if (r === t)
      return !1;
    e.setSuppressRefreshCell(!0);
    const o = n.setDataValue(i, r, "edit");
    return e.setSuppressRefreshCell(!1), o;
  }
  createCellEditorParams(e, t, r) {
    const n = e.getColumn(), i = e.getRowNode();
    return this.gos.addGridCommonParams({
      value: i.getValueFromValueService(n),
      eventKey: t,
      column: n,
      colDef: n.getColDef(),
      rowIndex: e.getCellPosition().rowIndex,
      node: i,
      data: i.data,
      cellStartedEdit: r,
      onKeyDown: e.onKeyDown.bind(e),
      stopEditing: e.stopEditingAndFocus.bind(e),
      eGridCell: e.getGui(),
      parseValue: (o) => this.valueService.parseValue(n, i, o, e.getValue()),
      formatValue: e.formatValue.bind(e)
    });
  }
  navigateAfterEdit(e, t) {
    if (this.gos.get("enterNavigatesVerticallyAfterEdit")) {
      const n = e ? pe.UP : pe.DOWN;
      this.navigationService.navigateToNextCell(null, n, t, !1);
    }
  }
}, XGe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowEditService";
  }
  startEditing(e, t = null, r = null, n = null) {
    e.getAllCellCtrls().reduce((o, a) => {
      const s = a === r;
      return s ? a.startEditing(t, s, n) : a.startEditing(null, s, n), o ? !0 : a.isEditing();
    }, !1) && this.setEditing(e, !0);
  }
  stopEditing(e, t = !1) {
    const r = e.getAllCellCtrls(), n = e.isEditing();
    e.setStoppingRowEdit(!0);
    let i = !1;
    for (const o of r) {
      const a = o.stopEditing(t);
      n && !t && !i && a && (i = !0);
    }
    if (i) {
      const o = e.createRowEvent("rowValueChanged");
      this.eventService.dispatchEvent(o);
    }
    n && this.setEditing(e, !1), e.setStoppingRowEdit(!1);
  }
  setEditing(e, t) {
    e.setEditingRow(t), e.forEachGui(void 0, (n) => n.rowComp.addOrRemoveCssClass("ag-row-editing", t));
    const r = t ? e.createRowEvent("rowEditingStarted") : e.createRowEvent("rowEditingStopped");
    this.eventService.dispatchEvent(r);
  }
}, md = {
  version: kt,
  moduleName: "@ag-grid-community/edit-core",
  beans: [qGe]
}, ZGe = {
  version: kt,
  moduleName: "@ag-grid-community/edit-api",
  apiFunctions: {
    undoCellEditing: HGe,
    redoCellEditing: GGe,
    getCellEditorInstances: zGe,
    getEditingCells: WGe,
    stopEditing: jGe,
    startEditingCell: UGe,
    getCurrentUndoSize: KGe,
    getCurrentRedoSize: YGe
  },
  dependantModules: [md]
}, QGe = {
  version: kt,
  moduleName: "@ag-grid-community/undo-redo-edit",
  beans: [kGe],
  dependantModules: [md]
}, JGe = {
  version: kt,
  moduleName: "@ag-grid-community/full-row-edit",
  beans: [XGe],
  dependantModules: [md]
}, Jq = {
  version: kt,
  moduleName: "@ag-grid-community/default-editor",
  userComponents: [{ name: "agCellEditor", classImp: qq }],
  dependantModules: [md]
}, eze = {
  version: kt,
  moduleName: "@ag-grid-community/data-type-editors",
  userComponents: [
    { name: "agTextCellEditor", classImp: qq },
    { name: "agNumberCellEditor", classImp: MGe },
    { name: "agDateCellEditor", classImp: IGe },
    { name: "agDateStringCellEditor", classImp: LGe },
    { name: "agCheckboxCellEditor", classImp: FGe }
  ],
  dependantModules: [Jq]
}, tze = {
  version: kt,
  moduleName: "@ag-grid-community/select-editor",
  userComponents: [{ name: "agSelectCellEditor", classImp: _Ge }],
  dependantModules: [md]
}, rze = {
  version: kt,
  moduleName: "@ag-grid-community/large-text-editor",
  userComponents: [{ name: "agLargeTextCellEditor", classImp: EGe }],
  dependantModules: [md]
}, nze = {
  version: kt,
  moduleName: "@ag-grid-community/all-editors",
  dependantModules: [Jq, eze, tze, rze]
}, ize = {
  version: kt,
  moduleName: "@ag-grid-community/editing",
  dependantModules: [md, QGe, JGe, nze, ZGe]
}, oze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "autoWidthCalculator";
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.centerRowContainerCtrl = e.center;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(e, t) {
    const r = this.getHeaderCellForColumn(e);
    if (!r)
      return -1;
    const n = this.rowRenderer.getAllCellsForColumn(e);
    return t || n.push(r), this.addElementsToContainerAndGetWidth(n);
  }
  getPreferredWidthForColumnGroup(e) {
    const t = this.getHeaderCellForColumn(e);
    return t ? this.addElementsToContainerAndGetWidth([t]) : -1;
  }
  addElementsToContainerAndGetWidth(e) {
    const t = document.createElement("form");
    t.style.position = "fixed";
    const r = this.centerRowContainerCtrl.getContainerElement();
    e.forEach((o) => this.cloneItemIntoDummy(o, t)), r.appendChild(t);
    const n = t.offsetWidth;
    r.removeChild(t);
    const i = this.getAutoSizePadding();
    return n + i;
  }
  getAutoSizePadding() {
    return this.gos.get("autoSizePadding");
  }
  getHeaderCellForColumn(e) {
    let t = null;
    return this.ctrlsService.getHeaderRowContainerCtrls().forEach((r) => {
      const n = r.getHtmlElementForColumnHeader(e);
      n != null && (t = n);
    }), t;
  }
  cloneItemIntoDummy(e, t) {
    const r = e.cloneNode(!0);
    r.style.width = "", r.style.position = "static", r.style.left = "";
    const n = document.createElement("div"), i = n.classList;
    ["ag-header-cell", "ag-header-group-cell"].some((s) => r.classList.contains(s)) ? (i.add("ag-header", "ag-header-row"), n.style.position = "static") : i.add("ag-row");
    let a = e.parentElement;
    for (; a; ) {
      if (["ag-header-row", "ag-row"].some((l) => a.classList.contains(l))) {
        for (let l = 0; l < a.classList.length; l++) {
          const u = a.classList[l];
          u != "ag-row-position-absolute" && i.add(u);
        }
        break;
      }
      a = a.parentElement;
    }
    n.appendChild(r), t.appendChild(n);
  }
}, aze = class extends Se {
  constructor(e, t) {
    super(), this.createRowCon = e, this.destroyRowCtrls = t, this.stickyTopRowCtrls = [], this.stickyBottomRowCtrls = [], this.topContainerHeight = 0, this.bottomContainerHeight = 0, this.extraTopHeight = 0, this.extraBottomHeight = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer, this.ctrlsService = e.ctrlsService, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.isClientSide = this.rowModel.getType() === "clientSide", this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl;
    });
  }
  getStickyTopRowCtrls() {
    return this.stickyTopRowCtrls;
  }
  getStickyBottomRowCtrls() {
    return this.stickyBottomRowCtrls;
  }
  setOffsetTop(e) {
    if (this.extraTopHeight === e)
      return;
    this.extraTopHeight = e;
    const t = {
      type: "stickyTopOffsetChanged",
      offset: e
    };
    this.eventService.dispatchEvent(t);
  }
  setOffsetBottom(e) {
    this.extraBottomHeight !== e && (this.extraBottomHeight = e);
  }
  resetOffsets() {
    this.setOffsetBottom(0), this.setOffsetTop(0);
  }
  getExtraTopHeight() {
    return this.extraTopHeight;
  }
  getExtraBottomHeight() {
    return this.extraBottomHeight;
  }
  /**
   * Get the last pixel of the group, this pixel is used to push the sticky node up out of the viewport.
   */
  getLastPixelOfGroup(e) {
    return this.isClientSide ? this.getClientSideLastPixelOfGroup(e) : this.getServerSideLastPixelOfGroup(e);
  }
  /**
   * Get the first pixel of the group, this pixel is used to push the sticky node down out of the viewport
   */
  getFirstPixelOfGroup(e) {
    return e.footer ? e.sibling.rowTop + e.sibling.rowHeight - 1 : e.hasChildren() ? e.rowTop - 1 : 0;
  }
  getServerSideLastPixelOfGroup(e) {
    var t, r;
    if (this.isClientSide)
      throw new Error("This func should only be called in server side row model.");
    if (e.isExpandable() || e.footer) {
      if (e.master)
        return e.detailNode.rowTop + e.detailNode.rowHeight;
      if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
        let i = (t = e.childStore) == null ? void 0 : t.getStoreBounds();
        return e.footer && (i = (r = e.sibling.childStore) == null ? void 0 : r.getStoreBounds()), ((i == null ? void 0 : i.heightPx) ?? 0) + ((i == null ? void 0 : i.topPx) ?? 0);
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  getClientSideLastPixelOfGroup(e) {
    if (!this.isClientSide)
      throw new Error("This func should only be called in client side row model.");
    if (e.isExpandable() || e.footer) {
      if (e.footer && e.rowIndex === 0)
        return Number.MAX_SAFE_INTEGER;
      if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
        let n = e.footer ? e.sibling : e;
        for (; n.isExpandable() && n.expanded; )
          if (n.master)
            n = n.detailNode;
          else if (n.childrenAfterSort) {
            if (n.childrenAfterSort.length === 0)
              break;
            n = gr(n.childrenAfterSort);
          }
        return n.rowTop + n.rowHeight;
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  updateStickyRows(e) {
    const t = e === "top";
    let r = 0;
    if (!this.canRowsBeSticky())
      return this.refreshNodesAndContainerHeight(e, /* @__PURE__ */ new Set(), r);
    const n = t ? this.rowRenderer.getFirstVisibleVerticalPixel() - this.extraTopHeight : this.rowRenderer.getLastVisibleVerticalPixel() - this.extraTopHeight, i = /* @__PURE__ */ new Set(), o = (u) => {
      if (i.add(u), t) {
        const c = this.getLastPixelOfGroup(u), d = n + r + u.rowHeight;
        c < d ? u.stickyRowTop = r + (c - d) : u.stickyRowTop = r;
      } else {
        const c = this.getFirstPixelOfGroup(u), d = n - (r + u.rowHeight);
        c > d ? u.stickyRowTop = r - (c - d) : u.stickyRowTop = r;
      }
      r = 0, i.forEach((c) => {
        const d = c.stickyRowTop + c.rowHeight;
        r < d && (r = d);
      });
    }, a = this.areFooterRowsStickySuppressed(), s = this.gos.get("suppressGroupRowsSticky"), l = (u) => u.displayed ? u.footer ? a === !0 || a === "grand" && u.level === -1 || a === "group" && u.level > -1 ? !1 : !i.has(u) : u.isExpandable() ? s === !0 ? !1 : !i.has(u) && u.expanded : !1 : !1;
    for (let u = 0; u < 100; u++) {
      let c = n + r;
      t || (c = n - r);
      const d = this.rowModel.getRowIndexAtPixel(c), h = this.rowModel.getRow(d);
      if (h == null)
        break;
      const p = this.getStickyAncestors(h).find(
        (v) => (t ? v.rowIndex < d : v.rowIndex > d) && l(v)
      );
      if (p) {
        o(p);
        continue;
      }
      if ((t ? h.rowTop < c : h.rowTop + h.rowHeight > c) && l(h)) {
        o(h);
        continue;
      }
      break;
    }
    return t || i.forEach((u) => {
      u.stickyRowTop = r - (u.stickyRowTop + u.rowHeight);
    }), this.refreshNodesAndContainerHeight(e, i, r);
  }
  areFooterRowsStickySuppressed() {
    const e = this.gos.get("suppressStickyTotalRow");
    if (e === !0)
      return !0;
    const t = !!this.gos.get("groupIncludeFooter") || e === "group", r = !!this.gos.get("groupIncludeTotalFooter") || e === "grand";
    return t && r ? !0 : r ? "grand" : t ? "group" : !1;
  }
  canRowsBeSticky() {
    const e = this.gos.isGroupRowsSticky(), t = this.areFooterRowsStickySuppressed(), r = this.gos.get("suppressGroupRowsSticky");
    return e && (!t || !r);
  }
  getStickyAncestors(e) {
    const t = [];
    let r = e.footer ? e.sibling : e.parent;
    for (; r; )
      r.sibling && t.push(r.sibling), t.push(r), r = r.parent;
    return t.reverse();
  }
  checkStickyRows() {
    const e = this.updateStickyRows("top"), t = this.updateStickyRows("bottom");
    return e || t;
  }
  destroyStickyCtrls() {
    this.refreshNodesAndContainerHeight("top", /* @__PURE__ */ new Set(), 0), this.refreshNodesAndContainerHeight("bottom", /* @__PURE__ */ new Set(), 0);
  }
  refreshStickyNode(e) {
    const t = /* @__PURE__ */ new Set();
    if (this.stickyTopRowCtrls.some((r) => r.getRowNode() === e)) {
      for (let r = 0; r < this.stickyTopRowCtrls.length; r++) {
        const n = this.stickyTopRowCtrls[r].getRowNode();
        n !== e && t.add(n);
      }
      this.refreshNodesAndContainerHeight("top", t, this.topContainerHeight) && this.checkStickyRows();
      return;
    }
    for (let r = 0; r < this.stickyBottomRowCtrls.length; r++) {
      const n = this.stickyBottomRowCtrls[r].getRowNode();
      n !== e && t.add(n);
    }
    this.refreshNodesAndContainerHeight("bottom", t, this.bottomContainerHeight) && this.checkStickyRows();
  }
  /**
   * Destroy old ctrls and create new ctrls where necessary.
   */
  refreshNodesAndContainerHeight(e, t, r) {
    const n = e === "top", i = n ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls, o = {}, a = [];
    for (let h = 0; h < i.length; h++) {
      const f = i[h].getRowNode();
      if (!t.has(f)) {
        o[f.id] = i[h], f.sticky = !1;
        continue;
      }
      a.push(i[h]);
    }
    const s = /* @__PURE__ */ new Set();
    for (let h = 0; h < a.length; h++)
      s.add(a[h].getRowNode());
    const l = [];
    t.forEach((h) => {
      s.has(h) || (h.sticky = !0, l.push(this.createRowCon(h, !1, !1)));
    });
    let u = !!l.length || a.length !== i.length;
    n ? this.topContainerHeight !== r && (this.topContainerHeight = r, this.gridBodyCtrl.setStickyTopHeight(r), u = !0) : this.bottomContainerHeight !== r && (this.bottomContainerHeight = r, this.gridBodyCtrl.setStickyBottomHeight(r), u = !0), this.destroyRowCtrls(o, !1);
    const c = [...a, ...l];
    c.sort((h, f) => f.getRowNode().rowIndex - h.getRowNode().rowIndex), n || c.reverse(), c.forEach((h) => h.setRowTop(h.getRowNode().stickyRowTop));
    let d = 0;
    return n ? (t.forEach((h) => {
      h.rowIndex < this.pageBoundsService.getFirstRow() && (d += h.rowHeight);
    }), d > this.topContainerHeight && (d = this.topContainerHeight), this.setOffsetTop(d)) : (t.forEach((h) => {
      h.rowIndex > this.pageBoundsService.getLastRow() && (d += h.rowHeight);
    }), d > this.bottomContainerHeight && (d = this.bottomContainerHeight), this.setOffsetBottom(d)), u ? (n ? this.stickyTopRowCtrls = c : this.stickyBottomRowCtrls = c, !0) : !1;
  }
  ensureRowHeightsValid() {
    let e = !1;
    const t = (r) => {
      const n = r.getRowNode();
      if (n.rowHeightEstimated) {
        const i = this.gos.getRowHeightForNode(n);
        n.setRowHeight(i.height), e = !0;
      }
    };
    return this.stickyTopRowCtrls.forEach(t), this.stickyBottomRowCtrls.forEach(t), e;
  }
}, sze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowRenderer", this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = !1, this.dataFirstRenderedFired = !1, this.setupRangeSelectionListeners = () => {
      const e = () => {
        this.getAllCellCtrls().forEach((o) => o.onRangeSelectionChanged());
      }, t = () => {
        this.getAllCellCtrls().forEach((o) => o.updateRangeBordersIfRangeCount());
      }, r = () => {
        this.eventService.addEventListener("rangeSelectionChanged", e), this.eventService.addEventListener("columnMoved", t), this.eventService.addEventListener("columnPinned", t), this.eventService.addEventListener("columnVisible", t);
      }, n = () => {
        this.eventService.removeEventListener("rangeSelectionChanged", e), this.eventService.removeEventListener("columnMoved", t), this.eventService.removeEventListener("columnPinned", t), this.eventService.removeEventListener("columnVisible", t);
      };
      this.addDestroyFunc(() => n()), this.addManagedPropertyListener("enableRangeSelection", (o) => {
        o.currentValue ? r() : n();
      }), this.gos.get("enableRangeSelection") && r();
    };
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.pinnedRowModel = e.pinnedRowModel, this.rowModel = e.rowModel, this.focusService = e.focusService, this.beans = e, this.rowContainerHeightService = e.rowContainerHeightService, this.ctrlsService = e.ctrlsService, this.environment = e.environment;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.initialise();
    });
  }
  initialise() {
    if (this.addManagedEventListeners({
      paginationChanged: this.onPageLoaded.bind(this),
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      bodyScroll: this.onBodyScroll.bind(this),
      bodyHeightChanged: this.redraw.bind(this)
    }), this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged()), this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw()), this.addManagedPropertyListeners(
      [
        "suppressCellFocus",
        "getBusinessKeyForNode",
        "fullWidthCellRenderer",
        "fullWidthCellRendererParams",
        "rowStyle",
        "getRowStyle",
        "rowClass",
        "getRowClass",
        "rowClassRules",
        "suppressStickyTotalRow",
        "groupRowRenderer",
        "groupRowRendererParams",
        // maybe only needs to refresh FW rows...
        "loadingCellRenderer",
        "loadingCellRendererParams",
        "detailCellRenderer",
        "detailCellRendererParams",
        "enableRangeSelection",
        "enableCellTextSelection"
      ],
      () => this.redrawRows()
    ), this.gos.isGroupRowsSticky()) {
      const e = this.rowModel.getType();
      (e === "clientSide" || e === "serverSide") && (this.stickyRowFeature = this.createManagedBean(
        new aze(this.createRowCon.bind(this), this.destroyRowCtrls.bind(this))
      ));
    }
    this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = this.gos.isDomLayout("print"), this.embedFullWidthRows = this.printLayout || this.gos.get("embedFullWidthRows"), this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const e = this.getKeepDetailRowsCount(), t = e ?? 3;
      this.cachedRowCtrls = new lze(t);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyTopRowCtrls() : [];
  }
  getStickyBottomRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyBottomRowCtrls() : [];
  }
  updateAllRowCtrls() {
    const e = iP(this.rowCtrlsByRowIndex), t = iP(this.zombieRowCtrls), r = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
    t.length > 0 || r.length > 0 ? this.allRowCtrls = [...e, ...t, ...r] : this.allRowCtrls = e;
  }
  onCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedEventListeners({
      cellFocused: (e) => {
        this.onCellFocusChanged(e);
      },
      cellFocusCleared: () => this.onCellFocusChanged(),
      flashCells: (e) => {
        this.getAllCellCtrls().forEach((t) => t.onFlashCells(e));
      },
      columnHoverChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onColumnHover());
      },
      displayedColumnsChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onDisplayedColumnsChanged());
      },
      displayedColumnsWidthChanged: () => {
        this.printLayout && this.getAllCellCtrls().forEach((e) => e.onLeftChanged());
      }
    }), this.setupRangeSelectionListeners(), this.refreshListenersToColumnsForCellComps(), this.addManagedEventListeners({
      gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this)
    }), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((e) => e()), this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners(), this.columnModel.getCols().forEach((t) => {
      const r = (l) => {
        this.getAllCellCtrls().forEach((u) => {
          u.getColumn() === t && l(u);
        });
      }, n = () => {
        r((l) => l.onLeftChanged());
      }, i = () => {
        r((l) => l.onWidthChanged());
      }, o = () => {
        r((l) => l.onFirstRightPinnedChanged());
      }, a = () => {
        r((l) => l.onLastLeftPinnedChanged());
      }, s = () => {
        r((l) => l.onColDefChanged());
      };
      t.addEventListener("leftChanged", n), t.addEventListener("widthChanged", i), t.addEventListener("firstRightPinnedChanged", o), t.addEventListener("lastLeftPinnedChanged", a), t.addEventListener("colDefChanged", s), this.destroyFuncsForColumnListeners.push(() => {
        t.removeEventListener("leftChanged", n), t.removeEventListener("widthChanged", i), t.removeEventListener("firstRightPinnedChanged", o), t.removeEventListener("lastLeftPinnedChanged", a), t.removeEventListener("colDefChanged", s);
      });
    });
  }
  onDomLayoutChanged() {
    const e = this.gos.isDomLayout("print"), t = e || this.gos.get("embedFullWidthRows"), r = t !== this.embedFullWidthRows || this.printLayout !== e;
    this.printLayout = e, this.embedFullWidthRows = t, r && this.redrawAfterModelUpdate({ domLayoutChanged: !0 });
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0, this.lastRenderedRow = -1;
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  onPageLoaded(e) {
    const t = {
      recycleRows: e.keepRenderedRows,
      animate: e.animate,
      newData: e.newData,
      newPage: e.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: !0
    };
    this.redrawAfterModelUpdate(t);
  }
  getAllCellsForColumn(e) {
    const t = [];
    return this.getAllRowCtrls().forEach((r) => {
      const n = r.getCellElement(e);
      n && t.push(n);
    }), t;
  }
  refreshFloatingRowComps() {
    this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowNodes()), this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowNodes());
  }
  getTopRowCtrls() {
    return this.topRowCtrls;
  }
  getCentreRowCtrls() {
    return this.allRowCtrls;
  }
  getBottomRowCtrls() {
    return this.bottomRowCtrls;
  }
  /**
   * Determines which row controllers need to be destroyed and re-created vs which ones can
   * be re-used.
   *
   * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
   *
   * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
   * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
   * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
   *
   * @param rowCtrls The list of existing row controllers
   * @param rowNodes The canonical list of row nodes that should have associated controllers
   */
  refreshFloatingRows(e, t) {
    const r = Object.fromEntries(t.map((i) => [i.id, i])), n = Object.fromEntries(e.map((i) => [i.getRowNode().id, i]));
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = e[i];
      a && r[a.getRowNode().id] === void 0 && (a.destroyFirstPass(), a.destroySecondPass()), o.id in n ? (e[i] = n[o.id], delete n[o.id]) : e[i] = new Vc(o, this.beans, !1, !1, this.printLayout);
    }
    e.length = t.length;
  }
  onPinnedRowDataChanged() {
    const e = {
      recycleRows: !0
    };
    this.redrawAfterModelUpdate(e);
  }
  redrawRow(e, t = !1) {
    var r;
    if (e.sticky)
      this.stickyRowFeature.refreshStickyNode(e);
    else if ((r = this.cachedRowCtrls) != null && r.has(e)) {
      this.cachedRowCtrls.removeRow(e);
      return;
    } else {
      const n = (i) => {
        const o = i[e.rowIndex];
        o && o.getRowNode() === e && (o.destroyFirstPass(), o.destroySecondPass(), i[e.rowIndex] = this.createRowCon(e, !1, !1));
      };
      switch (e.rowPinned) {
        case "top":
          n(this.topRowCtrls);
          break;
        case "bottom":
          n(this.bottomRowCtrls);
          break;
        default:
          n(this.rowCtrlsByRowIndex), this.updateAllRowCtrls();
      }
    }
    t || this.dispatchDisplayedRowsChanged(!1);
  }
  redrawRows(e) {
    if (e != null) {
      e == null || e.forEach((r) => this.redrawRow(r, !0)), this.dispatchDisplayedRowsChanged(!1);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  getCellToRestoreFocusToAfterRefresh(e) {
    const t = e != null && e.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();
    if (t == null)
      return null;
    const r = this.gos.getActiveDomElement(), n = this.gos.getDomData(r, kc.DOM_DATA_KEY_CELL_CTRL), i = this.gos.getDomData(r, Vc.DOM_DATA_KEY_ROW_CTRL);
    return n || i ? t : null;
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(e = {}) {
    this.getLockOnRefresh();
    const t = this.getCellToRestoreFocusToAfterRefresh(e);
    this.updateContainerHeights(), this.scrollToTopIfNewData(e);
    const r = !e.domLayoutChanged && !!e.recycleRows, n = e.animate && this.gos.isAnimateRows(), i = r ? this.getRowsToRecycle() : null;
    if (r || this.removeAllRowComps(), this.workOutFirstAndLastRowsToRender(), this.stickyRowFeature) {
      this.stickyRowFeature.checkStickyRows();
      const o = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
      o && this.updateContainerHeights(o);
    }
    this.recycleRows(i, n), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), t != null && this.restoreFocusedCell(t), this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(e) {
    var n;
    const t = e.newData || e.newPage, r = this.gos.get("suppressScrollOnNewData");
    t && !r && (this.gridBodyCtrl.getScrollFeature().scrollToTop(), (n = this.stickyRowFeature) == null || n.resetOffsets());
  }
  updateContainerHeights(e = 0) {
    if (this.printLayout) {
      this.rowContainerHeightService.setModelHeight(null);
      return;
    }
    let t = this.pageBoundsService.getCurrentPageHeight();
    t === 0 && (t = 1), this.rowContainerHeightService.setModelHeight(t + e);
  }
  getLockOnRefresh() {
    var e, t, r, n;
    if (this.refreshInProgress) {
      const i = ((t = (e = this.frameworkOverrides).getLockOnRefreshError) == null ? void 0 : t.call(e)) ?? "";
      throw new Error(
        "AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace." + i
      );
    }
    this.refreshInProgress = !0, (n = (r = this.frameworkOverrides).getLockOnRefresh) == null || n.call(r);
  }
  releaseLockOnRefresh() {
    var e, t;
    this.refreshInProgress = !1, (t = (e = this.frameworkOverrides).releaseLockOnRefresh) == null || t.call(e);
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(e) {
    e && setTimeout(() => {
      this.focusService.setRestoreFocusedCell(e), this.onCellFocusChanged(
        this.gos.addGridCommonParams({
          rowIndex: e.rowIndex,
          column: e.column,
          rowPinned: e.rowPinned,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0,
          type: "cellFocused"
        })
      );
    });
  }
  stopEditing(e = !1) {
    this.getAllRowCtrls().forEach((t) => {
      t.stopEditing(e);
    });
  }
  getAllCellCtrls() {
    const e = [], t = this.getAllRowCtrls(), r = t.length;
    for (let n = 0; n < r; n++) {
      const i = t[n].getAllCellCtrls(), o = i.length;
      for (let a = 0; a < o; a++)
        e.push(i[a]);
    }
    return e;
  }
  getAllRowCtrls() {
    const e = this.stickyRowFeature && this.stickyRowFeature.getStickyTopRowCtrls() || [], t = this.stickyRowFeature && this.stickyRowFeature.getStickyBottomRowCtrls() || [], r = [...this.topRowCtrls, ...this.bottomRowCtrls, ...e, ...t];
    for (const n in this.rowCtrlsByRowIndex)
      r.push(this.rowCtrlsByRowIndex[n]);
    return r;
  }
  addRenderedRowListener(e, t, r) {
    const n = this.rowCtrlsByRowIndex[t];
    n && n.addEventListener(e, r);
  }
  flashCells(e = {}) {
    this.getCellCtrls(e.rowNodes, e.columns).forEach(
      (t) => t.flashCell(e)
    );
  }
  refreshCells(e = {}) {
    const t = {
      forceRefresh: e.force,
      newData: !1,
      suppressFlash: e.suppressFlash
    };
    for (const r of this.getCellCtrls(e.rowNodes, e.columns))
      r.refreshOrDestroyCell(t);
    this.refreshFullWidth(e.rowNodes);
  }
  refreshFullWidth(e) {
    if (!e)
      return;
    let t = null;
    this.stickyRowFeature && $H() && (t = this.getCellToRestoreFocusToAfterRefresh() || null);
    for (const r of this.getRowCtrls(e)) {
      if (!r.isFullWidth())
        continue;
      r.refreshFullWidth() || this.redrawRow(r.getRowNode(), !0);
    }
    this.dispatchDisplayedRowsChanged(!1), t && this.restoreFocusedCell(t);
  }
  getCellRendererInstances(e) {
    var i;
    const t = this.getCellCtrls(e.rowNodes, e.columns).map((o) => o.getCellRenderer()).filter((o) => o != null);
    if ((i = e.columns) != null && i.length)
      return t;
    const r = [], n = this.mapRowNodes(e.rowNodes);
    return this.getAllRowCtrls().forEach((o) => {
      if (n && !this.isRowInMap(o.getRowNode(), n) || !o.isFullWidth())
        return;
      const a = o.getFullWidthCellRenderers();
      for (let s = 0; s < a.length; s++) {
        const l = a[s];
        l != null && r.push(l);
      }
    }), [...r, ...t];
  }
  getCellEditorInstances(e) {
    const t = [];
    return this.getCellCtrls(e.rowNodes, e.columns).forEach((r) => {
      const n = r.getCellEditor();
      n && t.push(n);
    }), t;
  }
  getEditingCells() {
    const e = [];
    return this.getAllCellCtrls().forEach((t) => {
      if (t.isEditing()) {
        const r = t.getCellPosition();
        e.push(r);
      }
    }), e;
  }
  mapRowNodes(e) {
    if (!e)
      return;
    const t = {
      top: {},
      bottom: {},
      normal: {}
    };
    return e.forEach((r) => {
      const n = r.id;
      switch (r.rowPinned) {
        case "top":
          t.top[n] = r;
          break;
        case "bottom":
          t.bottom[n] = r;
          break;
        default:
          t.normal[n] = r;
          break;
      }
    }), t;
  }
  isRowInMap(e, t) {
    const r = e.id;
    switch (e.rowPinned) {
      case "top":
        return t.top[r] != null;
      case "bottom":
        return t.bottom[r] != null;
      default:
        return t.normal[r] != null;
    }
  }
  /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */
  getRowCtrls(e) {
    const t = this.mapRowNodes(e), r = this.getAllRowCtrls();
    return !e || !t ? r : r.filter((n) => {
      const i = n.getRowNode();
      return this.isRowInMap(i, t);
    });
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(e, t) {
    let r;
    ke(t) && (r = {}, t.forEach((i) => {
      const o = this.columnModel.getCol(i);
      ke(o) && (r[o.getId()] = !0);
    }));
    const n = [];
    return this.getRowCtrls(e).forEach((i) => {
      i.getAllCellCtrls().forEach((o) => {
        const a = o.getColumn().getId();
        r && !r[a] || n.push(o);
      });
    }), n;
  }
  destroy() {
    this.removeAllRowComps(), super.destroy();
  }
  removeAllRowComps() {
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e), this.stickyRowFeature && this.stickyRowFeature.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const e = [];
    wa(this.rowCtrlsByRowIndex, (r, n) => {
      n.getRowNode().id == null && e.push(r);
    }), this.removeRowCtrls(e);
    const t = {};
    return wa(this.rowCtrlsByRowIndex, (r, n) => {
      const i = n.getRowNode();
      t[i.id] = n;
    }), this.rowCtrlsByRowIndex = {}, t;
  }
  // takes array of row indexes
  removeRowCtrls(e, t = !1) {
    e.forEach((r) => {
      const n = this.rowCtrlsByRowIndex[r];
      n && (n.destroyFirstPass(t), n.destroySecondPass()), delete this.rowCtrlsByRowIndex[r];
    });
  }
  onBodyScroll(e) {
    e.direction === "vertical" && this.redraw({ afterScroll: !0 });
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(e = {}) {
    const { afterScroll: t } = e;
    let r;
    this.stickyRowFeature && $H() && (r = this.getCellToRestoreFocusToAfterRefresh() || void 0);
    const n = this.firstRenderedRow, i = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let o = !1;
    if (this.stickyRowFeature) {
      o = this.stickyRowFeature.checkStickyRows();
      const s = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
      s && this.updateContainerHeights(s);
    }
    const a = this.firstRenderedRow !== n || this.lastRenderedRow !== i;
    if (!(t && !o && !a) && (this.getLockOnRefresh(), this.recycleRows(null, !1, t), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(t && !o), r != null)) {
      const s = this.getCellToRestoreFocusToAfterRefresh();
      r != null && s == null && (this.animationFrameService.flushAllFrames(), this.restoreFocusedCell(r));
    }
  }
  removeRowCompsNotToDraw(e, t) {
    const r = {};
    e.forEach((o) => r[o] = !0);
    const i = Object.keys(this.rowCtrlsByRowIndex).filter((o) => !r[o]);
    this.removeRowCtrls(i, t);
  }
  calculateIndexesToDraw(e) {
    const t = f$e(this.firstRenderedRow, this.lastRenderedRow), r = (i, o) => {
      const a = o.getRowNode().rowIndex;
      a != null && (a < this.firstRenderedRow || a > this.lastRenderedRow) && this.doNotUnVirtualiseRow(o) && t.push(a);
    };
    wa(this.rowCtrlsByRowIndex, r), wa(e, r), t.sort((i, o) => i - o);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = this.rowModel.getRow(o);
      a && !a.sticky && n.push(o);
    }
    return n;
  }
  recycleRows(e, t = !1, r = !1) {
    const n = this.calculateIndexesToDraw(e);
    (this.printLayout || r) && (t = !1), this.removeRowCompsNotToDraw(n, !t), n.forEach((i) => {
      this.createOrUpdateRowCtrl(i, e, t, r);
    }), e && (r && !this.gos.get("suppressAnimationFrame") && !this.printLayout ? this.beans.animationFrameService.addDestroyTask(() => {
      this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }) : this.destroyRowCtrls(e, t)), this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(e = !1) {
    const t = {
      type: "displayedRowsChanged",
      afterScroll: e
    };
    this.eventService.dispatchEvent(t);
  }
  onDisplayedColumnsChanged() {
    const e = this.visibleColsService.isPinningLeft(), t = this.visibleColsService.isPinningRight();
    (this.pinningLeft !== e || t !== this.pinningRight) && (this.pinningLeft = e, this.pinningRight = t, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const e = [];
    this.getFullWidthRowCtrls().forEach((t) => {
      const r = t.getRowNode().rowIndex;
      e.push(r.toString());
    }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw({ afterScroll: !0 });
  }
  getFullWidthRowCtrls(e) {
    const t = this.mapRowNodes(e);
    return this.getAllRowCtrls().filter((r) => {
      if (!r.isFullWidth())
        return !1;
      const n = r.getRowNode();
      return !(t != null && !this.isRowInMap(n, t));
    });
  }
  createOrUpdateRowCtrl(e, t, r, n) {
    let i, o = this.rowCtrlsByRowIndex[e];
    if (o || (i = this.rowModel.getRow(e), ke(i) && ke(t) && t[i.id] && i.alreadyRendered && (o = t[i.id], t[i.id] = null)), !o)
      if (i || (i = this.rowModel.getRow(e)), ke(i))
        o = this.createRowCon(i, r, n);
      else
        return;
    return i && (i.alreadyRendered = !0), this.rowCtrlsByRowIndex[e] = o, o;
  }
  destroyRowCtrls(e, t) {
    const r = [];
    wa(e, (n, i) => {
      if (i) {
        if (this.cachedRowCtrls && i.isCacheable()) {
          this.cachedRowCtrls.addRow(i);
          return;
        }
        i.destroyFirstPass(!t), t ? (this.zombieRowCtrls[i.getInstanceId()] = i, r.push(() => {
          i.destroySecondPass(), delete this.zombieRowCtrls[i.getInstanceId()];
        })) : i.destroySecondPass();
      }
    }), t && (r.push(() => {
      this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }), rBe(r));
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const e = this.getRowBuffer(), t = this.gos.getRowHeightAsNumber();
    return e * t;
  }
  workOutFirstAndLastRowsToRender() {
    this.rowContainerHeightService.updateOffset();
    let e, t;
    if (!this.rowModel.isRowsToRender())
      e = 0, t = -1;
    else if (this.printLayout)
      this.environment.refreshRowHeightVariable(), e = this.pageBoundsService.getFirstRow(), t = this.pageBoundsService.getLastRow();
    else {
      const s = this.getRowBufferInPixels(), l = this.ctrlsService.getGridBodyCtrl(), u = this.gos.get("suppressRowVirtualisation");
      let c = !1, d, h;
      do {
        const m = this.pageBoundsService.getPixelOffset(), { pageFirstPixel: y, pageLastPixel: C } = this.pageBoundsService.getCurrentPagePixelRange(), S = this.rowContainerHeightService.getDivStretchOffset(), b = l.getScrollFeature().getVScrollPosition(), w = b.top, x = b.bottom;
        u ? (d = y + S, h = C + S) : (d = Math.max(w + m - s, y) + S, h = Math.min(x + m + s, C) + S), this.firstVisibleVPixel = Math.max(w + m, y) + S, this.lastVisibleVPixel = Math.min(x + m, C) + S, c = this.ensureAllRowsInRangeHaveHeightsCalculated(d, h);
      } while (c);
      let f = this.rowModel.getRowIndexAtPixel(d), p = this.rowModel.getRowIndexAtPixel(h);
      const g = this.pageBoundsService.getFirstRow(), v = this.pageBoundsService.getLastRow();
      f < g && (f = g), p > v && (p = v), e = f, t = p;
    }
    const r = this.gos.isDomLayout("normal"), n = this.gos.get("suppressMaxRenderedRowRestriction"), i = Math.max(this.getRowBuffer(), 500);
    r && !n && t - e > i && (t = e + i);
    const o = e !== this.firstRenderedRow, a = t !== this.lastRenderedRow;
    if (o || a) {
      this.firstRenderedRow = e, this.lastRenderedRow = t;
      const s = {
        type: "viewportChanged",
        firstRow: e,
        lastRow: t
      };
      this.eventService.dispatchEvent(s);
    }
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    if (this.dataFirstRenderedFired)
      return;
    this.dataFirstRenderedFired = !0;
    const e = {
      type: "firstDataRendered",
      firstRow: this.firstRenderedRow,
      lastRow: this.lastRenderedRow
    };
    window.requestAnimationFrame(() => {
      this.beans.eventService.dispatchEvent(e);
    });
  }
  ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
    var o, a;
    const r = (o = this.pinnedRowModel) == null ? void 0 : o.ensureRowHeightsValid(), n = (a = this.stickyRowFeature) == null ? void 0 : a.ensureRowHeightsValid(), i = this.rowModel.ensureRowHeightsValid(
      e,
      t,
      this.pageBoundsService.getFirstRow(),
      this.pageBoundsService.getLastRow()
    );
    return (i || n) && this.eventService.dispatchEvent({
      type: "recalculateRowBounds"
    }), n || i || r ? (this.updateContainerHeights(), !0) : !1;
  }
  getFirstVisibleVerticalPixel() {
    return this.firstVisibleVPixel;
  }
  getLastVisibleVerticalPixel() {
    return this.lastVisibleVPixel;
  }
  getFirstVirtualRenderedRow() {
    return this.firstRenderedRow;
  }
  getLastVirtualRenderedRow() {
    return this.lastRenderedRow;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(e) {
    const n = e.getRowNode(), i = this.focusService.isRowNodeFocused(n), o = e.isEditing(), a = n.detail;
    return i || o || a ? !!this.isRowPresent(n) : !1;
  }
  isRowPresent(e) {
    return this.rowModel.isRowPresent(e) ? this.paginationService ? this.paginationService.isRowPresent(e) : !0 : !1;
  }
  createRowCon(e, t, r) {
    const n = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(e) : null;
    if (n)
      return n;
    const i = this.gos.get("suppressAnimationFrame"), o = r && !i && !this.printLayout;
    return new Vc(e, this.beans, t, o, this.printLayout);
  }
  getRenderedNodes() {
    const e = this.rowCtrlsByRowIndex;
    return Object.values(e).map((t) => t.getRowNode());
  }
  getRowByPosition(e) {
    let t;
    const { rowIndex: r } = e;
    switch (e.rowPinned) {
      case "top":
        t = this.topRowCtrls[r];
        break;
      case "bottom":
        t = this.bottomRowCtrls[r];
        break;
      default:
        t = this.rowCtrlsByRowIndex[r], t || (t = this.getStickyTopRowCtrls().find((n) => n.getRowNode().rowIndex === r) || null, t || (t = this.getStickyBottomRowCtrls().find((n) => n.getRowNode().rowIndex === r) || null));
        break;
    }
    return t;
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(e, t) {
    if (e == null || t == null)
      return !1;
    const n = e > this.lastRenderedRow;
    return !(t < this.firstRenderedRow) && !n;
  }
}, lze = class {
  constructor(e) {
    this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
  }
  addRow(e) {
    if (this.entriesMap[e.getRowNode().id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
      const t = this.entriesList[0];
      t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
    }
  }
  getRow(e) {
    if (e == null || e.id == null)
      return null;
    const t = this.entriesMap[e.id];
    return t ? (this.removeFromCache(t), t.setCached(!1), t.getRowNode() != e ? null : t) : null;
  }
  has(e) {
    return this.entriesMap[e.id] != null;
  }
  removeRow(e) {
    const t = e.id, r = this.entriesMap[t];
    delete this.entriesMap[t], _i(this.entriesList, r);
  }
  removeFromCache(e) {
    const t = e.getRowNode().id;
    delete this.entriesMap[t], _i(this.entriesList, e);
  }
  getEntries() {
    return this.entriesList;
  }
}, uze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "pinnedRowModel", this.nextId = 0;
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.setPinnedTopRowData(), this.setPinnedBottomRowData(), this.addManagedPropertyListener("pinnedTopRowData", () => this.setPinnedTopRowData()), this.addManagedPropertyListener("pinnedBottomRowData", () => this.setPinnedBottomRowData()), this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanges.bind(this) });
  }
  isEmpty(e) {
    const t = e === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    return Wn(t);
  }
  isRowsToRender(e) {
    return !this.isEmpty(e);
  }
  getRowAtPixel(e, t) {
    const r = t === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    if (Wn(r))
      return 0;
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      if (i.rowTop + i.rowHeight - 1 >= e)
        return n;
    }
    return r.length - 1;
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      const t = (r) => {
        r.setRowHeight(r.rowHeight, !0);
      };
      this.pinnedBottomRows.forEach(t), this.pinnedTopRows.forEach(t);
    }
  }
  ensureRowHeightsValid() {
    var i, o;
    let e = !1, t = 0;
    const r = (a) => {
      if (a.rowHeightEstimated) {
        const s = this.gos.getRowHeightForNode(a);
        a.setRowTop(t), a.setRowHeight(s.height), t += s.height, e = !0;
      }
    };
    (i = this.pinnedBottomRows) == null || i.forEach(r), t = 0, (o = this.pinnedTopRows) == null || o.forEach(r);
    const n = {
      type: "pinnedHeightChanged"
    };
    return this.eventService.dispatchEvent(n), e;
  }
  setPinnedTopRowData() {
    const e = this.gos.get("pinnedTopRowData");
    this.pinnedTopRows = this.createNodesFromData(e, !0);
    const t = {
      type: "pinnedRowDataChanged"
    };
    this.eventService.dispatchEvent(t);
  }
  setPinnedBottomRowData() {
    const e = this.gos.get("pinnedBottomRowData");
    this.pinnedBottomRows = this.createNodesFromData(e, !1);
    const t = {
      type: "pinnedRowDataChanged"
    };
    this.eventService.dispatchEvent(t);
  }
  createNodesFromData(e, t) {
    const r = [];
    if (e) {
      const n = this.gos.getRowIdCallback(), i = t ? Ks.ID_PREFIX_TOP_PINNED : Ks.ID_PREFIX_BOTTOM_PINNED;
      let o = 0;
      const a = t ? "top" : "bottom";
      e.forEach((s, l) => {
        const u = new Ks(this.beans);
        u.data = s, u.id = (n == null ? void 0 : n({ data: s, level: 0, rowPinned: a })) ?? i + this.nextId++, u.rowPinned = a, u.setRowTop(o), u.setRowHeight(this.gos.getRowHeightForNode(u).height), u.setRowIndex(l), o += u.rowHeight, r.push(u);
      });
    }
    return r;
  }
  getPinnedTopRowNodes() {
    return this.pinnedTopRows;
  }
  getPinnedBottomRowNodes() {
    return this.pinnedBottomRows;
  }
  getPinnedTopTotalHeight() {
    return this.getTotalHeight(this.pinnedTopRows);
  }
  getPinnedTopRowCount() {
    return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
  }
  getPinnedBottomRowCount() {
    return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
  }
  getPinnedTopRow(e) {
    return this.pinnedTopRows[e];
  }
  getPinnedBottomRow(e) {
    return this.pinnedBottomRows[e];
  }
  forEachPinnedTopRow(e) {
    Wn(this.pinnedTopRows) || this.pinnedTopRows.forEach(e);
  }
  forEachPinnedBottomRow(e) {
    Wn(this.pinnedBottomRows) || this.pinnedBottomRows.forEach(e);
  }
  getPinnedBottomTotalHeight() {
    return this.getTotalHeight(this.pinnedBottomRows);
  }
  getTotalHeight(e) {
    if (!e || e.length === 0)
      return 0;
    const t = gr(e);
    return t.rowTop + t.rowHeight;
  }
}, cze = class extends Se {
  constructor(e) {
    super(), this.state = "needsLoading", this.version = 0, this.id = e;
  }
  getId() {
    return this.id;
  }
  load() {
    this.state = "loading", this.loadFromDatasource();
  }
  getVersion() {
    return this.version;
  }
  setStateWaitingToLoad() {
    this.version++, this.state = "needsLoading";
  }
  getState() {
    return this.state;
  }
  pageLoadFailed(e) {
    this.isRequestMostRecentAndLive(e) && (this.state = "failed", this.processServerFail()), this.dispatchLoadCompleted(!1);
  }
  success(e, t) {
    this.successCommon(e, t);
  }
  pageLoaded(e, t, r) {
    this.successCommon(e, { rowData: t, rowCount: r });
  }
  isRequestMostRecentAndLive(e) {
    const t = e === this.version, r = this.isAlive();
    return t && r;
  }
  successCommon(e, t) {
    this.dispatchLoadCompleted(), this.isRequestMostRecentAndLive(e) && (this.state = "loaded", this.processServerResult(t));
  }
  dispatchLoadCompleted(e = !0) {
    const t = {
      type: "loadComplete",
      success: e,
      block: this
    };
    this.dispatchLocalEvent(t);
  }
}, dze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowNodeBlockLoader", this.activeBlockLoadsCount = 0, this.blocks = [], this.active = !0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests();
    const e = this.gos.get("blockLoadDebounceMillis");
    e && e > 0 && (this.checkBlockToLoadDebounce = Ti(
      this.performCheckBlocksToLoad.bind(this),
      e
    ));
  }
  getMaxConcurrentDatasourceRequests() {
    const e = this.gos.get("maxConcurrentDatasourceRequests");
    if (e == null)
      return 2;
    if (!(e <= 0))
      return e;
  }
  addBlock(e) {
    this.blocks.push(e), e.addEventListener("loadComplete", this.loadComplete.bind(this)), this.checkBlockToLoad();
  }
  removeBlock(e) {
    _i(this.blocks, e);
  }
  destroy() {
    super.destroy(), this.active = !1;
  }
  loadComplete() {
    this.activeBlockLoadsCount--, this.checkBlockToLoad(), this.dispatchLocalEvent({ type: "blockLoaded" }), this.activeBlockLoadsCount == 0 && this.dispatchLocalEvent({ type: "blockLoaderFinished" });
  }
  checkBlockToLoad() {
    this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad();
  }
  performCheckBlocksToLoad() {
    if (!this.active)
      return;
    if (this.printCacheStatus(), this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
      this.gos.get("debug") && Ea("RowNodeBlockLoader - checkBlockToLoad: max loads exceeded");
      return;
    }
    const e = this.getAvailableLoadingCount(), t = this.blocks.filter((r) => r.getState() === "needsLoading").slice(0, e);
    this.registerLoads(t.length), t.forEach((r) => r.load()), this.printCacheStatus();
  }
  getBlockState() {
    if (this.gos.isRowModelType("serverSide"))
      return this.rowModel.getBlockStates();
    const e = {};
    return this.blocks.forEach((t) => {
      const { id: r, state: n } = t.getBlockStateJson();
      e[r] = n;
    }), e;
  }
  printCacheStatus() {
    this.gos.get("debug") && Ea(
      `RowNodeBlockLoader - printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`
    );
  }
  isLoading() {
    return this.activeBlockLoadsCount > 0;
  }
  registerLoads(e) {
    this.activeBlockLoadsCount += e;
  }
  getAvailableLoadingCount() {
    return this.maxConcurrentRequests !== void 0 ? this.maxConcurrentRequests - this.activeBlockLoadsCount : void 0;
  }
}, hze = {
  version: kt,
  moduleName: "@ag-grid-community/row-node-block",
  beans: [dze]
}, fze = class {
  constructor() {
    this.root = null, this.end = null, this.cachedRange = [];
  }
  init(e) {
    this.rowModel = e;
  }
  reset() {
    this.root = null, this.end = null, this.cachedRange.length = 0;
  }
  setRoot(e) {
    this.root = e, this.end = null, this.cachedRange.length = 0;
  }
  setEndRange(e) {
    this.end = e, this.cachedRange.length = 0;
  }
  getRange() {
    if (this.cachedRange.length === 0) {
      const e = this.getRoot(), t = this.getEnd();
      if (e == null || t == null)
        return this.cachedRange;
      this.cachedRange = this.rowModel.getNodesInRangeForSelection(e, t);
    }
    return this.cachedRange;
  }
  isInRange(e) {
    return this.root === null ? !1 : this.getRange().some((t) => t.id === e.id);
  }
  getRoot() {
    var e;
    return this.root && ((e = this.root) == null ? void 0 : e.key) === null && (this.root = this.rowModel.getRowNode(this.root.id) ?? null), this.root;
  }
  getEnd() {
    var e;
    return this.end && ((e = this.end) == null ? void 0 : e.key) === null && (this.end = this.rowModel.getRowNode(this.end.id) ?? null), this.end;
  }
  /**
   * Truncates the range to the given node (assumed to be within the current range).
   * Returns nodes that remain in the current range and those that should be removed
   *
   * @param node - Node at which to truncate the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  truncate(e) {
    const t = this.getRange();
    if (t.length === 0)
      return { keep: [], discard: [] };
    const r = t[0].id === this.root.id, n = t.findIndex((i) => i.id === e.id);
    if (n > -1) {
      const i = t.slice(0, n), o = t.slice(n + 1);
      return this.setEndRange(e), r ? { keep: i, discard: o } : { keep: o, discard: i };
    } else
      return { keep: t, discard: [] };
  }
  /**
   * Extends the range to the given node. Returns nodes that remain in the current range
   * and those that should be removed.
   *
   * @param node - Node marking the new end of the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  extend(e, t = !1) {
    const r = this.getRoot();
    if (r == null) {
      const i = this.getRange().slice();
      return t && e.depthFirstSearch((o) => !o.group && i.push(o)), i.push(e), this.setRoot(e), { keep: i, discard: [] };
    }
    if (this.rowModel.getNodesInRangeForSelection(r, e).find((i) => {
      var o;
      return i.id === ((o = this.end) == null ? void 0 : o.id);
    }))
      return this.setEndRange(e), { keep: this.getRange(), discard: [] };
    {
      const i = this.getRange().slice();
      return this.setEndRange(e), { keep: this.getRange(), discard: i };
    }
  }
}, pze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "stylingService";
  }
  wireBeans(e) {
    this.expressionService = e.expressionService;
  }
  processAllCellClasses(e, t, r, n) {
    this.processClassRules(void 0, e.cellClassRules, t, r, n), this.processStaticCellClasses(e, t, r);
  }
  processClassRules(e, t, r, n, i) {
    if (t == null && e == null)
      return;
    const o = {}, a = {}, s = (l, u) => {
      l.split(" ").forEach((c) => {
        c.trim() != "" && u(c);
      });
    };
    if (t) {
      const l = Object.keys(t);
      for (let u = 0; u < l.length; u++) {
        const c = l[u], d = t[c];
        let h;
        typeof d == "string" ? h = this.expressionService.evaluate(d, r) : typeof d == "function" && (h = d(r)), s(c, (f) => {
          h ? o[f] = !0 : a[f] = !0;
        });
      }
    }
    e && i && Object.keys(e).forEach(
      (l) => s(l, (u) => {
        o[u] || (a[u] = !0);
      })
    ), i && Object.keys(a).forEach(i), Object.keys(o).forEach(n);
  }
  getStaticCellClasses(e, t) {
    const { cellClass: r } = e;
    if (!r)
      return [];
    let n;
    return typeof r == "function" ? n = r(t) : n = r, typeof n == "string" && (n = [n]), n || [];
  }
  processStaticCellClasses(e, t, r) {
    this.getStaticCellClasses(e, t).forEach((i) => {
      r(i);
    });
  }
}, E0 = /* @__PURE__ */ ((e) => (e.TAB_GUARD = "ag-tab-guard", e.TAB_GUARD_TOP = "ag-tab-guard-top", e.TAB_GUARD_BOTTOM = "ag-tab-guard-bottom", e))(E0 || {}), eX = class extends Se {
  constructor(e) {
    super(), this.skipTabGuardFocus = !1, this.forcingFocusOut = !1, this.allowFocus = !1;
    const {
      comp: t,
      eTopGuard: r,
      eBottomGuard: n,
      focusTrapActive: i,
      forceFocusOutWhenTabGuardsAreEmpty: o,
      isFocusableContainer: a,
      focusInnerElement: s,
      onFocusIn: l,
      onFocusOut: u,
      shouldStopEventPropagation: c,
      onTabKeyDown: d,
      handleKeyDown: h,
      eFocusableElement: f
    } = e;
    this.comp = t, this.eTopGuard = r, this.eBottomGuard = n, this.providedFocusInnerElement = s, this.eFocusableElement = f, this.focusTrapActive = !!i, this.forceFocusOutWhenTabGuardsAreEmpty = !!o, this.isFocusableContainer = !!a, this.providedFocusIn = l, this.providedFocusOut = u, this.providedShouldStopEventPropagation = c, this.providedOnTabKeyDown = d, this.providedHandleKeyDown = h;
  }
  wireBeans(e) {
    this.focusService = e.focusService;
  }
  postConstruct() {
    this.createManagedBean(
      new gd(this.eFocusableElement, {
        shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e)
      })
    ), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(
      (e) => this.addManagedElementListeners(e, { focus: this.onFocus.bind(this) })
    );
  }
  handleKeyDown(e) {
    this.providedHandleKeyDown && this.providedHandleKeyDown(e);
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
  }
  activateTabGuards() {
    if (this.forcingFocusOut)
      return;
    const e = this.gos.get("tabIndex");
    this.comp.setTabIndex(e.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget) && !this.allowFocus) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = !1;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty && this.focusService.findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget))
      return;
    const t = e.target === this.eBottomGuard;
    this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t);
  }
  findNextElementOutsideAndFocus(e) {
    const t = this.gos.getDocument(), r = this.focusService.findFocusableElements(t.body, null, !0), n = r.indexOf(e ? this.eTopGuard : this.eBottomGuard);
    if (n === -1)
      return;
    let i, o;
    e ? (i = 0, o = n) : (i = n + 1, o = r.length);
    const a = r.slice(i, o), s = this.gos.get("tabIndex");
    a.sort((l, u) => {
      const c = parseInt(l.getAttribute("tabindex") || "0"), d = parseInt(u.getAttribute("tabindex") || "0");
      return d === s ? 1 : c === s ? -1 : c === 0 ? 1 : d === 0 ? -1 : c - d;
    }), a[e ? a.length - 1 : 0].focus();
  }
  onFocusIn(e) {
    this.focusTrapActive || this.forcingFocusOut || (this.providedFocusIn && this.providedFocusIn(e), this.isFocusableContainer || this.deactivateTabGuards());
  }
  onFocusOut(e) {
    this.focusTrapActive || (this.providedFocusOut && this.providedFocusOut(e), this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards());
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive || e.defaultPrevented)
      return;
    const t = this.tabGuardsAreActive();
    t && this.deactivateTabGuards();
    const r = this.getNextFocusableElement(e.shiftKey);
    t && setTimeout(() => this.activateTabGuards(), 0), r && (r.focus(), e.preventDefault());
  }
  focusInnerElement(e = !1) {
    const t = this.focusService.findFocusableElements(this.eFocusableElement);
    this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length && t[e ? t.length - 1 : 0].focus({ preventScroll: !0 });
  }
  getNextFocusableElement(e) {
    return this.focusService.findNextFocusableElement(this.eFocusableElement, !1, e);
  }
  forceFocusOutOfContainer(e = !1) {
    if (this.forcingFocusOut)
      return;
    const t = e ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards(), this.skipTabGuardFocus = !0, this.forcingFocusOut = !0, t.focus(), window.setTimeout(() => {
      this.forcingFocusOut = !1, this.activateTabGuards();
    });
  }
  isTabGuard(e, t) {
    return e === this.eTopGuard && !t || e === this.eBottomGuard && (t ?? !0);
  }
  setAllowFocus(e) {
    this.allowFocus = e;
  }
}, gze = class extends Se {
  constructor(e) {
    super(), this.comp = e;
  }
  initialiseTabGuard(e) {
    this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.comp.getFocusableElement();
    const { eTopGuard: t, eBottomGuard: r, eFocusableElement: n } = this, i = [t, r], o = {
      setTabIndex: (g) => {
        i.forEach(
          (v) => g != null ? v.setAttribute("tabindex", g) : v.removeAttribute("tabindex")
        );
      }
    };
    this.addTabGuards(t, r);
    const {
      focusTrapActive: a = !1,
      onFocusIn: s,
      onFocusOut: l,
      focusInnerElement: u,
      handleKeyDown: c,
      onTabKeyDown: d,
      shouldStopEventPropagation: h,
      forceFocusOutWhenTabGuardsAreEmpty: f,
      isFocusableContainer: p
    } = e;
    this.tabGuardCtrl = this.createManagedBean(
      new eX({
        comp: o,
        focusTrapActive: a,
        eTopGuard: t,
        eBottomGuard: r,
        eFocusableElement: n,
        onFocusIn: s,
        onFocusOut: l,
        focusInnerElement: u,
        handleKeyDown: c,
        onTabKeyDown: d,
        shouldStopEventPropagation: h,
        forceFocusOutWhenTabGuardsAreEmpty: f,
        isFocusableContainer: p
      })
    );
  }
  getTabGuardCtrl() {
    return this.tabGuardCtrl;
  }
  createTabGuard(e) {
    const t = this.gos.getDocument().createElement("div"), r = e === "top" ? "ag-tab-guard-top" : "ag-tab-guard-bottom";
    return t.classList.add("ag-tab-guard", r), Na(t, "presentation"), t;
  }
  addTabGuards(e, t) {
    this.eFocusableElement.insertAdjacentElement("afterbegin", e), this.eFocusableElement.insertAdjacentElement("beforeend", t);
  }
  removeAllChildrenExceptTabGuards() {
    const e = [this.eTopGuard, this.eBottomGuard];
    xo(this.comp.getFocusableElement()), this.addTabGuards(...e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardCtrl.forceFocusOutOfContainer(e);
  }
  appendChild(e, t, r) {
    cI(t) || (t = t.getGui());
    const { eBottomGuard: n } = this;
    n ? n.insertAdjacentElement("beforebegin", t) : e(t, r);
  }
}, vze = class extends tn {
  initialiseTabGuard(t) {
    this.tabGuardFeature = this.createManagedBean(new gze(this)), this.tabGuardFeature.initialiseTabGuard(t);
  }
  forceFocusOutOfContainer(t = !1) {
    this.tabGuardFeature.forceFocusOutOfContainer(t);
  }
  appendChild(t, r) {
    this.tabGuardFeature.appendChild(super.appendChild.bind(this), t, r);
  }
}, mze = 0, yze = 200, Cze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "popupService", this.popupList = [];
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.resizeObserverService = e.resizeObserverService, this.environment = e.environment;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridCtrl = e.gridCtrl;
    }), this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
  }
  getPopupParent() {
    const e = this.gos.get("popupParent");
    return e || this.gridCtrl.getGui();
  }
  positionPopupForMenu(e) {
    const { eventSource: t, ePopup: r } = e, n = this.getPopupIndex(r);
    if (n !== -1) {
      const f = this.popupList[n];
      f.alignedToElement = t;
    }
    const i = t.getBoundingClientRect(), o = this.getParentRect(), a = this.keepXYWithinBounds(
      r,
      i.top - o.top,
      0
      /* vertical */
    ), s = r.clientWidth > 0 ? r.clientWidth : 200;
    r.style.minWidth = `${s}px`;
    const u = o.right - o.left - s;
    let c;
    this.gos.get("enableRtl") ? (c = h(), c < 0 && (c = d(), this.setAlignedStyles(r, "left")), c > u && (c = 0, this.setAlignedStyles(r, "right"))) : (c = d(), c > u && (c = h(), this.setAlignedStyles(r, "right")), c < 0 && (c = 0, this.setAlignedStyles(r, "left"))), r.style.left = `${c}px`, r.style.top = `${a}px`;
    function d() {
      return i.right - o.left - 2;
    }
    function h() {
      return i.left - o.left - s;
    }
  }
  positionPopupUnderMouseEvent(e) {
    const { ePopup: t, nudgeX: r, nudgeY: n, skipObserver: i } = e;
    this.positionPopup({
      ePopup: t,
      nudgeX: r,
      nudgeY: n,
      keepWithinBounds: !0,
      skipObserver: i,
      updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(
        e.type,
        e.ePopup,
        null,
        e.mouseEvent,
        e.column,
        e.rowNode
      )
    });
  }
  calculatePointerAlign(e) {
    const t = this.getParentRect();
    return {
      x: e.clientX - t.left,
      y: e.clientY - t.top
    };
  }
  positionPopupByComponent(e) {
    const {
      ePopup: t,
      nudgeX: r,
      nudgeY: n,
      keepWithinBounds: i,
      eventSource: o,
      alignSide: a = "left",
      position: s = "over",
      column: l,
      rowNode: u,
      type: c
    } = e, d = o.getBoundingClientRect(), h = this.getParentRect(), f = this.getPopupIndex(t);
    if (f !== -1) {
      const g = this.popupList[f];
      g.alignedToElement = o;
    }
    const p = () => {
      let g = d.left - h.left;
      a === "right" && (g -= t.offsetWidth - d.width);
      let v;
      return s === "over" ? (v = d.top - h.top, this.setAlignedStyles(t, "over")) : (this.setAlignedStyles(t, "under"), this.shouldRenderUnderOrAbove(t, d, h, e.nudgeY || 0) === "under" ? v = d.top - h.top + d.height : v = d.top - t.offsetHeight - (n || 0) * 2 - h.top), { x: g, y: v };
    };
    this.positionPopup({
      ePopup: t,
      nudgeX: r,
      nudgeY: n,
      keepWithinBounds: i,
      updatePosition: p,
      postProcessCallback: () => this.callPostProcessPopup(c, t, o, null, l, u)
    });
  }
  shouldRenderUnderOrAbove(e, t, r, n) {
    const i = r.bottom - t.bottom, o = t.top - r.top, a = e.offsetHeight + n;
    return i > a ? "under" : o > a || o > i ? "above" : "under";
  }
  setAlignedStyles(e, t) {
    const r = this.getPopupIndex(e);
    if (r === -1)
      return;
    const n = this.popupList[r], { alignedToElement: i } = n;
    !i || (["right", "left", "over", "above", "under"].forEach((a) => {
      i.classList.remove(`ag-has-popup-positioned-${a}`), e.classList.remove(`ag-popup-positioned-${a}`);
    }), !t) || (i.classList.add(`ag-has-popup-positioned-${t}`), e.classList.add(`ag-popup-positioned-${t}`));
  }
  callPostProcessPopup(e, t, r, n, i, o) {
    const a = this.gos.getCallback("postProcessPopup");
    a && a({
      column: i,
      rowNode: o,
      ePopup: t,
      type: e,
      eventSource: r,
      mouseEvent: n
    });
  }
  positionPopup(e) {
    const { ePopup: t, keepWithinBounds: r, nudgeX: n, nudgeY: i, skipObserver: o, updatePosition: a } = e, s = { width: 0, height: 0 }, l = (u = !1) => {
      let { x: c, y: d } = a();
      u && t.clientWidth === s.width && t.clientHeight === s.height || (s.width = t.clientWidth, s.height = t.clientHeight, n && (c += n), i && (d += i), r && (c = this.keepXYWithinBounds(
        t,
        c,
        1
        /* horizontal */
      ), d = this.keepXYWithinBounds(
        t,
        d,
        0
        /* vertical */
      )), t.style.left = `${c}px`, t.style.top = `${d}px`, e.postProcessCallback && e.postProcessCallback());
    };
    if (l(), !o) {
      const u = this.resizeObserverService.observeResize(
        t,
        () => l(!0)
      );
      setTimeout(() => u(), yze);
    }
  }
  getActivePopups() {
    return this.popupList.map((e) => e.element);
  }
  getPopupList() {
    return this.popupList;
  }
  getParentRect() {
    const e = this.gos.getDocument();
    let t = this.getPopupParent();
    return t === e.body ? t = e.documentElement : getComputedStyle(t).position === "static" && (t = t.offsetParent), JY(t);
  }
  keepXYWithinBounds(e, t, r) {
    const n = r === 0, i = n ? "clientHeight" : "clientWidth", o = n ? "top" : "left", a = n ? "height" : "width", s = n ? "scrollTop" : "scrollLeft", l = this.gos.getDocument(), u = l.documentElement, c = this.getPopupParent(), d = e.getBoundingClientRect(), h = c.getBoundingClientRect(), f = l.documentElement.getBoundingClientRect(), p = c === l.body, g = Math.ceil(d[a]);
    let m = p ? (n ? QY : rS)(u) + u[s] : c[i];
    p && (m -= Math.abs(f[o] - h[o]));
    const y = m - g;
    return Math.min(Math.max(t, 0), Math.abs(y));
  }
  addPopup(e) {
    const t = this.gos.getDocument(), { eChild: r, ariaLabel: n, alwaysOnTop: i, positionCallback: o, anchorToElement: a } = e;
    if (!t)
      return Te("could not find the document, document is empty"), { hideFunc: () => {
      } };
    const s = this.getPopupIndex(r);
    if (s !== -1)
      return { hideFunc: this.popupList[s].hideFunc };
    this.initialisePopupPosition(r);
    const l = this.createPopupWrapper(r, n, !!i), u = this.addEventListenersToPopup({ ...e, wrapperEl: l });
    return o && o(), this.addPopupToPopupList(r, l, u, a), {
      hideFunc: u
    };
  }
  initialisePopupPosition(e) {
    const r = this.getPopupParent().getBoundingClientRect();
    ke(e.style.top) || (e.style.top = `${r.top * -1}px`), ke(e.style.left) || (e.style.left = `${r.left * -1}px`);
  }
  createPopupWrapper(e, t, r) {
    const n = this.getPopupParent(), i = document.createElement("div");
    return this.environment.applyThemeClasses(i), i.classList.add("ag-popup"), e.classList.add(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child"), e.hasAttribute("role") || Na(e, "dialog"), tf(e, t), i.appendChild(e), n.appendChild(i), r ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e), i;
  }
  handleThemeChange(e) {
    if (e.themeChanged)
      for (const t of this.popupList)
        this.environment.applyThemeClasses(t.wrapper);
  }
  addEventListenersToPopup(e) {
    const t = this.gos.getDocument(), r = this.getPopupParent(), { wrapperEl: n, eChild: i, closedCallback: o, afterGuiAttached: a, closeOnEsc: s, modal: l } = e;
    let u = !1;
    const c = (p) => {
      if (!n.contains(this.gos.getActiveDomElement()))
        return;
      p.key === pe.ESCAPE && !Yl(p) && f({ keyboardEvent: p });
    }, d = (p) => f({ mouseEvent: p }), h = (p) => f({ touchEvent: p }), f = (p = {}) => {
      const { mouseEvent: g, touchEvent: v, keyboardEvent: m, forceHide: y } = p;
      !y && // we don't hide popup if the event was on the child, or any
      // children of this child
      (this.isEventFromCurrentPopup({ mouseEvent: g, touchEvent: v }, i) || // this method should only be called once. the client can have different
      // paths, each one wanting to close, so this method may be called multiple times.
      u) || (u = !0, r.removeChild(n), t.removeEventListener("keydown", c), t.removeEventListener("mousedown", d), t.removeEventListener("touchstart", h), t.removeEventListener("contextmenu", d), this.eventService.removeEventListener("dragStarted", d), o && o(g || v || m), this.removePopupFromPopupList(i));
    };
    return a && a({ hidePopup: f }), window.setTimeout(() => {
      s && t.addEventListener("keydown", c), l && (t.addEventListener("mousedown", d), this.eventService.addEventListener("dragStarted", d), t.addEventListener("touchstart", h), t.addEventListener("contextmenu", d));
    }, 0), f;
  }
  addPopupToPopupList(e, t, r, n) {
    this.popupList.push({
      element: e,
      wrapper: t,
      hideFunc: r,
      instanceId: mze++,
      isAnchored: !!n
    }), n && this.setPopupPositionRelatedToElement(e, n);
  }
  getPopupIndex(e) {
    return this.popupList.findIndex((t) => t.element === e);
  }
  setPopupPositionRelatedToElement(e, t) {
    const r = this.getPopupIndex(e);
    if (r === -1)
      return;
    const n = this.popupList[r];
    if (n.stopAnchoringPromise && n.stopAnchoringPromise.then((o) => o && o()), n.stopAnchoringPromise = void 0, n.isAnchored = !1, !t)
      return;
    const i = this.keepPopupPositionedRelativeTo({
      element: t,
      ePopup: e,
      hidePopup: n.hideFunc
    });
    return n.stopAnchoringPromise = i, n.isAnchored = !0, i;
  }
  removePopupFromPopupList(e) {
    this.setAlignedStyles(e, null), this.setPopupPositionRelatedToElement(e, null), this.popupList = this.popupList.filter((t) => t.element !== e);
  }
  keepPopupPositionedRelativeTo(e) {
    const t = this.getPopupParent(), r = t.getBoundingClientRect(), { element: n, ePopup: i } = e, o = n.getBoundingClientRect(), a = r.top - o.top, s = r.left - o.left;
    let l = a, u = s;
    const c = i.style.top, d = parseInt(c.substring(0, c.length - 1), 10), h = i.style.left, f = parseInt(h.substring(0, h.length - 1), 10), p = this.getFrameworkOverrides();
    return new gn((g) => {
      p.wrapIncoming(() => {
        p.setInterval(() => {
          const v = t.getBoundingClientRect(), m = n.getBoundingClientRect();
          if (m.top == 0 && m.left == 0 && m.height == 0 && m.width == 0) {
            e.hidePopup();
            return;
          }
          const C = v.top - m.top;
          if (C != l) {
            const b = this.keepXYWithinBounds(
              i,
              d + a - C,
              0
              /* vertical */
            );
            i.style.top = `${b}px`;
          }
          l = C;
          const S = v.left - m.left;
          if (S != u) {
            const b = this.keepXYWithinBounds(
              i,
              f + s - S,
              1
              /* horizontal */
            );
            i.style.left = `${b}px`;
          }
          u = S;
        }, 200).then((v) => {
          g(() => {
            v != null && window.clearInterval(v);
          });
        });
      }, "popupPositioning");
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((e) => e.isAnchored);
  }
  isEventFromCurrentPopup(e, t) {
    const { mouseEvent: r, touchEvent: n } = e, i = r || n;
    if (!i)
      return !1;
    const o = this.getPopupIndex(t);
    if (o === -1)
      return !1;
    for (let a = o; a < this.popupList.length; a++) {
      const s = this.popupList[a];
      if (YVe(s.element, i))
        return !0;
    }
    return this.isElementWithinCustomPopup(i.target);
  }
  isElementWithinCustomPopup(e) {
    const t = this.gos.getDocument();
    for (; e && e !== t.body; ) {
      if (e.classList.contains("ag-custom-component-popup") || e.parentElement === null)
        return !0;
      e = e.parentElement;
    }
    return !1;
  }
  getWrapper(e) {
    for (; !e.classList.contains("ag-popup") && e.parentElement; )
      e = e.parentElement;
    return e.classList.contains("ag-popup") ? e : null;
  }
  setAlwaysOnTop(e, t) {
    const r = this.getWrapper(e);
    r && (r.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(r));
  }
  /** @return true if moved */
  bringPopupToFront(e) {
    const t = this.getPopupParent(), r = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")), n = r.length, i = Array.prototype.slice.call(
      t.querySelectorAll(".ag-popup.ag-always-on-top")
    ), o = i.length, a = this.getWrapper(e);
    if (!a || n <= 1 || !t.contains(e))
      return !1;
    const s = r.indexOf(a), l = a.querySelectorAll("div"), u = [];
    l.forEach((d) => {
      d.scrollTop !== 0 && u.push([d, d.scrollTop]);
    });
    let c = !1;
    for (o ? a.classList.contains("ag-always-on-top") ? s !== n - 1 && (gr(i).insertAdjacentElement("afterend", a), c = !0) : s !== n - o - 1 && (i[0].insertAdjacentElement("beforebegin", a), c = !0) : s !== n - 1 && (gr(r).insertAdjacentElement("afterend", a), c = !0); u.length; ) {
      const d = u.pop();
      d[0].scrollTop = d[1];
    }
    return c;
  }
}, Sze = ["touchstart", "touchend", "touchmove", "touchcancel"], tX = class {
  constructor(e = "javascript") {
    this.frameworkName = e, this.renderingEngine = "vanilla", this.wrapIncoming = (t) => t(), this.wrapOutgoing = (t) => t();
  }
  setInterval(e, t) {
    return new gn((r) => {
      r(window.setInterval(e, t));
    });
  }
  // for Vanilla JS, we just add the event to the element
  addEventListener(e, t, r, n) {
    const i = Lc(Sze, t);
    e.addEventListener(t, r, { capture: !!n, passive: i });
  }
  get shouldWrapOutgoing() {
    return !1;
  }
  frameworkComponent(e) {
    return null;
  }
  isFrameworkComponent(e) {
    return !1;
  }
  getDocLink(e) {
    return `https://www.ag-grid.com/${this.frameworkName === "solid" ? "react" : this.frameworkName}-data-grid${e ? `/${e}` : ""}`;
  }
}, wze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "cellNavigationService";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer, this.pinnedRowModel = e.pinnedRowModel, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService;
  }
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(e, t, r = !1) {
    return r ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t);
  }
  getNextCellToFocusWithCtrlPressed(e, t) {
    const r = e === pe.UP, n = e === pe.DOWN, i = e === pe.LEFT;
    let o, a;
    if (r || n)
      a = r ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow(), o = t.column;
    else {
      const s = this.visibleColsService.getAllCols(), l = this.gos.get("enableRtl");
      a = t.rowIndex, o = i !== l ? s[0] : gr(s);
    }
    return {
      rowIndex: a,
      rowPinned: null,
      column: o
    };
  }
  getNextCellToFocusWithoutCtrlPressed(e, t) {
    let r = t, n = !1;
    for (; !n; ) {
      switch (e) {
        case pe.UP:
          r = this.getCellAbove(r);
          break;
        case pe.DOWN:
          r = this.getCellBelow(r);
          break;
        case pe.RIGHT:
          this.gos.get("enableRtl") ? r = this.getCellToLeft(r) : r = this.getCellToRight(r);
          break;
        case pe.LEFT:
          this.gos.get("enableRtl") ? r = this.getCellToRight(r) : r = this.getCellToLeft(r);
          break;
        default:
          r = null, Te("unknown key for navigation ", e);
          break;
      }
      r ? n = this.isCellGoodToFocusOn(r) : n = !0;
    }
    return r;
  }
  isCellGoodToFocusOn(e) {
    const t = e.column;
    let r;
    switch (e.rowPinned) {
      case "top":
        r = this.pinnedRowModel.getPinnedTopRow(e.rowIndex);
        break;
      case "bottom":
        r = this.pinnedRowModel.getPinnedBottomRow(e.rowIndex);
        break;
      default:
        r = this.rowModel.getRow(e.rowIndex);
        break;
    }
    return r ? !t.isSuppressNavigable(r) : !1;
  }
  getCellToLeft(e) {
    if (!e)
      return null;
    const t = this.visibleColsService.getColBefore(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellToRight(e) {
    if (!e)
      return null;
    const t = this.visibleColsService.getColAfter(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getRowBelow(e) {
    const t = e.rowIndex, r = e.rowPinned;
    if (this.isLastRowInContainer(e))
      switch (r) {
        case "bottom":
          return null;
        case "top":
          return this.rowModel.isRowsToRender() ? { rowIndex: this.pageBoundsService.getFirstRow(), rowPinned: null } : this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
        default:
          return this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
      }
    const n = this.rowModel.getRow(e.rowIndex), i = this.getNextStickyPosition(n);
    return i || { rowIndex: t + 1, rowPinned: r };
  }
  getNextStickyPosition(e, t) {
    if (!this.gos.isGroupRowsSticky() || !e || !e.sticky)
      return;
    const r = this.rowRenderer.getStickyTopRowCtrls().some((s) => s.getRowNode().rowIndex === e.rowIndex);
    let n = [];
    r ? n = [...this.rowRenderer.getStickyTopRowCtrls()].sort(
      (s, l) => s.getRowNode().rowIndex - l.getRowNode().rowIndex
    ) : n = [...this.rowRenderer.getStickyBottomRowCtrls()].sort(
      (s, l) => l.getRowNode().rowIndex - s.getRowNode().rowIndex
    );
    const i = t ? -1 : 1, o = n.findIndex((s) => s.getRowNode().rowIndex === e.rowIndex), a = n[o + i];
    if (a)
      return { rowIndex: a.getRowNode().rowIndex, rowPinned: null };
  }
  getCellBelow(e) {
    if (!e)
      return null;
    const t = this.getRowBelow(e);
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  isLastRowInContainer(e) {
    const t = e.rowPinned, r = e.rowIndex;
    return t === "top" ? this.pinnedRowModel.getPinnedTopRowNodes().length - 1 <= r : t === "bottom" ? this.pinnedRowModel.getPinnedBottomRowNodes().length - 1 <= r : this.pageBoundsService.getLastRow() <= r;
  }
  getRowAbove(e) {
    const t = e.rowIndex, r = e.rowPinned;
    if (r ? t === 0 : t === this.pageBoundsService.getFirstRow())
      return r === "top" ? null : r ? this.rowModel.isRowsToRender() ? this.getLastBodyCell() : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null;
    const i = this.rowModel.getRow(e.rowIndex), o = this.getNextStickyPosition(i, !0);
    return o || { rowIndex: t - 1, rowPinned: r };
  }
  getCellAbove(e) {
    if (!e)
      return null;
    const t = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  getLastBodyCell() {
    return { rowIndex: this.pageBoundsService.getLastRow(), rowPinned: null };
  }
  getLastFloatingTopRow() {
    return { rowIndex: this.pinnedRowModel.getPinnedTopRowNodes().length - 1, rowPinned: "top" };
  }
  getNextTabbedCell(e, t) {
    return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e);
  }
  getNextTabbedCellForwards(e) {
    var o;
    const t = this.visibleColsService.getAllCols();
    let r = e.rowIndex, n = e.rowPinned, i = this.visibleColsService.getColAfter(e.column);
    if (!i) {
      i = t[0];
      const a = this.getRowBelow(e);
      if (dr(a) || !a.rowPinned && !(((o = this.paginationService) == null ? void 0 : o.isRowInPage(a)) ?? !0))
        return null;
      r = a ? a.rowIndex : null, n = a ? a.rowPinned : null;
    }
    return { rowIndex: r, column: i, rowPinned: n };
  }
  getNextTabbedCellBackwards(e) {
    var o;
    const t = this.visibleColsService.getAllCols();
    let r = e.rowIndex, n = e.rowPinned, i = this.visibleColsService.getColBefore(e.column);
    if (!i) {
      i = gr(t);
      const a = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
      if (dr(a) || !a.rowPinned && !(((o = this.paginationService) == null ? void 0 : o.isRowInPage(a)) ?? !0))
        return null;
      r = a ? a.rowIndex : null, n = a ? a.rowPinned : null;
    }
    return { rowIndex: r, column: i, rowPinned: n };
  }
};
function bze(e, t) {
  e.eventService.dispatchEvent(t);
}
var xze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "apiFunctionService", this.functions = {
      // this is used by frameworks
      // also used by aligned grids to identify a grid api instance
      dispatchEvent: bze
    }, this.isDestroyed = !1;
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.preDestroyLink = this.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
  }
  callFunction(e, t) {
    var n;
    const r = this.functions[e];
    if (r)
      return r.apply(r, [this.beans, ...t]);
    if (this.isDestroyed)
      return this.destroyedHandler(e);
    this.isFrameworkMethod(e) || (n = this.beans.validationService) == null || n.warnMissingApiFunction(e);
  }
  addFunction(e, t) {
    const { validationService: r } = this.beans;
    r && (t = r.validateApiFunction(e, t)), this.functions[e] = t;
  }
  destroy() {
    this.functions = {}, this.isDestroyed = !0, super.destroy();
  }
  destroyedHandler(e) {
    if (e === "isDestroyed")
      return !0;
    e !== "destroy" && Te(
      `Grid API function ${e}() cannot be called as the grid has been destroyed.
Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${this.preDestroyLink}`
    );
  }
  isFrameworkMethod(e) {
    return ["preWireBeans", "wireBeans", "preConstruct", "postConstruct"].includes(e);
  }
};
function Eze(e) {
  const t = e.getBean("apiFunctionService");
  return new Proxy(t, {
    get(r, n) {
      if (n !== "then")
        return (...i) => r.callFunction(n, i);
    }
  });
}
function Rze(e) {
  return {
    beanName: "gridApi",
    bean: Eze(e)
  };
}
var _ze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnDefFactory";
  }
  buildColumnDefs(e, t, r) {
    const n = [], i = {};
    return e.forEach((o) => {
      const a = this.createDefFromColumn(o, t, r);
      let s = !0, l = a, u = o.getOriginalParent(), c = null;
      for (; u; ) {
        let d = null;
        if (u.isPadding()) {
          u = u.getOriginalParent();
          continue;
        }
        const h = i[u.getGroupId()];
        if (h) {
          h.children.push(l), s = !1;
          break;
        }
        if (d = this.createDefFromGroup(u), d && (d.children = [l], i[d.groupId] = d, l = d, u = u.getOriginalParent()), u != null && c === u) {
          s = !1;
          break;
        }
        c = u;
      }
      s && n.push(l);
    }), n;
  }
  createDefFromGroup(e) {
    const t = nP(e.getColGroupDef(), ["children"]);
    return t && (t.groupId = e.getGroupId()), t;
  }
  createDefFromColumn(e, t, r) {
    const n = nP(e.getColDef());
    return n.colId = e.getColId(), n.width = e.getActualWidth(), n.rowGroup = e.isRowGroupActive(), n.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, n.pivot = e.isPivotActive(), n.pivotIndex = e.isPivotActive() ? r.indexOf(e) : null, n.aggFunc = e.isValueActive() ? e.getAggFunc() : null, n.hide = e.isVisible() ? void 0 : !0, n.pinned = e.isPinned() ? e.getPinned() : null, n.sort = e.getSort() ? e.getSort() : null, n.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, n;
  }
}, Tze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnEventDispatcher";
  }
  visibleCols() {
    const e = {
      type: "displayedColumnsChanged"
    };
    this.eventService.dispatchEvent(e);
  }
  gridColumns() {
    const e = {
      type: "gridColumnsChanged"
    };
    this.eventService.dispatchEvent(e);
  }
  headerHeight(e) {
    const t = {
      type: "columnHeaderHeightChanged",
      column: e,
      columns: [e],
      source: "autosizeColumnHeaderHeight"
    };
    this.eventService.dispatchEvent(t);
  }
  groupOpened(e) {
    const t = {
      type: "columnGroupOpened",
      columnGroup: e.length === 1 ? e[0] : void 0,
      columnGroups: e
    };
    this.eventService.dispatchEvent(t);
  }
  rowGroupChanged(e, t) {
    const r = {
      type: "columnRowGroupChanged",
      columns: e,
      column: e.length === 1 ? e[0] : null,
      source: t
    };
    this.eventService.dispatchEvent(r);
  }
  genericColumnEvent(e, t, r) {
    const n = {
      type: e,
      columns: t,
      column: t.length === 1 ? t[0] : null,
      source: r
    };
    this.eventService.dispatchEvent(n);
  }
  pivotModeChanged() {
    const e = {
      type: "columnPivotModeChanged"
    };
    this.eventService.dispatchEvent(e);
  }
  virtualColumnsChanged(e) {
    const t = {
      type: "virtualColumnsChanged",
      afterScroll: e
    };
    this.eventService.dispatchEvent(t);
  }
  newColumnsLoaded(e) {
    const t = {
      type: "newColumnsLoaded",
      source: e
    };
    this.eventService.dispatchEvent(t);
  }
  everythingChanged(e) {
    const t = {
      type: "columnEverythingChanged",
      source: e
    };
    this.eventService.dispatchEvent(t);
  }
  columnMoved(e) {
    const { movedColumns: t, source: r, toIndex: n, finished: i } = e, o = {
      type: "columnMoved",
      columns: t,
      column: t && t.length === 1 ? t[0] : null,
      toIndex: n,
      finished: i,
      source: r
    };
    this.eventService.dispatchEvent(o);
  }
  columnPinned(e, t) {
    if (!e.length)
      return;
    const r = e.length === 1 ? e[0] : null, n = this.getCommonValue(e, (o) => o.getPinned()), i = {
      type: "columnPinned",
      // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
      pinned: n ?? null,
      columns: e,
      column: r,
      source: t
    };
    this.eventService.dispatchEvent(i);
  }
  columnVisible(e, t) {
    if (!e.length)
      return;
    const r = e.length === 1 ? e[0] : null, i = {
      type: "columnVisible",
      visible: this.getCommonValue(e, (o) => o.isVisible()),
      columns: e,
      column: r,
      source: t
    };
    this.eventService.dispatchEvent(i);
  }
  getCommonValue(e, t) {
    if (!e || e.length == 0)
      return;
    const r = t(e[0]);
    for (let n = 1; n < e.length; n++)
      if (r !== t(e[n]))
        return;
    return r;
  }
  columnChanged(e, t, r) {
    const n = {
      type: e,
      columns: t,
      column: t && t.length == 1 ? t[0] : null,
      source: r
    };
    this.eventService.dispatchEvent(n);
  }
  columnResized(e, t, r, n = null) {
    if (e && e.length) {
      const i = {
        type: "columnResized",
        columns: e,
        column: e.length === 1 ? e[0] : null,
        flexColumns: n,
        finished: t,
        source: r
      };
      this.eventService.dispatchEvent(i);
    }
  }
}, Pze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnGetStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService;
  }
  getColumnState() {
    const e = this.columnModel.getColDefCols();
    if (dr(e) || !this.columnModel.isAlive())
      return [];
    const r = this.columnModel.getAllCols().map(this.createStateItemFromColumn.bind(this));
    return this.orderColumnStateList(r), r;
  }
  createStateItemFromColumn(e) {
    const t = this.funcColsService.getRowGroupColumns(), r = this.funcColsService.getPivotColumns(), n = e.isRowGroupActive() ? t.indexOf(e) : null, i = e.isPivotActive() ? r.indexOf(e) : null, o = e.isValueActive() ? e.getAggFunc() : null, a = e.getSort() != null ? e.getSort() : null, s = e.getSortIndex() != null ? e.getSortIndex() : null, l = e.getFlex() != null && e.getFlex() > 0 ? e.getFlex() : null;
    return {
      colId: e.getColId(),
      width: e.getActualWidth(),
      hide: !e.isVisible(),
      pinned: e.getPinned(),
      sort: a,
      sortIndex: s,
      aggFunc: o,
      rowGroup: e.isRowGroupActive(),
      rowGroupIndex: n,
      pivot: e.isPivotActive(),
      pivotIndex: i,
      flex: l
    };
  }
  orderColumnStateList(e) {
    const t = this.columnModel.getCols(), r = new Map(t.map((n, i) => [n.getColId(), i]));
    e.sort((n, i) => {
      const o = r.has(n.colId) ? r.get(n.colId) : -1, a = r.has(i.colId) ? r.get(i.colId) : -1;
      return o - a;
    });
  }
}, Mze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnGroupStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnAnimationService = e.columnAnimationService, this.eventDispatcher = e.columnEventDispatcher, this.visibleColsService = e.visibleColsService;
  }
  getColumnGroupState() {
    const e = [], t = this.columnModel.getColTree();
    return ol(null, t, (r) => {
      Ri(r) && e.push({
        groupId: r.getGroupId(),
        open: r.isExpanded()
      });
    }), e;
  }
  resetColumnGroupState(e) {
    const t = this.columnModel.getColDefColTree();
    if (!t)
      return;
    const r = [];
    ol(null, t, (n) => {
      if (Ri(n)) {
        const i = n.getColGroupDef(), o = {
          groupId: n.getGroupId(),
          open: i ? i.openByDefault : void 0
        };
        r.push(o);
      }
    }), this.setColumnGroupState(r, e);
  }
  setColumnGroupState(e, t) {
    if (!this.columnModel.getColTree())
      return;
    this.columnAnimationService.start();
    const n = [];
    e.forEach((i) => {
      const o = i.groupId, a = i.open, s = this.columnModel.getProvidedColGroup(o);
      s && s.isExpanded() !== a && (s.setExpanded(a), n.push(s));
    }), this.visibleColsService.refresh(t, !0), n.length && this.eventDispatcher.groupOpened(n), this.columnAnimationService.finish();
  }
}, Dze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnViewportService", this.colsWithinViewport = [], this.headerColsWithinViewport = [], this.colsWithinViewportHash = "", this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher;
  }
  postConstruct() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
  }
  setScrollPosition(e, t, r = !1) {
    const n = this.visibleColsService.isBodyWidthDirty();
    if (!(e === this.scrollWidth && t === this.scrollPosition && !n)) {
      if (this.scrollWidth = e, this.scrollPosition = t, this.visibleColsService.setBodyWidthDirty(), this.gos.get("enableRtl")) {
        const o = this.visibleColsService.getBodyContainerWidth();
        this.viewportLeft = o - this.scrollPosition - this.scrollWidth, this.viewportRight = o - this.scrollPosition;
      } else
        this.viewportLeft = this.scrollPosition, this.viewportRight = this.scrollWidth + this.scrollPosition;
      this.columnModel.isReady() && this.checkViewportColumns(r);
    }
  }
  getHeadersToRender(e, t) {
    let r;
    switch (e) {
      case "left":
        r = this.rowsOfHeadersToRenderLeft[t];
        break;
      case "right":
        r = this.rowsOfHeadersToRenderRight[t];
        break;
      default:
        r = this.rowsOfHeadersToRenderCenter[t];
        break;
    }
    return r || [];
  }
  extractViewportColumns() {
    const e = this.visibleColsService.getCenterCols();
    this.isColumnVirtualisationSuppressed() ? (this.colsWithinViewport = e, this.headerColsWithinViewport = e) : (this.colsWithinViewport = e.filter(this.isColumnInRowViewport.bind(this)), this.headerColsWithinViewport = e.filter(this.isColumnInHeaderViewport.bind(this)));
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  clear() {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {}, this.colsWithinViewportHash = "";
  }
  isColumnInHeaderViewport(e) {
    return e.isAutoHeaderHeight() ? !0 : this.isColumnInRowViewport(e);
  }
  isColumnInRowViewport(e) {
    if (e.isAutoHeight())
      return !0;
    const t = e.getLeft() || 0, r = t + e.getActualWidth(), n = this.viewportLeft - 200, i = this.viewportRight + 200, o = t < n && r < n, a = t > i && r > i;
    return !o && !a;
  }
  // used by Grid API only
  getViewportColumns() {
    const e = this.visibleColsService.getLeftCols(), t = this.visibleColsService.getRightCols();
    return this.colsWithinViewport.concat(e).concat(t);
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getColsWithinViewport(e) {
    if (!this.columnModel.isColSpanActive())
      return this.colsWithinViewport;
    const t = (i) => {
      const o = i.getLeft();
      return ke(o) && o > this.viewportLeft;
    }, r = this.isColumnVirtualisationSuppressed() ? null : this.isColumnInRowViewport.bind(this), n = this.visibleColsService.getColsCenter();
    return this.visibleColsService.getColsForRow(
      e,
      n,
      r,
      t
    );
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns(e = !1) {
    this.extractViewport() && this.eventDispatcher.virtualColumnsChanged(e);
  }
  calculateHeaderRows() {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
    const e = {}, t = this.visibleColsService.getLeftCols(), r = this.visibleColsService.getRightCols();
    this.headerColsWithinViewport.concat(t).concat(r).forEach((o) => e[o.getId()] = !0);
    const i = (o, a, s) => {
      let l = !1;
      for (let u = 0; u < o.length; u++) {
        const c = o[u];
        let d = !1;
        if (cu(c))
          d = e[c.getId()] === !0;
        else {
          const f = c.getDisplayedChildren();
          f && (d = i(f, a, s + 1));
        }
        d && (l = !0, a[s] || (a[s] = []), a[s].push(c));
      }
      return l;
    };
    i(this.visibleColsService.getTreeLeft(), this.rowsOfHeadersToRenderLeft, 0), i(this.visibleColsService.getTreeRight(), this.rowsOfHeadersToRenderRight, 0), i(this.visibleColsService.getTreeCenter(), this.rowsOfHeadersToRenderCenter, 0);
  }
  extractViewport() {
    const e = (n) => `${n.getId()}-${n.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const t = this.getViewportColumns().map(e).join("#"), r = this.colsWithinViewportHash !== t;
    return r && (this.colsWithinViewportHash = t, this.calculateHeaderRows()), r;
  }
}, Aze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "agComponentUtils";
  }
  wireBeans(e) {
    this.componentMetadataProvider = e.componentMetadataProvider;
  }
  adaptFunction(e, t) {
    const r = this.componentMetadataProvider.retrieve(e);
    return r && r.functionAdapter ? r.functionAdapter(t) : null;
  }
  adaptCellRendererFunction(e) {
    class t {
      refresh() {
        return !1;
      }
      getGui() {
        return this.eGui;
      }
      init(n) {
        const i = e(n), o = typeof i;
        if (o === "string" || o === "number" || o === "boolean") {
          this.eGui = rf("<span>" + i + "</span>");
          return;
        }
        if (i == null) {
          this.eGui = rf("<span></span>");
          return;
        }
        this.eGui = i;
      }
    }
    return t;
  }
  doesImplementIComponent(e) {
    return e ? e.prototype && "getGui" in e.prototype : !1;
  }
}, Ize = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "componentMetadataProvider";
  }
  wireBeans(e) {
    this.agComponentUtils = e.agComponentUtils;
  }
  postConstruct() {
    this.componentMetaData = {
      dateComponent: {
        mandatoryMethodList: ["getDate", "setDate"],
        optionalMethodList: [
          "afterGuiAttached",
          "setInputPlaceholder",
          "setInputAriaLabel",
          "setDisabled",
          "onParamsUpdated",
          "refresh"
        ]
      },
      detailCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      headerComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      headerGroupComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      loadingCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: [],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      loadingOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      noRowsOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      floatingFilterComponent: {
        mandatoryMethodList: ["onParentModelChanged"],
        optionalMethodList: ["afterGuiAttached", "onParamsUpdated", "refresh"]
      },
      cellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      cellEditor: {
        mandatoryMethodList: ["getValue"],
        optionalMethodList: [
          "isPopup",
          "isCancelBeforeStart",
          "isCancelAfterEnd",
          "getPopupPosition",
          "focusIn",
          "focusOut",
          "afterGuiAttached",
          "refresh"
        ]
      },
      innerRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      fullWidthCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      groupRowRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      filter: {
        mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
        optionalMethodList: [
          "afterGuiAttached",
          "afterGuiDetached",
          "onNewRowsLoaded",
          "getModelAsString",
          "onFloatingFilterChanged",
          "onAnyFilterChanged",
          "refresh"
        ]
      },
      statusPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      toolPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "getState"]
      },
      tooltipComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      menuItem: {
        mandatoryMethodList: [],
        optionalMethodList: ["setActive", "select", "setExpanded", "configureDefaults"]
      }
    };
  }
  retrieve(e) {
    return this.componentMetaData[e];
  }
}, Oze = [
  // core beans only
  "rowPositionUtils",
  "cellPositionUtils",
  "headerPositionUtils",
  "paginationAutoPageSizeService",
  "apiFunctionService",
  "gridApi",
  "userComponentRegistry",
  "agComponentUtils",
  "componentMetadataProvider",
  "resizeObserverService",
  "userComponentFactory",
  "rowContainerHeightService",
  "horizontalResizeService",
  "localeService",
  "validationService",
  "pinnedRowModel",
  "dragService",
  "visibleColsService",
  "eventService",
  "gos",
  "popupService",
  "selectionService",
  "columnFilterService",
  "quickFilterService",
  "filterManager",
  "columnModel",
  "headerNavigationService",
  "pageBoundsService",
  "paginationService",
  "pageBoundsListener",
  "rowRenderer",
  "expressionService",
  "columnFactory",
  "alignedGridsService",
  "navigationService",
  "valueCache",
  "valueService",
  "loggerFactory",
  "autoWidthCalculator",
  "filterMenuFactory",
  "dragAndDropService",
  "focusService",
  "mouseEventService",
  "environment",
  "cellNavigationService",
  "stylingService",
  "scrollVisibleService",
  "sortController",
  "columnHoverService",
  "columnAnimationService",
  "selectableService",
  "autoColService",
  "changeDetectionService",
  "animationFrameService",
  "undoRedoService",
  "columnDefFactory",
  "rowCssClassCalculator",
  "rowNodeBlockLoader",
  "rowNodeSorter",
  "ctrlsService",
  "pinnedWidthService",
  "rowNodeEventThrottle",
  "ctrlsFactory",
  "dataTypeService",
  "syncService",
  "overlayService",
  "stateService",
  "expansionService",
  "apiEventService",
  "ariaAnnouncementService",
  "menuService",
  "columnApplyStateService",
  "columnEventDispatcher",
  "columnMoveService",
  "columnAutosizeService",
  "columnGetStateService",
  "columnGroupStateService",
  "columnSizeService",
  "funcColsService",
  "columnNameService",
  "columnViewportService",
  "pivotResultColsService",
  "showRowGroupColsService"
], YH = Object.fromEntries(
  Oze.map((e, t) => [e, t])
);
function Lze(e, t) {
  const r = (e.beanName ? YH[e.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER, n = (t.beanName ? YH[t.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
  return r - n;
}
function Fze(e, t) {
  return (e == null ? void 0 : e.beanName) === "gridDestroyService" ? -1 : 0;
}
var Nze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "ctrlsFactory", this.registry = {};
  }
  register(e) {
    this.registry[e.name] = e.classImp;
  }
  getInstance(e, ...t) {
    const r = this.registry[e];
    if (r != null)
      return new r(...t);
  }
}, kze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "ctrlsService", this.params = {}, this.ready = !1, this.readyCallbacks = [];
  }
  checkReady() {
    const e = this.params;
    this.ready = e.gridCtrl != null && e.gridBodyCtrl != null && e.center != null && e.left != null && e.right != null && e.bottomCenter != null && e.bottomLeft != null && e.bottomRight != null && e.topCenter != null && e.topLeft != null && e.topRight != null && e.stickyTopCenter != null && e.stickyTopLeft != null && e.stickyTopRight != null && e.stickyBottomCenter != null && e.stickyBottomLeft != null && e.stickyBottomRight != null && e.centerHeader != null && e.leftHeader != null && e.rightHeader != null && e.fakeHScrollComp != null && e.fakeVScrollComp != null && e.gridHeaderCtrl != null, this.ready && (this.readyCallbacks.forEach((t) => t(e)), this.readyCallbacks.length = 0);
  }
  whenReady(e) {
    this.ready ? e(this.params) : this.readyCallbacks.push(e);
  }
  register(e, t) {
    this.params[e] = t, this.checkReady();
  }
  registerHeaderContainer(e, t) {
    const r = this.params;
    switch (t) {
      case "left":
        r.leftHeader = e;
        break;
      case "right":
        r.rightHeader = e;
        break;
      default:
        r.centerHeader = e;
        break;
    }
    this.checkReady();
  }
  get(e) {
    return this.params[e];
  }
  getParams() {
    return this.params;
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    const { leftHeader: e, centerHeader: t, rightHeader: r } = this.params;
    return [e, r, t];
  }
  getHeaderRowContainerCtrl(e) {
    const t = this.params;
    switch (e) {
      case "left":
        return t.leftHeader;
      case "right":
        return t.rightHeader;
      default:
        return t.centerHeader;
    }
  }
}, Vze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "cellPositionUtils";
  }
  createId(e) {
    const { rowIndex: t, rowPinned: r, column: n } = e;
    return this.createIdFromValues({ rowIndex: t, column: n, rowPinned: r });
  }
  createIdFromValues(e) {
    const { rowIndex: t, rowPinned: r, column: n } = e;
    return `${t}.${r ?? "null"}.${n.getId()}`;
  }
  equals(e, t) {
    const r = e.column === t.column, n = e.rowPinned === t.rowPinned, i = e.rowIndex === t.rowIndex;
    return r && n && i;
  }
}, Bze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowNodeEventThrottle", this.events = [];
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.rowModel.getType() == "clientSide" && (this.clientSideRowModel = this.rowModel);
  }
  // because the user can call rowNode.setExpanded() many times in one VM turn,
  // we throttle the calls to ClientSideRowModel using animationFrameService. this means for 100
  // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
  // CSRM has updated.
  //
  // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
  // to re-render 100+ times, which would be a performance lag.
  //
  // we use animationFrameService
  // rather than debounce() so this will get done if anyone flushes the animationFrameService
  // (eg user calls api.ensureRowVisible(), which in turn flushes ).
  dispatchExpanded(e, t) {
    if (this.clientSideRowModel == null) {
      this.eventService.dispatchEvent(e);
      return;
    }
    this.events.push(e);
    const r = () => {
      this.clientSideRowModel && this.clientSideRowModel.onRowGroupOpened(), this.events.forEach((n) => this.eventService.dispatchEvent(n)), this.events = [];
    };
    t ? r() : (this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.animationFrameService.debounce(r)), this.dispatchExpandedDebounced());
  }
}, $ze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowPositionUtils";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.pageBoundsService = e.pageBoundsService;
  }
  getFirstRow() {
    let e = 0, t;
    return this.pinnedRowModel.getPinnedTopRowCount() ? t = "top" : this.rowModel.getRowCount() ? (t = null, e = this.pageBoundsService.getFirstRow()) : this.pinnedRowModel.getPinnedBottomRowCount() && (t = "bottom"), t === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getLastRow() {
    let e, t = null;
    const r = this.pinnedRowModel.getPinnedBottomRowCount(), n = this.pinnedRowModel.getPinnedTopRowCount();
    return r ? (t = "bottom", e = r - 1) : this.rowModel.getRowCount() ? (t = null, e = this.pageBoundsService.getLastRow()) : n && (t = "top", e = n - 1), e === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getRowNode(e) {
    switch (e.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRowNodes()[e.rowIndex];
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRowNodes()[e.rowIndex];
      default:
        return this.rowModel.getRow(e.rowIndex);
    }
  }
  sameRow(e, t) {
    return !e && !t ? !0 : e && !t || !e && t ? !1 : e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned;
  }
  // tests if this row selection is before the other row selection
  before(e, t) {
    switch (e.rowPinned) {
      case "top":
        if (t.rowPinned !== "top")
          return !0;
        break;
      case "bottom":
        if (t.rowPinned !== "bottom")
          return !1;
        break;
      default:
        if (ke(t.rowPinned))
          return t.rowPinned !== "top";
        break;
    }
    return e.rowIndex < t.rowIndex;
  }
}, qH = {
  cssName: "--ag-row-height",
  changeKey: "rowHeightChanged",
  defaultValue: 42
}, XH = {
  cssName: "--ag-header-height",
  changeKey: "headerHeightChanged",
  defaultValue: 48
}, ZH = {
  cssName: "--ag-list-item-height",
  changeKey: "listItemHeightChanged",
  defaultValue: 24
}, Hze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "environment", this.sizeEls = /* @__PURE__ */ new Map(), this.lastKnownValues = /* @__PURE__ */ new Map(), this.themeClasses = [], this.eThemeAncestor = null, this.eMeasurementContainer = null, this.sizesMeasured = !1;
  }
  wireBeans(e) {
    this.resizeObserverService = e.resizeObserverService, this.eGridDiv = e.eGridDiv;
  }
  postConstruct() {
    this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable()), this.themeClasses = this.getAncestorThemeClasses(), this.setUpThemeClassObservers(), this.getSizeEl(qH), this.getSizeEl(XH), this.getSizeEl(ZH);
  }
  getDefaultRowHeight() {
    return this.getCSSVariablePixelValue(qH);
  }
  getDefaultHeaderHeight() {
    return this.getCSSVariablePixelValue(XH);
  }
  getDefaultListItemHeight() {
    return this.getCSSVariablePixelValue(ZH);
  }
  hasMeasuredSizes() {
    return this.sizesMeasured;
  }
  getThemeClasses() {
    return this.themeClasses;
  }
  applyThemeClasses(e) {
    for (const t of Array.from(e.classList))
      t.startsWith("ag-theme-") && !this.themeClasses.includes(t) && e.classList.remove(t);
    for (const t of this.themeClasses)
      e.classList.contains(t) || e.classList.add(t);
  }
  getThemeAncestorElement() {
    return this.eThemeAncestor;
  }
  refreshRowHeightVariable() {
    const e = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim(), t = this.gos.get("rowHeight");
    if (t == null || isNaN(t) || !isFinite(t))
      return e !== null && this.eGridDiv.style.setProperty("--ag-line-height", null), -1;
    const r = `${t}px`;
    return e != r ? (this.eGridDiv.style.setProperty("--ag-line-height", r), t) : e != "" ? parseFloat(e) : -1;
  }
  getCSSVariablePixelValue(e) {
    const t = this.lastKnownValues.get(e);
    if (t != null)
      return t;
    const r = this.measureSizeEl(e);
    return r === "detached" || r === "no-styles" ? e.defaultValue : (this.lastKnownValues.set(e, r), r);
  }
  measureSizeEl(e) {
    const t = this.getSizeEl(e);
    if (t.offsetParent == null)
      return "detached";
    const r = t.offsetWidth;
    return r === QH ? "no-styles" : (this.sizesMeasured = !0, r);
  }
  getSizeEl(e) {
    let t = this.sizeEls.get(e);
    if (t)
      return t;
    let r = this.eMeasurementContainer;
    r || (r = this.eMeasurementContainer = document.createElement("div"), r.className = "ag-measurement-container", this.eGridDiv.appendChild(r)), t = document.createElement("div"), t.style.width = `var(${e.cssName}, ${QH}px)`, r.appendChild(t), this.sizeEls.set(e, t);
    let n = this.measureSizeEl(e);
    n === "no-styles" && Te(
      `no value for ${e.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${e.defaultValue} will be used and updated when styles load.`
    );
    const i = this.resizeObserverService.observeResize(t, () => {
      const o = this.measureSizeEl(e);
      o === "detached" || o === "no-styles" || (this.lastKnownValues.set(e, o), o !== n && (n = o, this.fireGridStylesChangedEvent(e.changeKey)));
    });
    return this.addDestroyFunc(() => i()), t;
  }
  fireGridStylesChangedEvent(e) {
    const t = {
      type: "gridStylesChanged",
      [e]: !0
    };
    this.eventService.dispatchEvent(t);
  }
  setUpThemeClassObservers() {
    const e = new MutationObserver(() => {
      const r = this.getAncestorThemeClasses();
      Gze(r, this.themeClasses) || (this.themeClasses = r, this.fireGridStylesChangedEvent("themeChanged"));
    });
    let t = this.eGridDiv;
    for (; t; )
      e.observe(t || this.eGridDiv, {
        attributes: !0,
        attributeFilter: ["class"]
      }), t = t.parentElement;
  }
  getAncestorThemeClasses() {
    let e = this.eGridDiv;
    const t = [];
    for (this.eThemeAncestor = null; e; ) {
      const r = Array.from(e.classList).filter((n) => n.startsWith("ag-theme-"));
      for (const n of r)
        this.eThemeAncestor = e, t.includes(n) || t.unshift(n);
      e = e.parentElement;
    }
    return Object.freeze(t);
  }
}, Gze = (e, t) => e.length === t.length && e.findIndex((r, n) => e[n] !== t[n]) === -1, QH = 15538, zze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "eventService", this.globalEventService = new Af();
  }
  wireBeans(e) {
    this.globalEventListener = e.globalEventListener, this.globalSyncEventListener = e.globalSyncEventListener;
  }
  postConstruct() {
    if (this.globalEventListener) {
      const e = this.gos.useAsyncEvents();
      this.addGlobalListener(this.globalEventListener, e);
    }
    this.globalSyncEventListener && this.addGlobalListener(this.globalSyncEventListener, !1);
  }
  addEventListener(e, t, r) {
    this.globalEventService.addEventListener(e, t, r);
  }
  removeEventListener(e, t, r) {
    this.globalEventService.removeEventListener(e, t, r);
  }
  addGlobalListener(e, t = !1) {
    this.globalEventService.addGlobalListener(e, t);
  }
  removeGlobalListener(e, t = !1) {
    this.globalEventService.removeGlobalListener(e, t);
  }
  /** @deprecated DO NOT FIRE LOCAL EVENTS OFF THE EVENT SERVICE */
  dispatchLocalEvent() {
  }
  dispatchEvent(e) {
    this.globalEventService.dispatchEvent(this.gos.addGridCommonParams(e));
  }
  dispatchEventOnce(e) {
    this.globalEventService.dispatchEventOnce(this.gos.addGridCommonParams(e));
  }
}, TI = class co extends Se {
  constructor() {
    super(...arguments), this.beanName = "focusService";
  }
  wireBeans(t) {
    this.eGridDiv = t.eGridDiv, this.columnModel = t.columnModel, this.visibleColsService = t.visibleColsService, this.headerNavigationService = t.headerNavigationService, this.headerPositionUtils = t.headerPositionUtils, this.rowRenderer = t.rowRenderer, this.rowPositionUtils = t.rowPositionUtils, this.cellPositionUtils = t.cellPositionUtils, this.navigationService = t.navigationService, this.ctrlsService = t.ctrlsService, this.filterManager = t.filterManager, this.rangeService = t.rangeService, this.advancedFilterService = t.advancedFilterService;
  }
  static addKeyboardModeEvents(t) {
    this.instanceCount > 0 || (t.addEventListener("keydown", co.toggleKeyboardMode), t.addEventListener("mousedown", co.toggleKeyboardMode));
  }
  static removeKeyboardModeEvents(t) {
    this.instanceCount > 0 || (t.addEventListener("keydown", co.toggleKeyboardMode), t.addEventListener("mousedown", co.toggleKeyboardMode));
  }
  static toggleKeyboardMode(t) {
    const r = co.keyboardModeActive, n = t.type === "keydown";
    n && (t.ctrlKey || t.metaKey || t.altKey) || r !== n && (co.keyboardModeActive = n);
  }
  static unregisterGridCompController(t) {
    co.removeKeyboardModeEvents(t);
  }
  postConstruct() {
    const t = this.clearFocusedCell.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: t,
      newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
      columnGroupOpened: t,
      columnRowGroupChanged: t
    }), this.registerKeyboardFocusEvents(), this.ctrlsService.whenReady((r) => {
      this.gridCtrl = r.gridCtrl;
    });
  }
  registerKeyboardFocusEvents() {
    const t = this.gos.getDocument();
    co.addKeyboardModeEvents(t), co.instanceCount++, this.addDestroyFunc(() => {
      co.instanceCount--, co.unregisterGridCompController(t);
    });
  }
  onColumnEverythingChanged() {
    if (!this.focusedCellPosition)
      return;
    const t = this.focusedCellPosition.column, r = this.columnModel.getCol(t.getId());
    t !== r && this.clearFocusedCell();
  }
  isKeyboardMode() {
    return co.keyboardModeActive;
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedCellPosition || this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), Vc.DOM_DATA_KEY_ROW_CTRL) ? null : this.focusedCellPosition;
  }
  getFocusHeaderToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeaderPosition || this.isDomDataMissingInHierarchy(
      this.gos.getActiveDomElement(),
      Bw.DOM_DATA_KEY_HEADER_CTRL
    ) ? null : this.focusedHeaderPosition;
  }
  isDomDataMissingInHierarchy(t, r) {
    let n = t;
    for (; n; ) {
      if (this.gos.getDomData(n, r))
        return !1;
      n = n.parentNode;
    }
    return !0;
  }
  getFocusedCell() {
    return this.focusedCellPosition;
  }
  shouldRestoreFocus(t) {
    return this.isCellRestoreFocused(t) ? (setTimeout(() => {
      this.restoredFocusedCellPosition = null;
    }, 0), !0) : !1;
  }
  isCellRestoreFocused(t) {
    return this.restoredFocusedCellPosition == null ? !1 : this.cellPositionUtils.equals(t, this.restoredFocusedCellPosition);
  }
  setRestoreFocusedCell(t) {
    this.getFrameworkOverrides().renderingEngine === "react" && (this.restoredFocusedCellPosition = t);
  }
  getFocusEventParams() {
    const { rowIndex: t, rowPinned: r, column: n } = this.focusedCellPosition, i = {
      rowIndex: t,
      rowPinned: r,
      column: n,
      isFullWidthCell: !1
    }, o = this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: r });
    return o && (i.isFullWidthCell = o.isFullWidth()), i;
  }
  clearFocusedCell() {
    if (this.restoredFocusedCellPosition = null, this.focusedCellPosition == null)
      return;
    const t = {
      type: "cellFocusCleared",
      ...this.getFocusEventParams()
    };
    this.focusedCellPosition = null, this.eventService.dispatchEvent(t);
  }
  setFocusedCell(t) {
    const { column: r, rowIndex: n, rowPinned: i, forceBrowserFocus: o = !1, preventScrollOnBrowserFocus: a = !1 } = t, s = this.columnModel.getCol(r);
    if (!s) {
      this.focusedCellPosition = null;
      return;
    }
    this.focusedCellPosition = s ? {
      rowIndex: n,
      rowPinned: Fc(i),
      column: s
    } : null;
    const l = {
      type: "cellFocused",
      ...this.getFocusEventParams(),
      forceBrowserFocus: o,
      preventScrollOnBrowserFocus: a
    };
    this.eventService.dispatchEvent(l);
  }
  isCellFocused(t) {
    return this.focusedCellPosition == null ? !1 : this.cellPositionUtils.equals(t, this.focusedCellPosition);
  }
  isRowNodeFocused(t) {
    return this.isRowFocused(t.rowIndex, t.rowPinned);
  }
  isHeaderWrapperFocused(t) {
    if (this.focusedHeaderPosition == null)
      return !1;
    const r = t.getColumnGroupChild(), n = t.getRowIndex(), i = t.getPinned(), { column: o, headerRowIndex: a } = this.focusedHeaderPosition;
    return r === o && n === a && i == o.getPinned();
  }
  clearFocusedHeader() {
    this.focusedHeaderPosition = null;
  }
  getFocusedHeader() {
    return this.focusedHeaderPosition;
  }
  setFocusedHeader(t, r) {
    this.focusedHeaderPosition = { headerRowIndex: t, column: r };
  }
  focusHeaderPosition(t) {
    var u;
    if (this.gos.get("suppressHeaderFocus"))
      return !1;
    const { direction: r, fromTab: n, allowUserOverride: i, event: o, fromCell: a, rowWithoutSpanValue: s } = t;
    let { headerPosition: l } = t;
    if (a && ((u = this.filterManager) != null && u.isAdvancedFilterHeaderActive()))
      return this.focusAdvancedFilter(l);
    if (i) {
      const c = this.getFocusedHeader(), d = this.headerNavigationService.getHeaderRowCount();
      if (n) {
        const h = this.gos.getCallback("tabToNextHeader");
        h && (l = this.getHeaderPositionFromUserFunc({
          userFunc: h,
          direction: r,
          currentPosition: c,
          headerPosition: l,
          headerRowCount: d
        }));
      } else {
        const h = this.gos.getCallback("navigateToNextHeader");
        if (h && o) {
          const f = {
            key: o.key,
            previousHeaderPosition: c,
            nextHeaderPosition: l,
            headerRowCount: d,
            event: o
          };
          l = h(f);
        }
      }
    }
    return l ? this.focusProvidedHeaderPosition({
      headerPosition: l,
      direction: r,
      event: o,
      fromCell: a,
      rowWithoutSpanValue: s
    }) : !1;
  }
  focusHeaderPositionFromUserFunc(t) {
    if (this.gos.get("suppressHeaderFocus"))
      return !1;
    const { userFunc: r, headerPosition: n, direction: i, event: o } = t, a = this.getFocusedHeader(), s = this.headerNavigationService.getHeaderRowCount(), l = this.getHeaderPositionFromUserFunc({
      userFunc: r,
      direction: i,
      currentPosition: a,
      headerPosition: n,
      headerRowCount: s
    });
    return !!l && this.focusProvidedHeaderPosition({
      headerPosition: l,
      direction: i,
      event: o
    });
  }
  getHeaderPositionFromUserFunc(t) {
    const { userFunc: r, direction: n, currentPosition: i, headerPosition: o, headerRowCount: a } = t, l = r({
      backwards: n === "Before",
      previousHeaderPosition: i,
      nextHeaderPosition: o,
      headerRowCount: a
    });
    return l === !0 || l === null ? (l === null && Te(
      "Since v31.3 Returning `null` from tabToNextHeader is deprecated. Return `true` to stay on the current header, or `false` to let the browser handle the tab behaviour."
    ), i) : l === !1 ? null : l;
  }
  focusProvidedHeaderPosition(t) {
    var d;
    const { headerPosition: r, direction: n, fromCell: i, rowWithoutSpanValue: o, event: a } = t, { column: s, headerRowIndex: l } = r;
    if (l === -1)
      return (d = this.filterManager) != null && d.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(r) : this.focusGridView(s);
    this.headerNavigationService.scrollToColumn(s, n);
    const c = this.ctrlsService.getHeaderRowContainerCtrl(s.getPinned()).focusHeader(
      r.headerRowIndex,
      s,
      a
    );
    return c && (o != null || i) && this.headerNavigationService.setCurrentHeaderRowWithoutSpan(o ?? -1), c;
  }
  focusFirstHeader() {
    let t = this.visibleColsService.getAllCols()[0];
    if (!t)
      return !1;
    t.getParent() && (t = this.visibleColsService.getColGroupAtLevel(t, 0));
    const r = this.headerPositionUtils.getHeaderIndexToFocus(t, 0);
    return this.focusHeaderPosition({
      headerPosition: r,
      rowWithoutSpanValue: 0
    });
  }
  focusLastHeader(t) {
    const r = this.headerNavigationService.getHeaderRowCount() - 1, n = gr(this.visibleColsService.getAllCols());
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex: r, column: n },
      rowWithoutSpanValue: -1,
      event: t
    });
  }
  focusPreviousFromFirstCell(t) {
    var r;
    return (r = this.filterManager) != null && r.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(null) : this.focusLastHeader(t);
  }
  isAnyCellFocused() {
    return !!this.focusedCellPosition;
  }
  isRowFocused(t, r) {
    return this.focusedCellPosition == null ? !1 : this.focusedCellPosition.rowIndex === t && this.focusedCellPosition.rowPinned === Fc(r);
  }
  findFocusableElements(t, r, n = !1) {
    const i = jBe;
    let o = ZY;
    r && (o += ", " + r), n && (o += ', [tabindex="-1"]');
    const a = Array.prototype.slice.apply(t.querySelectorAll(i)).filter((u) => ys(u)), s = Array.prototype.slice.apply(t.querySelectorAll(o));
    return s.length ? ((u, c) => u.filter((d) => c.indexOf(d) === -1))(a, s) : a;
  }
  focusInto(t, r = !1, n = !1) {
    const i = this.findFocusableElements(t, null, n), o = r ? gr(i) : i[0];
    return o ? (o.focus({ preventScroll: !0 }), !0) : !1;
  }
  findFocusableElementBeforeTabGuard(t, r) {
    if (!r)
      return null;
    const n = this.findFocusableElements(t), i = n.indexOf(r);
    if (i === -1)
      return null;
    let o = -1;
    for (let a = i - 1; a >= 0; a--)
      if (n[a].classList.contains(
        "ag-tab-guard-top"
        /* TAB_GUARD_TOP */
      )) {
        o = a;
        break;
      }
    return o <= 0 ? null : n[o - 1];
  }
  findNextFocusableElement(t = this.eGridDiv, r, n) {
    const i = this.findFocusableElements(t, r ? ':not([tabindex="-1"])' : null), o = this.gos.getActiveDomElement();
    let a;
    r ? a = i.findIndex((l) => l.contains(o)) : a = i.indexOf(o);
    const s = a + (n ? -1 : 1);
    return s < 0 || s >= i.length ? null : i[s];
  }
  isTargetUnderManagedComponent(t, r) {
    if (!r)
      return !1;
    const n = t.querySelectorAll(`.${gd.FOCUS_MANAGED_CLASS}`);
    if (!n.length)
      return !1;
    for (let i = 0; i < n.length; i++)
      if (n[i].contains(r))
        return !0;
    return !1;
  }
  findTabbableParent(t, r = 5) {
    let n = 0;
    for (; t && lP(t) === null && ++n <= r; )
      t = t.parentElement;
    return lP(t) === null ? null : t;
  }
  focusGridView(t, r) {
    var s;
    if (this.gos.get("suppressCellFocus"))
      return r ? this.gos.get("suppressHeaderFocus") ? this.focusNextGridCoreContainer(!0, !0) : this.focusLastHeader() : this.focusNextGridCoreContainer(!1);
    const n = r ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
    if (!n)
      return !1;
    const { rowIndex: i, rowPinned: o } = n, a = this.getFocusedHeader();
    return !t && a && (t = a.column), i == null || !t ? !1 : (this.navigationService.ensureCellVisible({ rowIndex: i, column: t, rowPinned: o }), this.setFocusedCell({
      rowIndex: i,
      column: t,
      rowPinned: Fc(o),
      forceBrowserFocus: !0
    }), (s = this.rangeService) == null || s.setRangeToCell({ rowIndex: i, rowPinned: o, column: t }), !0);
  }
  focusNextGridCoreContainer(t, r = !1) {
    return !r && this.gridCtrl.focusNextInnerContainer(t) ? !0 : ((r || !t && !this.gridCtrl.isDetailGrid()) && this.gridCtrl.forceFocusOutOfContainer(t), !1);
  }
  focusAdvancedFilter(t) {
    var r;
    return this.advancedFilterFocusColumn = t == null ? void 0 : t.column, ((r = this.advancedFilterService) == null ? void 0 : r.getCtrl().focusHeaderComp()) ?? !1;
  }
  focusNextFromAdvancedFilter(t, r) {
    var i;
    const n = (r ? void 0 : this.advancedFilterFocusColumn) ?? ((i = this.visibleColsService.getAllCols()) == null ? void 0 : i[0]);
    return t ? this.focusHeaderPosition({
      headerPosition: {
        column: n,
        headerRowIndex: this.headerNavigationService.getHeaderRowCount() - 1
      }
    }) : this.focusGridView(n);
  }
  clearAdvancedFilterColumn() {
    this.advancedFilterFocusColumn = void 0;
  }
  addFocusableContainer(t) {
    this.gridCtrl.addFocusableContainer(t);
  }
  removeFocusableContainer(t) {
    this.gridCtrl.removeFocusableContainer(t);
  }
  focusGridInnerElement(t) {
    return this.gridCtrl.focusInnerElement(t);
  }
};
TI.keyboardModeActive = !1;
TI.instanceCount = 0;
var Wze = TI, jze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "pinnedWidthService";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService;
  }
  postConstruct() {
    const e = this.checkContainerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e
    }), this.addManagedPropertyListener("domLayout", e);
  }
  checkContainerWidths() {
    const e = this.gos.isDomLayout("print"), t = e ? 0 : this.visibleColsService.getColsLeftWidth(), r = e ? 0 : this.visibleColsService.getDisplayedColumnsRightWidth();
    t != this.leftWidth && (this.leftWidth = t, this.eventService.dispatchEvent({ type: "leftPinnedWidthChanged" })), r != this.rightWidth && (this.rightWidth = r, this.eventService.dispatchEvent({ type: "rightPinnedWidthChanged" }));
  }
  getPinnedRightWidth() {
    return this.rightWidth;
  }
  getPinnedLeftWidth() {
    return this.leftWidth;
  }
}, Uze = class extends Se {
  constructor() {
    super(...arguments), this.additionalFocusableContainers = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.beans = e, this.focusService = e.focusService, this.visibleColsService = e.visibleColsService;
  }
  setComp(e, t, r) {
    this.view = e, this.eGridHostDiv = t, this.eGui = r, this.eGui.setAttribute("grid-id", this.gridId);
    const { dragAndDropService: n, mouseEventService: i, ctrlsService: o, resizeObserverService: a } = this.beans;
    n.addDropTarget({
      getContainer: () => this.eGui,
      isInterestedIn: (l) => l === 1 || l === 0,
      getIconName: () => "notAllowed"
    }), i.stampTopLevelGridCompWithGridInstance(t), this.createManagedBean(new _I(this.view)), this.addRtlSupport();
    const s = a.observeResize(
      this.eGridHostDiv,
      this.onGridSizeChanged.bind(this)
    );
    this.addDestroyFunc(() => s()), o.register("gridCtrl", this);
  }
  isDetailGrid() {
    var t;
    const e = this.focusService.findTabbableParent(this.getGui());
    return ((t = e == null ? void 0 : e.getAttribute("row-id")) == null ? void 0 : t.startsWith("detail")) || !1;
  }
  getOptionalSelectors() {
    var t, r, n, i, o;
    const e = this.beans;
    return {
      paginationSelector: (t = e.paginationService) == null ? void 0 : t.getPaginationSelector(),
      gridHeaderDropZonesSelector: (r = e.columnDropZonesService) == null ? void 0 : r.getDropZoneSelector(),
      sideBarSelector: (n = e.sideBarService) == null ? void 0 : n.getSideBarSelector(),
      statusBarSelector: (i = e.statusBarService) == null ? void 0 : i.getStatusPanelSelector(),
      watermarkSelector: (o = e.licenseManager) == null ? void 0 : o.getWatermarkSelector()
    };
  }
  onGridSizeChanged() {
    const e = {
      type: "gridSizeChanged",
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    };
    this.eventService.dispatchEvent(e);
  }
  addRtlSupport() {
    const e = this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr";
    this.view.setRtlClass(e);
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(e) {
    this.view.setCursor(e ? "ew-resize" : null);
  }
  disableUserSelect(e) {
    this.view.setUserSelect(e ? "none" : null);
  }
  focusNextInnerContainer(e) {
    const t = this.getFocusableContainers(), r = this.gos.getActiveDomElement(), n = t.findIndex((o) => o.getGui().contains(r)), i = n + (e ? -1 : 1);
    if (i < 0 || i >= t.length)
      return !1;
    if (i === 0) {
      if (n > 0) {
        const o = this.visibleColsService.getAllCols(), a = gr(o);
        if (this.focusService.focusGridView(a, !0))
          return !0;
      }
      return !1;
    }
    return this.focusContainer(t[i], e);
  }
  focusInnerElement(e) {
    const t = this.getFocusableContainers(), r = this.visibleColsService.getAllCols(), n = this.gos.getCallback("focusGridInnerElement");
    if (n && n({ fromBottom: !!e }))
      return !0;
    if (e) {
      if (t.length > 1)
        return this.focusContainer(gr(t), !0);
      const i = gr(r);
      if (this.focusService.focusGridView(i, !0))
        return !0;
    }
    if (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus")) {
      if (this.focusService.focusGridView(r[0]))
        return !0;
      for (let i = 1; i < t.length; i++)
        if (this.focusService.focusInto(t[i].getGui()))
          return !0;
      return !1;
    }
    return this.focusService.focusFirstHeader();
  }
  forceFocusOutOfContainer(e = !1) {
    this.view.forceFocusOutOfContainer(e);
  }
  addFocusableContainer(e) {
    this.additionalFocusableContainers.add(e);
  }
  removeFocusableContainer(e) {
    this.additionalFocusableContainers.delete(e);
  }
  focusContainer(e, t) {
    var n, i;
    (n = e == null ? void 0 : e.setAllowFocus) == null || n.call(e, !0);
    const r = this.focusService.focusInto(e.getGui(), t);
    return (i = e == null ? void 0 : e.setAllowFocus) == null || i.call(e, !1), r;
  }
  getFocusableContainers() {
    return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers.values()];
  }
  destroy() {
    this.additionalFocusableContainers.clear(), super.destroy();
  }
}, Kze = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "alignedGridsService", this.consuming = !1;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.ctrlsService = e.ctrlsService, this.columnApplyStateService = e.columnApplyStateService;
  }
  getAlignedGridApis() {
    let e = this.gos.get("alignedGrids") ?? [];
    const t = typeof e == "function";
    typeof e == "function" && (e = e());
    const r = () => `See ${this.getFrameworkOverrides().getDocLink("aligned-grids")}`;
    return e.map((i) => {
      var a;
      if (!i) {
        Er("alignedGrids contains an undefined option."), t || Er(`You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`), Er(r());
        return;
      }
      if (this.isGridApi(i))
        return i;
      const o = i;
      return "current" in o ? (a = o.current) == null ? void 0 : a.api : (o.api || Er(
        `alignedGrids - No api found on the linked grid. If you are passing gridOptions to alignedGrids since v31 this is no longer valid. ${r()}`
      ), o.api);
    }).filter((i) => !!i && !i.isDestroyed());
  }
  isGridApi(e) {
    return !!e && !!e.dispatchEvent;
  }
  postConstruct() {
    const e = this.fireColumnEvent.bind(this);
    this.addManagedEventListeners({
      columnMoved: e,
      columnVisible: e,
      columnPinned: e,
      columnGroupOpened: e,
      columnResized: e,
      bodyScroll: this.fireScrollEvent.bind(this),
      alignedGridColumn: ({ event: t }) => this.onColumnEvent(t),
      alignedGridScroll: ({ event: t }) => this.onScrollEvent(t)
    });
  }
  // common logic across all the fire methods
  fireEvent(e) {
    this.consuming || this.getAlignedGridApis().forEach((t) => {
      t.isDestroyed() || t.dispatchEvent(e);
    });
  }
  // common logic across all consume methods. very little common logic, however extracting
  // guarantees consistency across the methods.
  onEvent(e) {
    this.consuming = !0, e(), this.consuming = !1;
  }
  fireColumnEvent(e) {
    const t = {
      type: "alignedGridColumn",
      event: e
    };
    this.fireEvent(t);
  }
  fireScrollEvent(e) {
    if (e.direction !== "horizontal")
      return;
    const t = {
      type: "alignedGridScroll",
      event: e
    };
    this.fireEvent(t);
  }
  onScrollEvent(e) {
    this.onEvent(() => {
      this.ctrlsService.getGridBodyCtrl().getScrollFeature().setHorizontalScrollPosition(e.left, !0);
    });
  }
  getMasterColumns(e) {
    const t = [];
    return e.columns ? e.columns.forEach((r) => {
      t.push(r);
    }) : e.column && t.push(e.column), t;
  }
  getColumnIds(e) {
    const t = [];
    return e.columns ? e.columns.forEach((r) => {
      t.push(r.getColId());
    }) : e.column && t.push(e.column.getColId()), t;
  }
  onColumnEvent(e) {
    this.onEvent(() => {
      switch (e.type) {
        case "columnMoved":
        case "columnVisible":
        case "columnPinned":
        case "columnResized": {
          const t = e;
          this.processColumnEvent(t);
          break;
        }
        case "columnGroupOpened": {
          const t = e;
          this.processGroupOpenedEvent(t);
          break;
        }
        case "columnPivotChanged":
          Te(
            "pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid."
          );
          break;
      }
    });
  }
  processGroupOpenedEvent(e) {
    e.columnGroups.forEach((t) => {
      let r = null;
      if (t) {
        const n = t.getGroupId();
        r = this.columnModel.getProvidedColGroup(n);
      }
      t && !r || this.columnModel.setColumnGroupOpened(r, t.isExpanded(), "alignedGridChanged");
    });
  }
  processColumnEvent(e) {
    var a;
    const t = e.column;
    let r = null;
    if (t && (r = this.columnModel.getColDefCol(t.getColId())), t && !r)
      return;
    const n = this.getMasterColumns(e);
    switch (e.type) {
      case "columnMoved":
        {
          const l = e.api.getColumnState().map((u) => ({ colId: u.colId }));
          this.columnApplyStateService.applyColumnState(
            { state: l, applyOrder: !0 },
            "alignedGridChanged"
          );
        }
        break;
      case "columnVisible":
        {
          const l = e.api.getColumnState().map((u) => ({ colId: u.colId, hide: u.hide }));
          this.columnApplyStateService.applyColumnState({ state: l }, "alignedGridChanged");
        }
        break;
      case "columnPinned":
        {
          const l = e.api.getColumnState().map((u) => ({ colId: u.colId, pinned: u.pinned }));
          this.columnApplyStateService.applyColumnState({ state: l }, "alignedGridChanged");
        }
        break;
      case "columnResized": {
        const s = e, l = {};
        n.forEach((u) => {
          l[u.getId()] = { key: u.getColId(), newWidth: u.getActualWidth() };
        }), (a = s.flexColumns) == null || a.forEach((u) => {
          l[u.getId()] && delete l[u.getId()];
        }), this.columnSizeService.setColumnWidths(
          Object.values(l),
          !1,
          s.finished,
          "alignedGridChanged"
        );
        break;
      }
    }
    const o = this.ctrlsService.getGridBodyCtrl().isVerticalScrollShowing();
    this.getAlignedGridApis().forEach((s) => {
      s.setGridOption("alwaysShowVerticalScroll", o);
    });
  }
}, Yze = {
  version: kt,
  moduleName: "@ag-grid-community/aligned-grid",
  beans: [Kze]
};
function qze(e, t) {
  const r = e.columnModel.getColDefCol(t);
  return r ? r.getColDef() : null;
}
function Xze(e) {
  return e.columnModel.getColumnDefs();
}
function Zze(e, t) {
  typeof t == "number" ? e.columnSizeService.sizeColumnsToFit(t, "api") : e.ctrlsService.getGridBodyCtrl().sizeColumnsToFit(t);
}
function Qze(e, t, r) {
  e.columnModel.setColumnGroupOpened(t, r, "api");
}
function Jze(e, t, r) {
  return e.visibleColsService.getColumnGroup(t, r);
}
function e5e(e, t) {
  return e.columnModel.getProvidedColGroup(t);
}
function t5e(e, t, r) {
  return e.columnNameService.getDisplayNameForColumn(t, r) || "";
}
function r5e(e, t, r) {
  return e.columnNameService.getDisplayNameForColumnGroup(t, r) || "";
}
function n5e(e, t) {
  return e.columnModel.getColDefCol(t);
}
function i5e(e) {
  return e.columnModel.getColDefCols();
}
function o5e(e, t) {
  return e.columnApplyStateService.applyColumnState(t, "api");
}
function a5e(e) {
  return e.columnGetStateService.getColumnState();
}
function s5e(e) {
  e.columnApplyStateService.resetColumnState("api");
}
function l5e(e) {
  return e.columnGroupStateService.getColumnGroupState();
}
function u5e(e, t) {
  e.columnGroupStateService.setColumnGroupState(t, "api");
}
function c5e(e) {
  e.columnGroupStateService.resetColumnGroupState("api");
}
function d5e(e) {
  return e.visibleColsService.isPinningLeft() || e.visibleColsService.isPinningRight();
}
function h5e(e) {
  return e.visibleColsService.isPinningLeft();
}
function f5e(e) {
  return e.visibleColsService.isPinningRight();
}
function p5e(e, t) {
  return e.visibleColsService.getColAfter(t);
}
function g5e(e, t) {
  return e.visibleColsService.getColBefore(t);
}
function v5e(e, t, r) {
  e.columnModel.setColsVisible([t], r, "api");
}
function m5e(e, t, r) {
  e.columnModel.setColsVisible(t, r, "api");
}
function y5e(e, t, r) {
  e.columnModel.setColsPinned([t], r, "api");
}
function C5e(e, t, r) {
  e.columnModel.setColsPinned(t, r, "api");
}
function S5e(e) {
  return e.columnModel.getCols();
}
function w5e(e) {
  return e.visibleColsService.getLeftCols();
}
function b5e(e) {
  return e.visibleColsService.getCenterCols();
}
function x5e(e) {
  return e.visibleColsService.getRightCols();
}
function E5e(e) {
  return e.visibleColsService.getAllCols();
}
function R5e(e) {
  return e.columnViewportService.getViewportColumns();
}
function _5e(e, t, r) {
  e.columnMoveService.moveColumns([t], r, "api");
}
function T5e(e, t, r) {
  e.columnMoveService.moveColumnByIndex(t, r, "api");
}
function P5e(e, t, r) {
  e.columnMoveService.moveColumns(t, r, "api");
}
function M5e(e, t, r, n = !0, i = "api") {
  e.columnSizeService.setColumnWidths([{ key: t, newWidth: r }], !1, n, i);
}
function D5e(e, t, r = !0, n = "api") {
  e.columnSizeService.setColumnWidths(t, !1, r, n);
}
function A5e(e) {
  return e.visibleColsService.getTreeLeft();
}
function I5e(e) {
  return e.visibleColsService.getTreeCenter();
}
function O5e(e) {
  return e.visibleColsService.getTreeRight();
}
function L5e(e) {
  return e.visibleColsService.getAllTrees();
}
function F5e(e, t, r) {
  return e.columnAutosizeService.autoSizeCols({ colKeys: [t], skipHeader: r, source: "api" });
}
function N5e(e, t, r) {
  e.columnAutosizeService.autoSizeCols({ colKeys: t, skipHeader: r, source: "api" });
}
function k5e(e, t) {
  e.columnAutosizeService.autoSizeAllColumns("api", t);
}
var JH = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, eG = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
], V5e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "dataTypeService", this.dataTypeDefinitions = {}, this.isWaitingForRowData = !1, this.isColumnTypeOverrideInDataTypeDefinitions = !1, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.valueService = e.valueService, this.columnApplyStateService = e.columnApplyStateService;
  }
  postConstruct() {
    this.groupHideOpenParents = this.gos.get("groupHideOpenParents"), this.addManagedPropertyListener("groupHideOpenParents", () => {
      this.groupHideOpenParents = this.gos.get("groupHideOpenParents");
    }), this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", (e) => {
      this.processDataTypeDefinitions(), this.columnModel.recreateColumnDefs(Ch(e.source));
    });
  }
  processDataTypeDefinitions() {
    const e = this.getDefaultDataTypes();
    this.dataTypeDefinitions = {}, this.formatValueFuncs = {};
    const t = (n) => (i) => {
      const { column: o, node: a, value: s } = i;
      let l = o.getColDef().valueFormatter;
      return l === n.groupSafeValueFormatter && (l = n.valueFormatter), this.valueService.formatValue(o, a, s, l);
    };
    Object.entries(e).forEach(([n, i]) => {
      const o = {
        ...i,
        groupSafeValueFormatter: this.createGroupSafeValueFormatter(i)
      };
      this.dataTypeDefinitions[n] = o, this.formatValueFuncs[n] = t(o);
    });
    const r = this.gos.get("dataTypeDefinitions") ?? {};
    this.dataTypeMatchers = {}, Object.entries(r).forEach(([n, i]) => {
      const o = this.processDataTypeDefinition(
        i,
        r,
        [n],
        e
      );
      o && (this.dataTypeDefinitions[n] = o, i.dataTypeMatcher && (this.dataTypeMatchers[n] = i.dataTypeMatcher), this.formatValueFuncs[n] = t(o));
    }), this.checkObjectValueHandlers(e), ["dateString", "text", "number", "boolean", "date"].forEach((n) => {
      const i = this.dataTypeMatchers[n];
      i && delete this.dataTypeMatchers[n], this.dataTypeMatchers[n] = i ?? e[n].dataTypeMatcher;
    });
  }
  mergeDataTypeDefinitions(e, t) {
    const r = {
      ...e,
      ...t
    };
    return e.columnTypes && t.columnTypes && t.appendColumnTypes && (r.columnTypes = [
      ...x0(e.columnTypes),
      ...x0(t.columnTypes)
    ]), r;
  }
  processDataTypeDefinition(e, t, r, n) {
    let i;
    const o = e.extendsDataType;
    if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0), e.extendsDataType === e.baseDataType) {
      let a = n[o];
      const s = t[o];
      if (a && s && (a = s), !this.validateDataTypeDefinition(e, a, o))
        return;
      i = this.mergeDataTypeDefinitions(a, e);
    } else {
      if (r.includes(o)) {
        Te(
          'Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.'
        );
        return;
      }
      const a = t[o];
      if (!this.validateDataTypeDefinition(e, a, o))
        return;
      const s = this.processDataTypeDefinition(
        a,
        t,
        [...r, o],
        n
      );
      if (!s)
        return;
      i = this.mergeDataTypeDefinitions(
        s,
        e
      );
    }
    return {
      ...i,
      groupSafeValueFormatter: this.createGroupSafeValueFormatter(i)
    };
  }
  validateDataTypeDefinition(e, t, r) {
    return t ? t.baseDataType !== e.baseDataType ? (Te('The "baseDataType" property of a data type definition must match that of its parent.'), !1) : !0 : (Te(`The data type definition ${r} does not exist.`), !1);
  }
  createGroupSafeValueFormatter(e) {
    if (e.valueFormatter)
      return (t) => {
        var r, n;
        if ((r = t.node) != null && r.group) {
          const i = t.column.getAggFunc();
          if (i) {
            if (i === "first" || i === "last")
              return e.valueFormatter(t);
            if (e.baseDataType === "number" && i !== "count") {
              if (typeof t.value == "number")
                return e.valueFormatter(t);
              if (typeof t.value == "object") {
                if (!t.value)
                  return;
                if ("toNumber" in t.value)
                  return e.valueFormatter({
                    ...t,
                    value: t.value.toNumber()
                  });
                if ("value" in t.value)
                  return e.valueFormatter({
                    ...t,
                    value: t.value.value
                  });
              }
            }
          }
          if (!this.gos.get("suppressGroupMaintainValueType"))
            return;
        } else if (this.groupHideOpenParents && t.column.isRowGroupActive()) {
          if (typeof t.value != "string" || (n = e.dataTypeMatcher) != null && n.call(e, t.value))
            return e.valueFormatter(t);
          if (!this.gos.get("suppressGroupMaintainValueType"))
            return;
        }
        return e.valueFormatter(t);
      };
  }
  updateColDefAndGetColumnType(e, t, r) {
    let { cellDataType: n } = t;
    const { field: i } = t;
    if (n === void 0 && (n = e.cellDataType), (n == null || n === !0) && (n = this.canInferCellDataType(e, t) ? this.inferCellDataType(i, r) : !1), !n) {
      e.cellDataType = !1;
      return;
    }
    const o = this.dataTypeDefinitions[n];
    if (!o) {
      Te(`Missing data type definition - "${n}"`);
      return;
    }
    return e.cellDataType = n, o.groupSafeValueFormatter && (e.valueFormatter = o.groupSafeValueFormatter), o.valueParser && (e.valueParser = o.valueParser), o.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, n, o, r), o.columnTypes;
  }
  addColumnListeners(e) {
    if (!this.isWaitingForRowData)
      return;
    const t = this.columnStateUpdatesPendingInference[e.getColId()];
    if (!t)
      return;
    const r = (n) => {
      t.add(n.key);
    };
    e.addEventListener("columnStateUpdated", r), this.columnStateUpdateListenerDestroyFuncs.push(
      () => e.removeEventListener("columnStateUpdated", r)
    );
  }
  canInferCellDataType(e, t) {
    if (this.rowModel.getType() !== "clientSide")
      return !1;
    const r = { cellRenderer: !0, valueGetter: !0, valueParser: !0, refData: !0 };
    if (this.doColDefPropsPreventInference(t, r))
      return !1;
    const n = t.type === null ? e.type : t.type;
    if (n) {
      const i = this.gos.get("columnTypes") ?? {};
      if (x0(n).some((a) => {
        const s = i[a.trim()];
        return s && this.doColDefPropsPreventInference(s, r);
      }))
        return !1;
    }
    return !this.doColDefPropsPreventInference(e, r);
  }
  doColDefPropsPreventInference(e, t) {
    return [
      ["cellRenderer", "agSparklineCellRenderer"],
      ["valueGetter", void 0],
      ["valueParser", void 0],
      ["refData", void 0]
    ].some(
      ([r, n]) => this.doesColDefPropPreventInference(e, t, r, n)
    );
  }
  doesColDefPropPreventInference(e, t, r, n) {
    if (!t[r])
      return !1;
    const i = e[r];
    return i === null ? (t[r] = !1, !1) : n === void 0 ? !!i : i === n;
  }
  inferCellDataType(e, t) {
    if (!e)
      return;
    let r;
    const n = this.getInitialData();
    if (n) {
      const o = e.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      r = mg(n, e, o);
    } else
      this.initWaitForRowData(t);
    if (r == null)
      return;
    const [i] = Object.entries(this.dataTypeMatchers).find(
      ([o, a]) => a(r)
    ) ?? ["object"];
    return i;
  }
  getInitialData() {
    const e = this.gos.get("rowData");
    if (e != null && e.length)
      return e[0];
    if (this.initialData)
      return this.initialData;
    {
      const t = this.rowModel.getRootNode().allLeafChildren;
      if (t != null && t.length)
        return t[0].data;
    }
    return null;
  }
  initWaitForRowData(e) {
    if (this.columnStateUpdatesPendingInference[e] = /* @__PURE__ */ new Set(), this.isWaitingForRowData)
      return;
    this.isWaitingForRowData = !0;
    const t = this.isColumnTypeOverrideInDataTypeDefinitions;
    t && this.columnModel.queueResizeOperations();
    const [r] = this.addManagedEventListeners({
      rowDataUpdateStarted: (n) => {
        const { firstRowData: i } = n;
        if (!i)
          return;
        r == null || r(), this.isWaitingForRowData = !1, this.processColumnsPendingInference(i, t), this.columnStateUpdatesPendingInference = {}, t && this.columnModel.processResizeOperations();
        const o = {
          type: "dataTypesInferred"
        };
        this.eventService.dispatchEvent(o);
      }
    });
  }
  isPendingInference() {
    return this.isWaitingForRowData;
  }
  processColumnsPendingInference(e, t) {
    this.initialData = e;
    const r = [];
    this.destroyColumnStateUpdateListeners();
    const n = {}, i = {};
    Object.entries(this.columnStateUpdatesPendingInference).forEach(([o, a]) => {
      const s = this.columnModel.getCol(o);
      if (!s)
        return;
      const l = s.getColDef();
      if (!this.columnModel.resetColDefIntoCol(s, "cellDataTypeInferred"))
        return;
      const u = s.getColDef();
      if (t && u.type && u.type !== l.type) {
        const c = this.getUpdatedColumnState(s, a);
        c.rowGroup && c.rowGroupIndex == null && (n[o] = c), c.pivot && c.pivotIndex == null && (i[o] = c), r.push(c);
      }
    }), t && r.push(
      ...this.funcColsService.generateColumnStateForRowGroupAndPivotIndexes(
        n,
        i
      )
    ), r.length && this.columnApplyStateService.applyColumnState({ state: r }, "cellDataTypeInferred"), this.initialData = null;
  }
  getUpdatedColumnState(e, t) {
    const r = this.columnApplyStateService.getColumnStateFromColDef(e);
    return t.forEach((n) => {
      delete r[n], n === "rowGroup" ? delete r.rowGroupIndex : n === "pivot" && delete r.pivotIndex;
    }), r;
  }
  checkObjectValueHandlers(e) {
    const t = this.dataTypeDefinitions.object, r = e.object;
    this.hasObjectValueParser = t.valueParser !== r.valueParser, this.hasObjectValueFormatter = t.valueFormatter !== r.valueFormatter;
  }
  getDateStringTypeDefinition(e) {
    return e ? this.getDataTypeDefinition(e) ?? this.dataTypeDefinitions.dateString : this.dataTypeDefinitions.dateString;
  }
  getDateParserFunction(e) {
    return this.getDateStringTypeDefinition(e).dateParser;
  }
  getDateFormatterFunction(e) {
    return this.getDateStringTypeDefinition(e).dateFormatter;
  }
  getDataTypeDefinition(e) {
    const t = e.getColDef();
    if (t.cellDataType)
      return this.dataTypeDefinitions[t.cellDataType];
  }
  getBaseDataType(e) {
    var t;
    return (t = this.getDataTypeDefinition(e)) == null ? void 0 : t.baseDataType;
  }
  checkType(e, t) {
    var n;
    if (t == null)
      return !0;
    const r = (n = this.getDataTypeDefinition(e)) == null ? void 0 : n.dataTypeMatcher;
    return r ? r(t) : !0;
  }
  validateColDef(e) {
    e.cellDataType === "object" && (e.valueFormatter === this.dataTypeDefinitions.object.groupSafeValueFormatter && !this.hasObjectValueFormatter && Te(
      'Cell data type is "object" but no value formatter has been provided. Please either provide an object data type definition with a value formatter, or set "colDef.valueFormatter"'
    ), e.editable && e.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser && Te(
      'Cell data type is "object" but no value parser has been provided. Please either provide an object data type definition with a value parser, or set "colDef.valueParser"'
    ));
  }
  getFormatValue(e) {
    return this.formatValueFuncs[e];
  }
  setColDefPropertiesForBaseDataType(e, t, r, n) {
    const i = this.formatValueFuncs[t], o = ci.__isRegistered("@ag-grid-enterprise/set-filter", this.gridId), a = this.localeService.getLocaleTextFunc(), s = (l) => {
      const { filterParams: u } = e;
      e.filterParams = typeof u == "object" ? {
        ...u,
        ...l
      } : l;
    };
    switch (r.baseDataType) {
      case "number": {
        e.cellEditor = "agNumberCellEditor", o && s({
          comparator: (l, u) => {
            const c = l == null ? 0 : parseInt(l), d = u == null ? 0 : parseInt(u);
            return c === d ? 0 : c > d ? 1 : -1;
          }
        });
        break;
      }
      case "boolean": {
        e.cellEditor = "agCheckboxCellEditor", e.cellRenderer = "agCheckboxCellRenderer", e.suppressKeyboardEvent = (l) => !!l.colDef.editable && l.event.key === pe.SPACE, s(o ? {
          valueFormatter: (l) => ke(l.value) ? a(String(l.value), l.value ? "True" : "False") : a("blanks", "(Blanks)")
        } : {
          maxNumConditions: 1,
          debounceMs: 0,
          filterOptions: [
            "empty",
            {
              displayKey: "true",
              displayName: "True",
              predicate: (l, u) => u,
              numberOfInputs: 0
            },
            {
              displayKey: "false",
              displayName: "False",
              predicate: (l, u) => u === !1,
              numberOfInputs: 0
            }
          ]
        });
        break;
      }
      case "date": {
        e.cellEditor = "agDateCellEditor", e.keyCreator = i, o && s({
          valueFormatter: (l) => {
            const u = i(l);
            return ke(u) ? u : a("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListFormatter: (l, u) => {
            if (u === 1 && l != null) {
              const c = eG[Number(l) - 1];
              return a(c, JH[c]);
            }
            return l ?? a("blanks", "(Blanks)");
          }
        });
        break;
      }
      case "dateString": {
        e.cellEditor = "agDateStringCellEditor", e.keyCreator = i;
        const l = r.dateParser;
        s(o ? {
          valueFormatter: (u) => {
            const c = i(u);
            return ke(c) ? c : a("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListPathGetter: (u) => {
            const c = l(u ?? void 0);
            return c ? [String(c.getFullYear()), String(c.getMonth() + 1), String(c.getDate())] : null;
          },
          treeListFormatter: (u, c) => {
            if (c === 1 && u != null) {
              const d = eG[Number(u) - 1];
              return a(d, JH[d]);
            }
            return u ?? a("blanks", "(Blanks)");
          }
        } : {
          comparator: (u, c) => {
            const d = l(c);
            return c == null || d < u ? -1 : d > u ? 1 : 0;
          }
        });
        break;
      }
      case "object": {
        e.cellEditorParams = {
          useFormatter: !0
        }, e.comparator = (l, u) => {
          const c = this.columnModel.getColDefCol(n), d = c == null ? void 0 : c.getColDef();
          if (!c || !d)
            return 0;
          const h = l == null ? "" : i({ column: c, node: null, value: l }), f = u == null ? "" : i({ column: c, node: null, value: u });
          return h === f ? 0 : h > f ? 1 : -1;
        }, e.keyCreator = i, o ? s({
          valueFormatter: (l) => {
            const u = i(l);
            return ke(u) ? u : a("blanks", "(Blanks)");
          }
        }) : e.filterValueGetter = (l) => i({
          column: l.column,
          node: l.node,
          value: this.valueService.getValue(l.column, l.node)
        });
        break;
      }
    }
  }
  getDefaultDataTypes() {
    const e = (r) => !!r.match("^\\d{4}-\\d{2}-\\d{2}$"), t = this.localeService.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        // can be empty space with legacy copy
        valueParser: (r) => {
          var n, i;
          return ((i = (n = r.newValue) == null ? void 0 : n.trim) == null ? void 0 : i.call(n)) === "" ? null : Number(r.newValue);
        },
        valueFormatter: (r) => r.value == null ? "" : typeof r.value != "number" || isNaN(r.value) ? t("invalidNumber", "Invalid Number") : String(r.value),
        dataTypeMatcher: (r) => typeof r == "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (r) => r.newValue === "" ? null : eP(r.newValue),
        dataTypeMatcher: (r) => typeof r == "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (r) => {
          var n, i;
          return r.newValue == null ? r.newValue : ((i = (n = r.newValue) == null ? void 0 : n.trim) == null ? void 0 : i.call(n)) === "" ? null : String(r.newValue).toLowerCase() === "true";
        },
        valueFormatter: (r) => r.value == null ? "" : String(r.value),
        dataTypeMatcher: (r) => typeof r == "boolean"
      },
      date: {
        baseDataType: "date",
        valueParser: (r) => qi(r.newValue == null ? null : String(r.newValue)),
        valueFormatter: (r) => r.value == null ? "" : !(r.value instanceof Date) || isNaN(r.value.getTime()) ? t("invalidDate", "Invalid Date") : Xo(r.value, !1) ?? "",
        dataTypeMatcher: (r) => r instanceof Date
      },
      dateString: {
        baseDataType: "dateString",
        dateParser: (r) => qi(r) ?? void 0,
        dateFormatter: (r) => Xo(r ?? null, !1) ?? void 0,
        valueParser: (r) => e(String(r.newValue)) ? r.newValue : null,
        valueFormatter: (r) => e(String(r.value)) ? r.value : "",
        dataTypeMatcher: (r) => typeof r == "string" && e(r)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (r) => eP(r.value) ?? ""
      }
    };
  }
  destroyColumnStateUpdateListeners() {
    this.columnStateUpdateListenerDestroyFuncs.forEach((e) => e()), this.columnStateUpdateListenerDestroyFuncs = [];
  }
  destroy() {
    this.dataTypeDefinitions = {}, this.dataTypeMatchers = {}, this.formatValueFuncs = {}, this.columnStateUpdatesPendingInference = {}, this.destroyColumnStateUpdateListeners(), super.destroy();
  }
}, B5e = {
  version: kt,
  moduleName: "@ag-grid-community/data-type",
  beans: [V5e]
}, $5e = {
  version: kt,
  moduleName: "@ag-grid-community/column-api",
  apiFunctions: {
    getColumnDef: qze,
    getColumnDefs: Xze,
    sizeColumnsToFit: Zze,
    setColumnGroupOpened: Qze,
    getColumnGroup: Jze,
    getProvidedColumnGroup: e5e,
    getDisplayNameForColumn: t5e,
    getDisplayNameForColumnGroup: r5e,
    getColumn: n5e,
    getColumns: i5e,
    applyColumnState: o5e,
    getColumnState: a5e,
    resetColumnState: s5e,
    getColumnGroupState: l5e,
    setColumnGroupState: u5e,
    resetColumnGroupState: c5e,
    isPinning: d5e,
    isPinningLeft: h5e,
    isPinningRight: f5e,
    getDisplayedColAfter: p5e,
    getDisplayedColBefore: g5e,
    setColumnVisible: v5e,
    setColumnsVisible: m5e,
    setColumnPinned: y5e,
    setColumnsPinned: C5e,
    getAllGridColumns: S5e,
    getDisplayedLeftColumns: w5e,
    getDisplayedCenterColumns: b5e,
    getDisplayedRightColumns: x5e,
    getAllDisplayedColumns: E5e,
    getAllDisplayedVirtualColumns: R5e,
    moveColumn: _5e,
    moveColumnByIndex: T5e,
    moveColumns: P5e,
    setColumnWidth: M5e,
    setColumnWidths: D5e,
    getLeftDisplayedColumnGroups: A5e,
    getCenterDisplayedColumnGroups: I5e,
    getRightDisplayedColumnGroups: O5e,
    getAllDisplayedColumnGroups: L5e,
    autoSizeColumn: F5e,
    autoSizeColumns: N5e,
    autoSizeAllColumns: k5e
  }
};
function H5e(e, t) {
  e.ctrlsService.getGridBodyCtrl().getRowDragFeature().addRowDropZone(t);
}
function G5e(e, t) {
  const r = e.dragAndDropService.findExternalZone(t);
  r && e.dragAndDropService.removeDropTarget(r);
}
function z5e(e, t) {
  return e.ctrlsService.getGridBodyCtrl().getRowDragFeature().getRowDropZone(t);
}
var W5e = {
  version: kt,
  moduleName: "@ag-grid-community/drag-api",
  apiFunctions: {
    addRowDropZone: H5e,
    removeRowDropZone: G5e,
    getRowDropZoneParams: z5e
  }
};
function j5e(e) {
  return e.pinnedRowModel.getPinnedTopRowCount();
}
function U5e(e) {
  return e.pinnedRowModel.getPinnedBottomRowCount();
}
function K5e(e, t) {
  return e.pinnedRowModel.getPinnedTopRow(t);
}
function Y5e(e, t) {
  return e.pinnedRowModel.getPinnedBottomRow(t);
}
var q5e = {
  version: kt,
  moduleName: "@ag-grid-community/pinned-row-api",
  apiFunctions: {
    getPinnedTopRowCount: j5e,
    getPinnedBottomRowCount: U5e,
    getPinnedTopRow: K5e,
    getPinnedBottomRow: Y5e
  }
};
function X5e(e) {
  e.overlayService.showLoadingOverlay();
}
function Z5e(e) {
  e.overlayService.showNoRowsOverlay();
}
function Q5e(e) {
  e.overlayService.hideOverlay();
}
var J5e = {
  version: kt,
  moduleName: "@ag-grid-community/overlay-api",
  apiFunctions: {
    showLoadingOverlay: X5e,
    showNoRowsOverlay: Z5e,
    hideOverlay: Q5e
  }
};
function e8e(e, t, r) {
  if (!t)
    return;
  const n = e.ctrlsService.getGridBodyCtrl().getGui(), i = `aria-${t}`;
  r === null ? n.removeAttribute(i) : n.setAttribute(i, r);
}
function t8e(e, t = {}) {
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.refreshCells(t));
}
function r8e(e, t = {}) {
  const r = (n) => Te(
    `Since v31.1 api.flashCells parameter '${n}Delay' is deprecated. Please use '${n}Duration' instead.`
  );
  ke(t.fadeDelay) && r("fade"), ke(t.flashDelay) && r("flash"), e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.flashCells(t));
}
function n8e(e) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getHeaderRowContainerCtrls().forEach((t) => t.refresh())
  );
}
function i8e(e) {
  return e.animationFrameService.isQueueEmpty();
}
function o8e(e) {
  e.animationFrameService.flushAllFrames();
}
function a8e(e) {
  return {
    rowHeight: e.gos.getRowHeightAsNumber(),
    headerHeight: e.columnModel.getHeaderHeight()
  };
}
function s8e(e, t = {}) {
  return e.rowRenderer.getCellRendererInstances(t).map(Cg);
}
var l8e = {
  version: kt,
  moduleName: "@ag-grid-community/render-api",
  apiFunctions: {
    setGridAriaProperty: e8e,
    refreshCells: t8e,
    flashCells: r8e,
    refreshHeader: n8e,
    isAnimationFrameQueueEmpty: i8e,
    flushAllAnimationFrames: o8e,
    getSizesForCurrentTheme: a8e,
    getCellRendererInstances: s8e
  }
};
function u8e(e) {
  e.valueCache.expire();
}
function c8e(e, t, r) {
  return rX(e, { colKey: t, rowNode: r });
}
function rX(e, t) {
  const { colKey: r, rowNode: n, useFormatter: i } = t, o = e.columnModel.getColDefCol(r) ?? e.columnModel.getCol(r);
  if (dr(o))
    return null;
  const a = e.valueService.getValue(o, n);
  return i ? e.valueService.formatValue(o, n, a) ?? hs(a, !0) : a;
}
function d8e(e) {
  return e.context.getGridId();
}
function h8e(e) {
  e.gridDestroyService.destroy();
}
function f8e(e) {
  return e.gridDestroyService.isDestroyCalled();
}
function p8e(e, t) {
  return e.gos.get(t);
}
function g8e(e, t, r) {
  nX(e, { [t]: r });
}
function nX(e, t) {
  e.gos.updateGridOptions({ options: t });
}
function v8e(e, t, r) {
  e.apiEventService.addEventListener(t, r);
}
function m8e(e, t, r) {
  e.apiEventService.removeEventListener(t, r);
}
function y8e(e, t) {
  e.apiEventService.addGlobalListener(t);
}
function C8e(e, t) {
  e.apiEventService.removeGlobalListener(t);
}
function S8e(e) {
  return e.focusService.getFocusedCell();
}
function w8e(e) {
  return e.focusService.clearFocusedCell();
}
function b8e(e, t, r, n) {
  e.focusService.setFocusedCell({ rowIndex: t, column: r, rowPinned: n, forceBrowserFocus: !0 });
}
function x8e(e, t) {
  return e.navigationService.tabToNextCell(!1, t);
}
function E8e(e, t) {
  return e.navigationService.tabToNextCell(!0, t);
}
function R8e(e, t, r = !1) {
  const n = e.headerNavigationService.getHeaderPositionForColumn(t, r);
  n && e.focusService.focusHeaderPosition({ headerPosition: n });
}
function _8e(e, t, r) {
  const n = e.columnModel.getCol(t);
  e.menuService.showColumnMenu({
    column: n,
    buttonElement: r,
    positionBy: "button"
  });
}
function T8e(e, t, r) {
  let n = e.columnModel.getCol(t);
  if (n || (n = e.columnModel.getColDefCol(t)), !n) {
    Er(`column '${t}' not found`);
    return;
  }
  e.menuService.showColumnMenu({
    column: n,
    mouseEvent: r,
    positionBy: "mouse"
  });
}
function P8e(e, t) {
  const r = e.columnModel.getCol(t);
  if (!r) {
    Er(`column '${t}' not found`);
    return;
  }
  e.menuService.showColumnMenu({
    column: r,
    positionBy: "auto"
  });
}
function M8e(e) {
  e.menuService.hidePopupMenu();
}
function D8e(e, t = {}) {
  const r = t ? t.rowNodes : void 0;
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.redrawRows(r));
}
function A8e(e, t, r, n, i) {
  e.expansionService.setRowNodeExpanded(t, r, n, i);
}
function I8e(e, t) {
  return e.rowModel.getRowNode(t);
}
function O8e(e, t, r, n) {
  e.rowRenderer.addRenderedRowListener(t, r, n);
}
function L8e(e) {
  return e.rowRenderer.getRenderedNodes();
}
function F8e(e, t, r) {
  e.rowModel.forEachNode(t, r);
}
function N8e(e) {
  return iX(e);
}
function iX(e) {
  return e.rowRenderer.getFirstVirtualRenderedRow();
}
function k8e(e) {
  return oX(e);
}
function oX(e) {
  return e.rowRenderer.getLastVirtualRenderedRow();
}
function V8e(e, t) {
  return e.rowModel.getRow(t);
}
function B8e(e) {
  return e.rowModel.getRowCount();
}
function $8e(e) {
  return e.rowModel;
}
function H8e(e, t) {
  if (!t.nodes.every((s) => s.rowPinned ? (Te("cannot select pinned rows"), !1) : s.id === void 0 ? (Te("cannot select node until id for node is known"), !1) : !0))
    return;
  const { nodes: n, source: i, newValue: o } = t, a = n;
  e.selectionService.setNodesSelected({ nodes: a, source: i ?? "api", newValue: o });
}
function G8e(e, t = "apiSelectAll") {
  e.selectionService.selectAllRowNodes({ source: t });
}
function z8e(e, t = "apiSelectAll") {
  e.selectionService.deselectAllRowNodes({ source: t });
}
function W8e(e, t = "apiSelectAllFiltered") {
  e.selectionService.selectAllRowNodes({ source: t, justFiltered: !0 });
}
function j8e(e, t = "apiSelectAllFiltered") {
  e.selectionService.deselectAllRowNodes({ source: t, justFiltered: !0 });
}
function U8e(e, t = "apiSelectAllCurrentPage") {
  e.selectionService.selectAllRowNodes({ source: t, justCurrentPage: !0 });
}
function K8e(e, t = "apiSelectAllCurrentPage") {
  e.selectionService.deselectAllRowNodes({ source: t, justCurrentPage: !0 });
}
function Y8e(e) {
  return e.selectionService.getSelectedNodes();
}
function q8e(e) {
  return e.selectionService.getSelectedRows();
}
function X8e(e) {
  e.sortController.onSortChanged("api");
}
var Z8e = {
  version: kt,
  moduleName: "@ag-grid-community/core-api",
  apiFunctions: {
    getGridId: d8e,
    destroy: h8e,
    isDestroyed: f8e,
    getGridOption: p8e,
    setGridOption: g8e,
    updateGridOptions: nX
  }
}, Q8e = {
  version: kt,
  moduleName: "@ag-grid-community/row-selection-api",
  apiFunctions: {
    setNodesSelected: H8e,
    selectAll: G8e,
    deselectAll: z8e,
    selectAllFiltered: W8e,
    deselectAllFiltered: j8e,
    selectAllOnCurrentPage: U8e,
    deselectAllOnCurrentPage: K8e,
    getSelectedNodes: Y8e,
    getSelectedRows: q8e
  }
}, J8e = {
  version: kt,
  moduleName: "@ag-grid-community/row-api",
  apiFunctions: {
    redrawRows: D8e,
    setRowNodeExpanded: A8e,
    getRowNode: I8e,
    addRenderedRowListener: O8e,
    getRenderedNodes: L8e,
    forEachNode: F8e,
    getFirstDisplayedRow: N8e,
    getFirstDisplayedRowIndex: iX,
    getLastDisplayedRow: k8e,
    getLastDisplayedRowIndex: oX,
    getDisplayedRowAtIndex: V8e,
    getDisplayedRowCount: B8e,
    getModel: $8e
  }
}, e3e = {
  version: kt,
  moduleName: "@ag-grid-community/scroll-api",
  apiFunctions: {
    getVerticalPixelRange: VGe,
    getHorizontalPixelRange: BGe,
    ensureColumnVisible: Zq,
    ensureIndexVisible: Qq,
    ensureNodeVisible: $Ge
  }
}, t3e = {
  version: kt,
  moduleName: "@ag-grid-community/keyboard-navigation-api",
  apiFunctions: {
    getFocusedCell: S8e,
    clearFocusedCell: w8e,
    setFocusedCell: b8e,
    setFocusedHeader: R8e,
    tabToNextCell: x8e,
    tabToPreviousCell: E8e
  }
}, r3e = {
  version: kt,
  moduleName: "@ag-grid-community/event-api",
  apiFunctions: {
    addEventListener: v8e,
    addGlobalListener: y8e,
    removeEventListener: m8e,
    removeGlobalListener: C8e
  }
}, n3e = {
  version: kt,
  moduleName: "@ag-grid-community/cell-api",
  apiFunctions: {
    expireValueCache: u8e,
    getValue: c8e,
    getCellValue: rX
  }
}, i3e = {
  version: kt,
  moduleName: "@ag-grid-community/menu-api",
  apiFunctions: {
    showColumnMenuAfterButtonClick: _8e,
    showColumnMenuAfterMouseClick: T8e,
    showColumnMenu: P8e,
    hidePopupMenu: M8e
  }
}, o3e = {
  version: kt,
  moduleName: "@ag-grid-community/sort-api",
  apiFunctions: {
    onSortChanged: X8e
  }
}, a3e = {
  version: kt,
  moduleName: "@ag-grid-community/api",
  dependantModules: [
    Z8e,
    q5e,
    Q8e,
    $5e,
    J8e,
    W5e,
    e3e,
    J5e,
    t3e,
    r3e,
    l8e,
    n3e,
    i3e,
    o3e
  ]
};
function s3e(e) {
  var t;
  return ((t = e.stateService) == null ? void 0 : t.getState()) ?? {};
}
var l3e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "stateService", this.suppressEvents = !0, this.queuedUpdateSources = /* @__PURE__ */ new Set(), this.dispatchStateUpdateEventDebounced = Ti(() => this.dispatchQueuedStateUpdateEvents(), 0), this.onRowGroupOpenedDebounced = Ti(
      () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()),
      0
    ), this.onRowSelectedDebounced = Ti(() => {
      this.staleStateKeys.delete("rowSelection"), this.updateCachedState("rowSelection", this.getRowSelectionState());
    }, 0), this.staleStateKeys = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.ctrlsService = e.ctrlsService, this.pivotResultColsService = e.pivotResultColsService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnGroupStateService = e.columnGroupStateService, this.columnGetStateService = e.columnGetStateService, this.paginationService = e.paginationService, this.rowModel = e.rowModel, this.selectionService = e.selectionService, this.expansionService = e.expansionService, this.columnAnimationService = e.columnAnimationService, this.columnApplyStateService = e.columnApplyStateService, this.sideBarService = e.sideBarService, this.rangeService = e.rangeService;
  }
  postConstruct() {
    this.isClientSideRowModel = this.rowModel.getType() === "clientSide", this.cachedState = this.gos.get("initialState") ?? {}, this.ctrlsService.whenReady(() => this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnGridReady()));
    const [e, t, r] = this.addManagedEventListeners({
      newColumnsLoaded: ({ source: n }) => {
        n === "gridInitializing" && (e(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnColumnsInitialised()));
      },
      rowCountReady: () => {
        t == null || t(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnRowCountReady());
      },
      firstDataRendered: () => {
        r == null || r(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnFirstDataRendered());
      }
    });
  }
  getState() {
    return this.staleStateKeys.size && this.refreshStaleState(), this.cachedState;
  }
  setupStateOnGridReady() {
    this.updateCachedState("sideBar", this.getSideBarState());
    const e = () => this.updateCachedState("sideBar", this.getSideBarState());
    this.addManagedEventListeners({
      toolPanelVisibleChanged: e,
      sideBarUpdated: e
    });
  }
  setupStateOnColumnsInitialised() {
    const e = this.gos.get("initialState") ?? {};
    this.setColumnState(e), this.setColumnGroupState(e), this.updateColumnState([
      "aggregation",
      "columnOrder",
      "columnPinning",
      "columnSizing",
      "columnVisibility",
      "pivot",
      "pivot",
      "rowGroup",
      "sort"
    ]), this.updateCachedState("columnGroup", this.getColumnGroupState()), this.addManagedEventListeners({
      columnValueChanged: () => this.updateColumnState(["aggregation"]),
      columnMoved: () => this.updateColumnState(["columnOrder"]),
      columnPinned: () => this.updateColumnState(["columnPinning"]),
      columnResized: () => this.updateColumnState(["columnSizing"]),
      columnVisible: () => this.updateColumnState(["columnVisibility"]),
      columnPivotChanged: () => this.updateColumnState(["pivot"]),
      columnPivotModeChanged: () => this.updateColumnState(["pivot"]),
      columnRowGroupChanged: () => this.updateColumnState(["rowGroup"]),
      sortChanged: () => this.updateColumnState(["sort"]),
      newColumnsLoaded: () => this.updateColumnState([
        "aggregation",
        "columnOrder",
        "columnPinning",
        "columnSizing",
        "columnVisibility",
        "pivot",
        "rowGroup",
        "sort"
      ]),
      columnGroupOpened: () => this.updateCachedState("columnGroup", this.getColumnGroupState())
    });
  }
  setupStateOnRowCountReady() {
    const {
      filter: e,
      rowGroupExpansion: t,
      rowSelection: r,
      pagination: n
    } = this.gos.get("initialState") ?? {}, i = this.gos.get("advancedFilterModel");
    (e || i) && this.setFilterState(e, i), t && this.setRowGroupExpansionState(t), r && this.setRowSelectionState(r), n && this.setPaginationState(n), this.updateCachedState("filter", this.getFilterState()), this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), this.updateCachedState("rowSelection", this.getRowSelectionState()), this.updateCachedState("pagination", this.getPaginationState()), this.addManagedEventListeners({
      filterChanged: () => this.updateCachedState("filter", this.getFilterState()),
      rowGroupOpened: () => this.onRowGroupOpenedDebounced(),
      expandOrCollapseAll: () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()),
      selectionChanged: () => {
        this.staleStateKeys.add("rowSelection"), this.onRowSelectedDebounced();
      },
      paginationChanged: (o) => {
        (o.newPage || o.newPageSize) && this.updateCachedState("pagination", this.getPaginationState());
      }
    });
  }
  setupStateOnFirstDataRendered() {
    const {
      scroll: e,
      rangeSelection: t,
      focusedCell: r,
      columnOrder: n
    } = this.gos.get("initialState") ?? {};
    r && this.setFocusedCellState(r), t && this.setRangeSelectionState(t), e && this.setScrollState(e), this.setColumnPivotState(!!(n != null && n.orderedColIds)), this.updateCachedState("sideBar", this.getSideBarState()), this.updateCachedState("focusedCell", this.getFocusedCellState()), this.updateCachedState("rangeSelection", this.getRangeSelectionState()), this.updateCachedState("scroll", this.getScrollState()), this.addManagedEventListeners({
      cellFocused: () => this.updateCachedState("focusedCell", this.getFocusedCellState()),
      rangeSelectionChanged: (i) => {
        i.finished && this.updateCachedState("rangeSelection", this.getRangeSelectionState());
      },
      bodyScrollEnd: () => this.updateCachedState("scroll", this.getScrollState())
    });
  }
  getColumnState() {
    const e = this.columnModel.isPivotMode(), t = [], r = [], n = [], i = [], o = [], a = [], s = [], l = [], u = [], c = this.columnGetStateService.getColumnState();
    for (let d = 0; d < c.length; d++) {
      const {
        colId: h,
        sort: f,
        sortIndex: p,
        rowGroup: g,
        rowGroupIndex: v,
        aggFunc: m,
        pivot: y,
        pivotIndex: C,
        pinned: S,
        hide: b,
        width: w,
        flex: x
      } = c[d];
      u.push(h), f && (t[p ?? 0] = { colId: h, sort: f }), g && (r[v ?? 0] = h), typeof m == "string" && n.push({ colId: h, aggFunc: m }), y && (i[C ?? 0] = h), S && (S === "right" ? a : o).push(h), b && s.push(h), (x || w) && l.push({ colId: h, flex: x ?? void 0, width: w });
    }
    return {
      sort: t.length ? { sortModel: t } : void 0,
      rowGroup: r.length ? { groupColIds: r } : void 0,
      aggregation: n.length ? { aggregationModel: n } : void 0,
      pivot: i.length || e ? { pivotMode: e, pivotColIds: i } : void 0,
      columnPinning: o.length || a.length ? { leftColIds: o, rightColIds: a } : void 0,
      columnVisibility: s.length ? { hiddenColIds: s } : void 0,
      columnSizing: l.length ? { columnSizingModel: l } : void 0,
      columnOrder: u.length ? { orderedColIds: u } : void 0
    };
  }
  setColumnState(e) {
    const {
      sort: t,
      rowGroup: r,
      aggregation: n,
      pivot: i,
      columnPinning: o,
      columnVisibility: a,
      columnSizing: s,
      columnOrder: l
    } = e, u = {}, c = (p) => {
      let g = u[p];
      return g || (g = { colId: p }, u[p] = g, g);
    };
    t && t.sortModel.forEach(({ colId: p, sort: g }, v) => {
      const m = c(p);
      m.sort = g, m.sortIndex = v;
    }), r && r.groupColIds.forEach((p, g) => {
      const v = c(p);
      v.rowGroup = !0, v.rowGroupIndex = g;
    }), n && n.aggregationModel.forEach(({ colId: p, aggFunc: g }) => {
      c(p).aggFunc = g;
    }), i && (i.pivotColIds.forEach((p, g) => {
      const v = c(p);
      v.pivot = !0, v.pivotIndex = g;
    }), this.gos.updateGridOptions({
      options: { pivotMode: i.pivotMode },
      source: "gridInitializing"
    })), o && (o.leftColIds.forEach((p) => {
      c(p).pinned = "left";
    }), o.rightColIds.forEach((p) => {
      c(p).pinned = "right";
    })), a && a.hiddenColIds.forEach((p) => {
      c(p).hide = !0;
    }), s && s.columnSizingModel.forEach(({ colId: p, flex: g, width: v }) => {
      const m = c(p);
      m.flex = g ?? null, m.width = v;
    });
    const d = l == null ? void 0 : l.orderedColIds, h = !!(d != null && d.length), f = h ? d.map((p) => c(p)) : Object.values(u);
    if (f.length) {
      this.columnStates = f;
      const p = {
        sort: null,
        sortIndex: null,
        rowGroup: null,
        rowGroupIndex: null,
        aggFunc: null,
        pivot: null,
        pivotIndex: null,
        pinned: null,
        hide: null,
        flex: null
      };
      this.columnApplyStateService.applyColumnState(
        {
          state: f,
          applyOrder: h,
          defaultState: p
        },
        "gridInitializing"
      );
    }
  }
  setColumnPivotState(e) {
    const t = this.columnStates;
    this.columnStates = void 0;
    const r = this.columnGroupStates;
    if (this.columnGroupStates = void 0, !!this.pivotResultColsService.isPivotResultColsPresent()) {
      if (t) {
        const n = [];
        for (const i of t)
          this.pivotResultColsService.getPivotResultCol(i.colId) && n.push(i);
        this.columnApplyStateService.applyColumnState(
          {
            state: n,
            applyOrder: e
          },
          "gridInitializing"
        );
      }
      r && this.columnGroupStateService.setColumnGroupState(r, "gridInitializing");
    }
  }
  getColumnGroupState() {
    const e = this.columnGroupStateService.getColumnGroupState(), t = [];
    return e.forEach(({ groupId: r, open: n }) => {
      n && t.push(r);
    }), t.length ? { openColumnGroupIds: t } : void 0;
  }
  setColumnGroupState(e) {
    var i;
    if (!Object.prototype.hasOwnProperty.call(e, "columnGroup"))
      return;
    const t = new Set((i = e.columnGroup) == null ? void 0 : i.openColumnGroupIds), n = this.columnGroupStateService.getColumnGroupState().map(({ groupId: o }) => {
      const a = t.has(o);
      return a && t.delete(o), {
        groupId: o,
        open: a
      };
    });
    t.forEach((o) => {
      n.push({
        groupId: o,
        open: !0
      });
    }), n.length && (this.columnGroupStates = n), this.columnGroupStateService.setColumnGroupState(n, "gridInitializing");
  }
  getFilterState() {
    var r, n;
    let e = (r = this.filterManager) == null ? void 0 : r.getFilterModel();
    e && Object.keys(e).length === 0 && (e = void 0);
    const t = ((n = this.filterManager) == null ? void 0 : n.getAdvancedFilterModel()) ?? void 0;
    return e || t ? { filterModel: e, advancedFilterModel: t } : void 0;
  }
  setFilterState(e, t) {
    var i, o;
    const { filterModel: r, advancedFilterModel: n } = e ?? {
      advancedFilterModel: t
    };
    r && ((i = this.filterManager) == null || i.setFilterModel(r, "columnFilter")), n && ((o = this.filterManager) == null || o.setAdvancedFilterModel(n));
  }
  getRangeSelectionState() {
    var t;
    const e = (t = this.rangeService) == null ? void 0 : t.getCellRanges().map((r) => {
      const { id: n, type: i, startRow: o, endRow: a, columns: s, startColumn: l } = r;
      return {
        id: n,
        type: i,
        startRow: o,
        endRow: a,
        colIds: s.map((u) => u.getColId()),
        startColId: l.getColId()
      };
    });
    return e != null && e.length ? { cellRanges: e } : void 0;
  }
  setRangeSelectionState(e) {
    if (!this.gos.get("enableRangeSelection") || !this.rangeService)
      return;
    const t = [];
    e.cellRanges.forEach((r) => {
      const n = [];
      if (r.colIds.forEach((o) => {
        const a = this.columnModel.getCol(o);
        a && n.push(a);
      }), !n.length)
        return;
      let i = this.columnModel.getCol(r.startColId);
      if (!i) {
        const o = this.visibleColsService.getAllCols(), a = new Set(n);
        i = o.find((s) => a.has(s));
      }
      t.push({
        ...r,
        columns: n,
        startColumn: i
      });
    }), this.rangeService.setCellRanges(t);
  }
  getScrollState() {
    var n;
    if (!this.isClientSideRowModel)
      return;
    const e = (n = this.ctrlsService.getGridBodyCtrl()) == null ? void 0 : n.getScrollFeature(), { left: t } = (e == null ? void 0 : e.getHScrollPosition()) ?? { left: 0 }, { top: r } = (e == null ? void 0 : e.getVScrollPosition()) ?? { top: 0 };
    return r || t ? {
      top: r,
      left: t
    } : void 0;
  }
  setScrollState(e) {
    var n;
    if (!this.isClientSideRowModel)
      return;
    const { top: t, left: r } = e;
    (n = this.ctrlsService.getGridBodyCtrl()) == null || n.getScrollFeature().setScrollPosition(t, r);
  }
  getSideBarState() {
    var e, t;
    return (t = (e = this.sideBarService) == null ? void 0 : e.getSideBarComp()) == null ? void 0 : t.getState();
  }
  getFocusedCellState() {
    if (!this.isClientSideRowModel)
      return;
    const e = this.focusService.getFocusedCell();
    if (e) {
      const { column: t, rowIndex: r, rowPinned: n } = e;
      return {
        colId: t.getColId(),
        rowIndex: r,
        rowPinned: n
      };
    }
  }
  setFocusedCellState(e) {
    if (!this.isClientSideRowModel)
      return;
    const { colId: t, rowIndex: r, rowPinned: n } = e;
    this.focusService.setFocusedCell({
      column: this.columnModel.getCol(t),
      rowIndex: r,
      rowPinned: n,
      forceBrowserFocus: !0,
      preventScrollOnBrowserFocus: !0
    });
  }
  getPaginationState() {
    if (!this.paginationService)
      return;
    const e = this.paginationService.getCurrentPage(), t = this.gos.get("paginationAutoPageSize") ? void 0 : this.paginationService.getPageSize();
    if (!(!e && !t))
      return { page: e, pageSize: t };
  }
  setPaginationState(e) {
    this.paginationService && (e.pageSize && !this.gos.get("paginationAutoPageSize") && this.paginationService.setPageSize(e.pageSize, "initialState"), typeof e.page == "number" && this.paginationService.setPage(e.page));
  }
  getRowSelectionState() {
    var r;
    const e = this.selectionService.getSelectionState();
    return !e || !Array.isArray(e) && (e.selectAll === !1 || e.selectAllChildren === !1) && !((r = e == null ? void 0 : e.toggledNodes) != null && r.length) ? void 0 : e;
  }
  setRowSelectionState(e) {
    this.selectionService.setSelectionState(e, "gridInitializing");
  }
  getRowGroupExpansionState() {
    const e = this.expansionService.getExpandedRows();
    return e.length ? {
      expandedRowGroupIds: e
    } : void 0;
  }
  setRowGroupExpansionState(e) {
    this.expansionService.expandRows(e.expandedRowGroupIds);
  }
  updateColumnState(e) {
    const t = this.getColumnState();
    let r = !1;
    Object.entries(t).forEach(([n, i]) => {
      JC(i, this.cachedState[n]) || (r = !0);
    }), this.cachedState = {
      ...this.cachedState,
      ...t
    }, r && this.dispatchStateUpdateEvent(e);
  }
  updateCachedState(e, t) {
    const r = this.cachedState[e];
    this.setCachedStateValue(e, t), JC(t, r) || this.dispatchStateUpdateEvent([e]);
  }
  setCachedStateValue(e, t) {
    this.cachedState = {
      ...this.cachedState,
      [e]: t
    };
  }
  refreshStaleState() {
    this.staleStateKeys.forEach((e) => {
      switch (e) {
        case "rowSelection":
          this.setCachedStateValue(e, this.getRowSelectionState());
          break;
      }
    }), this.staleStateKeys.clear();
  }
  dispatchStateUpdateEvent(e) {
    this.suppressEvents || (e.forEach((t) => this.queuedUpdateSources.add(t)), this.dispatchStateUpdateEventDebounced());
  }
  dispatchQueuedStateUpdateEvents() {
    const e = Array.from(this.queuedUpdateSources);
    this.queuedUpdateSources.clear();
    const t = {
      type: "stateUpdated",
      sources: e,
      state: this.cachedState
    };
    this.eventService.dispatchEvent(t);
  }
  suppressEventsAndDispatchInitEvent(e) {
    this.suppressEvents = !0, this.columnAnimationService.setSuppressAnimation(!0), e(), setTimeout(() => {
      this.suppressEvents = !1, this.queuedUpdateSources.clear(), this.isAlive() && (this.columnAnimationService.setSuppressAnimation(!1), this.dispatchStateUpdateEvent(["gridInitializing"]));
    });
  }
}, aX = {
  version: kt,
  moduleName: "@ag-grid-community/state-core",
  beans: [l3e]
}, u3e = {
  version: kt,
  moduleName: "@ag-grid-community/state-api",
  apiFunctions: {
    getState: s3e
  },
  dependantModules: [aX]
}, c3e = {
  version: kt,
  moduleName: "@ag-grid-community/state",
  dependantModules: [aX, u3e]
};
function d3e(e) {
  return e.rowModel.isLastRowIndexKnown();
}
function h3e(e) {
  var t;
  return ((t = e.paginationService) == null ? void 0 : t.getPageSize()) ?? 100;
}
function f3e(e) {
  var t;
  return ((t = e.paginationService) == null ? void 0 : t.getCurrentPage()) ?? 0;
}
function p3e(e) {
  var t;
  return ((t = e.paginationService) == null ? void 0 : t.getTotalPages()) ?? 1;
}
function g3e(e) {
  return e.paginationService ? e.paginationService.getMasterRowCount() : e.rowModel.getRowCount();
}
function v3e(e) {
  var t;
  (t = e.paginationService) == null || t.goToNextPage();
}
function m3e(e) {
  var t;
  (t = e.paginationService) == null || t.goToPreviousPage();
}
function y3e(e) {
  var t;
  (t = e.paginationService) == null || t.goToFirstPage();
}
function C3e(e) {
  var t;
  (t = e.paginationService) == null || t.goToLastPage();
}
function S3e(e, t) {
  var r;
  (r = e.paginationService) == null || r.goToPage(t);
}
var w3e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "paginationAutoPageSizeService";
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.paginationService = e.paginationService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.centerRowsCtrl = e.center;
      const t = this.checkPageSize.bind(this);
      this.addManagedEventListeners({
        bodyHeightChanged: t,
        scrollVisibilityChanged: t
      }), this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this)), this.checkPageSize();
    });
  }
  notActive() {
    return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
  }
  onPaginationAutoSizeChanged() {
    this.notActive() ? this.paginationService.unsetAutoCalculatedPageSize() : this.checkPageSize();
  }
  checkPageSize() {
    if (this.notActive())
      return;
    const e = this.centerRowsCtrl.getViewportSizeFeature().getBodyHeight();
    if (e > 0) {
      const t = () => {
        const r = Math.max(this.gos.getRowHeightAsNumber(), 1), n = Math.floor(e / r);
        this.paginationService.setPageSize(n, "autoCalculated");
      };
      this.isBodyRendered ? Ti(() => t(), 50)() : (t(), this.isBodyRendered = !0);
    } else
      this.isBodyRendered = !1;
  }
};
function b3e(e, t, r) {
  e.addManagedElementListeners(t, {
    keydown: (n) => {
      if (!n.defaultPrevented && n.key === pe.TAB) {
        const i = n.shiftKey;
        r.findNextFocusableElement(t, !1, i) || r.focusNextGridCoreContainer(i) && n.preventDefault();
      }
    }
  });
}
var x3e = class extends tn {
  constructor() {
    super(
      /* html */
      '<span class="ag-paging-page-size"></span>'
    ), this.hasEmptyOption = !1, this.handlePageSizeItemSelected = () => {
      if (!this.selectPageSizeComp)
        return;
      const e = this.selectPageSizeComp.getValue();
      if (!e)
        return;
      const t = Number(e);
      isNaN(t) || t < 1 || t === this.paginationService.getPageSize() || (this.paginationService.setPageSize(t, "pageSizeSelector"), this.hasEmptyOption && this.toggleSelectDisplay(!0), this.selectPageSizeComp.getFocusableElement().focus());
    };
  }
  wireBeans(e) {
    this.paginationService = e.paginationService;
  }
  postConstruct() {
    this.addManagedPropertyListener("paginationPageSizeSelector", () => {
      this.onPageSizeSelectorValuesChange();
    }), this.addManagedEventListeners({ paginationChanged: (e) => this.handlePaginationChanged(e) });
  }
  handlePaginationChanged(e) {
    if (!this.selectPageSizeComp || !(e != null && e.newPageSize))
      return;
    const t = this.paginationService.getPageSize();
    this.getPageSizeSelectorValues().includes(t) ? this.selectPageSizeComp.setValue(t.toString()) : this.hasEmptyOption ? this.selectPageSizeComp.setValue("") : this.toggleSelectDisplay(!0);
  }
  toggleSelectDisplay(e) {
    this.selectPageSizeComp && this.reset(), e && (this.reloadPageSizesSelector(), this.selectPageSizeComp && this.appendChild(this.selectPageSizeComp));
  }
  reset() {
    xo(this.getGui()), this.selectPageSizeComp && (this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp));
  }
  onPageSizeSelectorValuesChange() {
    this.selectPageSizeComp && this.shouldShowPageSizeSelector() && this.reloadPageSizesSelector();
  }
  shouldShowPageSizeSelector() {
    return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get("paginationPageSizeSelector") !== !1;
  }
  reloadPageSizesSelector() {
    const e = this.getPageSizeSelectorValues(), t = this.paginationService.getPageSize(), r = !t || !e.includes(t);
    r && (e.unshift(""), Te(
      `The paginationPageSize grid option is set to a value that is not in the list of page size options.
                Please make sure that the paginationPageSize grid option is set to one of the values in the 
                paginationPageSizeSelector array, or set the paginationPageSizeSelector to false to hide the page size selector.`
    )), this.selectPageSizeComp && (this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp));
    const n = this.localeService.getLocaleTextFunc(), i = n("pageSizeSelectorLabel", "Page Size:"), o = e.map((s) => ({
      value: String(s),
      text: String(s)
    })), a = n("ariaPageSizeSelectorLabel", "Page Size");
    this.selectPageSizeComp = this.createManagedBean(new vI()).addOptions(o).setValue(String(r ? "" : t)).setAriaLabel(a).setLabel(i).onValueChange(() => this.handlePageSizeItemSelected()), this.hasEmptyOption = r;
  }
  getPageSizeSelectorValues() {
    const e = [20, 50, 100], t = this.gos.get("paginationPageSizeSelector");
    return !Array.isArray(t) || !this.validateValues(t) ? e : [...t].sort((r, n) => r - n);
  }
  validateValues(e) {
    if (!e.length)
      return Te(
        `The paginationPageSizeSelector grid option is an empty array. This is most likely a mistake.
                If you want to hide the page size selector, please set the paginationPageSizeSelector to false.`
      ), !1;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], n = typeof r == "number", i = r > 0;
      if (!n)
        return Te(
          `The paginationPageSizeSelector grid option contains a non-numeric value.
                    Please make sure that all values in the paginationPageSizeSelector array are numbers.`
        ), !1;
      if (!i)
        return Te(
          `The paginationPageSizeSelector grid option contains a negative number or zero.
                    Please make sure that all values in the paginationPageSizeSelector array are positive.`
        ), !1;
    }
    return !0;
  }
  destroy() {
    this.toggleSelectDisplay(!1), super.destroy();
  }
}, E3e = {
  selector: "AG-PAGE-SIZE-SELECTOR",
  component: x3e
}, R3e = class extends vze {
  constructor() {
    super(), this.btFirst = Pt, this.btPrevious = Pt, this.btNext = Pt, this.btLast = Pt, this.lbRecordCount = Pt, this.lbFirstRowOnPage = Pt, this.lbLastRowOnPage = Pt, this.lbCurrent = Pt, this.lbTotal = Pt, this.pageSizeComp = Pt, this.previousAndFirstButtonsDisabled = !1, this.nextButtonDisabled = !1, this.lastButtonDisabled = !1, this.areListenersSetup = !1, this.allowFocusInnerElement = !1;
  }
  wireBeans(e) {
    this.rowNodeBlockLoader = e.rowNodeBlockLoader, this.rowModel = e.rowModel, this.paginationService = e.paginationService, this.focusService = e.focusService;
  }
  postConstruct() {
    const e = this.gos.get("enableRtl");
    this.setTemplate(this.getTemplate(), [E3e]);
    const { btFirst: t, btPrevious: r, btNext: n, btLast: i } = this;
    this.activateTabIndex([t, r, n, i]), t.insertAdjacentElement("afterbegin", yo(e ? "last" : "first", this.gos)), r.insertAdjacentElement("afterbegin", yo(e ? "next" : "previous", this.gos)), n.insertAdjacentElement("afterbegin", yo(e ? "previous" : "next", this.gos)), i.insertAdjacentElement("afterbegin", yo(e ? "first" : "last", this.gos)), this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this)), this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this)), this.addManagedPropertyListeners(
      ["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"],
      () => this.onPageSizeRelatedOptionsChange()
    ), this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector()), this.initialiseTabGuard({
      // prevent tab guard default logic
      onTabKeyDown: () => {
      },
      focusInnerElement: (o) => {
        this.allowFocusInnerElement ? this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(o) : this.focusService.focusGridInnerElement(o);
      },
      forceFocusOutWhenTabGuardsAreEmpty: !0
    }), this.onPaginationChanged();
  }
  setAllowFocus(e) {
    this.allowFocusInnerElement = e;
  }
  onPaginationChanged() {
    const t = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.setDisplayed(t), t && (this.setupListeners(), this.enableOrDisableButtons(), this.updateRowLabels(), this.setCurrentPageLabel(), this.setTotalLabels(), this.onPageSizeRelatedOptionsChange());
  }
  onPageSizeRelatedOptionsChange() {
    this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
  }
  setupListeners() {
    this.areListenersSetup || (this.addManagedEventListeners({ paginationChanged: this.onPaginationChanged.bind(this) }), [
      { el: this.btFirst, fn: this.onBtFirst.bind(this) },
      { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
      { el: this.btNext, fn: this.onBtNext.bind(this) },
      { el: this.btLast, fn: this.onBtLast.bind(this) }
    ].forEach((e) => {
      const { el: t, fn: r } = e;
      this.addManagedListeners(t, {
        click: r,
        keydown: (n) => {
          (n.key === pe.ENTER || n.key === pe.SPACE) && (n.preventDefault(), r());
        }
      });
    }), b3e(this, this.getGui(), this.focusService), this.areListenersSetup = !0);
  }
  onBtFirst() {
    this.previousAndFirstButtonsDisabled || this.paginationService.goToFirstPage();
  }
  setCurrentPageLabel() {
    const e = this.paginationService.getTotalPages() > 0, t = this.paginationService.getCurrentPage(), r = e ? t + 1 : 0;
    this.lbCurrent.textContent = this.formatNumber(r);
  }
  formatNumber(e) {
    const t = this.gos.getCallback("paginationNumberFormatter");
    if (t)
      return t({ value: e });
    const r = this.localeService.getLocaleTextFunc(), n = r("thousandSeparator", ","), i = r("decimalSeparator", ".");
    return p$e(e, n, i);
  }
  getTemplate() {
    const e = this.localeService.getLocaleTextFunc(), t = e("page", "Page"), r = e("to", "to"), n = e("of", "of"), i = e("firstPage", "First Page"), o = e("previousPage", "Previous Page"), a = e("nextPage", "Next Page"), s = e("lastPage", "Last Page"), l = this.getCompId();
    return (
      /* html */
      `<div class="ag-paging-panel ag-unselectable" id="ag-${l}">
                <ag-page-size-selector data-ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel" role="status">
                    <span id="ag-${l}-first-row" data-ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-to">${r}</span>
                    <span id="ag-${l}-last-row" data-ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-of">${n}</span>
                    <span id="ag-${l}-row-count" data-ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div data-ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${i}"></div>
                    <div data-ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${o}"></div>
                    <span class="ag-paging-description" role="status">
                        <span id="ag-${l}-start-page">${t}</span>
                        <span id="ag-${l}-start-page-number" data-ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${l}-of-page">${n}</span>
                        <span id="ag-${l}-of-page-number" data-ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div data-ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${a}"></div>
                    <div data-ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${s}"></div>
                </span>
            </div>`
    );
  }
  onBtNext() {
    this.nextButtonDisabled || this.paginationService.goToNextPage();
  }
  onBtPrevious() {
    this.previousAndFirstButtonsDisabled || this.paginationService.goToPreviousPage();
  }
  onBtLast() {
    this.lastButtonDisabled || this.paginationService.goToLastPage();
  }
  enableOrDisableButtons() {
    const e = this.paginationService.getCurrentPage(), t = this.rowModel.isLastRowIndexKnown(), r = this.paginationService.getTotalPages();
    this.previousAndFirstButtonsDisabled = e === 0, this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled), this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const n = this.isZeroPagesToDisplay(), i = e === r - 1;
    this.nextButtonDisabled = i || n, this.lastButtonDisabled = !t || n || e === r - 1, this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled), this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(e, t) {
    ABe(e, t), e.classList.toggle("ag-disabled", t);
  }
  updateRowLabels() {
    var a;
    const e = this.paginationService.getCurrentPage(), t = this.paginationService.getPageSize(), r = this.rowModel.isLastRowIndexKnown(), n = this.rowModel.isLastRowIndexKnown() ? this.paginationService.getMasterRowCount() : null;
    let i, o;
    if (this.isZeroPagesToDisplay() ? i = o = 0 : (i = t * e + 1, o = i + t - 1, r && o > n && (o = n)), this.lbFirstRowOnPage.textContent = this.formatNumber(i), (a = this.rowNodeBlockLoader) != null && a.isLoading()) {
      const s = this.localeService.getLocaleTextFunc();
      this.lbLastRowOnPage.innerHTML = s("pageLastRowUnknown", "?");
    } else
      this.lbLastRowOnPage.textContent = this.formatNumber(o);
  }
  isZeroPagesToDisplay() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.paginationService.getTotalPages();
    return e && t === 0;
  }
  setTotalLabels() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.paginationService.getTotalPages(), r = e ? this.paginationService.getMasterRowCount() : null;
    if (r === 1) {
      const n = this.rowModel.getRow(0);
      if (n && n.group && !(n.groupData || n.aggData)) {
        this.setTotalLabelsToZero();
        return;
      }
    }
    if (e)
      this.lbTotal.textContent = this.formatNumber(t), this.lbRecordCount.textContent = this.formatNumber(r);
    else {
      const n = this.localeService.getLocaleTextFunc()("more", "more");
      this.lbTotal.innerHTML = n, this.lbRecordCount.innerHTML = n;
    }
  }
  setTotalLabelsToZero() {
    this.lbFirstRowOnPage.textContent = this.formatNumber(0), this.lbCurrent.textContent = this.formatNumber(0), this.lbLastRowOnPage.textContent = this.formatNumber(0), this.lbTotal.textContent = this.formatNumber(0), this.lbRecordCount.textContent = this.formatNumber(0);
  }
}, _3e = {
  selector: "AG-PAGINATION",
  component: R3e
}, T3e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "paginationService", this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = 0, this.masterRowCount = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.active = this.gos.get("pagination"), this.pageSizeFromGridOptions = this.gos.get("paginationPageSize"), this.paginateChildRows = this.isPaginateChildRows(), this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this)), this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this));
  }
  getPaginationSelector() {
    return _3e;
  }
  isPaginateChildRows() {
    return this.gos.get("groupRemoveSingleChildren") || this.gos.get("groupRemoveLowestSingleChildren") ? !0 : this.gos.get("paginateChildRows");
  }
  onPaginationGridOptionChanged() {
    this.active = this.gos.get("pagination"), this.calculatePages(), this.dispatchPaginationChangedEvent({ keepRenderedRows: !0 });
  }
  onPageSizeGridOptionChanged() {
    this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
  }
  goToPage(e) {
    !this.active || this.currentPage === e || typeof this.currentPage != "number" || (this.currentPage = e, this.calculatePages(), this.dispatchPaginationChangedEvent({ newPage: !0 }));
  }
  isRowPresent(e) {
    return e.rowIndex >= this.topDisplayedRowIndex && e.rowIndex <= this.bottomDisplayedRowIndex;
  }
  getPageForIndex(e) {
    return Math.floor(e / this.pageSize);
  }
  goToPageWithIndex(e) {
    if (!this.active)
      return;
    const t = this.getPageForIndex(e);
    this.goToPage(t);
  }
  isRowInPage(e) {
    return this.active ? this.getPageForIndex(e.rowIndex) === this.currentPage : !0;
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const e = this.rowModel.getRowCount(), t = Math.floor(e / this.pageSize);
    this.goToPage(t);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  /** This is only for state setting before data has been loaded */
  setPage(e) {
    this.currentPage = e;
  }
  get pageSize() {
    return ke(this.pageSizeAutoCalculated) ? this.pageSizeAutoCalculated : ke(this.pageSizeFromPageSizeSelector) ? this.pageSizeFromPageSizeSelector : ke(this.pageSizeFromInitialState) ? this.pageSizeFromInitialState : ke(this.pageSizeFromGridOptions) ? this.pageSizeFromGridOptions : this.defaultPageSize;
  }
  calculatePages() {
    this.active ? this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly() : this.calculatedPagesNotActive(), this.pageBoundsService.calculateBounds(this.topDisplayedRowIndex, this.bottomDisplayedRowIndex);
  }
  unsetAutoCalculatedPageSize() {
    if (this.pageSizeAutoCalculated === void 0)
      return;
    const e = this.pageSizeAutoCalculated;
    this.pageSizeAutoCalculated = void 0, this.pageSize !== e && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0 }));
  }
  setPageSize(e, t) {
    const r = this.pageSize;
    switch (t) {
      case "autoCalculated":
        this.pageSizeAutoCalculated = e;
        break;
      case "pageSizeSelector":
        this.pageSizeFromPageSizeSelector = e, this.currentPage !== 0 && this.goToFirstPage();
        break;
      case "initialState":
        this.pageSizeFromInitialState = e;
        break;
      case "gridOptions":
        this.pageSizeFromGridOptions = e, this.pageSizeFromInitialState = void 0, this.pageSizeFromPageSizeSelector = void 0, this.currentPage !== 0 && this.goToFirstPage();
        break;
    }
    r !== this.pageSize && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0, keepRenderedRows: !0 }));
  }
  setZeroRows() {
    this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0);
  }
  calculatePagesMasterRowsOnly() {
    if (this.masterRowCount = this.rowModel.getTopLevelRowCount(), this.masterRowCount <= 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid();
    const t = this.pageSize * this.currentPage;
    let r = this.pageSize * (this.currentPage + 1) - 1;
    if (r > e && (r = e), this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(t), r === e)
      this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    else {
      const n = this.rowModel.getTopLevelRowDisplayedIndex(r + 1);
      this.bottomDisplayedRowIndex = n - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    if (this.masterRowCount = this.rowModel.getRowCount(), this.masterRowCount === 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid(), this.topDisplayedRowIndex = this.pageSize * this.currentPage, this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1, this.bottomDisplayedRowIndex > e && (this.bottomDisplayedRowIndex = e);
  }
  calculatedPagesNotActive() {
    this.setPageSize(void 0, "autoCalculated"), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
  }
  dispatchPaginationChangedEvent(e) {
    const { keepRenderedRows: t = !1, newPage: r = !1, newPageSize: n = !1 } = e, i = {
      type: "paginationChanged",
      animate: !1,
      newData: !1,
      newPage: r,
      newPageSize: n,
      keepRenderedRows: t
    };
    this.eventService.dispatchEvent(i);
  }
}, sX = {
  version: kt,
  moduleName: "@ag-grid-community/pagination-core",
  beans: [T3e, w3e]
}, P3e = {
  version: kt,
  moduleName: "@ag-grid-community/pagination-api",
  dependantModules: [sX],
  apiFunctions: {
    paginationIsLastPageFound: d3e,
    paginationGetPageSize: h3e,
    paginationGetCurrentPage: f3e,
    paginationGetTotalPages: p3e,
    paginationGetRowCount: g3e,
    paginationGoToNextPage: v3e,
    paginationGoToPreviousPage: m3e,
    paginationGoToFirstPage: y3e,
    paginationGoToLastPage: C3e,
    paginationGoToPage: S3e
  }
}, M3e = {
  version: kt,
  moduleName: "@ag-grid-community/pagination",
  dependantModules: [sX, P3e]
}, fe = "@ag-grid-community/core", Ka = "@ag-grid-community/client-side-row-model", tG = "@ag-grid-community/csv-export", $y = "@ag-grid-community/infinite-row-model", Hy = "@ag-grid-enterprise/advanced-filter", ha = "@ag-grid-enterprise/charts", eh = "@ag-grid-enterprise/clipboard", _p = "@ag-grid-enterprise/excel-export", Gy = "@ag-grid-enterprise/master-detail", ME = "@ag-grid-enterprise/menu", DE = "@ag-grid-enterprise/range-selection", qr = "@ag-grid-enterprise/row-grouping", Ds = "@ag-grid-enterprise/server-side-row-model", Ya = "@ag-grid-enterprise/side-bar", D3e = "@ag-grid-enterprise/status-bar", A3e = {
  dispatchEvent: fe,
  getState: fe,
  getGridId: fe,
  destroy: fe,
  isDestroyed: fe,
  getGridOption: fe,
  setGridOption: fe,
  updateGridOptions: fe,
  setNodesSelected: fe,
  selectAll: fe,
  deselectAll: fe,
  selectAllFiltered: fe,
  deselectAllFiltered: fe,
  selectAllOnCurrentPage: fe,
  deselectAllOnCurrentPage: fe,
  getSelectedNodes: fe,
  getSelectedRows: fe,
  redrawRows: fe,
  setRowNodeExpanded: fe,
  getRowNode: fe,
  addRenderedRowListener: fe,
  getRenderedNodes: fe,
  forEachNode: fe,
  getFirstDisplayedRow: fe,
  getFirstDisplayedRowIndex: fe,
  getLastDisplayedRow: fe,
  getLastDisplayedRowIndex: fe,
  getDisplayedRowAtIndex: fe,
  getDisplayedRowCount: fe,
  getModel: fe,
  getVerticalPixelRange: fe,
  getHorizontalPixelRange: fe,
  ensureColumnVisible: fe,
  ensureIndexVisible: fe,
  ensureNodeVisible: fe,
  getFocusedCell: fe,
  clearFocusedCell: fe,
  setFocusedCell: fe,
  tabToNextCell: fe,
  tabToPreviousCell: fe,
  setFocusedHeader: fe,
  addEventListener: fe,
  addGlobalListener: fe,
  removeEventListener: fe,
  removeGlobalListener: fe,
  expireValueCache: fe,
  getValue: fe,
  getCellValue: fe,
  showColumnMenuAfterButtonClick: fe,
  showColumnMenuAfterMouseClick: fe,
  showColumnMenu: fe,
  hidePopupMenu: fe,
  onSortChanged: fe,
  getPinnedTopRowCount: fe,
  getPinnedBottomRowCount: fe,
  getPinnedTopRow: fe,
  getPinnedBottomRow: fe,
  showLoadingOverlay: fe,
  showNoRowsOverlay: fe,
  hideOverlay: fe,
  setGridAriaProperty: fe,
  refreshCells: fe,
  flashCells: fe,
  refreshHeader: fe,
  isAnimationFrameQueueEmpty: fe,
  flushAllAnimationFrames: fe,
  getSizesForCurrentTheme: fe,
  getCellRendererInstances: fe,
  addRowDropZone: fe,
  removeRowDropZone: fe,
  getRowDropZoneParams: fe,
  getColumnDef: fe,
  getColumnDefs: fe,
  sizeColumnsToFit: fe,
  setColumnGroupOpened: fe,
  getColumnGroup: fe,
  getProvidedColumnGroup: fe,
  getDisplayNameForColumn: fe,
  getDisplayNameForColumnGroup: fe,
  getColumn: fe,
  getColumns: fe,
  applyColumnState: fe,
  getColumnState: fe,
  resetColumnState: fe,
  getColumnGroupState: fe,
  setColumnGroupState: fe,
  resetColumnGroupState: fe,
  isPinning: fe,
  isPinningLeft: fe,
  isPinningRight: fe,
  getDisplayedColAfter: fe,
  getDisplayedColBefore: fe,
  setColumnVisible: fe,
  setColumnsVisible: fe,
  setColumnPinned: fe,
  setColumnsPinned: fe,
  getAllGridColumns: fe,
  getDisplayedLeftColumns: fe,
  getDisplayedCenterColumns: fe,
  getDisplayedRightColumns: fe,
  getAllDisplayedColumns: fe,
  getAllDisplayedVirtualColumns: fe,
  moveColumn: fe,
  moveColumnByIndex: fe,
  moveColumns: fe,
  setColumnWidth: fe,
  setColumnWidths: fe,
  getLeftDisplayedColumnGroups: fe,
  getCenterDisplayedColumnGroups: fe,
  getRightDisplayedColumnGroups: fe,
  getAllDisplayedColumnGroups: fe,
  autoSizeColumn: fe,
  autoSizeColumns: fe,
  autoSizeAllColumns: fe,
  undoCellEditing: fe,
  redoCellEditing: fe,
  getCellEditorInstances: fe,
  getEditingCells: fe,
  stopEditing: fe,
  startEditingCell: fe,
  getCurrentUndoSize: fe,
  getCurrentRedoSize: fe,
  isAnyFilterPresent: fe,
  onFilterChanged: fe,
  isColumnFilterPresent: fe,
  getFilterInstance: fe,
  getColumnFilterInstance: fe,
  destroyFilter: fe,
  setFilterModel: fe,
  getFilterModel: fe,
  getColumnFilterModel: fe,
  setColumnFilterModel: fe,
  showColumnFilter: fe,
  isQuickFilterPresent: fe,
  getQuickFilter: fe,
  resetQuickFilter: fe,
  paginationIsLastPageFound: fe,
  paginationGetPageSize: fe,
  paginationGetCurrentPage: fe,
  paginationGetTotalPages: fe,
  paginationGetRowCount: fe,
  paginationGoToNextPage: fe,
  paginationGoToPreviousPage: fe,
  paginationGoToFirstPage: fe,
  paginationGoToLastPage: fe,
  paginationGoToPage: fe,
  // These may need updating to say which of multiple possible modules they could be missing from.
  expandAll: fe,
  collapseAll: fe,
  onRowHeightChanged: fe,
  setRowCount: fe,
  getCacheBlockState: fe,
  onGroupExpandedOrCollapsed: Ka,
  refreshClientSideRowModel: Ka,
  forEachLeafNode: Ka,
  forEachNodeAfterFilter: Ka,
  forEachNodeAfterFilterAndSort: Ka,
  resetRowHeights: Ka,
  applyTransaction: Ka,
  applyTransactionAsync: Ka,
  flushAsyncTransactions: Ka,
  getBestCostNodeSelection: Ka,
  getDataAsCsv: tG,
  exportDataAsCsv: tG,
  refreshInfiniteCache: $y,
  purgeInfiniteCache: $y,
  getInfiniteRowCount: $y,
  isLastRowIndexKnown: $y,
  getAdvancedFilterModel: Hy,
  setAdvancedFilterModel: Hy,
  showAdvancedFilterBuilder: Hy,
  hideAdvancedFilterBuilder: Hy,
  getChartModels: ha,
  getChartRef: ha,
  getChartImageDataURL: ha,
  downloadChart: ha,
  openChartToolPanel: ha,
  closeChartToolPanel: ha,
  createRangeChart: ha,
  createPivotChart: ha,
  createCrossFilterChart: ha,
  updateChart: ha,
  restoreChart: ha,
  copyToClipboard: eh,
  cutToClipboard: eh,
  copySelectedRowsToClipboard: eh,
  copySelectedRangeToClipboard: eh,
  copySelectedRangeDown: eh,
  pasteFromClipboard: eh,
  getDataAsExcel: _p,
  exportDataAsExcel: _p,
  getSheetDataForExcel: _p,
  getMultipleSheetsAsExcel: _p,
  exportMultipleSheetsAsExcel: _p,
  addDetailGridInfo: Gy,
  removeDetailGridInfo: Gy,
  getDetailGridInfo: Gy,
  forEachDetailGridInfo: Gy,
  showContextMenu: ME,
  showColumnChooser: ME,
  hideColumnChooser: ME,
  getCellRanges: DE,
  addCellRange: DE,
  clearRangeSelection: DE,
  addAggFunc: qr,
  addAggFuncs: qr,
  clearAggFuncs: qr,
  setColumnAggFunc: qr,
  isPivotMode: qr,
  getPivotResultColumn: qr,
  setValueColumns: qr,
  getValueColumns: qr,
  removeValueColumn: qr,
  removeValueColumns: qr,
  addValueColumn: qr,
  addValueColumns: qr,
  setRowGroupColumns: qr,
  removeRowGroupColumn: qr,
  removeRowGroupColumns: qr,
  addRowGroupColumn: qr,
  addRowGroupColumns: qr,
  getRowGroupColumns: qr,
  moveRowGroupColumn: qr,
  setPivotColumns: qr,
  removePivotColumn: qr,
  removePivotColumns: qr,
  addPivotColumn: qr,
  addPivotColumns: qr,
  getPivotColumns: qr,
  setPivotResultColumns: qr,
  getPivotResultColumns: qr,
  getServerSideSelectionState: Ds,
  setServerSideSelectionState: Ds,
  applyServerSideTransaction: Ds,
  applyServerSideTransactionAsync: Ds,
  applyServerSideRowData: Ds,
  retryServerSideLoads: Ds,
  flushServerSideAsyncTransactions: Ds,
  refreshServerSide: Ds,
  getServerSideGroupLevelState: Ds,
  isSideBarVisible: Ya,
  setSideBarVisible: Ya,
  setSideBarPosition: Ya,
  openToolPanel: Ya,
  closeToolPanel: Ya,
  getOpenedToolPanel: Ya,
  refreshToolPanel: Ya,
  isToolPanelShowing: Ya,
  getToolPanelInstance: Ya,
  getSideBar: Ya,
  getStatusPanel: D3e
}, ao = "clientSide", zi = "serverSide", th = "infinite", I3e = {
  onGroupExpandedOrCollapsed: [ao],
  refreshClientSideRowModel: [ao],
  forEachLeafNode: [ao],
  forEachNodeAfterFilter: [ao],
  forEachNodeAfterFilterAndSort: [ao],
  resetRowHeights: [ao],
  applyTransaction: [ao],
  applyTransactionAsync: [ao],
  flushAsyncTransactions: [ao],
  getBestCostNodeSelection: [ao],
  getServerSideSelectionState: [zi],
  setServerSideSelectionState: [zi],
  applyServerSideTransaction: [zi],
  applyServerSideTransactionAsync: [zi],
  applyServerSideRowData: [zi],
  retryServerSideLoads: [zi],
  flushServerSideAsyncTransactions: [zi],
  refreshServerSide: [zi],
  getServerSideGroupLevelState: [zi],
  refreshInfiniteCache: [th],
  purgeInfiniteCache: [th],
  getInfiniteRowCount: [th],
  isLastRowIndexKnown: [th],
  expandAll: [ao, zi],
  collapseAll: [ao, zi],
  onRowHeightChanged: [ao, zi],
  setRowCount: [th, zi],
  getCacheBlockState: [th, zi]
}, O3e = {
  getValue: {
    version: "v31.3",
    new: "getCellValue"
  },
  getFirstDisplayedRow: {
    version: "v31.1",
    new: "getFirstDisplayedRowIndex"
  },
  getLastDisplayedRow: {
    version: "v31.1",
    new: "getLastDisplayedRowIndex"
  },
  getModel: {
    version: "v31.1",
    message: "Please use the appropriate grid API methods instead."
  },
  setColumnVisible: {
    version: "v31.1",
    old: "setColumnVisible(key,visible)",
    new: "setColumnsVisible([key],visible)"
  },
  setColumnPinned: {
    version: "v31.1",
    old: "setColumnPinned(key,pinned)",
    new: "setColumnsPinned([key],pinned)"
  },
  moveColumn: {
    version: "v31.1",
    old: "moveColumn(key, toIndex)",
    new: "moveColumns([key], toIndex)"
  },
  setColumnWidth: {
    version: "v31.1",
    old: "setColumnWidth(col, width)",
    new: "setColumnWidths([{key: col, newWidth: width}])"
  },
  autoSizeColumn: {
    version: "v31.1",
    old: "autoSizeColumn(key, skipHeader)",
    new: "autoSizeColumns([key], skipHeader)"
  },
  addAggFunc: {
    version: "v31.1",
    old: "addAggFunc(key, func)",
    new: "addAggFuncs({ key: func })"
  },
  removeValueColumn: {
    version: "v31.1",
    old: "removeValueColumn(colKey)",
    new: "removeValueColumns([colKey])"
  },
  addValueColumn: {
    version: "v31.1",
    old: "addValueColumn(colKey)",
    new: "addValueColumns([colKey])"
  },
  removeRowGroupColumn: {
    version: "v31.1",
    old: "removeRowGroupColumn(colKey)",
    new: "removeRowGroupColumns([colKey])"
  },
  addRowGroupColumn: {
    version: "v31.1",
    old: "addRowGroupColumn(colKey)",
    new: "addRowGroupColumns([colKey])"
  },
  removePivotColumn: {
    version: "v31.1",
    old: "removePivotColumn(colKey)",
    new: "removePivotColumns([colKey])"
  },
  addPivotColumn: {
    version: "v31.1",
    old: "addPivotColumn(colKey)",
    new: "addPivotColumns([colKey])"
  },
  showColumnMenuAfterButtonClick: {
    version: "v31.1",
    message: "Use 'IHeaderParams.showColumnMenu' within a header component, or 'api.showColumnMenu' elsewhere."
  },
  showColumnMenuAfterMouseClick: {
    version: "v31.1",
    message: "Use 'IHeaderParams.showColumnMenuAfterMouseClick' within a header component, or 'api.showColumnMenu' elsewhere."
  },
  getFilterInstance: {
    version: "v31.1",
    message: "'getFilterInstance' is deprecated. To get/set individual filter models, use 'getColumnFilterModel' or 'setColumnFilterModel' instead. To get hold of the filter instance, use 'getColumnFilterInstance' which returns the instance asynchronously."
  },
  showLoadingOverlay: {
    version: "v32",
    message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).'
  }
};
function L3e(e, t) {
  const r = A3e[e];
  r ? ci.__assertRegistered(r, `api.${e}`, t) && Te(`API function '${e}' not registered to module '${r}'`) : Er(`Unknown API function: '${e}' on GridApi.`);
}
function F3e(e, t, r) {
  const n = O3e[e];
  if (n) {
    const { version: o, new: a, old: s, message: l } = n, u = s ?? e;
    return (...c) => {
      const d = a ? `Please use ${a} instead. ` : "";
      return Te(`Since ${o} api.${u} is deprecated. ${d}${l ?? ""}`), t.apply(t, c);
    };
  }
  const i = I3e[e];
  return i ? (...o) => {
    const a = r.rowModel.getType();
    if (!i.includes(a)) {
      Er(
        `api.${e} can only be called when gridOptions.rowModelType is ${i.join(" or ")}`
      );
      return;
    }
    return t.apply(t, o);
  } : t;
}
var N3e = {
  columnsMenuParams: { version: "31.1", message: "Use `columnChooserParams` instead." },
  suppressMenu: { version: "31.1", message: "Use `suppressHeaderMenuButton` instead." },
  suppressCellFlash: { version: "31.2", message: "Use `enableCellChangeFlash={false}` in the ColDef" }
}, El = (e, t) => (t.rowModelType ?? "clientSide") === "clientSide" ? {
  module: "@ag-grid-enterprise/row-grouping"
  /* RowGroupingModule */
} : null, k3e = {
  // supported on all row models, but need module for client side.
  enableRowGroup: El,
  rowGroup: El,
  rowGroupIndex: El,
  enablePivot: El,
  enableValue: El,
  pivot: El,
  pivotIndex: El,
  aggFunc: El,
  cellEditor: (e) => e.cellEditor === "agRichSelect" || e.cellEditor === "agRichSelectCellEditor" ? {
    module: "@ag-grid-enterprise/rich-select"
    /* RichSelectModule */
  } : null,
  menuTabs: (e) => {
    var r;
    const t = ["columnsMenuTab", "generalMenuTab"];
    return (r = e.menuTabs) != null && r.some((n) => t.includes(n)) ? {
      module: "@ag-grid-enterprise/menu"
      /* MenuModule */
    } : null;
  },
  columnsMenuParams: {
    module: [
      "@ag-grid-enterprise/menu",
      "@ag-grid-enterprise/column-tool-panel"
      /* ColumnsToolPanelModule */
    ]
  },
  columnChooserParams: {
    module: [
      "@ag-grid-enterprise/menu",
      "@ag-grid-enterprise/column-tool-panel"
      /* ColumnsToolPanelModule */
    ]
  },
  headerCheckboxSelection: {
    supportedRowModels: ["clientSide", "serverSide"],
    dependencies: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionFilteredOnly: {
    supportedRowModels: ["clientSide"],
    dependencies: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionCurrentPageOnly: {
    supportedRowModels: ["clientSide"],
    dependencies: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
  },
  children: () => Sh
}, V3e = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellAriaRole: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnsMenuParams: void 0,
  columnChooserParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressCellFlash: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressMenu: void 0,
  suppressHeaderMenuButton: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0,
  mainMenuItems: void 0,
  contextMenuItems: void 0,
  suppressFloatingFilterButton: void 0,
  suppressHeaderFilterButton: void 0,
  suppressHeaderContextMenu: void 0,
  loadingCellRenderer: void 0,
  loadingCellRendererParams: void 0,
  loadingCellRendererSelector: void 0,
  context: void 0
}, B3e = Object.keys(V3e), Sh = {
  objectName: "colDef",
  allProperties: B3e,
  docsUrl: "column-properties/",
  deprecations: N3e,
  validations: k3e
}, $3e = () => ({
  advancedFilterModel: { version: "31", message: "Use `initialState.filter.advancedFilterModel` instead." },
  suppressAsyncEvents: { version: "31", message: "Events should be handled asynchronously." },
  cellFadeDelay: { version: "31.1", renamed: "cellFadeDuration" },
  cellFlashDelay: { version: "31.1", renamed: "cellFlashDuration" },
  suppressServerSideInfiniteScroll: { version: "31.1" },
  serverSideSortOnServer: { version: "31.1" },
  serverSideFilterOnServer: { version: "31.1" },
  enableCellChangeFlash: {
    version: "31.2",
    message: "Use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns."
  },
  groupIncludeFooter: { version: "31.3", message: "Use `groupTotalRow` instead." },
  groupIncludeTotalFooter: { version: "31.3", message: "Use `grandTotalRow` instead." },
  suppressLoadingOverlay: { version: "32", message: "Use `loading`=false instead." }
}), H3e = {
  suppressContextMenu: !1,
  preventDefaultOnContextMenu: !1,
  allowContextMenuWithControlKey: !1,
  suppressMenuHide: !0,
  enableBrowserTooltips: !1,
  tooltipTrigger: "hover",
  tooltipShowDelay: 2e3,
  tooltipHideDelay: 1e4,
  tooltipMouseTrack: !1,
  tooltipShowMode: "standard",
  tooltipInteraction: !1,
  copyHeadersToClipboard: !1,
  copyGroupHeadersToClipboard: !1,
  clipboardDelimiter: "	",
  suppressCopyRowsToClipboard: !1,
  suppressCopySingleCellRanges: !1,
  suppressLastEmptyLineOnPaste: !1,
  suppressClipboardPaste: !1,
  suppressClipboardApi: !1,
  suppressCutToClipboard: !1,
  maintainColumnOrder: !1,
  suppressFieldDotNotation: !1,
  allowDragFromColumnsToolPanel: !1,
  suppressMovableColumns: !1,
  suppressColumnMoveAnimation: !1,
  suppressDragLeaveHidesColumns: !1,
  suppressRowGroupHidesColumns: !1,
  suppressAutoSize: !1,
  autoSizePadding: 20,
  skipHeaderOnAutoSize: !1,
  singleClickEdit: !1,
  suppressClickEdit: !1,
  readOnlyEdit: !1,
  stopEditingWhenCellsLoseFocus: !1,
  enterNavigatesVertically: !1,
  enterNavigatesVerticallyAfterEdit: !1,
  enableCellEditingOnBackspace: !1,
  undoRedoCellEditing: !1,
  undoRedoCellEditingLimit: 10,
  suppressCsvExport: !1,
  suppressExcelExport: !1,
  cacheQuickFilter: !1,
  includeHiddenColumnsInQuickFilter: !1,
  excludeChildrenWhenTreeDataFiltering: !1,
  enableAdvancedFilter: !1,
  includeHiddenColumnsInAdvancedFilter: !1,
  enableCharts: !1,
  masterDetail: !1,
  keepDetailRows: !1,
  keepDetailRowsCount: 10,
  detailRowAutoHeight: !1,
  tabIndex: 0,
  rowBuffer: 10,
  valueCache: !1,
  valueCacheNeverExpires: !1,
  enableCellExpressions: !1,
  suppressTouch: !1,
  suppressFocusAfterRefresh: !1,
  suppressAsyncEvents: !1,
  suppressBrowserResizeObserver: !1,
  suppressPropertyNamesCheck: !1,
  suppressChangeDetection: !1,
  debug: !1,
  suppressLoadingOverlay: !1,
  suppressNoRowsOverlay: !1,
  pagination: !1,
  paginationPageSize: 100,
  paginationPageSizeSelector: !0,
  paginationAutoPageSize: !1,
  paginateChildRows: !1,
  suppressPaginationPanel: !1,
  pivotMode: !1,
  pivotPanelShow: "never",
  pivotDefaultExpanded: 0,
  pivotSuppressAutoColumn: !1,
  suppressExpandablePivotGroups: !1,
  functionsReadOnly: !1,
  suppressAggFuncInHeader: !1,
  alwaysAggregateAtRootLevel: !1,
  aggregateOnlyChangedColumns: !1,
  suppressAggFilteredOnly: !1,
  removePivotHeaderRowWhenSingleValueColumn: !1,
  animateRows: !0,
  enableCellChangeFlash: !1,
  cellFlashDelay: 500,
  cellFlashDuration: 500,
  cellFadeDelay: 1e3,
  cellFadeDuration: 1e3,
  allowShowChangeAfterFilter: !1,
  domLayout: "normal",
  ensureDomOrder: !1,
  enableRtl: !1,
  suppressColumnVirtualisation: !1,
  suppressMaxRenderedRowRestriction: !1,
  suppressRowVirtualisation: !1,
  rowDragManaged: !1,
  suppressRowDrag: !1,
  suppressMoveWhenRowDragging: !1,
  rowDragEntireRow: !1,
  rowDragMultiRow: !1,
  embedFullWidthRows: !1,
  groupDisplayType: "singleColumn",
  groupDefaultExpanded: 0,
  groupMaintainOrder: !1,
  groupSelectsChildren: !1,
  groupIncludeTotalFooter: !1,
  groupSuppressBlankHeader: !1,
  groupSelectsFiltered: !1,
  showOpenedGroup: !1,
  groupRemoveSingleChildren: !1,
  groupRemoveLowestSingleChildren: !1,
  groupHideOpenParents: !1,
  groupAllowUnbalanced: !1,
  rowGroupPanelShow: "never",
  suppressMakeColumnVisibleAfterUnGroup: !1,
  treeData: !1,
  rowGroupPanelSuppressSort: !1,
  suppressGroupRowsSticky: !1,
  rowModelType: "clientSide",
  asyncTransactionWaitMillis: 50,
  suppressModelUpdateAfterUpdateTransaction: !1,
  cacheOverflowSize: 1,
  infiniteInitialRowCount: 1,
  serverSideInitialRowCount: 1,
  suppressServerSideInfiniteScroll: !1,
  cacheBlockSize: 100,
  maxBlocksInCache: -1,
  maxConcurrentDatasourceRequests: 2,
  blockLoadDebounceMillis: 0,
  purgeClosedRowNodes: !1,
  serverSideSortAllLevels: !1,
  serverSideOnlyRefreshFilteredGroups: !1,
  serverSideSortOnServer: !1,
  serverSideFilterOnServer: !1,
  serverSidePivotResultFieldSeparator: "_",
  viewportRowModelPageSize: 5,
  viewportRowModelBufferSize: 5,
  alwaysShowHorizontalScroll: !1,
  alwaysShowVerticalScroll: !1,
  debounceVerticalScrollbar: !1,
  suppressHorizontalScroll: !1,
  suppressScrollOnNewData: !1,
  suppressScrollWhenPopupsAreOpen: !1,
  suppressAnimationFrame: !1,
  suppressMiddleClickScrolls: !1,
  suppressPreventDefaultOnMouseWheel: !1,
  rowMultiSelectWithClick: !1,
  suppressRowDeselection: !1,
  suppressRowClickSelection: !1,
  suppressCellFocus: !1,
  suppressHeaderFocus: !1,
  suppressMultiRangeSelection: !1,
  enableCellTextSelection: !1,
  enableRangeSelection: !1,
  enableRangeHandle: !1,
  enableFillHandle: !1,
  fillHandleDirection: "xy",
  suppressClearOnFillReduction: !1,
  accentedSort: !1,
  unSortIcon: !1,
  suppressMultiSort: !1,
  alwaysMultiSort: !1,
  suppressMaintainUnsortedOrder: !1,
  suppressRowHoverHighlight: !1,
  suppressRowTransform: !1,
  columnHoverHighlight: !1,
  deltaSort: !1,
  enableGroupEdit: !1,
  suppressGroupMaintainValueType: !1,
  groupLockGroupColumns: 0,
  serverSideEnableClientSideSort: !1,
  suppressServerSideFullWidthLoadingRow: !1,
  pivotMaxGeneratedColumns: -1,
  columnMenu: "new",
  reactiveCustomComponents: !0
}, G3e = () => ({
  sideBar: {
    module: "@ag-grid-enterprise/side-bar"
    /* SideBarModule */
  },
  statusBar: {
    module: "@ag-grid-enterprise/status-bar"
    /* StatusBarModule */
  },
  enableCharts: {
    module: "@ag-grid-enterprise/charts"
    /* GridChartsModule */
  },
  getMainMenuItems: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  getContextMenuItems: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  allowContextMenuWithControlKey: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  enableAdvancedFilter: {
    module: "@ag-grid-enterprise/advanced-filter"
    /* AdvancedFilterModule */
  },
  treeData: {
    supportedRowModels: ["clientSide", "serverSide"],
    module: "@ag-grid-enterprise/row-grouping",
    dependencies: (e) => {
      const t = e.rowModelType ?? "clientSide";
      switch (t) {
        case "clientSide": {
          const r = `treeData requires 'getDataPath' in the ${t} row model.`;
          return e.getDataPath ? null : r;
        }
        case "serverSide": {
          const r = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${t} row model.`;
          return e.isServerSideGroup && e.getServerSideGroupKey ? null : r;
        }
      }
      return null;
    }
  },
  masterDetail: {
    module: "@ag-grid-enterprise/master-detail"
    /* MasterDetailModule */
  },
  enableRangeSelection: {
    module: "@ag-grid-enterprise/range-selection"
    /* RangeSelectionModule */
  },
  enableRangeHandle: {
    dependencies: {
      enableRangeSelection: [!0]
    }
  },
  enableFillHandle: {
    dependencies: {
      enableRangeSelection: [!0]
    }
  },
  groupDefaultExpanded: {
    supportedRowModels: ["clientSide"]
  },
  groupIncludeFooter: {
    supportedRowModels: ["clientSide", "serverSide"],
    dependencies: (e) => {
      switch (e.rowModelType ?? "clientSide") {
        case "clientSide":
          return null;
        case "serverSide":
          return e.suppressServerSideInfiniteScroll ? "groupIncludeFooter is not supported alongside suppressServerSideInfiniteScroll" : null;
      }
      return null;
    }
  },
  groupHideOpenParents: {
    supportedRowModels: ["clientSide"],
    dependencies: {
      groupTotalRow: [void 0, "bottom"]
    }
  },
  groupIncludeTotalFooter: {
    supportedRowModels: ["clientSide"]
  },
  groupRemoveSingleChildren: {
    dependencies: {
      groupHideOpenParents: [void 0, !1],
      groupRemoveLowestSingleChildren: [void 0, !1]
    }
  },
  groupRemoveLowestSingleChildren: {
    dependencies: {
      groupHideOpenParents: [void 0, !1],
      groupRemoveSingleChildren: [void 0, !1]
    }
  },
  groupSelectsChildren: {
    dependencies: {
      rowSelection: ["multiple"]
    }
  },
  viewportDatasource: {
    supportedRowModels: ["viewport"],
    module: "@ag-grid-enterprise/viewport-row-model"
    /* ViewportRowModelModule */
  },
  serverSideDatasource: {
    supportedRowModels: ["serverSide"],
    module: "@ag-grid-enterprise/server-side-row-model"
    /* ServerSideRowModelModule */
  },
  cacheBlockSize: {
    supportedRowModels: ["serverSide", "infinite"]
  },
  datasource: {
    supportedRowModels: ["infinite"],
    module: "@ag-grid-community/infinite-row-model"
    /* InfiniteRowModelModule */
  },
  rowData: {
    supportedRowModels: ["clientSide"],
    module: "@ag-grid-community/client-side-row-model"
    /* ClientSideRowModelModule */
  },
  columnDefs: () => Sh,
  defaultColDef: () => Sh,
  defaultColGroupDef: () => Sh,
  autoGroupColumnDef: () => Sh
}), z3e = () => ({
  objectName: "gridOptions",
  allProperties: [...hv.ALL_PROPERTIES, ...fv.EVENT_CALLBACKS],
  propertyExceptions: ["api"],
  docsUrl: "grid-options/",
  deprecations: $3e(),
  validations: G3e()
}), W3e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "validationService";
  }
  wireBeans(e) {
    this.beans = e, this.gridOptions = e.gridOptions;
  }
  postConstruct() {
    this.processGridOptions(this.gridOptions);
  }
  processGridOptions(e) {
    this.processOptions(e, z3e());
  }
  processColumnDefs(e) {
    this.processOptions(e, Sh);
  }
  warnMissingApiFunction(e) {
    L3e(e, this.gridId);
  }
  validateApiFunction(e, t) {
    return F3e(e, t, this.beans);
  }
  processOptions(e, t) {
    const { validations: r, deprecations: n, allProperties: i, propertyExceptions: o, objectName: a, docsUrl: s } = t;
    i && this.gridOptions.suppressPropertyNamesCheck !== !0 && this.checkProperties(
      e,
      [...o ?? [], ...Object.keys(n)],
      i,
      a,
      s
    );
    const l = /* @__PURE__ */ new Set();
    Object.keys(e).forEach((c) => {
      const d = n[c];
      if (d)
        if ("renamed" in d) {
          const { renamed: y, version: C } = d;
          l.add(
            `As of v${C}, ${String(c)} is deprecated. Please use ${String(y)} instead.`
          ), e[y] = e[c];
        } else {
          const { message: y, version: C } = d;
          l.add(`As of v${C}, ${String(c)} is deprecated. ${y ?? ""}`);
        }
      const h = e[c];
      if (h == null || h === !1)
        return;
      const f = r[c];
      let p;
      if (f)
        if (typeof f == "function") {
          const y = f(e, this.gridOptions);
          if (!y)
            return;
          if ("objectName" in y) {
            const C = e[c];
            if (Array.isArray(C)) {
              C.forEach((S) => {
                this.processOptions(S, y);
              });
              return;
            }
            this.processOptions(e[c], y);
            return;
          }
          p = y;
        } else
          p = f;
      else return;
      const { module: g, dependencies: v, supportedRowModels: m } = p;
      if (m) {
        const y = this.gridOptions.rowModelType ?? "clientSide";
        if (!m.includes(y)) {
          l.add(`${String(c)} is not supported with the '${y}' row model.`);
          return;
        }
      }
      if (g) {
        const y = Array.isArray(g) ? g : [g];
        let C = !0;
        if (y.forEach((S) => {
          ci.__assertRegistered(S, String(c), this.gridId) || (C = !1, l.add(`${String(c)} is only available when ${S} is loaded.`));
        }), !C)
          return;
      }
      if (v) {
        const y = this.checkForWarning(c, v, e);
        if (y) {
          l.add(y);
          return;
        }
      }
    }), l.size > 0 && l.forEach((c) => {
      Te(c);
    });
  }
  checkForWarning(e, t, r) {
    if (typeof t == "function")
      return t(r, this.gridOptions);
    const i = Object.entries(t).find(([s, l]) => {
      const u = r[s];
      return !l.includes(u);
    });
    if (!i)
      return null;
    const [o, a] = i;
    return a.length > 1 ? `'${String(e)}' requires '${o}' to be one of [${a.join(", ")}].` : `'${String(e)}' requires '${o}' to be ${a[0]}.`;
  }
  checkProperties(e, t, r, n, i) {
    const o = ["__ob__", "__v_skip", "__metadata__"], a = m4e(
      Object.getOwnPropertyNames(e),
      [...o, ...t, ...r],
      r
    );
    if (wa(a, (s, l) => {
      let u = `invalid ${n} property '${s}' did you mean any of these: ${l.slice(0, 8).join(", ")}.`;
      r.includes("context") && (u += `
If you are trying to annotate ${n} with application data, use the '${n}.context' property instead.`), Te(u);
    }), Object.keys(a).length > 0 && i) {
      const s = this.getFrameworkOverrides().getDocLink(i);
      Te(`to see all the valid ${n} properties please check: ${s}`);
    }
  }
}, j3e = {
  version: kt,
  moduleName: "@ag-grid-community/core"
  /* CommunityCoreModule */
}, U3e = {
  version: kt,
  moduleName: "@ag-grid-community/core-validations",
  beans: [W3e]
}, lX = {
  version: kt,
  moduleName: "@ag-grid-community/core-community-features",
  dependantModules: [
    j3e,
    U3e,
    ize,
    Q$e,
    c3e,
    B5e,
    Yze,
    M3e,
    a3e
  ]
}, K3e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "gridDestroyService", this.destroyCalled = !1;
  }
  wireBeans(e) {
    this.beans = e;
  }
  destroy() {
    var t, r;
    if (this.destroyCalled)
      return;
    const e = {
      type: "gridPreDestroyed",
      state: ((t = this.beans.stateService) == null ? void 0 : t.getState()) ?? {}
    };
    this.eventService.dispatchEvent(e), this.destroyCalled = !0, (r = this.beans.ctrlsService.get("gridCtrl")) == null || r.destroyGridUi(), this.beans.context.destroy(), super.destroy();
  }
  isDestroyCalled() {
    return this.destroyCalled;
  }
}, R0 = /* @__PURE__ */ new Set(["gridPreDestroyed", "fillStart", "pasteStart"]), Y3e = (e) => e === "checkboxSelected" || e === "rowClicked" || e === "spaceKey" || e === "uiSelectAll" || e === "uiSelectAllCurrentPage" || e === "uiSelectAllFiltered", q3e = new Map([
  ...hv.BOOLEAN_PROPERTIES.map((e) => [e, rP]),
  ...hv.NUMBER_PROPERTIES.map((e) => [e, _q]),
  ["groupAggFiltering", (e) => typeof e == "function" ? e : rP(e)],
  ["pageSize", Ua(1)],
  ["autoSizePadding", Ua(0)],
  ["keepDetailRowsCount", Ua(1)],
  ["rowBuffer", Ua(0)],
  ["infiniteInitialRowCount", Ua(1)],
  ["cacheOverflowSize", Ua(1)],
  ["cacheBlockSize", Ua(1)],
  ["serverSideInitialRowCount", Ua(1)],
  ["viewportRowModelPageSize", Ua(1)],
  ["viewportRowModelBufferSize", Ua(0)]
]);
function uX(e, t) {
  const r = q3e.get(e);
  return r ? r(t) : t;
}
function X3e(e) {
  const t = {};
  return Object.entries(e).forEach(([r, n]) => {
    const i = uX(r, n);
    t[r] = i;
  }), t;
}
var cX = class dX extends Se {
  constructor() {
    super(...arguments), this.beanName = "gos", this.domDataKey = "__AG_" + Math.random().toString(), this.propertyEventService = new Af(), this.globalEventHandlerFactory = (t) => (r, n) => {
      if (!this.isAlive())
        return;
      const i = R0.has(r);
      if (i && !t || !i && t)
        return;
      const o = fv.getCallbackForEvent(r), a = this.gridOptions[o];
      typeof a == "function" && this.frameworkOverrides.wrapOutgoing(() => {
        a(n);
      });
    };
  }
  wireBeans(t) {
    this.gridOptions = t.gridOptions, this.eGridDiv = t.eGridDiv, this.validationService = t.validationService, this.environment = t.environment, this.api = t.gridApi;
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get gridOptionsContext() {
    return this.gridOptions.context;
  }
  postConstruct() {
    const t = !this.get("suppressAsyncEvents");
    this.eventService.addGlobalListener(this.globalEventHandlerFactory().bind(this), t), this.eventService.addGlobalListener(this.globalEventHandlerFactory(!0).bind(this), !1), this.propertyEventService.setFrameworkOverrides(this.frameworkOverrides), this.getScrollbarWidth(), this.addManagedEventListeners({
      gridOptionsChanged: ({ options: r }) => {
        this.updateGridOptions({ options: r, force: !0, source: "gridOptionsUpdated" });
      }
    });
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(t) {
    return this.gridOptions[t] ?? H3e[t];
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(t) {
    return this.mergeGridCommonParams(this.gridOptions[t]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(t) {
    return ke(this.gridOptions[t]);
  }
  /**
   * Wrap the user callback and attach the api and context to the params object on the way through.
   * @param callback User provided callback
   * @returns Wrapped callback where the params object not require api and context
   */
  mergeGridCommonParams(t) {
    return t && ((n) => {
      const i = n;
      return i.api = this.api, i.context = this.gridOptionsContext, t(i);
    });
  }
  updateGridOptions({
    options: t,
    force: r,
    source: n = "api"
  }) {
    var a;
    const i = { id: dX.changeSetId++, properties: [] }, o = [];
    Object.entries(t).forEach(([s, l]) => {
      n === "api" && EBe[s] && Te(`${s} is an initial property and cannot be updated.`);
      const u = uX(s, l), c = r || typeof u == "object" && n === "api", d = this.gridOptions[s];
      if (c || d !== u) {
        this.gridOptions[s] = u;
        const h = {
          type: s,
          currentValue: u,
          previousValue: d,
          changeSet: i,
          source: n
        };
        o.push(h);
      }
    }), (a = this.validationService) == null || a.processGridOptions(this.gridOptions), i.properties = o.map((s) => s.type), o.forEach((s) => {
      this.gridOptions.debug && Ea(`Updated property ${s.type} from`, s.previousValue, " to ", s.currentValue), this.propertyEventService.dispatchEvent(s);
    });
  }
  addPropertyEventListener(t, r) {
    this.propertyEventService.addEventListener(t, r);
  }
  removePropertyEventListener(t, r) {
    this.propertyEventService.removeEventListener(t, r);
  }
  // *************** Helper methods ************************** //
  // Methods to share common GridOptions related logic that goes above accessing a single property
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const r = typeof this.gridOptions.scrollbarWidth == "number" && this.gridOptions.scrollbarWidth >= 0 ? this.gridOptions.scrollbarWidth : WBe();
      r != null && (this.scrollbarWidth = r, this.eventService.dispatchEvent({
        type: "scrollbarWidthChanged"
      }));
    }
    return this.scrollbarWidth;
  }
  isRowModelType(t) {
    return this.gridOptions.rowModelType === t || t === "clientSide" && dr(this.gridOptions.rowModelType);
  }
  isDomLayout(t) {
    return (this.gridOptions.domLayout ?? "normal") === t;
  }
  isRowSelection() {
    return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
  }
  useAsyncEvents() {
    return !this.get("suppressAsyncEvents");
  }
  isGetRowHeightFunction() {
    return typeof this.gridOptions.getRowHeight == "function";
  }
  getRowHeightForNode(t, r = !1, n) {
    if (n == null && (n = this.environment.getDefaultRowHeight()), this.isGetRowHeightFunction()) {
      if (r)
        return { height: n, estimated: !0 };
      const o = {
        node: t,
        data: t.data
      }, a = this.getCallback("getRowHeight")(o);
      if (this.isNumeric(a))
        return a === 0 && Te(
          "The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead."
        ), { height: Math.max(1, a), estimated: !1 };
    }
    return t.detail && this.get("masterDetail") ? this.getMasterDetailRowHeight() : { height: this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : n, estimated: !1 };
  }
  getMasterDetailRowHeight() {
    return this.get("detailRowAutoHeight") ? { height: 1, estimated: !1 } : this.isNumeric(this.gridOptions.detailRowHeight) ? { height: this.gridOptions.detailRowHeight, estimated: !1 } : { height: 300, estimated: !1 };
  }
  // we don't allow dynamic row height for virtual paging
  getRowHeightAsNumber() {
    if (!this.gridOptions.rowHeight || dr(this.gridOptions.rowHeight))
      return this.environment.getDefaultRowHeight();
    const t = this.environment.refreshRowHeightVariable();
    return t !== -1 ? t : (Te("row height must be a number if not using standard row model"), this.environment.getDefaultRowHeight());
  }
  isNumeric(t) {
    return !isNaN(t) && typeof t == "number" && isFinite(t);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  // returns the dom data, or undefined if not found
  getDomData(t, r) {
    const n = t[this.getDomDataKey()];
    return n ? n[r] : void 0;
  }
  setDomData(t, r, n) {
    const i = this.getDomDataKey();
    let o = t[i];
    dr(o) && (o = {}, t[i] = o), o[r] = n;
  }
  getDocument() {
    let t = null;
    return this.gridOptions.getDocument && ke(this.gridOptions.getDocument) ? t = this.gridOptions.getDocument() : this.eGridDiv && (t = this.eGridDiv.ownerDocument), t && ke(t) ? t : document;
  }
  getWindow() {
    return this.getDocument().defaultView || window;
  }
  getRootNode() {
    return this.eGridDiv.getRootNode();
  }
  getActiveDomElement() {
    return this.getRootNode().activeElement;
  }
  getAsyncTransactionWaitMillis() {
    return ke(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : 50;
  }
  isAnimateRows() {
    return this.get("ensureDomOrder") ? !1 : this.get("animateRows");
  }
  isGroupRowsSticky() {
    return !(this.get("paginateChildRows") || this.get("groupHideOpenParents") || this.isDomLayout("print"));
  }
  isColumnsSortingCoupledToGroup() {
    const t = this.gridOptions.autoGroupColumnDef;
    return !(t != null && t.comparator) && !this.get("treeData");
  }
  getGroupAggFiltering() {
    const t = this.gridOptions.groupAggFiltering;
    if (typeof t == "function")
      return this.getCallback("groupAggFiltering");
    if (t === !0)
      return () => !0;
  }
  getGrandTotalRow() {
    const t = this.gridOptions.grandTotalRow;
    if (t)
      return t;
    if (this.gridOptions.groupIncludeTotalFooter)
      return "bottom";
  }
  getGroupTotalRowCallback() {
    const t = this.get("groupTotalRow");
    if (typeof t == "function")
      return this.getCallback("groupTotalRow");
    if (t)
      return () => t;
    const r = this.get("groupIncludeFooter");
    if (typeof r == "function") {
      const n = this.getCallback("groupIncludeFooter");
      return (i) => n(i) ? "bottom" : void 0;
    }
    return () => r ? "bottom" : void 0;
  }
  isGroupMultiAutoColumn() {
    return this.gridOptions.groupDisplayType ? this.gridOptions.groupDisplayType === "multipleColumns" : this.get("groupHideOpenParents");
  }
  isGroupUseEntireRow(t) {
    return t ? !1 : this.gridOptions.groupDisplayType === "groupRows";
  }
  getGridCommonParams() {
    return {
      api: this.api,
      context: this.gridOptionsContext
    };
  }
  addGridCommonParams(t) {
    const r = t;
    return r.api = this.api, r.context = this.gridOptionsContext, r;
  }
  // AG-9259 Can't use `WrappedCallback<'getRowId', ...>` here because of a strange typescript bug
  getRowIdCallback() {
    const t = this.getCallback("getRowId");
    return t === void 0 ? t : (r) => {
      let n = t(r);
      return typeof n != "string" && (Te("The getRowId callback must return a string. The ID ", n, " is being cast to a string."), n = String(n)), n;
    };
  }
};
cX.changeSetId = 0;
var Z3e = cX, Q3e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "headerPositionUtils";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService;
  }
  findHeader(e, t) {
    let r, n;
    if (Sn(e.column) ? r = this.visibleColsService.getGroupAtDirection(e.column, t) : (n = `getCol${t}`, r = this.visibleColsService[n](e.column)), !r)
      return;
    const { headerRowIndex: i } = e;
    if (this.getHeaderRowType(i) !== "filter") {
      const s = [r];
      for (; r.getParent(); )
        r = r.getParent(), s.push(r);
      r = s[s.length - 1 - i];
    }
    const { column: o, headerRowIndex: a } = this.getHeaderIndexToFocus(r, i);
    return {
      column: o,
      headerRowIndex: a
    };
  }
  getHeaderIndexToFocus(e, t) {
    let r;
    if (Sn(e) && this.isAnyChildSpanningHeaderHeight(e) && e.isPadding()) {
      const n = e;
      r = n.getLeafColumns()[0];
      let i = r;
      for (; i !== n; )
        t++, i = i.getParent();
    }
    return {
      column: r || e,
      headerRowIndex: t
    };
  }
  isAnyChildSpanningHeaderHeight(e) {
    return e ? e.getLeafColumns().some((t) => t.isSpanHeaderHeight()) : !1;
  }
  getColumnVisibleParent(e, t) {
    const r = this.getHeaderRowType(t), n = r === "filter", i = r === "column";
    let o = n ? e : e.getParent(), a = t - 1, s = a;
    if (i && this.isAnyChildSpanningHeaderHeight(e.getParent())) {
      for (; o && o.isPadding(); )
        o = o.getParent(), a--;
      s = a, a < 0 && (o = e, a = t, s = void 0);
    }
    return { column: o, headerRowIndex: a, headerRowIndexWithoutSpan: s };
  }
  getColumnVisibleChild(e, t, r = "After") {
    const n = this.getHeaderRowType(t);
    let i = e, o = t + 1;
    const a = o;
    if (n === "group") {
      const s = e.getDisplayedLeafColumns(), l = r === "After" ? s[0] : gr(s), u = [];
      let c = l;
      for (; c.getParent() !== e; )
        c = c.getParent(), u.push(c);
      if (i = l, l.isSpanHeaderHeight())
        for (let d = u.length - 1; d >= 0; d--) {
          const h = u[d];
          if (!h.isPadding()) {
            i = h;
            break;
          }
          o++;
        }
      else
        i = gr(u), i || (i = l);
    }
    return { column: i, headerRowIndex: o, headerRowIndexWithoutSpan: a };
  }
  getHeaderRowType(e) {
    const t = this.ctrlsService.getHeaderRowContainerCtrl();
    if (t)
      return t.getRowType(e);
  }
  findColAtEdgeForHeaderRow(e, t) {
    const r = this.visibleColsService.getAllCols(), n = r[t === "start" ? 0 : r.length - 1];
    if (!n)
      return;
    const o = this.ctrlsService.getHeaderRowContainerCtrl(n.getPinned()).getRowType(e);
    if (o == "group") {
      const a = this.visibleColsService.getColGroupAtLevel(n, e);
      return {
        headerRowIndex: e,
        column: a
      };
    }
    return {
      // if type==null, means the header level didn't exist
      headerRowIndex: o == null ? -1 : e,
      column: n
    };
  }
}, J3e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "localeService";
  }
  getLocaleTextFunc() {
    const e = this.gos.getCallback("getLocaleText");
    if (e)
      return (r, n, i) => e({
        key: r,
        defaultValue: n,
        variableValues: i
      });
    const t = this.gos.get("localeText");
    return (r, n, i) => {
      let o = t && t[r];
      if (o && i && i.length) {
        let a = 0;
        for (; !(a >= i.length || o.indexOf("${variable}") === -1); )
          o = o.replace("${variable}", i[a++]);
      }
      return o ?? n;
    };
  }
}, e6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "apiEventService", this.syncEventListeners = /* @__PURE__ */ new Map(), this.asyncEventListeners = /* @__PURE__ */ new Map(), this.syncGlobalEventListeners = /* @__PURE__ */ new Set(), this.globalEventListenerPairs = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    this.frameworkEventWrappingService = new JA(this.getFrameworkOverrides());
  }
  addEventListener(e, t) {
    const r = this.frameworkEventWrappingService.wrap(t), n = this.gos.useAsyncEvents() && !R0.has(e), i = n ? this.asyncEventListeners : this.syncEventListeners;
    i.has(e) || i.set(e, /* @__PURE__ */ new Set()), i.get(e).add(r), this.eventService.addEventListener(e, r, n);
  }
  removeEventListener(e, t) {
    var o;
    const r = this.frameworkEventWrappingService.unwrap(t), n = this.asyncEventListeners.get(e), i = !!(n != null && n.delete(r));
    i || (o = this.syncEventListeners.get(e)) == null || o.delete(r), this.eventService.removeEventListener(e, r, i);
  }
  addGlobalListener(e) {
    const t = this.frameworkEventWrappingService.wrapGlobal(e);
    if (this.gos.useAsyncEvents()) {
      const n = (o, a) => {
        R0.has(o) && t(o, a);
      }, i = (o, a) => {
        R0.has(o) || t(o, a);
      };
      this.globalEventListenerPairs.set(e, { syncListener: n, asyncListener: i }), this.eventService.addGlobalListener(n, !1), this.eventService.addGlobalListener(i, !0);
    } else
      this.syncGlobalEventListeners.add(t), this.eventService.addGlobalListener(t, !1);
  }
  removeGlobalListener(e) {
    const t = this.frameworkEventWrappingService.unwrapGlobal(e);
    if (this.globalEventListenerPairs.has(t)) {
      const { syncListener: n, asyncListener: i } = this.globalEventListenerPairs.get(t);
      this.eventService.removeGlobalListener(n, !1), this.eventService.removeGlobalListener(i, !0), this.globalEventListenerPairs.delete(e);
    } else
      this.syncGlobalEventListeners.delete(t), this.eventService.removeGlobalListener(t, !1);
  }
  destroyEventListeners(e, t) {
    e.forEach((r, n) => {
      r.forEach((i) => this.eventService.removeEventListener(n, i, t)), r.clear();
    }), e.clear();
  }
  destroyGlobalListeners(e, t) {
    e.forEach((r) => this.eventService.removeGlobalListener(r, t)), e.clear();
  }
  destroy() {
    super.destroy(), this.destroyEventListeners(this.syncEventListeners, !1), this.destroyEventListeners(this.asyncEventListeners, !0), this.destroyGlobalListeners(this.syncGlobalEventListeners, !1), this.globalEventListenerPairs.forEach(({ syncListener: e, asyncListener: t }) => {
      this.eventService.removeGlobalListener(e, !1), this.eventService.removeGlobalListener(t, !0);
    }), this.globalEventListenerPairs.clear();
  }
}, t6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsListener";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      modelUpdated: this.onModelUpdated.bind(this),
      recalculateRowBounds: this.calculatePages.bind(this)
    }), this.onModelUpdated();
  }
  onModelUpdated(e) {
    this.calculatePages();
    const t = {
      type: "paginationChanged",
      animate: e ? e.animate : !1,
      newData: e ? e.newData : !1,
      newPage: e ? e.newPage : !1,
      newPageSize: e ? e.newPageSize : !1,
      keepRenderedRows: e ? e.keepRenderedRows : !1
    };
    this.eventService.dispatchEvent(t);
  }
  calculatePages() {
    this.paginationService ? this.paginationService.calculatePages() : this.pageBoundsService.calculateBounds(0, this.rowModel.getRowCount() - 1);
  }
}, r6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsService", this.pixelOffset = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  getFirstRow() {
    return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
  }
  getLastRow() {
    return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
  }
  getCurrentPageHeight() {
    return dr(this.topRowBounds) || dr(this.bottomRowBounds) ? 0 : Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const e = this.topRowBounds ? this.topRowBounds.rowTop : 0, t = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
    return { pageFirstPixel: e, pageLastPixel: t };
  }
  calculateBounds(e, t) {
    this.topRowBounds = this.rowModel.getRowBounds(e), this.topRowBounds && (this.topRowBounds.rowIndex = e), this.bottomRowBounds = this.rowModel.getRowBounds(t), this.bottomRowBounds && (this.bottomRowBounds.rowIndex = t), this.calculatePixelOffset();
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  calculatePixelOffset() {
    const e = ke(this.topRowBounds) ? this.topRowBounds.rowTop : 0;
    this.pixelOffset !== e && (this.pixelOffset = e, this.eventService.dispatchEvent({ type: "paginationPixelOffsetChanged" }));
  }
}, n6e = class extends Se {
  constructor() {
    super(), this.beanName = "ariaAnnouncementService", this.descriptionContainer = null, this.announceValue = Ti(this.announceValue.bind(this), 200);
  }
  wireBeans(e) {
    this.eGridDiv = e.eGridDiv;
  }
  postConstruct() {
    const e = this.gos.getDocument(), t = this.descriptionContainer = e.createElement("div");
    t.classList.add("ag-aria-description-container"), WY(t, "polite"), DBe(t, "additions text"), MBe(t, !0), this.eGridDiv.appendChild(t);
  }
  announceValue(e) {
    this.descriptionContainer && (this.descriptionContainer.textContent = "", setTimeout(() => {
      this.isAlive() && this.descriptionContainer && (this.descriptionContainer.textContent = e);
    }, 50));
  }
  destroy() {
    super.destroy();
    const { descriptionContainer: e } = this;
    e && (xo(e), e.parentElement && e.parentElement.removeChild(e)), this.descriptionContainer = null, this.eGridDiv = null;
  }
}, i6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnAnimationService", this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = !1, this.suppressAnimation = !1, this.animationThreadCount = 0;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => this.gridBodyCtrl = e.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(e) {
    this.suppressAnimation = e;
  }
  start() {
    this.active || this.gos.get("suppressColumnMoveAnimation") || this.gos.get("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = !0);
  }
  finish() {
    this.active && this.flush(() => {
      this.active = !1;
    });
  }
  executeNextVMTurn(e) {
    this.active ? this.executeNextFuncs.push(e) : e();
  }
  executeLaterVMTurn(e) {
    this.active ? this.executeLaterFuncs.push(e) : e();
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const e = this.animationThreadCount;
    this.gridBodyCtrl.setColumnMovingCss(!0), this.executeLaterFuncs.push(() => {
      this.animationThreadCount === e && this.gridBodyCtrl.setColumnMovingCss(!1);
    });
  }
  flush(e) {
    if (this.executeNextFuncs.length === 0 && this.executeLaterFuncs.length === 0) {
      e();
      return;
    }
    const t = (r) => {
      for (; r.length; ) {
        const n = r.pop();
        n && n();
      }
    };
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => t(this.executeNextFuncs), 0), window.setTimeout(() => {
        e(), t(this.executeLaterFuncs);
      }, 200);
    });
  }
}, o6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "columnHoverService";
  }
  setMouseOver(e) {
    this.selectedColumns = e;
    const t = {
      type: "columnHoverChanged"
    };
    this.eventService.dispatchEvent(t);
  }
  clearMouseOver() {
    this.selectedColumns = null;
    const e = {
      type: "columnHoverChanged"
    };
    this.eventService.dispatchEvent(e);
  }
  isHovered(e) {
    return !!this.selectedColumns && this.selectedColumns.indexOf(e) >= 0;
  }
}, a6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "overlayService", this.state = 0, this.showInitialOverlay = !0;
  }
  wireBeans(e) {
    this.userComponentFactory = e.userComponentFactory, this.rowModel = e.rowModel, this.columnModel = e.columnModel;
  }
  postConstruct() {
    const e = () => this.updateOverlayVisibility();
    this.addManagedEventListeners({
      newColumnsLoaded: e,
      rowDataUpdated: e
    }), this.addManagedPropertyListener("loading", e);
  }
  registerOverlayWrapperComp(e) {
    this.overlayWrapperComp = e, this.updateOverlayVisibility();
  }
  showLoadingOverlay() {
    this.showInitialOverlay = !1;
    const e = this.gos.get("loading");
    !e && (e !== void 0 || this.gos.get("suppressLoadingOverlay")) || this.doShowLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.showInitialOverlay = !1, !(this.gos.get("loading") || this.gos.get("suppressNoRowsOverlay")) && this.doShowNoRowsOverlay();
  }
  hideOverlay() {
    this.showInitialOverlay = !1, !this.gos.get("loading") && this.doHideOverlay();
  }
  updateOverlayVisibility() {
    let e = this.gos.get("loading");
    this.showInitialOverlay && e === void 0 && !this.gos.get("suppressLoadingOverlay") && (e = !this.gos.get("columnDefs") || !this.columnModel.isReady() || !this.gos.get("rowData") && this.gos.isRowModelType("clientSide")), e ? this.state !== 1 && this.doShowLoadingOverlay() : (this.showInitialOverlay = !1, this.rowModel.isEmpty() && !this.gos.get("suppressNoRowsOverlay") && this.gos.isRowModelType("clientSide") ? this.state !== 2 && this.doShowNoRowsOverlay() : this.state !== 0 && this.doHideOverlay());
  }
  doShowLoadingOverlay() {
    this.state = 1, this.showOverlay(
      this.userComponentFactory.getLoadingOverlayCompDetails({}),
      "ag-overlay-loading-wrapper",
      "loadingOverlayComponentParams"
    );
  }
  doShowNoRowsOverlay() {
    this.state = 2, this.showOverlay(
      this.userComponentFactory.getNoRowsOverlayCompDetails({}),
      "ag-overlay-no-rows-wrapper",
      "noRowsOverlayComponentParams"
    );
  }
  doHideOverlay() {
    this.state = 0, this.overlayWrapperComp.hideOverlay();
  }
  showOverlay(e, t, r) {
    const n = e.newAgStackInstance();
    this.overlayWrapperComp.showOverlay(n, t, r);
  }
}, s6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowCssClassCalculator";
  }
  wireBeans(e) {
    this.stylingService = e.stylingService;
  }
  getInitialRowClasses(e) {
    const t = [];
    return ke(e.extraCssClass) && t.push(e.extraCssClass), t.push("ag-row"), t.push(e.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), e.fadeRowIn && t.push("ag-opacity-zero"), t.push(e.rowIsEven ? "ag-row-even" : "ag-row-odd"), e.rowNode.isRowPinned() && t.push("ag-row-pinned"), e.rowNode.isSelected() && t.push("ag-row-selected"), e.rowNode.footer && t.push("ag-row-footer"), t.push("ag-row-level-" + e.rowLevel), e.rowNode.stub && t.push("ag-row-loading"), e.fullWidthRow && t.push("ag-full-width-row"), e.expandable && (t.push("ag-row-group"), t.push(e.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted")), e.rowNode.dragging && t.push("ag-row-dragging"), OH(t, this.processClassesFromGridOptions(e.rowNode)), OH(t, this.preProcessRowClassRules(e.rowNode)), t.push(e.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), e.firstRowOnPage && t.push("ag-row-first"), e.lastRowOnPage && t.push("ag-row-last"), e.fullWidthRow && (e.pinned === "left" && t.push("ag-cell-last-left-pinned"), e.pinned === "right" && t.push("ag-cell-first-right-pinned")), t;
  }
  processClassesFromGridOptions(e) {
    const t = [], r = (o) => {
      typeof o == "string" ? t.push(o) : Array.isArray(o) && o.forEach((a) => t.push(a));
    }, n = this.gos.get("rowClass");
    if (n) {
      if (typeof n == "function")
        return Te("rowClass should not be a function, please use getRowClass instead"), [];
      r(n);
    }
    const i = this.gos.getCallback("getRowClass");
    if (i) {
      const o = {
        data: e.data,
        node: e,
        rowIndex: e.rowIndex
      }, a = i(o);
      r(a);
    }
    return t;
  }
  preProcessRowClassRules(e) {
    const t = [];
    return this.processRowClassRules(
      e,
      (r) => {
        t.push(r);
      },
      () => {
      }
    ), t;
  }
  processRowClassRules(e, t, r) {
    const n = this.gos.addGridCommonParams({
      data: e.data,
      node: e,
      rowIndex: e.rowIndex
    });
    this.stylingService.processClassRules(
      void 0,
      this.gos.get("rowClassRules"),
      n,
      t,
      r
    );
  }
  calculateRowLevel(e) {
    return e.group ? e.level : e.parent ? e.parent.level + 1 : 0;
  }
}, l6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowContainerHeightService", this.scrollY = 0, this.uiBodyHeight = 0;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) }), this.maxDivHeight = HBe(), this.gos.get("debug") && Ea("RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
  }
  isStretching() {
    return this.stretching;
  }
  getDivStretchOffset() {
    return this.divStretchOffset;
  }
  updateOffset() {
    if (!this.stretching)
      return;
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition().top, r = this.getUiBodyHeight();
    (t !== this.scrollY || r !== this.uiBodyHeight) && (this.scrollY = t, this.uiBodyHeight = r, this.calculateOffset());
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const e = this.scrollY / this.maxScrollY, t = e * this.pixelsToShave;
    this.gos.get("debug") && Ea(
      `RowContainerHeightService - Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`
    ), this.setDivStretchOffset(t);
  }
  setUiContainerHeight(e) {
    e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventService.dispatchEvent({ type: "rowContainerHeightChanged" }));
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
  }
  setDivStretchOffset(e) {
    const t = typeof e == "number" ? Math.floor(e) : null;
    this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventService.dispatchEvent({ type: "heightScaleChanged" }));
  }
  setModelHeight(e) {
    this.modelHeight = e, this.stretching = e != null && // null happens when in print layout
    this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
  }
  getUiContainerHeight() {
    return this.uiContainerHeight;
  }
  getRealPixelPosition(e) {
    return e - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
    return t.bottom - t.top;
  }
  getScrollPositionForPixel(e) {
    if (this.pixelsToShave <= 0)
      return e;
    const t = this.modelHeight - this.getUiBodyHeight(), r = e / t;
    return this.maxScrollY * r;
  }
}, u6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowNodeSorter";
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  postConstruct() {
    this.isAccentedSort = this.gos.get("accentedSort"), this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup(), this.addManagedPropertyListener(
      "accentedSort",
      (e) => this.isAccentedSort = e.currentValue
    ), this.addManagedPropertyListener(
      "autoGroupColumnDef",
      () => this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup()
    );
  }
  doFullSort(e, t) {
    const r = (i, o) => ({ currentPos: o, rowNode: i }), n = e.map(r);
    return n.sort(this.compareRowNodes.bind(this, t)), n.map((i) => i.rowNode);
  }
  compareRowNodes(e, t, r) {
    const n = t.rowNode, i = r.rowNode;
    for (let o = 0, a = e.length; o < a; o++) {
      const s = e[o], l = s.sort === "desc", u = this.getValue(n, s.column), c = this.getValue(i, s.column);
      let d;
      const h = this.getComparator(s, n);
      if (h ? d = h(u, c, n, i, l) : d = QVe(u, c, this.isAccentedSort), !isNaN(d) && d !== 0)
        return s.sort === "asc" ? d : d * -1;
    }
    return t.currentPos - r.currentPos;
  }
  getComparator(e, t) {
    const r = e.column, n = r.getColDef().comparator;
    if (n != null)
      return n;
    if (!r.getColDef().showRowGroup)
      return;
    const i = !t.group && r.getColDef().field;
    if (!i)
      return;
    const o = this.columnModel.getColDefCol(i);
    if (o)
      return o.getColDef().comparator;
  }
  getValue(e, t) {
    var n, i, o;
    if (!this.primaryColumnsSortGroups)
      return this.valueService.getValue(t, e, !1, !1);
    if (e.rowGroupColumn === t) {
      if (this.gos.isGroupUseEntireRow(this.columnModel.isPivotActive())) {
        const l = (n = e.allLeafChildren) == null ? void 0 : n[0];
        return l ? this.valueService.getValue(t, l, !1, !1) : void 0;
      }
      const s = (i = this.showRowGroupColsService) == null ? void 0 : i.getShowRowGroupCol(t.getId());
      return s ? (o = e.groupData) == null ? void 0 : o[s.getId()] : void 0;
    }
    if (!(e.group && t.getColDef().showRowGroup))
      return this.valueService.getValue(t, e, !1, !1);
  }
}, Hw = class {
  constructor(e, t) {
    this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
      rowNode: t,
      children: null
    }, this.mapToItems[t.id] = this.pathRoot;
  }
  // can be set inactive by:
  // a) ClientSideRowModel, if no transactions or
  // b) PivotService, if secondary columns changed
  setInactive() {
    this.active = !1;
  }
  isActive() {
    return this.active;
  }
  depthFirstSearchChangedPath(e, t) {
    if (e.children)
      for (let r = 0; r < e.children.length; r++)
        this.depthFirstSearchChangedPath(e.children[r], t);
    t(e.rowNode);
  }
  depthFirstSearchEverything(e, t, r) {
    if (e.childrenAfterGroup)
      for (let n = 0; n < e.childrenAfterGroup.length; n++) {
        const i = e.childrenAfterGroup[n];
        i.childrenAfterGroup ? this.depthFirstSearchEverything(e.childrenAfterGroup[n], t, r) : r && t(i);
      }
    t(e);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(e, t = !1, r = !1) {
    this.active && !r ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
  }
  executeFromRootNode(e) {
    e(this.pathRoot.rowNode);
  }
  createPathItems(e) {
    let t = e, r = 0;
    for (; !this.mapToItems[t.id]; ) {
      const n = {
        rowNode: t,
        children: null
      };
      this.mapToItems[t.id] = n, r++, t = t.parent;
    }
    return r;
  }
  populateColumnsMap(e, t) {
    if (!this.keepingColumns || !t)
      return;
    let r = e;
    for (; r; )
      this.nodeIdsToColumns[r.id] || (this.nodeIdsToColumns[r.id] = {}), t.forEach((n) => this.nodeIdsToColumns[r.id][n.getId()] = !0), r = r.parent;
  }
  linkPathItems(e, t) {
    let r = e;
    for (let n = 0; n < t; n++) {
      const i = this.mapToItems[r.id], o = this.mapToItems[r.parent.id];
      o.children || (o.children = []), o.children.push(i), r = r.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(e, t) {
    if (!e || e.isRowPinned())
      return;
    const r = this.createPathItems(e);
    this.linkPathItems(e, r), this.populateColumnsMap(e, t);
  }
  canSkip(e) {
    return this.active && !this.mapToItems[e.id];
  }
  getValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return t;
    const r = this.nodeIdsToColumns[e.id];
    return t.filter((i) => r[i.getId()]);
  }
  getNotValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return null;
    const r = this.nodeIdsToColumns[e.id];
    return t.filter((i) => !r[i.getId()]);
  }
}, hX = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "selectionService", this.selectedNodes = /* @__PURE__ */ new Map(), this.selectionCtx = new fze();
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.selectionCtx.init(this.rowModel), this.rowSelection = this.gos.get("rowSelection"), this.groupSelectsChildren = this.gos.get("groupSelectsChildren"), this.addManagedPropertyListeners(["groupSelectsChildren", "rowSelection"], () => {
      this.groupSelectsChildren = this.gos.get("groupSelectsChildren"), this.rowSelection = this.gos.get("rowSelection"), this.deselectAllRowNodes({ source: "api" });
    }), this.addManagedEventListeners({ rowSelected: this.onRowSelected.bind(this) });
  }
  destroy() {
    super.destroy(), this.resetNodes(), this.selectionCtx.reset();
  }
  isMultiselect() {
    return this.rowSelection === "multiple";
  }
  /**
   * We override the selection value for UI-triggered events because it's the
   * current selection state that should determine the next selection state. This
   * is a stepping stone towards removing selection logic from event listeners and
   * other code external to the selection service(s).
   */
  overrideSelectionValue(e, t) {
    if (!Y3e(t))
      return e;
    const r = this.selectionCtx.getRoot();
    return r ? r.isSelected() ?? !1 : !0;
  }
  setNodesSelected(e) {
    var d;
    const { newValue: t, clearSelection: r, suppressFinishActions: n, rangeSelect: i, nodes: o, event: a, source: s } = e;
    if (o.length === 0)
      return 0;
    if (o.length > 1 && !this.isMultiselect())
      return Te("cannot multi select while rowSelection='single'"), 0;
    const l = this.groupSelectsChildren && e.groupSelectsFiltered === !0, u = o.map((h) => h.footer ? h.sibling : h);
    if (i) {
      if (u.length > 1)
        return Te("cannot range select while selecting multiple rows"), 0;
      const h = u[0], f = this.overrideSelectionValue(t, s);
      if (this.isMultiselect()) {
        if (this.selectionCtx.isInRange(h)) {
          const p = this.selectionCtx.truncate(h);
          return f && this.selectRange(p.discard, !1, s), this.selectRange(p.keep, f, s);
        } else if (this.selectionCtx.getRoot() !== h) {
          const v = this.selectionCtx.extend(h, this.groupSelectsChildren);
          return f && this.selectRange(v.discard, !1, s), this.selectRange(v.keep, f, s);
        }
      }
    }
    n || this.selectionCtx.setRoot(u[0]);
    let c = 0;
    for (let h = 0; h < u.length; h++) {
      const f = u[h];
      l && f.group || f.selectThisNode(t, a, s) && c++, this.groupSelectsChildren && ((d = f.childrenAfterGroup) != null && d.length) && (c += this.selectChildren(f, t, l, s));
    }
    return n || (t && (r || !this.isMultiselect()) && (c += this.clearOtherNodes(u[0], s)), c > 0 && (this.updateGroupsFromChildrenSelections(s), this.dispatchSelectionChanged(s))), c;
  }
  // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
  // holding down 'shift'.
  selectRange(e, t, r) {
    let n = 0;
    return e.forEach((i) => {
      if (i.group && this.groupSelectsChildren)
        return;
      i.selectThisNode(t, void 0, r) && n++;
    }), n > 0 && (this.updateGroupsFromChildrenSelections(r), this.dispatchSelectionChanged(r)), n;
  }
  selectChildren(e, t, r, n) {
    const i = r ? e.childrenAfterAggFilter : e.childrenAfterGroup;
    return dr(i) ? 0 : this.setNodesSelected({
      newValue: t,
      clearSelection: !1,
      suppressFinishActions: !0,
      groupSelectsFiltered: r,
      source: n,
      nodes: i
    });
  }
  getSelectedNodes() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && e.push(t);
    }), e;
  }
  getSelectedRows() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && t.data && e.push(t.data);
    }), e;
  }
  getSelectionCount() {
    return this.selectedNodes.size;
  }
  /**
   * This method is used by the CSRM to remove groups which are being disposed of,
   * events do not need fired in this case
   */
  filterFromSelection(e) {
    const t = /* @__PURE__ */ new Map();
    this.selectedNodes.forEach((r, n) => {
      r && e(r) && t.set(n, r);
    }), this.selectedNodes = t;
  }
  // should only be called if groupSelectsChildren=true
  updateGroupsFromChildrenSelections(e, t) {
    if (!this.groupSelectsChildren || this.rowModel.getType() !== "clientSide")
      return !1;
    const n = this.rowModel.getRootNode();
    t || (t = new Hw(!0, n), t.setInactive());
    let i = !1;
    return t.forEachChangedNodeDepthFirst((o) => {
      if (o !== n) {
        const a = o.calculateSelectedFromChildren();
        i = o.selectThisNode(a === null ? !1 : a, void 0, e) || i;
      }
    }), i;
  }
  clearOtherNodes(e, t) {
    const r = /* @__PURE__ */ new Map();
    let n = 0;
    return this.selectedNodes.forEach((i) => {
      if (i && i.id !== e.id) {
        const o = this.selectedNodes.get(i.id);
        n += o.setSelectedParams({
          newValue: !1,
          clearSelection: !1,
          suppressFinishActions: !0,
          source: t
        }), this.groupSelectsChildren && i.parent && r.set(i.parent.id, i.parent);
      }
    }), r.forEach((i) => {
      const o = i.calculateSelectedFromChildren();
      i.selectThisNode(o === null ? !1 : o, void 0, t);
    }), n;
  }
  onRowSelected(e) {
    const t = e.node;
    this.groupSelectsChildren && t.group || (t.isSelected() ? this.selectedNodes.set(t.id, t) : this.selectedNodes.delete(t.id));
  }
  syncInRowNode(e, t) {
    this.syncInOldRowNode(e, t), this.syncInNewRowNode(e);
  }
  // if the id has changed for the node, then this means the rowNode
  // is getting used for a different data item, which breaks
  // our selectedNodes, as the node now is mapped by the old id
  // which is inconsistent. so to keep the old node as selected,
  // we swap in the clone (with the old id and old data). this means
  // the oldNode is effectively a daemon we keep a reference to,
  // so if client calls api.getSelectedNodes(), it gets the daemon
  // in the result. when the client un-selects, the reference to the
  // daemon is removed. the daemon, because it's an oldNode, is not
  // used by the grid for rendering, it's a copy of what the node used
  // to be like before the id was changed.
  syncInOldRowNode(e, t) {
    if (ke(t) && e.id !== t.id && t) {
      const n = t.id;
      this.selectedNodes.get(n) == e && this.selectedNodes.set(t.id, t);
    }
  }
  syncInNewRowNode(e) {
    this.selectedNodes.has(e.id) ? (e.setSelectedInitialValue(!0), this.selectedNodes.set(e.id, e)) : e.setSelectedInitialValue(!1);
  }
  reset(e) {
    const t = this.getSelectionCount();
    this.resetNodes(), t && this.dispatchSelectionChanged(e);
  }
  resetNodes() {
    var e;
    (e = this.selectedNodes) == null || e.clear();
  }
  // returns a list of all nodes at 'best cost' - a feature to be used
  // with groups / trees. if a group has all it's children selected,
  // then the group appears in the result, but not the children.
  // Designed for use with 'children' as the group selection type,
  // where groups don't actually appear in the selection normally.
  getBestCostNodeSelection() {
    if (this.rowModel.getType() !== "clientSide")
      return;
    const t = this.rowModel.getTopLevelNodes();
    if (t === null)
      return;
    const r = [];
    function n(i) {
      for (let o = 0, a = i.length; o < a; o++) {
        const s = i[o];
        if (s.isSelected())
          r.push(s);
        else {
          const l = s;
          l.group && l.children && n(l.children);
        }
      }
    }
    return n(t), r;
  }
  isEmpty() {
    let e = 0;
    return this.selectedNodes.forEach((t) => {
      t && e++;
    }), e === 0;
  }
  deselectAllRowNodes(e) {
    const t = (a) => a.selectThisNode(!1, void 0, n), r = this.rowModel.getType() === "clientSide", { source: n, justFiltered: i, justCurrentPage: o } = e;
    if (o || i) {
      if (!r) {
        Er("selecting just filtered only works when gridOptions.rowModelType='clientSide'");
        return;
      }
      this.getNodesToSelect(i, o).forEach(t);
    } else
      this.selectedNodes.forEach((a) => {
        a && t(a);
      }), this.reset(n);
    this.selectionCtx.reset(), r && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(n), this.dispatchSelectionChanged(n);
  }
  getSelectedCounts(e, t) {
    let r = 0, n = 0;
    const i = (o) => {
      this.groupSelectsChildren && o.group || (o.isSelected() ? r++ : o.selectable && n++);
    };
    return this.getNodesToSelect(e, t).forEach(i), { selectedCount: r, notSelectedCount: n };
  }
  getSelectAllState(e, t) {
    const { selectedCount: r, notSelectedCount: n } = this.getSelectedCounts(e, t);
    return r === 0 && n === 0 ? !1 : r > 0 && n > 0 ? null : r > 0;
  }
  hasNodesToSelect(e = !1, t = !1) {
    return this.getNodesToSelect(e, t).filter((r) => r.selectable).length > 0;
  }
  /**
   * @param justFiltered whether to just include nodes which have passed the filter
   * @param justCurrentPage whether to just include nodes on the current page
   * @returns all nodes including unselectable nodes which are the target of this selection attempt
   */
  getNodesToSelect(e = !1, t = !1) {
    if (this.rowModel.getType() !== "clientSide")
      throw new Error(
        `selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`
      );
    const r = [];
    if (t)
      return this.forEachNodeOnPage((i) => {
        if (!i.group) {
          r.push(i);
          return;
        }
        if (!i.expanded) {
          const o = (a) => {
            var s;
            r.push(a), (s = a.childrenAfterFilter) != null && s.length && a.childrenAfterFilter.forEach(o);
          };
          o(i);
          return;
        }
        this.groupSelectsChildren || r.push(i);
      }), r;
    const n = this.rowModel;
    return e ? (n.forEachNodeAfterFilter((i) => {
      r.push(i);
    }), r) : (n.forEachNode((i) => {
      r.push(i);
    }), r);
  }
  forEachNodeOnPage(e) {
    const t = this.pageBoundsService.getFirstRow(), r = this.pageBoundsService.getLastRow();
    for (let n = t; n <= r; n++) {
      const i = this.rowModel.getRow(n);
      i && e(i);
    }
  }
  selectAllRowNodes(e) {
    if (this.rowModel.getType() !== "clientSide")
      throw new Error(
        `selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`
      );
    const { source: t, justFiltered: r, justCurrentPage: n } = e, i = this.getNodesToSelect(r, n);
    i.forEach((o) => o.selectThisNode(!0, void 0, t)), this.selectionCtx.setRoot(i[0] ?? null), this.selectionCtx.setEndRange(gr(i) ?? null), this.rowModel.getType() === "clientSide" && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(t), this.dispatchSelectionChanged(t);
  }
  getSelectionState() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t != null && t.id && e.push(t.id);
    }), e.length ? e : null;
  }
  setSelectionState(e, t) {
    if (!Array.isArray(e))
      return;
    const r = new Set(e), n = [];
    this.rowModel.forEachNode((i) => {
      r.has(i.id) && n.push(i);
    }), this.setNodesSelected({
      newValue: !0,
      nodes: n,
      source: t
    });
  }
  dispatchSelectionChanged(e) {
    const t = {
      type: "selectionChanged",
      source: e
    };
    this.eventService.dispatchEvent(t);
  }
}, c6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "selectableService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  postConstruct() {
    this.addManagedPropertyListener("isRowSelectable", () => this.updateSelectable());
  }
  /**
   * Used by CSRM only, to update selectable state after group state changes.
   */
  updateSelectableAfterGrouping() {
    this.updateSelectable(!0);
  }
  updateSelectable(e = !1) {
    const t = !!this.gos.get("rowSelection"), r = this.gos.get("isRowSelectable");
    if (!t || !r)
      return;
    const n = this.gos.get("groupSelectsChildren"), i = this.rowModel.getType() === "clientSide" && n, o = [], a = (s) => {
      if (e && !s.group)
        return;
      if (i && s.group) {
        const u = s.childrenAfterGroup.some((c) => c.selectable === !0);
        s.setRowSelectable(u, !0);
        return;
      }
      const l = r ? r(s) : !0;
      s.setRowSelectable(l, !0), !l && s.isSelected() && o.push(s);
    };
    if (i) {
      const s = this.rowModel;
      new Hw(!1, s.getRootNode()).forEachChangedNodeDepthFirst(a, !0, !0);
    } else
      this.rowModel.forEachNode(a);
    o.length && this.selectionService.setNodesSelected({
      nodes: o,
      newValue: !1,
      source: "selectableChanged"
    }), i && this.selectionService instanceof hX && this.selectionService.updateGroupsFromChildrenSelections("selectableChanged");
  }
}, rG = ["asc", "desc", null], d6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "sortController";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  progressSort(e, t, r) {
    const n = this.getNextSortDirection(e);
    this.setSortForColumn(e, n, t, r);
  }
  setSortForColumn(e, t, r, n) {
    t !== "asc" && t !== "desc" && (t = null);
    const i = this.gos.isColumnsSortingCoupledToGroup();
    let o = [e];
    if (i && e.getColDef().showRowGroup) {
      const l = this.funcColsService.getSourceColumnsForGroupColumn(e), u = l == null ? void 0 : l.filter((c) => c.isSortable());
      u && (o = [e, ...u]);
    }
    o.forEach((l) => l.setSort(t, n));
    const a = (r || this.gos.get("alwaysMultiSort")) && !this.gos.get("suppressMultiSort"), s = [];
    if (!a) {
      const l = this.clearSortBarTheseColumns(o, n);
      s.push(...l);
    }
    this.updateSortIndex(e), s.push(...o), this.dispatchSortChangedEvents(n, s);
  }
  updateSortIndex(e) {
    var s;
    const t = this.gos.isColumnsSortingCoupledToGroup(), r = (s = this.showRowGroupColsService) == null ? void 0 : s.getShowRowGroupCol(e.getId()), n = t && r || e, i = this.getColumnsWithSortingOrdered();
    this.columnModel.getAllCols().forEach((l) => l.setSortIndex(null));
    const o = i.filter((l) => t && l.getColDef().showRowGroup ? !1 : l !== n);
    (n.getSort() ? [...o, n] : o).forEach((l, u) => {
      l.setSortIndex(u);
    });
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(e, t) {
    this.dispatchSortChangedEvents(e, t);
  }
  isSortActive() {
    const t = this.columnModel.getAllCols().filter((r) => !!r.getSort());
    return t && t.length > 0;
  }
  dispatchSortChangedEvents(e, t) {
    const r = {
      type: "sortChanged",
      source: e
    };
    t && (r.columns = t), this.eventService.dispatchEvent(r);
  }
  clearSortBarTheseColumns(e, t) {
    const r = [];
    return this.columnModel.getAllCols().forEach((n) => {
      e.includes(n) || (n.getSort() && r.push(n), n.setSort(void 0, t));
    }), r;
  }
  getNextSortDirection(e) {
    let t;
    if (e.getColDef().sortingOrder ? t = e.getColDef().sortingOrder : this.gos.get("sortingOrder") ? t = this.gos.get("sortingOrder") : t = rG, !Array.isArray(t) || t.length <= 0)
      return Te(`sortingOrder must be an array with at least one element, currently it's ${t}`), null;
    const r = t.indexOf(e.getSort()), n = r < 0, i = r == t.length - 1;
    let o;
    return n || i ? o = t[0] : o = t[r + 1], rG.indexOf(o) < 0 ? (Te("invalid sort type ", o), null) : o;
  }
  /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    let e = this.columnModel.getAllCols().filter((o) => !!o.getSort());
    if (this.columnModel.isPivotMode()) {
      const o = this.gos.isColumnsSortingCoupledToGroup();
      e = e.filter((a) => {
        var c;
        const s = !!a.getAggFunc(), l = !a.isPrimary(), u = o ? (c = this.showRowGroupColsService) == null ? void 0 : c.getShowRowGroupCol(a.getId()) : a.getColDef().showRowGroup;
        return s || l || u;
      });
    }
    const t = this.funcColsService.getRowGroupColumns().filter((o) => !!o.getSort()), r = {};
    e.forEach((o, a) => r[o.getId()] = a), e.sort((o, a) => {
      const s = o.getSortIndex(), l = a.getSortIndex();
      if (s != null && l != null)
        return s - l;
      if (s == null && l == null) {
        const u = r[o.getId()], c = r[a.getId()];
        return u > c ? 1 : -1;
      } else return l == null ? -1 : 1;
    });
    const n = this.gos.isColumnsSortingCoupledToGroup() && !!t.length;
    n && (e = [
      ...new Set(
        // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
        e.map((o) => {
          var a;
          return ((a = this.showRowGroupColsService) == null ? void 0 : a.getShowRowGroupCol(o.getId())) ?? o;
        })
      )
    ]);
    const i = /* @__PURE__ */ new Map();
    return e.forEach((o, a) => i.set(o, a)), n && t.forEach((o) => {
      const a = this.showRowGroupColsService.getShowRowGroupCol(o.getId());
      i.set(o, i.get(a));
    }), i;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([e, t], [r, n]) => t - n).map(([e]) => e);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      colId: e.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      column: e
    }));
  }
  canColumnDisplayMixedSort(e) {
    const t = this.gos.isColumnsSortingCoupledToGroup(), r = !!e.getColDef().showRowGroup;
    return t && r;
  }
  getDisplaySortForColumn(e) {
    const t = this.funcColsService.getSourceColumnsForGroupColumn(e);
    if (!this.canColumnDisplayMixedSort(e) || !(t != null && t.length))
      return e.getSort();
    const n = e.getColDef().field != null || !!e.getColDef().valueGetter ? [e, ...t] : t, i = n[0].getSort();
    return n.every((a) => a.getSort() == i) ? i : "mixed";
  }
  getDisplaySortIndexForColumn(e) {
    return this.getIndexedSortMap().get(e);
  }
}, h6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "syncService", this.waitingForColumns = !1;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (e) => this.setColumnDefs(e));
  }
  start() {
    this.ctrlsService.whenReady(() => {
      const e = this.gos.get("columnDefs");
      e ? this.setColumnsAndData(e) : this.waitingForColumns = !0, this.gridReady();
    });
  }
  setColumnsAndData(e) {
    this.columnModel.setColumnDefs(e ?? [], "gridInitializing"), this.rowModel.start();
  }
  gridReady() {
    this.dispatchGridReadyEvent();
    const e = ci.__isRegistered("@ag-grid-enterprise/core", this.gridId);
    this.gos.get("debug") && Ea(`initialised successfully, enterprise = ${e}`);
  }
  dispatchGridReadyEvent() {
    const e = {
      type: "gridReady"
    };
    this.eventService.dispatchEvent(e);
  }
  setColumnDefs(e) {
    const t = this.gos.get("columnDefs");
    if (t) {
      if (this.waitingForColumns) {
        this.waitingForColumns = !1, this.setColumnsAndData(t);
        return;
      }
      this.columnModel.setColumnDefs(t, Ch(e.source));
    }
  }
}, f6e = "paste", p6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "changeDetectionService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer;
  }
  postConstruct() {
    this.rowModel.getType() === "clientSide" && (this.clientSideRowModel = this.rowModel), this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
  }
  onCellValueChanged(e) {
    e.source !== f6e && this.doChangeDetection(e.node, e.column);
  }
  doChangeDetection(e, t) {
    if (this.gos.get("suppressChangeDetection"))
      return;
    const r = [e];
    if (this.clientSideRowModel && !e.isRowPinned()) {
      const n = this.gos.get("aggregateOnlyChangedColumns"), i = new Hw(n, this.clientSideRowModel.getRootNode());
      i.addParentNode(e.parent, [t]), this.clientSideRowModel.doAggregate(i), i.forEachChangedNodeDepthFirst((o) => {
        r.push(o);
      });
    }
    this.rowRenderer.refreshCells({ rowNodes: r });
  }
}, g6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "expressionService", this.expressionToFunctionCache = {};
  }
  evaluate(e, t) {
    if (typeof e == "string")
      return this.evaluateExpression(e, t);
    Er("value should be either a string or a function", e);
  }
  evaluateExpression(e, t) {
    try {
      return this.createExpressionFunction(e)(
        t.value,
        t.context,
        t.oldValue,
        t.newValue,
        t.value,
        t.node,
        t.data,
        t.colDef,
        t.rowIndex,
        t.api,
        t.getValue,
        t.column,
        t.columnGroup
      );
    } catch (r) {
      return Ea("Processing of the expression failed"), Ea("Expression = ", e), Ea("Params = ", t), Ea("Exception = ", r), null;
    }
  }
  createExpressionFunction(e) {
    if (this.expressionToFunctionCache[e])
      return this.expressionToFunctionCache[e];
    const t = this.createFunctionBody(e), r = new Function(
      "x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup",
      t
    );
    return this.expressionToFunctionCache[e] = r, r;
  }
  createFunctionBody(e) {
    return e.indexOf("return") >= 0 ? e : "return " + e + ";";
  }
}, v6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "valueCache", this.cacheVersion = 0;
  }
  postConstruct() {
    this.active = this.gos.get("valueCache"), this.neverExpires = this.gos.get("valueCacheNeverExpires");
  }
  onDataChanged() {
    this.neverExpires || this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(e, t, r) {
    this.active && (e.__cacheVersion !== this.cacheVersion && (e.__cacheVersion = this.cacheVersion, e.__cacheData = {}), e.__cacheData[t] = r);
  }
  getValue(e, t) {
    if (!(!this.active || e.__cacheVersion !== this.cacheVersion))
      return e.__cacheData[t];
  }
}, m6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "valueService", this.initialised = !1, this.isSsrm = !1;
  }
  wireBeans(e) {
    this.expressionService = e.expressionService, this.columnModel = e.columnModel, this.valueCache = e.valueCache, this.dataTypeService = e.dataTypeService;
  }
  postConstruct() {
    this.initialised || this.init();
  }
  init() {
    this.isSsrm = this.gos.isRowModelType("serverSide"), this.cellExpressions = this.gos.get("enableCellExpressions"), this.isTreeData = this.gos.get("treeData"), this.initialised = !0;
    const e = (r) => this.callColumnCellValueChangedHandler(r), t = this.gos.useAsyncEvents();
    this.eventService.addEventListener("cellValueChanged", e, t), this.addDestroyFunc(() => this.eventService.removeEventListener("cellValueChanged", e, t)), this.addManagedPropertyListener("treeData", (r) => this.isTreeData = r.currentValue);
  }
  getValue(e, t, r = !1, n = !1) {
    if (this.initialised || this.init(), !t)
      return;
    const i = e.getColDef(), o = i.field, a = e.getColId(), s = t.data;
    let l;
    const u = t.groupData && t.groupData[a] !== void 0, c = !n && t.aggData && t.aggData[a] !== void 0, d = this.isSsrm && n && !!e.getColDef().aggFunc, h = this.isSsrm && t.footer && t.field && (e.getColDef().showRowGroup === !0 || e.getColDef().showRowGroup === t.field);
    if (r && i.filterValueGetter ? l = this.executeFilterValueGetter(i.filterValueGetter, s, e, t) : this.isTreeData && c ? l = t.aggData[a] : this.isTreeData && i.valueGetter ? l = this.executeValueGetter(i.valueGetter, s, e, t) : this.isTreeData && o && s ? l = mg(s, o, e.isFieldContainsDots()) : u ? l = t.groupData[a] : c ? l = t.aggData[a] : i.valueGetter ? l = this.executeValueGetter(i.valueGetter, s, e, t) : h ? l = mg(s, t.field, e.isFieldContainsDots()) : o && s && !d && (l = mg(s, o, e.isFieldContainsDots())), this.cellExpressions && typeof l == "string" && l.indexOf("=") === 0) {
      const f = l.substring(1);
      l = this.executeValueGetter(f, s, e, t);
    }
    if (l == null) {
      const f = this.getOpenedGroup(t, e);
      if (f != null)
        return f;
    }
    return l;
  }
  parseValue(e, t, r, n) {
    const i = e.getColDef(), o = this.gos.addGridCommonParams({
      node: t,
      data: t == null ? void 0 : t.data,
      oldValue: n,
      newValue: r,
      colDef: i,
      column: e
    }), a = i.valueParser;
    return ke(a) ? typeof a == "function" ? a(o) : this.expressionService.evaluate(a, o) : r;
  }
  formatValue(e, t, r, n, i = !0) {
    let o = null, a;
    const s = e.getColDef();
    if (n ? a = n : i && (a = s.valueFormatter), a) {
      const l = this.gos.addGridCommonParams({
        value: r,
        node: t,
        data: t ? t.data : null,
        colDef: s,
        column: e
      });
      typeof a == "function" ? o = a(l) : o = this.expressionService.evaluate(a, l);
    } else if (s.refData)
      return s.refData[r] || "";
    return o == null && Array.isArray(r) && (o = r.join(", ")), o;
  }
  getOpenedGroup(e, t) {
    if (!this.gos.get("showOpenedGroup") || !t.getColDef().showRowGroup)
      return;
    const n = t.getColDef().showRowGroup;
    let i = e.parent;
    for (; i != null; ) {
      if (i.rowGroupColumn && (n === !0 || n === i.rowGroupColumn.getColId()))
        return i.key;
      i = i.parent;
    }
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(e, t, r, n) {
    const i = this.columnModel.getColDefCol(t);
    if (!e || !i)
      return !1;
    dr(e.data) && (e.data = {});
    const { field: o, valueSetter: a } = i.getColDef();
    if (dr(o) && dr(a))
      return Te("you need either field or valueSetter set on colDef for editing to work"), !1;
    if (this.dataTypeService && !this.dataTypeService.checkType(i, r))
      return Te("Data type of the new value does not match the cell data type of the column"), !1;
    const s = this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      oldValue: this.getValue(i, e),
      newValue: r,
      colDef: i.getColDef(),
      column: i
    });
    s.newValue = r;
    let l;
    if (ke(a) ? typeof a == "function" ? l = a(s) : l = this.expressionService.evaluate(a, s) : l = this.setValueUsingField(e.data, o, r, i.isFieldContainsDots()), l === void 0 && (l = !0), !l)
      return !1;
    e.resetQuickFilterAggregateText(), this.valueCache.onDataChanged(), s.newValue = this.getValue(i, e);
    const u = {
      type: "cellValueChanged",
      event: null,
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: s.column,
      api: s.api,
      colDef: s.colDef,
      context: s.context,
      data: e.data,
      node: e,
      oldValue: s.oldValue,
      newValue: s.newValue,
      value: s.newValue,
      source: n
    };
    return this.eventService.dispatchEvent(u), !0;
  }
  callColumnCellValueChangedHandler(e) {
    const t = e.colDef.onCellValueChanged;
    typeof t == "function" && this.getFrameworkOverrides().wrapOutgoing(() => {
      t({
        node: e.node,
        data: e.data,
        oldValue: e.oldValue,
        newValue: e.newValue,
        colDef: e.colDef,
        column: e.column,
        api: e.api,
        context: e.context
      });
    });
  }
  setValueUsingField(e, t, r, n) {
    if (!t)
      return !1;
    let i = !1;
    if (!n)
      i = e[t] === r, i || (e[t] = r);
    else {
      const o = t.split(".");
      let a = e;
      for (; o.length > 0 && a; ) {
        const s = o.shift();
        o.length === 0 ? (i = a[s] === r, i || (a[s] = r)) : a = a[s];
      }
    }
    return !i;
  }
  executeFilterValueGetter(e, t, r, n) {
    const i = this.gos.addGridCommonParams({
      data: t,
      node: n,
      column: r,
      colDef: r.getColDef(),
      getValue: this.getValueCallback.bind(this, n)
    });
    return typeof e == "function" ? e(i) : this.expressionService.evaluate(e, i);
  }
  executeValueGetter(e, t, r, n) {
    const i = r.getColId(), o = this.valueCache.getValue(n, i);
    if (o !== void 0)
      return o;
    const a = this.gos.addGridCommonParams({
      data: t,
      node: n,
      column: r,
      colDef: r.getColDef(),
      getValue: this.getValueCallback.bind(this, n)
    });
    let s;
    return typeof e == "function" ? s = e(a) : s = this.expressionService.evaluate(e, a), this.valueCache.setValue(n, i, s), s;
  }
  getValueCallback(e, t) {
    const r = this.columnModel.getColDefCol(t);
    return r ? this.getValue(r, e) : null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(e, t) {
    const r = this.getValue(e, t), n = e.getColDef().keyCreator;
    let i = r;
    if (n) {
      const o = this.gos.addGridCommonParams({
        value: r,
        colDef: e.getColDef(),
        column: e,
        node: t,
        data: t.data
      });
      i = n(o);
    }
    return typeof i == "string" || i == null || (i = String(i), i === "[object Object]" && Te(
      "a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key"
    )), i;
  }
}, vP = class {
};
vP.gridOptions = void 0;
var y6e = 1, C6e = class {
  create(e, t, r, n, i) {
    let o = {};
    vP.gridOptions ? (jo(o, vP.gridOptions, !0, !0), o = { ...o, ...t }) : o = t;
    const a = X3e(o), s = a.gridId ?? String(y6e++), l = this.getRegisteredModules(i, s), u = this.createBeansList(a.rowModelType, l, s), c = this.createProvidedBeans(e, a, i);
    if (!u) {
      Er("Failed to create grid.");
      return;
    }
    const d = {
      providedBeanInstances: c,
      beanClasses: u,
      gridId: s,
      beanInitComparator: Lze,
      beanDestroyComparator: Fze,
      derivedBeans: [Rze]
    }, h = new V4e(d);
    return this.registerModuleUserComponents(h, l), this.registerControllers(h, l), this.registerModuleApiFunctions(h, l), r(h), h.getBean("syncService").start(), n && n(h), h.getBean("gridApi");
  }
  registerControllers(e, t) {
    const r = e.getBean("ctrlsFactory");
    t.forEach((n) => {
      n.controllers && n.controllers.forEach((i) => r.register(i));
    });
  }
  getRegisteredModules(e, t) {
    const r = e ? e.modules : null, n = ci.__getRegisteredModules(t), i = [], o = {}, a = (s, l, u) => {
      ((d) => {
        o[d.moduleName] || (o[d.moduleName] = !0, i.push(d), ci.__register(d, s, u));
      })(l), l.dependantModules && l.dependantModules.forEach((d) => a(s, d, u));
    };
    return a(
      !!(r != null && r.length) || !ci.__isPackageBased(),
      lX,
      void 0
    ), r && r.forEach((s) => a(!0, s, t)), n && n.forEach((s) => a(!ci.__isPackageBased(), s, void 0)), i;
  }
  registerModuleUserComponents(e, t) {
    const r = this.extractModuleEntity(
      t,
      (i) => i.userComponents ? i.userComponents : []
    ), n = e.getBean("userComponentRegistry");
    r.forEach((i) => {
      n.registerDefaultComponent(i.name, i.classImp);
    });
  }
  registerModuleApiFunctions(e, t) {
    const r = e.getBean("apiFunctionService");
    t.forEach((n) => {
      const i = n.apiFunctions ?? {};
      Object.keys(i).forEach((a) => {
        r == null || r.addFunction(a, i[a]);
      });
    });
  }
  createProvidedBeans(e, t, r) {
    let n = r ? r.frameworkOverrides : null;
    dr(n) && (n = new tX());
    const i = {
      gridOptions: t,
      eGridDiv: e,
      globalEventListener: r ? r.globalEventListener : null,
      globalSyncEventListener: r ? r.globalSyncEventListener : null,
      frameworkOverrides: n
    };
    return r && r.providedBeanInstances && Object.assign(i, r.providedBeanInstances), i;
  }
  createBeansList(e = "clientSide", t, r) {
    const n = t.filter(
      (l) => !l.rowModel || l.rowModel === e
    ), i = {
      clientSide: "@ag-grid-community/client-side-row-model",
      infinite: "@ag-grid-community/infinite-row-model",
      serverSide: "@ag-grid-enterprise/server-side-row-model",
      viewport: "@ag-grid-enterprise/viewport-row-model"
      /* ViewportRowModelModule */
    };
    if (!i[e]) {
      Er("Could not find row model for rowModelType = ", e);
      return;
    }
    if (!ci.__assertRegistered(
      i[e],
      `rowModelType = '${e}'`,
      r
    ))
      return;
    const o = [
      $ze,
      Vze,
      Q3e,
      K3e,
      xze,
      C4e,
      Aze,
      Ize,
      yGe,
      uq,
      l6e,
      gGe,
      J3e,
      uze,
      z4e,
      wBe,
      zze,
      Z3e,
      Cze,
      hX,
      lBe,
      J$e,
      r6e,
      t6e,
      sze,
      g6e,
      sBe,
      pGe,
      v6e,
      m6e,
      oze,
      vGe,
      $4e,
      Wze,
      fGe,
      Hze,
      wze,
      pze,
      hGe,
      d6e,
      o6e,
      i6e,
      c6e,
      p6e,
      CGe,
      _ze,
      s6e,
      u6e,
      kze,
      jze,
      Bze,
      Nze,
      h6e,
      a6e,
      SGe,
      e6e,
      n6e,
      wGe,
      fBe,
      Tze,
      pBe,
      dBe,
      Pze,
      Mze,
      SBe,
      hBe,
      yBe,
      Dze,
      CBe
    ], a = this.extractModuleEntity(n, (l) => l.beans ? l.beans : []);
    o.push(...a);
    const s = [];
    return o.forEach((l) => {
      s.indexOf(l) < 0 && s.push(l);
    }), s;
  }
  extractModuleEntity(e, t) {
    return [].concat(...e.map(t));
  }
}, fX = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowModelHelperService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    const e = this.rowModel;
    switch (e.getType()) {
      case "clientSide":
        this.clientSideRowModel = e;
        break;
      case "infinite":
        this.infiniteRowModel = e;
        break;
      case "serverSide":
        this.serverSideRowModel = e;
        break;
    }
  }
  getClientSideRowModel() {
    return this.clientSideRowModel;
  }
  getInfiniteRowModel() {
    return this.infiniteRowModel;
  }
  getServerSideRowModel() {
    return this.serverSideRowModel;
  }
};
function S6e(e) {
  e.expansionService.expandAll(!0);
}
function w6e(e) {
  e.expansionService.expandAll(!1);
}
function b6e(e) {
  var n, i;
  const t = (n = e.rowModelHelperService) == null ? void 0 : n.getClientSideRowModel(), r = (i = e.rowModelHelperService) == null ? void 0 : i.getServerSideRowModel();
  t ? t.onRowHeightChanged() : r && r.onRowHeightChanged();
}
function x6e(e, t, r) {
  var o, a;
  const n = (o = e.rowModelHelperService) == null ? void 0 : o.getServerSideRowModel();
  if (n) {
    if (e.funcColsService.isRowGroupEmpty()) {
      n.setRowCount(t, r);
      return;
    }
    Er("setRowCount cannot be used while using row grouping.");
    return;
  }
  const i = (a = e.rowModelHelperService) == null ? void 0 : a.getInfiniteRowModel();
  if (i) {
    i.setRowCount(t, r);
    return;
  }
}
function E6e(e) {
  var t;
  return ((t = e.rowNodeBlockLoader) == null ? void 0 : t.getBlockState()) ?? {};
}
var R6e = {
  version: kt,
  moduleName: "@ag-grid-community/csrm-ssrm-shared-api",
  apiFunctions: {
    expandAll: S6e,
    collapseAll: w6e,
    onRowHeightChanged: b6e
  }
}, _6e = {
  version: kt,
  moduleName: "@ag-grid-community/ssrm-infinite-shared-api",
  apiFunctions: {
    setRowCount: x6e,
    getCacheBlockState: E6e
  }
}, T6e = class {
  wrap(e, t, r = [], n) {
    const i = this.createWrapper(e, n);
    return t.forEach((o) => {
      this.createMethod(i, o, !0);
    }), r.forEach((o) => {
      this.createMethod(i, o, !1);
    }), i;
  }
  unwrap(e) {
    return e;
  }
  createMethod(e, t, r) {
    e.addMethod(t, this.createMethodProxy(e, t, r));
  }
  createMethodProxy(e, t, r) {
    return function() {
      return e.hasMethod(t) ? e.callMethod(t, arguments) : (r && Te("Framework component is missing the method " + t + "()"), null);
    };
  }
};
function P6e(e, t) {
  if (!e)
    return !1;
  const r = (a, s) => {
    const l = t[a.id], u = t[s.id], c = l !== void 0, d = u !== void 0, h = c && d, f = !c && !d;
    return h ? l - u : f ? a.__objectId - s.__objectId : c ? 1 : -1;
  };
  let n, i, o = !1;
  for (let a = 0; a < e.length - 1; a++)
    if (n = e[a], i = e[a + 1], r(n, i) > 0) {
      o = !0;
      break;
    }
  return o ? (e.sort(r), !0) : !1;
}
var Lf = typeof global > "u" ? {} : global;
Lf.HTMLElement = typeof HTMLElement > "u" ? {} : HTMLElement;
Lf.HTMLButtonElement = typeof HTMLButtonElement > "u" ? {} : HTMLButtonElement;
Lf.HTMLSelectElement = typeof HTMLSelectElement > "u" ? {} : HTMLSelectElement;
Lf.HTMLInputElement = typeof HTMLInputElement > "u" ? {} : HTMLInputElement;
Lf.Node = typeof Node > "u" ? {} : Node;
Lf.MouseEvent = typeof MouseEvent > "u" ? {} : MouseEvent;
var M6e = "ROOT_NODE_ID", AE = 0, D6e = class {
  constructor(e, t, r, n, i, o) {
    this.nextId = 0, this.rowCountReady = !1, this.allNodesMap = {}, this.rootNode = e, this.gos = t, this.eventService = r, this.funcColsService = n, this.beans = o, this.selectionService = i, this.rootNode.group = !0, this.rootNode.level = -1, this.rootNode.id = M6e, this.rootNode.allLeafChildren = [], this.rootNode.childrenAfterGroup = [], this.rootNode.childrenAfterSort = [], this.rootNode.childrenAfterAggFilter = [], this.rootNode.childrenAfterFilter = [];
  }
  getCopyOfNodesMap() {
    return LY(this.allNodesMap);
  }
  getRowNode(e) {
    return this.allNodesMap[e];
  }
  setRowData(e) {
    if (typeof e == "string") {
      Te("rowData must be an array.");
      return;
    }
    this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(e);
    const t = this.rootNode, r = this.rootNode.sibling;
    t.childrenAfterFilter = null, t.childrenAfterGroup = null, t.childrenAfterAggFilter = null, t.childrenAfterSort = null, t.childrenMapped = null, t.updateHasChildren(), this.nextId = 0, this.allNodesMap = {}, e ? t.allLeafChildren = e.map((n) => this.createNode(n, this.rootNode, AE)) : (t.allLeafChildren = [], t.childrenAfterGroup = []), r && (r.childrenAfterFilter = t.childrenAfterFilter, r.childrenAfterGroup = t.childrenAfterGroup, r.childrenAfterAggFilter = t.childrenAfterAggFilter, r.childrenAfterSort = t.childrenAfterSort, r.childrenMapped = t.childrenMapped, r.allLeafChildren = t.allLeafChildren);
  }
  updateRowData(e, t) {
    this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(e.add);
    const r = {
      remove: [],
      update: [],
      add: []
    }, n = [];
    return this.executeRemove(e, r, n), this.executeUpdate(e, r, n), this.executeAdd(e, r), this.updateSelection(n, "rowDataChanged"), t && P6e(this.rootNode.allLeafChildren, t), r;
  }
  isRowCountReady() {
    return this.rowCountReady;
  }
  dispatchRowDataUpdateStartedEvent(e) {
    const t = {
      type: "rowDataUpdateStarted",
      firstRowData: e != null && e.length ? e[0] : null
    };
    this.eventService.dispatchEvent(t);
  }
  updateSelection(e, t) {
    const r = e.length > 0;
    if (r && this.selectionService.setNodesSelected({
      newValue: !1,
      nodes: e,
      suppressFinishActions: !0,
      source: t
    }), this.selectionService.updateGroupsFromChildrenSelections(t), r) {
      const n = {
        type: "selectionChanged",
        source: t
      };
      this.eventService.dispatchEvent(n);
    }
  }
  executeAdd(e, t) {
    var a;
    const { add: r, addIndex: n } = e;
    if (Wn(r))
      return;
    const i = r.map((s) => this.createNode(s, this.rootNode, AE)), o = this.rootNode.allLeafChildren;
    if (typeof n == "number" && n >= 0) {
      const s = o.length;
      let l = n;
      if (this.gos.get("treeData") && n > 0 && s > 0) {
        for (let h = 0; h < s; h++)
          if (((a = o[h]) == null ? void 0 : a.rowIndex) == n - 1) {
            l = h + 1;
            break;
          }
      }
      const c = o.slice(0, l), d = o.slice(l, o.length);
      this.rootNode.allLeafChildren = [...c, ...i, ...d];
    } else
      this.rootNode.allLeafChildren = [...o, ...i];
    this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = o), t.add = i;
  }
  executeRemove(e, t, r) {
    var o;
    const { remove: n } = e;
    if (Wn(n))
      return;
    const i = {};
    n.forEach((a) => {
      const s = this.lookupRowNode(a);
      s && (s.isSelected() && r.push(s), s.clearRowTopAndRowIndex(), i[s.id] = !0, delete this.allNodesMap[s.id], t.remove.push(s));
    }), this.rootNode.allLeafChildren = ((o = this.rootNode.allLeafChildren) == null ? void 0 : o.filter((a) => !i[a.id])) ?? null, this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren);
  }
  executeUpdate(e, t, r) {
    const { update: n } = e;
    Wn(n) || n.forEach((i) => {
      const o = this.lookupRowNode(i);
      o && (o.updateData(i), !o.selectable && o.isSelected() && r.push(o), this.setMasterForRow(o, i, AE, !1), t.update.push(o));
    });
  }
  lookupRowNode(e) {
    var n;
    const t = this.gos.getRowIdCallback();
    let r;
    if (t) {
      const i = t({ data: e, level: 0 });
      if (r = this.allNodesMap[i], !r)
        return Er(`could not find row id=${i}, data item was not found for this id`), null;
    } else if (r = (n = this.rootNode.allLeafChildren) == null ? void 0 : n.find((i) => i.data === e), !r)
      return Er("could not find data item as object was not found", e), Er("Consider using getRowId to help the Grid find matching row data"), null;
    return r || null;
  }
  createNode(e, t, r) {
    const n = new Ks(this.beans);
    return n.group = !1, this.setMasterForRow(n, e, r, !0), t && (n.parent = t), n.level = r, n.setDataAndId(e, this.nextId.toString()), this.allNodesMap[n.id] && Te(
      `duplicate node id '${n.id}' detected from getRowId callback, this could cause issues in your grid.`
    ), this.allNodesMap[n.id] = n, this.nextId++, n;
  }
  setMasterForRow(e, t, r, n) {
    if (this.gos.get("treeData"))
      e.setMaster(!1), n && (e.expanded = !1);
    else {
      if (this.gos.get("masterDetail")) {
        const a = this.gos.get("isRowMaster");
        a ? e.setMaster(a(t)) : e.setMaster(!0);
      } else
        e.setMaster(!1);
      if (n) {
        const a = this.funcColsService.getRowGroupColumns(), s = a ? a.length : 0, l = r + s;
        e.expanded = e.master ? this.isExpanded(l) : !1;
      }
    }
  }
  isExpanded(e) {
    const t = this.gos.get("groupDefaultExpanded");
    return t === -1 ? !0 : e < t;
  }
}, A6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.onRowHeightChanged_debounced = Ti(this.onRowHeightChanged.bind(this), 100), this.rowsToDisplay = [], this.hasStarted = !1, this.shouldSkipSettingDataOnStart = !1, this.isRefreshingModel = !1, this.rowCountReady = !1;
  }
  wireBeans(e) {
    this.beans = e, this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.selectionService = e.selectionService, this.valueCache = e.valueCache, this.environment = e.environment, this.filterStage = e.filterStage, this.sortStage = e.sortStage, this.flattenStage = e.flattenStage, this.groupStage = e.groupStage, this.aggregationStage = e.aggregationStage, this.pivotStage = e.pivotStage, this.filterAggregatesStage = e.filterAggregatesStage;
  }
  postConstruct() {
    const e = this.refreshModel.bind(this, {
      step: "group"
      /* EVERYTHING */
    }), t = !this.gos.get("suppressAnimationFrame"), r = this.refreshModel.bind(this, {
      step: "group",
      // after cols change, row grouping (the first stage) could of changed
      afterColumnsChanged: !0,
      keepRenderedRows: !0,
      // we want animations cos sorting or filtering could be applied
      animate: t
    });
    this.addManagedEventListeners({
      newColumnsLoaded: r,
      columnRowGroupChanged: e,
      columnValueChanged: this.onValueChanged.bind(this),
      columnPivotChanged: this.refreshModel.bind(this, {
        step: "pivot"
        /* PIVOT */
      }),
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      columnPivotModeChanged: e,
      gridStylesChanged: this.onGridStylesChanges.bind(this),
      gridReady: this.onGridReady.bind(this)
    }), this.addPropertyListeners(), this.rootNode = new Ks(this.beans), this.nodeManager = new D6e(
      this.rootNode,
      this.gos,
      this.eventService,
      this.funcColsService,
      this.selectionService,
      this.beans
    );
  }
  addPropertyListeners() {
    const e = /* @__PURE__ */ new Set(["treeData", "masterDetail"]), t = /* @__PURE__ */ new Set([
      "groupDefaultExpanded",
      "groupAllowUnbalanced",
      "initialGroupOrderComparator",
      "groupHideOpenParents",
      "groupDisplayType"
    ]), r = /* @__PURE__ */ new Set(["excludeChildrenWhenTreeDataFiltering"]), n = /* @__PURE__ */ new Set([
      "removePivotHeaderRowWhenSingleValueColumn",
      "pivotRowTotals",
      "pivotColumnGroupTotals",
      "suppressExpandablePivotGroups"
    ]), i = /* @__PURE__ */ new Set([
      "getGroupRowAgg",
      "alwaysAggregateAtRootLevel",
      "groupIncludeTotalFooter",
      "suppressAggFilteredOnly",
      "grandTotalRow"
    ]), o = /* @__PURE__ */ new Set([
      "postSortRows",
      "groupDisplayType",
      "accentedSort"
    ]), a = /* @__PURE__ */ new Set([]), s = /* @__PURE__ */ new Set([
      "groupRemoveSingleChildren",
      "groupRemoveLowestSingleChildren",
      "groupIncludeFooter",
      "groupTotalRow"
    ]), l = [
      ...e,
      ...t,
      ...r,
      ...n,
      ...n,
      ...i,
      ...o,
      ...a,
      ...s
    ];
    this.addManagedPropertyListeners(l, (u) => {
      var h;
      const c = (h = u.changeSet) == null ? void 0 : h.properties;
      if (!c)
        return;
      const d = (f) => c.some((p) => f.has(p));
      if (d(e)) {
        this.setRowData(this.rootNode.allLeafChildren.map((f) => f.data));
        return;
      }
      if (d(t)) {
        this.refreshModel({
          step: "group"
          /* EVERYTHING */
        });
        return;
      }
      if (d(r)) {
        this.refreshModel({
          step: "filter"
          /* FILTER */
        });
        return;
      }
      if (d(n)) {
        this.refreshModel({
          step: "pivot"
          /* PIVOT */
        });
        return;
      }
      if (d(i)) {
        this.refreshModel({
          step: "aggregate"
          /* AGGREGATE */
        });
        return;
      }
      if (d(o)) {
        this.refreshModel({
          step: "sort"
          /* SORT */
        });
        return;
      }
      if (d(a)) {
        this.refreshModel({
          step: "filter_aggregates"
          /* FILTER_AGGREGATES */
        });
        return;
      }
      d(s) && this.refreshModel({
        step: "map"
        /* MAP */
      });
    }), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
  }
  start() {
    this.hasStarted = !0, this.shouldSkipSettingDataOnStart ? this.dispatchUpdateEventsAndRefresh() : this.setInitialData();
  }
  setInitialData() {
    const e = this.gos.get("rowData");
    e && (this.shouldSkipSettingDataOnStart = !0, this.setRowData(e));
  }
  ensureRowHeightsValid(e, t, r, n) {
    let i, o = !1;
    do {
      i = !1;
      const a = this.getRowIndexAtPixel(e), s = this.getRowIndexAtPixel(t), l = Math.max(a, r), u = Math.min(s, n);
      for (let c = l; c <= u; c++) {
        const d = this.getRow(c);
        if (d.rowHeightEstimated) {
          const h = this.gos.getRowHeightForNode(d);
          d.setRowHeight(h.height), i = !0, o = !0;
        }
      }
      i && this.setRowTopAndRowIndex();
    } while (i);
    return o;
  }
  setRowTopAndRowIndex() {
    const e = this.environment.getDefaultRowHeight();
    let t = 0;
    const r = /* @__PURE__ */ new Set(), n = this.gos.isDomLayout("normal");
    for (let i = 0; i < this.rowsToDisplay.length; i++) {
      const o = this.rowsToDisplay[i];
      if (o.id != null && r.add(o.id), o.rowHeight == null) {
        const a = this.gos.getRowHeightForNode(o, n, e);
        o.setRowHeight(a.height, a.estimated);
      }
      o.setRowTop(t), o.setRowIndex(i), t += o.rowHeight;
    }
    return r;
  }
  clearRowTopAndRowIndex(e, t) {
    const r = e.isActive(), n = (o) => {
      o && o.id != null && !t.has(o.id) && o.clearRowTopAndRowIndex();
    }, i = (o) => {
      if (n(o), n(o.detailNode), n(o.sibling), o.hasChildren() && o.childrenAfterGroup) {
        const a = o.level == -1;
        r && !a && !o.expanded || o.childrenAfterGroup.forEach(i);
      }
    };
    i(this.rootNode);
  }
  // returns false if row was moved, otherwise true
  ensureRowsAtPixel(e, t, r = 0) {
    const n = this.getRowIndexAtPixel(t), i = this.getRow(n), o = !this.gos.get("suppressAnimationFrame");
    return i === e[0] ? !1 : (e.forEach((a) => {
      _i(this.rootNode.allLeafChildren, a);
    }), e.forEach((a, s) => {
      QC(this.rootNode.allLeafChildren, a, Math.max(n + r, 0) + s);
    }), this.refreshModel({
      step: "group",
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: o
    }), !0);
  }
  highlightRowAtPixel(e, t) {
    const r = t != null ? this.getRowIndexAtPixel(t) : null, n = r != null ? this.getRow(r) : null;
    if (!n || !e || n === e || t == null) {
      this.lastHighlightedRow && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null);
      return;
    }
    const i = this.getHighlightPosition(t, n);
    this.lastHighlightedRow && this.lastHighlightedRow !== n && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null), n.setHighlighted(i), this.lastHighlightedRow = n;
  }
  getHighlightPosition(e, t) {
    if (!t) {
      const i = this.getRowIndexAtPixel(e);
      if (t = this.getRow(i || 0), !t)
        return 1;
    }
    const { rowTop: r, rowHeight: n } = t;
    return e - r < n / 2 ? 0 : 1;
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isLastRowIndexKnown() {
    return !0;
  }
  getRowCount() {
    return this.rowsToDisplay ? this.rowsToDisplay.length : 0;
  }
  getTopLevelRowCount() {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return 1;
    const t = this.rootNode.sibling ? 1 : 0, r = this.rootNode.childrenAfterAggFilter;
    return (r ? r.length : 0) + t;
  }
  getTopLevelRowDisplayedIndex(e) {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return e;
    let r = e;
    if (this.rowsToDisplay[0].footer) {
      if (e === 0)
        return 0;
      r -= 1;
    }
    let n = this.rootNode.childrenAfterSort[r];
    if (this.gos.get("groupHideOpenParents"))
      for (; n.expanded && n.childrenAfterSort && n.childrenAfterSort.length > 0; )
        n = n.childrenAfterSort[0];
    return n.rowIndex;
  }
  getRowBounds(e) {
    if (dr(this.rowsToDisplay))
      return null;
    const t = this.rowsToDisplay[e];
    return t ? {
      rowTop: t.rowTop,
      rowHeight: t.rowHeight
    } : null;
  }
  onRowGroupOpened() {
    const e = this.gos.isAnimateRows();
    this.refreshModel({ step: "map", keepRenderedRows: !0, animate: e });
  }
  onFilterChanged(e) {
    if (e.afterDataChange)
      return;
    const t = this.gos.isAnimateRows(), n = e.columns.length === 0 || e.columns.some((i) => i.isPrimary()) ? "filter" : "filter_aggregates";
    this.refreshModel({ step: n, keepRenderedRows: !0, animate: t });
  }
  onSortChanged() {
    const e = this.gos.isAnimateRows();
    this.refreshModel({
      step: "sort",
      keepRenderedRows: !0,
      animate: e,
      keepEditingRows: !0
    });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.columnModel.isPivotActive() ? this.refreshModel({
      step: "pivot"
      /* PIVOT */
    }) : this.refreshModel({
      step: "aggregate"
      /* AGGREGATE */
    });
  }
  createChangePath(e) {
    const t = Wn(e), r = new Hw(!1, this.rootNode);
    return (t || this.gos.get("treeData")) && r.setInactive(), r;
  }
  isSuppressModelUpdateAfterUpdateTransaction(e) {
    if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction") || e.rowNodeTransactions == null)
      return !1;
    const t = e.rowNodeTransactions.filter(
      (n) => n.add != null && n.add.length > 0 || n.remove != null && n.remove.length > 0
    );
    return t == null || t.length == 0;
  }
  buildRefreshModelParams(e) {
    let t = "group";
    const r = {
      everything: "group",
      group: "group",
      filter: "filter",
      map: "map",
      aggregate: "aggregate",
      sort: "sort",
      pivot: "pivot"
      /* PIVOT */
    };
    if (ke(e) && (t = r[e]), dr(t)) {
      Er(`invalid step ${e}, available steps are ${Object.keys(r).join(", ")}`);
      return;
    }
    const n = !this.gos.get("suppressAnimationFrame");
    return {
      step: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: n
    };
  }
  refreshModel(e) {
    if (!this.hasStarted || this.isRefreshingModel || this.columnModel.isChangeEventsDispatching())
      return;
    const t = typeof e == "object" && "step" in e ? e : this.buildRefreshModelParams(e);
    if (!t || this.isSuppressModelUpdateAfterUpdateTransaction(t))
      return;
    const r = this.createChangePath(t.rowNodeTransactions);
    switch (this.isRefreshingModel = !0, t.step) {
      case "group":
        this.doRowGrouping(
          t.rowNodeTransactions,
          t.rowNodeOrder,
          r,
          !!t.afterColumnsChanged
        );
      case "filter":
        this.doFilter(r);
      case "pivot":
        this.doPivot(r);
      case "aggregate":
        this.doAggregate(r);
      case "filter_aggregates":
        this.doFilterAggregates(r);
      case "sort":
        this.doSort(t.rowNodeTransactions, r);
      case "map":
        this.doRowsToDisplay();
    }
    const n = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(r, n), this.isRefreshingModel = !1;
    const i = {
      type: "modelUpdated",
      animate: t.animate,
      keepRenderedRows: t.keepRenderedRows,
      newData: t.newData,
      newPage: !1,
      keepUndoRedoStack: t.keepUndoRedoStack
    };
    this.eventService.dispatchEvent(i);
  }
  isEmpty() {
    const e = dr(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
    return dr(this.rootNode) || e || !this.columnModel.isReady();
  }
  isRowsToRender() {
    return ke(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(e, t) {
    let r = !1, n = !1;
    const i = [], o = this.gos.get("groupSelectsChildren");
    return this.forEachNodeAfterFilterAndSort((a) => {
      if (n)
        return;
      if (r && (a === t || a === e) && (n = !0, a.group && o)) {
        i.push(...a.allLeafChildren);
        return;
      }
      if (!r) {
        if (a !== t && a !== e)
          return;
        r = !0;
      }
      if (!a.group || !o) {
        i.push(a);
        return;
      }
    }), i;
  }
  // eslint-disable-next-line
  setDatasource(e) {
    Er("should never call setDatasource on clientSideRowController");
  }
  getTopLevelNodes() {
    return this.rootNode ? this.rootNode.childrenAfterGroup : null;
  }
  getRootNode() {
    return this.rootNode;
  }
  getRow(e) {
    return this.rowsToDisplay[e];
  }
  isRowPresent(e) {
    return this.rowsToDisplay.indexOf(e) >= 0;
  }
  getRowIndexAtPixel(e) {
    if (this.isEmpty() || this.rowsToDisplay.length === 0)
      return -1;
    let t = 0, r = this.rowsToDisplay.length - 1;
    if (e <= 0)
      return 0;
    if (gr(this.rowsToDisplay).rowTop <= e)
      return this.rowsToDisplay.length - 1;
    let i = -1, o = -1;
    for (; ; ) {
      const a = Math.floor((t + r) / 2), s = this.rowsToDisplay[a];
      if (this.isRowInPixel(s, e) || (s.rowTop < e ? t = a + 1 : s.rowTop > e && (r = a - 1), i === t && o === r))
        return a;
      i = t, o = r;
    }
  }
  isRowInPixel(e, t) {
    const r = e.rowTop, n = e.rowTop + e.rowHeight;
    return r <= t && n > t;
  }
  forEachLeafNode(e) {
    this.rootNode.allLeafChildren && this.rootNode.allLeafChildren.forEach((t, r) => e(t, r));
  }
  forEachNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterGroup || []],
      callback: e,
      recursionType: 0,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilter(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterAggFilter || []],
      callback: e,
      recursionType: 1,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterSort || []],
      callback: e,
      recursionType: 2,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachPivotNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [this.rootNode],
      callback: e,
      recursionType: 3,
      index: 0,
      includeFooterNodes: t
    });
  }
  // iterates through each item in memory, and calls the callback function
  // nodes - the rowNodes to traverse
  // callback - the user provided callback
  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
  // index - works similar to the index in forEach in javascript's array function
  recursivelyWalkNodesAndCallback(e) {
    const { nodes: t, callback: r, recursionType: n, includeFooterNodes: i } = e;
    let { index: o } = e;
    const a = (s) => {
      var f;
      const l = (f = t[0]) == null ? void 0 : f.parent;
      if (!l)
        return;
      const u = i && this.gos.getGrandTotalRow(), c = this.gos.getGroupTotalRowCallback(), d = i && c({ node: l });
      if (l === this.rootNode) {
        u === s && (l.createFooter(), r(l.sibling, o++));
        return;
      }
      d === s && (l.createFooter(), r(l.sibling, o++));
    };
    a("top");
    for (let s = 0; s < t.length; s++) {
      const l = t[s];
      if (r(l, o++), l.hasChildren() && !l.footer) {
        let u = null;
        switch (n) {
          case 0:
            u = l.childrenAfterGroup;
            break;
          case 1:
            u = l.childrenAfterAggFilter;
            break;
          case 2:
            u = l.childrenAfterSort;
            break;
          case 3:
            u = l.leafGroup ? null : l.childrenAfterSort;
            break;
        }
        u && (o = this.recursivelyWalkNodesAndCallback({
          nodes: [...u],
          callback: r,
          recursionType: n,
          index: o,
          includeFooterNodes: i
        }));
      }
    }
    return a("bottom"), o;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  doAggregate(e) {
    var t;
    (t = this.aggregationStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doFilterAggregates(e) {
    this.filterAggregatesStage ? this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath: e }) : this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;
  }
  // + gridApi.expandAll()
  // + gridApi.collapseAll()
  expandOrCollapseAll(e) {
    const t = this.gos.get("treeData"), r = this.columnModel.isPivotActive(), n = (a) => {
      a && a.forEach((s) => {
        const l = () => {
          s.expanded = e, n(s.childrenAfterGroup);
        };
        if (t) {
          ke(s.childrenAfterGroup) && l();
          return;
        }
        if (r) {
          !s.leafGroup && l();
          return;
        }
        s.group && l();
      });
    };
    this.rootNode && n(this.rootNode.childrenAfterGroup), this.refreshModel({
      step: "map"
      /* MAP */
    });
    const o = {
      type: "expandOrCollapseAll",
      source: e ? "expandAll" : "collapseAll"
    };
    this.eventService.dispatchEvent(o);
  }
  doSort(e, t) {
    this.sortStage.execute({
      rowNode: this.rootNode,
      rowNodeTransactions: e,
      changedPath: t
    });
  }
  doRowGrouping(e, t, r, n) {
    if (this.groupStage) {
      if (e ? this.groupStage.execute({
        rowNode: this.rootNode,
        rowNodeTransactions: e,
        rowNodeOrder: t,
        changedPath: r
      }) : this.groupStage.execute({
        rowNode: this.rootNode,
        changedPath: r,
        afterColumnsChanged: n
      }), this.gos.get("groupSelectsChildren") && this.selectionService.updateGroupsFromChildrenSelections(
        "rowGroupChanged",
        r
      )) {
        const o = {
          type: "selectionChanged",
          source: "rowGroupChanged"
        };
        this.eventService.dispatchEvent(o);
      }
    } else
      this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren, this.rootNode.sibling && (this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup), this.rootNode.updateHasChildren();
    this.nodeManager.isRowCountReady() && (this.rowCountReady = !0, this.eventService.dispatchEventOnce({
      type: "rowCountReady"
    }));
  }
  doFilter(e) {
    this.filterStage.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doPivot(e) {
    var t;
    (t = this.pivotStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  getCopyOfNodesMap() {
    return this.nodeManager.getCopyOfNodesMap();
  }
  getRowNode(e) {
    if (typeof e == "string" && e.indexOf(Ks.ID_PREFIX_ROW_GROUP) == 0) {
      let r;
      return this.forEachNode((n) => {
        n.id === e && (r = n);
      }), r;
    }
    return this.nodeManager.getRowNode(e);
  }
  // rows: the rows to put into the model
  setRowData(e) {
    this.selectionService.reset("rowDataChanged"), this.nodeManager.setRowData(e), this.hasStarted && this.dispatchUpdateEventsAndRefresh();
  }
  dispatchUpdateEventsAndRefresh() {
    const e = {
      type: "rowDataUpdated"
    };
    this.eventService.dispatchEvent(e), this.refreshModel({
      step: "group",
      newData: !0
    });
  }
  batchUpdateRowData(e, t) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const r = this.gos.getAsyncTransactionWaitMillis();
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.executeBatchUpdateRowData();
      }, r);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t });
  }
  flushAsyncTransactions() {
    this.applyAsyncTransactionsTimeout != null && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData());
  }
  executeBatchUpdateRowData() {
    this.valueCache.onDataChanged();
    const e = [], t = [];
    let r = !1;
    if (this.rowDataTransactionBatch && this.rowDataTransactionBatch.forEach((n) => {
      const i = this.nodeManager.updateRowData(n.rowDataTransaction, void 0);
      t.push(i), n.callback && e.push(n.callback.bind(null, i)), typeof n.rowDataTransaction.addIndex == "number" && (r = !0);
    }), this.commonUpdateRowData(t, void 0, r), e.length > 0 && window.setTimeout(() => {
      e.forEach((n) => n());
    }, 0), t.length > 0) {
      const n = {
        type: "asyncTransactionsFlushed",
        results: t
      };
      this.eventService.dispatchEvent(n);
    }
    this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0;
  }
  updateRowData(e, t) {
    this.valueCache.onDataChanged();
    const r = this.nodeManager.updateRowData(e, t), n = typeof e.addIndex == "number";
    return this.commonUpdateRowData([r], t, n), r;
  }
  createRowNodeOrder() {
    if (this.gos.get("suppressMaintainUnsortedOrder"))
      return;
    const t = {};
    if (this.rootNode && this.rootNode.allLeafChildren)
      for (let r = 0; r < this.rootNode.allLeafChildren.length; r++) {
        const n = this.rootNode.allLeafChildren[r];
        t[n.id] = r;
      }
    return t;
  }
  // common to updateRowData and batchUpdateRowData
  commonUpdateRowData(e, t, r) {
    if (!this.hasStarted)
      return;
    const n = !this.gos.get("suppressAnimationFrame");
    r && (t = this.createRowNodeOrder());
    const i = {
      type: "rowDataUpdated"
    };
    this.eventService.dispatchEvent(i), this.refreshModel({
      step: "group",
      rowNodeTransactions: e,
      rowNodeOrder: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: n
    });
  }
  doRowsToDisplay() {
    this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });
  }
  onRowHeightChanged() {
    this.refreshModel({
      step: "map",
      keepRenderedRows: !0,
      keepEditingRows: !0,
      keepUndoRedoStack: !0
    });
  }
  /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  resetRowHeights() {
    const e = this.resetRowHeightsForAllRowNodes();
    this.rootNode.setRowHeight(this.rootNode.rowHeight, !0), this.rootNode.sibling && this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, !0), e && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      t.setRowHeight(t.rowHeight, !0);
      const r = t.detailNode;
      r && r.setRowHeight(r.rowHeight, !0), t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, !0), e = !0;
    }), e;
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      if (this.columnModel.isAutoRowHeightActive())
        return;
      this.resetRowHeights();
    }
  }
  onGridReady() {
    this.hasStarted || this.setInitialData();
  }
  isRowDataLoaded() {
    return this.rowCountReady;
  }
};
function I6e(e) {
  e.expansionService.onGroupExpandedOrCollapsed();
}
function O6e(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.refreshModel(t);
}
function L6e(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.forEachLeafNode(t);
}
function F6e(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.forEachNodeAfterFilter(t);
}
function N6e(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.forEachNodeAfterFilterAndSort(t);
}
function k6e(e) {
  var t, r;
  if (e.columnModel.isAutoRowHeightActive()) {
    Te("calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
    return;
  }
  (r = (t = e.rowModelHelperService) == null ? void 0 : t.getClientSideRowModel()) == null || r.resetRowHeights();
}
function V6e(e, t) {
  return e.frameworkOverrides.wrapIncoming(
    () => {
      var r, n;
      return (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null ? void 0 : n.updateRowData(t);
    }
  );
}
function B6e(e, t, r) {
  e.frameworkOverrides.wrapIncoming(
    () => {
      var n, i;
      return (i = (n = e.rowModelHelperService) == null ? void 0 : n.getClientSideRowModel()) == null ? void 0 : i.batchUpdateRowData(t, r);
    }
  );
}
function $6e(e) {
  e.frameworkOverrides.wrapIncoming(
    () => {
      var t, r;
      return (r = (t = e.rowModelHelperService) == null ? void 0 : t.getClientSideRowModel()) == null ? void 0 : r.flushAsyncTransactions();
    }
  );
}
function H6e(e) {
  return e.selectionService.getBestCostNodeSelection();
}
var G6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "filterStage";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  execute(e) {
    const { changedPath: t } = e;
    this.filter(t);
  }
  filter(e) {
    var r;
    const t = !!((r = this.filterManager) != null && r.isChildFilterPresent());
    this.filterNodes(t, e);
  }
  filterNodes(e, t) {
    const r = (n, i) => {
      n.hasChildren() && e && !i ? n.childrenAfterFilter = n.childrenAfterGroup.filter((o) => {
        const a = o.childrenAfterFilter && o.childrenAfterFilter.length > 0, s = o.data && this.filterManager.doesRowPassFilter({ rowNode: o });
        return a || s;
      }) : n.childrenAfterFilter = n.childrenAfterGroup, n.sibling && (n.sibling.childrenAfterFilter = n.childrenAfterFilter);
    };
    if (this.doingTreeDataFiltering()) {
      const n = (o, a) => {
        if (o.childrenAfterGroup)
          for (let s = 0; s < o.childrenAfterGroup.length; s++) {
            const l = o.childrenAfterGroup[s], u = a || this.filterManager.doesRowPassFilter({ rowNode: l });
            l.childrenAfterGroup ? n(o.childrenAfterGroup[s], u) : r(l, u);
          }
        r(o, a);
      }, i = (o) => n(o, !1);
      t.executeFromRootNode(i);
    } else {
      const n = (i) => r(i, !1);
      t.forEachChangedNodeDepthFirst(n, !0);
    }
  }
  doingTreeDataFiltering() {
    return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
  }
}, z6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "flattenStage";
  }
  wireBeans(e) {
    this.beans = e, this.columnModel = e.columnModel;
  }
  execute(e) {
    const t = e.rowNode, r = [], n = this.columnModel.isPivotMode(), i = n && t.leafGroup, o = i ? [t] : t.childrenAfterSort, a = this.getFlattenDetails();
    this.recursivelyAddToRowsToDisplay(a, o, r, n, 0);
    const s = r.length > 0;
    if (!i && // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)
    s && a.grandTotalRow) {
      t.createFooter();
      const u = a.grandTotalRow === "top";
      this.addRowNodeToRowsToDisplay(a, t.sibling, r, 0, u);
    }
    return r;
  }
  getFlattenDetails() {
    const e = this.gos.get("groupRemoveSingleChildren");
    return {
      groupRemoveLowestSingleChildren: !e && this.gos.get("groupRemoveLowestSingleChildren"),
      groupRemoveSingleChildren: e,
      isGroupMultiAutoColumn: this.gos.isGroupMultiAutoColumn(),
      hideOpenParents: this.gos.get("groupHideOpenParents"),
      grandTotalRow: this.gos.getGrandTotalRow(),
      groupTotalRow: this.gos.getGroupTotalRowCallback()
    };
  }
  recursivelyAddToRowsToDisplay(e, t, r, n, i) {
    if (!Wn(t))
      for (let o = 0; o < t.length; o++) {
        const a = t[o], s = a.hasChildren(), l = n && !s, u = e.groupRemoveSingleChildren && s && a.childrenAfterGroup.length === 1, c = e.groupRemoveLowestSingleChildren && s && a.leafGroup && a.childrenAfterGroup.length === 1, d = n && a.leafGroup, h = e.hideOpenParents && a.expanded && !a.master && !d;
        if (!l && !h && !u && !c && this.addRowNodeToRowsToDisplay(e, a, r, i), !(n && a.leafGroup)) {
          if (s) {
            const p = u || c;
            if (a.expanded || p) {
              const g = e.groupTotalRow({ node: a });
              g || a.destroyFooter();
              const v = p ? i : i + 1;
              g === "top" && (a.createFooter(), this.addRowNodeToRowsToDisplay(e, a.sibling, r, v)), this.recursivelyAddToRowsToDisplay(
                e,
                a.childrenAfterSort,
                r,
                n,
                v
              ), g === "bottom" && (a.createFooter(), this.addRowNodeToRowsToDisplay(e, a.sibling, r, v));
            }
          } else if (a.master && a.expanded) {
            const p = this.createDetailNode(a);
            this.addRowNodeToRowsToDisplay(e, p, r, i);
          }
        }
      }
  }
  // duplicated method, it's also in floatingRowModel
  addRowNodeToRowsToDisplay(e, t, r, n, i) {
    i ? r.unshift(t) : r.push(t), t.setUiLevel(e.isGroupMultiAutoColumn ? 0 : n);
  }
  createDetailNode(e) {
    if (ke(e.detailNode))
      return e.detailNode;
    const t = new Ks(this.beans);
    return t.detail = !0, t.selectable = !1, t.parent = e, ke(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1, e.detailNode = t, t;
  }
}, W6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "immutableService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  postConstruct() {
    this.rowModel.getType() === "clientSide" && (this.clientSideRowModel = this.rowModel, this.addManagedPropertyListener("rowData", () => this.onRowDataUpdated()));
  }
  isActive() {
    const e = this.gos.exists("getRowId");
    return this.gos.get("resetRowDataOnUpdate") ? !1 : e;
  }
  setRowData(e) {
    const t = this.createTransactionForRowData(e);
    if (!t)
      return;
    const [r, n] = t;
    this.clientSideRowModel.updateRowData(r, n);
  }
  // converts the setRowData() command to a transaction
  createTransactionForRowData(e) {
    if (dr(this.clientSideRowModel)) {
      Er("ImmutableService only works with ClientSideRowModel");
      return;
    }
    const t = this.gos.getRowIdCallback();
    if (t == null) {
      Er("ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!");
      return;
    }
    const r = {
      remove: [],
      update: [],
      add: []
    }, n = this.clientSideRowModel.getCopyOfNodesMap(), o = this.gos.get("suppressMaintainUnsortedOrder") ? void 0 : {};
    return ke(e) && e.forEach((a, s) => {
      const l = t({ data: a, level: 0 }), u = n[l];
      o && (o[l] = s), u ? (u.data !== a && r.update.push(a), n[l] = void 0) : r.add.push(a);
    }), wa(n, (a, s) => {
      s && r.remove.push(s.data);
    }), [r, o];
  }
  onRowDataUpdated() {
    const e = this.gos.get("rowData");
    e && (this.isActive() ? this.setRowData(e) : (this.selectionService.reset("rowDataChanged"), this.clientSideRowModel.setRowData(e)));
  }
}, j6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "sortService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.rowNodeSorter = e.rowNodeSorter, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  sort(e, t, r, n, i, o) {
    const a = this.gos.get("groupMaintainOrder"), s = this.columnModel.getCols().some((h) => h.isRowGroupActive());
    let l = {};
    r && n && (l = this.calculateDirtyNodes(n));
    const u = this.columnModel.isPivotMode(), c = this.gos.getCallback("postSortRows"), d = (h) => {
      var g;
      this.pullDownGroupDataForHideOpenParents(h.childrenAfterAggFilter, !0);
      const f = u && h.leafGroup;
      if (a && s && !h.leafGroup && !o) {
        const v = (g = this.funcColsService.getRowGroupColumns()) == null ? void 0 : g[h.level + 1], m = (v == null ? void 0 : v.getSort()) === null, y = h.childrenAfterAggFilter.slice(0);
        if (h.childrenAfterSort && !m) {
          const C = {};
          h.childrenAfterSort.forEach((S, b) => {
            C[S.id] = b;
          }), y.sort(
            (S, b) => (C[S.id] ?? 0) - (C[b.id] ?? 0)
          );
        }
        h.childrenAfterSort = y;
      } else !t || f ? h.childrenAfterSort = h.childrenAfterAggFilter.slice(0) : r ? h.childrenAfterSort = this.doDeltaSort(h, l, i, e) : h.childrenAfterSort = this.rowNodeSorter.doFullSort(h.childrenAfterAggFilter, e);
      if (h.sibling && (h.sibling.childrenAfterSort = h.childrenAfterSort), this.updateChildIndexes(h), c) {
        const v = { nodes: h.childrenAfterSort };
        c(v);
      }
    };
    i && i.forEachChangedNodeDepthFirst(d), this.updateGroupDataForHideOpenParents(i);
  }
  calculateDirtyNodes(e) {
    const t = {}, r = (n) => {
      n && n.forEach((i) => t[i.id] = !0);
    };
    return e && e.forEach((n) => {
      r(n.add), r(n.update), r(n.remove);
    }), t;
  }
  doDeltaSort(e, t, r, n) {
    const i = e.childrenAfterAggFilter, o = e.childrenAfterSort;
    if (!o)
      return this.rowNodeSorter.doFullSort(i, n);
    const a = {}, s = [];
    i.forEach((d) => {
      t[d.id] || !r.canSkip(d) ? s.push(d) : a[d.id] = !0;
    });
    const l = o.filter((d) => a[d.id]), u = (d, h) => ({
      currentPos: h,
      rowNode: d
    }), c = s.map(u).sort((d, h) => this.rowNodeSorter.compareRowNodes(n, d, h));
    return this.mergeSortedArrays(n, c, l.map(u)).map(
      ({ rowNode: d }) => d
    );
  }
  // Merge two sorted arrays into each other
  mergeSortedArrays(e, t, r) {
    const n = [];
    let i = 0, o = 0;
    for (; i < t.length && o < r.length; )
      this.rowNodeSorter.compareRowNodes(e, t[i], r[o]) < 0 ? n.push(t[i++]) : n.push(r[o++]);
    for (; i < t.length; )
      n.push(t[i++]);
    for (; o < r.length; )
      n.push(r[o++]);
    return n;
  }
  updateChildIndexes(e) {
    if (dr(e.childrenAfterSort))
      return;
    const t = e.childrenAfterSort;
    for (let r = 0; r < t.length; r++) {
      const n = t[r], i = r === 0, o = r === e.childrenAfterSort.length - 1;
      n.setFirstChild(i), n.setLastChild(o), n.setChildIndex(r);
    }
  }
  updateGroupDataForHideOpenParents(e) {
    if (!this.gos.get("groupHideOpenParents"))
      return;
    if (this.gos.get("treeData"))
      return Te(
        "The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them."
      ), !1;
    const t = (r) => {
      this.pullDownGroupDataForHideOpenParents(r.childrenAfterSort, !1), r.childrenAfterSort.forEach((n) => {
        n.hasChildren() && t(n);
      });
    };
    e && e.executeFromRootNode((r) => t(r));
  }
  pullDownGroupDataForHideOpenParents(e, t) {
    !this.gos.get("groupHideOpenParents") || dr(e) || e.forEach((r) => {
      var i;
      (((i = this.showRowGroupColsService) == null ? void 0 : i.getShowRowGroupCols()) ?? []).forEach((o) => {
        const a = o.getColDef().showRowGroup;
        if (typeof a != "string") {
          Er(
            "groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup"
          );
          return;
        }
        const s = a, l = this.columnModel.getColDefCol(s);
        if (l !== r.rowGroupColumn)
          if (t)
            r.setGroupValue(o.getId(), void 0);
          else {
            const c = r.getFirstChildOfFirstChild(l);
            c && r.setGroupValue(o.getId(), c.key);
          }
      });
    });
  }
}, U6e = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "sortStage";
  }
  wireBeans(e) {
    this.sortService = e.sortService, this.sortController = e.sortController;
  }
  execute(e) {
    const t = this.sortController.getSortOptions(), r = ke(t) && t.length > 0, n = r && ke(e.rowNodeTransactions) && // in time we can remove this check, so that delta sort is always
    // on if transactions are present. it's off for now so that we can
    // selectively turn it on and test it with some select users before
    // rolling out to everyone.
    this.gos.get("deltaSort"), i = t.some((o) => this.gos.isColumnsSortingCoupledToGroup() ? o.column.isPrimary() && o.column.isRowGroupActive() : !!o.column.getColDef().showRowGroup);
    this.sortService.sort(
      t,
      r,
      n,
      e.rowNodeTransactions,
      e.changedPath,
      i
    );
  }
}, PI = "32.0.1", pX = {
  version: PI,
  moduleName: "@ag-grid-community/client-side-row-model-core",
  rowModel: "clientSide",
  beans: [A6e, G6e, U6e, z6e, j6e, W6e]
}, K6e = {
  version: PI,
  moduleName: "@ag-grid-community/client-side-row-model-api",
  beans: [fX],
  apiFunctions: {
    onGroupExpandedOrCollapsed: I6e,
    refreshClientSideRowModel: O6e,
    forEachLeafNode: L6e,
    forEachNodeAfterFilter: F6e,
    forEachNodeAfterFilterAndSort: N6e,
    resetRowHeights: k6e,
    applyTransaction: V6e,
    applyTransactionAsync: B6e,
    flushAsyncTransactions: $6e,
    getBestCostNodeSelection: H6e
  },
  dependantModules: [pX, R6e]
}, Y6e = {
  version: PI,
  moduleName: "@ag-grid-community/client-side-row-model",
  dependantModules: [pX, K6e]
}, q6e = class extends Se {
  setBeans(e) {
    this.beans = e;
  }
  getFileName(e) {
    const t = this.getDefaultFileExtension();
    return (e == null || !e.length) && (e = this.getDefaultFileName()), e.indexOf(".") === -1 ? `${e}.${t}` : e;
  }
  getData(e) {
    const t = this.createSerializingSession(e);
    return this.beans.gridSerializer.serialize(t, e);
  }
  getDefaultFileName() {
    return `export.${this.getDefaultFileExtension()}`;
  }
}, X6e = class {
  constructor(e) {
    this.groupColumns = [];
    const {
      columnModel: t,
      funcColsService: r,
      columnNameService: n,
      valueService: i,
      gos: o,
      processCellCallback: a,
      processHeaderCallback: s,
      processGroupHeaderCallback: l,
      processRowGroupCallback: u
    } = e;
    this.columnModel = t, this.funcColsService = r, this.columnNameService = n, this.valueService = i, this.gos = o, this.processCellCallback = a, this.processHeaderCallback = s, this.processGroupHeaderCallback = l, this.processRowGroupCallback = u;
  }
  prepare(e) {
    this.groupColumns = e.filter((t) => !!t.getColDef().showRowGroup);
  }
  extractHeaderValue(e) {
    return this.getHeaderName(this.processHeaderCallback, e) ?? "";
  }
  extractRowCellValue(e, t, r, n, i) {
    const a = (!this.gos.get("groupHideOpenParents") || i.footer) && this.shouldRenderGroupSummaryCell(i, e, t) ? this.createValueForGroupNode(e, i) : this.valueService.getValue(e, i);
    return this.processCell({
      accumulatedRowIndex: r,
      rowNode: i,
      column: e,
      value: a,
      processCellCallback: this.processCellCallback,
      type: n
    });
  }
  shouldRenderGroupSummaryCell(e, t, r) {
    var a;
    if (!(e && e.group))
      return !1;
    if (this.groupColumns.indexOf(t) !== -1) {
      if (((a = e.groupData) == null ? void 0 : a[t.getId()]) != null || this.gos.isRowModelType("serverSide") && e.group)
        return !0;
      if (e.footer && e.level === -1) {
        const s = t.getColDef();
        return s == null || s.showRowGroup === !0 || s.showRowGroup === this.funcColsService.getRowGroupColumns()[0].getId();
      }
    }
    const o = this.gos.isGroupUseEntireRow(this.columnModel.isPivotMode());
    return r === 0 && o;
  }
  getHeaderName(e, t) {
    return e ? e(this.gos.addGridCommonParams({ column: t })) : this.columnNameService.getDisplayNameForColumn(t, "csv", !0);
  }
  createValueForGroupNode(e, t) {
    if (this.processRowGroupCallback)
      return this.processRowGroupCallback(this.gos.addGridCommonParams({ column: e, node: t }));
    const r = this.gos.get("treeData"), n = this.gos.get("suppressGroupMaintainValueType"), i = (l) => {
      var c;
      if (r || n)
        return l.key;
      const u = (c = l.groupData) == null ? void 0 : c[e.getId()];
      return !u || !l.rowGroupColumn || l.rowGroupColumn.getColDef().useValueFormatterForExport === !1 ? u : this.valueService.formatValue(l.rowGroupColumn, l, u) ?? u;
    }, o = t.footer, a = [i(t)];
    if (!this.gos.isGroupMultiAutoColumn())
      for (; t.parent; )
        t = t.parent, a.push(i(t));
    const s = a.reverse().join(" -> ");
    return o ? `Total ${s}` : s;
  }
  processCell(e) {
    const { accumulatedRowIndex: t, rowNode: r, column: n, value: i, processCellCallback: o, type: a } = e;
    return o ? {
      value: o(
        this.gos.addGridCommonParams({
          accumulatedRowIndex: t,
          column: n,
          node: r,
          value: i,
          type: a,
          parseValue: (s) => this.valueService.parseValue(
            n,
            r,
            s,
            this.valueService.getValue(n, r)
          ),
          formatValue: (s) => this.valueService.formatValue(n, r, s) ?? s
        })
      ) ?? ""
    } : n.getColDef().useValueFormatterForExport !== !1 ? {
      value: i ?? "",
      valueFormatted: this.valueService.formatValue(n, r, i)
    } : { value: i ?? "" };
  }
}, Z6e = class {
  static download(e, t) {
    const r = document.defaultView || window;
    if (!r) {
      Te("There is no `window` associated with the current `document`");
      return;
    }
    const n = document.createElement("a"), i = r.URL.createObjectURL(t);
    n.setAttribute("href", i), n.setAttribute("download", e), n.style.display = "none", document.body.appendChild(n), n.dispatchEvent(
      new MouseEvent("click", {
        bubbles: !1,
        cancelable: !0,
        view: r
      })
    ), document.body.removeChild(n), r.setTimeout(() => {
      r.URL.revokeObjectURL(i);
    }, 0);
  }
}, nG = `\r
`, Q6e = class extends X6e {
  constructor(e) {
    super(e), this.isFirstLine = !0, this.result = "";
    const { suppressQuotes: t, columnSeparator: r } = e;
    this.suppressQuotes = t, this.columnSeparator = r;
  }
  addCustomContent(e) {
    e && (typeof e == "string" ? (/^\s*\n/.test(e) || this.beginNewLine(), e = e.replace(/\r?\n/g, nG), this.result += e) : e.forEach((t) => {
      this.beginNewLine(), t.forEach((r, n) => {
        n !== 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(r.data.value || ""), r.mergeAcross && this.appendEmptyCells(r.mergeAcross);
      });
    }));
  }
  onNewHeaderGroupingRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
    };
  }
  onNewHeaderGroupingRowColumn(e, t, r, n) {
    r != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(t), this.appendEmptyCells(n);
  }
  appendEmptyCells(e) {
    for (let t = 1; t <= e; t++)
      this.result += this.columnSeparator + this.putInQuotes("");
  }
  onNewHeaderRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderRowColumn.bind(this)
    };
  }
  onNewHeaderRowColumn(e, t) {
    t != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(this.extractHeaderValue(e));
  }
  onNewBodyRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewBodyRowColumn.bind(this)
    };
  }
  onNewBodyRowColumn(e, t, r) {
    t != 0 && (this.result += this.columnSeparator);
    const n = this.extractRowCellValue(e, t, t, "csv", r);
    this.result += this.putInQuotes(n.valueFormatted ?? n.value);
  }
  putInQuotes(e) {
    if (this.suppressQuotes)
      return e;
    if (e == null)
      return '""';
    let t;
    return typeof e == "string" ? t = e : typeof e.toString == "function" ? t = e.toString() : (Te("unknown value type during csv conversion"), t = ""), '"' + t.replace(/"/g, '""') + '"';
  }
  parse() {
    return this.result;
  }
  beginNewLine() {
    this.isFirstLine || (this.result += nG), this.isFirstLine = !1;
  }
}, J6e = class extends q6e {
  constructor() {
    super(...arguments), this.beanName = "csvCreator";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnNameService = e.columnNameService, this.funcColsService = e.funcColsService, this.valueService = e.valueService, this.gridSerializer = e.gridSerializer;
  }
  postConstruct() {
    this.setBeans({
      gridSerializer: this.gridSerializer,
      gos: this.gos
    });
  }
  getMergedParams(e) {
    const t = this.gos.get("defaultCsvExportParams");
    return Object.assign({}, t, e);
  }
  export(e) {
    if (this.isExportSuppressed()) {
      Te("Export cancelled. Export is not allowed as per your configuration.");
      return;
    }
    const t = this.getMergedParams(e), r = this.getData(t), n = new Blob(["\uFEFF", r], { type: "text/plain" }), i = typeof t.fileName == "function" ? t.fileName(this.gos.getGridCommonParams()) : t.fileName;
    Z6e.download(this.getFileName(i), n);
  }
  exportDataAsCsv(e) {
    this.export(e);
  }
  getDataAsCsv(e, t = !1) {
    const r = t ? Object.assign({}, e) : this.getMergedParams(e);
    return this.getData(r);
  }
  getDefaultFileExtension() {
    return "csv";
  }
  createSerializingSession(e) {
    const { columnModel: t, columnNameService: r, funcColsService: n, valueService: i, gos: o } = this, {
      processCellCallback: a,
      processHeaderCallback: s,
      processGroupHeaderCallback: l,
      processRowGroupCallback: u,
      suppressQuotes: c,
      columnSeparator: d
    } = e;
    return new Q6e({
      columnModel: t,
      columnNameService: r,
      funcColsService: n,
      valueService: i,
      gos: o,
      processCellCallback: a || void 0,
      processHeaderCallback: s || void 0,
      processGroupHeaderCallback: l || void 0,
      processRowGroupCallback: u || void 0,
      suppressQuotes: c || !1,
      columnSeparator: d || ","
    });
  }
  isExportSuppressed() {
    return this.gos.get("suppressCsvExport");
  }
};
function eWe(e, t) {
  var r;
  return (r = e.csvCreator) == null ? void 0 : r.getDataAsCsv(t);
}
function tWe(e, t) {
  var r;
  (r = e.csvCreator) == null || r.exportDataAsCsv(t);
}
var rWe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "gridSerializer";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.columnModel = e.columnModel, this.columnNameService = e.columnNameService, this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.selectionService = e.selectionService, this.rowNodeSorter = e.rowNodeSorter, this.sortController = e.sortController;
  }
  serialize(e, t = {}) {
    const { allColumns: r, columnKeys: n, skipRowGroups: i } = t, o = this.getColumnsToExport(
      r,
      i,
      n
    );
    return oBe(
      // first pass, put in the header names of the cols
      this.prepareSession(o),
      this.prependContent(t),
      this.exportColumnGroups(t, o),
      this.exportHeaders(t, o),
      this.processPinnedTopRows(t, o),
      this.processRows(t, o),
      this.processPinnedBottomRows(t, o),
      this.appendContent(t)
    )(e).parse();
  }
  processRow(e, t, r, n) {
    var m;
    const i = t.shouldRowBeSkipped || (() => !1), o = this.gos.get("groupRemoveSingleChildren"), a = this.gos.get("groupRemoveLowestSingleChildren"), l = t.rowPositions != null || !!t.onlySelected, u = this.gos.get("groupHideOpenParents") && !l, c = this.columnModel.isPivotMode() ? n.leafGroup : !n.group, d = !!n.footer, h = a && n.leafGroup, f = n.allChildrenCount === 1 && ((m = n.childrenAfterGroup) == null ? void 0 : m.length) === 1 && (o || h);
    if (!c && !d && (t.skipRowGroups || f || u) || t.onlySelected && !n.isSelected() || t.skipPinnedTop && n.rowPinned === "top" || t.skipPinnedBottom && n.rowPinned === "bottom" || n.level === -1 && !c && !d || i(this.gos.addGridCommonParams({ node: n })))
      return;
    const v = e.onNewBodyRow(n);
    if (r.forEach((y, C) => {
      v.onColumn(y, C, n);
    }), t.getCustomContentBelowRow) {
      const y = t.getCustomContentBelowRow(this.gos.addGridCommonParams({ node: n }));
      y && e.addCustomContent(y);
    }
  }
  appendContent(e) {
    return (t) => {
      const r = e.appendContent;
      return r && t.addCustomContent(r), t;
    };
  }
  prependContent(e) {
    return (t) => {
      const r = e.prependContent;
      return r && t.addCustomContent(r), t;
    };
  }
  prepareSession(e) {
    return (t) => (t.prepare(e), t);
  }
  exportColumnGroups(e, t) {
    return (r) => {
      if (!e.skipColumnGroupHeaders) {
        const n = new $Y(), i = this.visibleColsService.createGroups({
          columns: t,
          idCreator: n,
          pinned: null,
          isStandaloneStructure: !0
        });
        this.recursivelyAddHeaderGroups(
          i,
          r,
          e.processGroupHeaderCallback
        );
      }
      return r;
    };
  }
  exportHeaders(e, t) {
    return (r) => {
      if (!e.skipColumnHeaders) {
        const n = r.onNewHeaderRow();
        t.forEach((i, o) => {
          n.onColumn(i, o, void 0);
        });
      }
      return r;
    };
  }
  processPinnedTopRows(e, t) {
    return (r) => {
      const n = this.processRow.bind(this, r, e, t);
      return e.rowPositions ? e.rowPositions.filter((i) => i.rowPinned === "top").sort((i, o) => i.rowIndex - o.rowIndex).map((i) => this.pinnedRowModel.getPinnedTopRow(i.rowIndex)).forEach(n) : this.pinnedRowModel.forEachPinnedTopRow(n), r;
    };
  }
  processRows(e, t) {
    return (r) => {
      const n = this.rowModel, i = n.getType(), o = i === "clientSide", a = i === "serverSide", s = !o && e.onlySelected, l = this.processRow.bind(this, r, e, t), { exportedRows: u = "filteredAndSorted" } = e;
      if (e.rowPositions)
        e.rowPositions.filter((c) => c.rowPinned == null).sort((c, d) => c.rowIndex - d.rowIndex).map((c) => n.getRow(c.rowIndex)).forEach(l);
      else if (this.columnModel.isPivotMode())
        o ? n.forEachPivotNode(l, !0) : a ? n.forEachNodeAfterFilterAndSort(l, !0) : n.forEachNode(l);
      else if (e.onlySelectedAllPages || s) {
        const c = this.selectionService.getSelectedNodes();
        this.replicateSortedOrder(c), c.forEach(l);
      } else
        u === "all" ? n.forEachNode(l) : o || a ? n.forEachNodeAfterFilterAndSort(l, !0) : n.forEachNode(l);
      return r;
    };
  }
  replicateSortedOrder(e) {
    const t = this.sortController.getSortOptions(), r = (n, i) => {
      var o, a;
      return n.rowIndex != null && i.rowIndex != null ? n.rowIndex - i.rowIndex : n.level === i.level ? ((o = n.parent) == null ? void 0 : o.id) === ((a = i.parent) == null ? void 0 : a.id) ? this.rowNodeSorter.compareRowNodes(
        t,
        {
          rowNode: n,
          currentPos: n.rowIndex ?? -1
        },
        {
          rowNode: i,
          currentPos: i.rowIndex ?? -1
        }
      ) : r(n.parent, i.parent) : n.level > i.level ? r(n.parent, i) : r(n, i.parent);
    };
    e.sort(r);
  }
  processPinnedBottomRows(e, t) {
    return (r) => {
      const n = this.processRow.bind(this, r, e, t);
      return e.rowPositions ? e.rowPositions.filter((i) => i.rowPinned === "bottom").sort((i, o) => i.rowIndex - o.rowIndex).map((i) => this.pinnedRowModel.getPinnedBottomRow(i.rowIndex)).forEach(n) : this.pinnedRowModel.forEachPinnedBottomRow(n), r;
    };
  }
  getColumnsToExport(e = !1, t = !1, r) {
    const n = this.columnModel.isPivotMode();
    if (r && r.length)
      return this.columnModel.getColsForKeys(r);
    const i = this.gos.get("treeData");
    let o = [];
    return e && !n ? o = this.columnModel.getCols() : o = this.visibleColsService.getAllCols(), t && !i && (o = o.filter((a) => a.getColId() !== em)), o;
  }
  recursivelyAddHeaderGroups(e, t, r) {
    const n = [];
    e.forEach((i) => {
      const o = i;
      o.getChildren && o.getChildren().forEach((a) => n.push(a));
    }), e.length > 0 && Sn(e[0]) && this.doAddHeaderHeader(t, e, r), n && n.length > 0 && this.recursivelyAddHeaderGroups(
      n,
      t,
      r
    );
  }
  doAddHeaderHeader(e, t, r) {
    const n = e.onNewHeaderGroupingRow();
    let i = 0;
    t.forEach((o) => {
      const a = o;
      let s;
      r ? s = r(
        this.gos.addGridCommonParams({
          columnGroup: a
        })
      ) : s = this.columnNameService.getDisplayNameForColumnGroup(a, "header");
      const l = a.getLeafColumns().reduce((u, c, d, h) => {
        let f = gr(u);
        return c.getColumnGroupShow() === "open" ? (!f || f[1] != null) && (f = [d], u.push(f)) : f && f[1] == null && (f[1] = d - 1), d === h.length - 1 && f && f[1] == null && (f[1] = d), u;
      }, []);
      n.onColumn(
        a,
        s || "",
        i++,
        a.getLeafColumns().length - 1,
        l
      );
    });
  }
}, MI = "32.0.1", gX = {
  version: MI,
  moduleName: "@ag-grid-community/csv-export-core",
  beans: [J6e, rWe]
}, nWe = {
  version: MI,
  moduleName: "@ag-grid-community/csv-export-api",
  apiFunctions: {
    getDataAsCsv: eWe,
    exportDataAsCsv: tWe
  },
  dependantModules: [gX]
}, iWe = {
  version: MI,
  moduleName: "@ag-grid-community/csv-export",
  dependantModules: [gX, nWe]
}, oWe = class extends cze {
  wireBeans(e) {
    this.beans = e;
  }
  constructor(e, t, r) {
    super(e), this.parentCache = t, this.params = r, this.startRow = e * r.blockSize, this.endRow = this.startRow + r.blockSize;
  }
  postConstruct() {
    this.createRowNodes();
  }
  getBlockStateJson() {
    return {
      id: "" + this.getId(),
      state: {
        blockNumber: this.getId(),
        startRow: this.getStartRow(),
        endRow: this.getEndRow(),
        pageStatus: this.getState()
      }
    };
  }
  setDataAndId(e, t, r) {
    ke(t) ? e.setDataAndId(t, r.toString()) : e.setDataAndId(void 0, void 0);
  }
  loadFromDatasource() {
    const e = this.createLoadParams();
    if (dr(this.params.datasource.getRows)) {
      Te("datasource is missing getRows method");
      return;
    }
    window.setTimeout(() => {
      this.params.datasource.getRows(e);
    }, 0);
  }
  processServerFail() {
  }
  createLoadParams() {
    return {
      startRow: this.getStartRow(),
      endRow: this.getEndRow(),
      successCallback: this.pageLoaded.bind(this, this.getVersion()),
      failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
      sortModel: this.params.sortModel,
      filterModel: this.params.filterModel,
      context: this.gos.getGridCommonParams().context
    };
  }
  forEachNode(e, t, r) {
    this.rowNodes.forEach((n, i) => {
      this.startRow + i < r && e(n, t.next());
    });
  }
  getLastAccessed() {
    return this.lastAccessed;
  }
  getRow(e, t = !1) {
    t || (this.lastAccessed = this.params.lastAccessedSequence.next());
    const r = e - this.startRow;
    return this.rowNodes[r];
  }
  getStartRow() {
    return this.startRow;
  }
  getEndRow() {
    return this.endRow;
  }
  // creates empty row nodes, data is missing as not loaded yet
  createRowNodes() {
    this.rowNodes = [];
    for (let e = 0; e < this.params.blockSize; e++) {
      const t = this.startRow + e, r = new Ks(this.beans);
      r.setRowHeight(this.params.rowHeight), r.uiLevel = 0, r.setRowIndex(t), r.setRowTop(this.params.rowHeight * t), this.rowNodes.push(r);
    }
  }
  processServerResult(e) {
    this.rowNodes.forEach((r, n) => {
      const i = e.rowData ? e.rowData[n] : void 0;
      !r.id && r.alreadyRendered && i && (this.rowNodes[n] = new Ks(this.beans), this.rowNodes[n].setRowIndex(r.rowIndex), this.rowNodes[n].setRowTop(r.rowTop), this.rowNodes[n].setRowHeight(r.rowHeight), r.clearRowTopAndRowIndex()), this.setDataAndId(this.rowNodes[n], i, this.startRow + n);
    });
    const t = e.rowCount != null && e.rowCount >= 0 ? e.rowCount : void 0;
    this.parentCache.pageLoaded(this, t);
  }
  destroy() {
    this.rowNodes.forEach((e) => {
      e.clearRowTopAndRowIndex();
    }), super.destroy();
  }
}, aWe = 2, sWe = class extends Se {
  constructor(e) {
    super(), this.lastRowIndexKnown = !1, this.blocks = {}, this.blockCount = 0, this.rowCount = e.initialRowCount, this.params = e;
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.focusService = e.focusService;
  }
  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
  // it will want new pages in the cache as it asks for rows. only when we are inserting /
  // removing rows via the api is dontCreatePage set, where we move rows between the pages.
  getRow(e, t = !1) {
    const r = Math.floor(e / this.params.blockSize);
    let n = this.blocks[r];
    if (!n) {
      if (t)
        return;
      n = this.createBlock(r);
    }
    return n.getRow(e);
  }
  createBlock(e) {
    const t = this.createBean(new oWe(e, this, this.params));
    return this.blocks[t.getId()] = t, this.blockCount++, this.purgeBlocksIfNeeded(t), this.params.rowNodeBlockLoader.addBlock(t), t;
  }
  // we have this on infinite row model only, not server side row model,
  // because for server side, it would leave the children in inconsistent
  // state - eg if a node had children, but after the refresh it had data
  // for a different row, then the children would be with the wrong row node.
  refreshCache() {
    if (this.blockCount == 0) {
      this.purgeCache();
      return;
    }
    this.getBlocksInOrder().forEach((t) => t.setStateWaitingToLoad()), this.params.rowNodeBlockLoader.checkBlockToLoad();
  }
  destroy() {
    this.getBlocksInOrder().forEach((e) => this.destroyBlock(e)), super.destroy();
  }
  getRowCount() {
    return this.rowCount;
  }
  isLastRowIndexKnown() {
    return this.lastRowIndexKnown;
  }
  // block calls this, when page loaded
  pageLoaded(e, t) {
    this.isAlive() && (this.gos.get("debug") && Ea(`InfiniteCache - onPageLoaded: page = ${e.getId()}, lastRow = ${t}`), this.checkRowCount(e, t), this.onCacheUpdated());
  }
  purgeBlocksIfNeeded(e) {
    const t = this.getBlocksInOrder().filter((a) => a != e), r = (a, s) => s.getLastAccessed() - a.getLastAccessed();
    t.sort(r);
    const n = this.params.maxBlocksInCache > 0, i = n ? this.params.maxBlocksInCache - 1 : null, o = aWe - 1;
    t.forEach((a, s) => {
      const l = a.getState() === "needsLoading" && s >= o, u = n ? s >= i : !1;
      if (l || u) {
        if (this.isBlockCurrentlyDisplayed(a) || this.isBlockFocused(a))
          return;
        this.removeBlockFromCache(a);
      }
    });
  }
  isBlockFocused(e) {
    const t = this.focusService.getFocusCellToUseAfterRefresh();
    if (!t || t.rowPinned != null)
      return !1;
    const r = e.getStartRow(), n = e.getEndRow();
    return t.rowIndex >= r && t.rowIndex < n;
  }
  isBlockCurrentlyDisplayed(e) {
    const t = e.getStartRow(), r = e.getEndRow() - 1;
    return this.rowRenderer.isRangeInRenderedViewport(t, r);
  }
  removeBlockFromCache(e) {
    e && this.destroyBlock(e);
  }
  checkRowCount(e, t) {
    if (typeof t == "number" && t >= 0)
      this.rowCount = t, this.lastRowIndexKnown = !0;
    else if (!this.lastRowIndexKnown) {
      const n = (e.getId() + 1) * this.params.blockSize + this.params.overflowSize;
      this.rowCount < n && (this.rowCount = n);
    }
  }
  setRowCount(e, t) {
    this.rowCount = e, ke(t) && (this.lastRowIndexKnown = t), this.lastRowIndexKnown || this.rowCount % this.params.blockSize === 0 && this.rowCount++, this.onCacheUpdated();
  }
  forEachNodeDeep(e) {
    const t = new nf();
    this.getBlocksInOrder().forEach((r) => r.forEachNode(e, t, this.rowCount));
  }
  getBlocksInOrder() {
    const e = (r, n) => r.getId() - n.getId();
    return iP(this.blocks).sort(e);
  }
  destroyBlock(e) {
    delete this.blocks[e.getId()], this.destroyBean(e), this.blockCount--, this.params.rowNodeBlockLoader.removeBlock(e);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  onCacheUpdated() {
    if (this.isAlive()) {
      this.destroyAllBlocksPastVirtualRowCount();
      const e = {
        type: "storeUpdated"
      };
      this.eventService.dispatchEvent(e);
    }
  }
  destroyAllBlocksPastVirtualRowCount() {
    const e = [];
    this.getBlocksInOrder().forEach((t) => {
      t.getId() * this.params.blockSize >= this.rowCount && e.push(t);
    }), e.length > 0 && e.forEach((t) => this.destroyBlock(t));
  }
  purgeCache() {
    this.getBlocksInOrder().forEach((e) => this.removeBlockFromCache(e)), this.lastRowIndexKnown = !1, this.rowCount === 0 && (this.rowCount = this.params.initialRowCount), this.onCacheUpdated();
  }
  getRowNodesInRange(e, t) {
    const r = [];
    let n = -1, i = !1;
    const o = new nf();
    let a = !1;
    return this.getBlocksInOrder().forEach((l) => {
      if (!a) {
        if (i && n + 1 !== l.getId()) {
          a = !0;
          return;
        }
        n = l.getId(), l.forEachNode(
          (u) => {
            const c = u === e || u === t;
            (i || c) && r.push(u), c && (i = !i);
          },
          o,
          this.rowCount
        );
      }
    }), a || i ? [] : r;
  }
}, lWe = class extends Se {
  constructor() {
    super(...arguments), this.beanName = "rowModel";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.sortController = e.sortController, this.selectionService = e.selectionService, this.rowRenderer = e.rowRenderer, this.rowNodeBlockLoader = e.rowNodeBlockLoader;
  }
  getRowBounds(e) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * e
    };
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid() {
    return !1;
  }
  postConstruct() {
    this.gos.isRowModelType("infinite") && (this.rowHeight = this.gos.getRowHeightAsNumber(), this.addEventListeners(), this.addDestroyFunc(() => this.destroyCache()), this.verifyProps());
  }
  verifyProps() {
    this.gos.exists("initialGroupOrderComparator") && Te(
      "initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side"
    );
  }
  start() {
    this.setDatasource(this.gos.get("datasource"));
  }
  destroy() {
    this.destroyDatasource(), super.destroy();
  }
  destroyDatasource() {
    this.datasource && (this.destroyBean(this.datasource), this.rowRenderer.datasourceChanged(), this.datasource = null);
  }
  addEventListeners() {
    this.addManagedEventListeners({
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      newColumnsLoaded: this.onColumnEverything.bind(this),
      storeUpdated: this.onCacheUpdated.bind(this)
    }), this.addManagedPropertyListener("datasource", () => this.setDatasource(this.gos.get("datasource"))), this.addManagedPropertyListener("cacheBlockSize", () => this.resetCache()), this.addManagedPropertyListener("rowHeight", () => {
      this.rowHeight = this.gos.getRowHeightAsNumber(), this.cacheParams.rowHeight = this.rowHeight, this.updateRowHeights();
    });
  }
  onFilterChanged() {
    this.reset();
  }
  onSortChanged() {
    this.reset();
  }
  onColumnEverything() {
    let e;
    this.cacheParams ? e = this.isSortModelDifferent() : e = !0, e && this.reset();
  }
  isSortModelDifferent() {
    return !JC(this.cacheParams.sortModel, this.sortController.getSortModel());
  }
  getType() {
    return "infinite";
  }
  setDatasource(e) {
    this.destroyDatasource(), this.datasource = e, e && this.reset();
  }
  isEmpty() {
    return !this.infiniteCache;
  }
  isRowsToRender() {
    return !!this.infiniteCache;
  }
  getNodesInRangeForSelection(e, t) {
    return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(e, t) : [];
  }
  reset() {
    if (!this.datasource)
      return;
    this.gos.getRowIdCallback() != null || this.selectionService.reset("rowDataChanged"), this.resetCache();
  }
  createModelUpdatedEvent() {
    return {
      type: "modelUpdated",
      // not sure if these should all be false - noticed if after implementing,
      // maybe they should be true?
      newPage: !1,
      newPageSize: !1,
      newData: !1,
      keepRenderedRows: !0,
      animate: !1
    };
  }
  resetCache() {
    var t;
    this.destroyCache(), this.cacheParams = {
      // the user provided datasource
      datasource: this.datasource,
      // sort and filter model
      filterModel: ((t = this.filterManager) == null ? void 0 : t.getFilterModel()) ?? {},
      sortModel: this.sortController.getSortModel(),
      rowNodeBlockLoader: this.rowNodeBlockLoader,
      // properties - this way we take a snapshot of them, so if user changes any, they will be
      // used next time we create a new cache, which is generally after a filter or sort change,
      // or a new datasource is set
      initialRowCount: this.gos.get("infiniteInitialRowCount"),
      maxBlocksInCache: this.gos.get("maxBlocksInCache"),
      rowHeight: this.gos.getRowHeightAsNumber(),
      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
      // the current page and request first row of next page
      overflowSize: this.gos.get("cacheOverflowSize"),
      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
      // server for one page at a time. so the default if not specified is 100.
      blockSize: this.gos.get("cacheBlockSize"),
      // the cache could create this, however it is also used by the pages, so handy to create it
      // here as the settings are also passed to the pages
      lastAccessedSequence: new nf()
    }, this.infiniteCache = this.createBean(new sWe(this.cacheParams)), this.eventService.dispatchEventOnce({
      type: "rowCountReady"
    });
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  updateRowHeights() {
    this.forEachNode((t) => {
      t.setRowHeight(this.rowHeight), t.setRowTop(this.rowHeight * t.rowIndex);
    });
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  destroyCache() {
    this.infiniteCache && (this.infiniteCache = this.destroyBean(this.infiniteCache));
  }
  onCacheUpdated() {
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  getRow(e) {
    if (this.infiniteCache && !(e >= this.infiniteCache.getRowCount()))
      return this.infiniteCache.getRow(e);
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((r) => {
      r.id === e && (t = r);
    }), t;
  }
  forEachNode(e) {
    this.infiniteCache && this.infiniteCache.forEachNodeDeep(e);
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(e) {
    return e;
  }
  getRowIndexAtPixel(e) {
    if (this.rowHeight !== 0) {
      const t = Math.floor(e / this.rowHeight), r = this.getRowCount() - 1;
      return t > r ? r : t;
    }
    return 0;
  }
  getRowCount() {
    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  refreshCache() {
    this.infiniteCache && this.infiniteCache.refreshCache();
  }
  purgeCache() {
    this.infiniteCache && this.infiniteCache.purgeCache();
  }
  // for iRowModel
  isLastRowIndexKnown() {
    return this.infiniteCache ? this.infiniteCache.isLastRowIndexKnown() : !1;
  }
  setRowCount(e, t) {
    this.infiniteCache && this.infiniteCache.setRowCount(e, t);
  }
};
function uWe(e) {
  var t, r;
  (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null || r.refreshCache();
}
function cWe(e) {
  var t, r;
  (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null || r.purgeCache();
}
function dWe(e) {
  var t, r;
  return (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null ? void 0 : r.getRowCount();
}
function hWe(e) {
  var t, r;
  return (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null ? void 0 : r.isLastRowIndexKnown();
}
var DI = "32.0.1", vX = {
  version: DI,
  moduleName: "@ag-grid-community/infinite-row-model-core",
  rowModel: "infinite",
  beans: [lWe],
  dependantModules: [hze]
}, fWe = {
  version: DI,
  moduleName: "@ag-grid-community/infinite-row-model-api",
  beans: [fX],
  apiFunctions: {
    refreshInfiniteCache: uWe,
    purgeInfiniteCache: cWe,
    getInfiniteRowCount: dWe,
    isLastRowIndexKnown: hWe
  },
  dependantModules: [vX, _6e]
}, pWe = {
  version: DI,
  moduleName: "@ag-grid-community/infinite-row-model",
  dependantModules: [vX, fWe]
};
ci.__registerModules(
  [lX, Y6e, pWe, iWe],
  !1,
  void 0
);
var ki = H.createContext({}), im = (e, t, r, n) => {
  if (!e || e.componentFromFramework || t.isDestroyed())
    return;
  const o = e.newAgStackInstance();
  if (o == null)
    return;
  let a, s, l = !1;
  return o.then((u) => {
    if (l) {
      t.destroyBean(u);
      return;
    }
    a = u, s = a.getGui(), r.appendChild(s), iG(n, a);
  }), () => {
    l = !0, a && (s && s.parentElement && s.parentElement.removeChild(s), t.destroyBean(a), n && iG(n, void 0));
  };
}, iG = (e, t) => {
  if (e)
    if (e instanceof Function)
      e(t);
    else {
      const r = e;
      r.current = t;
    }
}, Sa = (...e) => e.filter((r) => r != null && r !== "").join(" "), Uo = class mX {
  constructor(...t) {
    this.classesMap = {}, t.forEach((r) => {
      this.classesMap[r] = !0;
    });
  }
  setClass(t, r) {
    if (!!this.classesMap[t] == r)
      return this;
    const i = new mX();
    return i.classesMap = { ...this.classesMap }, i.classesMap[t] = r, i;
  }
  toString() {
    return Object.keys(this.classesMap).filter((r) => this.classesMap[r]).join(" ");
  }
}, Ff = (e) => {
  const t = () => typeof Symbol == "function" && Symbol.for, r = () => t() ? Symbol.for("react.memo") : 60115;
  return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === r();
}, yX = Bc.createRoot != null && Bc.flushSync != null;
function gWe() {
  return !yX;
}
var _0 = !1;
function vWe(e) {
  return _0 || setTimeout(() => _0 = !1, 0), _0 = !0, e();
}
var AI = (e, t) => {
  yX && e && !_0 ? Bc.flushSync(t) : t();
};
function II(e, t, r) {
  if (t == null || e == null)
    return t;
  if (e === t || t.length === 0 && e.length === 0)
    return e;
  if (r || e.length === 0 && t.length > 0 || e.length > 0 && t.length === 0)
    return t;
  const n = [], i = [], o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
  for (let s = 0; s < t.length; s++) {
    const l = t[s];
    a.set(l.getInstanceId(), l);
  }
  for (let s = 0; s < e.length; s++) {
    const l = e[s];
    o.set(l.getInstanceId(), l), a.has(l.getInstanceId()) && n.push(l);
  }
  for (let s = 0; s < t.length; s++) {
    const l = t[s], u = l.getInstanceId();
    o.has(u) || i.push(l);
  }
  return n.length === e.length && i.length === 0 ? e : n.length === 0 && i.length === t.length ? t : n.length === 0 ? i : i.length === 0 ? n : [...n, ...i];
}
var CX = yn((e, t) => {
  var N;
  const { ctrlsFactory: r, context: n } = vr(ki), i = se(null), o = se(null), a = se(null), s = se(null), l = se(null), u = se(), [c, d] = Me(), [h, f] = Me(), [p, g] = Me(), [v, m] = Me(() => new Uo()), [y, C] = Me(() => new Uo("ag-hidden")), [S, b] = Me(() => new Uo("ag-hidden")), [w, x] = Me(() => new Uo("ag-invisible"));
  Zc(t, () => ({
    // force new instance when grid tries to refresh
    refresh() {
      return !1;
    }
  })), as(() => im(c, n, o.current), [c]);
  const R = lr((I) => {
    if (i.current = I, !i.current) {
      n.destroyBean(u.current), u.current = null;
      return;
    }
    const B = {
      setInnerRenderer: (V, G) => {
        d(V), g(G);
      },
      setChildCount: (V) => f(V),
      addOrRemoveCssClass: (V, G) => m((k) => k.setClass(V, G)),
      setContractedDisplayed: (V) => b((G) => G.setClass("ag-hidden", !V)),
      setExpandedDisplayed: (V) => C((G) => G.setClass("ag-hidden", !V)),
      setCheckboxVisible: (V) => x((G) => G.setClass("ag-invisible", !V))
    }, M = r.getInstance("groupCellRendererCtrl");
    M && (u.current = n.createBean(M), u.current.init(
      B,
      i.current,
      a.current,
      s.current,
      l.current,
      CX,
      e
    ));
  }, []), _ = Et(() => `ag-cell-wrapper ${v.toString()}`, [v]), T = Et(() => `ag-group-expanded ${y.toString()}`, [y]), P = Et(
    () => `ag-group-contracted ${S.toString()}`,
    [S]
  ), D = Et(() => `ag-group-checkbox ${w.toString()}`, [w]), O = c && c.componentFromFramework, A = O ? c.componentClass : void 0, F = c == null && p != null, L = hs(p, !0);
  return /* @__PURE__ */ H.createElement(
    "span",
    {
      className: _,
      ref: R,
      ...e.colDef ? {} : { role: (N = u.current) == null ? void 0 : N.getCellAriaRole() }
    },
    /* @__PURE__ */ H.createElement("span", { className: T, ref: s }),
    /* @__PURE__ */ H.createElement("span", { className: P, ref: l }),
    /* @__PURE__ */ H.createElement("span", { className: D, ref: a }),
    /* @__PURE__ */ H.createElement("span", { className: "ag-group-value", ref: o }, F && /* @__PURE__ */ H.createElement(H.Fragment, null, L), O && /* @__PURE__ */ H.createElement(A, { ...c.params })),
    /* @__PURE__ */ H.createElement("span", { className: "ag-group-child-count" }, h)
  );
}), oG = CX, OI = du({
  setMethods: () => {
  }
}), mWe = (e) => {
  const { initialProps: t, addUpdateCallback: r, CustomComponentClass: n, setMethods: i } = e, [o, a] = Me(t);
  return Nt(() => {
    r((s) => a(s));
  }, []), /* @__PURE__ */ H.createElement(OI.Provider, { value: { setMethods: i } }, /* @__PURE__ */ H.createElement(n, { ...o }));
}, yWe = eo(mWe), CWe = 0;
function aG() {
  return `agPortalKey_${++CWe}`;
}
var SX = class {
  constructor(e, t, r, n) {
    this.portal = null, this.oldPortal = null, this.reactComponent = e, this.portalManager = t, this.componentType = r, this.suppressFallbackMethods = !!n, this.statelessComponent = this.isStateless(this.reactComponent), this.key = aG(), this.portalKey = aG(), this.instanceCreated = this.isStatelessComponent() ? gn.resolve(!1) : new gn((i) => {
      this.resolveInstanceCreated = i;
    });
  }
  getGui() {
    return this.eParentElement;
  }
  /** `getGui()` returns the parent element. This returns the actual root element. */
  getRootElement() {
    return this.eParentElement.firstChild;
  }
  destroy() {
    this.componentInstance && typeof this.componentInstance.destroy == "function" && this.componentInstance.destroy();
    const e = this.portal;
    e && this.portalManager.destroyPortal(e);
  }
  createParentElement(e) {
    const t = this.portalManager.getComponentWrappingElement(), r = document.createElement(t || "div");
    return r.classList.add("ag-react-container"), e.reactContainer = r, r;
  }
  addParentContainerStyleAndClasses() {
    this.componentInstance && (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle() && (Te(
      'Since v31.1 "getReactContainerStyle" is deprecated. Apply styling directly to ".ag-react-container" if needed.'
    ), Object.assign(this.eParentElement.style, this.componentInstance.getReactContainerStyle())), this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses() && (Te(
      'Since v31.1 "getReactContainerClasses" is deprecated. Apply styling directly to ".ag-react-container" if needed.'
    ), this.componentInstance.getReactContainerClasses().forEach((t) => this.eParentElement.classList.add(t))));
  }
  statelessComponentRendered() {
    return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  isStatelessComponent() {
    return this.statelessComponent;
  }
  getReactComponentName() {
    return this.reactComponent.name;
  }
  getMemoType() {
    return this.hasSymbol() ? Symbol.for("react.memo") : 60115;
  }
  hasSymbol() {
    return typeof Symbol == "function" && Symbol.for;
  }
  isStateless(e) {
    return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === this.getMemoType();
  }
  hasMethod(e) {
    const t = this.getFrameworkComponentInstance();
    return !!t && t[e] != null || this.fallbackMethodAvailable(e);
  }
  callMethod(e, t) {
    const r = this.getFrameworkComponentInstance();
    if (this.isStatelessComponent())
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
    if (!r) {
      setTimeout(() => this.callMethod(e, t));
      return;
    }
    const n = r[e];
    if (n)
      return n.apply(r, t);
    if (this.fallbackMethodAvailable(e))
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
  }
  addMethod(e, t) {
    this[e] = t;
  }
  init(e) {
    return this.eParentElement = this.createParentElement(e), this.params = e, this.createOrUpdatePortal(e), new gn((t) => this.createReactComponent(t));
  }
  createOrUpdatePortal(e) {
    this.isStatelessComponent() || (this.ref = (t) => {
      var r;
      this.componentInstance = t, this.addParentContainerStyleAndClasses(), (r = this.resolveInstanceCreated) == null || r.call(this, !0), this.resolveInstanceCreated = void 0;
    }, e.ref = this.ref), this.reactElement = this.createElement(this.reactComponent, { ...e, key: this.key }), this.portal = yP(
      this.reactElement,
      this.eParentElement,
      this.portalKey
      // fixed deltaRowModeRefreshCompRenderer
    );
  }
  createElement(e, t) {
    return CG(e, t);
  }
  createReactComponent(e) {
    this.portalManager.mountReactPortal(this.portal, this, e);
  }
  rendered() {
    return this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
  }
  /*
   * fallback methods - these will be invoked if a corresponding instance method is not present
   * for example if refresh is called and is not available on the component instance, then refreshComponent on this
   * class will be invoked instead
   *
   * Currently only refresh is supported
   */
  refreshComponent(e) {
    this.oldPortal = this.portal, this.createOrUpdatePortal(e), this.portalManager.updateReactPortal(this.oldPortal, this.portal);
  }
  fallbackMethod(e, t) {
    const r = this[`${e}Component`];
    if (!this.suppressFallbackMethods && r)
      return r.bind(this)(t);
  }
  fallbackMethodAvailable(e) {
    return this.suppressFallbackMethods ? !1 : !!this[`${e}Component`];
  }
};
function LI(e, t, r) {
  e.forEach((n) => {
    const i = t[n];
    i && (r[n] = i);
  });
}
var dl = class extends SX {
  constructor() {
    super(...arguments), this.awaitUpdateCallback = new gn((e) => {
      this.resolveUpdateCallback = e;
    }), this.wrapperComponent = yWe;
  }
  init(e) {
    return this.sourceParams = e, super.init(this.getProps());
  }
  addMethod() {
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  getFrameworkComponentInstance() {
    return this;
  }
  createElement(e, t) {
    return super.createElement(this.wrapperComponent, {
      initialProps: t,
      CustomComponentClass: e,
      setMethods: (r) => this.setMethods(r),
      addUpdateCallback: (r) => {
        this.updateCallback = () => (r(this.getProps()), new gn((n) => {
          setTimeout(() => {
            n();
          });
        })), this.resolveUpdateCallback();
      }
    });
  }
  setMethods(e) {
    this.providedMethods = e, LI(this.getOptionalMethods(), this.providedMethods, this);
  }
  getOptionalMethods() {
    return [];
  }
  getProps() {
    return {
      ...this.sourceParams,
      key: this.key,
      ref: this.ref
    };
  }
  refreshProps() {
    return this.updateCallback ? this.updateCallback() : new gn(
      (e) => this.awaitUpdateCallback.then(() => {
        this.updateCallback().then(() => e());
      })
    );
  }
}, SWe = class extends dl {
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
}, wWe = class extends dl {
  constructor() {
    super(...arguments), this.date = null, this.onDateChange = (e) => this.updateDate(e);
  }
  getDate() {
    return this.date;
  }
  setDate(e) {
    this.date = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled"];
  }
  updateDate(e) {
    this.setDate(e), this.sourceParams.onDateChanged();
  }
  getProps() {
    const e = super.getProps();
    return e.date = this.date, e.onDateChange = this.onDateChange, delete e.onDateChanged, e;
  }
}, bWe = class extends dl {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e), this.onUiChange = () => this.sourceParams.filterChangedCallback(), this.expectingNewMethods = !0;
  }
  isFilterActive() {
    return this.model != null;
  }
  doesFilterPass(e) {
    return this.providedMethods.doesFilterPass(e);
  }
  getModel() {
    return this.model;
  }
  setModel(e) {
    return this.expectingNewMethods = !0, this.model = e, this.refreshProps();
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onAnyFilterChanged"];
  }
  setMethods(e) {
    var t;
    this.expectingNewMethods === !1 && ((t = this.providedMethods) == null ? void 0 : t.doesFilterPass) !== (e == null ? void 0 : e.doesFilterPass) && setTimeout(() => {
      this.sourceParams.filterChangedCallback();
    }), this.expectingNewMethods = !1, super.setMethods(e);
  }
  updateModel(e) {
    this.setModel(e).then(() => this.sourceParams.filterChangedCallback());
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e.onUiChange = this.onUiChange, delete e.filterChangedCallback, delete e.filterModifiedCallback, delete e.valueGetter, e;
  }
};
function wX(e, t) {
  e.parentFilterInstance((r) => {
    (r.setModel(t) || gn.resolve()).then(() => {
      e.filterParams.filterChangedCallback();
    });
  });
}
var xWe = class {
  constructor(e, t) {
    this.floatingFilterParams = e, this.refreshProps = t, this.model = null, this.onModelChange = (r) => this.updateModel(r);
  }
  getProps() {
    return {
      ...this.floatingFilterParams,
      model: this.model,
      onModelChange: this.onModelChange
    };
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.floatingFilterParams = e, this.refreshProps();
  }
  setMethods(e) {
    LI(this.getOptionalMethods(), e, this);
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), wX(this.floatingFilterParams, e);
  }
}, EWe = class extends dl {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e);
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), wX(this.sourceParams, e);
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e;
  }
}, RWe = class extends dl {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, _We = class extends dl {
  constructor() {
    super(...arguments), this.active = !1, this.expanded = !1, this.onActiveChange = (e) => this.updateActive(e);
  }
  setActive(e) {
    this.awaitSetActive(e);
  }
  setExpanded(e) {
    this.expanded = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["select", "configureDefaults"];
  }
  awaitSetActive(e) {
    return this.active = e, this.refreshProps();
  }
  updateActive(e) {
    const t = this.awaitSetActive(e);
    e && t.then(() => this.sourceParams.onItemActivated());
  }
  getProps() {
    const e = super.getProps();
    return e.active = this.active, e.expanded = this.expanded, e.onActiveChange = this.onActiveChange, delete e.onItemActivated, e;
  }
}, TWe = class extends dl {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, PWe = class extends dl {
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
}, MWe = class extends dl {
  constructor() {
    super(...arguments), this.onStateChange = (e) => this.updateState(e);
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
  getState() {
    return this.state;
  }
  updateState(e) {
    this.state = e, this.refreshProps(), this.sourceParams.onStateUpdated();
  }
  getProps() {
    const e = super.getProps();
    return e.state = this.state, e.onStateChange = this.onStateChange, e;
  }
};
function FI() {
  Te("As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.");
}
var DWe = 1e3, AWe = class {
  constructor(e, t, r) {
    this.destroyed = !1, this.portals = [], this.hasPendingPortalUpdate = !1, this.wrappingElement = t || "div", this.refresher = e, this.maxComponentCreationTimeMs = r || DWe;
  }
  getPortals() {
    return this.portals;
  }
  destroy() {
    this.destroyed = !0;
  }
  destroyPortal(e) {
    this.portals = this.portals.filter((t) => t !== e), this.batchUpdate();
  }
  getComponentWrappingElement() {
    return this.wrappingElement;
  }
  mountReactPortal(e, t, r) {
    this.portals = [...this.portals, e], this.waitForInstance(t, r), this.batchUpdate();
  }
  updateReactPortal(e, t) {
    this.portals[this.portals.indexOf(e)] = t, this.batchUpdate();
  }
  batchUpdate() {
    this.hasPendingPortalUpdate || (setTimeout(() => {
      this.destroyed || (this.refresher(), this.hasPendingPortalUpdate = !1);
    }), this.hasPendingPortalUpdate = !0);
  }
  waitForInstance(e, t, r = Date.now()) {
    if (this.destroyed) {
      t(null);
      return;
    }
    if (e.rendered())
      t(e);
    else {
      if (Date.now() - r >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate)
        return;
      window.setTimeout(() => {
        this.waitForInstance(e, t, r);
      });
    }
  }
}, IWe = (e) => {
  const { ctrl: t } = e, r = t.isAlive(), { context: n } = vr(ki), i = r ? t.getColId() : void 0, [o, a] = Me(), s = se(null), l = se(null), u = se(null), c = se(), d = se();
  r && !d.current && (d.current = new tm(() => s.current));
  const h = lr((v) => {
    var C;
    if (s.current = v, !s.current || !r)
      return;
    const m = {
      setWidth: (S) => {
        s.current && (s.current.style.width = S);
      },
      addOrRemoveCssClass: (S, b) => d.current.addOrRemoveCssClass(S, b),
      setAriaSort: (S) => {
        s.current && (S ? VBe(s.current, S) : BBe(s.current));
      },
      setUserCompDetails: (S) => a(S),
      getUserCompInstance: () => c.current || void 0
    };
    t.setComp(m, s.current, l.current, u.current);
    const y = t.getSelectAllGui();
    (C = l.current) == null || C.insertAdjacentElement("afterend", y);
  }, []);
  as(
    () => im(o, n, u.current, c),
    [o]
  ), Nt(() => {
    t.setDragSource(s.current);
  }, [o]);
  const f = Et(() => !!((o == null ? void 0 : o.componentFromFramework) && Ff(o.componentClass)), [o]), p = o && o.componentFromFramework, g = o && o.componentClass;
  return /* @__PURE__ */ H.createElement("div", { ref: h, className: "ag-header-cell", "col-id": i, role: "columnheader" }, /* @__PURE__ */ H.createElement("div", { ref: l, className: "ag-header-cell-resize", role: "presentation" }), /* @__PURE__ */ H.createElement("div", { ref: u, className: "ag-header-cell-comp-wrapper", role: "presentation" }, p && f && /* @__PURE__ */ H.createElement(g, { ...o.params }), p && !f && /* @__PURE__ */ H.createElement(g, { ...o.params, ref: c })));
}, OWe = eo(IWe), LWe = (e) => {
  const { context: t, gos: r } = vr(ki), [n, i] = Me(
    () => new Uo("ag-header-cell", "ag-floating-filter")
  ), [o, a] = Me(() => new Uo()), [s, l] = Me(
    () => new Uo("ag-floating-filter-button", "ag-hidden")
  ), [u, c] = Me("false"), [d, h] = Me(), [, f] = Me(1), p = se(null), g = se(null), v = se(null), m = se(null), y = se(), C = se(), S = (L) => {
    L != null && y.current && y.current(L);
  }, { ctrl: b } = e, w = lr((L) => {
    if (p.current = L, !p.current)
      return;
    C.current = new gn((I) => {
      y.current = I;
    });
    const N = {
      addOrRemoveCssClass: (I, B) => i((M) => M.setClass(I, B)),
      addOrRemoveBodyCssClass: (I, B) => a((M) => M.setClass(I, B)),
      setButtonWrapperDisplayed: (I) => {
        l((B) => B.setClass("ag-hidden", !I)), c(I ? "false" : "true");
      },
      setWidth: (I) => {
        p.current && (p.current.style.width = I);
      },
      setCompDetails: (I) => h(I),
      getFloatingFilterComp: () => C.current ? C.current : null,
      setMenuIcon: (I) => {
        var B;
        return (B = m.current) == null ? void 0 : B.appendChild(I);
      }
    };
    b.setComp(N, p.current, m.current, g.current);
  }, []);
  as(
    () => im(d, t, g.current, S),
    [d]
  );
  const x = Et(() => n.toString(), [n]), R = Et(() => o.toString(), [o]), _ = Et(() => s.toString(), [s]), T = Et(() => !!(d && d.componentFromFramework && Ff(d.componentClass)), [d]), P = Et(() => r.get("reactiveCustomComponents"), []), D = Et(() => {
    if (d)
      if (P) {
        const L = new xWe(
          d.params,
          () => f((N) => N + 1)
        );
        return S(L), L;
      } else d.componentFromFramework && FI();
  }, [d]), O = D == null ? void 0 : D.getProps(), A = d && d.componentFromFramework, F = d && d.componentClass;
  return /* @__PURE__ */ H.createElement("div", { ref: w, className: x, role: "gridcell" }, /* @__PURE__ */ H.createElement("div", { ref: g, className: R, role: "presentation" }, A && !P && /* @__PURE__ */ H.createElement(F, { ...d.params, ref: T ? () => {
  } : S }), A && P && /* @__PURE__ */ H.createElement(
    OI.Provider,
    {
      value: {
        setMethods: (L) => D.setMethods(L)
      }
    },
    /* @__PURE__ */ H.createElement(F, { ...O })
  )), /* @__PURE__ */ H.createElement(
    "div",
    {
      ref: v,
      "aria-hidden": u,
      className: _,
      role: "presentation"
    },
    /* @__PURE__ */ H.createElement(
      "button",
      {
        ref: m,
        type: "button",
        className: "ag-button ag-floating-filter-button-button",
        tabIndex: -1
      }
    )
  ));
}, FWe = eo(LWe), NWe = (e) => {
  const { context: t } = vr(ki), { ctrl: r } = e, [n, i] = Me(() => new Uo()), [o, a] = Me(() => new Uo()), [s, l] = Me("false"), [u, c] = Me(), [d, h] = Me(), f = Et(() => r.getColId(), []), p = se(null), g = se(null), v = se(), m = lr((x) => {
    if (p.current = x, !p.current)
      return;
    const R = {
      setWidth: (_) => {
        p.current && (p.current.style.width = _);
      },
      addOrRemoveCssClass: (_, T) => i((P) => P.setClass(_, T)),
      setUserCompDetails: (_) => h(_),
      setResizableDisplayed: (_) => {
        a((T) => T.setClass("ag-hidden", !_)), l(_ ? "false" : "true");
      },
      setAriaExpanded: (_) => c(_),
      getUserCompInstance: () => v.current || void 0
    };
    r.setComp(R, p.current, g.current);
  }, []);
  as(() => im(d, t, p.current), [d]), Nt(() => {
    p.current && r.setDragSource(p.current);
  }, [d]);
  const y = Et(() => !!((d == null ? void 0 : d.componentFromFramework) && Ff(d.componentClass)), [d]), C = Et(() => "ag-header-group-cell " + n.toString(), [n]), S = Et(
    () => "ag-header-cell-resize " + o.toString(),
    [o]
  ), b = d && d.componentFromFramework, w = d && d.componentClass;
  return /* @__PURE__ */ H.createElement("div", { ref: m, className: C, "col-id": f, role: "columnheader", "aria-expanded": u }, b && y && /* @__PURE__ */ H.createElement(w, { ...d.params }), b && !y && /* @__PURE__ */ H.createElement(w, { ...d.params, ref: v }), /* @__PURE__ */ H.createElement("div", { ref: g, "aria-hidden": s, className: S }));
}, kWe = eo(NWe), VWe = (e) => {
  const { ctrl: t } = e, { topOffset: r, rowHeight: n } = Et(() => t.getTopAndHeight(), []), i = t.getAriaRowIndex(), o = t.getHeaderRowClass(), [a, s] = Me(() => n + "px"), [l, u] = Me(() => r + "px"), c = se(null), d = se(null), [h, f] = Me(() => t.getHeaderCtrls()), p = se(null), g = lr((y) => {
    if (p.current = y, !y)
      return;
    const C = {
      setHeight: (S) => s(S),
      setTop: (S) => u(S),
      setHeaderCtrls: (S, b, w) => {
        d.current = c.current, c.current = S;
        const x = II(d.current, S, b);
        x !== d.current && AI(w, () => f(x));
      },
      setWidth: (S) => {
        p.current && (p.current.style.width = S);
      }
    };
    t.setComp(C, !1);
  }, []), v = Et(
    () => ({
      height: a,
      top: l
    }),
    [a, l]
  ), m = lr((y) => {
    switch (t.getType()) {
      case fP.COLUMN_GROUP:
        return /* @__PURE__ */ H.createElement(kWe, { ctrl: y, key: y.getInstanceId() });
      case fP.FLOATING_FILTER:
        return /* @__PURE__ */ H.createElement(FWe, { ctrl: y, key: y.getInstanceId() });
      default:
        return /* @__PURE__ */ H.createElement(OWe, { ctrl: y, key: y.getInstanceId() });
    }
  }, []);
  return /* @__PURE__ */ H.createElement("div", { ref: g, className: o, role: "row", style: v, "aria-rowindex": i }, h.map(m));
}, BWe = eo(VWe), $We = (e) => {
  const [t, r] = Me(!0), [n, i] = Me([]), { context: o } = vr(ki), a = se(null), s = se(null), l = se(null), u = e.pinned === "left", c = e.pinned === "right", d = !u && !c, h = lr((g) => {
    if (a.current = g, !a.current) {
      o.destroyBean(l.current), l.current = null;
      return;
    }
    const v = {
      setDisplayed: r,
      setCtrls: (m) => i(m),
      // centre only
      setCenterWidth: (m) => {
        s.current && (s.current.style.width = m);
      },
      setViewportScrollLeft: (m) => {
        a.current && (a.current.scrollLeft = m);
      },
      // pinned only
      setPinnedContainerWidth: (m) => {
        a.current && (a.current.style.width = m, a.current.style.minWidth = m, a.current.style.maxWidth = m);
      }
    };
    l.current = o.createBean(new gHe(e.pinned)), l.current.setComp(v, a.current);
  }, []), f = t ? "" : "ag-hidden", p = () => n.map((g) => /* @__PURE__ */ H.createElement(BWe, { ctrl: g, key: g.getInstanceId() }));
  return /* @__PURE__ */ H.createElement(H.Fragment, null, u && /* @__PURE__ */ H.createElement(
    "div",
    {
      ref: h,
      className: "ag-pinned-left-header " + f,
      "aria-hidden": !t,
      role: "rowgroup"
    },
    p()
  ), c && /* @__PURE__ */ H.createElement(
    "div",
    {
      ref: h,
      className: "ag-pinned-right-header " + f,
      "aria-hidden": !t,
      role: "rowgroup"
    },
    p()
  ), d && /* @__PURE__ */ H.createElement("div", { ref: h, className: "ag-header-viewport " + f, role: "presentation" }, /* @__PURE__ */ H.createElement("div", { ref: s, className: "ag-header-container", role: "rowgroup" }, p())));
}, IE = eo($We), HWe = () => {
  const [e, t] = Me(() => new Uo()), [r, n] = Me(), { context: i } = vr(ki), o = se(null), a = se(null), s = lr((c) => {
    if (o.current = c, !c) {
      i.destroyBean(a.current), a.current = null;
      return;
    }
    const d = {
      addOrRemoveCssClass: (h, f) => t((p) => p.setClass(h, f)),
      setHeightAndMinHeight: (h) => n(h)
    };
    a.current = i.createBean(new eHe()), a.current.setComp(d, o.current, o.current);
  }, []), l = Et(() => "ag-header " + e.toString(), [e]), u = Et(
    () => ({
      height: r,
      minHeight: r
    }),
    [r]
  );
  return /* @__PURE__ */ H.createElement("div", { ref: s, className: l, style: u, role: "presentation" }, /* @__PURE__ */ H.createElement(IE, { pinned: "left" }), /* @__PURE__ */ H.createElement(IE, { pinned: null }), /* @__PURE__ */ H.createElement(IE, { pinned: "right" }));
}, GWe = eo(HWe), zWe = (e, t) => {
  Nt(() => {
    const r = t.current;
    if (r) {
      const n = r.parentElement;
      if (n) {
        const i = document.createComment(e);
        return n.insertBefore(i, r), () => {
          n.removeChild(i);
        };
      }
    }
  }, [e]);
}, hc = zWe, WWe = class {
  constructor(e, t) {
    this.cellEditorParams = e, this.refreshProps = t, this.instanceCreated = new gn((r) => {
      this.resolveInstanceCreated = r;
    }), this.onValueChange = (r) => this.updateValue(r), this.value = e.value;
  }
  getProps() {
    return {
      ...this.cellEditorParams,
      initialValue: this.cellEditorParams.value,
      value: this.value,
      onValueChange: this.onValueChange
    };
  }
  getValue() {
    return this.value;
  }
  refresh(e) {
    this.cellEditorParams = e, this.refreshProps();
  }
  setMethods(e) {
    LI(this.getOptionalMethods(), e, this);
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  setRef(e) {
    var t;
    this.componentInstance = e, (t = this.resolveInstanceCreated) == null || t.call(this), this.resolveInstanceCreated = void 0;
  }
  getOptionalMethods() {
    return ["isCancelBeforeStart", "isCancelAfterEnd", "focusIn", "focusOut", "afterGuiAttached"];
  }
  updateValue(e) {
    this.value = e, this.refreshProps();
  }
}, jWe = (e) => {
  const t = se(e), r = se(), n = se(!1), i = se(!1), [, o] = Me(0);
  n.current && (i.current = !0), Nt(() => (n.current || (r.current = t.current(), n.current = !0), o((a) => a + 1), () => {
    i.current && r.current && r.current();
  }), []);
}, UWe = (e) => {
  const [t, r] = Me(), { context: n, popupService: i, localeService: o, gos: a, editService: s } = vr(ki);
  return jWe(() => {
    const { editDetails: l, cellCtrl: u, eParentCell: c } = e, { compDetails: d } = l, h = a.get("stopEditingWhenCellsLoseFocus"), f = n.createBean(s.createPopupEditorWrapper(d.params)), p = f.getGui();
    if (e.jsChildComp) {
      const S = e.jsChildComp.getGui();
      S && p.appendChild(S);
    }
    const g = {
      column: u.getColumn(),
      rowNode: u.getRowNode(),
      type: "popupCellEditor",
      eventSource: c,
      ePopup: p,
      position: l.popupPosition,
      keepWithinBounds: !0
    }, v = i.positionPopupByComponent.bind(i, g), m = o.getLocaleTextFunc(), y = i.addPopup({
      modal: h,
      eChild: p,
      closeOnEsc: !0,
      closedCallback: () => {
        u.onPopupEditorClosed();
      },
      anchorToElement: c,
      positionCallback: v,
      ariaLabel: m("ariaLabelCellEditor", "Cell Editor")
    }), C = y ? y.hideFunc : void 0;
    return r(f), e.jsChildComp && e.jsChildComp.afterGuiAttached && e.jsChildComp.afterGuiAttached(), () => {
      C != null && C(), n.destroyBean(f);
    };
  }), /* @__PURE__ */ H.createElement(H.Fragment, null, t && e.wrappedContent && yP(e.wrappedContent, t.getGui()));
}, sG = eo(UWe), KWe = (e, t, r, n, i, o) => {
  const { context: a } = vr(ki), s = lr(() => {
    const l = i.current;
    if (!l)
      return;
    const u = l.getGui();
    u && u.parentElement && u.parentElement.removeChild(u), a.destroyBean(l), i.current = void 0;
  }, []);
  Nt(() => {
    const l = e != null, u = e && e.compDetails && !e.compDetails.componentFromFramework, c = t && r == null;
    if (!(l && u && !c)) {
      s();
      return;
    }
    const h = e.compDetails;
    if (i.current) {
      const p = i.current, v = p.refresh != null && e.force == !1 ? p.refresh(h.params) : !1;
      if (v === !0 || v === void 0)
        return;
      s();
    }
    const f = h.newAgStackInstance();
    f != null && f.then((p) => {
      if (!p)
        return;
      const g = p.getGui();
      if (!g)
        return;
      (t ? r : o.current).appendChild(g), i.current = p;
    });
  }, [e, t, n]), Nt(() => s, []);
}, YWe = KWe, qWe = (e, t, r) => {
  const { compProxy: n } = e;
  r(n);
  const i = n.getProps(), o = Ff(t);
  return /* @__PURE__ */ H.createElement(
    OI.Provider,
    {
      value: {
        setMethods: (a) => n.setMethods(a)
      }
    },
    o && /* @__PURE__ */ H.createElement(t, { ...i }),
    !o && /* @__PURE__ */ H.createElement(t, { ...i, ref: (a) => n.setRef(a) })
  );
}, lG = (e, t, r) => {
  const n = e.compProxy;
  return /* @__PURE__ */ H.createElement(H.Fragment, null, !n && /* @__PURE__ */ H.createElement(t, { ...e.compDetails.params, ref: r }), n && qWe(e, t, r));
}, XWe = (e, t, r, n, i, o) => {
  const a = e.compDetails, s = a.componentClass, l = a.componentFromFramework && !e.popup, u = a.componentFromFramework && e.popup, c = !a.componentFromFramework && e.popup;
  return /* @__PURE__ */ H.createElement(H.Fragment, null, l && lG(e, s, t), u && /* @__PURE__ */ H.createElement(
    sG,
    {
      editDetails: e,
      cellCtrl: i,
      eParentCell: n,
      wrappedContent: lG(e, s, r)
    }
  ), c && o && /* @__PURE__ */ H.createElement(
    sG,
    {
      editDetails: e,
      cellCtrl: i,
      eParentCell: n,
      jsChildComp: o
    }
  ));
}, ZWe = (e, t, r, n, i, o, a) => {
  const { compDetails: s, value: l } = e, u = !s, c = s && s.componentFromFramework, d = s && s.componentClass, h = l != null && l.toString ? l.toString() : l, f = () => /* @__PURE__ */ H.createElement(H.Fragment, null, u && /* @__PURE__ */ H.createElement(H.Fragment, null, h), c && !o && /* @__PURE__ */ H.createElement(d, { ...s.params, key: t, ref: n }), c && o && /* @__PURE__ */ H.createElement(d, { ...s.params, key: t }));
  return /* @__PURE__ */ H.createElement(H.Fragment, null, i ? /* @__PURE__ */ H.createElement("span", { role: "presentation", id: `cell-${r}`, className: "ag-cell-value", ref: a }, f()) : f());
}, QWe = (e) => {
  const { context: t } = vr(ki), { cellCtrl: r, printLayout: n, editingRow: i } = e, o = r.getTabIndex(), a = r.getColumnIdSanitised(), s = r.getInstanceId(), [l, u] = Me(
    () => r.isCellRenderer() ? void 0 : { compDetails: void 0, value: r.getValueToDisplay(), force: !1 }
  ), [c, d] = Me(), [h, f] = Me(1), [p, g] = Me(), [v, m] = Me(!1), [y, C] = Me(!1), [S, b] = Me(!1), [w, x] = Me(), R = Et(() => r.isForceWrapper(), [r]), _ = Et(() => r.getCellAriaRole(), [r]), T = se(null), P = se(null), D = se(), O = se(), A = se(), F = se([]), L = se(), [N, I] = Me(0), B = lr((Y) => {
    L.current = Y, I((U) => U + 1);
  }, []), M = l != null && (v || S || y), V = R || M, G = lr(
    (Y, U) => {
      O.current = U, U && U.isCancelBeforeStart && U.isCancelBeforeStart() && setTimeout(() => {
        r.stopEditing(!0), r.focusCell(!0);
      });
    },
    [r]
  ), k = lr(
    (Y) => G(!0, Y),
    [G]
  ), z = lr(
    (Y) => G(!1, Y),
    [G]
  ), j = se();
  j.current || (j.current = new tm(() => T.current)), YWe(l, V, L.current, N, D, T);
  const q = se();
  as(() => {
    const Y = q.current, U = l;
    if (q.current = l, Y == null || Y.compDetails == null || U == null || U.compDetails == null)
      return;
    const oe = Y.compDetails, W = U.compDetails;
    if (oe.componentClass != W.componentClass || P.current == null || P.current.refresh == null)
      return;
    P.current.refresh(W.params) != !0 && f((ce) => ce + 1);
  }, [l]), as(() => {
    if (!(c && !c.compDetails.componentFromFramework))
      return;
    const U = c.compDetails, oe = c.popup === !0, W = U.newAgStackInstance();
    return W.then((ne) => {
      if (!ne)
        return;
      const ce = ne.getGui();
      if (G(oe, ne), !oe) {
        const we = (R ? A : T).current;
        we == null || we.appendChild(ce), ne.afterGuiAttached && ne.afterGuiAttached();
      }
      x(ne);
    }), () => {
      W.then((ne) => {
        const ce = ne.getGui();
        t.destroyBean(ne), G(oe, void 0), x(void 0), ce && ce.parentElement && ce.parentElement.removeChild(ce);
      });
    };
  }, [c]);
  const K = lr(
    (Y) => {
      if (A.current = Y, !A.current) {
        F.current.forEach((oe) => oe()), F.current = [];
        return;
      }
      const U = (oe) => {
        var W;
        if (oe) {
          const ne = oe.getGui();
          (W = A.current) == null || W.insertAdjacentElement("afterbegin", ne), F.current.push(() => {
            t.destroyBean(oe), Xc(ne);
          });
        }
        return oe;
      };
      if (v) {
        const oe = r.createSelectionCheckbox();
        U(oe);
      }
      S && U(r.createDndSource()), y && U(r.createRowDragComp());
    },
    [r, t, S, y, v]
  ), Z = lr((Y) => {
    if (T.current = Y, !T.current || !r)
      return;
    const U = {
      addOrRemoveCssClass: (W, ne) => j.current.addOrRemoveCssClass(W, ne),
      setUserStyles: (W) => g(W),
      getFocusableElement: () => T.current,
      setIncludeSelection: (W) => m(W),
      setIncludeRowDrag: (W) => C(W),
      setIncludeDndSource: (W) => b(W),
      getCellEditor: () => O.current || null,
      getCellRenderer: () => P.current ? P.current : D.current,
      getParentOfValue: () => L.current ? L.current : A.current ? A.current : T.current,
      setRenderDetails: (W, ne, ce) => {
        u((we) => (we == null ? void 0 : we.compDetails) !== W || (we == null ? void 0 : we.value) !== ne || (we == null ? void 0 : we.force) !== ce ? {
          value: ne,
          compDetails: W,
          force: ce
        } : we);
      },
      setEditDetails: (W, ne, ce, we) => {
        if (W) {
          let Re;
          we ? Re = new WWe(
            W.params,
            () => f((ve) => ve + 1)
          ) : W.componentFromFramework && FI(), d({
            compDetails: W,
            popup: ne,
            popupPosition: ce,
            compProxy: Re
          }), ne || u(void 0);
        } else
          d((Re) => {
            Re != null && Re.compProxy && (O.current = void 0);
          });
      }
    }, oe = A.current || void 0;
    r.setComp(U, T.current, oe, n, i);
  }, []), re = Et(() => !!(l && l.compDetails && l.compDetails.componentFromFramework && Ff(l.compDetails.componentClass)), [l]);
  as(() => {
    var Y;
    T.current && (j.current.addOrRemoveCssClass("ag-cell-value", !V), j.current.addOrRemoveCssClass("ag-cell-inline-editing", !!c && !c.popup), j.current.addOrRemoveCssClass("ag-cell-popup-editing", !!c && !!c.popup), j.current.addOrRemoveCssClass("ag-cell-not-inline-editing", !c || !!c.popup), (Y = r.getRowCtrl()) == null || Y.setInlineEditingCss(!!c), r.shouldRestoreFocus() && !r.isEditing() && T.current.focus({ preventScroll: !0 }));
  });
  const X = () => /* @__PURE__ */ H.createElement(H.Fragment, null, l != null && ZWe(
    l,
    h,
    s,
    P,
    V,
    re,
    B
  ), c != null && XWe(
    c,
    z,
    k,
    T.current,
    r,
    w
  ));
  return /* @__PURE__ */ H.createElement("div", { ref: Z, style: p, tabIndex: o, role: _, "col-id": a }, V ? /* @__PURE__ */ H.createElement("div", { className: "ag-cell-wrapper", role: "presentation", ref: K }, X()) : X());
}, JWe = eo(QWe), e7e = (e) => {
  const { context: t, gos: r } = vr(ki), { rowCtrl: n, containerType: i } = e, o = n.getTabIndex(), a = se(n.getDomOrder()), s = n.isFullWidth(), l = n.getRowNode().displayed, [u, c] = Me(() => l ? n.getRowIndex() : null), [d, h] = Me(() => n.getRowId()), [f, p] = Me(() => n.getBusinessKey()), [g, v] = Me(() => n.getRowStyles()), m = se(null), y = se(null), [C, S] = Me(() => null), [b, w] = Me(), [x, R] = Me(
    () => l ? n.getInitialRowTop(i) : void 0
  ), [_, T] = Me(
    () => l ? n.getInitialTransform(i) : void 0
  ), P = se(null), D = se(), O = se(!1), [A, F] = Me(0);
  Nt(() => {
    var q;
    if (O.current || !b || A > 10)
      return;
    const j = (q = P.current) == null ? void 0 : q.firstChild;
    j ? (n.setupDetailRowAutoHeight(j), O.current = !0) : F((K) => K + 1);
  }, [b, A]);
  const L = se();
  L.current || (L.current = new tm(() => P.current));
  const N = lr((j) => {
    if (P.current = j, !P.current) {
      n.unsetComp(i);
      return;
    }
    if (!n.isAlive())
      return;
    const q = {
      // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
      // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
      setTop: R,
      setTransform: T,
      // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
      // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
      addOrRemoveCssClass: (K, Z) => L.current.addOrRemoveCssClass(K, Z),
      setDomOrder: (K) => a.current = K,
      setRowIndex: c,
      setRowId: h,
      setRowBusinessKey: p,
      setUserStyles: v,
      // if we don't maintain the order, then cols will be ripped out and into the dom
      // when cols reordered, which would stop the CSS transitions from working
      setCellCtrls: (K, Z) => {
        y.current = m.current, m.current = K;
        const re = II(y.current, K, a.current);
        re !== y.current && AI(Z, () => S(re));
      },
      showFullWidth: (K) => w(K),
      getFullWidthCellRenderer: () => D.current,
      refreshFullWidth: (K) => G.current ? (w((Z) => ({
        ...Z,
        params: K()
      })), !0) : !D.current || !D.current.refresh ? !1 : D.current.refresh(K())
    };
    n.setComp(q, P.current, i);
  }, []);
  as(
    () => im(b, t, P.current, D),
    [b]
  );
  const I = Et(() => {
    const j = { top: x, transform: _ };
    return Object.assign(j, g), j;
  }, [x, _, g]), B = s && b && b.componentFromFramework, M = !s && C != null, V = Et(() => !!((b == null ? void 0 : b.componentFromFramework) && Ff(b.componentClass)), [b]), G = se(!1);
  Nt(() => {
    G.current = V && !!b && !!r.get("reactiveCustomComponents");
  }, [V, b]);
  const k = () => C == null ? void 0 : C.map((j) => /* @__PURE__ */ H.createElement(
    JWe,
    {
      cellCtrl: j,
      editingRow: n.isEditing(),
      printLayout: n.isPrintLayout(),
      key: j.getInstanceId()
    }
  )), z = () => {
    const j = b.componentClass;
    return /* @__PURE__ */ H.createElement(H.Fragment, null, V && /* @__PURE__ */ H.createElement(j, { ...b.params }), !V && /* @__PURE__ */ H.createElement(j, { ...b.params, ref: D }));
  };
  return /* @__PURE__ */ H.createElement(
    "div",
    {
      ref: N,
      role: "row",
      style: I,
      "row-index": u,
      "row-id": d,
      "row-business-key": f,
      tabIndex: o
    },
    M && k(),
    B && z()
  );
}, t7e = eo(e7e), r7e = (e) => {
  const { context: t } = vr(ki), { name: r } = e, n = Et(() => Wq(r), [r]), i = se(null), o = se(null), a = se([]), s = se([]), [l, u] = Me(() => []), c = se(!1), d = se(), h = Et(() => Sa(n.viewport), [n]), f = Et(() => Sa(n.container), [n]), p = n.type === "center", g = p ? i : o;
  hc(" AG Row Container " + r + " ", g);
  const v = lr(() => p ? i.current != null && o.current != null : o.current != null, []), m = lr(() => p ? i.current == null && o.current == null : o.current == null, []), y = lr(() => {
    if (m() && (t.destroyBean(d.current), d.current = null), v()) {
      const w = (R) => {
        const _ = II(
          s.current,
          a.current,
          c.current
        );
        _ !== s.current && (s.current = _, AI(R, () => u(_)));
      }, x = {
        setViewportHeight: (R) => {
          i.current && (i.current.style.height = R);
        },
        setRowCtrls: ({ rowCtrls: R, useFlushSync: _ }) => {
          const T = !!_ && a.current.length > 0 && R.length > 0;
          a.current = R, w(T);
        },
        setDomOrder: (R) => {
          c.current != R && (c.current = R, w(!1));
        },
        setContainerWidth: (R) => {
          o.current && (o.current.style.width = R);
        },
        setOffsetTop: (R) => {
          o.current && (o.current.style.transform = `translateY(${R})`);
        }
      };
      d.current = t.createBean(new dGe(r)), d.current.setComp(x, o.current, i.current);
    }
  }, [v, m]), C = lr(
    (w) => {
      o.current = w, y();
    },
    [y]
  ), S = lr(
    (w) => {
      i.current = w, y();
    },
    [y]
  ), b = () => /* @__PURE__ */ H.createElement("div", { className: f, ref: C, role: "rowgroup" }, l.map((w) => /* @__PURE__ */ H.createElement(
    t7e,
    {
      rowCtrl: w,
      containerType: n.type,
      key: w.getInstanceId()
    }
  )));
  return /* @__PURE__ */ H.createElement(H.Fragment, null, p ? /* @__PURE__ */ H.createElement("div", { className: h, ref: S, role: "presentation" }, b()) : b());
}, n7e = eo(r7e), i7e = () => {
  const { context: e, resizeObserverService: t } = vr(ki), [r, n] = Me(""), [i, o] = Me(0), [a, s] = Me(0), [l, u] = Me("0px"), [c, d] = Me("0px"), [h, f] = Me("100%"), [p, g] = Me("0px"), [v, m] = Me("0px"), [y, C] = Me("100%"), [S, b] = Me(""), [w, x] = Me(""), [R, _] = Me(null), [T, P] = Me(""), [D, O] = Me(null), [A, F] = Me("ag-layout-normal"), L = se();
  L.current || (L.current = new tm(() => N.current));
  const N = se(null), I = se(null), B = se(null), M = se(null), V = se(null), G = se(null), k = se(null), z = se([]), j = se([]);
  hc(" AG Grid Body ", N), hc(" AG Pinned Top ", I), hc(" AG Sticky Top ", B), hc(" AG Middle ", G), hc(" AG Pinned Bottom ", k);
  const q = lr((xe) => {
    if (N.current = xe, !N.current) {
      e.destroyBeans(z.current), j.current.forEach((J) => J()), z.current = [], j.current = [];
      return;
    }
    if (!e)
      return;
    const _e = (J, he) => {
      J.appendChild(he), j.current.push(() => J.removeChild(he));
    }, Ve = (J) => {
      const he = e.createBean(new J());
      return z.current.push(he), he;
    }, Fe = (J, he, Le) => {
      _e(J, document.createComment(Le)), _e(J, Ve(he).getGui());
    };
    Fe(N.current, mHe, " AG Fake Horizontal Scroll "), Fe(N.current, vHe, " AG Overlay Wrapper "), V.current && Fe(V.current, yHe, " AG Fake Vertical Scroll ");
    const Ne = {
      setRowAnimationCssOnBodyViewport: n,
      setColumnCount: (J) => {
        N.current && NBe(N.current, J);
      },
      setRowCount: (J) => {
        N.current && LBe(N.current, J);
      },
      setTopHeight: o,
      setBottomHeight: s,
      setStickyTopHeight: u,
      setStickyTopTop: d,
      setStickyTopWidth: f,
      setTopDisplay: b,
      setBottomDisplay: x,
      setColumnMovingCss: (J, he) => L.current.addOrRemoveCssClass(J, he),
      updateLayoutClasses: F,
      setAlwaysVerticalScrollClass: _,
      setPinnedTopBottomOverflowY: P,
      setCellSelectableCss: (J, he) => O(he ? J : null),
      setBodyViewportWidth: (J) => {
        G.current && (G.current.style.width = J);
      },
      registerBodyViewportResizeListener: (J) => {
        if (G.current) {
          const he = t.observeResize(G.current, J);
          j.current.push(() => he());
        }
      },
      setStickyBottomHeight: g,
      setStickyBottomBottom: m,
      setStickyBottomWidth: C
    }, Je = e.createBean(new xHe());
    z.current.push(Je), Je.setComp(
      Ne,
      N.current,
      G.current,
      I.current,
      k.current,
      B.current,
      M.current
    );
  }, []), K = Et(() => Sa("ag-root", "ag-unselectable", A), [A]), Z = Et(
    () => Sa(
      "ag-body-viewport",
      r,
      A,
      R,
      D
    ),
    [r, A, R, D]
  ), re = Et(() => Sa("ag-body", A), [A]), X = Et(() => Sa("ag-floating-top", D), [D]), Y = Et(() => Sa("ag-sticky-top", D), [D]), U = Et(() => Sa("ag-sticky-bottom", D), [D]), oe = Et(() => Sa("ag-floating-bottom", D), [D]), W = Et(
    () => ({
      height: i,
      minHeight: i,
      display: S,
      overflowY: T
    }),
    [i, S, T]
  ), ne = Et(
    () => ({
      height: l,
      top: c,
      width: h
    }),
    [l, c, h]
  ), ce = Et(
    () => ({
      height: p,
      bottom: v,
      width: y
    }),
    [p, v, y]
  ), we = Et(
    () => ({
      height: a,
      minHeight: a,
      display: w,
      overflowY: T
    }),
    [a, w, T]
  ), Re = (xe) => /* @__PURE__ */ H.createElement(n7e, { name: xe, key: `${xe}-container` }), ve = ({
    section: xe,
    children: _e,
    className: Ve,
    style: Fe
  }) => /* @__PURE__ */ H.createElement("div", { ref: xe, className: Ve, role: "presentation", style: Fe }, _e.map(Re));
  return /* @__PURE__ */ H.createElement("div", { ref: q, className: K, role: "treegrid" }, /* @__PURE__ */ H.createElement(GWe, null), ve({
    section: I,
    className: X,
    style: W,
    children: ["topLeft", "topCenter", "topRight", "topFullWidth"]
  }), /* @__PURE__ */ H.createElement("div", { className: re, ref: V, role: "presentation" }, ve({
    section: G,
    className: Z,
    children: ["left", "center", "right", "fullWidth"]
  })), ve({
    section: B,
    className: Y,
    style: ne,
    children: ["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"]
  }), ve({
    section: M,
    className: U,
    style: ce,
    children: ["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"]
  }), ve({
    section: k,
    className: oe,
    style: we,
    children: ["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"]
  }));
}, o7e = eo(i7e), a7e = (e, t) => {
  const { children: r, eFocusableElement: n, onTabKeyDown: i, gridCtrl: o, forceFocusOutWhenTabGuardsAreEmpty: a } = e, { context: s } = vr(ki), l = se(null), u = se(null), c = se(), d = (v) => {
    const m = v == null ? void 0 : parseInt(v, 10).toString();
    [l, u].forEach((y) => {
      var C, S;
      m === void 0 ? (C = y.current) == null || C.removeAttribute("tabindex") : (S = y.current) == null || S.setAttribute("tabindex", m);
    });
  };
  Zc(t, () => ({
    forceFocusOutOfContainer(v) {
      var m;
      (m = c.current) == null || m.forceFocusOutOfContainer(v);
    }
  }));
  const h = lr(() => {
    if (!l.current && !u.current) {
      s.destroyBean(c.current), c.current = null;
      return;
    }
    if (l.current && u.current) {
      const v = {
        setTabIndex: d
      };
      c.current = s.createBean(
        new eX({
          comp: v,
          eTopGuard: l.current,
          eBottomGuard: u.current,
          eFocusableElement: n,
          onTabKeyDown: i,
          forceFocusOutWhenTabGuardsAreEmpty: a,
          focusInnerElement: (m) => o.focusInnerElement(m)
        })
      );
    }
  }, []), f = lr(
    (v) => {
      l.current = v, h();
    },
    [h]
  ), p = lr(
    (v) => {
      u.current = v, h();
    },
    [h]
  ), g = (v) => {
    const m = v === "top" ? E0.TAB_GUARD_TOP : E0.TAB_GUARD_BOTTOM;
    return /* @__PURE__ */ H.createElement(
      "div",
      {
        className: `${E0.TAB_GUARD} ${m}`,
        role: "presentation",
        ref: v === "top" ? f : p
      }
    );
  };
  return /* @__PURE__ */ H.createElement(H.Fragment, null, g("top"), r, g("bottom"));
}, s7e = yn(a7e), l7e = eo(s7e), u7e = ({ context: e }) => {
  const [t, r] = Me(""), [n, i] = Me(""), [o, a] = Me(null), [s, l] = Me(null), [u, c] = Me(!1), [d, h] = Me(), f = se(null), p = se(null), g = se(), [v, m] = Me(null), y = se(() => {
  }), C = se(), S = se([]), b = lr(() => {
  }, []), w = Et(() => e.isDestroyed() ? null : e.getBeans(), [e]);
  hc(" AG Grid ", p);
  const x = lr((D) => {
    if (p.current = D, !p.current) {
      e.destroyBean(f.current), f.current = null;
      return;
    }
    if (e.isDestroyed())
      return;
    f.current = e.createBean(new Uze());
    const O = f.current;
    y.current = O.focusInnerElement.bind(O);
    const A = {
      destroyGridUi: () => {
      },
      // do nothing, as framework users destroy grid by removing the comp
      setRtlClass: r,
      forceFocusOutOfContainer: (F) => {
        var L, N;
        if (!F && ((L = C.current) != null && L.isDisplayed())) {
          C.current.forceFocusOutOfContainer(F);
          return;
        }
        (N = g.current) == null || N.forceFocusOutOfContainer(F);
      },
      updateLayoutClasses: i,
      getFocusableContainers: () => {
        var N;
        const F = [], L = (N = p.current) == null ? void 0 : N.querySelector(".ag-root");
        return L && F.push({ getGui: () => L }), S.current.forEach((I) => {
          I.isDisplayed() && F.push(I);
        }), F;
      },
      setCursor: a,
      setUserSelect: l
    };
    O.setComp(A, p.current, p.current), c(!0);
  }, []);
  Nt(() => {
    if (!d || !w || !f.current || !v || !p.current)
      return;
    const D = f.current, O = [], {
      watermarkSelector: A,
      paginationSelector: F,
      sideBarSelector: L,
      statusBarSelector: N,
      gridHeaderDropZonesSelector: I
    } = D.getOptionalSelectors(), B = [], M = p.current;
    if (I) {
      const G = e.createBean(new I.component()), k = G.getGui();
      M.insertAdjacentElement("afterbegin", k), B.push(k), O.push(G);
    }
    if (L) {
      const G = e.createBean(new L.component()), k = G.getGui(), z = v.querySelector(".ag-tab-guard-bottom");
      z && (z.insertAdjacentElement("beforebegin", k), B.push(k)), O.push(G), S.current.push(G);
    }
    const V = (G) => {
      const k = e.createBean(new G()), z = k.getGui();
      return M.insertAdjacentElement("beforeend", z), B.push(z), O.push(k), k;
    };
    if (N && V(N.component), F) {
      const G = V(F.component);
      C.current = G, S.current.push(G);
    }
    return A && V(A.component), () => {
      e.destroyBeans(O), B.forEach((G) => {
        G.parentElement && G.parentElement.removeChild(G);
      });
    };
  }, [d, v, w]);
  const R = Et(
    () => Sa("ag-root-wrapper", t, n),
    [t, n]
  ), _ = Et(
    () => Sa("ag-root-wrapper-body", "ag-focus-managed", n),
    [n]
  ), T = Et(
    () => ({
      userSelect: s ?? "",
      WebkitUserSelect: s ?? "",
      cursor: o ?? ""
    }),
    [s, o]
  ), P = lr((D) => {
    g.current = D, h(D !== null);
  }, []);
  return /* @__PURE__ */ H.createElement("div", { ref: x, className: R, style: T, role: "presentation" }, /* @__PURE__ */ H.createElement("div", { className: _, ref: m, role: "presentation" }, u && v && w && /* @__PURE__ */ H.createElement(ki.Provider, { value: w }, /* @__PURE__ */ H.createElement(
    l7e,
    {
      ref: P,
      eFocusableElement: v,
      onTabKeyDown: b,
      gridCtrl: f.current,
      forceFocusOutWhenTabGuardsAreEmpty: !0
    },
    // we wait for initialised before rending the children, so GridComp has created and registered with it's
    // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
    // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
    // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
    // hangs the UI)
    /* @__PURE__ */ H.createElement(o7e, null)
  ))));
}, c7e = eo(u7e), d7e = class extends Se {
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  areHeaderCellsRendered() {
    return this.ctrlsService.getHeaderRowContainerCtrls().every((e) => e.getAllCtrls().every((t) => t.areCellsRendered()));
  }
}, bX = (e) => {
  var g;
  const t = se(), r = se(null), n = se(null), i = se([]), o = se([]), a = se(e), s = se(), l = se(!1), [u, c] = Me(void 0), [, d] = Me(0), h = lr((v) => {
    if (r.current = v, !r.current) {
      i.current.forEach((T) => T()), i.current.length = 0;
      return;
    }
    const m = e.modules || [];
    n.current || (n.current = new AWe(
      () => d((T) => T + 1),
      e.componentWrappingElement,
      e.maxComponentCreationTimeMs
    ), i.current.push(() => {
      var T;
      (T = n.current) == null || T.destroy(), n.current = null;
    }));
    const y = RBe(e.gridOptions, e), C = () => {
      if (l.current) {
        const T = () => {
          var D;
          return (D = s.current) != null && D.shouldQueueUpdates() ? void 0 : o.current.shift();
        };
        let P = T();
        for (; P; )
          P(), P = T();
      }
    }, S = gWe() ? new g7e(C) : new xX();
    s.current = S;
    const b = new d7e(), w = {
      providedBeanInstances: {
        frameworkComponentWrapper: new f7e(
          n.current,
          y.reactiveCustomComponents ?? !0
        ),
        renderStatusService: b
      },
      modules: m,
      frameworkOverrides: S
    }, x = (T) => {
      c(T), T.createBean(b), i.current.push(() => {
        T.destroy();
      }), T.getBean("ctrlsService").whenReady(() => {
        if (T.isDestroyed())
          return;
        const D = t.current;
        D && e.setGridApi && e.setGridApi(D);
      });
    }, R = (T) => {
      T.getBean("ctrlsService").whenReady(() => {
        o.current.forEach((D) => D()), o.current.length = 0, l.current = !0;
      });
    }, _ = new C6e();
    t.current = _.create(
      r.current,
      y,
      x,
      R,
      w
    );
  }, []), f = Et(() => ({
    height: "100%",
    ...e.containerStyle || {}
  }), [e.containerStyle]), p = lr((v) => {
    var m;
    l.current && !((m = s.current) != null && m.shouldQueueUpdates()) ? v() : o.current.push(v);
  }, []);
  return Nt(() => {
    const v = h7e(a.current, e);
    a.current = e, p(() => {
      t.current && _Be(v, t.current);
    });
  }, [e]), /* @__PURE__ */ H.createElement("div", { style: f, className: e.className, ref: h }, u && !u.isDestroyed() ? /* @__PURE__ */ H.createElement(c7e, { context: u }) : null, ((g = n.current) == null ? void 0 : g.getPortals()) ?? null);
};
function h7e(e, t) {
  const r = {};
  return Object.keys(t).forEach((n) => {
    const i = t[n];
    e[n] !== i && (r[n] = i);
  }), r;
}
var f7e = class extends T6e {
  constructor(e, t) {
    super(), this.parent = e, this.reactiveCustomComponents = t;
  }
  createWrapper(e, t) {
    if (this.reactiveCustomComponents) {
      const i = ((o) => {
        switch (o) {
          case "filter":
            return bWe;
          case "floatingFilterComponent":
            return EWe;
          case "dateComponent":
            return wWe;
          case "loadingOverlayComponent":
            return RWe;
          case "noRowsOverlayComponent":
            return TWe;
          case "statusPanel":
            return PWe;
          case "toolPanel":
            return MWe;
          case "menuItem":
            return _We;
          case "cellRenderer":
            return SWe;
        }
      })(t.propertyName);
      if (i)
        return new i(e, this.parent, t);
    } else
      switch (t.propertyName) {
        case "filter":
        case "floatingFilterComponent":
        case "dateComponent":
        case "loadingOverlayComponent":
        case "noRowsOverlayComponent":
        case "statusPanel":
        case "toolPanel":
        case "menuItem":
        case "cellRenderer":
          FI();
          break;
      }
    const r = !t.cellRenderer && t.propertyName !== "toolPanel";
    return new SX(e, this.parent, t, r);
  }
}, p7e = yn((e, t) => {
  const { ctrlsFactory: r, context: n, gos: i, resizeObserverService: o, rowModel: a } = vr(ki), [s, l] = Me(() => new Uo()), [u, c] = Me(() => new Uo()), [d, h] = Me(), [f, p] = Me(), g = se(), v = se(null), m = se(), y = Et(() => ci.__getGridRegisteredModules(e.api.getGridId()), [e]), C = Et(() => s.toString() + " ag-details-row", [s]), S = Et(() => u.toString() + " ag-details-grid", [u]);
  t && Zc(t, () => ({
    refresh() {
      var x;
      return ((x = g.current) == null ? void 0 : x.refresh()) ?? !1;
    }
  })), e.template && Te(
    "detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://ag-grid.com/react-data-grid/master-detail-custom-detail/"
  );
  const b = lr((x) => {
    if (v.current = x, !v.current) {
      n.destroyBean(g.current), m.current && m.current();
      return;
    }
    const R = {
      addOrRemoveCssClass: (T, P) => l((D) => D.setClass(T, P)),
      addOrRemoveDetailGridCssClass: (T, P) => c((D) => D.setClass(T, P)),
      setDetailGrid: (T) => h(T),
      setRowData: (T) => p(T),
      getGui: () => v.current
    }, _ = r.getInstance("detailCellRenderer");
    if (_ && (n.createBean(_), _.init(R, e), g.current = _, i.get("detailRowAutoHeight"))) {
      const T = () => {
        if (v.current == null)
          return;
        const P = v.current.clientHeight;
        P != null && P > 0 && setTimeout(() => {
          e.node.setRowHeight(P), (a.getType() === "clientSide" || a.getType() === "serverSide") && a.onRowHeightChanged();
        }, 0);
      };
      m.current = o.observeResize(v.current, T), T();
    }
  }, []), w = lr((x) => {
    var R;
    (R = g.current) == null || R.registerDetailWithMaster(x);
  }, []);
  return /* @__PURE__ */ H.createElement("div", { className: C, ref: b }, d && /* @__PURE__ */ H.createElement(
    bX,
    {
      className: S,
      ...d,
      modules: y,
      rowData: f,
      setGridApi: w
    }
  ));
}), xX = class extends tX {
  constructor() {
    super("react"), this.frameworkComponents = {
      agGroupCellRenderer: oG,
      agGroupRowRenderer: oG,
      agDetailCellRenderer: p7e
    }, this.wrapIncoming = (e, t) => t === "ensureVisible" ? vWe(e) : e(), this.renderingEngine = "react";
  }
  frameworkComponent(e) {
    return this.frameworkComponents[e];
  }
  isFrameworkComponent(e) {
    if (!e)
      return !1;
    const t = e.prototype;
    return !(t && "getGui" in t);
  }
  shouldQueueUpdates() {
    return !1;
  }
  getLockOnRefreshError() {
    return " This error can also occur if using 'ReactDOM.render' instead of 'createRoot'. If so, please upgrade to 'createRoot'.";
  }
}, g7e = class extends xX {
  constructor(e) {
    super(), this.processQueuedUpdates = e, this.queueUpdates = !1;
  }
  getLockOnRefresh() {
    this.queueUpdates = !0;
  }
  releaseLockOnRefresh() {
    this.queueUpdates = !1, this.processQueuedUpdates();
  }
  shouldQueueUpdates() {
    return this.queueUpdates;
  }
  getLockOnRefreshError() {
    return "";
  }
}, v7e = class extends GX {
  constructor() {
    super(...arguments), this.apiListeners = [], this.setGridApi = (e) => {
      this.api = e, this.apiListeners.forEach((t) => t(e));
    };
  }
  registerApiListener(e) {
    this.apiListeners.push(e);
  }
  componentWillUnmount() {
    this.apiListeners.length = 0;
  }
  render() {
    return /* @__PURE__ */ H.createElement(bX, { ...this.props, setGridApi: this.setGridApi });
  }
};
const m7e = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent), EX = (e) => Array.isArray(e) && e.every(
  (t) => typeof t == "object" && !(t instanceof Array)
), y7e = (e) => Array.isArray(e) && e.every(
  (t) => Array.isArray(t)
), C7e = (e) => Array.from(
  e.map((t) => Object.keys(t)).reduce((t, r) => /* @__PURE__ */ new Set([...t, ...r]), [])
), S7e = (e, t) => {
  t = t || C7e(e);
  let r = t, n = t;
  EX(t) && (r = t.map((o) => o.label), n = t.map((o) => o.key));
  const i = e.map((o) => n.map((a) => w7e(a, o)));
  return [r, ...i];
}, w7e = (e, t) => {
  const r = e.replace(/\[([^\]]+)]/g, ".$1").split(".").reduce(function(n, i, o, a) {
    const s = n[i];
    if (s == null)
      a.splice(1);
    else
      return s;
  }, t);
  return r === void 0 ? e in t ? t[e] : "" : r;
}, b7e = (e) => typeof e > "u" || e === null ? "" : e, RX = (e, t = ",", r = '"') => e.filter((n) => n).map(
  (n) => n.map((i) => b7e(i)).map((i) => `${r}${i}${r}`).join(t)
).join(`
`), x7e = (e, t, r, n) => RX(t ? [t, ...e] : e, r, n), E7e = (e, t, r, n) => RX(S7e(e, t), r, n), R7e = (e, t, r, n) => t ? `${t.join(r)}
${e}` : e.replace(/"/g, '""'), _X = (e, t, r, n) => {
  if (EX(e)) return E7e(e, t, r, n);
  if (y7e(e)) return x7e(e, t, r, n);
  if (typeof e == "string") return R7e(e, t, r);
  throw new TypeError('Data should be a "String", "Array of arrays" OR "Array of objects" ');
}, TX = (e, t, r, n, i) => {
  const o = _X(e, r, n, i), a = m7e() ? "application/csv" : "text/csv", s = new Blob([t ? "\uFEFF" : "", o], { type: a }), l = `data:${a};charset=utf-8,${t ? "\uFEFF" : ""}${o}`, u = window.URL || window.webkitURL;
  return typeof u.createObjectURL > "u" ? l : u.createObjectURL(s);
};
var mP = { exports: {} }, zy = { exports: {} }, Fr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uG;
function _7e() {
  if (uG) return Fr;
  uG = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, h = e ? Symbol.for("react.suspense_list") : 60120, f = e ? Symbol.for("react.memo") : 60115, p = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, m = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
  function C(b) {
    if (typeof b == "object" && b !== null) {
      var w = b.$$typeof;
      switch (w) {
        case t:
          switch (b = b.type, b) {
            case l:
            case u:
            case n:
            case o:
            case i:
            case d:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case s:
                case c:
                case p:
                case f:
                case a:
                  return b;
                default:
                  return w;
              }
          }
        case r:
          return w;
      }
    }
  }
  function S(b) {
    return C(b) === u;
  }
  return Fr.AsyncMode = l, Fr.ConcurrentMode = u, Fr.ContextConsumer = s, Fr.ContextProvider = a, Fr.Element = t, Fr.ForwardRef = c, Fr.Fragment = n, Fr.Lazy = p, Fr.Memo = f, Fr.Portal = r, Fr.Profiler = o, Fr.StrictMode = i, Fr.Suspense = d, Fr.isAsyncMode = function(b) {
    return S(b) || C(b) === l;
  }, Fr.isConcurrentMode = S, Fr.isContextConsumer = function(b) {
    return C(b) === s;
  }, Fr.isContextProvider = function(b) {
    return C(b) === a;
  }, Fr.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, Fr.isForwardRef = function(b) {
    return C(b) === c;
  }, Fr.isFragment = function(b) {
    return C(b) === n;
  }, Fr.isLazy = function(b) {
    return C(b) === p;
  }, Fr.isMemo = function(b) {
    return C(b) === f;
  }, Fr.isPortal = function(b) {
    return C(b) === r;
  }, Fr.isProfiler = function(b) {
    return C(b) === o;
  }, Fr.isStrictMode = function(b) {
    return C(b) === i;
  }, Fr.isSuspense = function(b) {
    return C(b) === d;
  }, Fr.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === n || b === u || b === o || b === i || b === d || b === h || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === f || b.$$typeof === a || b.$$typeof === s || b.$$typeof === c || b.$$typeof === v || b.$$typeof === m || b.$$typeof === y || b.$$typeof === g);
  }, Fr.typeOf = C, Fr;
}
var Nr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cG;
function T7e() {
  return cG || (cG = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, h = e ? Symbol.for("react.suspense_list") : 60120, f = e ? Symbol.for("react.memo") : 60115, p = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, m = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
    function C(U) {
      return typeof U == "string" || typeof U == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      U === n || U === u || U === o || U === i || U === d || U === h || typeof U == "object" && U !== null && (U.$$typeof === p || U.$$typeof === f || U.$$typeof === a || U.$$typeof === s || U.$$typeof === c || U.$$typeof === v || U.$$typeof === m || U.$$typeof === y || U.$$typeof === g);
    }
    function S(U) {
      if (typeof U == "object" && U !== null) {
        var oe = U.$$typeof;
        switch (oe) {
          case t:
            var W = U.type;
            switch (W) {
              case l:
              case u:
              case n:
              case o:
              case i:
              case d:
                return W;
              default:
                var ne = W && W.$$typeof;
                switch (ne) {
                  case s:
                  case c:
                  case p:
                  case f:
                  case a:
                    return ne;
                  default:
                    return oe;
                }
            }
          case r:
            return oe;
        }
      }
    }
    var b = l, w = u, x = s, R = a, _ = t, T = c, P = n, D = p, O = f, A = r, F = o, L = i, N = d, I = !1;
    function B(U) {
      return I || (I = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), M(U) || S(U) === l;
    }
    function M(U) {
      return S(U) === u;
    }
    function V(U) {
      return S(U) === s;
    }
    function G(U) {
      return S(U) === a;
    }
    function k(U) {
      return typeof U == "object" && U !== null && U.$$typeof === t;
    }
    function z(U) {
      return S(U) === c;
    }
    function j(U) {
      return S(U) === n;
    }
    function q(U) {
      return S(U) === p;
    }
    function K(U) {
      return S(U) === f;
    }
    function Z(U) {
      return S(U) === r;
    }
    function re(U) {
      return S(U) === o;
    }
    function X(U) {
      return S(U) === i;
    }
    function Y(U) {
      return S(U) === d;
    }
    Nr.AsyncMode = b, Nr.ConcurrentMode = w, Nr.ContextConsumer = x, Nr.ContextProvider = R, Nr.Element = _, Nr.ForwardRef = T, Nr.Fragment = P, Nr.Lazy = D, Nr.Memo = O, Nr.Portal = A, Nr.Profiler = F, Nr.StrictMode = L, Nr.Suspense = N, Nr.isAsyncMode = B, Nr.isConcurrentMode = M, Nr.isContextConsumer = V, Nr.isContextProvider = G, Nr.isElement = k, Nr.isForwardRef = z, Nr.isFragment = j, Nr.isLazy = q, Nr.isMemo = K, Nr.isPortal = Z, Nr.isProfiler = re, Nr.isStrictMode = X, Nr.isSuspense = Y, Nr.isValidElementType = C, Nr.typeOf = S;
  }()), Nr;
}
var dG;
function PX() {
  return dG || (dG = 1, process.env.NODE_ENV === "production" ? zy.exports = _7e() : zy.exports = T7e()), zy.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var OE, hG;
function P7e() {
  if (hG) return OE;
  hG = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
  function n(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return OE = i() ? Object.assign : function(o, a) {
    for (var s, l = n(o), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var d in s)
        t.call(s, d) && (l[d] = s[d]);
      if (e) {
        u = e(s);
        for (var h = 0; h < u.length; h++)
          r.call(s, u[h]) && (l[u[h]] = s[u[h]]);
      }
    }
    return l;
  }, OE;
}
var LE, fG;
function NI() {
  if (fG) return LE;
  fG = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return LE = e, LE;
}
var FE, pG;
function MX() {
  return pG || (pG = 1, FE = Function.call.bind(Object.prototype.hasOwnProperty)), FE;
}
var NE, gG;
function M7e() {
  if (gG) return NE;
  gG = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = NI(), r = {}, n = MX();
    e = function(o) {
      var a = "Warning: " + o;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function i(o, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in o)
        if (n(o, c)) {
          var d;
          try {
            if (typeof o[c] != "function") {
              var h = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw h.name = "Invariant Violation", h;
            }
            d = o[c](a, c, l, s, null, t);
          } catch (p) {
            d = p;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in r)) {
            r[d.message] = !0;
            var f = u ? u() : "";
            e(
              "Failed " + s + " type: " + d.message + (f ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (r = {});
  }, NE = i, NE;
}
var kE, vG;
function D7e() {
  if (vG) return kE;
  vG = 1;
  var e = PX(), t = P7e(), r = NI(), n = MX(), i = M7e(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return kE = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(M) {
      var V = M && (u && M[u] || M[c]);
      if (typeof V == "function")
        return V;
    }
    var h = "<<anonymous>>", f = {
      array: m("array"),
      bigint: m("bigint"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: y(),
      arrayOf: C,
      element: S(),
      elementType: b(),
      instanceOf: w,
      node: T(),
      objectOf: R,
      oneOf: x,
      oneOfType: _,
      shape: D,
      exact: O
    };
    function p(M, V) {
      return M === V ? M !== 0 || 1 / M === 1 / V : M !== M && V !== V;
    }
    function g(M, V) {
      this.message = M, this.data = V && typeof V == "object" ? V : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function v(M) {
      if (process.env.NODE_ENV !== "production")
        var V = {}, G = 0;
      function k(j, q, K, Z, re, X, Y) {
        if (Z = Z || h, X = X || K, Y !== r) {
          if (l) {
            var U = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw U.name = "Invariant Violation", U;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var oe = Z + ":" + K;
            !V[oe] && // Avoid spamming the console because they are often not actionable except for lib authors
            G < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + X + "` prop on `" + Z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), V[oe] = !0, G++);
          }
        }
        return q[K] == null ? j ? q[K] === null ? new g("The " + re + " `" + X + "` is marked as required " + ("in `" + Z + "`, but its value is `null`.")) : new g("The " + re + " `" + X + "` is marked as required in " + ("`" + Z + "`, but its value is `undefined`.")) : null : M(q, K, Z, re, X);
      }
      var z = k.bind(null, !1);
      return z.isRequired = k.bind(null, !0), z;
    }
    function m(M) {
      function V(G, k, z, j, q, K) {
        var Z = G[k], re = L(Z);
        if (re !== M) {
          var X = N(Z);
          return new g(
            "Invalid " + j + " `" + q + "` of type " + ("`" + X + "` supplied to `" + z + "`, expected ") + ("`" + M + "`."),
            { expectedType: M }
          );
        }
        return null;
      }
      return v(V);
    }
    function y() {
      return v(a);
    }
    function C(M) {
      function V(G, k, z, j, q) {
        if (typeof M != "function")
          return new g("Property `" + q + "` of component `" + z + "` has invalid PropType notation inside arrayOf.");
        var K = G[k];
        if (!Array.isArray(K)) {
          var Z = L(K);
          return new g("Invalid " + j + " `" + q + "` of type " + ("`" + Z + "` supplied to `" + z + "`, expected an array."));
        }
        for (var re = 0; re < K.length; re++) {
          var X = M(K, re, z, j, q + "[" + re + "]", r);
          if (X instanceof Error)
            return X;
        }
        return null;
      }
      return v(V);
    }
    function S() {
      function M(V, G, k, z, j) {
        var q = V[G];
        if (!s(q)) {
          var K = L(q);
          return new g("Invalid " + z + " `" + j + "` of type " + ("`" + K + "` supplied to `" + k + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(M);
    }
    function b() {
      function M(V, G, k, z, j) {
        var q = V[G];
        if (!e.isValidElementType(q)) {
          var K = L(q);
          return new g("Invalid " + z + " `" + j + "` of type " + ("`" + K + "` supplied to `" + k + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(M);
    }
    function w(M) {
      function V(G, k, z, j, q) {
        if (!(G[k] instanceof M)) {
          var K = M.name || h, Z = B(G[k]);
          return new g("Invalid " + j + " `" + q + "` of type " + ("`" + Z + "` supplied to `" + z + "`, expected ") + ("instance of `" + K + "`."));
        }
        return null;
      }
      return v(V);
    }
    function x(M) {
      if (!Array.isArray(M))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), a;
      function V(G, k, z, j, q) {
        for (var K = G[k], Z = 0; Z < M.length; Z++)
          if (p(K, M[Z]))
            return null;
        var re = JSON.stringify(M, function(Y, U) {
          var oe = N(U);
          return oe === "symbol" ? String(U) : U;
        });
        return new g("Invalid " + j + " `" + q + "` of value `" + String(K) + "` " + ("supplied to `" + z + "`, expected one of " + re + "."));
      }
      return v(V);
    }
    function R(M) {
      function V(G, k, z, j, q) {
        if (typeof M != "function")
          return new g("Property `" + q + "` of component `" + z + "` has invalid PropType notation inside objectOf.");
        var K = G[k], Z = L(K);
        if (Z !== "object")
          return new g("Invalid " + j + " `" + q + "` of type " + ("`" + Z + "` supplied to `" + z + "`, expected an object."));
        for (var re in K)
          if (n(K, re)) {
            var X = M(K, re, z, j, q + "." + re, r);
            if (X instanceof Error)
              return X;
          }
        return null;
      }
      return v(V);
    }
    function _(M) {
      if (!Array.isArray(M))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var V = 0; V < M.length; V++) {
        var G = M[V];
        if (typeof G != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + I(G) + " at index " + V + "."
          ), a;
      }
      function k(z, j, q, K, Z) {
        for (var re = [], X = 0; X < M.length; X++) {
          var Y = M[X], U = Y(z, j, q, K, Z, r);
          if (U == null)
            return null;
          U.data && n(U.data, "expectedType") && re.push(U.data.expectedType);
        }
        var oe = re.length > 0 ? ", expected one of type [" + re.join(", ") + "]" : "";
        return new g("Invalid " + K + " `" + Z + "` supplied to " + ("`" + q + "`" + oe + "."));
      }
      return v(k);
    }
    function T() {
      function M(V, G, k, z, j) {
        return A(V[G]) ? null : new g("Invalid " + z + " `" + j + "` supplied to " + ("`" + k + "`, expected a ReactNode."));
      }
      return v(M);
    }
    function P(M, V, G, k, z) {
      return new g(
        (M || "React class") + ": " + V + " type `" + G + "." + k + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + z + "`."
      );
    }
    function D(M) {
      function V(G, k, z, j, q) {
        var K = G[k], Z = L(K);
        if (Z !== "object")
          return new g("Invalid " + j + " `" + q + "` of type `" + Z + "` " + ("supplied to `" + z + "`, expected `object`."));
        for (var re in M) {
          var X = M[re];
          if (typeof X != "function")
            return P(z, j, q, re, N(X));
          var Y = X(K, re, z, j, q + "." + re, r);
          if (Y)
            return Y;
        }
        return null;
      }
      return v(V);
    }
    function O(M) {
      function V(G, k, z, j, q) {
        var K = G[k], Z = L(K);
        if (Z !== "object")
          return new g("Invalid " + j + " `" + q + "` of type `" + Z + "` " + ("supplied to `" + z + "`, expected `object`."));
        var re = t({}, G[k], M);
        for (var X in re) {
          var Y = M[X];
          if (n(M, X) && typeof Y != "function")
            return P(z, j, q, X, N(Y));
          if (!Y)
            return new g(
              "Invalid " + j + " `" + q + "` key `" + X + "` supplied to `" + z + "`.\nBad object: " + JSON.stringify(G[k], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(M), null, "  ")
            );
          var U = Y(K, X, z, j, q + "." + X, r);
          if (U)
            return U;
        }
        return null;
      }
      return v(V);
    }
    function A(M) {
      switch (typeof M) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !M;
        case "object":
          if (Array.isArray(M))
            return M.every(A);
          if (M === null || s(M))
            return !0;
          var V = d(M);
          if (V) {
            var G = V.call(M), k;
            if (V !== M.entries) {
              for (; !(k = G.next()).done; )
                if (!A(k.value))
                  return !1;
            } else
              for (; !(k = G.next()).done; ) {
                var z = k.value;
                if (z && !A(z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function F(M, V) {
      return M === "symbol" ? !0 : V ? V["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && V instanceof Symbol : !1;
    }
    function L(M) {
      var V = typeof M;
      return Array.isArray(M) ? "array" : M instanceof RegExp ? "object" : F(V, M) ? "symbol" : V;
    }
    function N(M) {
      if (typeof M > "u" || M === null)
        return "" + M;
      var V = L(M);
      if (V === "object") {
        if (M instanceof Date)
          return "date";
        if (M instanceof RegExp)
          return "regexp";
      }
      return V;
    }
    function I(M) {
      var V = N(M);
      switch (V) {
        case "array":
        case "object":
          return "an " + V;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + V;
        default:
          return V;
      }
    }
    function B(M) {
      return !M.constructor || !M.constructor.name ? h : M.constructor.name;
    }
    return f.checkPropTypes = i, f.resetWarningCache = i.resetWarningCache, f.PropTypes = f, f;
  }, kE;
}
var VE, mG;
function A7e() {
  if (mG) return VE;
  mG = 1;
  var e = NI();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, VE = function() {
    function n(a, s, l, u, c, d) {
      if (d !== e) {
        var h = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw h.name = "Invariant Violation", h;
      }
    }
    n.isRequired = n;
    function i() {
      return n;
    }
    var o = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: i,
      element: n,
      elementType: n,
      instanceOf: i,
      node: n,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, VE;
}
if (process.env.NODE_ENV !== "production") {
  var I7e = PX(), O7e = !0;
  mP.exports = D7e()(I7e.isElement, O7e);
} else
  mP.exports = A7e()();
var Lo = mP.exports;
const DX = {
  data: Lo.oneOfType([Lo.string, Lo.array, Lo.func]).isRequired,
  headers: Lo.array,
  target: Lo.string,
  separator: Lo.string,
  filename: Lo.string,
  uFEFF: Lo.bool,
  onClick: Lo.func,
  asyncOnClick: Lo.bool,
  enclosingCharacter: Lo.string
}, AX = {
  separator: ",",
  filename: "generatedBy_react-csv.csv",
  uFEFF: !0,
  asyncOnClick: !1,
  enclosingCharacter: '"'
}, L7e = {
  target: "_blank"
};
class yG extends H.Component {
  constructor(t) {
    super(t), this.state = {};
  }
  buildURI() {
    return TX(...arguments);
  }
  componentDidMount() {
    const { data: t, headers: r, separator: n, enclosingCharacter: i, uFEFF: o, target: a, specs: s, replace: l } = this.props;
    this.state.page = window.open(
      this.buildURI(t, o, r, n, i),
      a,
      s,
      l
    );
  }
  getWindow() {
    return this.state.page;
  }
  render() {
    return null;
  }
}
Bf(yG, "defaultProps", Object.assign(
  AX,
  L7e
)), Bf(yG, "propTypes", DX);
var Wy;
let F7e = (Wy = class extends H.Component {
  constructor(t) {
    super(t), this.buildURI = this.buildURI.bind(this);
  }
  buildURI() {
    return TX(...arguments);
  }
  /**
   * In IE11 this method will trigger the file download
   */
  handleLegacy(t, r = !1) {
    if (window.navigator.msSaveOrOpenBlob) {
      t.preventDefault();
      const {
        data: n,
        headers: i,
        separator: o,
        filename: a,
        enclosingCharacter: s,
        uFEFF: l
      } = this.props, u = r && typeof n == "function" ? n() : n;
      let c = new Blob([l ? "\uFEFF" : "", _X(u, i, o, s)]);
      return window.navigator.msSaveBlob(c, a), !1;
    }
  }
  handleAsyncClick(t) {
    const r = (n) => {
      if (n === !1) {
        t.preventDefault();
        return;
      }
      this.handleLegacy(t, !0);
    };
    this.props.onClick(t, r);
  }
  handleSyncClick(t) {
    if (this.props.onClick(t) === !1) {
      t.preventDefault();
      return;
    }
    this.handleLegacy(t);
  }
  handleClick() {
    return (t) => {
      if (typeof this.props.onClick == "function")
        return this.props.asyncOnClick ? this.handleAsyncClick(t) : this.handleSyncClick(t);
      this.handleLegacy(t);
    };
  }
  render() {
    const {
      data: t,
      headers: r,
      separator: n,
      filename: i,
      uFEFF: o,
      children: a,
      onClick: s,
      asyncOnClick: l,
      enclosingCharacter: u,
      ...c
    } = this.props, h = typeof window > "u" ? "" : this.buildURI(t, o, r, n, u);
    return /* @__PURE__ */ ie.jsx(
      "a",
      {
        download: i,
        ...c,
        ref: (f) => this.link = f,
        target: "_self",
        href: h,
        onClick: this.handleClick(),
        children: a
      }
    );
  }
}, Bf(Wy, "defaultProps", AX), Bf(Wy, "propTypes", DX), Wy);
const N7e = F7e;
function q7e({
  title: e,
  summary: t,
  rowData: r,
  columnDefs: n
}) {
  return /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      vertical: !0,
      gap: 16,
      style: {
        width: "100%"
      },
      children: [
        /* @__PURE__ */ ie.jsx(
          Ji,
          {
            size: "small",
            bordered: !0,
            hoverable: !0,
            style: {
              backgroundColor: "var(--foreground)",
              width: "100%"
            },
            styles: {
              header: {
                backgroundColor: "#FFF"
              }
            },
            title: /* @__PURE__ */ ie.jsxs(Zt, { justify: "space-between", style: { width: "100%" }, children: [
              /* @__PURE__ */ ie.jsx(xr, { children: e }),
              /* @__PURE__ */ ie.jsx(N7e, { data: r, children: /* @__PURE__ */ ie.jsx(vu, { title: "download as CSV", children: /* @__PURE__ */ ie.jsx(_G, { size: 20 }) }) })
            ] }),
            children: /* @__PURE__ */ ie.jsx(
              "div",
              {
                style: {
                  width: "100%",
                  height: 300
                },
                children: /* @__PURE__ */ ie.jsx(v7e, { rowData: r, columnDefs: n })
              }
            )
          }
        ),
        /* @__PURE__ */ ie.jsx(xr, { children: /* @__PURE__ */ ie.jsx(HS, { children: t }) })
      ]
    }
  );
}
const X7e = () => /* @__PURE__ */ ie.jsxs(ie.Fragment, { children: [
  /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      align: "center",
      gap: 8,
      style: {
        position: "absolute",
        top: 16,
        left: 16,
        cursor: "pointer"
      },
      onClick: () => {
        window.open("https://houseware.io", "_blank");
      },
      children: [
        /* @__PURE__ */ ie.jsx(_v, { src: "/app-logo.png", height: 30, width: 30, preview: !1 }),
        /* @__PURE__ */ ie.jsx(
          xr.Title,
          {
            style: {
              fontFamily: "Libre Franklin, sans-serif",
              fontSize: "1rem",
              margin: 0,
              fontWeight: 600
            },
            level: 5,
            children: "houseware"
          }
        )
      ]
    }
  ),
  /* @__PURE__ */ ie.jsxs(
    Zt,
    {
      vertical: !0,
      style: {
        position: "absolute",
        bottom: 16,
        right: 16,
        zIndex: 1
      },
      gap: 16,
      children: [
        /* @__PURE__ */ ie.jsx(
          jn,
          {
            size: "large",
            shape: "circle",
            type: "text",
            onClick: () => {
              window.open("https://x.com/gethouseware", "_blank");
            },
            icon: /* @__PURE__ */ ie.jsx(
              DG,
              {
                size: "1.5rem",
                weight: "duotone",
                color: "var(--secondary-text)"
              }
            )
          }
        ),
        /* @__PURE__ */ ie.jsx(
          jn,
          {
            size: "large",
            shape: "circle",
            type: "text",
            onClick: () => {
              window.open(
                "https://www.linkedin.com/company/gethouseware",
                "_blank"
              );
            },
            icon: /* @__PURE__ */ ie.jsx(
              PG,
              {
                size: "1.5rem",
                weight: "duotone",
                color: "var(--secondary-text)"
              }
            )
          }
        ),
        /* @__PURE__ */ ie.jsx(
          jn,
          {
            size: "large",
            shape: "circle",
            type: "text",
            onClick: () => {
              window.open("https://www.youtube.com/@getHouseware", "_blank");
            },
            icon: /* @__PURE__ */ ie.jsx(
              AG,
              {
                size: "1.5rem",
                weight: "duotone",
                color: "var(--secondary-text)"
              }
            )
          }
        )
      ]
    }
  )
] }), Z7e = () => {
  const { currentTheme: e, toggleTheme: t } = Tv(), r = () => {
    const n = e === "light" ? "dark" : "light";
    localStorage == null || localStorage.setItem("appThemeMode", n), t();
  };
  return /* @__PURE__ */ ie.jsx(
    "div",
    {
      style: {
        position: "absolute",
        bottom: 16,
        left: 16,
        zIndex: 1
      },
      children: /* @__PURE__ */ ie.jsx("button", { className: `toggle ${e}`, onClick: r, children: /* @__PURE__ */ ie.jsxs("div", { className: "icon-container", children: [
        /* @__PURE__ */ ie.jsx("div", { className: "icon icon--sun", children: /* @__PURE__ */ ie.jsxs(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 47.5 47.5",
            id: "sun",
            children: [
              /* @__PURE__ */ ie.jsx("defs", { children: /* @__PURE__ */ ie.jsx("clipPath", { id: "a", children: /* @__PURE__ */ ie.jsx("path", { d: "M0 38h38V0H0v38Z" }) }) }),
              /* @__PURE__ */ ie.jsx(
                "g",
                {
                  fill: "#ffac33",
                  clipPath: "url(#a)",
                  transform: "matrix(1.25 0 0 -1.25 0 47.5)",
                  children: /* @__PURE__ */ ie.jsx("path", { d: "M17 35s0 2 2 2 2-2 2-2v-2s0-2-2-2-2 2-2 2v2zM35 21s2 0 2-2-2-2-2-2h-2s-2 0-2 2 2 2 2 2h2zM5 21s2 0 2-2-2-2-2-2H3s-2 0-2 2 2 2 2 2h2zM10.121 29.706s1.414-1.414 0-2.828-2.828 0-2.828 0l-1.415 1.414s-1.414 1.414 0 2.829c1.415 1.414 2.829 0 2.829 0l1.414-1.415ZM31.121 8.707s1.414-1.414 0-2.828-2.828 0-2.828 0l-1.414 1.414s-1.414 1.414 0 2.828 2.828 0 2.828 0l1.414-1.414ZM30.708 26.879s-1.414-1.414-2.828 0 0 2.828 0 2.828l1.414 1.414s1.414 1.414 2.828 0 0-2.828 0-2.828l-1.414-1.414ZM9.708 5.879s-1.414-1.414-2.828 0 0 2.828 0 2.828l1.414 1.414s1.414 1.414 2.828 0 0-2.828 0-2.828L9.708 5.879ZM17 5s0 2 2 2 2-2 2-2V3s0-2-2-2-2 2-2 2v2zM29 19c0 5.523-4.478 10-10 10-5.523 0-10-4.477-10-10 0-5.522 4.477-10 10-10 5.522 0 10 4.478 10 10" })
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ ie.jsx("div", { className: "icon icon--moon", children: /* @__PURE__ */ ie.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "30",
            height: "30",
            viewBox: "0 0 512 512",
            id: "moon",
            children: /* @__PURE__ */ ie.jsxs("g", { children: [
              /* @__PURE__ */ ie.jsx(
                "path",
                {
                  fill: "#6A6D68",
                  d: "M412.95,381.15c-8.05,10.119-16.94,19.33-26.55,27.54c-2.271,1.939-4.58,3.819-6.92,5.64   c-0.261,0.21-0.521,0.42-0.78,0.63c-0.09,0.07-0.19,0.13-0.28,0.2c-5.979,4.6-12.2,8.83-18.64,12.689   c-1.92,1.15-3.851,2.28-5.811,3.37c-18.14,10.061-37.819,17.221-58.42,21.16c-12.27,2.34-24.87,3.55-37.66,3.55   c-27.92,0-54.94-5.739-80.32-17.04c-7.74-3.46-15.3-7.43-22.47-11.81c-6.96-4.24-13.77-9-20.24-14.14   c-5.28-4.19-10.3-8.62-15.07-13.25c-1.3-1.261-2.57-2.54-3.82-3.83c-30.43-31.21-49.57-71.37-54.6-115.38   c-4.54-39.75,2.83-79.04,20.95-113.75c4.99-9.561,10.81-18.78,17.41-27.561c0.2-0.26,0.4-0.529,0.6-0.79   c0.9-1.18,1.81-2.359,2.74-3.529c37.77-47.521,94.29-74.78,155.07-74.78c45.101,0,87.641,14.87,123.021,42.99   c1.54,1.22,2.89,2.33,4.14,3.39c3.16,2.64,6.29,5.43,9.51,8.5c0.49,0.47,0.99,0.94,1.471,1.43c1.3,1.25,2.58,2.54,3.84,3.83   c32.41,33.351,51.979,77.011,55.31,123.75C458.97,293.51,443.88,342.23,412.95,381.15z",
                  opacity: ".9"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "path",
                {
                  fill: "#A3AAA0",
                  d: "M408.95,377.15c-8.05,10.119-16.94,19.33-26.55,27.54c-2.271,1.939-4.58,3.819-6.92,5.64   c-0.261,0.21-0.521,0.42-0.78,0.63c-0.09,0.07-0.19,0.13-0.28,0.2c-5.979,4.6-12.2,8.83-18.64,12.689   c-1.92,1.15-3.851,2.28-5.811,3.37c-19.76,10.96-41.359,18.471-63.979,22.141c-10.51,1.699-21.23,2.569-32.101,2.569   c-27.92,0-54.94-5.739-80.32-17.04c-7.74-3.46-15.3-7.43-22.47-11.81c-6.96-4.24-13.77-9-20.24-14.14   c-5.21-4.141-10.17-8.511-14.89-13.08c-0.06-0.051-0.12-0.11-0.18-0.17c-32.64-31.721-53.18-73.381-58.42-119.21   c-4.54-39.75,2.83-79.04,20.95-113.75c4.99-9.561,10.81-18.78,17.41-27.561c1.09-1.449,2.2-2.89,3.34-4.319   c0.55-0.69,1.1-1.37,1.65-2.051c37.76-46.25,93.52-72.729,153.42-72.729c45.101,0,87.641,14.87,123.021,42.99   c1.54,1.22,2.89,2.33,4.14,3.39c3.16,2.64,6.29,5.43,9.51,8.5c1.811,1.72,3.58,3.48,5.311,5.26c0.05,0.061,0.11,0.11,0.16,0.17   c32.319,33.33,51.83,76.92,55.149,123.58C454.97,289.51,439.88,338.23,408.95,377.15z"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "circle",
                {
                  cx: "285",
                  cy: "156",
                  r: "44.5",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "circle",
                {
                  cx: "385",
                  cy: "300",
                  r: "21.5",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "circle",
                {
                  cx: "166",
                  cy: "296.5",
                  r: "27.84",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "circle",
                {
                  cx: "261.25",
                  cy: "272.75",
                  r: "14.75",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "circle",
                {
                  cx: "151.5",
                  cy: "184",
                  r: "28",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "circle",
                {
                  cx: "297.5",
                  cy: "382.501",
                  r: "27.5",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "circle",
                {
                  cx: "395",
                  cy: "213",
                  r: "18.5",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "circle",
                {
                  cx: "317",
                  cy: "216",
                  r: "8",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "path",
                {
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4",
                  d: "M299.55,450.38   c-12.27,2.34-24.87,3.55-37.66,3.55c-27.92,0-54.94-5.739-80.32-17.04c-7.74-3.46-15.3-7.43-22.47-11.81   c-6.96-4.24-13.77-9-20.24-14.14c-5.28-4.19-10.3-8.62-15.07-13.25c-1.3-1.261-2.57-2.54-3.82-3.83   c-0.06-0.051-0.12-0.11-0.18-0.17c-32.64-31.721-53.18-73.381-58.42-119.21c-4.54-39.75,2.83-79.04,20.95-113.75   c4.99-9.561,10.81-18.78,17.41-27.561c1.09-1.449,2.2-2.89,3.34-4.319c0.55-0.69,1.1-1.37,1.65-2.051   c-0.16,3.011-0.29,6.2-0.39,9.58c-2.39,79.15,12.97,253.43,185.661,310.98C293.12,448.41,296.31,449.42,299.55,450.38z",
                  opacity: ".2"
                }
              )
            ] })
          }
        ) })
      ] }) })
    }
  );
};
export {
  q7e as AiMessageTable,
  $7e as AppThemeProvider,
  k3 as ChatInput,
  W7e as ChatScreenAdsPreview,
  z7e as ChatScreenPA,
  X7e as HousewareBranding,
  Z7e as ThemeToggle,
  G7e as WelcomeScreenAds,
  H7e as WelcomeScreenConversations,
  Tv as useThemeManager
};
