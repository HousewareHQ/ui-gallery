var YY = Object.defineProperty;
var qY = (e, t, r) => t in e ? YY(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r;
var Ff = (e, t, r) => qY(e, typeof t != "symbol" ? t + "" : t, r);
import * as T from "react";
import H, { createContext as Xl, forwardRef as fn, useContext as rr, version as ZY, isValidElement as XY, useRef as le, useLayoutEffect as ja, useEffect as It, useMemo as ct, useState as Ee, Children as QY, createRef as JY, useCallback as Wt, useImperativeHandle as Nc, cloneElement as eq, createElement as uH, useReducer as tq, PureComponent as rq, Fragment as nq, memo as Vi, Component as iq } from "react";
import * as oq from "react-dom";
import Ec, { createPortal as kT, unstable_batchedUpdates as aq, flushSync as sq } from "react-dom";
var S0 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Uh(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var dE = { exports: {} }, Lf = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var QA;
function lq() {
  if (QA) return Lf;
  QA = 1;
  var e = H, t = Symbol.for("react.element"), r = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, d = {}, h = null, f = null;
    u !== void 0 && (h = "" + u), l.key !== void 0 && (h = "" + l.key), l.ref !== void 0 && (f = l.ref);
    for (c in l) n.call(l, c) && !o.hasOwnProperty(c) && (d[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: s, key: h, ref: f, props: d, _owner: i.current };
  }
  return Lf.Fragment = r, Lf.jsx = a, Lf.jsxs = a, Lf;
}
var Of = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JA;
function uq() {
  return JA || (JA = 1, process.env.NODE_ENV !== "production" && function() {
    var e = H, t = Symbol.for("react.element"), r = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), p = Symbol.iterator, g = "@@iterator";
    function v(q) {
      if (q === null || typeof q != "object")
        return null;
      var ve = p && q[p] || q[g];
      return typeof ve == "function" ? ve : null;
    }
    var m = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function y(q) {
      {
        for (var ve = arguments.length, be = new Array(ve > 1 ? ve - 1 : 0), Ke = 1; Ke < ve; Ke++)
          be[Ke - 1] = arguments[Ke];
        C("error", q, be);
      }
    }
    function C(q, ve, be) {
      {
        var Ke = m.ReactDebugCurrentFrame, vt = Ke.getStackAddendum();
        vt !== "" && (ve += "%s", be = be.concat([vt]));
        var ut = be.map(function(mt) {
          return String(mt);
        });
        ut.unshift("Warning: " + ve), Function.prototype.apply.call(console[q], console, ut);
      }
    }
    var S = !1, b = !1, w = !1, x = !1, E = !1, R;
    R = Symbol.for("react.module.reference");
    function _(q) {
      return !!(typeof q == "string" || typeof q == "function" || q === n || q === o || E || q === i || q === u || q === c || x || q === f || S || b || w || typeof q == "object" && q !== null && (q.$$typeof === h || q.$$typeof === d || q.$$typeof === a || q.$$typeof === s || q.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      q.$$typeof === R || q.getModuleId !== void 0));
    }
    function P(q, ve, be) {
      var Ke = q.displayName;
      if (Ke)
        return Ke;
      var vt = ve.displayName || ve.name || "";
      return vt !== "" ? be + "(" + vt + ")" : be;
    }
    function D(q) {
      return q.displayName || "Context";
    }
    function I(q) {
      if (q == null)
        return null;
      if (typeof q.tag == "number" && y("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof q == "function")
        return q.displayName || q.name || null;
      if (typeof q == "string")
        return q;
      switch (q) {
        case n:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof q == "object")
        switch (q.$$typeof) {
          case s:
            var ve = q;
            return D(ve) + ".Consumer";
          case a:
            var be = q;
            return D(be._context) + ".Provider";
          case l:
            return P(q, q.render, "ForwardRef");
          case d:
            var Ke = q.displayName || null;
            return Ke !== null ? Ke : I(q.type) || "Memo";
          case h: {
            var vt = q, ut = vt._payload, mt = vt._init;
            try {
              return I(mt(ut));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var A = Object.assign, O = 0, L, N, F, G, M, V, z;
    function k() {
    }
    k.__reactDisabledLog = !0;
    function $() {
      {
        if (O === 0) {
          L = console.log, N = console.info, F = console.warn, G = console.error, M = console.group, V = console.groupCollapsed, z = console.groupEnd;
          var q = {
            configurable: !0,
            enumerable: !0,
            value: k,
            writable: !0
          };
          Object.defineProperties(console, {
            info: q,
            log: q,
            warn: q,
            error: q,
            group: q,
            groupCollapsed: q,
            groupEnd: q
          });
        }
        O++;
      }
    }
    function W() {
      {
        if (O--, O === 0) {
          var q = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: A({}, q, {
              value: L
            }),
            info: A({}, q, {
              value: N
            }),
            warn: A({}, q, {
              value: F
            }),
            error: A({}, q, {
              value: G
            }),
            group: A({}, q, {
              value: M
            }),
            groupCollapsed: A({}, q, {
              value: V
            }),
            groupEnd: A({}, q, {
              value: z
            })
          });
        }
        O < 0 && y("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = m.ReactCurrentDispatcher, U;
    function Z(q, ve, be) {
      {
        if (U === void 0)
          try {
            throw Error();
          } catch (vt) {
            var Ke = vt.stack.trim().match(/\n( *(at )?)/);
            U = Ke && Ke[1] || "";
          }
        return `
` + U + q;
      }
    }
    var ee = !1, J;
    {
      var X = typeof WeakMap == "function" ? WeakMap : Map;
      J = new X();
    }
    function Y(q, ve) {
      if (!q || ee)
        return "";
      {
        var be = J.get(q);
        if (be !== void 0)
          return be;
      }
      var Ke;
      ee = !0;
      var vt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ut;
      ut = j.current, j.current = null, $();
      try {
        if (ve) {
          var mt = function() {
            throw Error();
          };
          if (Object.defineProperty(mt.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(mt, []);
            } catch (Ir) {
              Ke = Ir;
            }
            Reflect.construct(q, [], mt);
          } else {
            try {
              mt.call();
            } catch (Ir) {
              Ke = Ir;
            }
            q.call(mt.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ir) {
            Ke = Ir;
          }
          q();
        }
      } catch (Ir) {
        if (Ir && Ke && typeof Ir.stack == "string") {
          for (var Pt = Ir.stack.split(`
`), Dr = Ke.stack.split(`
`), or = Pt.length - 1, Ot = Dr.length - 1; or >= 1 && Ot >= 0 && Pt[or] !== Dr[Ot]; )
            Ot--;
          for (; or >= 1 && Ot >= 0; or--, Ot--)
            if (Pt[or] !== Dr[Ot]) {
              if (or !== 1 || Ot !== 1)
                do
                  if (or--, Ot--, Ot < 0 || Pt[or] !== Dr[Ot]) {
                    var nn = `
` + Pt[or].replace(" at new ", " at ");
                    return q.displayName && nn.includes("<anonymous>") && (nn = nn.replace("<anonymous>", q.displayName)), typeof q == "function" && J.set(q, nn), nn;
                  }
                while (or >= 1 && Ot >= 0);
              break;
            }
        }
      } finally {
        ee = !1, j.current = ut, W(), Error.prepareStackTrace = vt;
      }
      var ii = q ? q.displayName || q.name : "", Wn = ii ? Z(ii) : "";
      return typeof q == "function" && J.set(q, Wn), Wn;
    }
    function de(q, ve, be) {
      return Y(q, !1);
    }
    function K(q) {
      var ve = q.prototype;
      return !!(ve && ve.isReactComponent);
    }
    function ie(q, ve, be) {
      if (q == null)
        return "";
      if (typeof q == "function")
        return Y(q, K(q));
      if (typeof q == "string")
        return Z(q);
      switch (q) {
        case u:
          return Z("Suspense");
        case c:
          return Z("SuspenseList");
      }
      if (typeof q == "object")
        switch (q.$$typeof) {
          case l:
            return de(q.render);
          case d:
            return ie(q.type, ve, be);
          case h: {
            var Ke = q, vt = Ke._payload, ut = Ke._init;
            try {
              return ie(ut(vt), ve, be);
            } catch {
            }
          }
        }
      return "";
    }
    var Ce = Object.prototype.hasOwnProperty, Te = {}, Ie = m.ReactDebugCurrentFrame;
    function we(q) {
      if (q) {
        var ve = q._owner, be = ie(q.type, q._source, ve ? ve.type : null);
        Ie.setExtraStackFrame(be);
      } else
        Ie.setExtraStackFrame(null);
    }
    function Re(q, ve, be, Ke, vt) {
      {
        var ut = Function.call.bind(Ce);
        for (var mt in q)
          if (ut(q, mt)) {
            var Pt = void 0;
            try {
              if (typeof q[mt] != "function") {
                var Dr = Error((Ke || "React class") + ": " + be + " type `" + mt + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof q[mt] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Dr.name = "Invariant Violation", Dr;
              }
              Pt = q[mt](ve, mt, Ke, be, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (or) {
              Pt = or;
            }
            Pt && !(Pt instanceof Error) && (we(vt), y("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Ke || "React class", be, mt, typeof Pt), we(null)), Pt instanceof Error && !(Pt.message in Te) && (Te[Pt.message] = !0, we(vt), y("Failed %s type: %s", be, Pt.message), we(null));
          }
      }
    }
    var _e = Array.isArray;
    function He(q) {
      return _e(q);
    }
    function Ve(q) {
      {
        var ve = typeof Symbol == "function" && Symbol.toStringTag, be = ve && q[Symbol.toStringTag] || q.constructor.name || "Object";
        return be;
      }
    }
    function $e(q) {
      try {
        return Je(q), !1;
      } catch {
        return !0;
      }
    }
    function Je(q) {
      return "" + q;
    }
    function Q(q) {
      if ($e(q))
        return y("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Ve(q)), Je(q);
    }
    var ye = m.ReactCurrentOwner, Ge = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Pe, Le, me;
    me = {};
    function De(q) {
      if (Ce.call(q, "ref")) {
        var ve = Object.getOwnPropertyDescriptor(q, "ref").get;
        if (ve && ve.isReactWarning)
          return !1;
      }
      return q.ref !== void 0;
    }
    function qe(q) {
      if (Ce.call(q, "key")) {
        var ve = Object.getOwnPropertyDescriptor(q, "key").get;
        if (ve && ve.isReactWarning)
          return !1;
      }
      return q.key !== void 0;
    }
    function ht(q, ve) {
      if (typeof q.ref == "string" && ye.current && ve && ye.current.stateNode !== ve) {
        var be = I(ye.current.type);
        me[be] || (y('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', I(ye.current.type), q.ref), me[be] = !0);
      }
    }
    function Tt(q, ve) {
      {
        var be = function() {
          Pe || (Pe = !0, y("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ve));
        };
        be.isReactWarning = !0, Object.defineProperty(q, "key", {
          get: be,
          configurable: !0
        });
      }
    }
    function lt(q, ve) {
      {
        var be = function() {
          Le || (Le = !0, y("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ve));
        };
        be.isReactWarning = !0, Object.defineProperty(q, "ref", {
          get: be,
          configurable: !0
        });
      }
    }
    var tt = function(q, ve, be, Ke, vt, ut, mt) {
      var Pt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: q,
        key: ve,
        ref: be,
        props: mt,
        // Record the component responsible for creating this element.
        _owner: ut
      };
      return Pt._store = {}, Object.defineProperty(Pt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Pt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ke
      }), Object.defineProperty(Pt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: vt
      }), Object.freeze && (Object.freeze(Pt.props), Object.freeze(Pt)), Pt;
    };
    function Oe(q, ve, be, Ke, vt) {
      {
        var ut, mt = {}, Pt = null, Dr = null;
        be !== void 0 && (Q(be), Pt = "" + be), qe(ve) && (Q(ve.key), Pt = "" + ve.key), De(ve) && (Dr = ve.ref, ht(ve, vt));
        for (ut in ve)
          Ce.call(ve, ut) && !Ge.hasOwnProperty(ut) && (mt[ut] = ve[ut]);
        if (q && q.defaultProps) {
          var or = q.defaultProps;
          for (ut in or)
            mt[ut] === void 0 && (mt[ut] = or[ut]);
        }
        if (Pt || Dr) {
          var Ot = typeof q == "function" ? q.displayName || q.name || "Unknown" : q;
          Pt && Tt(mt, Ot), Dr && lt(mt, Ot);
        }
        return tt(q, Pt, Dr, vt, Ke, ye.current, mt);
      }
    }
    var je = m.ReactCurrentOwner, pt = m.ReactDebugCurrentFrame;
    function wt(q) {
      if (q) {
        var ve = q._owner, be = ie(q.type, q._source, ve ? ve.type : null);
        pt.setExtraStackFrame(be);
      } else
        pt.setExtraStackFrame(null);
    }
    var $r;
    $r = !1;
    function xr(q) {
      return typeof q == "object" && q !== null && q.$$typeof === t;
    }
    function Ut() {
      {
        if (je.current) {
          var q = I(je.current.type);
          if (q)
            return `

Check the render method of \`` + q + "`.";
        }
        return "";
      }
    }
    function Ht(q) {
      return "";
    }
    var Lt = {};
    function gt(q) {
      {
        var ve = Ut();
        if (!ve) {
          var be = typeof q == "string" ? q : q.displayName || q.name;
          be && (ve = `

Check the top-level render call using <` + be + ">.");
        }
        return ve;
      }
    }
    function nt(q, ve) {
      {
        if (!q._store || q._store.validated || q.key != null)
          return;
        q._store.validated = !0;
        var be = gt(ve);
        if (Lt[be])
          return;
        Lt[be] = !0;
        var Ke = "";
        q && q._owner && q._owner !== je.current && (Ke = " It was passed a child from " + I(q._owner.type) + "."), wt(q), y('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', be, Ke), wt(null);
      }
    }
    function Qt(q, ve) {
      {
        if (typeof q != "object")
          return;
        if (He(q))
          for (var be = 0; be < q.length; be++) {
            var Ke = q[be];
            xr(Ke) && nt(Ke, ve);
          }
        else if (xr(q))
          q._store && (q._store.validated = !0);
        else if (q) {
          var vt = v(q);
          if (typeof vt == "function" && vt !== q.entries)
            for (var ut = vt.call(q), mt; !(mt = ut.next()).done; )
              xr(mt.value) && nt(mt.value, ve);
        }
      }
    }
    function kr(q) {
      {
        var ve = q.type;
        if (ve == null || typeof ve == "string")
          return;
        var be;
        if (typeof ve == "function")
          be = ve.propTypes;
        else if (typeof ve == "object" && (ve.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ve.$$typeof === d))
          be = ve.propTypes;
        else
          return;
        if (be) {
          var Ke = I(ve);
          Re(be, q.props, "prop", Ke, q);
        } else if (ve.PropTypes !== void 0 && !$r) {
          $r = !0;
          var vt = I(ve);
          y("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", vt || "Unknown");
        }
        typeof ve.getDefaultProps == "function" && !ve.getDefaultProps.isReactClassApproved && y("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Kt(q) {
      {
        for (var ve = Object.keys(q.props), be = 0; be < ve.length; be++) {
          var Ke = ve[be];
          if (Ke !== "children" && Ke !== "key") {
            wt(q), y("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Ke), wt(null);
            break;
          }
        }
        q.ref !== null && (wt(q), y("Invalid attribute `ref` supplied to `React.Fragment`."), wt(null));
      }
    }
    var Yt = {};
    function vr(q, ve, be, Ke, vt, ut) {
      {
        var mt = _(q);
        if (!mt) {
          var Pt = "";
          (q === void 0 || typeof q == "object" && q !== null && Object.keys(q).length === 0) && (Pt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Dr = Ht();
          Dr ? Pt += Dr : Pt += Ut();
          var or;
          q === null ? or = "null" : He(q) ? or = "array" : q !== void 0 && q.$$typeof === t ? (or = "<" + (I(q.type) || "Unknown") + " />", Pt = " Did you accidentally export a JSX literal instead of a component?") : or = typeof q, y("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", or, Pt);
        }
        var Ot = Oe(q, ve, be, vt, ut);
        if (Ot == null)
          return Ot;
        if (mt) {
          var nn = ve.children;
          if (nn !== void 0)
            if (Ke)
              if (He(nn)) {
                for (var ii = 0; ii < nn.length; ii++)
                  Qt(nn[ii], q);
                Object.freeze && Object.freeze(nn);
              } else
                y("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Qt(nn, q);
        }
        if (Ce.call(ve, "key")) {
          var Wn = I(q), Ir = Object.keys(ve).filter(function(oi) {
            return oi !== "key";
          }), ba = Ir.length > 0 ? "{key: someKey, " + Ir.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Yt[Wn + ba]) {
            var rl = Ir.length > 0 ? "{" + Ir.join(": ..., ") + ": ...}" : "{}";
            y(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ba, Wn, rl, Wn), Yt[Wn + ba] = !0;
          }
        }
        return q === n ? Kt(Ot) : kr(Ot), Ot;
      }
    }
    function Br(q, ve, be) {
      return vr(q, ve, be, !0);
    }
    function yn(q, ve, be) {
      return vr(q, ve, be, !1);
    }
    var $n = yn, ni = Br;
    Of.Fragment = n, Of.jsx = $n, Of.jsxs = ni;
  }()), Of;
}
process.env.NODE_ENV === "production" ? dE.exports = lq() : dE.exports = uq();
var ce = dE.exports;
const cq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M244,56v48a12,12,0,0,1-12,12H184a12,12,0,1,1,0-24H201.1l-19-17.38c-.13-.12-.26-.24-.38-.37A76,76,0,1,0,127,204h1a75.53,75.53,0,0,0,52.15-20.72,12,12,0,0,1,16.49,17.45A99.45,99.45,0,0,1,128,228h-1.37A100,100,0,1,1,198.51,57.06L220,76.72V56a12,12,0,0,1,24,0Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,128a88,88,0,1,1-88-88A88,88,0,0,1,216,128Z", opacity: "0.2" }), /* @__PURE__ */ H.createElement("path", { d: "M240,56v48a8,8,0,0,1-8,8H184a8,8,0,0,1,0-16H211.4L184.81,71.64l-.25-.24a80,80,0,1,0-1.67,114.78,8,8,0,0,1,11,11.63A95.44,95.44,0,0,1,128,224h-1.32A96,96,0,1,1,195.75,60L224,85.8V56a8,8,0,1,1,16,0Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M240,56v48a8,8,0,0,1-8,8H184a8,8,0,0,1-5.66-13.66l17-17-10.55-9.65-.25-.24a80,80,0,1,0-1.67,114.78,8,8,0,1,1,11,11.63A95.44,95.44,0,0,1,128,224h-1.32A96,96,0,1,1,195.75,60l10.93,10L226.34,50.3A8,8,0,0,1,240,56Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M238,56v48a6,6,0,0,1-6,6H184a6,6,0,0,1,0-12h32.55l-30.38-27.8c-.06-.06-.12-.13-.19-.19a82,82,0,1,0-1.7,117.65,6,6,0,0,1,8.24,8.73A93.46,93.46,0,0,1,128,222h-1.28A94,94,0,1,1,194.37,61.4L226,90.35V56a6,6,0,1,1,12,0Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M240,56v48a8,8,0,0,1-8,8H184a8,8,0,0,1,0-16H211.4L184.81,71.64l-.25-.24a80,80,0,1,0-1.67,114.78,8,8,0,0,1,11,11.63A95.44,95.44,0,0,1,128,224h-1.32A96,96,0,1,1,195.75,60L224,85.8V56a8,8,0,1,1,16,0Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M236,56v48a4,4,0,0,1-4,4H184a4,4,0,0,1,0-8h37.7L187.53,68.69l-.13-.12a84,84,0,1,0-1.75,120.51,4,4,0,0,1,5.5,5.82A91.43,91.43,0,0,1,128,220h-1.26A92,92,0,1,1,193,62.84l35,32.05V56a4,4,0,1,1,8,0Z" }))
  ]
]), dq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M176.49,95.51a12,12,0,0,1,0,17l-56,56a12,12,0,0,1-17,0l-24-24a12,12,0,1,1,17-17L112,143l47.51-47.52A12,12,0,0,1,176.49,95.51ZM236,128A108,108,0,1,1,128,20,108.12,108.12,0,0,1,236,128Zm-24,0a84,84,0,1,0-84,84A84.09,84.09,0,0,0,212,128Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M224,128a96,96,0,1,1-96-96A96,96,0,0,1,224,128Z", opacity: "0.2" }), /* @__PURE__ */ H.createElement("path", { d: "M173.66,98.34a8,8,0,0,1,0,11.32l-56,56a8,8,0,0,1-11.32,0l-24-24a8,8,0,0,1,11.32-11.32L112,148.69l50.34-50.35A8,8,0,0,1,173.66,98.34ZM232,128A104,104,0,1,1,128,24,104.11,104.11,0,0,1,232,128Zm-16,0a88,88,0,1,0-88,88A88.1,88.1,0,0,0,216,128Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm45.66,85.66-56,56a8,8,0,0,1-11.32,0l-24-24a8,8,0,0,1,11.32-11.32L112,148.69l50.34-50.35a8,8,0,0,1,11.32,11.32Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M172.24,99.76a6,6,0,0,1,0,8.48l-56,56a6,6,0,0,1-8.48,0l-24-24a6,6,0,0,1,8.48-8.48L112,151.51l51.76-51.75A6,6,0,0,1,172.24,99.76ZM230,128A102,102,0,1,1,128,26,102.12,102.12,0,0,1,230,128Zm-12,0a90,90,0,1,0-90,90A90.1,90.1,0,0,0,218,128Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M173.66,98.34a8,8,0,0,1,0,11.32l-56,56a8,8,0,0,1-11.32,0l-24-24a8,8,0,0,1,11.32-11.32L112,148.69l50.34-50.35A8,8,0,0,1,173.66,98.34ZM232,128A104,104,0,1,1,128,24,104.11,104.11,0,0,1,232,128Zm-16,0a88,88,0,1,0-88,88A88.1,88.1,0,0,0,216,128Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M170.83,101.17a4,4,0,0,1,0,5.66l-56,56a4,4,0,0,1-5.66,0l-24-24a4,4,0,0,1,5.66-5.66L112,154.34l53.17-53.17A4,4,0,0,1,170.83,101.17ZM228,128A100,100,0,1,1,128,28,100.11,100.11,0,0,1,228,128Zm-8,0a92,92,0,1,0-92,92A92.1,92.1,0,0,0,220,128Z" }))
  ]
]), hq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,28H165.47a51.88,51.88,0,0,0-74.94,0H56A20,20,0,0,0,36,48V216a20,20,0,0,0,20,20H200a20,20,0,0,0,20-20V48A20,20,0,0,0,200,28ZM155.71,60H100.29a28,28,0,0,1,55.42,0ZM196,212H60V52H77.41A52.13,52.13,0,0,0,76,64v8A12,12,0,0,0,88,84h80a12,12,0,0,0,12-12V64a52.13,52.13,0,0,0-1.41-12H196Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M208,48V216a8,8,0,0,1-8,8H56a8,8,0,0,1-8-8V48a8,8,0,0,1,8-8H96a39.83,39.83,0,0,0-8,24v8h80V64a39.83,39.83,0,0,0-8-24h40A8,8,0,0,1,208,48Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M200,32H163.74a47.92,47.92,0,0,0-71.48,0H56A16,16,0,0,0,40,48V216a16,16,0,0,0,16,16H200a16,16,0,0,0,16-16V48A16,16,0,0,0,200,32Zm-72,0a32,32,0,0,1,32,32H96A32,32,0,0,1,128,32Zm72,184H56V48H82.75A47.93,47.93,0,0,0,80,64v8a8,8,0,0,0,8,8h80a8,8,0,0,0,8-8V64a47.93,47.93,0,0,0-2.75-16H200Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,32H163.74a47.92,47.92,0,0,0-71.48,0H56A16,16,0,0,0,40,48V216a16,16,0,0,0,16,16H200a16,16,0,0,0,16-16V48A16,16,0,0,0,200,32Zm-72,0a32,32,0,0,1,32,32H96A32,32,0,0,1,128,32Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,34H162.83a45.91,45.91,0,0,0-69.66,0H56A14,14,0,0,0,42,48V216a14,14,0,0,0,14,14H200a14,14,0,0,0,14-14V48A14,14,0,0,0,200,34Zm-72-4a34,34,0,0,1,34,34v2H94V64A34,34,0,0,1,128,30Zm74,186a2,2,0,0,1-2,2H56a2,2,0,0,1-2-2V48a2,2,0,0,1,2-2H85.67A45.77,45.77,0,0,0,82,64v8a6,6,0,0,0,6,6h80a6,6,0,0,0,6-6V64a45.77,45.77,0,0,0-3.67-18H200a2,2,0,0,1,2,2Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,32H163.74a47.92,47.92,0,0,0-71.48,0H56A16,16,0,0,0,40,48V216a16,16,0,0,0,16,16H200a16,16,0,0,0,16-16V48A16,16,0,0,0,200,32Zm-72,0a32,32,0,0,1,32,32H96A32,32,0,0,1,128,32Zm72,184H56V48H82.75A47.93,47.93,0,0,0,80,64v8a8,8,0,0,0,8,8h80a8,8,0,0,0,8-8V64a47.93,47.93,0,0,0-2.75-16H200Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M200,36H161.92a44,44,0,0,0-67.84,0H56A12,12,0,0,0,44,48V216a12,12,0,0,0,12,12H200a12,12,0,0,0,12-12V48A12,12,0,0,0,200,36Zm-72-8a36,36,0,0,1,36,36v4H92V64A36,36,0,0,1,128,28Zm76,188a4,4,0,0,1-4,4H56a4,4,0,0,1-4-4V48a4,4,0,0,1,4-4H88.83A43.71,43.71,0,0,0,84,64v8a4,4,0,0,0,4,4h80a4,4,0,0,0,4-4V64a43.71,43.71,0,0,0-4.83-20H200a4,4,0,0,1,4,4Z" }))
  ]
]), fq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M71.51,88.49a12,12,0,0,1,17-17L116,99V24a12,12,0,0,1,24,0V99l27.51-27.52a12,12,0,0,1,17,17l-48,48a12,12,0,0,1-17,0ZM224,116H188a12,12,0,0,0,0,24h32v56H36V140H68a12,12,0,0,0,0-24H32a20,20,0,0,0-20,20v64a20,20,0,0,0,20,20H224a20,20,0,0,0,20-20V136A20,20,0,0,0,224,116Zm-20,52a16,16,0,1,0-16,16A16,16,0,0,0,204,168Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M232,136v64a8,8,0,0,1-8,8H32a8,8,0,0,1-8-8V136a8,8,0,0,1,8-8H224A8,8,0,0,1,232,136Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H72a8,8,0,0,1,0,16H32v64H224V136H184a8,8,0,0,1,0-16h40A16,16,0,0,1,240,136Zm-117.66-2.34a8,8,0,0,0,11.32,0l48-48a8,8,0,0,0-11.32-11.32L136,108.69V24a8,8,0,0,0-16,0v84.69L85.66,74.34A8,8,0,0,0,74.34,85.66ZM200,168a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M74.34,85.66A8,8,0,0,1,85.66,74.34L120,108.69V24a8,8,0,0,1,16,0v84.69l34.34-34.35a8,8,0,0,1,11.32,11.32l-48,48a8,8,0,0,1-11.32,0ZM240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H84.4a4,4,0,0,1,2.83,1.17L111,145A24,24,0,0,0,145,145l23.8-23.8A4,4,0,0,1,171.6,120H224A16,16,0,0,1,240,136Zm-40,32a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M238,136v64a14,14,0,0,1-14,14H32a14,14,0,0,1-14-14V136a14,14,0,0,1,14-14H72a6,6,0,0,1,0,12H32a2,2,0,0,0-2,2v64a2,2,0,0,0,2,2H224a2,2,0,0,0,2-2V136a2,2,0,0,0-2-2H184a6,6,0,0,1,0-12h40A14,14,0,0,1,238,136Zm-114.24-3.76a6,6,0,0,0,8.48,0l48-48a6,6,0,0,0-8.48-8.48L134,113.51V24a6,6,0,0,0-12,0v89.51L84.24,75.76a6,6,0,0,0-8.48,8.48ZM198,168a10,10,0,1,0-10,10A10,10,0,0,0,198,168Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M240,136v64a16,16,0,0,1-16,16H32a16,16,0,0,1-16-16V136a16,16,0,0,1,16-16H72a8,8,0,0,1,0,16H32v64H224V136H184a8,8,0,0,1,0-16h40A16,16,0,0,1,240,136Zm-117.66-2.34a8,8,0,0,0,11.32,0l48-48a8,8,0,0,0-11.32-11.32L136,108.69V24a8,8,0,0,0-16,0v84.69L85.66,74.34A8,8,0,0,0,74.34,85.66ZM200,168a12,12,0,1,0-12,12A12,12,0,0,0,200,168Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M236,136v64a12,12,0,0,1-12,12H32a12,12,0,0,1-12-12V136a12,12,0,0,1,12-12H72a4,4,0,0,1,0,8H32a4,4,0,0,0-4,4v64a4,4,0,0,0,4,4H224a4,4,0,0,0,4-4V136a4,4,0,0,0-4-4H184a4,4,0,0,1,0-8h40A12,12,0,0,1,236,136Zm-110.83-5.17a4,4,0,0,0,5.66,0l48-48a4,4,0,1,0-5.66-5.66L132,118.34V24a4,4,0,0,0-8,0v94.34L82.83,77.17a4,4,0,0,0-5.66,5.66ZM196,168a8,8,0,1,0-8,8A8,8,0,0,0,196,168Z" }))
  ]
]), pq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,20A108,108,0,1,0,236,128,108.12,108.12,0,0,0,128,20Zm84,108a83.64,83.64,0,0,1-4.47,27L167,130a19.65,19.65,0,0,0-7.8-2.78l-22.82-3.08A20.14,20.14,0,0,0,117.72,132h-4.07l-2.71-5.6a19.88,19.88,0,0,0-13.8-10.84L94.46,115l4-7h14.39a20,20,0,0,0,9.66-2.49l12.25-6.76a20.57,20.57,0,0,0,3.74-2.68l26.92-24.33A20,20,0,0,0,172,56.49,84,84,0,0,1,212,128ZM140.76,45l6.2,11.1L122.75,78l-10.93,6H96.14A20.05,20.05,0,0,0,78.78,94.06l-4.49,7.85L67.68,84.28l9.91-23.42A83.91,83.91,0,0,1,140.76,45ZM44,128a83.52,83.52,0,0,1,4.4-26.77l7.74,20.65a19.89,19.89,0,0,0,14.52,12.53l19.53,4.2,3,6.1a20.11,20.11,0,0,0,13.55,10.77l-5,11.12a20,20,0,0,0,3.58,21.71l.21.22,18.16,18.7-.89,4.59A84.09,84.09,0,0,1,44,128Zm103.65,81.66a20.11,20.11,0,0,0-5-17.3l-.21-.22-17.72-18.25,11.37-25.52,19,2.56,41.43,25.48A84.2,84.2,0,0,1,147.65,209.66Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M213.09,172.48a96,96,0,0,1-80.41,51.41l3.17-16.44a8,8,0,0,0-2-6.95l-19.74-20.33a8,8,0,0,1-1.44-8.69l13.7-30.74a8,8,0,0,1,8.38-4.67l22.82,3.08a8.11,8.11,0,0,1,3.12,1.11ZM116.71,95,129,88.24a7.46,7.46,0,0,0,1.5-1.07l26.91-24.33A8,8,0,0,0,159,53l-10.5-18.81A96.62,96.62,0,0,0,128,32,95.61,95.61,0,0,0,67.78,53.23L56,81.08A8,8,0,0,0,55.88,87l11.5,30.67a8,8,0,0,0,5.81,5l2.69.58L89.2,100a8,8,0,0,1,6.94-4h16.71A7.9,7.9,0,0,0,116.71,95Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm88,104a87.62,87.62,0,0,1-6.4,32.94l-44.7-27.49a15.92,15.92,0,0,0-6.24-2.23l-22.82-3.08a16.11,16.11,0,0,0-16,7.86h-8.72l-3.8-7.86a15.91,15.91,0,0,0-11-8.67l-8-1.73L96.14,104h16.71a16.06,16.06,0,0,0,7.73-2l12.25-6.76a16.62,16.62,0,0,0,3-2.14l26.91-24.34A15.93,15.93,0,0,0,166,49.1l-.36-.65A88.11,88.11,0,0,1,216,128ZM143.31,41.34,152,56.9,125.09,81.24,112.85,88H96.14a16,16,0,0,0-13.88,8l-8.73,15.23L63.38,84.19,74.32,58.32a87.87,87.87,0,0,1,69-17ZM40,128a87.53,87.53,0,0,1,8.54-37.8l11.34,30.27a16,16,0,0,0,11.62,10l21.43,4.61L96.74,143a16.09,16.09,0,0,0,14.4,9h1.48l-7.23,16.23a16,16,0,0,0,2.86,17.37l.14.14L128,205.94l-1.94,10A88.11,88.11,0,0,1,40,128Zm102.58,86.78,1.13-5.81a16.09,16.09,0,0,0-4-13.9,1.85,1.85,0,0,1-.14-.14L120,174.74,133.7,144l22.82,3.08,45.72,28.12A88.18,88.18,0,0,1,142.58,214.78Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm88,104a87.62,87.62,0,0,1-6.4,32.94l-44.7-27.49a15.92,15.92,0,0,0-6.24-2.23l-22.82-3.08a16.11,16.11,0,0,0-16,7.86h-8.72l-3.8-7.86a15.91,15.91,0,0,0-11-8.67l-8-1.73L96.14,104h16.71a16.06,16.06,0,0,0,7.73-2l12.25-6.76a16.62,16.62,0,0,0,3-2.14l26.91-24.34A15.93,15.93,0,0,0,166,49.1l-.36-.65A88.11,88.11,0,0,1,216,128ZM40,128a87.53,87.53,0,0,1,8.54-37.8l11.34,30.27a16,16,0,0,0,11.62,10l21.43,4.61L96.74,143a16.09,16.09,0,0,0,14.4,9h1.48l-7.23,16.23a16,16,0,0,0,2.86,17.37l.14.14L128,205.94l-1.94,10A88.11,88.11,0,0,1,40,128Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,26A102,102,0,1,0,230,128,102.12,102.12,0,0,0,128,26Zm90,102a89.55,89.55,0,0,1-7.46,35.86l-46.69-28.71a13.94,13.94,0,0,0-5.46-2l-22.82-3.07A14.06,14.06,0,0,0,121.06,138h-9.92a2,2,0,0,1-1.8-1.13l-3.8-7.86a13.94,13.94,0,0,0-9.66-7.59l-10.71-2.3L94.4,103a2,2,0,0,1,1.74-1h16.71a13.9,13.9,0,0,0,6.76-1.75l12.25-6.75a14.73,14.73,0,0,0,2.62-1.88l26.91-24.33a13.93,13.93,0,0,0,2.83-17.21L161,44.25A90.16,90.16,0,0,1,218,128ZM144.6,39.54l9.15,16.39a2,2,0,0,1-.41,2.46L126.43,82.72a1.84,1.84,0,0,1-.37.27l-12.25,6.76a2,2,0,0,1-1,.25H96.14A14,14,0,0,0,84,97L73.18,115.91a2,2,0,0,1-.19-.35L61.5,84.89a2,2,0,0,1,0-1.48L72.68,57.06A89.9,89.9,0,0,1,144.6,39.54ZM38,128A89.52,89.52,0,0,1,49.38,84.23a13.85,13.85,0,0,0,.89,4.87l11.49,30.67a13.94,13.94,0,0,0,10.16,8.78l21.44,4.6a2,2,0,0,1,1.38,1.09l3.8,7.86a14.07,14.07,0,0,0,12.6,7.9h4.56l-8.49,19a14,14,0,0,0,2.51,15.2l.1.11,19.68,20.26a2,2,0,0,1,.46,1.7L127.7,218A90.1,90.1,0,0,1,38,128Zm102.08,89.19,1.67-8.6a14.07,14.07,0,0,0-3.47-12.16l-.1-.11L118.5,176.06a2,2,0,0,1-.33-2.14l13.7-30.73A2,2,0,0,1,134,142l22.82,3.08a2,2,0,0,1,.78.27L205,174.55A90.18,90.18,0,0,1,140.08,217.19Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,24A104,104,0,1,0,232,128,104.11,104.11,0,0,0,128,24Zm88,104a87.62,87.62,0,0,1-6.4,32.94l-44.7-27.49a15.92,15.92,0,0,0-6.24-2.23l-22.82-3.08a16.11,16.11,0,0,0-16,7.86h-8.72l-3.8-7.86a15.91,15.91,0,0,0-11-8.67l-8-1.73L96.14,104h16.71a16.06,16.06,0,0,0,7.73-2l12.25-6.76a16.62,16.62,0,0,0,3-2.14l26.91-24.34A15.93,15.93,0,0,0,166,49.1l-.36-.65A88.11,88.11,0,0,1,216,128ZM143.31,41.34,152,56.9,125.09,81.24,112.85,88H96.14a16,16,0,0,0-13.88,8l-8.73,15.23L63.38,84.19,74.32,58.32a87.87,87.87,0,0,1,69-17ZM40,128a87.53,87.53,0,0,1,8.54-37.8l11.34,30.27a16,16,0,0,0,11.62,10l21.43,4.61L96.74,143a16.09,16.09,0,0,0,14.4,9h1.48l-7.23,16.23a16,16,0,0,0,2.86,17.37l.14.14L128,205.94l-1.94,10A88.11,88.11,0,0,1,40,128Zm102.58,86.78,1.13-5.81a16.09,16.09,0,0,0-4-13.9,1.85,1.85,0,0,1-.14-.14L120,174.74,133.7,144l22.82,3.08,45.72,28.12A88.18,88.18,0,0,1,142.58,214.78Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M128,28A100,100,0,1,0,228,128,100.11,100.11,0,0,0,128,28Zm92,100a91.44,91.44,0,0,1-8.58,38.76L162.8,136.85a12.07,12.07,0,0,0-4.68-1.67l-22.82-3.07a12,12,0,0,0-12.56,7l-.4.88h-11.2a4,4,0,0,1-3.6-2.26l-3.8-7.86a11.93,11.93,0,0,0-8.28-6.5L82.07,120.5,92.67,102a4,4,0,0,1,3.47-2h16.71a12,12,0,0,0,5.8-1.5l12.24-6.76a11.79,11.79,0,0,0,2.25-1.6L160.05,65.8a12,12,0,0,0,2.43-14.75l-5.86-10.49A92.17,92.17,0,0,1,220,128ZM145.89,37.75l9.6,17.2a4,4,0,0,1-.81,4.92L127.77,84.21a4.41,4.41,0,0,1-.75.53L114.78,91.5a4,4,0,0,1-1.93.5H96.14a12,12,0,0,0-10.41,6l-11.86,20.7a4,4,0,0,1-2.75-2.47L59.63,85.6a4,4,0,0,1,.06-3L71,55.81A91.51,91.51,0,0,1,128,36,92.53,92.53,0,0,1,145.89,37.75ZM36,128A91.52,91.52,0,0,1,56,70.77l-3.71,8.75a12,12,0,0,0-.18,8.88l11.49,30.67a11.93,11.93,0,0,0,8.72,7.52l21.43,4.61a4,4,0,0,1,2.76,2.17l3.8,7.86a12.07,12.07,0,0,0,10.8,6.77h7.64L109,169.85A12,12,0,0,0,111.26,183l19.68,20.26a4,4,0,0,1,1,3.47L129.36,220,128,220A92.1,92.1,0,0,1,36,128Zm101.6,91.5,2.18-11.29a12.08,12.08,0,0,0-3-10.49l-19.68-20.26a4,4,0,0,1-.71-4.35l13.7-30.74a4,4,0,0,1,4.18-2.33l22.82,3.07a4.12,4.12,0,0,1,1.56.56l49.11,30.2A92.12,92.12,0,0,1,137.6,219.5Z" }))
  ]
]), gq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,20H40A20,20,0,0,0,20,40V216a20,20,0,0,0,20,20H216a20,20,0,0,0,20-20V40A20,20,0,0,0,216,20Zm-4,192H44V44H212ZM112,176V120a12,12,0,0,1,21.43-7.41A40,40,0,0,1,192,148v28a12,12,0,0,1-24,0V148a16,16,0,0,0-32,0v28a12,12,0,0,1-24,0ZM96,120v56a12,12,0,0,1-24,0V120a12,12,0,0,1,24,0ZM68,80A16,16,0,1,1,84,96,16,16,0,0,1,68,80Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M224,40V216a8,8,0,0,1-8,8H40a8,8,0,0,1-8-8V40a8,8,0,0,1,8-8H216A8,8,0,0,1,224,40Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M216,24H40A16,16,0,0,0,24,40V216a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V40A16,16,0,0,0,216,24Zm0,192H40V40H216V216ZM96,112v64a8,8,0,0,1-16,0V112a8,8,0,0,1,16,0Zm88,28v36a8,8,0,0,1-16,0V140a20,20,0,0,0-40,0v36a8,8,0,0,1-16,0V112a8,8,0,0,1,15.79-1.78A36,36,0,0,1,184,140ZM100,84A12,12,0,1,1,88,72,12,12,0,0,1,100,84Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,24H40A16,16,0,0,0,24,40V216a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V40A16,16,0,0,0,216,24ZM96,176a8,8,0,0,1-16,0V112a8,8,0,0,1,16,0ZM88,96a12,12,0,1,1,12-12A12,12,0,0,1,88,96Zm96,80a8,8,0,0,1-16,0V140a20,20,0,0,0-40,0v36a8,8,0,0,1-16,0V112a8,8,0,0,1,15.79-1.78A36,36,0,0,1,184,140Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,26H40A14,14,0,0,0,26,40V216a14,14,0,0,0,14,14H216a14,14,0,0,0,14-14V40A14,14,0,0,0,216,26Zm2,190a2,2,0,0,1-2,2H40a2,2,0,0,1-2-2V40a2,2,0,0,1,2-2H216a2,2,0,0,1,2,2ZM94,112v64a6,6,0,0,1-12,0V112a6,6,0,0,1,12,0Zm88,28v36a6,6,0,0,1-12,0V140a22,22,0,0,0-44,0v36a6,6,0,0,1-12,0V112a6,6,0,0,1,12,0v2.11A34,34,0,0,1,182,140ZM98,84A10,10,0,1,1,88,74,10,10,0,0,1,98,84Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,24H40A16,16,0,0,0,24,40V216a16,16,0,0,0,16,16H216a16,16,0,0,0,16-16V40A16,16,0,0,0,216,24Zm0,192H40V40H216V216ZM96,112v64a8,8,0,0,1-16,0V112a8,8,0,0,1,16,0Zm88,28v36a8,8,0,0,1-16,0V140a20,20,0,0,0-40,0v36a8,8,0,0,1-16,0V112a8,8,0,0,1,15.79-1.78A36,36,0,0,1,184,140ZM100,84A12,12,0,1,1,88,72,12,12,0,0,1,100,84Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M216,28H40A12,12,0,0,0,28,40V216a12,12,0,0,0,12,12H216a12,12,0,0,0,12-12V40A12,12,0,0,0,216,28Zm4,188a4,4,0,0,1-4,4H40a4,4,0,0,1-4-4V40a4,4,0,0,1,4-4H216a4,4,0,0,1,4,4ZM92,112v64a4,4,0,0,1-8,0V112a4,4,0,0,1,8,0Zm88,28v36a4,4,0,0,1-8,0V140a24,24,0,0,0-48,0v36a4,4,0,0,1-8,0V112a4,4,0,0,1,8,0v6.87A32,32,0,0,1,180,140ZM96,84a8,8,0,1,1-8-8A8,8,0,0,1,96,84Z" }))
  ]
]), vq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M230.14,25.86a20,20,0,0,0-19.57-5.11l-.22.07L18.44,79a20,20,0,0,0-3.06,37.25L99,157l40.71,83.65a19.81,19.81,0,0,0,18,11.38c.57,0,1.15,0,1.73-.07A19.82,19.82,0,0,0,177,237.56L235.18,45.65a1.42,1.42,0,0,0,.07-.22A20,20,0,0,0,230.14,25.86ZM156.91,221.07l-34.37-70.64,46-45.95a12,12,0,0,0-17-17l-46,46L34.93,99.09,210,46Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M223.69,42.18l-58.22,192a8,8,0,0,1-14.92,1.25L108,148,20.58,105.45a8,8,0,0,1,1.25-14.92l192-58.22A8,8,0,0,1,223.69,42.18Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M227.32,28.68a16,16,0,0,0-15.66-4.08l-.15,0L19.57,82.84a16,16,0,0,0-2.49,29.8L102,154l41.3,84.87A15.86,15.86,0,0,0,157.74,248q.69,0,1.38-.06a15.88,15.88,0,0,0,14-11.51l58.2-191.94c0-.05,0-.1,0-.15A16,16,0,0,0,227.32,28.68ZM157.83,231.85l-.05.14,0-.07-40.06-82.3,48-48a8,8,0,0,0-11.31-11.31l-48,48L24.08,98.25l-.07,0,.14,0L216,40Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M231.4,44.34s0,.1,0,.15l-58.2,191.94a15.88,15.88,0,0,1-14,11.51q-.69.06-1.38.06a15.86,15.86,0,0,1-14.42-9.15L107,164.15a4,4,0,0,1,.77-4.58l57.92-57.92a8,8,0,0,0-11.31-11.31L96.43,148.26a4,4,0,0,1-4.58.77L17.08,112.64a16,16,0,0,1,2.49-29.8l191.94-58.2.15,0A16,16,0,0,1,231.4,44.34Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M225.88,30.12a13.83,13.83,0,0,0-13.7-3.58l-.11,0L20.14,84.77A14,14,0,0,0,18,110.85l85.56,41.64L145.12,238a13.87,13.87,0,0,0,12.61,8c.4,0,.81,0,1.21-.05a13.9,13.9,0,0,0,12.29-10.09l58.2-191.93,0-.11A13.83,13.83,0,0,0,225.88,30.12Zm-8,10.4L159.73,232.43l0,.11a2,2,0,0,1-3.76.26l-40.68-83.58,49-49a6,6,0,1,0-8.49-8.49l-49,49L23.15,100a2,2,0,0,1,.31-3.74l.11,0L215.48,38.08a1.94,1.94,0,0,1,1.92.52A2,2,0,0,1,217.92,40.52Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M227.32,28.68a16,16,0,0,0-15.66-4.08l-.15,0L19.57,82.84a16,16,0,0,0-2.49,29.8L102,154l41.3,84.87A15.86,15.86,0,0,0,157.74,248q.69,0,1.38-.06a15.88,15.88,0,0,0,14-11.51l58.2-191.94c0-.05,0-.1,0-.15A16,16,0,0,0,227.32,28.68ZM157.83,231.85l-.05.14,0-.07-40.06-82.3,48-48a8,8,0,0,0-11.31-11.31l-48,48L24.08,98.25l-.07,0,.14,0L216,40Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M224.47,31.52a11.87,11.87,0,0,0-11.82-3L20.74,86.67a12,12,0,0,0-1.91,22.38L105,151l41.92,86.15A11.88,11.88,0,0,0,157.74,244c.34,0,.69,0,1,0a11.89,11.89,0,0,0,10.52-8.63l58.21-192,0-.08A11.85,11.85,0,0,0,224.47,31.52Zm-4.62,9.54-58.23,192a4,4,0,0,1-7.48.59l-41.3-84.86,50-50a4,4,0,1,0-5.66-5.66l-50,50-84.9-41.31a3.88,3.88,0,0,1-2.27-4,3.93,3.93,0,0,1,3-3.54L214.9,36.16A3.93,3.93,0,0,1,216,36a4,4,0,0,1,2.79,1.19A3.93,3.93,0,0,1,219.85,41.06Z" }))
  ]
]), mq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M250.73,210.63l-56-112a12,12,0,0,0-21.46,0l-20.52,41A84.2,84.2,0,0,1,114,126.22,107.48,107.48,0,0,0,139.33,68H160a12,12,0,0,0,0-24H108V32a12,12,0,0,0-24,0V44H32a12,12,0,0,0,0,24h83.13A83.69,83.69,0,0,1,96,110.35,84,84,0,0,1,83.6,91a12,12,0,1,0-21.81,10A107.55,107.55,0,0,0,78,126.24,83.54,83.54,0,0,1,32,140a12,12,0,0,0,0,24,107.47,107.47,0,0,0,64-21.07,108.4,108.4,0,0,0,45.39,19.44l-24.13,48.26a12,12,0,1,0,21.46,10.73L151.41,196h65.17l12.68,25.36a12,12,0,1,0,21.47-10.73ZM163.41,172,184,130.83,204.58,172Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M224,184H144l40-80ZM96,127.56h0A95.78,95.78,0,0,0,128,56H64A95.78,95.78,0,0,0,96,127.56Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M247.15,212.42l-56-112a8,8,0,0,0-14.31,0l-21.71,43.43A88,88,0,0,1,108,126.93,103.65,103.65,0,0,0,135.69,64H160a8,8,0,0,0,0-16H104V32a8,8,0,0,0-16,0V48H32a8,8,0,0,0,0,16h87.63A87.7,87.7,0,0,1,96,116.35a87.74,87.74,0,0,1-19-31,8,8,0,1,0-15.08,5.34A103.63,103.63,0,0,0,84,127a87.55,87.55,0,0,1-52,17,8,8,0,0,0,0,16,103.46,103.46,0,0,0,64-22.08,104.18,104.18,0,0,0,51.44,21.31l-26.6,53.19a8,8,0,0,0,14.31,7.16L148.94,192h70.11l13.79,27.58A8,8,0,0,0,240,224a8,8,0,0,0,7.15-11.58ZM156.94,176,184,121.89,211.05,176Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M160,129.89,175.06,160H144.94l6.36-12.7v0ZM224,48V208a16,16,0,0,1-16,16H48a16,16,0,0,1-16-16V48A16,16,0,0,1,48,32H208A16,16,0,0,1,224,48ZM207.16,188.42l-40-80a8,8,0,0,0-14.32,0L139.66,134.8a62.31,62.31,0,0,1-23.61-10A79.61,79.61,0,0,0,135.6,80H152a8,8,0,0,0,0-16H112V56a8,8,0,0,0-16,0v8H56a8,8,0,0,0,0,16h63.48a63.73,63.73,0,0,1-15.3,34.05,65.93,65.93,0,0,1-9-13.61,8,8,0,0,0-14.32,7.12,81.75,81.75,0,0,0,11.4,17.15A63.62,63.62,0,0,1,56,136a8,8,0,0,0,0,16,79.56,79.56,0,0,0,48.11-16.13,78.33,78.33,0,0,0,28.18,13.66l-19.45,38.89a8,8,0,0,0,14.32,7.16L136.94,176h46.12l9.78,19.58a8,8,0,1,0,14.32-7.16Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M245.37,213.32l-56-112a6,6,0,0,0-10.74,0l-22.3,44.6A90,90,0,0,1,105,127.19,101.73,101.73,0,0,0,133.82,62H160a6,6,0,0,0,0-12H102V32a6,6,0,0,0-12,0V50H32a6,6,0,0,0,0,12h89.79A89.71,89.71,0,0,1,96,119.23,89.81,89.81,0,0,1,75.11,86,6,6,0,1,0,63.8,90,101.66,101.66,0,0,0,87,127.2,89.56,89.56,0,0,1,32,146a6,6,0,0,0,0,12,101.55,101.55,0,0,0,64-22.63,102.11,102.11,0,0,0,54.53,22.17l-27.89,55.78a6,6,0,0,0,10.74,5.36L147.71,190h72.58l14.34,28.68A6,6,0,0,0,240,222a5.87,5.87,0,0,0,2.68-.64A6,6,0,0,0,245.37,213.32ZM153.71,178,184,117.42,214.29,178Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M247.15,212.42l-56-112a8,8,0,0,0-14.31,0l-21.71,43.43A88,88,0,0,1,108,126.93,103.65,103.65,0,0,0,135.69,64H160a8,8,0,0,0,0-16H104V32a8,8,0,0,0-16,0V48H32a8,8,0,0,0,0,16h87.63A87.76,87.76,0,0,1,96,116.35a87.74,87.74,0,0,1-19-31,8,8,0,1,0-15.08,5.34A103.63,103.63,0,0,0,84,127a87.55,87.55,0,0,1-52,17,8,8,0,0,0,0,16,103.46,103.46,0,0,0,64-22.08,104.18,104.18,0,0,0,51.44,21.31l-26.6,53.19a8,8,0,0,0,14.31,7.16L148.94,192h70.11l13.79,27.58A8,8,0,0,0,240,224a8,8,0,0,0,7.15-11.58ZM156.94,176,184,121.89,211.05,176Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M243.58,214.21l-56-112a4,4,0,0,0-7.16,0L157.55,148A92.05,92.05,0,0,1,102,127.36,99.68,99.68,0,0,0,131.91,60H160a4,4,0,0,0,0-8H100V32a4,4,0,0,0-8,0V52H32a4,4,0,0,0,0,8h91.91A91.8,91.8,0,0,1,96,122.05,92,92,0,0,1,73.23,86.67a4,4,0,1,0-7.54,2.66,99.59,99.59,0,0,0,24.3,38A91.59,91.59,0,0,1,32,148a4,4,0,0,0,0,8,99.54,99.54,0,0,0,64-23.21,100.09,100.09,0,0,0,57.66,23l-29.22,58.43a4,4,0,1,0,7.16,3.58L146.47,188h75.06l14.89,29.79A4,4,0,0,0,240,220a4.12,4.12,0,0,0,1.79-.42A4,4,0,0,0,243.58,214.21ZM150.47,180,184,112.94,217.53,180Z" }))
  ]
]), yq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M218.12,209.56l-61-95.8,59.72-65.69a12,12,0,0,0-17.76-16.14L143.81,92.77,106.12,33.56A12,12,0,0,0,96,28H48A12,12,0,0,0,37.88,46.44l61,95.8L39.12,207.93a12,12,0,1,0,17.76,16.14l55.31-60.84,37.69,59.21A12,12,0,0,0,160,228h48a12,12,0,0,0,10.12-18.44ZM166.59,204,69.86,52H89.41l96.73,152Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M208,216H160L48,40H96Z", opacity: "0.2" }), /* @__PURE__ */ H.createElement("path", { d: "M214.75,211.71l-62.6-98.38,61.77-67.95a8,8,0,0,0-11.84-10.76L143.24,99.34,102.75,35.71A8,8,0,0,0,96,32H48a8,8,0,0,0-6.75,12.3l62.6,98.37-61.77,68a8,8,0,1,0,11.84,10.76l58.84-64.72,40.49,63.63A8,8,0,0,0,160,224h48a8,8,0,0,0,6.75-12.29ZM164.39,208,62.57,48h29L193.43,208Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M215,219.85a8,8,0,0,1-7,4.15H160a8,8,0,0,1-6.75-3.71l-40.49-63.63L53.92,221.38a8,8,0,0,1-11.84-10.76l61.77-68L41.25,44.3A8,8,0,0,1,48,32H96a8,8,0,0,1,6.75,3.71l40.49,63.63,58.84-64.72a8,8,0,0,1,11.84,10.76l-61.77,67.95,62.6,98.38A8,8,0,0,1,215,219.85Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M213.06,212.78l-63.42-99.66L212.44,44A6,6,0,1,0,203.56,36L143,102.62l-41.9-65.84A6,6,0,0,0,96,34H48a6,6,0,0,0-5.06,9.22l63.42,99.66L43.56,212A6,6,0,0,0,52.44,220L113,153.38l41.9,65.84A6,6,0,0,0,160,222h48a6,6,0,0,0,5.06-9.22ZM163.29,210,58.93,46H92.71L197.07,210Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M214.75,211.71l-62.6-98.38,61.77-67.95a8,8,0,0,0-11.84-10.76L143.24,99.34,102.75,35.71A8,8,0,0,0,96,32H48a8,8,0,0,0-6.75,12.3l62.6,98.37-61.77,68a8,8,0,1,0,11.84,10.76l58.84-64.72,40.49,63.63A8,8,0,0,0,160,224h48a8,8,0,0,0,6.75-12.29ZM164.39,208,62.57,48h29L193.43,208Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M211.37,213.85,147.13,112.9,211,42.69A4,4,0,0,0,205,37.31L142.68,105.9,99.38,37.85A4,4,0,0,0,96,36H48a4,4,0,0,0-3.37,6.15L108.87,143.1,45,213.31A4,4,0,1,0,51,218.69l62.36-68.59,43.3,68.05A4,4,0,0,0,160,220h48a4,4,0,0,0,3.37-6.15ZM162.2,212,55.29,44H93.8L200.71,212Z" }))
  ]
]), Cq = /* @__PURE__ */ new Map([
  [
    "bold",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M170.49,117.91l-56-36A12,12,0,0,0,96,92v72a12,12,0,0,0,18.49,10.09l56-36a12,12,0,0,0,0-20.18ZM120,142V114l21.81,14Zm118.21-73.5a28.05,28.05,0,0,0-16.93-19.14C186.4,35.91,131.29,36,128,36s-58.4-.09-93.28,13.38A28.05,28.05,0,0,0,17.79,68.52C15.15,78.72,12,97.32,12,128s3.15,49.28,5.79,59.48a28.05,28.05,0,0,0,16.93,19.14C68.21,219.55,120.36,220,127.37,220h1.26c7,0,59.16-.45,92.65-13.38a28.05,28.05,0,0,0,16.93-19.14c2.64-10.2,5.79-28.8,5.79-59.48S240.85,78.72,238.21,68.52ZM215,181.46a4,4,0,0,1-2.34,2.77C182.78,195.76,132.27,196,128.32,196h-.39c-.53,0-53.64.17-84.56-11.77A4,4,0,0,1,41,181.46c-1.88-7.24-5-23.82-5-53.46s3.15-46.22,5-53.46a4,4,0,0,1,2.34-2.77C74.29,59.83,127.39,60,127.92,60h.15c.54,0,53.64-.17,84.56,11.77A4,4,0,0,1,215,74.54c1.88,7.24,5,23.82,5,53.46S216.85,174.22,215,181.46Z" }))
  ],
  [
    "duotone",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(
      "path",
      {
        d: "M226.59,71.53a16,16,0,0,0-9.63-11C183.48,47.65,128,48,128,48s-55.48-.35-89,12.58a16,16,0,0,0-9.63,11C27.07,80.54,24,98.09,24,128s3.07,47.46,5.41,56.47A16,16,0,0,0,39,195.42C72.52,208.35,128,208,128,208s55.48.35,89-12.58a16,16,0,0,0,9.63-10.95c2.34-9,5.41-26.56,5.41-56.47S228.93,80.54,226.59,71.53ZM112,160V96l48,32Z",
        opacity: "0.2"
      }
    ), /* @__PURE__ */ H.createElement("path", { d: "M164.44,121.34l-48-32A8,8,0,0,0,104,96v64a8,8,0,0,0,12.44,6.66l48-32a8,8,0,0,0,0-13.32ZM120,145.05V111l25.58,17ZM234.33,69.52a24,24,0,0,0-14.49-16.4C185.56,39.88,131,40,128,40s-57.56-.12-91.84,13.12a24,24,0,0,0-14.49,16.4C19.08,79.5,16,97.74,16,128s3.08,48.5,5.67,58.48a24,24,0,0,0,14.49,16.41C69,215.56,120.4,216,127.34,216h1.32c6.94,0,58.37-.44,91.18-13.11a24,24,0,0,0,14.49-16.41c2.59-10,5.67-28.22,5.67-58.48S236.92,79.5,234.33,69.52Zm-15.49,113a8,8,0,0,1-4.77,5.49c-31.65,12.22-85.48,12-86.12,12s-54.37.18-86-12a8,8,0,0,1-4.77-5.49C34.8,173.39,32,156.57,32,128s2.8-45.39,5.16-54.47A8,8,0,0,1,41.93,68C73.58,55.82,127.4,56,128.05,56s54.37-.18,86,12a8,8,0,0,1,4.77,5.49C221.2,82.61,224,99.43,224,128S221.2,173.39,218.84,182.47Z" }))
  ],
  [
    "fill",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M234.33,69.52a24,24,0,0,0-14.49-16.4C185.56,39.88,131,40,128,40s-57.56-.12-91.84,13.12a24,24,0,0,0-14.49,16.4C19.08,79.5,16,97.74,16,128s3.08,48.5,5.67,58.48a24,24,0,0,0,14.49,16.41C69,215.56,120.4,216,127.34,216h1.32c6.94,0,58.37-.44,91.18-13.11a24,24,0,0,0,14.49-16.41c2.59-10,5.67-28.22,5.67-58.48S236.92,79.5,234.33,69.52Zm-73.74,65-40,28A8,8,0,0,1,108,156V100a8,8,0,0,1,12.59-6.55l40,28a8,8,0,0,1,0,13.1Z" }))
  ],
  [
    "light",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M163.33,123l-48-32A6,6,0,0,0,106,96v64a6,6,0,0,0,9.33,5l48-32a6,6,0,0,0,0-10ZM118,148.79V107.21L149.18,128ZM232.4,70a22,22,0,0,0-13.28-15C185,41.79,130.27,42,128,42s-57-.21-91.16,13A22,22,0,0,0,23.6,70C21.05,79.89,18,98,18,128s3.05,48.11,5.6,58a22,22,0,0,0,13.28,15C71,214.21,125.72,214,128,214h.71c6.91,0,58-.44,90.45-13a22,22,0,0,0,13.28-15c2.55-9.87,5.6-27.93,5.6-58S235,79.89,232.4,70ZM220.78,183a10,10,0,0,1-6,6.86C182.78,202.19,128.58,202,128,202s-54.71.2-86.75-12.17a10,10,0,0,1-6-6.86C32.84,173.78,30,156.78,30,128s2.84-45.78,5.22-55a10,10,0,0,1,6-6.86C72.06,54.26,123.53,54,127.76,54H128c.54,0,54.71-.2,86.75,12.17a10,10,0,0,1,6,6.86c2.38,9.19,5.22,26.19,5.22,55S223.16,173.78,220.78,183Z" }))
  ],
  [
    "regular",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M164.44,121.34l-48-32A8,8,0,0,0,104,96v64a8,8,0,0,0,12.44,6.66l48-32a8,8,0,0,0,0-13.32ZM120,145.05V111l25.58,17ZM234.33,69.52a24,24,0,0,0-14.49-16.4C185.56,39.88,131,40,128,40s-57.56-.12-91.84,13.12a24,24,0,0,0-14.49,16.4C19.08,79.5,16,97.74,16,128s3.08,48.5,5.67,58.48a24,24,0,0,0,14.49,16.41C69,215.56,120.4,216,127.34,216h1.32c6.94,0,58.37-.44,91.18-13.11a24,24,0,0,0,14.49-16.41c2.59-10,5.67-28.22,5.67-58.48S236.92,79.5,234.33,69.52Zm-15.49,113a8,8,0,0,1-4.77,5.49c-31.65,12.22-85.48,12-86,12H128c-.54,0-54.33.2-86-12a8,8,0,0,1-4.77-5.49C34.8,173.39,32,156.57,32,128s2.8-45.39,5.16-54.47A8,8,0,0,1,41.93,68c30.52-11.79,81.66-12,85.85-12h.27c.54,0,54.38-.18,86,12a8,8,0,0,1,4.77,5.49C221.2,82.61,224,99.43,224,128S221.2,173.39,218.84,182.47Z" }))
  ],
  [
    "thin",
    /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement("path", { d: "M162.22,124.67l-48-32A4,4,0,0,0,108,96v64a4,4,0,0,0,2.11,3.53,4,4,0,0,0,4.11-.2l48-32a4,4,0,0,0,0-6.66ZM116,152.53V103.47L152.79,128Zm114.46-82A20,20,0,0,0,218.4,56.85C184.6,43.79,130.27,44,128,44S71.4,43.79,37.6,56.85A20,20,0,0,0,25.54,70.52C23,80.27,20,98.16,20,128s3,47.73,5.54,57.48A20,20,0,0,0,37.6,199.15C71.4,212.21,125.73,212,128,212h.71c6.89,0,57.58-.43,89.72-12.85a20,20,0,0,0,12.06-13.67C233,175.72,236,157.84,236,128S233,80.27,230.46,70.52Zm-7.74,113a12,12,0,0,1-7.21,8.22C183.14,204.19,128.57,204,128,204s-55.11.19-87.48-12.31a12,12,0,0,1-7.21-8.22C30.87,174.17,28,157,28,128s2.87-46.17,5.28-55.47a12,12,0,0,1,7.21-8.22C72.86,51.81,127.43,52,128,52s55.11-.2,87.48,12.31a12,12,0,0,1,7.21,8.22C225.13,81.83,228,99,228,128S225.13,174.17,222.72,183.47Z" }))
  ]
]), Sq = Xl({
  color: "currentColor",
  size: "1em",
  weight: "regular",
  mirrored: !1
});
var wq = Object.defineProperty, w0 = Object.getOwnPropertySymbols, cH = Object.prototype.hasOwnProperty, dH = Object.prototype.propertyIsEnumerable, eI = (e, t, r) => t in e ? wq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, tI = (e, t) => {
  for (var r in t || (t = {}))
    cH.call(t, r) && eI(e, r, t[r]);
  if (w0)
    for (var r of w0(t))
      dH.call(t, r) && eI(e, r, t[r]);
  return e;
}, rI = (e, t) => {
  var r = {};
  for (var n in e)
    cH.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && w0)
    for (var n of w0(e))
      t.indexOf(n) < 0 && dH.call(e, n) && (r[n] = e[n]);
  return r;
};
const hH = fn((e, t) => {
  const r = e, {
    alt: n,
    color: i,
    size: o,
    weight: a,
    mirrored: s,
    children: l,
    weights: u
  } = r, c = rI(r, [
    "alt",
    "color",
    "size",
    "weight",
    "mirrored",
    "children",
    "weights"
  ]), d = rr(Sq), {
    color: h = "currentColor",
    size: f,
    weight: p = "regular",
    mirrored: g = !1
  } = d, v = rI(d, [
    "color",
    "size",
    "weight",
    "mirrored"
  ]);
  return /* @__PURE__ */ H.createElement(
    "svg",
    tI(tI({
      ref: t,
      xmlns: "http://www.w3.org/2000/svg",
      width: o ?? f,
      height: o ?? f,
      fill: i ?? h,
      viewBox: "0 0 256 256",
      transform: s || g ? "scale(-1, 1)" : void 0
    }, v), c),
    !!n && /* @__PURE__ */ H.createElement("title", null, n),
    l,
    u.get(a ?? p)
  );
});
hH.displayName = "IconBase";
const rs = hH;
var bq = Object.defineProperty, xq = Object.defineProperties, Eq = Object.getOwnPropertyDescriptors, nI = Object.getOwnPropertySymbols, Rq = Object.prototype.hasOwnProperty, _q = Object.prototype.propertyIsEnumerable, iI = (e, t, r) => t in e ? bq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Tq = (e, t) => {
  for (var r in t || (t = {}))
    Rq.call(t, r) && iI(e, r, t[r]);
  if (nI)
    for (var r of nI(t))
      _q.call(t, r) && iI(e, r, t[r]);
  return e;
}, Pq = (e, t) => xq(e, Eq(t));
const fH = fn((e, t) => /* @__PURE__ */ H.createElement(rs, Pq(Tq({ ref: t }, e), { weights: cq })));
fH.displayName = "ArrowClockwise";
var Mq = Object.defineProperty, Dq = Object.defineProperties, Aq = Object.getOwnPropertyDescriptors, oI = Object.getOwnPropertySymbols, Iq = Object.prototype.hasOwnProperty, Fq = Object.prototype.propertyIsEnumerable, aI = (e, t, r) => t in e ? Mq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Lq = (e, t) => {
  for (var r in t || (t = {}))
    Iq.call(t, r) && aI(e, r, t[r]);
  if (oI)
    for (var r of oI(t))
      Fq.call(t, r) && aI(e, r, t[r]);
  return e;
}, Oq = (e, t) => Dq(e, Aq(t));
const pH = fn((e, t) => /* @__PURE__ */ H.createElement(rs, Oq(Lq({ ref: t }, e), { weights: dq })));
pH.displayName = "CheckCircle";
var Nq = Object.defineProperty, kq = Object.defineProperties, Vq = Object.getOwnPropertyDescriptors, sI = Object.getOwnPropertySymbols, Bq = Object.prototype.hasOwnProperty, Gq = Object.prototype.propertyIsEnumerable, lI = (e, t, r) => t in e ? Nq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Hq = (e, t) => {
  for (var r in t || (t = {}))
    Bq.call(t, r) && lI(e, r, t[r]);
  if (sI)
    for (var r of sI(t))
      Gq.call(t, r) && lI(e, r, t[r]);
  return e;
}, zq = (e, t) => kq(e, Vq(t));
const gH = fn((e, t) => /* @__PURE__ */ H.createElement(rs, zq(Hq({ ref: t }, e), { weights: hq })));
gH.displayName = "Clipboard";
var $q = Object.defineProperty, Wq = Object.defineProperties, jq = Object.getOwnPropertyDescriptors, uI = Object.getOwnPropertySymbols, Uq = Object.prototype.hasOwnProperty, Kq = Object.prototype.propertyIsEnumerable, cI = (e, t, r) => t in e ? $q(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, Yq = (e, t) => {
  for (var r in t || (t = {}))
    Uq.call(t, r) && cI(e, r, t[r]);
  if (uI)
    for (var r of uI(t))
      Kq.call(t, r) && cI(e, r, t[r]);
  return e;
}, qq = (e, t) => Wq(e, jq(t));
const vH = fn((e, t) => /* @__PURE__ */ H.createElement(rs, qq(Yq({ ref: t }, e), { weights: fq })));
vH.displayName = "Download";
var Zq = Object.defineProperty, Xq = Object.defineProperties, Qq = Object.getOwnPropertyDescriptors, dI = Object.getOwnPropertySymbols, Jq = Object.prototype.hasOwnProperty, eZ = Object.prototype.propertyIsEnumerable, hI = (e, t, r) => t in e ? Zq(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, tZ = (e, t) => {
  for (var r in t || (t = {}))
    Jq.call(t, r) && hI(e, r, t[r]);
  if (dI)
    for (var r of dI(t))
      eZ.call(t, r) && hI(e, r, t[r]);
  return e;
}, rZ = (e, t) => Xq(e, Qq(t));
const mH = fn((e, t) => /* @__PURE__ */ H.createElement(rs, rZ(tZ({ ref: t }, e), { weights: pq })));
mH.displayName = "GlobeHemisphereWest";
var nZ = Object.defineProperty, iZ = Object.defineProperties, oZ = Object.getOwnPropertyDescriptors, fI = Object.getOwnPropertySymbols, aZ = Object.prototype.hasOwnProperty, sZ = Object.prototype.propertyIsEnumerable, pI = (e, t, r) => t in e ? nZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, lZ = (e, t) => {
  for (var r in t || (t = {}))
    aZ.call(t, r) && pI(e, r, t[r]);
  if (fI)
    for (var r of fI(t))
      sZ.call(t, r) && pI(e, r, t[r]);
  return e;
}, uZ = (e, t) => iZ(e, oZ(t));
const yH = fn((e, t) => /* @__PURE__ */ H.createElement(rs, uZ(lZ({ ref: t }, e), { weights: gq })));
yH.displayName = "LinkedinLogo";
var cZ = Object.defineProperty, dZ = Object.defineProperties, hZ = Object.getOwnPropertyDescriptors, gI = Object.getOwnPropertySymbols, fZ = Object.prototype.hasOwnProperty, pZ = Object.prototype.propertyIsEnumerable, vI = (e, t, r) => t in e ? cZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, gZ = (e, t) => {
  for (var r in t || (t = {}))
    fZ.call(t, r) && vI(e, r, t[r]);
  if (gI)
    for (var r of gI(t))
      pZ.call(t, r) && vI(e, r, t[r]);
  return e;
}, vZ = (e, t) => dZ(e, hZ(t));
const VT = fn((e, t) => /* @__PURE__ */ H.createElement(rs, vZ(gZ({ ref: t }, e), { weights: vq })));
VT.displayName = "PaperPlaneTilt";
var mZ = Object.defineProperty, yZ = Object.defineProperties, CZ = Object.getOwnPropertyDescriptors, mI = Object.getOwnPropertySymbols, SZ = Object.prototype.hasOwnProperty, wZ = Object.prototype.propertyIsEnumerable, yI = (e, t, r) => t in e ? mZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, bZ = (e, t) => {
  for (var r in t || (t = {}))
    SZ.call(t, r) && yI(e, r, t[r]);
  if (mI)
    for (var r of mI(t))
      wZ.call(t, r) && yI(e, r, t[r]);
  return e;
}, xZ = (e, t) => yZ(e, CZ(t));
const CH = fn((e, t) => /* @__PURE__ */ H.createElement(rs, xZ(bZ({ ref: t }, e), { weights: mq })));
CH.displayName = "Translate";
var EZ = Object.defineProperty, RZ = Object.defineProperties, _Z = Object.getOwnPropertyDescriptors, CI = Object.getOwnPropertySymbols, TZ = Object.prototype.hasOwnProperty, PZ = Object.prototype.propertyIsEnumerable, SI = (e, t, r) => t in e ? EZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, MZ = (e, t) => {
  for (var r in t || (t = {}))
    TZ.call(t, r) && SI(e, r, t[r]);
  if (CI)
    for (var r of CI(t))
      PZ.call(t, r) && SI(e, r, t[r]);
  return e;
}, DZ = (e, t) => RZ(e, _Z(t));
const SH = fn((e, t) => /* @__PURE__ */ H.createElement(rs, DZ(MZ({ ref: t }, e), { weights: yq })));
SH.displayName = "XLogo";
var AZ = Object.defineProperty, IZ = Object.defineProperties, FZ = Object.getOwnPropertyDescriptors, wI = Object.getOwnPropertySymbols, LZ = Object.prototype.hasOwnProperty, OZ = Object.prototype.propertyIsEnumerable, bI = (e, t, r) => t in e ? AZ(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r, NZ = (e, t) => {
  for (var r in t || (t = {}))
    LZ.call(t, r) && bI(e, r, t[r]);
  if (wI)
    for (var r of wI(t))
      OZ.call(t, r) && bI(e, r, t[r]);
  return e;
}, kZ = (e, t) => IZ(e, FZ(t));
const wH = fn((e, t) => /* @__PURE__ */ H.createElement(rs, kZ(NZ({ ref: t }, e), { weights: Cq })));
wH.displayName = "YoutubeLogo";
var bH = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(e) {
  (function() {
    var t = {}.hasOwnProperty;
    function r() {
      for (var o = "", a = 0; a < arguments.length; a++) {
        var s = arguments[a];
        s && (o = i(o, n(s)));
      }
      return o;
    }
    function n(o) {
      if (typeof o == "string" || typeof o == "number")
        return o;
      if (typeof o != "object")
        return "";
      if (Array.isArray(o))
        return r.apply(null, o);
      if (o.toString !== Object.prototype.toString && !o.toString.toString().includes("[native code]"))
        return o.toString();
      var a = "";
      for (var s in o)
        t.call(o, s) && o[s] && (a = i(a, s));
      return a;
    }
    function i(o, a) {
      return a ? o ? o + " " + a : o + a : o;
    }
    e.exports ? (r.default = r, e.exports = r) : window.classNames = r;
  })();
})(bH);
var VZ = bH.exports;
const pe = /* @__PURE__ */ Uh(VZ);
function ze() {
  return ze = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var n in r) ({}).hasOwnProperty.call(r, n) && (e[n] = r[n]);
    }
    return e;
  }, ze.apply(null, arguments);
}
var hE = { exports: {} }, mr = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xI;
function BZ() {
  if (xI) return mr;
  xI = 1;
  var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), s = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), p;
  p = Symbol.for("react.module.reference");
  function g(v) {
    if (typeof v == "object" && v !== null) {
      var m = v.$$typeof;
      switch (m) {
        case e:
          switch (v = v.type, v) {
            case r:
            case i:
            case n:
            case u:
            case c:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case s:
                case a:
                case l:
                case h:
                case d:
                case o:
                  return v;
                default:
                  return m;
              }
          }
        case t:
          return m;
      }
    }
  }
  return mr.ContextConsumer = a, mr.ContextProvider = o, mr.Element = e, mr.ForwardRef = l, mr.Fragment = r, mr.Lazy = h, mr.Memo = d, mr.Portal = t, mr.Profiler = i, mr.StrictMode = n, mr.Suspense = u, mr.SuspenseList = c, mr.isAsyncMode = function() {
    return !1;
  }, mr.isConcurrentMode = function() {
    return !1;
  }, mr.isContextConsumer = function(v) {
    return g(v) === a;
  }, mr.isContextProvider = function(v) {
    return g(v) === o;
  }, mr.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === e;
  }, mr.isForwardRef = function(v) {
    return g(v) === l;
  }, mr.isFragment = function(v) {
    return g(v) === r;
  }, mr.isLazy = function(v) {
    return g(v) === h;
  }, mr.isMemo = function(v) {
    return g(v) === d;
  }, mr.isPortal = function(v) {
    return g(v) === t;
  }, mr.isProfiler = function(v) {
    return g(v) === i;
  }, mr.isStrictMode = function(v) {
    return g(v) === n;
  }, mr.isSuspense = function(v) {
    return g(v) === u;
  }, mr.isSuspenseList = function(v) {
    return g(v) === c;
  }, mr.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === i || v === n || v === u || v === c || v === f || typeof v == "object" && v !== null && (v.$$typeof === h || v.$$typeof === d || v.$$typeof === o || v.$$typeof === a || v.$$typeof === l || v.$$typeof === p || v.getModuleId !== void 0);
  }, mr.typeOf = g, mr;
}
var yr = {};
/**
 * @license React
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EI;
function GZ() {
  return EI || (EI = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Symbol.for("react.element"), t = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), n = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), o = Symbol.for("react.provider"), a = Symbol.for("react.context"), s = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), h = Symbol.for("react.lazy"), f = Symbol.for("react.offscreen"), p = !1, g = !1, v = !1, m = !1, y = !1, C;
    C = Symbol.for("react.module.reference");
    function S(K) {
      return !!(typeof K == "string" || typeof K == "function" || K === r || K === i || y || K === n || K === u || K === c || m || K === f || p || g || v || typeof K == "object" && K !== null && (K.$$typeof === h || K.$$typeof === d || K.$$typeof === o || K.$$typeof === a || K.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      K.$$typeof === C || K.getModuleId !== void 0));
    }
    function b(K) {
      if (typeof K == "object" && K !== null) {
        var ie = K.$$typeof;
        switch (ie) {
          case e:
            var Ce = K.type;
            switch (Ce) {
              case r:
              case i:
              case n:
              case u:
              case c:
                return Ce;
              default:
                var Te = Ce && Ce.$$typeof;
                switch (Te) {
                  case s:
                  case a:
                  case l:
                  case h:
                  case d:
                  case o:
                    return Te;
                  default:
                    return ie;
                }
            }
          case t:
            return ie;
        }
      }
    }
    var w = a, x = o, E = e, R = l, _ = r, P = h, D = d, I = t, A = i, O = n, L = u, N = c, F = !1, G = !1;
    function M(K) {
      return F || (F = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function V(K) {
      return G || (G = !0, console.warn("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.")), !1;
    }
    function z(K) {
      return b(K) === a;
    }
    function k(K) {
      return b(K) === o;
    }
    function $(K) {
      return typeof K == "object" && K !== null && K.$$typeof === e;
    }
    function W(K) {
      return b(K) === l;
    }
    function j(K) {
      return b(K) === r;
    }
    function U(K) {
      return b(K) === h;
    }
    function Z(K) {
      return b(K) === d;
    }
    function ee(K) {
      return b(K) === t;
    }
    function J(K) {
      return b(K) === i;
    }
    function X(K) {
      return b(K) === n;
    }
    function Y(K) {
      return b(K) === u;
    }
    function de(K) {
      return b(K) === c;
    }
    yr.ContextConsumer = w, yr.ContextProvider = x, yr.Element = E, yr.ForwardRef = R, yr.Fragment = _, yr.Lazy = P, yr.Memo = D, yr.Portal = I, yr.Profiler = A, yr.StrictMode = O, yr.Suspense = L, yr.SuspenseList = N, yr.isAsyncMode = M, yr.isConcurrentMode = V, yr.isContextConsumer = z, yr.isContextProvider = k, yr.isElement = $, yr.isForwardRef = W, yr.isFragment = j, yr.isLazy = U, yr.isMemo = Z, yr.isPortal = ee, yr.isProfiler = J, yr.isStrictMode = X, yr.isSuspense = Y, yr.isSuspenseList = de, yr.isValidElementType = S, yr.typeOf = b;
  }()), yr;
}
process.env.NODE_ENV === "production" ? hE.exports = BZ() : hE.exports = GZ();
var Bp = hE.exports;
function Gl(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = [];
  return H.Children.forEach(e, function(n) {
    n == null && !t.keepEmpty || (Array.isArray(n) ? r = r.concat(Gl(n)) : Bp.isFragment(n) && n.props ? r = r.concat(Gl(n.props.children, t)) : r.push(n));
  }), r;
}
var fE = {}, BT = [], HZ = function(t) {
  BT.push(t);
};
function Ns(e, t) {
  if (process.env.NODE_ENV !== "production" && !e && console !== void 0) {
    var r = BT.reduce(function(n, i) {
      return i(n ?? "", "warning");
    }, t);
    r && console.error("Warning: ".concat(r));
  }
}
function zZ(e, t) {
  if (process.env.NODE_ENV !== "production" && !e && console !== void 0) {
    var r = BT.reduce(function(n, i) {
      return i(n ?? "", "note");
    }, t);
    r && console.warn("Note: ".concat(r));
  }
}
function xH() {
  fE = {};
}
function EH(e, t, r) {
  !t && !fE[r] && (e(!1, r), fE[r] = !0);
}
function gr(e, t) {
  EH(Ns, e, t);
}
function $Z(e, t) {
  EH(zZ, e, t);
}
gr.preMessage = HZ;
gr.resetWarned = xH;
gr.noteOnce = $Z;
function xt(e) {
  "@babel/helpers - typeof";
  return xt = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xt(e);
}
function WZ(e, t) {
  if (xt(e) != "object" || !e) return e;
  var r = e[Symbol.toPrimitive];
  if (r !== void 0) {
    var n = r.call(e, t || "default");
    if (xt(n) != "object") return n;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function RH(e) {
  var t = WZ(e, "string");
  return xt(t) == "symbol" ? t : t + "";
}
function te(e, t, r) {
  return (t = RH(t)) in e ? Object.defineProperty(e, t, {
    value: r,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = r, e;
}
function RI(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t && (n = n.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), r.push.apply(r, n);
  }
  return r;
}
function re(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RI(Object(r), !0).forEach(function(n) {
      te(e, n, r[n]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r)) : RI(Object(r)).forEach(function(n) {
      Object.defineProperty(e, n, Object.getOwnPropertyDescriptor(r, n));
    });
  }
  return e;
}
function pg(e) {
  return e instanceof HTMLElement || e instanceof SVGElement;
}
function jZ(e) {
  return e && xt(e) === "object" && pg(e.nativeElement) ? e.nativeElement : pg(e) ? e : null;
}
function ky(e) {
  var t = jZ(e);
  if (t)
    return t;
  if (e instanceof H.Component) {
    var r;
    return (r = Ec.findDOMNode) === null || r === void 0 ? void 0 : r.call(Ec, e);
  }
  return null;
}
function qC(e, t, r) {
  var n = T.useRef({});
  return (!("value" in n.current) || r(n.current.condition, t)) && (n.current.value = e(), n.current.condition = t), n.current.value;
}
var GT = function(t, r) {
  typeof t == "function" ? t(r) : xt(t) === "object" && t && "current" in t && (t.current = r);
}, Vo = function() {
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  var i = r.filter(Boolean);
  return i.length <= 1 ? i[0] : function(o) {
    r.forEach(function(a) {
      GT(a, o);
    });
  };
}, Kh = function() {
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  return qC(function() {
    return Vo.apply(void 0, r);
  }, r, function(i, o) {
    return i.length !== o.length || i.every(function(a, s) {
      return a !== o[s];
    });
  });
}, kc = function(t) {
  var r, n, i = Bp.isMemo(t) ? t.type.type : t.type;
  return !(typeof i == "function" && !((r = i.prototype) !== null && r !== void 0 && r.render) && i.$$typeof !== Bp.ForwardRef || typeof t == "function" && !((n = t.prototype) !== null && n !== void 0 && n.render) && t.$$typeof !== Bp.ForwardRef);
};
function _I(e) {
  return /* @__PURE__ */ XY(e) && !Bp.isFragment(e);
}
Number(ZY.split(".")[0]) >= 19;
var pE = /* @__PURE__ */ T.createContext(null);
function UZ(e) {
  var t = e.children, r = e.onBatchResize, n = T.useRef(0), i = T.useRef([]), o = T.useContext(pE), a = T.useCallback(function(s, l, u) {
    n.current += 1;
    var c = n.current;
    i.current.push({
      size: s,
      element: l,
      data: u
    }), Promise.resolve().then(function() {
      c === n.current && (r == null || r(i.current), i.current = []);
    }), o == null || o(s, l, u);
  }, [r, o]);
  return /* @__PURE__ */ T.createElement(pE.Provider, {
    value: a
  }, t);
}
var _H = function() {
  if (typeof Map < "u")
    return Map;
  function e(t, r) {
    var n = -1;
    return t.some(function(i, o) {
      return i[0] === r ? (n = o, !0) : !1;
    }), n;
  }
  return (
    /** @class */
    function() {
      function t() {
        this.__entries__ = [];
      }
      return Object.defineProperty(t.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.get = function(r) {
        var n = e(this.__entries__, r), i = this.__entries__[n];
        return i && i[1];
      }, t.prototype.set = function(r, n) {
        var i = e(this.__entries__, r);
        ~i ? this.__entries__[i][1] = n : this.__entries__.push([r, n]);
      }, t.prototype.delete = function(r) {
        var n = this.__entries__, i = e(n, r);
        ~i && n.splice(i, 1);
      }, t.prototype.has = function(r) {
        return !!~e(this.__entries__, r);
      }, t.prototype.clear = function() {
        this.__entries__.splice(0);
      }, t.prototype.forEach = function(r, n) {
        n === void 0 && (n = null);
        for (var i = 0, o = this.__entries__; i < o.length; i++) {
          var a = o[i];
          r.call(n, a[1], a[0]);
        }
      }, t;
    }()
  );
}(), gE = typeof window < "u" && typeof document < "u" && window.document === document, b0 = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), KZ = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(b0) : function(e) {
    return setTimeout(function() {
      return e(Date.now());
    }, 1e3 / 60);
  };
}(), YZ = 2;
function qZ(e, t) {
  var r = !1, n = !1, i = 0;
  function o() {
    r && (r = !1, e()), n && s();
  }
  function a() {
    KZ(o);
  }
  function s() {
    var l = Date.now();
    if (r) {
      if (l - i < YZ)
        return;
      n = !0;
    } else
      r = !0, n = !1, setTimeout(a, t);
    i = l;
  }
  return s;
}
var ZZ = 20, XZ = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], QZ = typeof MutationObserver < "u", JZ = (
  /** @class */
  function() {
    function e() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = qZ(this.refresh.bind(this), ZZ);
    }
    return e.prototype.addObserver = function(t) {
      ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
    }, e.prototype.removeObserver = function(t) {
      var r = this.observers_, n = r.indexOf(t);
      ~n && r.splice(n, 1), !r.length && this.connected_ && this.disconnect_();
    }, e.prototype.refresh = function() {
      var t = this.updateObservers_();
      t && this.refresh();
    }, e.prototype.updateObservers_ = function() {
      var t = this.observers_.filter(function(r) {
        return r.gatherActive(), r.hasActive();
      });
      return t.forEach(function(r) {
        return r.broadcastActive();
      }), t.length > 0;
    }, e.prototype.connect_ = function() {
      !gE || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), QZ ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, e.prototype.disconnect_ = function() {
      !gE || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, e.prototype.onTransitionEnd_ = function(t) {
      var r = t.propertyName, n = r === void 0 ? "" : r, i = XZ.some(function(o) {
        return !!~n.indexOf(o);
      });
      i && this.refresh();
    }, e.getInstance = function() {
      return this.instance_ || (this.instance_ = new e()), this.instance_;
    }, e.instance_ = null, e;
  }()
), TH = function(e, t) {
  for (var r = 0, n = Object.keys(t); r < n.length; r++) {
    var i = n[r];
    Object.defineProperty(e, i, {
      value: t[i],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return e;
}, bh = function(e) {
  var t = e && e.ownerDocument && e.ownerDocument.defaultView;
  return t || b0;
}, PH = ZC(0, 0, 0, 0);
function x0(e) {
  return parseFloat(e) || 0;
}
function TI(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  return t.reduce(function(n, i) {
    var o = e["border-" + i + "-width"];
    return n + x0(o);
  }, 0);
}
function eX(e) {
  for (var t = ["top", "right", "bottom", "left"], r = {}, n = 0, i = t; n < i.length; n++) {
    var o = i[n], a = e["padding-" + o];
    r[o] = x0(a);
  }
  return r;
}
function tX(e) {
  var t = e.getBBox();
  return ZC(0, 0, t.width, t.height);
}
function rX(e) {
  var t = e.clientWidth, r = e.clientHeight;
  if (!t && !r)
    return PH;
  var n = bh(e).getComputedStyle(e), i = eX(n), o = i.left + i.right, a = i.top + i.bottom, s = x0(n.width), l = x0(n.height);
  if (n.boxSizing === "border-box" && (Math.round(s + o) !== t && (s -= TI(n, "left", "right") + o), Math.round(l + a) !== r && (l -= TI(n, "top", "bottom") + a)), !iX(e)) {
    var u = Math.round(s + o) - t, c = Math.round(l + a) - r;
    Math.abs(u) !== 1 && (s -= u), Math.abs(c) !== 1 && (l -= c);
  }
  return ZC(i.left, i.top, s, l);
}
var nX = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(e) {
    return e instanceof bh(e).SVGGraphicsElement;
  } : function(e) {
    return e instanceof bh(e).SVGElement && typeof e.getBBox == "function";
  };
}();
function iX(e) {
  return e === bh(e).document.documentElement;
}
function oX(e) {
  return gE ? nX(e) ? tX(e) : rX(e) : PH;
}
function aX(e) {
  var t = e.x, r = e.y, n = e.width, i = e.height, o = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, a = Object.create(o.prototype);
  return TH(a, {
    x: t,
    y: r,
    width: n,
    height: i,
    top: r,
    right: t + n,
    bottom: i + r,
    left: t
  }), a;
}
function ZC(e, t, r, n) {
  return { x: e, y: t, width: r, height: n };
}
var sX = (
  /** @class */
  function() {
    function e(t) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = ZC(0, 0, 0, 0), this.target = t;
    }
    return e.prototype.isActive = function() {
      var t = oX(this.target);
      return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
    }, e.prototype.broadcastRect = function() {
      var t = this.contentRect_;
      return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
    }, e;
  }()
), lX = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, r) {
      var n = aX(r);
      TH(this, { target: t, contentRect: n });
    }
    return e;
  }()
), uX = (
  /** @class */
  function() {
    function e(t, r, n) {
      if (this.activeObservations_ = [], this.observations_ = new _H(), typeof t != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = t, this.controller_ = r, this.callbackCtx_ = n;
    }
    return e.prototype.observe = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof bh(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(t) || (r.set(t, new sX(t)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, e.prototype.unobserve = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof bh(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var r = this.observations_;
        r.has(t) && (r.delete(t), r.size || this.controller_.removeObserver(this));
      }
    }, e.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, e.prototype.gatherActive = function() {
      var t = this;
      this.clearActive(), this.observations_.forEach(function(r) {
        r.isActive() && t.activeObservations_.push(r);
      });
    }, e.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var t = this.callbackCtx_, r = this.activeObservations_.map(function(n) {
          return new lX(n.target, n.broadcastRect());
        });
        this.callback_.call(t, r, t), this.clearActive();
      }
    }, e.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, e.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, e;
  }()
), MH = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new _H(), DH = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      if (!(this instanceof e))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var r = JZ.getInstance(), n = new uX(t, r, this);
      MH.set(this, n);
    }
    return e;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(e) {
  DH.prototype[e] = function() {
    var t;
    return (t = MH.get(this))[e].apply(t, arguments);
  };
});
var cX = function() {
  return typeof b0.ResizeObserver < "u" ? b0.ResizeObserver : DH;
}(), xs = /* @__PURE__ */ new Map();
function AH(e) {
  e.forEach(function(t) {
    var r, n = t.target;
    (r = xs.get(n)) === null || r === void 0 || r.forEach(function(i) {
      return i(n);
    });
  });
}
var IH = new cX(AH);
process.env.NODE_ENV;
process.env.NODE_ENV;
function dX(e, t) {
  xs.has(e) || (xs.set(e, /* @__PURE__ */ new Set()), IH.observe(e)), xs.get(e).add(t);
}
function hX(e, t) {
  xs.has(e) && (xs.get(e).delete(t), xs.get(e).size || (IH.unobserve(e), xs.delete(e)));
}
function Hn(e, t) {
  if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
}
function PI(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, RH(n.key), n);
  }
}
function zn(e, t, r) {
  return t && PI(e.prototype, t), r && PI(e, r), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}
function gg(e, t) {
  return gg = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(r, n) {
    return r.__proto__ = n, r;
  }, gg(e, t);
}
function Ql(e, t) {
  if (typeof t != "function" && t !== null) throw new TypeError("Super expression must either be null or a function");
  e.prototype = Object.create(t && t.prototype, {
    constructor: {
      value: e,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(e, "prototype", {
    writable: !1
  }), t && gg(e, t);
}
function vg(e) {
  return vg = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, vg(e);
}
function HT() {
  try {
    var e = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (HT = function() {
    return !!e;
  })();
}
function qt(e) {
  if (e === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}
function fX(e, t) {
  if (t && (xt(t) == "object" || typeof t == "function")) return t;
  if (t !== void 0) throw new TypeError("Derived constructors may only return object or undefined");
  return qt(e);
}
function Jl(e) {
  var t = HT();
  return function() {
    var r, n = vg(e);
    if (t) {
      var i = vg(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else r = n.apply(this, arguments);
    return fX(this, r);
  };
}
var pX = /* @__PURE__ */ function(e) {
  Ql(r, e);
  var t = Jl(r);
  function r() {
    return Hn(this, r), t.apply(this, arguments);
  }
  return zn(r, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), r;
}(T.Component);
function gX(e, t) {
  var r = e.children, n = e.disabled, i = T.useRef(null), o = T.useRef(null), a = T.useContext(pE), s = typeof r == "function", l = s ? r(i) : r, u = T.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  }), c = !s && /* @__PURE__ */ T.isValidElement(l) && kc(l), d = c ? l.ref : null, h = Kh(d, i), f = function() {
    var m;
    return ky(i.current) || // Support `nativeElement` format
    (i.current && xt(i.current) === "object" ? ky((m = i.current) === null || m === void 0 ? void 0 : m.nativeElement) : null) || ky(o.current);
  };
  T.useImperativeHandle(t, function() {
    return f();
  });
  var p = T.useRef(e);
  p.current = e;
  var g = T.useCallback(function(v) {
    var m = p.current, y = m.onResize, C = m.data, S = v.getBoundingClientRect(), b = S.width, w = S.height, x = v.offsetWidth, E = v.offsetHeight, R = Math.floor(b), _ = Math.floor(w);
    if (u.current.width !== R || u.current.height !== _ || u.current.offsetWidth !== x || u.current.offsetHeight !== E) {
      var P = {
        width: R,
        height: _,
        offsetWidth: x,
        offsetHeight: E
      };
      u.current = P;
      var D = x === Math.round(b) ? b : x, I = E === Math.round(w) ? w : E, A = re(re({}, P), {}, {
        offsetWidth: D,
        offsetHeight: I
      });
      a == null || a(A, v, C), y && Promise.resolve().then(function() {
        y(A, v);
      });
    }
  }, []);
  return T.useEffect(function() {
    var v = f();
    return v && !n && dX(v, g), function() {
      return hX(v, g);
    };
  }, [i.current, n]), /* @__PURE__ */ T.createElement(pX, {
    ref: o
  }, c ? /* @__PURE__ */ T.cloneElement(l, {
    ref: h
  }) : l);
}
var FH = /* @__PURE__ */ T.forwardRef(gX);
process.env.NODE_ENV !== "production" && (FH.displayName = "SingleObserver");
var vX = "rc-observer-key";
function mX(e, t) {
  var r = e.children, n = typeof r == "function" ? [r] : Gl(r);
  return process.env.NODE_ENV !== "production" && (n.length > 1 ? Ns(!1, "Find more than one child node with `children` in ResizeObserver. Please use ResizeObserver.Collection instead.") : n.length === 0 && Ns(!1, "`children` of ResizeObserver is empty. Nothing is in observe.")), n.map(function(i, o) {
    var a = (i == null ? void 0 : i.key) || "".concat(vX, "-").concat(o);
    return /* @__PURE__ */ T.createElement(FH, ze({}, e, {
      key: a,
      ref: o === 0 ? t : void 0
    }), i);
  });
}
var la = /* @__PURE__ */ T.forwardRef(mX);
process.env.NODE_ENV !== "production" && (la.displayName = "ResizeObserver");
la.Collection = UZ;
function Bi(e, t) {
  var r = Object.assign({}, e);
  return Array.isArray(t) && t.forEach(function(n) {
    delete r[n];
  }), r;
}
function vE(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var r = 0, n = Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function yX(e) {
  if (Array.isArray(e)) return vE(e);
}
function LH(e) {
  if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e);
}
function zT(e, t) {
  if (e) {
    if (typeof e == "string") return vE(e, t);
    var r = {}.toString.call(e).slice(8, -1);
    return r === "Object" && e.constructor && (r = e.constructor.name), r === "Map" || r === "Set" ? Array.from(e) : r === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? vE(e, t) : void 0;
  }
}
function CX() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function rt(e) {
  return yX(e) || LH(e) || zT(e) || CX();
}
var OH = function(t) {
  return +setTimeout(t, 16);
}, NH = function(t) {
  return clearTimeout(t);
};
typeof window < "u" && "requestAnimationFrame" in window && (OH = function(t) {
  return window.requestAnimationFrame(t);
}, NH = function(t) {
  return window.cancelAnimationFrame(t);
});
var MI = 0, XC = /* @__PURE__ */ new Map();
function kH(e) {
  XC.delete(e);
}
var cn = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  MI += 1;
  var n = MI;
  function i(o) {
    if (o === 0)
      kH(n), t();
    else {
      var a = OH(function() {
        i(o - 1);
      });
      XC.set(n, a);
    }
  }
  return i(r), n;
};
cn.cancel = function(e) {
  var t = XC.get(e);
  return kH(e), NH(t);
};
process.env.NODE_ENV !== "production" && (cn.ids = function() {
  return XC;
});
function VH(e) {
  if (Array.isArray(e)) return e;
}
function SX(e, t) {
  var r = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (r != null) {
    var n, i, o, a, s = [], l = !0, u = !1;
    try {
      if (o = (r = r.call(e)).next, t === 0) {
        if (Object(r) !== r) return;
        l = !1;
      } else for (; !(l = (n = o.call(r)).done) && (s.push(n.value), s.length !== t); l = !0) ;
    } catch (c) {
      u = !0, i = c;
    } finally {
      try {
        if (!l && r.return != null && (a = r.return(), Object(a) !== a)) return;
      } finally {
        if (u) throw i;
      }
    }
    return s;
  }
}
function BH() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ue(e, t) {
  return VH(e) || SX(e, t) || zT(e, t) || BH();
}
function mg(e) {
  for (var t = 0, r, n = 0, i = e.length; i >= 4; ++n, i -= 4)
    r = e.charCodeAt(n) & 255 | (e.charCodeAt(++n) & 255) << 8 | (e.charCodeAt(++n) & 255) << 16 | (e.charCodeAt(++n) & 255) << 24, r = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16), r ^= /* k >>> r: */
    r >>> 24, t = /* Math.imul(k, m): */
    (r & 65535) * 1540483477 + ((r >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      t ^= (e.charCodeAt(n + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(n + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(n) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
function mi() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function mE(e, t) {
  if (!e)
    return !1;
  if (e.contains)
    return e.contains(t);
  for (var r = t; r; ) {
    if (r === e)
      return !0;
    r = r.parentNode;
  }
  return !1;
}
var DI = "data-rc-order", AI = "data-rc-priority", wX = "rc-util-key", yE = /* @__PURE__ */ new Map();
function GH() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.mark;
  return t ? t.startsWith("data-") ? t : "data-".concat(t) : wX;
}
function QC(e) {
  if (e.attachTo)
    return e.attachTo;
  var t = document.querySelector("head");
  return t || document.body;
}
function bX(e) {
  return e === "queue" ? "prependQueue" : e ? "prepend" : "append";
}
function $T(e) {
  return Array.from((yE.get(e) || e).children).filter(function(t) {
    return t.tagName === "STYLE";
  });
}
function HH(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!mi())
    return null;
  var r = t.csp, n = t.prepend, i = t.priority, o = i === void 0 ? 0 : i, a = bX(n), s = a === "prependQueue", l = document.createElement("style");
  l.setAttribute(DI, a), s && o && l.setAttribute(AI, "".concat(o)), r != null && r.nonce && (l.nonce = r == null ? void 0 : r.nonce), l.innerHTML = e;
  var u = QC(t), c = u.firstChild;
  if (n) {
    if (s) {
      var d = (t.styles || $T(u)).filter(function(h) {
        if (!["prepend", "prependQueue"].includes(h.getAttribute(DI)))
          return !1;
        var f = Number(h.getAttribute(AI) || 0);
        return o >= f;
      });
      if (d.length)
        return u.insertBefore(l, d[d.length - 1].nextSibling), l;
    }
    u.insertBefore(l, c);
  } else
    u.appendChild(l);
  return l;
}
function zH(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = QC(t);
  return (t.styles || $T(r)).find(function(n) {
    return n.getAttribute(GH(t)) === e;
  });
}
function yg(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = zH(e, t);
  if (r) {
    var n = QC(t);
    n.removeChild(r);
  }
}
function xX(e, t) {
  var r = yE.get(e);
  if (!r || !mE(document, r)) {
    var n = HH("", t), i = n.parentNode;
    yE.set(e, i), e.removeChild(n);
  }
}
function Ms(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = QC(r), i = $T(n), o = re(re({}, r), {}, {
    styles: i
  });
  xX(n, o);
  var a = zH(t, o);
  if (a) {
    var s, l;
    if ((s = o.csp) !== null && s !== void 0 && s.nonce && a.nonce !== ((l = o.csp) === null || l === void 0 ? void 0 : l.nonce)) {
      var u;
      a.nonce = (u = o.csp) === null || u === void 0 ? void 0 : u.nonce;
    }
    return a.innerHTML !== e && (a.innerHTML = e), a;
  }
  var c = HH(e, o);
  return c.setAttribute(GH(o), t), c;
}
function EX(e, t) {
  if (e == null) return {};
  var r = {};
  for (var n in e) if ({}.hasOwnProperty.call(e, n)) {
    if (t.indexOf(n) >= 0) continue;
    r[n] = e[n];
  }
  return r;
}
function zt(e, t) {
  if (e == null) return {};
  var r, n, i = EX(e, t);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    for (n = 0; n < o.length; n++) r = o[n], t.indexOf(r) >= 0 || {}.propertyIsEnumerable.call(e, r) && (i[r] = e[r]);
  }
  return i;
}
function xh(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1, n = /* @__PURE__ */ new Set();
  function i(o, a) {
    var s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, l = n.has(o);
    if (gr(!l, "Warning: There may be circular references"), l)
      return !1;
    if (o === a)
      return !0;
    if (r && s > 1)
      return !1;
    n.add(o);
    var u = s + 1;
    if (Array.isArray(o)) {
      if (!Array.isArray(a) || o.length !== a.length)
        return !1;
      for (var c = 0; c < o.length; c++)
        if (!i(o[c], a[c], u))
          return !1;
      return !0;
    }
    if (o && a && xt(o) === "object" && xt(a) === "object") {
      var d = Object.keys(o);
      return d.length !== Object.keys(a).length ? !1 : d.every(function(h) {
        return i(o[h], a[h], u);
      });
    }
    return !1;
  }
  return i(e, t);
}
var RX = "%";
function CE(e) {
  return e.join(RX);
}
var _X = /* @__PURE__ */ function() {
  function e(t) {
    Hn(this, e), te(this, "instanceId", void 0), te(this, "cache", /* @__PURE__ */ new Map()), this.instanceId = t;
  }
  return zn(e, [{
    key: "get",
    value: function(r) {
      return this.opGet(CE(r));
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opGet",
    value: function(r) {
      return this.cache.get(r) || null;
    }
  }, {
    key: "update",
    value: function(r, n) {
      return this.opUpdate(CE(r), n);
    }
    /** A fast get cache with `get` concat. */
  }, {
    key: "opUpdate",
    value: function(r, n) {
      var i = this.cache.get(r), o = n(i);
      o === null ? this.cache.delete(r) : this.cache.set(r, o);
    }
  }]), e;
}(), Eh = "data-token-hash", ua = "data-css-hash", TX = "data-cache-path", bl = "__cssinjs_instance__";
function PX() {
  var e = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    var t = document.body.querySelectorAll("style[".concat(ua, "]")) || [], r = document.head.firstChild;
    Array.from(t).forEach(function(i) {
      i[bl] = i[bl] || e, i[bl] === e && document.head.insertBefore(i, r);
    });
    var n = {};
    Array.from(document.querySelectorAll("style[".concat(ua, "]"))).forEach(function(i) {
      var o = i.getAttribute(ua);
      if (n[o]) {
        if (i[bl] === e) {
          var a;
          (a = i.parentNode) === null || a === void 0 || a.removeChild(i);
        }
      } else
        n[o] = !0;
    });
  }
  return new _X(e);
}
var JC = /* @__PURE__ */ T.createContext({
  hashPriority: "low",
  cache: PX(),
  defaultCache: !0
}), $H = /* @__PURE__ */ zn(function e() {
  Hn(this, e);
}), WH = "CALC_UNIT", MX = new RegExp(WH, "g");
function Rw(e) {
  return typeof e == "number" ? "".concat(e).concat(WH) : e;
}
var DX = /* @__PURE__ */ function(e) {
  Ql(r, e);
  var t = Jl(r);
  function r(n, i) {
    var o;
    Hn(this, r), o = t.call(this), te(qt(o), "result", ""), te(qt(o), "unitlessCssVar", void 0), te(qt(o), "lowPriority", void 0);
    var a = xt(n);
    return o.unitlessCssVar = i, n instanceof r ? o.result = "(".concat(n.result, ")") : a === "number" ? o.result = Rw(n) : a === "string" && (o.result = n), o;
  }
  return zn(r, [{
    key: "add",
    value: function(i) {
      return i instanceof r ? this.result = "".concat(this.result, " + ").concat(i.getResult()) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " + ").concat(Rw(i))), this.lowPriority = !0, this;
    }
  }, {
    key: "sub",
    value: function(i) {
      return i instanceof r ? this.result = "".concat(this.result, " - ").concat(i.getResult()) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " - ").concat(Rw(i))), this.lowPriority = !0, this;
    }
  }, {
    key: "mul",
    value: function(i) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), i instanceof r ? this.result = "".concat(this.result, " * ").concat(i.getResult(!0)) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " * ").concat(i)), this.lowPriority = !1, this;
    }
  }, {
    key: "div",
    value: function(i) {
      return this.lowPriority && (this.result = "(".concat(this.result, ")")), i instanceof r ? this.result = "".concat(this.result, " / ").concat(i.getResult(!0)) : (typeof i == "number" || typeof i == "string") && (this.result = "".concat(this.result, " / ").concat(i)), this.lowPriority = !1, this;
    }
  }, {
    key: "getResult",
    value: function(i) {
      return this.lowPriority || i ? "(".concat(this.result, ")") : this.result;
    }
  }, {
    key: "equal",
    value: function(i) {
      var o = this, a = i || {}, s = a.unit, l = !0;
      return typeof s == "boolean" ? l = s : Array.from(this.unitlessCssVar).some(function(u) {
        return o.result.includes(u);
      }) && (l = !1), this.result = this.result.replace(MX, l ? "px" : ""), typeof this.lowPriority < "u" ? "calc(".concat(this.result, ")") : this.result;
    }
  }]), r;
}($H), AX = /* @__PURE__ */ function(e) {
  Ql(r, e);
  var t = Jl(r);
  function r(n) {
    var i;
    return Hn(this, r), i = t.call(this), te(qt(i), "result", 0), n instanceof r ? i.result = n.result : typeof n == "number" && (i.result = n), i;
  }
  return zn(r, [{
    key: "add",
    value: function(i) {
      return i instanceof r ? this.result += i.result : typeof i == "number" && (this.result += i), this;
    }
  }, {
    key: "sub",
    value: function(i) {
      return i instanceof r ? this.result -= i.result : typeof i == "number" && (this.result -= i), this;
    }
  }, {
    key: "mul",
    value: function(i) {
      return i instanceof r ? this.result *= i.result : typeof i == "number" && (this.result *= i), this;
    }
  }, {
    key: "div",
    value: function(i) {
      return i instanceof r ? this.result /= i.result : typeof i == "number" && (this.result /= i), this;
    }
  }, {
    key: "equal",
    value: function() {
      return this.result;
    }
  }]), r;
}($H), IX = function(t, r) {
  var n = t === "css" ? DX : AX;
  return function(i) {
    return new n(i, r);
  };
};
function FX(e, t) {
  if (e.length !== t.length)
    return !1;
  for (var r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
var WT = /* @__PURE__ */ function() {
  function e() {
    Hn(this, e), te(this, "cache", void 0), te(this, "keys", void 0), te(this, "cacheCallTimes", void 0), this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  return zn(e, [{
    key: "size",
    value: function() {
      return this.keys.length;
    }
  }, {
    key: "internalGet",
    value: function(r) {
      var n, i, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, a = {
        map: this.cache
      };
      return r.forEach(function(s) {
        if (!a)
          a = void 0;
        else {
          var l;
          a = (l = a) === null || l === void 0 || (l = l.map) === null || l === void 0 ? void 0 : l.get(s);
        }
      }), (n = a) !== null && n !== void 0 && n.value && o && (a.value[1] = this.cacheCallTimes++), (i = a) === null || i === void 0 ? void 0 : i.value;
    }
  }, {
    key: "get",
    value: function(r) {
      var n;
      return (n = this.internalGet(r, !0)) === null || n === void 0 ? void 0 : n[0];
    }
  }, {
    key: "has",
    value: function(r) {
      return !!this.internalGet(r);
    }
  }, {
    key: "set",
    value: function(r, n) {
      var i = this;
      if (!this.has(r)) {
        if (this.size() + 1 > e.MAX_CACHE_SIZE + e.MAX_CACHE_OFFSET) {
          var o = this.keys.reduce(function(u, c) {
            var d = ue(u, 2), h = d[1];
            return i.internalGet(c)[1] < h ? [c, i.internalGet(c)[1]] : u;
          }, [this.keys[0], this.cacheCallTimes]), a = ue(o, 1), s = a[0];
          this.delete(s);
        }
        this.keys.push(r);
      }
      var l = this.cache;
      r.forEach(function(u, c) {
        if (c === r.length - 1)
          l.set(u, {
            value: [n, i.cacheCallTimes++]
          });
        else {
          var d = l.get(u);
          d ? d.map || (d.map = /* @__PURE__ */ new Map()) : l.set(u, {
            map: /* @__PURE__ */ new Map()
          }), l = l.get(u).map;
        }
      });
    }
  }, {
    key: "deleteByPath",
    value: function(r, n) {
      var i = r.get(n[0]);
      if (n.length === 1) {
        var o;
        return i.map ? r.set(n[0], {
          map: i.map
        }) : r.delete(n[0]), (o = i.value) === null || o === void 0 ? void 0 : o[0];
      }
      var a = this.deleteByPath(i.map, n.slice(1));
      return (!i.map || i.map.size === 0) && !i.value && r.delete(n[0]), a;
    }
  }, {
    key: "delete",
    value: function(r) {
      if (this.has(r))
        return this.keys = this.keys.filter(function(n) {
          return !FX(n, r);
        }), this.deleteByPath(this.cache, r);
    }
  }]), e;
}();
te(WT, "MAX_CACHE_SIZE", 20);
te(WT, "MAX_CACHE_OFFSET", 5);
var II = 0, jH = /* @__PURE__ */ function() {
  function e(t) {
    Hn(this, e), te(this, "derivatives", void 0), te(this, "id", void 0), this.derivatives = Array.isArray(t) ? t : [t], this.id = II, t.length === 0 && Ns(t.length > 0, "[Ant Design CSS-in-JS] Theme should have at least one derivative function."), II += 1;
  }
  return zn(e, [{
    key: "getDerivativeToken",
    value: function(r) {
      return this.derivatives.reduce(function(n, i) {
        return i(r, n);
      }, void 0);
    }
  }]), e;
}(), _w = new WT();
function SE(e) {
  var t = Array.isArray(e) ? e : [e];
  return _w.has(t) || _w.set(t, new jH(t)), _w.get(t);
}
var LX = /* @__PURE__ */ new WeakMap(), Tw = {};
function OX(e, t) {
  for (var r = LX, n = 0; n < t.length; n += 1) {
    var i = t[n];
    r.has(i) || r.set(i, /* @__PURE__ */ new WeakMap()), r = r.get(i);
  }
  return r.has(Tw) || r.set(Tw, e()), r.get(Tw);
}
var FI = /* @__PURE__ */ new WeakMap();
function Gp(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = FI.get(e) || "";
  return r || (Object.keys(e).forEach(function(n) {
    var i = e[n];
    r += n, i instanceof jH ? r += i.id : i && xt(i) === "object" ? r += Gp(i, t) : r += i;
  }), t && (r = mg(r)), FI.set(e, r)), r;
}
function LI(e, t) {
  return mg("".concat(t, "_").concat(Gp(e, !0)));
}
var wE = mi();
function xe(e) {
  return typeof e == "number" ? "".concat(e, "px") : e;
}
function E0(e, t, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1;
  if (i)
    return e;
  var o = re(re({}, n), {}, te(te({}, Eh, t), ua, r)), a = Object.keys(o).map(function(s) {
    var l = o[s];
    return l ? "".concat(s, '="').concat(l, '"') : null;
  }).filter(function(s) {
    return s;
  }).join(" ");
  return "<style ".concat(a, ">").concat(e, "</style>");
}
var Vy = function(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return "--".concat(r ? "".concat(r, "-") : "").concat(t).replace(/([a-z0-9])([A-Z])/g, "$1-$2").replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, "$1-$2").replace(/([a-z])([A-Z0-9])/g, "$1-$2").toLowerCase();
}, NX = function(t, r, n) {
  return Object.keys(t).length ? ".".concat(r).concat(n != null && n.scope ? ".".concat(n.scope) : "", "{").concat(Object.entries(t).map(function(i) {
    var o = ue(i, 2), a = o[0], s = o[1];
    return "".concat(a, ":").concat(s, ";");
  }).join(""), "}") : "";
}, UH = function(t, r, n) {
  var i = {}, o = {};
  return Object.entries(t).forEach(function(a) {
    var s, l, u = ue(a, 2), c = u[0], d = u[1];
    if (n != null && (s = n.preserve) !== null && s !== void 0 && s[c])
      o[c] = d;
    else if ((typeof d == "string" || typeof d == "number") && !(n != null && (l = n.ignore) !== null && l !== void 0 && l[c])) {
      var h, f = Vy(c, n == null ? void 0 : n.prefix);
      i[f] = typeof d == "number" && !(n != null && (h = n.unitless) !== null && h !== void 0 && h[c]) ? "".concat(d, "px") : String(d), o[c] = "var(".concat(f, ")");
    }
  }), [o, NX(i, r, {
    scope: n == null ? void 0 : n.scope
  })];
}, OI = process.env.NODE_ENV !== "test" && mi() ? T.useLayoutEffect : T.useEffect, Wr = function(t, r) {
  var n = T.useRef(!0);
  OI(function() {
    return t(n.current);
  }, r), OI(function() {
    return n.current = !1, function() {
      n.current = !0;
    };
  }, []);
}, bE = function(t, r) {
  Wr(function(n) {
    if (!n)
      return t();
  }, r);
}, kX = re({}, T), NI = kX.useInsertionEffect, VX = function(t, r, n) {
  T.useMemo(t, n), Wr(function() {
    return r(!0);
  }, n);
}, BX = NI ? function(e, t, r) {
  return NI(function() {
    return e(), t();
  }, r);
} : VX, GX = re({}, T), HX = GX.useInsertionEffect, zX = function(t) {
  var r = [], n = !1;
  function i(o) {
    if (n) {
      process.env.NODE_ENV !== "production" && Ns(!1, "[Ant Design CSS-in-JS] You are registering a cleanup function after unmount, which will not have any effect.");
      return;
    }
    r.push(o);
  }
  return T.useEffect(function() {
    return n = !1, function() {
      n = !0, r.length && r.forEach(function(o) {
        return o();
      });
    };
  }, t), i;
}, $X = function() {
  return function(t) {
    t();
  };
}, WX = typeof HX < "u" ? zX : $X;
function jX() {
  return !1;
}
var xE = !1;
function UX() {
  return xE;
}
const KX = process.env.NODE_ENV === "production" ? jX : UX;
if (process.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  var Pw = window;
  if (typeof Pw.webpackHotUpdate == "function") {
    var YX = Pw.webpackHotUpdate;
    Pw.webpackHotUpdate = function() {
      return xE = !0, setTimeout(function() {
        xE = !1;
      }, 0), YX.apply(void 0, arguments);
    };
  }
}
function jT(e, t, r, n, i) {
  var o = T.useContext(JC), a = o.cache, s = [e].concat(rt(t)), l = CE(s), u = WX([l]), c = KX(), d = function(g) {
    a.opUpdate(l, function(v) {
      var m = v || [void 0, void 0], y = ue(m, 2), C = y[0], S = C === void 0 ? 0 : C, b = y[1], w = b;
      process.env.NODE_ENV !== "production" && b && c && (n == null || n(w, c), w = null);
      var x = w || r(), E = [S, x];
      return g ? g(E) : E;
    });
  };
  T.useMemo(
    function() {
      d();
    },
    /* eslint-disable react-hooks/exhaustive-deps */
    [l]
    /* eslint-enable */
  );
  var h = a.opGet(l);
  process.env.NODE_ENV !== "production" && !h && (d(), h = a.opGet(l));
  var f = h[1];
  return BX(function() {
    i == null || i(f);
  }, function(p) {
    return d(function(g) {
      var v = ue(g, 2), m = v[0], y = v[1];
      return p && m === 0 && (i == null || i(f)), [m + 1, y];
    }), function() {
      a.opUpdate(l, function(g) {
        var v = g || [], m = ue(v, 2), y = m[0], C = y === void 0 ? 0 : y, S = m[1], b = C - 1;
        return b === 0 ? (u(function() {
          (p || !a.opGet(l)) && (n == null || n(S, !1));
        }), null) : [C - 1, S];
      });
    };
  }, [l]), f;
}
var qX = {}, ZX = process.env.NODE_ENV !== "production" ? "css-dev-only-do-not-override" : "css", Wu = /* @__PURE__ */ new Map();
function XX(e) {
  Wu.set(e, (Wu.get(e) || 0) + 1);
}
function QX(e, t) {
  if (typeof document < "u") {
    var r = document.querySelectorAll("style[".concat(Eh, '="').concat(e, '"]'));
    r.forEach(function(n) {
      if (n[bl] === t) {
        var i;
        (i = n.parentNode) === null || i === void 0 || i.removeChild(n);
      }
    });
  }
}
var JX = 0;
function eQ(e, t) {
  Wu.set(e, (Wu.get(e) || 0) - 1);
  var r = Array.from(Wu.keys()), n = r.filter(function(i) {
    var o = Wu.get(i) || 0;
    return o <= 0;
  });
  r.length - n.length > JX && n.forEach(function(i) {
    QX(i, t), Wu.delete(i);
  });
}
var tQ = function(t, r, n, i) {
  var o = n.getDerivativeToken(t), a = re(re({}, o), r);
  return i && (a = i(a)), a;
}, KH = "token";
function rQ(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, n = rr(JC), i = n.cache.instanceId, o = n.container, a = r.salt, s = a === void 0 ? "" : a, l = r.override, u = l === void 0 ? qX : l, c = r.formatToken, d = r.getComputedToken, h = r.cssVar, f = OX(function() {
    return Object.assign.apply(Object, [{}].concat(rt(t)));
  }, t), p = Gp(f), g = Gp(u), v = h ? Gp(h) : "", m = jT(KH, [s, e.id, p, g, v], function() {
    var y, C = d ? d(f, u, e) : tQ(f, u, e, c), S = re({}, C), b = "";
    if (h) {
      var w = UH(C, h.key, {
        prefix: h.prefix,
        ignore: h.ignore,
        unitless: h.unitless,
        preserve: h.preserve
      }), x = ue(w, 2);
      C = x[0], b = x[1];
    }
    var E = LI(C, s);
    C._tokenKey = E, S._tokenKey = LI(S, s);
    var R = (y = h == null ? void 0 : h.key) !== null && y !== void 0 ? y : E;
    C._themeKey = R, XX(R);
    var _ = "".concat(ZX, "-").concat(mg(E));
    return C._hashId = _, [C, _, S, b, (h == null ? void 0 : h.key) || ""];
  }, function(y) {
    eQ(y[0]._themeKey, i);
  }, function(y) {
    var C = ue(y, 4), S = C[0], b = C[3];
    if (h && b) {
      var w = Ms(b, mg("css-variables-".concat(S._themeKey)), {
        mark: ua,
        prepend: "queue",
        attachTo: o,
        priority: -999
      });
      w[bl] = i, w.setAttribute(Eh, S._themeKey);
    }
  });
  return m;
}
var nQ = function(t, r, n) {
  var i = ue(t, 5), o = i[2], a = i[3], s = i[4], l = n || {}, u = l.plain;
  if (!a)
    return null;
  var c = o._tokenKey, d = -999, h = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(d)
  }, f = E0(a, s, c, h, u);
  return [d, c, f];
}, iQ = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, YH = "comm", qH = "rule", ZH = "decl", oQ = "@import", aQ = "@keyframes", sQ = "@layer", XH = Math.abs, UT = String.fromCharCode;
function QH(e) {
  return e.trim();
}
function By(e, t, r) {
  return e.replace(t, r);
}
function lQ(e, t, r) {
  return e.indexOf(t, r);
}
function Cg(e, t) {
  return e.charCodeAt(t) | 0;
}
function Sg(e, t, r) {
  return e.slice(t, r);
}
function ws(e) {
  return e.length;
}
function uQ(e) {
  return e.length;
}
function em(e, t) {
  return t.push(e), e;
}
var eS = 1, Rh = 1, JH = 0, Fo = 0, gn = 0, Yh = "";
function KT(e, t, r, n, i, o, a, s) {
  return { value: e, root: t, parent: r, type: n, props: i, children: o, line: eS, column: Rh, length: a, return: "", siblings: s };
}
function cQ() {
  return gn;
}
function dQ() {
  return gn = Fo > 0 ? Cg(Yh, --Fo) : 0, Rh--, gn === 10 && (Rh = 1, eS--), gn;
}
function ca() {
  return gn = Fo < JH ? Cg(Yh, Fo++) : 0, Rh++, gn === 10 && (Rh = 1, eS++), gn;
}
function uc() {
  return Cg(Yh, Fo);
}
function Gy() {
  return Fo;
}
function tS(e, t) {
  return Sg(Yh, e, t);
}
function EE(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function hQ(e) {
  return eS = Rh = 1, JH = ws(Yh = e), Fo = 0, [];
}
function fQ(e) {
  return Yh = "", e;
}
function Mw(e) {
  return QH(tS(Fo - 1, RE(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function pQ(e) {
  for (; (gn = uc()) && gn < 33; )
    ca();
  return EE(e) > 2 || EE(gn) > 3 ? "" : " ";
}
function gQ(e, t) {
  for (; --t && ca() && !(gn < 48 || gn > 102 || gn > 57 && gn < 65 || gn > 70 && gn < 97); )
    ;
  return tS(e, Gy() + (t < 6 && uc() == 32 && ca() == 32));
}
function RE(e) {
  for (; ca(); )
    switch (gn) {
      case e:
        return Fo;
      case 34:
      case 39:
        e !== 34 && e !== 39 && RE(gn);
        break;
      case 40:
        e === 41 && RE(e);
        break;
      case 92:
        ca();
        break;
    }
  return Fo;
}
function vQ(e, t) {
  for (; ca() && e + gn !== 57; )
    if (e + gn === 84 && uc() === 47)
      break;
  return "/*" + tS(t, Fo - 1) + "*" + UT(e === 47 ? e : ca());
}
function mQ(e) {
  for (; !EE(uc()); )
    ca();
  return tS(e, Fo);
}
function yQ(e) {
  return fQ(Hy("", null, null, null, [""], e = hQ(e), 0, [0], e));
}
function Hy(e, t, r, n, i, o, a, s, l) {
  for (var u = 0, c = 0, d = a, h = 0, f = 0, p = 0, g = 1, v = 1, m = 1, y = 0, C = "", S = i, b = o, w = n, x = C; v; )
    switch (p = y, y = ca()) {
      case 40:
        if (p != 108 && Cg(x, d - 1) == 58) {
          lQ(x += By(Mw(y), "&", "&\f"), "&\f", XH(u ? s[u - 1] : 0)) != -1 && (m = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        x += Mw(y);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        x += pQ(p);
        break;
      case 92:
        x += gQ(Gy() - 1, 7);
        continue;
      case 47:
        switch (uc()) {
          case 42:
          case 47:
            em(CQ(vQ(ca(), Gy()), t, r, l), l);
            break;
          default:
            x += "/";
        }
        break;
      case 123 * g:
        s[u++] = ws(x) * m;
      case 125 * g:
      case 59:
      case 0:
        switch (y) {
          case 0:
          case 125:
            v = 0;
          case 59 + c:
            m == -1 && (x = By(x, /\f/g, "")), f > 0 && ws(x) - d && em(f > 32 ? VI(x + ";", n, r, d - 1, l) : VI(By(x, " ", "") + ";", n, r, d - 2, l), l);
            break;
          case 59:
            x += ";";
          default:
            if (em(w = kI(x, t, r, u, c, i, s, C, S = [], b = [], d, o), o), y === 123)
              if (c === 0)
                Hy(x, t, w, w, S, o, d, s, b);
              else
                switch (h === 99 && Cg(x, 3) === 110 ? 100 : h) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Hy(e, w, w, n && em(kI(e, w, w, 0, 0, i, s, C, i, S = [], d, b), b), i, b, d, s, n ? S : b);
                    break;
                  default:
                    Hy(x, w, w, w, [""], b, 0, s, b);
                }
        }
        u = c = f = 0, g = m = 1, C = x = "", d = a;
        break;
      case 58:
        d = 1 + ws(x), f = p;
      default:
        if (g < 1) {
          if (y == 123)
            --g;
          else if (y == 125 && g++ == 0 && dQ() == 125)
            continue;
        }
        switch (x += UT(y), y * g) {
          case 38:
            m = c > 0 ? 1 : (x += "\f", -1);
            break;
          case 44:
            s[u++] = (ws(x) - 1) * m, m = 1;
            break;
          case 64:
            uc() === 45 && (x += Mw(ca())), h = uc(), c = d = ws(C = x += mQ(Gy())), y++;
            break;
          case 45:
            p === 45 && ws(x) == 2 && (g = 0);
        }
    }
  return o;
}
function kI(e, t, r, n, i, o, a, s, l, u, c, d) {
  for (var h = i - 1, f = i === 0 ? o : [""], p = uQ(f), g = 0, v = 0, m = 0; g < n; ++g)
    for (var y = 0, C = Sg(e, h + 1, h = XH(v = a[g])), S = e; y < p; ++y)
      (S = QH(v > 0 ? f[y] + " " + C : By(C, /&\f/g, f[y]))) && (l[m++] = S);
  return KT(e, t, r, i === 0 ? qH : s, l, u, c, d);
}
function CQ(e, t, r, n) {
  return KT(e, t, r, YH, UT(cQ()), Sg(e, 2, -2), 0, n);
}
function VI(e, t, r, n, i) {
  return KT(e, t, r, ZH, Sg(e, 0, n), Sg(e, n + 1, -1), n, i);
}
function _E(e, t) {
  for (var r = "", n = 0; n < e.length; n++)
    r += t(e[n], n, e, t) || "";
  return r;
}
function SQ(e, t, r, n) {
  switch (e.type) {
    case sQ:
      if (e.children.length) break;
    case oQ:
    case ZH:
      return e.return = e.return || e.value;
    case YH:
      return "";
    case aQ:
      return e.return = e.value + "{" + _E(e.children, n) + "}";
    case qH:
      if (!ws(e.value = e.props.join(","))) return "";
  }
  return ws(r = _E(e.children, n)) ? e.return = e.value + "{" + r + "}" : "";
}
function ez(e, t) {
  var r = t.path, n = t.parentSelectors;
  gr(!1, "[Ant Design CSS-in-JS] ".concat(r ? "Error in ".concat(r, ": ") : "").concat(e).concat(n.length ? " Selector: ".concat(n.join(" | ")) : ""));
}
var wQ = function(t, r, n) {
  if (t === "content") {
    var i = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, o = ["normal", "none", "initial", "inherit", "unset"];
    (typeof r != "string" || o.indexOf(r) === -1 && !i.test(r) && (r.charAt(0) !== r.charAt(r.length - 1) || r.charAt(0) !== '"' && r.charAt(0) !== "'")) && ez("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"".concat(r, "\"'`."), n);
  }
}, bQ = function(t, r, n) {
  t === "animation" && n.hashId && r !== "none" && ez("You seem to be using hashed animation '".concat(r, "', in which case 'animationName' with Keyframe as value is recommended."), n);
}, BI = "data-ant-cssinjs-cache-path", tz = "_FILE_STYLE__", cc, rz = !0;
function xQ() {
  if (!cc && (cc = {}, mi())) {
    var e = document.createElement("div");
    e.className = BI, e.style.position = "fixed", e.style.visibility = "hidden", e.style.top = "-9999px", document.body.appendChild(e);
    var t = getComputedStyle(e).content || "";
    t = t.replace(/^"/, "").replace(/"$/, ""), t.split(";").forEach(function(i) {
      var o = i.split(":"), a = ue(o, 2), s = a[0], l = a[1];
      cc[s] = l;
    });
    var r = document.querySelector("style[".concat(BI, "]"));
    if (r) {
      var n;
      rz = !1, (n = r.parentNode) === null || n === void 0 || n.removeChild(r);
    }
    document.body.removeChild(e);
  }
}
function EQ(e) {
  return xQ(), !!cc[e];
}
function RQ(e) {
  var t = cc[e], r = null;
  if (t && mi())
    if (rz)
      r = tz;
    else {
      var n = document.querySelector("style[".concat(ua, '="').concat(cc[e], '"]'));
      n ? r = n.innerHTML : delete cc[e];
    }
  return [r, t];
}
var nz = "_skip_check_", iz = "_multi_value_";
function zy(e) {
  var t = _E(yQ(e), SQ);
  return t.replace(/\{%%%\:[^;];}/g, ";");
}
function _Q(e) {
  return xt(e) === "object" && e && (nz in e || iz in e);
}
function TQ(e, t, r) {
  if (!t)
    return e;
  var n = ".".concat(t), i = r === "low" ? ":where(".concat(n, ")") : n, o = e.split(",").map(function(a) {
    var s, l = a.trim().split(/\s+/), u = l[0] || "", c = ((s = u.match(/^\w+/)) === null || s === void 0 ? void 0 : s[0]) || "";
    return u = "".concat(c).concat(i).concat(u.slice(c.length)), [u].concat(rt(l.slice(1))).join(" ");
  });
  return o.join(",");
}
var PQ = function e(t) {
  var r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  }, i = n.root, o = n.injectHash, a = n.parentSelectors, s = r.hashId, l = r.layer, u = r.path, c = r.hashPriority, d = r.transformers, h = d === void 0 ? [] : d, f = r.linters, p = f === void 0 ? [] : f, g = "", v = {};
  function m(S) {
    var b = S.getName(s);
    if (!v[b]) {
      var w = e(S.style, r, {
        root: !1,
        parentSelectors: a
      }), x = ue(w, 1), E = x[0];
      v[b] = "@keyframes ".concat(S.getName(s)).concat(E);
    }
  }
  function y(S) {
    var b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return S.forEach(function(w) {
      Array.isArray(w) ? y(w, b) : w && b.push(w);
    }), b;
  }
  var C = y(Array.isArray(t) ? t : [t]);
  return C.forEach(function(S) {
    var b = typeof S == "string" && !i ? {} : S;
    if (typeof b == "string")
      g += "".concat(b, `
`);
    else if (b._keyframe)
      m(b);
    else {
      var w = h.reduce(function(x, E) {
        var R;
        return (E == null || (R = E.visit) === null || R === void 0 ? void 0 : R.call(E, x)) || x;
      }, b);
      Object.keys(w).forEach(function(x) {
        var E = w[x];
        if (xt(E) === "object" && E && (x !== "animationName" || !E._keyframe) && !_Q(E)) {
          var R = !1, _ = x.trim(), P = !1;
          (i || o) && s ? _.startsWith("@") ? R = !0 : _ = TQ(x, s, c) : i && !s && (_ === "&" || _ === "") && (_ = "", P = !0);
          var D = e(E, r, {
            root: P,
            injectHash: R,
            parentSelectors: [].concat(rt(a), [_])
          }), I = ue(D, 2), A = I[0], O = I[1];
          v = re(re({}, v), O), g += "".concat(_).concat(A);
        } else {
          let F = function(G, M) {
            process.env.NODE_ENV !== "production" && (xt(E) !== "object" || !(E != null && E[nz])) && [wQ, bQ].concat(rt(p)).forEach(function(k) {
              return k(G, M, {
                path: u,
                hashId: s,
                parentSelectors: a
              });
            });
            var V = G.replace(/[A-Z]/g, function(k) {
              return "-".concat(k.toLowerCase());
            }), z = M;
            !iQ[G] && typeof z == "number" && z !== 0 && (z = "".concat(z, "px")), G === "animationName" && M !== null && M !== void 0 && M._keyframe && (m(M), z = M.getName(s)), g += "".concat(V, ":").concat(z, ";");
          };
          var L, N = (L = E == null ? void 0 : E.value) !== null && L !== void 0 ? L : E;
          xt(E) === "object" && E !== null && E !== void 0 && E[iz] && Array.isArray(N) ? N.forEach(function(G) {
            F(x, G);
          }) : F(x, N);
        }
      });
    }
  }), i ? l && (g = "@layer ".concat(l.name, " {").concat(g, "}"), l.dependencies && (v["@layer ".concat(l.name)] = l.dependencies.map(function(S) {
    return "@layer ".concat(S, ", ").concat(l.name, ";");
  }).join(`
`))) : g = "{".concat(g, "}"), [g, v];
};
function oz(e, t) {
  return mg("".concat(e.join("%")).concat(t));
}
function MQ() {
  return null;
}
var az = "style";
function TE(e, t) {
  var r = e.token, n = e.path, i = e.hashId, o = e.layer, a = e.nonce, s = e.clientOnly, l = e.order, u = l === void 0 ? 0 : l, c = T.useContext(JC), d = c.autoClear, h = c.mock, f = c.defaultCache, p = c.hashPriority, g = c.container, v = c.ssrInline, m = c.transformers, y = c.linters, C = c.cache, S = c.layer, b = r._tokenKey, w = [b];
  S && w.push("layer"), w.push.apply(w, rt(n));
  var x = wE;
  process.env.NODE_ENV !== "production" && h !== void 0 && (x = h === "client");
  var E = jT(
    az,
    w,
    // Create cache if needed
    function() {
      var I = w.join("|");
      if (EQ(I)) {
        var A = RQ(I), O = ue(A, 2), L = O[0], N = O[1];
        if (L)
          return [L, b, N, {}, s, u];
      }
      var F = t(), G = PQ(F, {
        hashId: i,
        hashPriority: p,
        layer: S ? o : void 0,
        path: n.join("-"),
        transformers: m,
        linters: y
      }), M = ue(G, 2), V = M[0], z = M[1], k = zy(V), $ = oz(w, k);
      return [k, b, $, z, s, u];
    },
    // Remove cache if no need
    function(I, A) {
      var O = ue(I, 3), L = O[2];
      (A || d) && wE && yg(L, {
        mark: ua
      });
    },
    // Effect: Inject style here
    function(I) {
      var A = ue(I, 4), O = A[0];
      A[1];
      var L = A[2], N = A[3];
      if (x && O !== tz) {
        var F = {
          mark: ua,
          prepend: S ? !1 : "queue",
          attachTo: g,
          priority: u
        }, G = typeof a == "function" ? a() : a;
        G && (F.csp = {
          nonce: G
        });
        var M = [], V = [];
        Object.keys(N).forEach(function(k) {
          k.startsWith("@layer") ? M.push(k) : V.push(k);
        }), M.forEach(function(k) {
          Ms(zy(N[k]), "_layer-".concat(k), re(re({}, F), {}, {
            prepend: !0
          }));
        });
        var z = Ms(O, L, F);
        z[bl] = C.instanceId, z.setAttribute(Eh, b), process.env.NODE_ENV !== "production" && z.setAttribute(TX, w.join("|")), V.forEach(function(k) {
          Ms(zy(N[k]), "_effect-".concat(k), F);
        });
      }
    }
  ), R = ue(E, 3), _ = R[0], P = R[1], D = R[2];
  return function(I) {
    var A;
    return !v || x || !f ? A = /* @__PURE__ */ T.createElement(MQ, null) : A = /* @__PURE__ */ T.createElement("style", ze({}, te(te({}, Eh, P), ua, D), {
      dangerouslySetInnerHTML: {
        __html: _
      }
    })), /* @__PURE__ */ T.createElement(T.Fragment, null, A, I);
  };
}
var DQ = function(t, r, n) {
  var i = ue(t, 6), o = i[0], a = i[1], s = i[2], l = i[3], u = i[4], c = i[5], d = n || {}, h = d.plain;
  if (u)
    return null;
  var f = o, p = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(c)
  };
  return f = E0(o, a, s, p, h), l && Object.keys(l).forEach(function(g) {
    if (!r[g]) {
      r[g] = !0;
      var v = zy(l[g]), m = E0(v, a, "_effect-".concat(g), p, h);
      g.startsWith("@layer") ? f = m + f : f += m;
    }
  }), [c, s, f];
}, sz = "cssVar", AQ = function(t, r) {
  var n = t.key, i = t.prefix, o = t.unitless, a = t.ignore, s = t.token, l = t.scope, u = l === void 0 ? "" : l, c = rr(JC), d = c.cache.instanceId, h = c.container, f = s._tokenKey, p = [].concat(rt(t.path), [n, u, f]), g = jT(sz, p, function() {
    var v = r(), m = UH(v, n, {
      prefix: i,
      unitless: o,
      ignore: a,
      scope: u
    }), y = ue(m, 2), C = y[0], S = y[1], b = oz(p, S);
    return [C, S, b, n];
  }, function(v) {
    var m = ue(v, 3), y = m[2];
    wE && yg(y, {
      mark: ua
    });
  }, function(v) {
    var m = ue(v, 3), y = m[1], C = m[2];
    if (y) {
      var S = Ms(y, C, {
        mark: ua,
        prepend: "queue",
        attachTo: h,
        priority: -999
      });
      S[bl] = d, S.setAttribute(Eh, n);
    }
  });
  return g;
}, IQ = function(t, r, n) {
  var i = ue(t, 4), o = i[1], a = i[2], s = i[3], l = n || {}, u = l.plain;
  if (!o)
    return null;
  var c = -999, d = {
    "data-rc-order": "prependQueue",
    "data-rc-priority": "".concat(c)
  }, h = E0(o, s, a, d, u);
  return [c, a, h];
};
te(te(te({}, az, DQ), KH, nQ), sz, IQ);
var Yr = /* @__PURE__ */ function() {
  function e(t, r) {
    Hn(this, e), te(this, "name", void 0), te(this, "style", void 0), te(this, "_keyframe", !0), this.name = t, this.style = r;
  }
  return zn(e, [{
    key: "getName",
    value: function() {
      var r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      return r ? "".concat(r, "-").concat(this.name) : this.name;
    }
  }]), e;
}();
function ad(e) {
  return e.notSplit = !0, e;
}
ad(["borderTop", "borderBottom"]), ad(["borderTop"]), ad(["borderBottom"]), ad(["borderLeft", "borderRight"]), ad(["borderLeft"]), ad(["borderRight"]);
var YT = /* @__PURE__ */ Xl({});
function FQ(e) {
  return VH(e) || LH(e) || zT(e) || BH();
}
function Ha(e, t) {
  for (var r = e, n = 0; n < t.length; n += 1) {
    if (r == null)
      return;
    r = r[t[n]];
  }
  return r;
}
function lz(e, t, r, n) {
  if (!t.length)
    return r;
  var i = FQ(t), o = i[0], a = i.slice(1), s;
  return !e && typeof o == "number" ? s = [] : Array.isArray(e) ? s = rt(e) : s = re({}, e), n && r === void 0 && a.length === 1 ? delete s[o][a[0]] : s[o] = lz(s[o], a, r, n), s;
}
function ta(e, t, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return t.length && n && r === void 0 && !Ha(e, t.slice(0, -1)) ? e : lz(e, t, r, n);
}
function LQ(e) {
  return xt(e) === "object" && e !== null && Object.getPrototypeOf(e) === Object.prototype;
}
function GI(e) {
  return Array.isArray(e) ? [] : {};
}
var OQ = typeof Reflect > "u" ? Object.keys : Reflect.ownKeys;
function Zd() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = GI(t[0]);
  return t.forEach(function(i) {
    function o(a, s) {
      var l = new Set(s), u = Ha(i, a), c = Array.isArray(u);
      if (c || LQ(u)) {
        if (!l.has(u)) {
          l.add(u);
          var d = Ha(n, a);
          c ? n = ta(n, a, []) : (!d || xt(d) !== "object") && (n = ta(n, a, GI(u))), OQ(u).forEach(function(h) {
            o([].concat(rt(a), [h]), l);
          });
        }
      } else
        n = ta(n, a, u);
    }
    o([]);
  }), n;
}
function uz() {
}
let ys = null;
function NQ() {
  ys = null, xH();
}
let qh = uz;
process.env.NODE_ENV !== "production" && (qh = (e, t, r) => {
  gr(e, `[antd: ${t}] ${r}`), process.env.NODE_ENV === "test" && NQ();
});
const cz = /* @__PURE__ */ T.createContext({}), mn = process.env.NODE_ENV !== "production" ? (e) => {
  const {
    strict: t
  } = T.useContext(cz), r = (n, i, o) => {
    if (!n)
      if (t === !1 && i === "deprecated") {
        const a = ys;
        ys || (ys = {}), ys[e] = ys[e] || [], ys[e].includes(o || "") || ys[e].push(o || ""), a || console.warn("[antd] There exists deprecated usage in your code:", ys);
      } else
        process.env.NODE_ENV !== "production" && qh(n, e, o);
  };
  return r.deprecated = (n, i, o, a) => {
    r(n, "deprecated", `\`${i}\` is deprecated. Please use \`${o}\` instead.${a ? ` ${a}` : ""}`);
  }, r;
} : () => {
  const e = () => {
  };
  return e.deprecated = uz, e;
}, kQ = /* @__PURE__ */ Xl(void 0);
var VQ = {
  // Options
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "Page",
  // Pagination
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages",
  page_size: "Page Size"
}, BQ = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "OK",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: !0,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
};
const dz = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
}, HI = {
  lang: Object.assign({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, BQ),
  timePickerLocale: Object.assign({}, dz)
}, Hi = "${label} is not a valid ${type}", ks = {
  locale: "en",
  Pagination: VQ,
  DatePicker: HI,
  TimePicker: dz,
  Calendar: HI,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    deselectAll: "Deselect all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand",
    collapse: "Collapse"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: Hi,
        method: Hi,
        array: Hi,
        object: Hi,
        number: Hi,
        date: Hi,
        boolean: Hi,
        integer: Hi,
        float: Hi,
        regexp: Hi,
        email: Hi,
        url: Hi,
        hex: Hi
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  },
  ColorPicker: {
    presetEmpty: "Empty"
  }
};
Object.assign({}, ks.Modal);
let $y = [];
const zI = () => $y.reduce((e, t) => Object.assign(Object.assign({}, e), t), ks.Modal);
function GQ(e) {
  if (e) {
    const t = Object.assign({}, e);
    return $y.push(t), zI(), () => {
      $y = $y.filter((r) => r !== t), zI();
    };
  }
  Object.assign({}, ks.Modal);
}
const qT = /* @__PURE__ */ Xl(void 0), hz = (e, t) => {
  const r = T.useContext(qT), n = T.useMemo(() => {
    var o;
    const a = t || ks[e], s = (o = r == null ? void 0 : r[e]) !== null && o !== void 0 ? o : {};
    return Object.assign(Object.assign({}, typeof a == "function" ? a() : a), s || {});
  }, [e, t, r]), i = T.useMemo(() => {
    const o = r == null ? void 0 : r.locale;
    return r != null && r.exist && !o ? ks.locale : o;
  }, [r]);
  return [n, i];
}, fz = "internalMark", pz = (e) => {
  const {
    locale: t = {},
    children: r,
    _ANT_MARK__: n
  } = e;
  if (process.env.NODE_ENV !== "production") {
    const o = mn("LocaleProvider");
    process.env.NODE_ENV !== "production" && o(n === fz, "deprecated", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead: http://u.ant.design/locale");
  }
  T.useEffect(() => GQ(t == null ? void 0 : t.Modal), [t]);
  const i = T.useMemo(() => Object.assign(Object.assign({}, t), {
    exist: !0
  }), [t]);
  return /* @__PURE__ */ T.createElement(qT.Provider, {
    value: i
  }, r);
};
process.env.NODE_ENV !== "production" && (pz.displayName = "LocaleProvider");
function On(e, t) {
  HQ(e) && (e = "100%");
  var r = zQ(e);
  return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), r && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
}
function tm(e) {
  return Math.min(1, Math.max(0, e));
}
function HQ(e) {
  return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
}
function zQ(e) {
  return typeof e == "string" && e.indexOf("%") !== -1;
}
function gz(e) {
  return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function rm(e) {
  return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
}
function Qu(e) {
  return e.length === 1 ? "0" + e : String(e);
}
function $Q(e, t, r) {
  return {
    r: On(e, 255) * 255,
    g: On(t, 255) * 255,
    b: On(r, 255) * 255
  };
}
function $I(e, t, r) {
  e = On(e, 255), t = On(t, 255), r = On(r, 255);
  var n = Math.max(e, t, r), i = Math.min(e, t, r), o = 0, a = 0, s = (n + i) / 2;
  if (n === i)
    a = 0, o = 0;
  else {
    var l = n - i;
    switch (a = s > 0.5 ? l / (2 - n - i) : l / (n + i), n) {
      case e:
        o = (t - r) / l + (t < r ? 6 : 0);
        break;
      case t:
        o = (r - e) / l + 2;
        break;
      case r:
        o = (e - t) / l + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: a, l: s };
}
function Dw(e, t, r) {
  return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + (t - e) * (6 * r) : r < 1 / 2 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function WQ(e, t, r) {
  var n, i, o;
  if (e = On(e, 360), t = On(t, 100), r = On(r, 100), t === 0)
    i = r, o = r, n = r;
  else {
    var a = r < 0.5 ? r * (1 + t) : r + t - r * t, s = 2 * r - a;
    n = Dw(s, a, e + 1 / 3), i = Dw(s, a, e), o = Dw(s, a, e - 1 / 3);
  }
  return { r: n * 255, g: i * 255, b: o * 255 };
}
function PE(e, t, r) {
  e = On(e, 255), t = On(t, 255), r = On(r, 255);
  var n = Math.max(e, t, r), i = Math.min(e, t, r), o = 0, a = n, s = n - i, l = n === 0 ? 0 : s / n;
  if (n === i)
    o = 0;
  else {
    switch (n) {
      case e:
        o = (t - r) / s + (t < r ? 6 : 0);
        break;
      case t:
        o = (r - e) / s + 2;
        break;
      case r:
        o = (e - t) / s + 4;
        break;
    }
    o /= 6;
  }
  return { h: o, s: l, v: a };
}
function jQ(e, t, r) {
  e = On(e, 360) * 6, t = On(t, 100), r = On(r, 100);
  var n = Math.floor(e), i = e - n, o = r * (1 - t), a = r * (1 - i * t), s = r * (1 - (1 - i) * t), l = n % 6, u = [r, a, o, o, s, r][l], c = [s, r, r, a, o, o][l], d = [o, o, s, r, r, a][l];
  return { r: u * 255, g: c * 255, b: d * 255 };
}
function ME(e, t, r, n) {
  var i = [
    Qu(Math.round(e).toString(16)),
    Qu(Math.round(t).toString(16)),
    Qu(Math.round(r).toString(16))
  ];
  return n && i[0].startsWith(i[0].charAt(1)) && i[1].startsWith(i[1].charAt(1)) && i[2].startsWith(i[2].charAt(1)) ? i[0].charAt(0) + i[1].charAt(0) + i[2].charAt(0) : i.join("");
}
function UQ(e, t, r, n, i) {
  var o = [
    Qu(Math.round(e).toString(16)),
    Qu(Math.round(t).toString(16)),
    Qu(Math.round(r).toString(16)),
    Qu(KQ(n))
  ];
  return i && o[0].startsWith(o[0].charAt(1)) && o[1].startsWith(o[1].charAt(1)) && o[2].startsWith(o[2].charAt(1)) && o[3].startsWith(o[3].charAt(1)) ? o[0].charAt(0) + o[1].charAt(0) + o[2].charAt(0) + o[3].charAt(0) : o.join("");
}
function KQ(e) {
  return Math.round(parseFloat(e) * 255).toString(16);
}
function WI(e) {
  return ji(e) / 255;
}
function ji(e) {
  return parseInt(e, 16);
}
function YQ(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255
  };
}
var DE = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function $d(e) {
  var t = { r: 0, g: 0, b: 0 }, r = 1, n = null, i = null, o = null, a = !1, s = !1;
  return typeof e == "string" && (e = XQ(e)), typeof e == "object" && (ds(e.r) && ds(e.g) && ds(e.b) ? (t = $Q(e.r, e.g, e.b), a = !0, s = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : ds(e.h) && ds(e.s) && ds(e.v) ? (n = rm(e.s), i = rm(e.v), t = jQ(e.h, n, i), a = !0, s = "hsv") : ds(e.h) && ds(e.s) && ds(e.l) && (n = rm(e.s), o = rm(e.l), t = WQ(e.h, n, o), a = !0, s = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (r = e.a)), r = gz(r), {
    ok: a,
    format: e.format || s,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: r
  };
}
var qQ = "[-\\+]?\\d+%?", ZQ = "[-\\+]?\\d*\\.\\d+%?", xl = "(?:".concat(ZQ, ")|(?:").concat(qQ, ")"), Aw = "[\\s|\\(]+(".concat(xl, ")[,|\\s]+(").concat(xl, ")[,|\\s]+(").concat(xl, ")\\s*\\)?"), Iw = "[\\s|\\(]+(".concat(xl, ")[,|\\s]+(").concat(xl, ")[,|\\s]+(").concat(xl, ")[,|\\s]+(").concat(xl, ")\\s*\\)?"), Zo = {
  CSS_UNIT: new RegExp(xl),
  rgb: new RegExp("rgb" + Aw),
  rgba: new RegExp("rgba" + Iw),
  hsl: new RegExp("hsl" + Aw),
  hsla: new RegExp("hsla" + Iw),
  hsv: new RegExp("hsv" + Aw),
  hsva: new RegExp("hsva" + Iw),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function XQ(e) {
  if (e = e.trim().toLowerCase(), e.length === 0)
    return !1;
  var t = !1;
  if (DE[e])
    e = DE[e], t = !0;
  else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var r = Zo.rgb.exec(e);
  return r ? { r: r[1], g: r[2], b: r[3] } : (r = Zo.rgba.exec(e), r ? { r: r[1], g: r[2], b: r[3], a: r[4] } : (r = Zo.hsl.exec(e), r ? { h: r[1], s: r[2], l: r[3] } : (r = Zo.hsla.exec(e), r ? { h: r[1], s: r[2], l: r[3], a: r[4] } : (r = Zo.hsv.exec(e), r ? { h: r[1], s: r[2], v: r[3] } : (r = Zo.hsva.exec(e), r ? { h: r[1], s: r[2], v: r[3], a: r[4] } : (r = Zo.hex8.exec(e), r ? {
    r: ji(r[1]),
    g: ji(r[2]),
    b: ji(r[3]),
    a: WI(r[4]),
    format: t ? "name" : "hex8"
  } : (r = Zo.hex6.exec(e), r ? {
    r: ji(r[1]),
    g: ji(r[2]),
    b: ji(r[3]),
    format: t ? "name" : "hex"
  } : (r = Zo.hex4.exec(e), r ? {
    r: ji(r[1] + r[1]),
    g: ji(r[2] + r[2]),
    b: ji(r[3] + r[3]),
    a: WI(r[4] + r[4]),
    format: t ? "name" : "hex8"
  } : (r = Zo.hex3.exec(e), r ? {
    r: ji(r[1] + r[1]),
    g: ji(r[2] + r[2]),
    b: ji(r[3] + r[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function ds(e) {
  return !!Zo.CSS_UNIT.exec(String(e));
}
var ln = (
  /** @class */
  function() {
    function e(t, r) {
      t === void 0 && (t = ""), r === void 0 && (r = {});
      var n;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = YQ(t)), this.originalInput = t;
      var i = $d(t);
      this.originalInput = t, this.r = i.r, this.g = i.g, this.b = i.b, this.a = i.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (n = r.format) !== null && n !== void 0 ? n : i.format, this.gradientType = r.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = i.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), r, n, i, o = t.r / 255, a = t.g / 255, s = t.b / 255;
      return o <= 0.03928 ? r = o / 12.92 : r = Math.pow((o + 0.055) / 1.055, 2.4), a <= 0.03928 ? n = a / 12.92 : n = Math.pow((a + 0.055) / 1.055, 2.4), s <= 0.03928 ? i = s / 12.92 : i = Math.pow((s + 0.055) / 1.055, 2.4), 0.2126 * r + 0.7152 * n + 0.0722 * i;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = gz(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = PE(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = PE(this.r, this.g, this.b), r = Math.round(t.h * 360), n = Math.round(t.s * 100), i = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(r, ", ").concat(n, "%, ").concat(i, "%)") : "hsva(".concat(r, ", ").concat(n, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = $I(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = $I(this.r, this.g, this.b), r = Math.round(t.h * 360), n = Math.round(t.s * 100), i = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(r, ", ").concat(n, "%, ").concat(i, "%)") : "hsla(".concat(r, ", ").concat(n, "%, ").concat(i, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), ME(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), UQ(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), r = Math.round(this.g), n = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(r, ", ").concat(n, ")") : "rgba(".concat(t, ", ").concat(r, ", ").concat(n, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(r) {
        return "".concat(Math.round(On(r, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(r) {
        return Math.round(On(r, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + ME(this.r, this.g, this.b, !1), r = 0, n = Object.entries(DE); r < n.length; r++) {
        var i = n[r], o = i[0], a = i[1];
        if (t === a)
          return o;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var r = !!t;
      t = t ?? this.format;
      var n = !1, i = this.a < 1 && this.a >= 0, o = !r && i && (t.startsWith("hex") || t === "name");
      return o ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (n = this.toRgbString()), t === "prgb" && (n = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (n = this.toHexString()), t === "hex3" && (n = this.toHexString(!0)), t === "hex4" && (n = this.toHex8String(!0)), t === "hex8" && (n = this.toHex8String()), t === "name" && (n = this.toName()), t === "hsl" && (n = this.toHslString()), t === "hsv" && (n = this.toHsvString()), n || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.l += t / 100, r.l = tm(r.l), new e(r);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var r = this.toRgb();
      return r.r = Math.max(0, Math.min(255, r.r - Math.round(255 * -(t / 100)))), r.g = Math.max(0, Math.min(255, r.g - Math.round(255 * -(t / 100)))), r.b = Math.max(0, Math.min(255, r.b - Math.round(255 * -(t / 100)))), new e(r);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.l -= t / 100, r.l = tm(r.l), new e(r);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.s -= t / 100, r.s = tm(r.s), new e(r);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var r = this.toHsl();
      return r.s += t / 100, r.s = tm(r.s), new e(r);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var r = this.toHsl(), n = (r.h + t) % 360;
      return r.h = n < 0 ? 360 + n : n, new e(r);
    }, e.prototype.mix = function(t, r) {
      r === void 0 && (r = 50);
      var n = this.toRgb(), i = new e(t).toRgb(), o = r / 100, a = {
        r: (i.r - n.r) * o + n.r,
        g: (i.g - n.g) * o + n.g,
        b: (i.b - n.b) * o + n.b,
        a: (i.a - n.a) * o + n.a
      };
      return new e(a);
    }, e.prototype.analogous = function(t, r) {
      t === void 0 && (t = 6), r === void 0 && (r = 30);
      var n = this.toHsl(), i = 360 / r, o = [this];
      for (n.h = (n.h - (i * t >> 1) + 720) % 360; --t; )
        n.h = (n.h + i) % 360, o.push(new e(n));
      return o;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var r = this.toHsv(), n = r.h, i = r.s, o = r.v, a = [], s = 1 / t; t--; )
        a.push(new e({ h: n, s: i, v: o })), o = (o + s) % 1;
      return a;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), r = t.h;
      return [
        this,
        new e({ h: (r + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (r + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var r = this.toRgb(), n = new e(t).toRgb(), i = r.a + n.a * (1 - r.a);
      return new e({
        r: (r.r * r.a + n.r * n.a * (1 - r.a)) / i,
        g: (r.g * r.a + n.g * n.a * (1 - r.a)) / i,
        b: (r.b * r.a + n.b * n.a * (1 - r.a)) / i,
        a: i
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var r = this.toHsl(), n = r.h, i = [this], o = 360 / t, a = 1; a < t; a++)
        i.push(new e({ h: (n + a * o) % 360, s: r.s, l: r.l }));
      return i;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }()
), nm = 2, jI = 0.16, QQ = 0.05, JQ = 0.05, eJ = 0.15, vz = 5, mz = 4, tJ = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function UI(e) {
  var t = e.r, r = e.g, n = e.b, i = PE(t, r, n);
  return {
    h: i.h * 360,
    s: i.s,
    v: i.v
  };
}
function im(e) {
  var t = e.r, r = e.g, n = e.b;
  return "#".concat(ME(t, r, n, !1));
}
function rJ(e, t, r) {
  var n = r / 100, i = {
    r: (t.r - e.r) * n + e.r,
    g: (t.g - e.g) * n + e.g,
    b: (t.b - e.b) * n + e.b
  };
  return i;
}
function KI(e, t, r) {
  var n;
  return Math.round(e.h) >= 60 && Math.round(e.h) <= 240 ? n = r ? Math.round(e.h) - nm * t : Math.round(e.h) + nm * t : n = r ? Math.round(e.h) + nm * t : Math.round(e.h) - nm * t, n < 0 ? n += 360 : n >= 360 && (n -= 360), n;
}
function YI(e, t, r) {
  if (e.h === 0 && e.s === 0)
    return e.s;
  var n;
  return r ? n = e.s - jI * t : t === mz ? n = e.s + jI : n = e.s + QQ * t, n > 1 && (n = 1), r && t === vz && n > 0.1 && (n = 0.1), n < 0.06 && (n = 0.06), Number(n.toFixed(2));
}
function qI(e, t, r) {
  var n;
  return r ? n = e.v + JQ * t : n = e.v - eJ * t, n > 1 && (n = 1), Number(n.toFixed(2));
}
function wg(e) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = [], n = $d(e), i = vz; i > 0; i -= 1) {
    var o = UI(n), a = im($d({
      h: KI(o, i, !0),
      s: YI(o, i, !0),
      v: qI(o, i, !0)
    }));
    r.push(a);
  }
  r.push(im(n));
  for (var s = 1; s <= mz; s += 1) {
    var l = UI(n), u = im($d({
      h: KI(l, s),
      s: YI(l, s),
      v: qI(l, s)
    }));
    r.push(u);
  }
  return t.theme === "dark" ? tJ.map(function(c) {
    var d = c.index, h = c.opacity, f = im(rJ($d(t.backgroundColor || "#141414"), $d(r[d]), h * 100));
    return f;
  }) : r;
}
var AE = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
AE.primary = AE[5];
var IE = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
IE.primary = IE[5];
const yz = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, bg = Object.assign(Object.assign({}, yz), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorLink: "",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontFamilyCode: "'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace",
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1,
  // Motion
  motion: !0
});
function nJ(e, t) {
  let {
    generateColorPalettes: r,
    generateNeutralColorPalettes: n
  } = t;
  const {
    colorSuccess: i,
    colorWarning: o,
    colorError: a,
    colorInfo: s,
    colorPrimary: l,
    colorBgBase: u,
    colorTextBase: c
  } = e, d = r(l), h = r(i), f = r(o), p = r(a), g = r(s), v = n(u, c), m = e.colorLink || e.colorInfo, y = r(m);
  return Object.assign(Object.assign({}, v), {
    colorPrimaryBg: d[1],
    colorPrimaryBgHover: d[2],
    colorPrimaryBorder: d[3],
    colorPrimaryBorderHover: d[4],
    colorPrimaryHover: d[5],
    colorPrimary: d[6],
    colorPrimaryActive: d[7],
    colorPrimaryTextHover: d[8],
    colorPrimaryText: d[9],
    colorPrimaryTextActive: d[10],
    colorSuccessBg: h[1],
    colorSuccessBgHover: h[2],
    colorSuccessBorder: h[3],
    colorSuccessBorderHover: h[4],
    colorSuccessHover: h[4],
    colorSuccess: h[6],
    colorSuccessActive: h[7],
    colorSuccessTextHover: h[8],
    colorSuccessText: h[9],
    colorSuccessTextActive: h[10],
    colorErrorBg: p[1],
    colorErrorBgHover: p[2],
    colorErrorBgActive: p[3],
    colorErrorBorder: p[3],
    colorErrorBorderHover: p[4],
    colorErrorHover: p[5],
    colorError: p[6],
    colorErrorActive: p[7],
    colorErrorTextHover: p[8],
    colorErrorText: p[9],
    colorErrorTextActive: p[10],
    colorWarningBg: f[1],
    colorWarningBgHover: f[2],
    colorWarningBorder: f[3],
    colorWarningBorderHover: f[4],
    colorWarningHover: f[4],
    colorWarning: f[6],
    colorWarningActive: f[7],
    colorWarningTextHover: f[8],
    colorWarningText: f[9],
    colorWarningTextActive: f[10],
    colorInfoBg: g[1],
    colorInfoBgHover: g[2],
    colorInfoBorder: g[3],
    colorInfoBorderHover: g[4],
    colorInfoHover: g[4],
    colorInfo: g[6],
    colorInfoActive: g[7],
    colorInfoTextHover: g[8],
    colorInfoText: g[9],
    colorInfoTextActive: g[10],
    colorLinkHover: y[4],
    colorLink: y[6],
    colorLinkActive: y[7],
    colorBgMask: new ln("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const iJ = (e) => {
  let t = e, r = e, n = e, i = e;
  return e < 6 && e >= 5 ? t = e + 1 : e < 16 && e >= 6 ? t = e + 2 : e >= 16 && (t = 16), e < 7 && e >= 5 ? r = 4 : e < 8 && e >= 7 ? r = 5 : e < 14 && e >= 8 ? r = 6 : e < 16 && e >= 14 ? r = 7 : e >= 16 && (r = 8), e < 6 && e >= 2 ? n = 1 : e >= 6 && (n = 2), e > 4 && e < 8 ? i = 4 : e >= 8 && (i = 6), {
    borderRadius: e,
    borderRadiusXS: n,
    borderRadiusSM: r,
    borderRadiusLG: t,
    borderRadiusOuter: i
  };
};
function oJ(e) {
  const {
    motionUnit: t,
    motionBase: r,
    borderRadius: n,
    lineWidth: i
  } = e;
  return Object.assign({
    // motion
    motionDurationFast: `${(r + t).toFixed(1)}s`,
    motionDurationMid: `${(r + t * 2).toFixed(1)}s`,
    motionDurationSlow: `${(r + t * 3).toFixed(1)}s`,
    // line
    lineWidthBold: i + 1
  }, iJ(n));
}
const aJ = (e) => {
  const {
    controlHeight: t
  } = e;
  return {
    controlHeightSM: t * 0.75,
    controlHeightXS: t * 0.5,
    controlHeightLG: t * 1.25
  };
};
function Wy(e) {
  return (e + 8) / e;
}
function sJ(e) {
  const t = new Array(10).fill(null).map((r, n) => {
    const i = n - 1, o = e * Math.pow(Math.E, i / 5), a = n > 1 ? Math.floor(o) : Math.ceil(o);
    return Math.floor(a / 2) * 2;
  });
  return t[1] = e, t.map((r) => ({
    size: r,
    lineHeight: Wy(r)
  }));
}
const lJ = (e) => {
  const t = sJ(e), r = t.map((c) => c.size), n = t.map((c) => c.lineHeight), i = r[1], o = r[0], a = r[2], s = n[1], l = n[0], u = n[2];
  return {
    fontSizeSM: o,
    fontSize: i,
    fontSizeLG: a,
    fontSizeXL: r[3],
    fontSizeHeading1: r[6],
    fontSizeHeading2: r[5],
    fontSizeHeading3: r[4],
    fontSizeHeading4: r[3],
    fontSizeHeading5: r[2],
    lineHeight: s,
    lineHeightLG: u,
    lineHeightSM: l,
    fontHeight: Math.round(s * i),
    fontHeightLG: Math.round(u * a),
    fontHeightSM: Math.round(l * o),
    lineHeightHeading1: n[6],
    lineHeightHeading2: n[5],
    lineHeightHeading3: n[4],
    lineHeightHeading4: n[3],
    lineHeightHeading5: n[2]
  };
};
function uJ(e) {
  const {
    sizeUnit: t,
    sizeStep: r
  } = e;
  return {
    sizeXXL: t * (r + 8),
    // 48
    sizeXL: t * (r + 4),
    // 32
    sizeLG: t * (r + 2),
    // 24
    sizeMD: t * (r + 1),
    // 20
    sizeMS: t * r,
    // 16
    size: t * r,
    // 16
    sizeSM: t * (r - 1),
    // 12
    sizeXS: t * (r - 2),
    // 8
    sizeXXS: t * (r - 3)
    // 4
  };
}
const hs = (e, t) => new ln(e).setAlpha(t).toRgbString(), Nf = (e, t) => new ln(e).darken(t).toHexString(), cJ = (e) => {
  const t = wg(e);
  return {
    1: t[0],
    2: t[1],
    3: t[2],
    4: t[3],
    5: t[4],
    6: t[5],
    7: t[6],
    8: t[4],
    9: t[5],
    10: t[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, dJ = (e, t) => {
  const r = e || "#fff", n = t || "#000";
  return {
    colorBgBase: r,
    colorTextBase: n,
    colorText: hs(n, 0.88),
    colorTextSecondary: hs(n, 0.65),
    colorTextTertiary: hs(n, 0.45),
    colorTextQuaternary: hs(n, 0.25),
    colorFill: hs(n, 0.15),
    colorFillSecondary: hs(n, 0.06),
    colorFillTertiary: hs(n, 0.04),
    colorFillQuaternary: hs(n, 0.02),
    colorBgLayout: Nf(r, 4),
    colorBgContainer: Nf(r, 0),
    colorBgElevated: Nf(r, 0),
    colorBgSpotlight: hs(n, 0.85),
    colorBgBlur: "transparent",
    colorBorder: Nf(r, 15),
    colorBorderSecondary: Nf(r, 6)
  };
};
function hJ(e) {
  const t = Object.keys(yz).map((r) => {
    const n = wg(e[r]);
    return new Array(10).fill(1).reduce((i, o, a) => (i[`${r}-${a + 1}`] = n[a], i[`${r}${a + 1}`] = n[a], i), {});
  }).reduce((r, n) => (r = Object.assign(Object.assign({}, r), n), r), {});
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, e), t), nJ(e, {
    generateColorPalettes: cJ,
    generateNeutralColorPalettes: dJ
  })), lJ(e.fontSize)), uJ(e)), aJ(e)), oJ(e));
}
const Cz = SE(hJ), FE = {
  token: bg,
  override: {
    override: bg
  },
  hashed: !0
}, Sz = /* @__PURE__ */ H.createContext(FE), wz = "anticon", fJ = ["outlined", "borderless", "filled"], pJ = (e, t) => t || (e ? `ant-${e}` : "ant"), Xt = /* @__PURE__ */ T.createContext({
  // We provide a default function for Context without provider
  getPrefixCls: pJ,
  iconPrefixCls: wz
}), gJ = `-ant-${Date.now()}-${Math.random()}`;
function vJ(e, t) {
  const r = {}, n = (a, s) => {
    let l = a.clone();
    return l = (s == null ? void 0 : s(l)) || l, l.toRgbString();
  }, i = (a, s) => {
    const l = new ln(a), u = wg(l.toRgbString());
    r[`${s}-color`] = n(l), r[`${s}-color-disabled`] = u[1], r[`${s}-color-hover`] = u[4], r[`${s}-color-active`] = u[6], r[`${s}-color-outline`] = l.clone().setAlpha(0.2).toRgbString(), r[`${s}-color-deprecated-bg`] = u[0], r[`${s}-color-deprecated-border`] = u[2];
  };
  if (t.primaryColor) {
    i(t.primaryColor, "primary");
    const a = new ln(t.primaryColor), s = wg(a.toRgbString());
    s.forEach((u, c) => {
      r[`primary-${c + 1}`] = u;
    }), r["primary-color-deprecated-l-35"] = n(a, (u) => u.lighten(35)), r["primary-color-deprecated-l-20"] = n(a, (u) => u.lighten(20)), r["primary-color-deprecated-t-20"] = n(a, (u) => u.tint(20)), r["primary-color-deprecated-t-50"] = n(a, (u) => u.tint(50)), r["primary-color-deprecated-f-12"] = n(a, (u) => u.setAlpha(u.getAlpha() * 0.12));
    const l = new ln(s[0]);
    r["primary-color-active-deprecated-f-30"] = n(l, (u) => u.setAlpha(u.getAlpha() * 0.3)), r["primary-color-active-deprecated-d-02"] = n(l, (u) => u.darken(2));
  }
  return t.successColor && i(t.successColor, "success"), t.warningColor && i(t.warningColor, "warning"), t.errorColor && i(t.errorColor, "error"), t.infoColor && i(t.infoColor, "info"), `
  :root {
    ${Object.keys(r).map((a) => `--${e}-${a}: ${r[a]};`).join(`
`)}
  }
  `.trim();
}
function mJ(e, t) {
  const r = vJ(e, t);
  mi() ? Ms(r, `${gJ}-dynamic-theme`) : process.env.NODE_ENV !== "production" && qh(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
const _h = /* @__PURE__ */ T.createContext(!1), yJ = (e) => {
  let {
    children: t,
    disabled: r
  } = e;
  const n = T.useContext(_h);
  return /* @__PURE__ */ T.createElement(_h.Provider, {
    value: r ?? n
  }, t);
}, Th = /* @__PURE__ */ T.createContext(void 0), CJ = (e) => {
  let {
    children: t,
    size: r
  } = e;
  const n = T.useContext(Th);
  return /* @__PURE__ */ T.createElement(Th.Provider, {
    value: r || n
  }, t);
};
function SJ() {
  const e = rr(_h), t = rr(Th);
  return {
    componentDisabled: e,
    componentSize: t
  };
}
const xg = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"], wJ = "5.19.0";
function Fw(e) {
  return e >= 0 && e <= 255;
}
function om(e, t) {
  const {
    r,
    g: n,
    b: i,
    a: o
  } = new ln(e).toRgb();
  if (o < 1)
    return e;
  const {
    r: a,
    g: s,
    b: l
  } = new ln(t).toRgb();
  for (let u = 0.01; u <= 1; u += 0.01) {
    const c = Math.round((r - a * (1 - u)) / u), d = Math.round((n - s * (1 - u)) / u), h = Math.round((i - l * (1 - u)) / u);
    if (Fw(c) && Fw(d) && Fw(h))
      return new ln({
        r: c,
        g: d,
        b: h,
        a: Math.round(u * 100) / 100
      }).toRgbString();
  }
  return new ln({
    r,
    g: n,
    b: i,
    a: 1
  }).toRgbString();
}
var bJ = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function bz(e) {
  const {
    override: t
  } = e, r = bJ(e, ["override"]), n = Object.assign({}, t);
  Object.keys(bg).forEach((h) => {
    delete n[h];
  });
  const i = Object.assign(Object.assign({}, r), n), o = 480, a = 576, s = 768, l = 992, u = 1200, c = 1600;
  if (i.motion === !1) {
    const h = "0s";
    i.motionDurationFast = h, i.motionDurationMid = h, i.motionDurationSlow = h;
  }
  return Object.assign(Object.assign(Object.assign({}, i), {
    // ============== Background ============== //
    colorFillContent: i.colorFillSecondary,
    colorFillContentHover: i.colorFill,
    colorFillAlter: i.colorFillQuaternary,
    colorBgContainerDisabled: i.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: i.colorBgContainer,
    colorSplit: om(i.colorBorderSecondary, i.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: i.colorTextQuaternary,
    colorTextDisabled: i.colorTextQuaternary,
    colorTextHeading: i.colorText,
    colorTextLabel: i.colorTextSecondary,
    colorTextDescription: i.colorTextTertiary,
    colorTextLightSolid: i.colorWhite,
    colorHighlight: i.colorError,
    colorBgTextHover: i.colorFillSecondary,
    colorBgTextActive: i.colorFill,
    colorIcon: i.colorTextTertiary,
    colorIconHover: i.colorText,
    colorErrorOutline: om(i.colorErrorBg, i.colorBgContainer),
    colorWarningOutline: om(i.colorWarningBg, i.colorBgContainer),
    // Font
    fontSizeIcon: i.fontSizeSM,
    // Line
    lineWidthFocus: i.lineWidth * 4,
    // Control
    lineWidth: i.lineWidth,
    controlOutlineWidth: i.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: i.controlHeight / 2,
    controlItemBgHover: i.colorFillTertiary,
    controlItemBgActive: i.colorPrimaryBg,
    controlItemBgActiveHover: i.colorPrimaryBgHover,
    controlItemBgActiveDisabled: i.colorFill,
    controlTmpOutline: i.colorFillQuaternary,
    controlOutline: om(i.colorPrimaryBg, i.colorBgContainer),
    lineType: i.lineType,
    borderRadius: i.borderRadius,
    borderRadiusXS: i.borderRadiusXS,
    borderRadiusSM: i.borderRadiusSM,
    borderRadiusLG: i.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: i.sizeXXS,
    paddingXS: i.sizeXS,
    paddingSM: i.sizeSM,
    padding: i.size,
    paddingMD: i.sizeMD,
    paddingLG: i.sizeLG,
    paddingXL: i.sizeXL,
    paddingContentHorizontalLG: i.sizeLG,
    paddingContentVerticalLG: i.sizeMS,
    paddingContentHorizontal: i.sizeMS,
    paddingContentVertical: i.sizeSM,
    paddingContentHorizontalSM: i.size,
    paddingContentVerticalSM: i.sizeXS,
    marginXXS: i.sizeXXS,
    marginXS: i.sizeXS,
    marginSM: i.sizeSM,
    margin: i.size,
    marginMD: i.sizeMD,
    marginLG: i.sizeLG,
    marginXL: i.sizeXL,
    marginXXL: i.sizeXXL,
    boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS: o,
    screenXSMin: o,
    screenXSMax: a - 1,
    screenSM: a,
    screenSMMin: a,
    screenSMMax: s - 1,
    screenMD: s,
    screenMDMin: s,
    screenMDMax: l - 1,
    screenLG: l,
    screenLGMin: l,
    screenLGMax: u - 1,
    screenXL: u,
    screenXLMin: u,
    screenXLMax: c - 1,
    screenXXL: c,
    screenXXLMin: c,
    boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
    boxShadowCard: `
      0 1px 2px -2px ${new ln("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new ln("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new ln("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), n);
}
var ZI = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const xz = {
  lineHeight: !0,
  lineHeightSM: !0,
  lineHeightLG: !0,
  lineHeightHeading1: !0,
  lineHeightHeading2: !0,
  lineHeightHeading3: !0,
  lineHeightHeading4: !0,
  lineHeightHeading5: !0,
  opacityLoading: !0,
  fontWeightStrong: !0,
  zIndexPopupBase: !0,
  zIndexBase: !0
}, Ez = {
  size: !0,
  sizeSM: !0,
  sizeLG: !0,
  sizeMD: !0,
  sizeXS: !0,
  sizeXXS: !0,
  sizeMS: !0,
  sizeXL: !0,
  sizeXXL: !0,
  sizeUnit: !0,
  sizeStep: !0,
  motionBase: !0,
  motionUnit: !0
}, xJ = {
  screenXS: !0,
  screenXSMin: !0,
  screenXSMax: !0,
  screenSM: !0,
  screenSMMin: !0,
  screenSMMax: !0,
  screenMD: !0,
  screenMDMin: !0,
  screenMDMax: !0,
  screenLG: !0,
  screenLGMin: !0,
  screenLGMax: !0,
  screenXL: !0,
  screenXLMin: !0,
  screenXLMax: !0,
  screenXXL: !0,
  screenXXLMin: !0
}, Rz = (e, t, r) => {
  const n = r.getDerivativeToken(e), {
    override: i
  } = t, o = ZI(t, ["override"]);
  let a = Object.assign(Object.assign({}, n), {
    override: i
  });
  return a = bz(a), o && Object.entries(o).forEach((s) => {
    let [l, u] = s;
    const {
      theme: c
    } = u, d = ZI(u, ["theme"]);
    let h = d;
    c && (h = Rz(Object.assign(Object.assign({}, a), d), {
      override: d
    }, c)), a[l] = h;
  }), a;
};
function Xa() {
  const {
    token: e,
    hashed: t,
    theme: r,
    override: n,
    cssVar: i
  } = H.useContext(Sz), o = `${wJ}-${t || ""}`, a = r || Cz, [s, l, u] = rQ(a, [bg, e], {
    salt: o,
    override: n,
    getComputedToken: Rz,
    // formatToken will not be consumed after 1.15.0 with getComputedToken.
    // But token will break if @ant-design/cssinjs is under 1.15.0 without it
    formatToken: bz,
    cssVar: i && {
      prefix: i.prefix,
      key: i.key,
      unitless: xz,
      ignore: Ez,
      preserve: xJ
    }
  });
  return [a, u, t ? l : "", s, i];
}
function Mn(e) {
  var t = T.useRef();
  t.current = e;
  var r = T.useCallback(function() {
    for (var n, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return (n = t.current) === null || n === void 0 ? void 0 : n.call.apply(n, [t].concat(o));
  }, []);
  return r;
}
function Ph(e) {
  var t = T.useRef(!1), r = T.useState(e), n = ue(r, 2), i = n[0], o = n[1];
  T.useEffect(function() {
    return t.current = !1, function() {
      t.current = !0;
    };
  }, []);
  function a(s, l) {
    l && t.current || o(s);
  }
  return [i, a];
}
function Lw(e) {
  return e !== void 0;
}
function Nn(e, t) {
  var r = t || {}, n = r.defaultValue, i = r.value, o = r.onChange, a = r.postState, s = Ph(function() {
    return Lw(i) ? i : Lw(n) ? typeof n == "function" ? n() : n : typeof e == "function" ? e() : e;
  }), l = ue(s, 2), u = l[0], c = l[1], d = i !== void 0 ? i : u, h = a ? a(d) : d, f = Mn(o), p = Ph([d]), g = ue(p, 2), v = g[0], m = g[1];
  bE(function() {
    var C = v[0];
    u !== C && f(u, C);
  }, [v]), bE(function() {
    Lw(i) || c(i);
  }, [i]);
  var y = Mn(function(C, S) {
    c(C, S), m([d], S);
  });
  return [h, y];
}
const EJ = 1e3 * 60 * 10;
let RJ = /* @__PURE__ */ function() {
  function e() {
    Hn(this, e), this.map = /* @__PURE__ */ new Map(), this.objectIDMap = /* @__PURE__ */ new WeakMap(), this.nextID = 0, this.lastAccessBeat = /* @__PURE__ */ new Map(), this.accessBeat = 0;
  }
  return zn(e, [{
    key: "set",
    value: function(r, n) {
      this.clear();
      const i = this.getCompositeKey(r);
      this.map.set(i, n), this.lastAccessBeat.set(i, Date.now());
    }
  }, {
    key: "get",
    value: function(r) {
      const n = this.getCompositeKey(r), i = this.map.get(n);
      return this.lastAccessBeat.set(n, Date.now()), this.accessBeat += 1, i;
    }
  }, {
    key: "getCompositeKey",
    value: function(r) {
      return r.map((i) => i && typeof i == "object" ? `obj_${this.getObjectID(i)}` : `${typeof i}_${i}`).join("|");
    }
  }, {
    key: "getObjectID",
    value: function(r) {
      if (this.objectIDMap.has(r))
        return this.objectIDMap.get(r);
      const n = this.nextID;
      return this.objectIDMap.set(r, n), this.nextID += 1, n;
    }
  }, {
    key: "clear",
    value: function() {
      if (this.accessBeat > 1e4) {
        const r = Date.now();
        this.lastAccessBeat.forEach((n, i) => {
          r - n > EJ && (this.map.delete(i), this.lastAccessBeat.delete(i));
        }), this.accessBeat = 0;
      }
    }
  }]);
}();
const XI = new RJ();
function _J(e, t) {
  return H.useMemo(() => {
    const r = XI.get(t);
    if (r)
      return r;
    const n = e();
    return XI.set(t, n), n;
  }, t);
}
const _z = (e) => ({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: e.colorLink,
  textDecoration: "none",
  outline: "none",
  cursor: "pointer",
  transition: `color ${e.motionDurationSlow}`,
  "&:focus, &:hover": {
    color: e.colorLinkHover
  },
  "&:active": {
    color: e.colorLinkActive
  }
}), rS = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
}, Xs = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return {
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: e.colorText,
    fontSize: e.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: e.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: t ? "inherit" : e.fontFamily
  };
}, TJ = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), lv = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), PJ = (e) => ({
  a: {
    color: e.colorLink,
    textDecoration: e.linkDecoration,
    backgroundColor: "transparent",
    // remove the gray background on active links in IE 10.
    outline: "none",
    cursor: "pointer",
    transition: `color ${e.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    // remove gaps in links underline in iOS 8+ and Safari 8+.
    "&:hover": {
      color: e.colorLinkHover
    },
    "&:active": {
      color: e.colorLinkActive
    },
    "&:active, &:hover": {
      textDecoration: e.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: e.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: e.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), MJ = (e, t, r, n) => {
  const i = `[class^="${t}"], [class*=" ${t}"]`, o = r ? `.${r}` : i, a = {
    boxSizing: "border-box",
    "&::before, &::after": {
      boxSizing: "border-box"
    }
  };
  let s = {};
  return n !== !1 && (s = {
    fontFamily: e.fontFamily,
    fontSize: e.fontSize
  }), {
    [o]: Object.assign(Object.assign(Object.assign({}, s), a), {
      [i]: a
    })
  };
}, DJ = (e) => ({
  outline: `${xe(e.lineWidthFocus)} solid ${e.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), nS = (e) => ({
  "&:focus-visible": Object.assign({}, DJ(e))
});
function AJ(e) {
  return e === "js" ? {
    max: Math.max,
    min: Math.min
  } : {
    max: function() {
      for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
        r[n] = arguments[n];
      return `max(${r.map((i) => xe(i)).join(",")})`;
    },
    min: function() {
      for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
        r[n] = arguments[n];
      return `min(${r.map((i) => xe(i)).join(",")})`;
    }
  };
}
const Tz = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u";
let LE = !0;
function dn() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  if (!Tz)
    return Object.assign.apply(Object, [{}].concat(t));
  LE = !1;
  const n = {};
  return t.forEach((i) => {
    Object.keys(i).forEach((a) => {
      Object.defineProperty(n, a, {
        configurable: !0,
        enumerable: !0,
        get: () => i[a]
      });
    });
  }), LE = !0, n;
}
const QI = {};
function IJ() {
}
const FJ = (e) => {
  let t, r = e, n = IJ;
  return Tz && typeof Proxy < "u" && (t = /* @__PURE__ */ new Set(), r = new Proxy(e, {
    get(i, o) {
      return LE && t.add(o), i[o];
    }
  }), n = (i, o) => {
    var a;
    QI[i] = {
      global: Array.from(t),
      component: Object.assign(Object.assign({}, (a = QI[i]) === null || a === void 0 ? void 0 : a.component), o)
    };
  }), {
    token: r,
    keys: t,
    flush: n
  };
}, Pz = (e, t) => {
  const [r, n] = Xa();
  return TE({
    theme: r,
    token: n,
    hashId: "",
    path: ["ant-design-icons", e],
    nonce: () => t == null ? void 0 : t.nonce,
    layer: {
      name: "antd"
    }
  }, () => [{
    [`.${e}`]: Object.assign(Object.assign({}, TJ()), {
      [`.${e} .${e}-icon`]: {
        display: "block"
      }
    })
  }]);
}, Mz = (e, t, r) => {
  var n;
  return typeof r == "function" ? r(dn(t, (n = t[e]) !== null && n !== void 0 ? n : {})) : r ?? {};
}, Dz = (e, t, r, n) => {
  const i = Object.assign({}, t[e]);
  if (n != null && n.deprecatedTokens) {
    const {
      deprecatedTokens: a
    } = n;
    a.forEach((s) => {
      let [l, u] = s;
      var c;
      process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "production" && gr(!(i != null && i[l]), `Component Token \`${String(l)}\` of ${e} is deprecated. Please use \`${String(u)}\` instead.`), (i != null && i[l] || i != null && i[u]) && ((c = i[u]) !== null && c !== void 0 || (i[u] = i == null ? void 0 : i[l]));
    });
  }
  const o = Object.assign(Object.assign({}, r), i);
  return Object.keys(o).forEach((a) => {
    o[a] === t[a] && delete o[a];
  }), o;
}, JI = (e, t) => `${[t, e.replace(/([A-Z]+)([A-Z][a-z]+)/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2")].filter(Boolean).join("-")}`;
function ZT(e, t, r) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  const i = Array.isArray(e) ? e : [e, e], [o] = i, a = i.join("-");
  return function(s) {
    let l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : s;
    const [u, c, d, h, f] = Xa(), {
      getPrefixCls: p,
      iconPrefixCls: g,
      csp: v
    } = rr(Xt), m = p(), y = f ? "css" : "js", C = _J(() => {
      const E = /* @__PURE__ */ new Set();
      return f && Object.keys(n.unitless || {}).forEach((R) => {
        E.add(Vy(R, f.prefix)), E.add(Vy(R, JI(o, f.prefix)));
      }), IX(y, E);
    }, [y, o, f == null ? void 0 : f.prefix]), {
      max: S,
      min: b
    } = AJ(y), w = {
      theme: u,
      token: h,
      hashId: d,
      nonce: () => v == null ? void 0 : v.nonce,
      clientOnly: n.clientOnly,
      layer: {
        name: "antd"
      },
      // antd is always at top of styles
      order: n.order || -999
    };
    return TE(Object.assign(Object.assign({}, w), {
      clientOnly: !1,
      path: ["Shared", m]
    }), () => [{
      // Link
      "&": PJ(h)
    }]), Pz(g, v), [TE(Object.assign(Object.assign({}, w), {
      path: [a, s, g]
    }), () => {
      if (n.injectStyle === !1)
        return [];
      const {
        token: E,
        flush: R
      } = FJ(h), _ = Mz(o, c, r), P = `.${s}`, D = Dz(o, c, _, {
        deprecatedTokens: n.deprecatedTokens
      });
      f && Object.keys(_).forEach((O) => {
        _[O] = `var(${Vy(O, JI(o, f.prefix))})`;
      });
      const I = dn(E, {
        componentCls: P,
        prefixCls: s,
        iconCls: `.${g}`,
        antCls: `.${m}`,
        calc: C,
        // @ts-ignore
        max: S,
        // @ts-ignore
        min: b
      }, f ? _ : D), A = t(I, {
        hashId: d,
        prefixCls: s,
        rootPrefixCls: m,
        iconPrefixCls: g
      });
      return R(o, D), [n.resetStyle === !1 ? null : MJ(I, s, l, n.resetFont), A];
    }), d];
  };
}
const XT = (e, t, r, n) => {
  const i = ZT(e, t, r, Object.assign({
    resetStyle: !1,
    // Sub Style should default after root one
    order: -998
  }, n)), o = (a) => {
    let {
      prefixCls: s,
      rootCls: l = s
    } = a;
    return i(s, l), null;
  };
  return process.env.NODE_ENV !== "production" && (o.displayName = `SubStyle_${Array.isArray(e) ? e.join(".") : e}`), o;
}, LJ = (e, t, r) => {
  const {
    unitless: n,
    injectStyle: i = !0,
    prefixToken: o
  } = r, a = (l) => {
    let {
      rootCls: u,
      cssVar: c
    } = l;
    const [, d] = Xa();
    return AQ({
      path: [e],
      prefix: c.prefix,
      key: c == null ? void 0 : c.key,
      unitless: n,
      ignore: Ez,
      token: d,
      scope: u
    }, () => {
      const h = Mz(e, d, t), f = Dz(e, d, h, {
        deprecatedTokens: r == null ? void 0 : r.deprecatedTokens
      });
      return Object.keys(h).forEach((p) => {
        f[o(p)] = f[p], delete f[p];
      }), f;
    }), null;
  };
  return (l) => {
    const [, , , , u] = Xa();
    return [(c) => i && u ? /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(a, {
      rootCls: l,
      cssVar: u,
      component: e
    }), c) : c, u == null ? void 0 : u.key];
  };
}, Gi = (e, t, r, n) => {
  const i = Array.isArray(e) ? e[0] : e;
  function o(d) {
    return `${i}${d.slice(0, 1).toUpperCase()}${d.slice(1)}`;
  }
  const a = (n == null ? void 0 : n.unitless) || {}, s = Object.assign(Object.assign({}, xz), {
    [o("zIndexPopup")]: !0
  });
  Object.keys(a).forEach((d) => {
    s[o(d)] = a[d];
  });
  const l = Object.assign(Object.assign({}, n), {
    unitless: s,
    prefixToken: o
  }), u = ZT(e, t, r, l), c = LJ(i, r, l);
  return function(d) {
    let h = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : d;
    const [, f] = u(d, h), [p, g] = c(h);
    return [p, f, g];
  };
};
function Az(e, t) {
  return xg.reduce((r, n) => {
    const i = e[`${n}1`], o = e[`${n}3`], a = e[`${n}6`], s = e[`${n}7`];
    return Object.assign(Object.assign({}, r), t(n, {
      lightColor: i,
      lightBorderColor: o,
      darkColor: a,
      textColor: s
    }));
  }, {});
}
const OJ = Object.assign({}, T), {
  useId: e2
} = OJ, NJ = () => "", kJ = typeof e2 > "u" ? NJ : e2;
function VJ(e, t, r) {
  var n, i;
  const o = mn("ConfigProvider"), a = e || {}, s = a.inherit === !1 || !t ? Object.assign(Object.assign({}, FE), {
    hashed: (n = t == null ? void 0 : t.hashed) !== null && n !== void 0 ? n : FE.hashed,
    cssVar: t == null ? void 0 : t.cssVar
  }) : t, l = kJ();
  if (process.env.NODE_ENV !== "production") {
    const u = a.cssVar || s.cssVar, c = !!(typeof a.cssVar == "object" && (!((i = a.cssVar) === null || i === void 0) && i.key) || l);
    process.env.NODE_ENV !== "production" && o(!u || c, "breaking", "Missing key in `cssVar` config. Please upgrade to React 18 or set `cssVar.key` manually in each ConfigProvider inside `cssVar` enabled ConfigProvider.");
  }
  return qC(() => {
    var u, c;
    if (!e)
      return t;
    const d = Object.assign({}, s.components);
    Object.keys(e.components || {}).forEach((p) => {
      d[p] = Object.assign(Object.assign({}, d[p]), e.components[p]);
    });
    const h = `css-var-${l.replace(/:/g, "")}`, f = ((u = a.cssVar) !== null && u !== void 0 ? u : s.cssVar) && Object.assign(Object.assign(Object.assign({
      prefix: r == null ? void 0 : r.prefixCls
    }, typeof s.cssVar == "object" ? s.cssVar : {}), typeof a.cssVar == "object" ? a.cssVar : {}), {
      key: typeof a.cssVar == "object" && ((c = a.cssVar) === null || c === void 0 ? void 0 : c.key) || h
    });
    return Object.assign(Object.assign(Object.assign({}, s), a), {
      token: Object.assign(Object.assign({}, s.token), a.token),
      components: d,
      cssVar: f
    });
  }, [a, s], (u, c) => u.some((d, h) => {
    const f = c[h];
    return !xh(d, f, !0);
  }));
}
var BJ = ["children"], Iz = /* @__PURE__ */ T.createContext({});
function GJ(e) {
  var t = e.children, r = zt(e, BJ);
  return /* @__PURE__ */ T.createElement(Iz.Provider, {
    value: r
  }, t);
}
var HJ = /* @__PURE__ */ function(e) {
  Ql(r, e);
  var t = Jl(r);
  function r() {
    return Hn(this, r), t.apply(this, arguments);
  }
  return zn(r, [{
    key: "render",
    value: function() {
      return this.props.children;
    }
  }]), r;
}(T.Component);
function zJ(e) {
  var t = T.useReducer(function(s) {
    return s + 1;
  }, 0), r = ue(t, 2), n = r[1], i = T.useRef(e), o = Mn(function() {
    return i.current;
  }), a = Mn(function(s) {
    i.current = typeof s == "function" ? s(i.current) : s, n();
  });
  return [o, a];
}
var ml = "none", am = "appear", sm = "enter", lm = "leave", t2 = "none", ra = "prepare", Xd = "start", Qd = "active", QT = "end", Fz = "prepared";
function r2(e, t) {
  var r = {};
  return r[e.toLowerCase()] = t.toLowerCase(), r["Webkit".concat(e)] = "webkit".concat(t), r["Moz".concat(e)] = "moz".concat(t), r["ms".concat(e)] = "MS".concat(t), r["O".concat(e)] = "o".concat(t.toLowerCase()), r;
}
function $J(e, t) {
  var r = {
    animationend: r2("Animation", "AnimationEnd"),
    transitionend: r2("Transition", "TransitionEnd")
  };
  return e && ("AnimationEvent" in t || delete r.animationend.animation, "TransitionEvent" in t || delete r.transitionend.transition), r;
}
var WJ = $J(mi(), typeof window < "u" ? window : {}), Lz = {};
if (mi()) {
  var jJ = document.createElement("div");
  Lz = jJ.style;
}
var um = {};
function Oz(e) {
  if (um[e])
    return um[e];
  var t = WJ[e];
  if (t)
    for (var r = Object.keys(t), n = r.length, i = 0; i < n; i += 1) {
      var o = r[i];
      if (Object.prototype.hasOwnProperty.call(t, o) && o in Lz)
        return um[e] = t[o], um[e];
    }
  return "";
}
var Nz = Oz("animationend"), kz = Oz("transitionend"), Vz = !!(Nz && kz), n2 = Nz || "animationend", i2 = kz || "transitionend";
function o2(e, t) {
  if (!e) return null;
  if (xt(e) === "object") {
    var r = t.replace(/-\w/g, function(n) {
      return n[1].toUpperCase();
    });
    return e[r];
  }
  return "".concat(e, "-").concat(t);
}
const UJ = function(e) {
  var t = le();
  function r(i) {
    i && (i.removeEventListener(i2, e), i.removeEventListener(n2, e));
  }
  function n(i) {
    t.current && t.current !== i && r(t.current), i && i !== t.current && (i.addEventListener(i2, e), i.addEventListener(n2, e), t.current = i);
  }
  return T.useEffect(function() {
    return function() {
      r(t.current);
    };
  }, []), [n, r];
};
var Bz = mi() ? ja : It;
const KJ = function() {
  var e = T.useRef(null);
  function t() {
    cn.cancel(e.current);
  }
  function r(n) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    t();
    var o = cn(function() {
      i <= 1 ? n({
        isCanceled: function() {
          return o !== e.current;
        }
      }) : r(n, i - 1);
    });
    e.current = o;
  }
  return T.useEffect(function() {
    return function() {
      t();
    };
  }, []), [r, t];
};
var YJ = [ra, Xd, Qd, QT], qJ = [ra, Fz], Gz = !1, ZJ = !0;
function Hz(e) {
  return e === Qd || e === QT;
}
const XJ = function(e, t, r) {
  var n = Ph(t2), i = ue(n, 2), o = i[0], a = i[1], s = KJ(), l = ue(s, 2), u = l[0], c = l[1];
  function d() {
    a(ra, !0);
  }
  var h = t ? qJ : YJ;
  return Bz(function() {
    if (o !== t2 && o !== QT) {
      var f = h.indexOf(o), p = h[f + 1], g = r(o);
      g === Gz ? a(p, !0) : p && u(function(v) {
        function m() {
          v.isCanceled() || a(p, !0);
        }
        g === !0 ? m() : Promise.resolve(g).then(m);
      });
    }
  }, [e, o]), T.useEffect(function() {
    return function() {
      c();
    };
  }, []), [d, o];
};
function QJ(e, t, r, n) {
  var i = n.motionEnter, o = i === void 0 ? !0 : i, a = n.motionAppear, s = a === void 0 ? !0 : a, l = n.motionLeave, u = l === void 0 ? !0 : l, c = n.motionDeadline, d = n.motionLeaveImmediately, h = n.onAppearPrepare, f = n.onEnterPrepare, p = n.onLeavePrepare, g = n.onAppearStart, v = n.onEnterStart, m = n.onLeaveStart, y = n.onAppearActive, C = n.onEnterActive, S = n.onLeaveActive, b = n.onAppearEnd, w = n.onEnterEnd, x = n.onLeaveEnd, E = n.onVisibleChanged, R = Ph(), _ = ue(R, 2), P = _[0], D = _[1], I = zJ(ml), A = ue(I, 2), O = A[0], L = A[1], N = Ph(null), F = ue(N, 2), G = F[0], M = F[1], V = O(), z = le(!1), k = le(null);
  function $() {
    return r();
  }
  var W = le(!1);
  function j() {
    L(ml), M(null, !0);
  }
  var U = Mn(function(Re) {
    var _e = O();
    if (_e !== ml) {
      var He = $();
      if (!(Re && !Re.deadline && Re.target !== He)) {
        var Ve = W.current, $e;
        _e === am && Ve ? $e = b == null ? void 0 : b(He, Re) : _e === sm && Ve ? $e = w == null ? void 0 : w(He, Re) : _e === lm && Ve && ($e = x == null ? void 0 : x(He, Re)), Ve && $e !== !1 && j();
      }
    }
  }), Z = UJ(U), ee = ue(Z, 1), J = ee[0], X = function(_e) {
    switch (_e) {
      case am:
        return te(te(te({}, ra, h), Xd, g), Qd, y);
      case sm:
        return te(te(te({}, ra, f), Xd, v), Qd, C);
      case lm:
        return te(te(te({}, ra, p), Xd, m), Qd, S);
      default:
        return {};
    }
  }, Y = T.useMemo(function() {
    return X(V);
  }, [V]), de = XJ(V, !e, function(Re) {
    if (Re === ra) {
      var _e = Y[ra];
      return _e ? _e($()) : Gz;
    }
    if (Ce in Y) {
      var He;
      M(((He = Y[Ce]) === null || He === void 0 ? void 0 : He.call(Y, $(), null)) || null);
    }
    return Ce === Qd && V !== ml && (J($()), c > 0 && (clearTimeout(k.current), k.current = setTimeout(function() {
      U({
        deadline: !0
      });
    }, c))), Ce === Fz && j(), ZJ;
  }), K = ue(de, 2), ie = K[0], Ce = K[1], Te = Hz(Ce);
  W.current = Te, Bz(function() {
    D(t);
    var Re = z.current;
    z.current = !0;
    var _e;
    !Re && t && s && (_e = am), Re && t && o && (_e = sm), (Re && !t && u || !Re && d && !t && u) && (_e = lm);
    var He = X(_e);
    _e && (e || He[ra]) ? (L(_e), ie()) : L(ml);
  }, [t]), It(function() {
    // Cancel appear
    (V === am && !s || // Cancel enter
    V === sm && !o || // Cancel leave
    V === lm && !u) && L(ml);
  }, [s, o, u]), It(function() {
    return function() {
      z.current = !1, clearTimeout(k.current);
    };
  }, []);
  var Ie = T.useRef(!1);
  It(function() {
    P && (Ie.current = !0), P !== void 0 && V === ml && ((Ie.current || P) && (E == null || E(P)), Ie.current = !0);
  }, [P, V]);
  var we = G;
  return Y[ra] && Ce === Xd && (we = re({
    transition: "none"
  }, we)), [V, Ce, we, P ?? t];
}
function JJ(e) {
  var t = e;
  xt(e) === "object" && (t = e.transitionSupport);
  function r(i, o) {
    return !!(i.motionName && t && o !== !1);
  }
  var n = /* @__PURE__ */ T.forwardRef(function(i, o) {
    var a = i.visible, s = a === void 0 ? !0 : a, l = i.removeOnLeave, u = l === void 0 ? !0 : l, c = i.forceRender, d = i.children, h = i.motionName, f = i.leavedClassName, p = i.eventProps, g = T.useContext(Iz), v = g.motion, m = r(i, v), y = le(), C = le();
    function S() {
      try {
        return y.current instanceof HTMLElement ? y.current : ky(C.current);
      } catch {
        return null;
      }
    }
    var b = QJ(m, s, S, i), w = ue(b, 4), x = w[0], E = w[1], R = w[2], _ = w[3], P = T.useRef(_);
    _ && (P.current = !0);
    var D = T.useCallback(function(G) {
      y.current = G, GT(o, G);
    }, [o]), I, A = re(re({}, p), {}, {
      visible: s
    });
    if (!d)
      I = null;
    else if (x === ml)
      _ ? I = d(re({}, A), D) : !u && P.current && f ? I = d(re(re({}, A), {}, {
        className: f
      }), D) : c || !u && !f ? I = d(re(re({}, A), {}, {
        style: {
          display: "none"
        }
      }), D) : I = null;
    else {
      var O;
      E === ra ? O = "prepare" : Hz(E) ? O = "active" : E === Xd && (O = "start");
      var L = o2(h, "".concat(x, "-").concat(O));
      I = d(re(re({}, A), {}, {
        className: pe(o2(h, x), te(te({}, L, L && O), h, typeof h == "string")),
        style: R
      }), D);
    }
    if (/* @__PURE__ */ T.isValidElement(I) && kc(I)) {
      var N = I, F = N.ref;
      F || (I = /* @__PURE__ */ T.cloneElement(I, {
        ref: D
      }));
    }
    return /* @__PURE__ */ T.createElement(HJ, {
      ref: C
    }, I);
  });
  return n.displayName = "CSSMotion", n;
}
const ns = JJ(Vz);
var OE = "add", NE = "keep", kE = "remove", Ow = "removed";
function eee(e) {
  var t;
  return e && xt(e) === "object" && "key" in e ? t = e : t = {
    key: e
  }, re(re({}, t), {}, {
    key: String(t.key)
  });
}
function VE() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  return e.map(eee);
}
function tee() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = [], n = 0, i = t.length, o = VE(e), a = VE(t);
  o.forEach(function(u) {
    for (var c = !1, d = n; d < i; d += 1) {
      var h = a[d];
      if (h.key === u.key) {
        n < d && (r = r.concat(a.slice(n, d).map(function(f) {
          return re(re({}, f), {}, {
            status: OE
          });
        })), n = d), r.push(re(re({}, h), {}, {
          status: NE
        })), n += 1, c = !0;
        break;
      }
    }
    c || r.push(re(re({}, u), {}, {
      status: kE
    }));
  }), n < i && (r = r.concat(a.slice(n).map(function(u) {
    return re(re({}, u), {}, {
      status: OE
    });
  })));
  var s = {};
  r.forEach(function(u) {
    var c = u.key;
    s[c] = (s[c] || 0) + 1;
  });
  var l = Object.keys(s).filter(function(u) {
    return s[u] > 1;
  });
  return l.forEach(function(u) {
    r = r.filter(function(c) {
      var d = c.key, h = c.status;
      return d !== u || h !== kE;
    }), r.forEach(function(c) {
      c.key === u && (c.status = NE);
    });
  }), r;
}
var ree = ["component", "children", "onVisibleChanged", "onAllRemoved"], nee = ["status"], iee = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearPrepare", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
function oee(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ns, r = /* @__PURE__ */ function(n) {
    Ql(o, n);
    var i = Jl(o);
    function o() {
      var a;
      Hn(this, o);
      for (var s = arguments.length, l = new Array(s), u = 0; u < s; u++)
        l[u] = arguments[u];
      return a = i.call.apply(i, [this].concat(l)), te(qt(a), "state", {
        keyEntities: []
      }), te(qt(a), "removeKey", function(c) {
        var d = a.state.keyEntities, h = d.map(function(f) {
          return f.key !== c ? f : re(re({}, f), {}, {
            status: Ow
          });
        });
        return a.setState({
          keyEntities: h
        }), h.filter(function(f) {
          var p = f.status;
          return p !== Ow;
        }).length;
      }), a;
    }
    return zn(o, [{
      key: "render",
      value: function() {
        var s = this, l = this.state.keyEntities, u = this.props, c = u.component, d = u.children, h = u.onVisibleChanged, f = u.onAllRemoved, p = zt(u, ree), g = c || T.Fragment, v = {};
        return iee.forEach(function(m) {
          v[m] = p[m], delete p[m];
        }), delete p.keys, /* @__PURE__ */ T.createElement(g, p, l.map(function(m, y) {
          var C = m.status, S = zt(m, nee), b = C === OE || C === NE;
          return /* @__PURE__ */ T.createElement(t, ze({}, v, {
            key: S.key,
            visible: b,
            eventProps: S,
            onVisibleChanged: function(x) {
              if (h == null || h(x, {
                key: S.key
              }), !x) {
                var E = s.removeKey(S.key);
                E === 0 && f && f();
              }
            }
          }), function(w, x) {
            return d(re(re({}, w), {}, {
              index: y
            }), x);
          });
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function(s, l) {
        var u = s.keys, c = l.keyEntities, d = VE(u), h = tee(c, d);
        return {
          keyEntities: h.filter(function(f) {
            var p = c.find(function(g) {
              var v = g.key;
              return f.key === v;
            });
            return !(p && p.status === Ow && f.status === kE);
          })
        };
      }
    }]), o;
  }(T.Component);
  return te(r, "defaultProps", {
    component: "div"
  }), r;
}
oee(Vz);
function aee(e) {
  const {
    children: t
  } = e, [, r] = Xa(), {
    motion: n
  } = r, i = T.useRef(!1);
  return i.current = i.current || n === !1, i.current ? /* @__PURE__ */ T.createElement(GJ, {
    motion: n
  }, t) : t;
}
const zz = /* @__PURE__ */ T.memo((e) => {
  let {
    dropdownMatchSelectWidth: t
  } = e;
  return mn("ConfigProvider").deprecated(t === void 0, "dropdownMatchSelectWidth", "popupMatchSelectWidth"), null;
});
process.env.NODE_ENV !== "production" && (zz.displayName = "PropWarning");
const see = process.env.NODE_ENV !== "production" ? zz : () => null;
var lee = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
let BE = !1;
process.env.NODE_ENV;
const uee = ["getTargetContainer", "getPopupContainer", "renderEmpty", "input", "pagination", "form", "select", "button"], $z = "ant";
let Wz;
function cee() {
  return Wz || $z;
}
function dee(e) {
  return Object.keys(e).some((t) => t.endsWith("Color"));
}
const hee = (e) => {
  const {
    prefixCls: t,
    iconPrefixCls: r,
    theme: n,
    holderRender: i
  } = e;
  t !== void 0 && (Wz = t), n && dee(n) && (process.env.NODE_ENV !== "production" && qh(!1, "ConfigProvider", "`config` of css variable theme is not work in v5. Please use new `theme` config instead."), mJ(cee(), n));
}, fee = (e) => {
  const {
    children: t,
    csp: r,
    autoInsertSpaceInButton: n,
    alert: i,
    anchor: o,
    form: a,
    locale: s,
    componentSize: l,
    direction: u,
    space: c,
    virtual: d,
    dropdownMatchSelectWidth: h,
    popupMatchSelectWidth: f,
    popupOverflow: p,
    legacyLocale: g,
    parentContext: v,
    iconPrefixCls: m,
    theme: y,
    componentDisabled: C,
    segmented: S,
    statistic: b,
    spin: w,
    calendar: x,
    carousel: E,
    cascader: R,
    collapse: _,
    typography: P,
    checkbox: D,
    descriptions: I,
    divider: A,
    drawer: O,
    skeleton: L,
    steps: N,
    image: F,
    layout: G,
    list: M,
    mentions: V,
    modal: z,
    progress: k,
    result: $,
    slider: W,
    breadcrumb: j,
    menu: U,
    pagination: Z,
    input: ee,
    textArea: J,
    empty: X,
    badge: Y,
    radio: de,
    rate: K,
    switch: ie,
    transfer: Ce,
    avatar: Te,
    message: Ie,
    tag: we,
    table: Re,
    card: _e,
    tabs: He,
    timeline: Ve,
    timePicker: $e,
    upload: Je,
    notification: Q,
    tree: ye,
    colorPicker: Ge,
    datePicker: Pe,
    rangePicker: Le,
    flex: me,
    wave: De,
    dropdown: qe,
    warning: ht,
    tour: Tt,
    floatButtonGroup: lt,
    variant: tt,
    inputNumber: Oe,
    treeSelect: je
  } = e, pt = T.useCallback((Kt, Yt) => {
    const {
      prefixCls: vr
    } = e;
    if (Yt)
      return Yt;
    const Br = vr || v.getPrefixCls("");
    return Kt ? `${Br}-${Kt}` : Br;
  }, [v.getPrefixCls, e.prefixCls]), wt = m || v.iconPrefixCls || wz, $r = r || v.csp;
  Pz(wt, $r);
  const xr = VJ(y, v.theme, {
    prefixCls: pt("")
  });
  process.env.NODE_ENV !== "production" && (BE = BE || !!xr);
  const Ut = {
    csp: $r,
    autoInsertSpaceInButton: n,
    alert: i,
    anchor: o,
    locale: s || g,
    direction: u,
    space: c,
    virtual: d,
    popupMatchSelectWidth: f ?? h,
    popupOverflow: p,
    getPrefixCls: pt,
    iconPrefixCls: wt,
    theme: xr,
    segmented: S,
    statistic: b,
    spin: w,
    calendar: x,
    carousel: E,
    cascader: R,
    collapse: _,
    typography: P,
    checkbox: D,
    descriptions: I,
    divider: A,
    drawer: O,
    skeleton: L,
    steps: N,
    image: F,
    input: ee,
    textArea: J,
    layout: G,
    list: M,
    mentions: V,
    modal: z,
    progress: k,
    result: $,
    slider: W,
    breadcrumb: j,
    menu: U,
    pagination: Z,
    empty: X,
    badge: Y,
    radio: de,
    rate: K,
    switch: ie,
    transfer: Ce,
    avatar: Te,
    message: Ie,
    tag: we,
    table: Re,
    card: _e,
    tabs: He,
    timeline: Ve,
    timePicker: $e,
    upload: Je,
    notification: Q,
    tree: ye,
    colorPicker: Ge,
    datePicker: Pe,
    rangePicker: Le,
    flex: me,
    wave: De,
    dropdown: qe,
    warning: ht,
    tour: Tt,
    floatButtonGroup: lt,
    variant: tt,
    inputNumber: Oe,
    treeSelect: je
  };
  process.env.NODE_ENV !== "production" && mn("ConfigProvider")(!("autoInsertSpaceInButton" in e), "deprecated", "`autoInsertSpaceInButton` is deprecated. Please use `{ button: { autoInsertSpace: boolean }}` instead.");
  const Ht = Object.assign({}, v);
  Object.keys(Ut).forEach((Kt) => {
    Ut[Kt] !== void 0 && (Ht[Kt] = Ut[Kt]);
  }), uee.forEach((Kt) => {
    const Yt = e[Kt];
    Yt && (Ht[Kt] = Yt);
  }), typeof n < "u" && (Ht.button = Object.assign({
    autoInsertSpace: n
  }, Ht.button));
  const Lt = qC(() => Ht, Ht, (Kt, Yt) => {
    const vr = Object.keys(Kt), Br = Object.keys(Yt);
    return vr.length !== Br.length || vr.some((yn) => Kt[yn] !== Yt[yn]);
  }), gt = T.useMemo(() => ({
    prefixCls: wt,
    csp: $r
  }), [wt, $r]);
  let nt = /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(see, {
    dropdownMatchSelectWidth: h
  }), t);
  const Qt = T.useMemo(() => {
    var Kt, Yt, vr, Br;
    return Zd(((Kt = ks.Form) === null || Kt === void 0 ? void 0 : Kt.defaultValidateMessages) || {}, ((vr = (Yt = Lt.locale) === null || Yt === void 0 ? void 0 : Yt.Form) === null || vr === void 0 ? void 0 : vr.defaultValidateMessages) || {}, ((Br = Lt.form) === null || Br === void 0 ? void 0 : Br.validateMessages) || {}, (a == null ? void 0 : a.validateMessages) || {});
  }, [Lt, a == null ? void 0 : a.validateMessages]);
  Object.keys(Qt).length > 0 && (nt = /* @__PURE__ */ T.createElement(kQ.Provider, {
    value: Qt
  }, nt)), s && (nt = /* @__PURE__ */ T.createElement(pz, {
    locale: s,
    _ANT_MARK__: fz
  }, nt)), (wt || $r) && (nt = /* @__PURE__ */ T.createElement(YT.Provider, {
    value: gt
  }, nt)), l && (nt = /* @__PURE__ */ T.createElement(CJ, {
    size: l
  }, nt)), nt = /* @__PURE__ */ T.createElement(aee, null, nt);
  const kr = T.useMemo(() => {
    const Kt = xr || {}, {
      algorithm: Yt,
      token: vr,
      components: Br,
      cssVar: yn
    } = Kt, $n = lee(Kt, ["algorithm", "token", "components", "cssVar"]), ni = Yt && (!Array.isArray(Yt) || Yt.length > 0) ? SE(Yt) : Cz, q = {};
    Object.entries(Br || {}).forEach((be) => {
      let [Ke, vt] = be;
      const ut = Object.assign({}, vt);
      "algorithm" in ut && (ut.algorithm === !0 ? ut.theme = ni : (Array.isArray(ut.algorithm) || typeof ut.algorithm == "function") && (ut.theme = SE(ut.algorithm)), delete ut.algorithm), q[Ke] = ut;
    });
    const ve = Object.assign(Object.assign({}, bg), vr);
    return Object.assign(Object.assign({}, $n), {
      theme: ni,
      token: ve,
      components: q,
      override: Object.assign({
        override: ve
      }, q),
      cssVar: yn
    });
  }, [xr]);
  return y && (nt = /* @__PURE__ */ T.createElement(Sz.Provider, {
    value: kr
  }, nt)), Lt.warning && (nt = /* @__PURE__ */ T.createElement(cz.Provider, {
    value: Lt.warning
  }, nt)), C !== void 0 && (nt = /* @__PURE__ */ T.createElement(yJ, {
    disabled: C
  }, nt)), /* @__PURE__ */ T.createElement(Xt.Provider, {
    value: Lt
  }, nt);
}, Vc = (e) => {
  const t = T.useContext(Xt), r = T.useContext(qT);
  return /* @__PURE__ */ T.createElement(fee, Object.assign({
    parentContext: t,
    legacyLocale: r
  }, e));
};
Vc.ConfigContext = Xt;
Vc.SizeContext = Th;
Vc.config = hee;
Vc.useConfig = SJ;
Object.defineProperty(Vc, "SizeContext", {
  get: () => (process.env.NODE_ENV !== "production" && qh(!1, "ConfigProvider", "ConfigProvider.SizeContext is deprecated. Please use `ConfigProvider.useConfig().componentSize` instead."), Th)
});
process.env.NODE_ENV !== "production" && (Vc.displayName = "ConfigProvider");
function jz(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
}
function pee(e) {
  return jz(e) instanceof ShadowRoot;
}
function R0(e) {
  return pee(e) ? jz(e) : null;
}
function gee(e) {
  return e.replace(/-(.)/g, function(t, r) {
    return r.toUpperCase();
  });
}
function vee(e, t) {
  gr(e, "[@ant-design/icons] ".concat(t));
}
function a2(e) {
  return xt(e) === "object" && typeof e.name == "string" && typeof e.theme == "string" && (xt(e.icon) === "object" || typeof e.icon == "function");
}
function s2() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return Object.keys(e).reduce(function(t, r) {
    var n = e[r];
    switch (r) {
      case "class":
        t.className = n, delete t.class;
        break;
      default:
        delete t[r], t[gee(r)] = n;
    }
    return t;
  }, {});
}
function GE(e, t, r) {
  return r ? /* @__PURE__ */ H.createElement(e.tag, re(re({
    key: t
  }, s2(e.attrs)), r), (e.children || []).map(function(n, i) {
    return GE(n, "".concat(t, "-").concat(e.tag, "-").concat(i));
  })) : /* @__PURE__ */ H.createElement(e.tag, re({
    key: t
  }, s2(e.attrs)), (e.children || []).map(function(n, i) {
    return GE(n, "".concat(t, "-").concat(e.tag, "-").concat(i));
  }));
}
function Uz(e) {
  return wg(e)[0];
}
function Kz(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
var mee = `
.anticon {
  display: inline-flex;
  align-items: center;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`, yee = function(t) {
  var r = rr(YT), n = r.csp, i = r.prefixCls, o = mee;
  i && (o = o.replace(/anticon/g, i)), It(function() {
    var a = t.current, s = R0(a);
    Ms(o, "@ant-design-icons", {
      prepend: !0,
      csp: n,
      attachTo: s
    });
  }, []);
}, Cee = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"], Hp = {
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
};
function See(e) {
  var t = e.primaryColor, r = e.secondaryColor;
  Hp.primaryColor = t, Hp.secondaryColor = r || Uz(t), Hp.calculated = !!r;
}
function wee() {
  return re({}, Hp);
}
var Zh = function(t) {
  var r = t.icon, n = t.className, i = t.onClick, o = t.style, a = t.primaryColor, s = t.secondaryColor, l = zt(t, Cee), u = T.useRef(), c = Hp;
  if (a && (c = {
    primaryColor: a,
    secondaryColor: s || Uz(a)
  }), yee(u), vee(a2(r), "icon should be icon definiton, but got ".concat(r)), !a2(r))
    return null;
  var d = r;
  return d && typeof d.icon == "function" && (d = re(re({}, d), {}, {
    icon: d.icon(c.primaryColor, c.secondaryColor)
  })), GE(d.icon, "svg-".concat(d.name), re(re({
    className: n,
    onClick: i,
    style: o,
    "data-icon": d.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }, l), {}, {
    ref: u
  }));
};
Zh.displayName = "IconReact";
Zh.getTwoToneColors = wee;
Zh.setTwoToneColors = See;
function Yz(e) {
  var t = Kz(e), r = ue(t, 2), n = r[0], i = r[1];
  return Zh.setTwoToneColors({
    primaryColor: n,
    secondaryColor: i
  });
}
function bee() {
  var e = Zh.getTwoToneColors();
  return e.calculated ? [e.primaryColor, e.secondaryColor] : e.primaryColor;
}
var xee = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
Yz(IE.primary);
var zr = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.className, n = e.icon, i = e.spin, o = e.rotate, a = e.tabIndex, s = e.onClick, l = e.twoToneColor, u = zt(e, xee), c = T.useContext(YT), d = c.prefixCls, h = d === void 0 ? "anticon" : d, f = c.rootClassName, p = pe(f, h, te(te({}, "".concat(h, "-").concat(n.name), !!n.name), "".concat(h, "-spin"), !!i || n.name === "loading"), r), g = a;
  g === void 0 && s && (g = -1);
  var v = o ? {
    msTransform: "rotate(".concat(o, "deg)"),
    transform: "rotate(".concat(o, "deg)")
  } : void 0, m = Kz(l), y = ue(m, 2), C = y[0], S = y[1];
  return /* @__PURE__ */ T.createElement("span", ze({
    role: "img",
    "aria-label": n.name
  }, u, {
    ref: t,
    tabIndex: g,
    onClick: s,
    className: p
  }), /* @__PURE__ */ T.createElement(Zh, {
    icon: n,
    primaryColor: C,
    secondaryColor: S,
    style: v
  }));
});
zr.displayName = "AntdIcon";
zr.getTwoToneColor = bee;
zr.setTwoToneColor = Yz;
var Eee = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" }, Ree = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: Eee
  }));
}, qz = /* @__PURE__ */ T.forwardRef(Ree);
process.env.NODE_ENV !== "production" && (qz.displayName = "CloseCircleFilled");
var _ee = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" }, Tee = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: _ee
  }));
}, iS = /* @__PURE__ */ T.forwardRef(Tee);
process.env.NODE_ENV !== "production" && (iS.displayName = "CloseOutlined");
var Pee = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "exclamation-circle", theme: "filled" }, Mee = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: Pee
  }));
}, JT = /* @__PURE__ */ T.forwardRef(Mee);
process.env.NODE_ENV !== "production" && (JT.displayName = "ExclamationCircleFilled");
var Dee = `accept acceptCharset accessKey action allowFullScreen allowTransparency
    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable contextMenu
    controls coords crossOrigin data dateTime default defer dir disabled download draggable
    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder
    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity
    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap`, Aee = `onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown
    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick
    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown
    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel
    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough
    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata
    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError`, Iee = "".concat(Dee, " ").concat(Aee).split(/[\s\n]+/), Fee = "aria-", Lee = "data-";
function l2(e, t) {
  return e.indexOf(t) === 0;
}
function oS(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r;
  t === !1 ? r = {
    aria: !0,
    data: !0,
    attr: !0
  } : t === !0 ? r = {
    aria: !0
  } : r = re({}, t);
  var n = {};
  return Object.keys(e).forEach(function(i) {
    // Aria
    (r.aria && (i === "role" || l2(i, Fee)) || // Data
    r.data && l2(i, Lee) || // Attr
    r.attr && Iee.includes(i)) && (n[i] = e[i]);
  }), n;
}
function Zz(e) {
  return e && /* @__PURE__ */ H.isValidElement(e) && e.type === H.Fragment;
}
const Xz = (e, t, r) => /* @__PURE__ */ H.isValidElement(e) ? /* @__PURE__ */ H.cloneElement(e, typeof r == "function" ? r(e.props || {}) : r) : t;
function Rc(e, t) {
  return Xz(e, e, t);
}
const Xh = (e) => {
  const [, , , , t] = Xa();
  return t ? `${e}-css-var` : "";
};
var Ue = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function(t) {
    var r = t.keyCode;
    if (t.altKey && !t.ctrlKey || t.metaKey || // Function keys don't generate text
    r >= Ue.F1 && r <= Ue.F12)
      return !1;
    switch (r) {
      case Ue.ALT:
      case Ue.CAPS_LOCK:
      case Ue.CONTEXT_MENU:
      case Ue.CTRL:
      case Ue.DOWN:
      case Ue.END:
      case Ue.ESC:
      case Ue.HOME:
      case Ue.INSERT:
      case Ue.LEFT:
      case Ue.MAC_FF_META:
      case Ue.META:
      case Ue.NUMLOCK:
      case Ue.NUM_CENTER:
      case Ue.PAGE_DOWN:
      case Ue.PAGE_UP:
      case Ue.PAUSE:
      case Ue.PRINT_SCREEN:
      case Ue.RIGHT:
      case Ue.SHIFT:
      case Ue.UP:
      case Ue.WIN_KEY:
      case Ue.WIN_KEY_RIGHT:
        return !1;
      default:
        return !0;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function(t) {
    if (t >= Ue.ZERO && t <= Ue.NINE || t >= Ue.NUM_ZERO && t <= Ue.NUM_MULTIPLY || t >= Ue.A && t <= Ue.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && t === 0)
      return !0;
    switch (t) {
      case Ue.SPACE:
      case Ue.QUESTION_MARK:
      case Ue.NUM_PLUS:
      case Ue.NUM_MINUS:
      case Ue.NUM_PERIOD:
      case Ue.NUM_DIVISION:
      case Ue.SEMICOLON:
      case Ue.DASH:
      case Ue.EQUALS:
      case Ue.COMMA:
      case Ue.PERIOD:
      case Ue.SLASH:
      case Ue.APOSTROPHE:
      case Ue.SINGLE_QUOTE:
      case Ue.OPEN_SQUARE_BRACKET:
      case Ue.BACKSLASH:
      case Ue.CLOSE_SQUARE_BRACKET:
        return !0;
      default:
        return !1;
    }
  }
}, Oee = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" }, Nee = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: Oee
  }));
}, eP = /* @__PURE__ */ T.forwardRef(Nee);
process.env.NODE_ENV !== "production" && (eP.displayName = "LoadingOutlined");
const tP = /* @__PURE__ */ H.createContext(void 0);
process.env.NODE_ENV !== "production" && (tP.displayName = "zIndexContext");
const Ou = 100, kee = 10, Vee = Ou * kee, Qz = {
  Modal: Ou,
  Drawer: Ou,
  Popover: Ou,
  Popconfirm: Ou,
  Tooltip: Ou,
  Tour: Ou
}, Bee = {
  SelectLike: 50,
  Dropdown: 50,
  DatePicker: 50,
  Menu: 50,
  ImagePreview: 1
};
function Gee(e) {
  return e in Qz;
}
function rP(e, t) {
  const [, r] = Xa(), n = H.useContext(tP), i = Gee(e);
  if (t !== void 0)
    return [t, t];
  let o = n ?? 0;
  return i ? (o += // Use preset token zIndex by default but not stack when has parent container
  (n ? 0 : r.zIndexPopupBase) + // Container offset
  Qz[e], o = Math.min(o, r.zIndexPopupBase + Vee)) : o += Bee[e], [n === void 0 ? t : o, o];
}
function Si() {
  Si = function() {
    return t;
  };
  var e, t = {}, r = Object.prototype, n = r.hasOwnProperty, i = Object.defineProperty || function(L, N, F) {
    L[N] = F.value;
  }, o = typeof Symbol == "function" ? Symbol : {}, a = o.iterator || "@@iterator", s = o.asyncIterator || "@@asyncIterator", l = o.toStringTag || "@@toStringTag";
  function u(L, N, F) {
    return Object.defineProperty(L, N, {
      value: F,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), L[N];
  }
  try {
    u({}, "");
  } catch {
    u = function(F, G, M) {
      return F[G] = M;
    };
  }
  function c(L, N, F, G) {
    var M = N && N.prototype instanceof m ? N : m, V = Object.create(M.prototype), z = new A(G || []);
    return i(V, "_invoke", {
      value: _(L, F, z)
    }), V;
  }
  function d(L, N, F) {
    try {
      return {
        type: "normal",
        arg: L.call(N, F)
      };
    } catch (G) {
      return {
        type: "throw",
        arg: G
      };
    }
  }
  t.wrap = c;
  var h = "suspendedStart", f = "suspendedYield", p = "executing", g = "completed", v = {};
  function m() {
  }
  function y() {
  }
  function C() {
  }
  var S = {};
  u(S, a, function() {
    return this;
  });
  var b = Object.getPrototypeOf, w = b && b(b(O([])));
  w && w !== r && n.call(w, a) && (S = w);
  var x = C.prototype = m.prototype = Object.create(S);
  function E(L) {
    ["next", "throw", "return"].forEach(function(N) {
      u(L, N, function(F) {
        return this._invoke(N, F);
      });
    });
  }
  function R(L, N) {
    function F(M, V, z, k) {
      var $ = d(L[M], L, V);
      if ($.type !== "throw") {
        var W = $.arg, j = W.value;
        return j && xt(j) == "object" && n.call(j, "__await") ? N.resolve(j.__await).then(function(U) {
          F("next", U, z, k);
        }, function(U) {
          F("throw", U, z, k);
        }) : N.resolve(j).then(function(U) {
          W.value = U, z(W);
        }, function(U) {
          return F("throw", U, z, k);
        });
      }
      k($.arg);
    }
    var G;
    i(this, "_invoke", {
      value: function(V, z) {
        function k() {
          return new N(function($, W) {
            F(V, z, $, W);
          });
        }
        return G = G ? G.then(k, k) : k();
      }
    });
  }
  function _(L, N, F) {
    var G = h;
    return function(M, V) {
      if (G === p) throw Error("Generator is already running");
      if (G === g) {
        if (M === "throw") throw V;
        return {
          value: e,
          done: !0
        };
      }
      for (F.method = M, F.arg = V; ; ) {
        var z = F.delegate;
        if (z) {
          var k = P(z, F);
          if (k) {
            if (k === v) continue;
            return k;
          }
        }
        if (F.method === "next") F.sent = F._sent = F.arg;
        else if (F.method === "throw") {
          if (G === h) throw G = g, F.arg;
          F.dispatchException(F.arg);
        } else F.method === "return" && F.abrupt("return", F.arg);
        G = p;
        var $ = d(L, N, F);
        if ($.type === "normal") {
          if (G = F.done ? g : f, $.arg === v) continue;
          return {
            value: $.arg,
            done: F.done
          };
        }
        $.type === "throw" && (G = g, F.method = "throw", F.arg = $.arg);
      }
    };
  }
  function P(L, N) {
    var F = N.method, G = L.iterator[F];
    if (G === e) return N.delegate = null, F === "throw" && L.iterator.return && (N.method = "return", N.arg = e, P(L, N), N.method === "throw") || F !== "return" && (N.method = "throw", N.arg = new TypeError("The iterator does not provide a '" + F + "' method")), v;
    var M = d(G, L.iterator, N.arg);
    if (M.type === "throw") return N.method = "throw", N.arg = M.arg, N.delegate = null, v;
    var V = M.arg;
    return V ? V.done ? (N[L.resultName] = V.value, N.next = L.nextLoc, N.method !== "return" && (N.method = "next", N.arg = e), N.delegate = null, v) : V : (N.method = "throw", N.arg = new TypeError("iterator result is not an object"), N.delegate = null, v);
  }
  function D(L) {
    var N = {
      tryLoc: L[0]
    };
    1 in L && (N.catchLoc = L[1]), 2 in L && (N.finallyLoc = L[2], N.afterLoc = L[3]), this.tryEntries.push(N);
  }
  function I(L) {
    var N = L.completion || {};
    N.type = "normal", delete N.arg, L.completion = N;
  }
  function A(L) {
    this.tryEntries = [{
      tryLoc: "root"
    }], L.forEach(D, this), this.reset(!0);
  }
  function O(L) {
    if (L || L === "") {
      var N = L[a];
      if (N) return N.call(L);
      if (typeof L.next == "function") return L;
      if (!isNaN(L.length)) {
        var F = -1, G = function M() {
          for (; ++F < L.length; ) if (n.call(L, F)) return M.value = L[F], M.done = !1, M;
          return M.value = e, M.done = !0, M;
        };
        return G.next = G;
      }
    }
    throw new TypeError(xt(L) + " is not iterable");
  }
  return y.prototype = C, i(x, "constructor", {
    value: C,
    configurable: !0
  }), i(C, "constructor", {
    value: y,
    configurable: !0
  }), y.displayName = u(C, l, "GeneratorFunction"), t.isGeneratorFunction = function(L) {
    var N = typeof L == "function" && L.constructor;
    return !!N && (N === y || (N.displayName || N.name) === "GeneratorFunction");
  }, t.mark = function(L) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(L, C) : (L.__proto__ = C, u(L, l, "GeneratorFunction")), L.prototype = Object.create(x), L;
  }, t.awrap = function(L) {
    return {
      __await: L
    };
  }, E(R.prototype), u(R.prototype, s, function() {
    return this;
  }), t.AsyncIterator = R, t.async = function(L, N, F, G, M) {
    M === void 0 && (M = Promise);
    var V = new R(c(L, N, F, G), M);
    return t.isGeneratorFunction(N) ? V : V.next().then(function(z) {
      return z.done ? z.value : V.next();
    });
  }, E(x), u(x, l, "Generator"), u(x, a, function() {
    return this;
  }), u(x, "toString", function() {
    return "[object Generator]";
  }), t.keys = function(L) {
    var N = Object(L), F = [];
    for (var G in N) F.push(G);
    return F.reverse(), function M() {
      for (; F.length; ) {
        var V = F.pop();
        if (V in N) return M.value = V, M.done = !1, M;
      }
      return M.done = !0, M;
    };
  }, t.values = O, A.prototype = {
    constructor: A,
    reset: function(N) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = e, this.done = !1, this.delegate = null, this.method = "next", this.arg = e, this.tryEntries.forEach(I), !N) for (var F in this) F.charAt(0) === "t" && n.call(this, F) && !isNaN(+F.slice(1)) && (this[F] = e);
    },
    stop: function() {
      this.done = !0;
      var N = this.tryEntries[0].completion;
      if (N.type === "throw") throw N.arg;
      return this.rval;
    },
    dispatchException: function(N) {
      if (this.done) throw N;
      var F = this;
      function G(W, j) {
        return z.type = "throw", z.arg = N, F.next = W, j && (F.method = "next", F.arg = e), !!j;
      }
      for (var M = this.tryEntries.length - 1; M >= 0; --M) {
        var V = this.tryEntries[M], z = V.completion;
        if (V.tryLoc === "root") return G("end");
        if (V.tryLoc <= this.prev) {
          var k = n.call(V, "catchLoc"), $ = n.call(V, "finallyLoc");
          if (k && $) {
            if (this.prev < V.catchLoc) return G(V.catchLoc, !0);
            if (this.prev < V.finallyLoc) return G(V.finallyLoc);
          } else if (k) {
            if (this.prev < V.catchLoc) return G(V.catchLoc, !0);
          } else {
            if (!$) throw Error("try statement without catch or finally");
            if (this.prev < V.finallyLoc) return G(V.finallyLoc);
          }
        }
      }
    },
    abrupt: function(N, F) {
      for (var G = this.tryEntries.length - 1; G >= 0; --G) {
        var M = this.tryEntries[G];
        if (M.tryLoc <= this.prev && n.call(M, "finallyLoc") && this.prev < M.finallyLoc) {
          var V = M;
          break;
        }
      }
      V && (N === "break" || N === "continue") && V.tryLoc <= F && F <= V.finallyLoc && (V = null);
      var z = V ? V.completion : {};
      return z.type = N, z.arg = F, V ? (this.method = "next", this.next = V.finallyLoc, v) : this.complete(z);
    },
    complete: function(N, F) {
      if (N.type === "throw") throw N.arg;
      return N.type === "break" || N.type === "continue" ? this.next = N.arg : N.type === "return" ? (this.rval = this.arg = N.arg, this.method = "return", this.next = "end") : N.type === "normal" && F && (this.next = F), v;
    },
    finish: function(N) {
      for (var F = this.tryEntries.length - 1; F >= 0; --F) {
        var G = this.tryEntries[F];
        if (G.finallyLoc === N) return this.complete(G.completion, G.afterLoc), I(G), v;
      }
    },
    catch: function(N) {
      for (var F = this.tryEntries.length - 1; F >= 0; --F) {
        var G = this.tryEntries[F];
        if (G.tryLoc === N) {
          var M = G.completion;
          if (M.type === "throw") {
            var V = M.arg;
            I(G);
          }
          return V;
        }
      }
      throw Error("illegal catch attempt");
    },
    delegateYield: function(N, F, G) {
      return this.delegate = {
        iterator: O(N),
        resultName: F,
        nextLoc: G
      }, this.method === "next" && (this.arg = e), v;
    }
  }, t;
}
function u2(e, t, r, n, i, o, a) {
  try {
    var s = e[o](a), l = s.value;
  } catch (u) {
    return void r(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(n, i);
}
function Bc(e) {
  return function() {
    var t = this, r = arguments;
    return new Promise(function(n, i) {
      var o = e.apply(t, r);
      function a(l) {
        u2(o, n, i, a, s, "next", l);
      }
      function s(l) {
        u2(o, n, i, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
var uv = re({}, oq), Hee = uv.version, zee = uv.render, $ee = uv.unmountComponentAtNode, aS;
try {
  var Wee = Number((Hee || "").split(".")[0]);
  Wee >= 18 && (aS = uv.createRoot);
} catch {
}
function c2(e) {
  var t = uv.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  t && xt(t) === "object" && (t.usingClientEntryPoint = e);
}
var _0 = "__rc_react_root__";
function jee(e, t) {
  c2(!0);
  var r = t[_0] || aS(t);
  c2(!1), r.render(e), t[_0] = r;
}
function Uee(e, t) {
  zee(e, t);
}
function Kee(e, t) {
  if (aS) {
    jee(e, t);
    return;
  }
  Uee(e, t);
}
function Yee(e) {
  return HE.apply(this, arguments);
}
function HE() {
  return HE = Bc(/* @__PURE__ */ Si().mark(function e(t) {
    return Si().wrap(function(n) {
      for (; ; ) switch (n.prev = n.next) {
        case 0:
          return n.abrupt("return", Promise.resolve().then(function() {
            var i;
            (i = t[_0]) === null || i === void 0 || i.unmount(), delete t[_0];
          }));
        case 1:
        case "end":
          return n.stop();
      }
    }, e);
  })), HE.apply(this, arguments);
}
function qee(e) {
  $ee(e);
}
function Zee(e) {
  return zE.apply(this, arguments);
}
function zE() {
  return zE = Bc(/* @__PURE__ */ Si().mark(function e(t) {
    return Si().wrap(function(n) {
      for (; ; ) switch (n.prev = n.next) {
        case 0:
          if (aS === void 0) {
            n.next = 2;
            break;
          }
          return n.abrupt("return", Yee(t));
        case 2:
          qee(t);
        case 3:
        case "end":
          return n.stop();
      }
    }, e);
  })), zE.apply(this, arguments);
}
const _c = (e, t, r) => r !== void 0 ? r : `${e}-${t}`, nP = function(e) {
  if (!e)
    return !1;
  if (e instanceof Element) {
    if (e.offsetParent)
      return !0;
    if (e.getBBox) {
      var t = e.getBBox(), r = t.width, n = t.height;
      if (r || n)
        return !0;
    }
    if (e.getBoundingClientRect) {
      var i = e.getBoundingClientRect(), o = i.width, a = i.height;
      if (o || a)
        return !0;
    }
  }
  return !1;
}, Xee = (e) => {
  const {
    componentCls: t,
    colorPrimary: r
  } = e;
  return {
    [t]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${r})`,
      boxShadow: "0 0 0 0 currentcolor",
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${e.motionEaseOutCirc}`, `opacity 2s ${e.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: "0 0 0 6px currentcolor",
          opacity: 0
        },
        "&.wave-quick": {
          transition: [`box-shadow ${e.motionDurationSlow} ${e.motionEaseInOut}`, `opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`].join(",")
        }
      }
    }
  };
}, Qee = ZT("Wave", (e) => [Xee(e)]), Jz = `${$z}-wave-target`;
function Jee(e) {
  const t = (e || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return t && t[1] && t[2] && t[3] ? !(t[1] === t[2] && t[2] === t[3]) : !0;
}
function Nw(e) {
  return e && e !== "#fff" && e !== "#ffffff" && e !== "rgb(255, 255, 255)" && e !== "rgba(255, 255, 255, 1)" && Jee(e) && !/rgba\((?:\d*, ){3}0\)/.test(e) && // any transparent rgba color
  e !== "transparent";
}
function ete(e) {
  const {
    borderTopColor: t,
    borderColor: r,
    backgroundColor: n
  } = getComputedStyle(e);
  return Nw(t) ? t : Nw(r) ? r : Nw(n) ? n : null;
}
function kw(e) {
  return Number.isNaN(e) ? 0 : e;
}
const tte = (e) => {
  const {
    className: t,
    target: r,
    component: n
  } = e, i = T.useRef(null), [o, a] = T.useState(null), [s, l] = T.useState([]), [u, c] = T.useState(0), [d, h] = T.useState(0), [f, p] = T.useState(0), [g, v] = T.useState(0), [m, y] = T.useState(!1), C = {
    left: u,
    top: d,
    width: f,
    height: g,
    borderRadius: s.map((w) => `${w}px`).join(" ")
  };
  o && (C["--wave-color"] = o);
  function S() {
    const w = getComputedStyle(r);
    a(ete(r));
    const x = w.position === "static", {
      borderLeftWidth: E,
      borderTopWidth: R
    } = w;
    c(x ? r.offsetLeft : kw(-parseFloat(E))), h(x ? r.offsetTop : kw(-parseFloat(R))), p(r.offsetWidth), v(r.offsetHeight);
    const {
      borderTopLeftRadius: _,
      borderTopRightRadius: P,
      borderBottomLeftRadius: D,
      borderBottomRightRadius: I
    } = w;
    l([_, P, I, D].map((A) => kw(parseFloat(A))));
  }
  if (T.useEffect(() => {
    if (r) {
      const w = cn(() => {
        S(), y(!0);
      });
      let x;
      return typeof ResizeObserver < "u" && (x = new ResizeObserver(S), x.observe(r)), () => {
        cn.cancel(w), x == null || x.disconnect();
      };
    }
  }, []), !m)
    return null;
  const b = (n === "Checkbox" || n === "Radio") && (r == null ? void 0 : r.classList.contains(Jz));
  return /* @__PURE__ */ T.createElement(ns, {
    visible: !0,
    motionAppear: !0,
    motionName: "wave-motion",
    motionDeadline: 5e3,
    onAppearEnd: (w, x) => {
      var E;
      if (x.deadline || x.propertyName === "opacity") {
        const R = (E = i.current) === null || E === void 0 ? void 0 : E.parentElement;
        Zee(R).then(() => {
          R == null || R.remove();
        });
      }
      return !1;
    }
  }, (w, x) => {
    let {
      className: E
    } = w;
    return /* @__PURE__ */ T.createElement("div", {
      ref: Vo(i, x),
      className: pe(t, E, {
        "wave-quick": b
      }),
      style: C
    });
  });
}, rte = (e, t) => {
  var r;
  const {
    component: n
  } = t;
  if (n === "Checkbox" && !(!((r = e.querySelector("input")) === null || r === void 0) && r.checked))
    return;
  const i = document.createElement("div");
  i.style.position = "absolute", i.style.left = "0px", i.style.top = "0px", e == null || e.insertBefore(i, e == null ? void 0 : e.firstChild), Kee(/* @__PURE__ */ T.createElement(tte, Object.assign({}, t, {
    target: e
  })), i);
}, nte = (e, t, r) => {
  const {
    wave: n
  } = T.useContext(Xt), [, i, o] = Xa(), a = Mn((u) => {
    const c = e.current;
    if (n != null && n.disabled || !c)
      return;
    const d = c.querySelector(`.${Jz}`) || c, {
      showEffect: h
    } = n || {};
    (h || rte)(d, {
      className: t,
      token: i,
      component: r,
      event: u,
      hashId: o
    });
  }), s = T.useRef();
  return (u) => {
    cn.cancel(s.current), s.current = cn(() => {
      a(u);
    });
  };
}, iP = (e) => {
  const {
    children: t,
    disabled: r,
    component: n
  } = e, {
    getPrefixCls: i
  } = rr(Xt), o = le(null), a = i("wave"), [, s] = Qee(a), l = nte(o, pe(a, s), n);
  if (H.useEffect(() => {
    const c = o.current;
    if (!c || c.nodeType !== 1 || r)
      return;
    const d = (h) => {
      !nP(h.target) || // No need wave
      !c.getAttribute || c.getAttribute("disabled") || c.disabled || c.className.includes("disabled") || c.className.includes("-leave") || l(h);
    };
    return c.addEventListener("click", d, !0), () => {
      c.removeEventListener("click", d, !0);
    };
  }, [r]), !/* @__PURE__ */ H.isValidElement(t))
    return t ?? null;
  const u = kc(t) ? Vo(t.ref, o) : o;
  return Rc(t, {
    ref: u
  });
};
process.env.NODE_ENV !== "production" && (iP.displayName = "Wave");
const Gc = (e) => {
  const t = H.useContext(Th);
  return H.useMemo(() => e ? typeof e == "string" ? e ?? t : e instanceof Function ? e(t) : t : t, [e, t]);
}, e5 = /* @__PURE__ */ T.createContext(null), oP = (e, t) => {
  const r = T.useContext(e5), n = T.useMemo(() => {
    if (!r)
      return "";
    const {
      compactDirection: i,
      isFirstItem: o,
      isLastItem: a
    } = r, s = i === "vertical" ? "-vertical-" : "-";
    return pe(`${e}-compact${s}item`, {
      [`${e}-compact${s}first-item`]: o,
      [`${e}-compact${s}last-item`]: a,
      [`${e}-compact${s}item-rtl`]: t === "rtl"
    });
  }, [e, t, r]);
  return {
    compactSize: r == null ? void 0 : r.compactSize,
    compactDirection: r == null ? void 0 : r.compactDirection,
    compactItemClassnames: n
  };
}, ite = (e) => {
  let {
    children: t
  } = e;
  return /* @__PURE__ */ T.createElement(e5.Provider, {
    value: null
  }, t);
};
var ote = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const t5 = /* @__PURE__ */ T.createContext(void 0), ate = (e) => {
  const {
    getPrefixCls: t,
    direction: r
  } = T.useContext(Xt), {
    prefixCls: n,
    size: i,
    className: o
  } = e, a = ote(e, ["prefixCls", "size", "className"]), s = t("btn-group", n), [, , l] = Xa();
  let u = "";
  switch (i) {
    case "large":
      u = "lg";
      break;
    case "small":
      u = "sm";
      break;
  }
  if (process.env.NODE_ENV !== "production") {
    const d = mn("Button.Group");
    process.env.NODE_ENV !== "production" && d(!i || ["large", "small", "middle"].includes(i), "usage", "Invalid prop `size`.");
  }
  const c = pe(s, {
    [`${s}-${u}`]: u,
    [`${s}-rtl`]: r === "rtl"
  }, o, l);
  return /* @__PURE__ */ T.createElement(t5.Provider, {
    value: i
  }, /* @__PURE__ */ T.createElement("div", Object.assign({}, a, {
    className: c
  })));
}, d2 = /^[\u4e00-\u9fa5]{2}$/, $E = d2.test.bind(d2);
function r5(e) {
  return e === "danger" ? {
    danger: !0
  } : {
    type: e
  };
}
function h2(e) {
  return typeof e == "string";
}
function cm(e) {
  return e === "text" || e === "link";
}
function ste(e, t) {
  if (e == null)
    return;
  const r = t ? " " : "";
  return typeof e != "string" && typeof e != "number" && h2(e.type) && $E(e.props.children) ? Rc(e, {
    children: e.props.children.split("").join(r)
  }) : h2(e) ? $E(e) ? /* @__PURE__ */ H.createElement("span", null, e.split("").join(r)) : /* @__PURE__ */ H.createElement("span", null, e) : Zz(e) ? /* @__PURE__ */ H.createElement("span", null, e) : e;
}
function lte(e, t) {
  let r = !1;
  const n = [];
  return H.Children.forEach(e, (i) => {
    const o = typeof i, a = o === "string" || o === "number";
    if (r && a) {
      const s = n.length - 1, l = n[s];
      n[s] = `${l}${i}`;
    } else
      n.push(i);
    r = a;
  }), H.Children.map(n, (i) => ste(i, t));
}
const n5 = /* @__PURE__ */ fn((e, t) => {
  const {
    className: r,
    style: n,
    children: i,
    prefixCls: o
  } = e, a = pe(`${o}-icon`, r);
  return /* @__PURE__ */ H.createElement("span", {
    ref: t,
    className: a,
    style: n
  }, i);
}), f2 = /* @__PURE__ */ fn((e, t) => {
  const {
    prefixCls: r,
    className: n,
    style: i,
    iconClassName: o
  } = e, a = pe(`${r}-loading-icon`, n);
  return /* @__PURE__ */ H.createElement(n5, {
    prefixCls: r,
    className: a,
    style: i,
    ref: t
  }, /* @__PURE__ */ H.createElement(eP, {
    className: o
  }));
}), Vw = () => ({
  width: 0,
  opacity: 0,
  transform: "scale(0)"
}), Bw = (e) => ({
  width: e.scrollWidth,
  opacity: 1,
  transform: "scale(1)"
}), ute = (e) => {
  const {
    prefixCls: t,
    loading: r,
    existIcon: n,
    className: i,
    style: o
  } = e, a = !!r;
  return n ? /* @__PURE__ */ H.createElement(f2, {
    prefixCls: t,
    className: i,
    style: o
  }) : /* @__PURE__ */ H.createElement(ns, {
    visible: a,
    // We do not really use this motionName
    motionName: `${t}-loading-icon-motion`,
    motionLeave: a,
    removeOnLeave: !0,
    onAppearStart: Vw,
    onAppearActive: Bw,
    onEnterStart: Vw,
    onEnterActive: Bw,
    onLeaveStart: Bw,
    onLeaveActive: Vw
  }, (s, l) => {
    let {
      className: u,
      style: c
    } = s;
    return /* @__PURE__ */ H.createElement(f2, {
      prefixCls: t,
      className: i,
      style: Object.assign(Object.assign({}, o), c),
      ref: l,
      iconClassName: u
    });
  });
}, p2 = (e, t) => ({
  // Border
  [`> span, > ${e}`]: {
    "&:not(:last-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: t
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: t
        }
      }
    }
  }
}), cte = (e) => {
  const {
    componentCls: t,
    fontSize: r,
    lineWidth: n,
    groupBorderColor: i,
    colorErrorHover: o
  } = e;
  return {
    [`${t}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${t}`]: {
          "&:not(:last-child)": {
            [`&, & > ${t}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: e.calc(n).mul(-1).equal(),
            [`&, & > ${t}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [t]: {
          position: "relative",
          zIndex: 1,
          "&:hover, &:focus, &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${t}-icon-only`]: {
          fontSize: r
        }
      },
      // Border Color
      p2(`${t}-primary`, i),
      p2(`${t}-danger`, o)
    ]
  };
}, i5 = (e) => {
  const {
    paddingInline: t,
    onlyIconSize: r,
    paddingBlock: n
  } = e;
  return dn(e, {
    buttonPaddingHorizontal: t,
    buttonPaddingVertical: n,
    buttonIconOnlyFontSize: r
  });
}, o5 = (e) => {
  var t, r, n, i, o, a;
  const s = (t = e.contentFontSize) !== null && t !== void 0 ? t : e.fontSize, l = (r = e.contentFontSizeSM) !== null && r !== void 0 ? r : e.fontSize, u = (n = e.contentFontSizeLG) !== null && n !== void 0 ? n : e.fontSizeLG, c = (i = e.contentLineHeight) !== null && i !== void 0 ? i : Wy(s), d = (o = e.contentLineHeightSM) !== null && o !== void 0 ? o : Wy(l), h = (a = e.contentLineHeightLG) !== null && a !== void 0 ? a : Wy(u);
  return {
    fontWeight: 400,
    defaultShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlTmpOutline}`,
    primaryShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlOutline}`,
    dangerShadow: `0 ${e.controlOutlineWidth}px 0 ${e.colorErrorOutline}`,
    primaryColor: e.colorTextLightSolid,
    dangerColor: e.colorTextLightSolid,
    borderColorDisabled: e.colorBorder,
    defaultGhostColor: e.colorBgContainer,
    ghostBg: "transparent",
    defaultGhostBorderColor: e.colorBgContainer,
    paddingInline: e.paddingContentHorizontal - e.lineWidth,
    paddingInlineLG: e.paddingContentHorizontal - e.lineWidth,
    paddingInlineSM: 8 - e.lineWidth,
    onlyIconSize: e.fontSizeLG,
    onlyIconSizeSM: e.fontSizeLG - 2,
    onlyIconSizeLG: e.fontSizeLG + 2,
    groupBorderColor: e.colorPrimaryHover,
    linkHoverBg: "transparent",
    textHoverBg: e.colorBgTextHover,
    defaultColor: e.colorText,
    defaultBg: e.colorBgContainer,
    defaultBorderColor: e.colorBorder,
    defaultBorderColorDisabled: e.colorBorder,
    defaultHoverBg: e.colorBgContainer,
    defaultHoverColor: e.colorPrimaryHover,
    defaultHoverBorderColor: e.colorPrimaryHover,
    defaultActiveBg: e.colorBgContainer,
    defaultActiveColor: e.colorPrimaryActive,
    defaultActiveBorderColor: e.colorPrimaryActive,
    contentFontSize: s,
    contentFontSizeSM: l,
    contentFontSizeLG: u,
    contentLineHeight: c,
    contentLineHeightSM: d,
    contentLineHeightLG: h,
    paddingBlock: Math.max((e.controlHeight - s * c) / 2 - e.lineWidth, 0),
    paddingBlockSM: Math.max((e.controlHeightSM - l * d) / 2 - e.lineWidth, 0),
    paddingBlockLG: Math.max((e.controlHeightLG - u * h) / 2 - e.lineWidth, 0)
  };
}, dte = (e) => {
  const {
    componentCls: t,
    iconCls: r,
    fontWeight: n
  } = e;
  return {
    [t]: {
      outline: "none",
      position: "relative",
      display: "inline-flex",
      gap: e.marginXS,
      alignItems: "center",
      justifyContent: "center",
      fontWeight: n,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      background: "transparent",
      border: `${xe(e.lineWidth)} ${e.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      color: e.colorText,
      "&:disabled > *": {
        pointerEvents: "none"
      },
      "> span": {
        display: "inline-block"
      },
      [`${t}-icon`]: {
        lineHeight: 1
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": Object.assign({}, nS(e)),
      [`&${t}-two-chinese-chars::first-letter`]: {
        letterSpacing: "0.34em"
      },
      [`&${t}-two-chinese-chars > *:not(${r})`]: {
        marginInlineEnd: "-0.34em",
        letterSpacing: "0.34em"
      },
      // iconPosition="end"
      "&-icon-end": {
        flexDirection: "row-reverse"
      }
    }
  };
}, Vs = (e, t, r) => ({
  [`&:not(:disabled):not(${e}-disabled)`]: {
    "&:hover": t,
    "&:active": r
  }
}), hte = (e) => ({
  minWidth: e.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), fte = (e) => ({
  borderRadius: e.controlHeight,
  paddingInlineStart: e.calc(e.controlHeight).div(2).equal(),
  paddingInlineEnd: e.calc(e.controlHeight).div(2).equal()
}), pte = (e) => ({
  cursor: "not-allowed",
  borderColor: e.borderColorDisabled,
  color: e.colorTextDisabled,
  background: e.colorBgContainerDisabled,
  boxShadow: "none"
}), Eg = (e, t, r, n, i, o, a, s) => ({
  [`&${e}-background-ghost`]: Object.assign(Object.assign({
    color: r || void 0,
    background: t,
    borderColor: n || void 0,
    boxShadow: "none"
  }, Vs(e, Object.assign({
    background: t
  }, a), Object.assign({
    background: t
  }, s))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: i || void 0,
      borderColor: o || void 0
    }
  })
}), aP = (e) => ({
  [`&:disabled, &${e.componentCls}-disabled`]: Object.assign({}, pte(e))
}), a5 = (e) => Object.assign({}, aP(e)), T0 = (e) => ({
  [`&:disabled, &${e.componentCls}-disabled`]: {
    cursor: "not-allowed",
    color: e.colorTextDisabled
  }
}), s5 = (e) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, a5(e)), {
  background: e.defaultBg,
  borderColor: e.defaultBorderColor,
  color: e.defaultColor,
  boxShadow: e.defaultShadow
}), Vs(e.componentCls, {
  color: e.defaultHoverColor,
  borderColor: e.defaultHoverBorderColor,
  background: e.defaultHoverBg
}, {
  color: e.defaultActiveColor,
  borderColor: e.defaultActiveBorderColor,
  background: e.defaultActiveBg
})), Eg(e.componentCls, e.ghostBg, e.defaultGhostColor, e.defaultGhostBorderColor, e.colorTextDisabled, e.colorBorder)), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    color: e.colorError,
    borderColor: e.colorError
  }, Vs(e.componentCls, {
    color: e.colorErrorHover,
    borderColor: e.colorErrorBorderHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), Eg(e.componentCls, e.ghostBg, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder)), aP(e))
}), gte = (e) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, a5(e)), {
  color: e.primaryColor,
  background: e.colorPrimary,
  boxShadow: e.primaryShadow
}), Vs(e.componentCls, {
  color: e.colorTextLightSolid,
  background: e.colorPrimaryHover
}, {
  color: e.colorTextLightSolid,
  background: e.colorPrimaryActive
})), Eg(e.componentCls, e.ghostBg, e.colorPrimary, e.colorPrimary, e.colorTextDisabled, e.colorBorder, {
  color: e.colorPrimaryHover,
  borderColor: e.colorPrimaryHover
}, {
  color: e.colorPrimaryActive,
  borderColor: e.colorPrimaryActive
})), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
    background: e.colorError,
    boxShadow: e.dangerShadow,
    color: e.dangerColor
  }, Vs(e.componentCls, {
    background: e.colorErrorHover
  }, {
    background: e.colorErrorActive
  })), Eg(e.componentCls, e.ghostBg, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder, {
    color: e.colorErrorHover,
    borderColor: e.colorErrorHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), aP(e))
}), vte = (e) => Object.assign(Object.assign({}, s5(e)), {
  borderStyle: "dashed"
}), mte = (e) => Object.assign(Object.assign(Object.assign({
  color: e.colorLink
}, Vs(e.componentCls, {
  color: e.colorLinkHover,
  background: e.linkHoverBg
}, {
  color: e.colorLinkActive
})), T0(e)), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: e.colorError
  }, Vs(e.componentCls, {
    color: e.colorErrorHover
  }, {
    color: e.colorErrorActive
  })), T0(e))
}), yte = (e) => Object.assign(Object.assign(Object.assign({}, Vs(e.componentCls, {
  color: e.colorText,
  background: e.textHoverBg
}, {
  color: e.colorText,
  background: e.colorBgTextActive
})), T0(e)), {
  [`&${e.componentCls}-dangerous`]: Object.assign(Object.assign({
    color: e.colorError
  }, T0(e)), Vs(e.componentCls, {
    color: e.colorErrorHover,
    background: e.colorErrorBg
  }, {
    color: e.colorErrorHover,
    background: e.colorErrorBgActive
  }))
}), Cte = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-default`]: s5(e),
    [`${t}-primary`]: gte(e),
    [`${t}-dashed`]: vte(e),
    [`${t}-link`]: mte(e),
    [`${t}-text`]: yte(e),
    [`${t}-ghost`]: Eg(e.componentCls, e.ghostBg, e.colorBgContainer, e.colorBgContainer, e.colorTextDisabled, e.colorBorder)
  };
}, sP = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls: r,
    controlHeight: n,
    fontSize: i,
    lineHeight: o,
    borderRadius: a,
    buttonPaddingHorizontal: s,
    iconCls: l,
    buttonPaddingVertical: u
  } = e, c = `${r}-icon-only`;
  return [
    {
      [`${t}`]: {
        fontSize: i,
        lineHeight: o,
        height: n,
        padding: `${xe(u)} ${xe(s)}`,
        borderRadius: a,
        [`&${c}`]: {
          width: n,
          paddingInline: 0,
          // make `btn-icon-only` not too narrow
          [`&${r}-compact-item`]: {
            flex: "none"
          },
          [`&${r}-round`]: {
            width: "auto"
          },
          [l]: {
            fontSize: e.buttonIconOnlyFontSize
          }
        },
        // Loading
        [`&${r}-loading`]: {
          opacity: e.opacityLoading,
          cursor: "default"
        },
        [`${r}-loading-icon`]: {
          transition: `width ${e.motionDurationSlow} ${e.motionEaseInOut}, opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${r}${r}-circle${t}`]: hte(e)
    },
    {
      [`${r}${r}-round${t}`]: fte(e)
    }
  ];
}, Ste = (e) => {
  const t = dn(e, {
    fontSize: e.contentFontSize,
    lineHeight: e.contentLineHeight
  });
  return sP(t, e.componentCls);
}, wte = (e) => {
  const t = dn(e, {
    controlHeight: e.controlHeightSM,
    fontSize: e.contentFontSizeSM,
    lineHeight: e.contentLineHeightSM,
    padding: e.paddingXS,
    buttonPaddingHorizontal: e.paddingInlineSM,
    buttonPaddingVertical: e.paddingBlockSM,
    borderRadius: e.borderRadiusSM,
    buttonIconOnlyFontSize: e.onlyIconSizeSM
  });
  return sP(t, `${e.componentCls}-sm`);
}, bte = (e) => {
  const t = dn(e, {
    controlHeight: e.controlHeightLG,
    fontSize: e.contentFontSizeLG,
    lineHeight: e.contentLineHeightLG,
    buttonPaddingHorizontal: e.paddingInlineLG,
    buttonPaddingVertical: e.paddingBlockLG,
    borderRadius: e.borderRadiusLG,
    buttonIconOnlyFontSize: e.onlyIconSizeLG
  });
  return sP(t, `${e.componentCls}-lg`);
}, xte = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`&${t}-block`]: {
        width: "100%"
      }
    }
  };
}, Ete = Gi("Button", (e) => {
  const t = i5(e);
  return [
    // Shared
    dte(t),
    // Size
    Ste(t),
    wte(t),
    bte(t),
    // Block
    xte(t),
    // Group (type, ghost, danger, loading)
    Cte(t),
    // Button Group
    cte(t)
  ];
}, o5, {
  unitless: {
    fontWeight: !0,
    contentLineHeight: !0,
    contentLineHeightSM: !0,
    contentLineHeightLG: !0
  }
});
function Rte(e, t, r) {
  const {
    focusElCls: n,
    focus: i,
    borderElCls: o
  } = r, a = o ? "> *" : "", s = ["hover", i ? "focus" : null, "active"].filter(Boolean).map((l) => `&:${l} ${a}`).join(",");
  return {
    [`&-item:not(${t}-last-item)`]: {
      marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal()
    },
    "&-item": Object.assign(Object.assign({
      [s]: {
        zIndex: 2
      }
    }, n ? {
      [`&${n}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${a}`]: {
        zIndex: 0
      }
    })
  };
}
function _te(e, t, r) {
  const {
    borderElCls: n
  } = r, i = n ? `> ${n}` : "";
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item) ${i}`]: {
      borderRadius: 0
    },
    [`&-item:not(${t}-last-item)${t}-first-item`]: {
      [`& ${i}, &${e}-sm ${i}, &${e}-lg ${i}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${t}-first-item)${t}-last-item`]: {
      [`& ${i}, &${e}-sm ${i}, &${e}-lg ${i}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function l5(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls: r
  } = e, n = `${r}-compact`;
  return {
    [n]: Object.assign(Object.assign({}, Rte(e, n, t)), _te(r, n, t))
  };
}
function Tte(e, t) {
  return {
    // border collapse
    [`&-item:not(${t}-last-item)`]: {
      marginBottom: e.calc(e.lineWidth).mul(-1).equal()
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function Pte(e, t) {
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${t}-first-item:not(${t}-last-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${t}-last-item:not(${t}-first-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function Mte(e) {
  const t = `${e.componentCls}-compact-vertical`;
  return {
    [t]: Object.assign(Object.assign({}, Tte(e, t)), Pte(e.componentCls, t))
  };
}
const Dte = (e) => {
  const {
    componentCls: t,
    calc: r
  } = e;
  return {
    [t]: {
      // Special styles for Primary Button
      [`&-compact-item${t}-primary`]: {
        [`&:not([disabled]) + ${t}-compact-item${t}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: r(e.lineWidth).mul(-1).equal(),
            insetInlineStart: r(e.lineWidth).mul(-1).equal(),
            display: "inline-block",
            width: e.lineWidth,
            height: `calc(100% + ${xe(e.lineWidth)} * 2)`,
            backgroundColor: e.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${t}-primary`]: {
          [`&:not([disabled]) + ${t}-compact-vertical-item${t}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: r(e.lineWidth).mul(-1).equal(),
              insetInlineStart: r(e.lineWidth).mul(-1).equal(),
              display: "inline-block",
              width: `calc(100% + ${xe(e.lineWidth)} * 2)`,
              height: e.lineWidth,
              backgroundColor: e.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
}, Ate = XT(["Button", "compact"], (e) => {
  const t = i5(e);
  return [
    // Space Compact
    l5(t),
    Mte(t),
    Dte(t)
  ];
}, o5);
var Ite = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function Fte(e) {
  if (typeof e == "object" && e) {
    let t = e == null ? void 0 : e.delay;
    return t = !Number.isNaN(t) && typeof t == "number" ? t : 0, {
      loading: t <= 0,
      delay: t
    };
  }
  return {
    loading: !!e,
    delay: 0
  };
}
const Lte = /* @__PURE__ */ H.forwardRef((e, t) => {
  var r, n, i;
  const {
    loading: o = !1,
    prefixCls: a,
    type: s,
    danger: l = !1,
    shape: u = "default",
    size: c,
    styles: d,
    disabled: h,
    className: f,
    rootClassName: p,
    children: g,
    icon: v,
    iconPosition: m = "start",
    ghost: y = !1,
    block: C = !1,
    // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
    htmlType: S = "button",
    classNames: b,
    style: w = {},
    autoInsertSpace: x
  } = e, E = Ite(e, ["loading", "prefixCls", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "iconPosition", "ghost", "block", "htmlType", "classNames", "style", "autoInsertSpace"]), R = s || "default", {
    getPrefixCls: _,
    direction: P,
    button: D
  } = rr(Xt), I = (r = x ?? (D == null ? void 0 : D.autoInsertSpace)) !== null && r !== void 0 ? r : !0, A = _("btn", a), [O, L, N] = Ete(A), F = rr(_h), G = h ?? F, M = rr(t5), V = ct(() => Fte(o), [o]), [z, k] = Ee(V.loading), [$, W] = Ee(!1), U = Vo(t, /* @__PURE__ */ JY()), Z = QY.count(g) === 1 && !v && !cm(R);
  It(() => {
    let $e = null;
    V.delay > 0 ? $e = setTimeout(() => {
      $e = null, k(!0);
    }, V.delay) : k(V.loading);
    function Je() {
      $e && (clearTimeout($e), $e = null);
    }
    return Je;
  }, [V]), It(() => {
    if (!U || !U.current || !I)
      return;
    const $e = U.current.textContent;
    Z && $E($e) ? $ || W(!0) : $ && W(!1);
  }, [U]);
  const ee = ($e) => {
    const {
      onClick: Je
    } = e;
    if (z || G) {
      $e.preventDefault();
      return;
    }
    Je == null || Je($e);
  };
  if (process.env.NODE_ENV !== "production") {
    const $e = mn("Button");
    process.env.NODE_ENV !== "production" && $e(!(typeof v == "string" && v.length > 2), "breaking", `\`icon\` is using ReactNode instead of string naming in v4. Please check \`${v}\` at https://ant.design/components/icon`), process.env.NODE_ENV !== "production" && $e(!(y && cm(R)), "usage", "`link` or `text` button can't be a `ghost` button.");
  }
  const {
    compactSize: J,
    compactItemClassnames: X
  } = oP(A, P), Y = {
    large: "lg",
    small: "sm",
    middle: void 0
  }, de = Gc(($e) => {
    var Je, Q;
    return (Q = (Je = c ?? J) !== null && Je !== void 0 ? Je : M) !== null && Q !== void 0 ? Q : $e;
  }), K = de && Y[de] || "", ie = z ? "loading" : v, Ce = Bi(E, ["navigate"]), Te = pe(A, L, N, {
    [`${A}-${u}`]: u !== "default" && u,
    [`${A}-${R}`]: R,
    [`${A}-${K}`]: K,
    [`${A}-icon-only`]: !g && g !== 0 && !!ie,
    [`${A}-background-ghost`]: y && !cm(R),
    [`${A}-loading`]: z,
    [`${A}-two-chinese-chars`]: $ && I && !z,
    [`${A}-block`]: C,
    [`${A}-dangerous`]: l,
    [`${A}-rtl`]: P === "rtl",
    [`${A}-icon-end`]: m === "end"
  }, X, f, p, D == null ? void 0 : D.className), Ie = Object.assign(Object.assign({}, D == null ? void 0 : D.style), w), we = pe(b == null ? void 0 : b.icon, (n = D == null ? void 0 : D.classNames) === null || n === void 0 ? void 0 : n.icon), Re = Object.assign(Object.assign({}, (d == null ? void 0 : d.icon) || {}), ((i = D == null ? void 0 : D.styles) === null || i === void 0 ? void 0 : i.icon) || {}), _e = v && !z ? /* @__PURE__ */ H.createElement(n5, {
    prefixCls: A,
    className: we,
    style: Re
  }, v) : /* @__PURE__ */ H.createElement(ute, {
    existIcon: !!v,
    prefixCls: A,
    loading: z
  }), He = g || g === 0 ? lte(g, Z && I) : null;
  if (Ce.href !== void 0)
    return O(/* @__PURE__ */ H.createElement("a", Object.assign({}, Ce, {
      className: pe(Te, {
        [`${A}-disabled`]: G
      }),
      href: G ? void 0 : Ce.href,
      style: Ie,
      onClick: ee,
      ref: U,
      tabIndex: G ? -1 : 0
    }), _e, He));
  let Ve = /* @__PURE__ */ H.createElement("button", Object.assign({}, E, {
    type: S,
    className: Te,
    style: Ie,
    onClick: ee,
    disabled: G,
    ref: U
  }), _e, He, !!X && /* @__PURE__ */ H.createElement(Ate, {
    key: "compact",
    prefixCls: A
  }));
  return cm(R) || (Ve = /* @__PURE__ */ H.createElement(iP, {
    component: "Button",
    disabled: z
  }, Ve)), O(Ve);
}), Qn = Lte;
Qn.Group = ate;
Qn.__ANT_BUTTON = !0;
process.env.NODE_ENV !== "production" && (Qn.displayName = "Button");
function Gw(e) {
  return !!(e != null && e.then);
}
const Ote = (e) => {
  const {
    type: t,
    children: r,
    prefixCls: n,
    buttonProps: i,
    close: o,
    autoFocus: a,
    emitEvent: s,
    isSilent: l,
    quitOnNullishReturnValue: u,
    actionFn: c
  } = e, d = T.useRef(!1), h = T.useRef(null), [f, p] = Ph(!1), g = function() {
    o == null || o.apply(void 0, arguments);
  };
  T.useEffect(() => {
    let y = null;
    return a && (y = setTimeout(() => {
      var C;
      (C = h.current) === null || C === void 0 || C.focus();
    })), () => {
      y && clearTimeout(y);
    };
  }, []);
  const v = (y) => {
    Gw(y) && (p(!0), y.then(function() {
      p(!1, !0), g.apply(void 0, arguments), d.current = !1;
    }, (C) => {
      if (p(!1, !0), d.current = !1, !(l != null && l()))
        return Promise.reject(C);
    }));
  }, m = (y) => {
    if (d.current)
      return;
    if (d.current = !0, !c) {
      g();
      return;
    }
    let C;
    if (s) {
      if (C = c(y), u && !Gw(C)) {
        d.current = !1, g(y);
        return;
      }
    } else if (c.length)
      C = c(o), d.current = !1;
    else if (C = c(), !Gw(C)) {
      g();
      return;
    }
    v(C);
  };
  return /* @__PURE__ */ T.createElement(Qn, Object.assign({}, r5(t), {
    onClick: m,
    loading: f,
    prefixCls: n
  }, i, {
    ref: h
  }), r);
};
var u5 = /* @__PURE__ */ T.createContext(null), g2 = [];
function Nte(e, t) {
  var r = T.useState(function() {
    if (!mi())
      return null;
    var p = document.createElement("div");
    return process.env.NODE_ENV !== "production" && t && p.setAttribute("data-debug", t), p;
  }), n = ue(r, 1), i = n[0], o = T.useRef(!1), a = T.useContext(u5), s = T.useState(g2), l = ue(s, 2), u = l[0], c = l[1], d = a || (o.current ? void 0 : function(p) {
    c(function(g) {
      var v = [p].concat(rt(g));
      return v;
    });
  });
  function h() {
    i.parentElement || document.body.appendChild(i), o.current = !0;
  }
  function f() {
    var p;
    (p = i.parentElement) === null || p === void 0 || p.removeChild(i), o.current = !1;
  }
  return Wr(function() {
    return e ? a ? a(h) : h() : f(), f;
  }, [e]), Wr(function() {
    u.length && (u.forEach(function(p) {
      return p();
    }), c(g2));
  }, [u]), [i, d];
}
function kte(e) {
  var t = "rc-scrollbar-measure-".concat(Math.random().toString(36).substring(7)), r = document.createElement("div");
  r.id = t;
  var n = r.style;
  n.position = "absolute", n.left = "0", n.top = "0", n.width = "100px", n.height = "100px", n.overflow = "scroll";
  var i, o;
  if (e) {
    var a = getComputedStyle(e);
    n.scrollbarColor = a.scrollbarColor, n.scrollbarWidth = a.scrollbarWidth;
    var s = getComputedStyle(e, "::-webkit-scrollbar"), l = parseInt(s.width, 10), u = parseInt(s.height, 10);
    try {
      var c = l ? "width: ".concat(s.width, ";") : "", d = u ? "height: ".concat(s.height, ";") : "";
      Ms(`
#`.concat(t, `::-webkit-scrollbar {
`).concat(c, `
`).concat(d, `
}`), t);
    } catch (p) {
      console.error(p), i = l, o = u;
    }
  }
  document.body.appendChild(r);
  var h = e && i && !isNaN(i) ? i : r.offsetWidth - r.clientWidth, f = e && o && !isNaN(o) ? o : r.offsetHeight - r.clientHeight;
  return document.body.removeChild(r), yg(t), {
    width: h,
    height: f
  };
}
function Vte(e) {
  return typeof document > "u" || !e || !(e instanceof Element) ? {
    width: 0,
    height: 0
  } : kte(e);
}
function Bte() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
var Gte = "rc-util-locker-".concat(Date.now()), v2 = 0;
function Hte(e) {
  var t = !!e, r = T.useState(function() {
    return v2 += 1, "".concat(Gte, "_").concat(v2);
  }), n = ue(r, 1), i = n[0];
  Wr(function() {
    if (t) {
      var o = Vte(document.body).width, a = Bte();
      Ms(`
html body {
  overflow-y: hidden;
  `.concat(a ? "width: calc(100% - ".concat(o, "px);") : "", `
}`), i);
    } else
      yg(i);
    return function() {
      yg(i);
    };
  }, [t, i]);
}
var zte = !1;
function $te(e) {
  return zte;
}
var m2 = function(t) {
  return t === !1 ? !1 : !mi() || !t ? null : typeof t == "string" ? document.querySelector(t) : typeof t == "function" ? t() : t;
}, cv = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.open, n = e.autoLock, i = e.getContainer, o = e.debug, a = e.autoDestroy, s = a === void 0 ? !0 : a, l = e.children, u = T.useState(r), c = ue(u, 2), d = c[0], h = c[1], f = d || r;
  process.env.NODE_ENV !== "production" && gr(mi() || !r, "Portal only work in client side. Please call 'useEffect' to show Portal instead default render in SSR."), T.useEffect(function() {
    (s || r) && h(r);
  }, [r, s]);
  var p = T.useState(function() {
    return m2(i);
  }), g = ue(p, 2), v = g[0], m = g[1];
  T.useEffect(function() {
    var D = m2(i);
    m(D ?? null);
  });
  var y = Nte(f && !v, o), C = ue(y, 2), S = C[0], b = C[1], w = v ?? S;
  Hte(n && r && mi() && (w === S || w === document.body));
  var x = null;
  if (l && kc(l) && t) {
    var E = l;
    x = E.ref;
  }
  var R = Kh(x, t);
  if (!f || !mi() || v === void 0)
    return null;
  var _ = w === !1 || $te(), P = l;
  return t && (P = /* @__PURE__ */ T.cloneElement(l, {
    ref: R
  })), /* @__PURE__ */ T.createElement(u5.Provider, {
    value: b
  }, _ ? P : /* @__PURE__ */ kT(P, w));
});
process.env.NODE_ENV !== "production" && (cv.displayName = "Portal");
var c5 = /* @__PURE__ */ T.createContext({});
function Wte() {
  var e = re({}, T);
  return e.useId;
}
var y2 = 0, C2 = Wte();
const d5 = C2 ? (
  // Use React `useId`
  function(t) {
    var r = C2();
    return t || (process.env.NODE_ENV === "test" ? "test-id" : r);
  }
) : (
  // Use compatible of `useId`
  function(t) {
    var r = T.useState("ssr-id"), n = ue(r, 2), i = n[0], o = n[1];
    return T.useEffect(function() {
      var a = y2;
      y2 += 1, o("rc_unique_".concat(a));
    }, []), t || (process.env.NODE_ENV === "test" ? "test-id" : i);
  }
);
function S2(e, t, r) {
  var n = t;
  return !n && r && (n = "".concat(e, "-").concat(r)), n;
}
function w2(e, t) {
  var r = e["page".concat(t ? "Y" : "X", "Offset")], n = "scroll".concat(t ? "Top" : "Left");
  if (typeof r != "number") {
    var i = e.document;
    r = i.documentElement[n], typeof r != "number" && (r = i.body[n]);
  }
  return r;
}
function jte(e) {
  var t = e.getBoundingClientRect(), r = {
    left: t.left,
    top: t.top
  }, n = e.ownerDocument, i = n.defaultView || n.parentWindow;
  return r.left += w2(i), r.top += w2(i, !0), r;
}
const Ute = /* @__PURE__ */ T.memo(function(e) {
  var t = e.children;
  return t;
}, function(e, t) {
  var r = t.shouldUpdate;
  return !r;
});
var b2 = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
}, Kte = {
  outline: "none"
}, h5 = /* @__PURE__ */ H.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.className, i = e.style, o = e.title, a = e.ariaId, s = e.footer, l = e.closable, u = e.closeIcon, c = e.onClose, d = e.children, h = e.bodyStyle, f = e.bodyProps, p = e.modalRender, g = e.onMouseDown, v = e.onMouseUp, m = e.holderRef, y = e.visible, C = e.forceRender, S = e.width, b = e.height, w = e.classNames, x = e.styles, E = H.useContext(c5), R = E.panel, _ = Kh(m, R), P = le(), D = le(), I = le();
  H.useImperativeHandle(t, function() {
    return {
      focus: function() {
        var k;
        (k = I.current) === null || k === void 0 || k.focus({
          preventScroll: !0
        });
      },
      changeActive: function(k) {
        var $ = document, W = $.activeElement;
        k && W === D.current ? P.current.focus({
          preventScroll: !0
        }) : !k && W === P.current && D.current.focus({
          preventScroll: !0
        });
      }
    };
  });
  var A = {};
  S !== void 0 && (A.width = S), b !== void 0 && (A.height = b);
  var O = s ? /* @__PURE__ */ H.createElement("div", {
    className: pe("".concat(r, "-footer"), w == null ? void 0 : w.footer),
    style: re({}, x == null ? void 0 : x.footer)
  }, s) : null, L = o ? /* @__PURE__ */ H.createElement("div", {
    className: pe("".concat(r, "-header"), w == null ? void 0 : w.header),
    style: re({}, x == null ? void 0 : x.header)
  }, /* @__PURE__ */ H.createElement("div", {
    className: "".concat(r, "-title"),
    id: a
  }, o)) : null, N = ct(function() {
    return xt(l) === "object" && l !== null ? l : l ? {
      closeIcon: u ?? /* @__PURE__ */ H.createElement("span", {
        className: "".concat(r, "-close-x")
      })
    } : {};
  }, [l, u, r]), F = oS(N, !0), G = xt(l) === "object" && l.disabled, M = l ? /* @__PURE__ */ H.createElement("button", ze({
    type: "button",
    onClick: c,
    "aria-label": "Close"
  }, F, {
    className: "".concat(r, "-close"),
    disabled: G
  }), N.closeIcon) : null, V = /* @__PURE__ */ H.createElement("div", {
    className: pe("".concat(r, "-content"), w == null ? void 0 : w.content),
    style: x == null ? void 0 : x.content
  }, M, L, /* @__PURE__ */ H.createElement("div", ze({
    className: pe("".concat(r, "-body"), w == null ? void 0 : w.body),
    style: re(re({}, h), x == null ? void 0 : x.body)
  }, f), d), O);
  return /* @__PURE__ */ H.createElement("div", {
    key: "dialog-element",
    role: "dialog",
    "aria-labelledby": o ? a : null,
    "aria-modal": "true",
    ref: _,
    style: re(re({}, i), A),
    className: pe(r, n),
    onMouseDown: g,
    onMouseUp: v
  }, /* @__PURE__ */ H.createElement("div", {
    tabIndex: 0,
    ref: P,
    style: b2,
    "aria-hidden": "true"
  }), /* @__PURE__ */ H.createElement("div", {
    ref: I,
    tabIndex: -1,
    style: Kte
  }, /* @__PURE__ */ H.createElement(Ute, {
    shouldUpdate: y || C
  }, p ? p(V) : V)), /* @__PURE__ */ H.createElement("div", {
    tabIndex: 0,
    ref: D,
    style: b2,
    "aria-hidden": "true"
  }));
});
process.env.NODE_ENV !== "production" && (h5.displayName = "Panel");
var f5 = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.title, i = e.style, o = e.className, a = e.visible, s = e.forceRender, l = e.destroyOnClose, u = e.motionName, c = e.ariaId, d = e.onVisibleChanged, h = e.mousePosition, f = le(), p = T.useState(), g = ue(p, 2), v = g[0], m = g[1], y = {};
  v && (y.transformOrigin = v);
  function C() {
    var S = jte(f.current);
    m(h && (h.x || h.y) ? "".concat(h.x - S.left, "px ").concat(h.y - S.top, "px") : "");
  }
  return /* @__PURE__ */ T.createElement(ns, {
    visible: a,
    onVisibleChanged: d,
    onAppearPrepare: C,
    onEnterPrepare: C,
    forceRender: s,
    motionName: u,
    removeOnLeave: l,
    ref: f
  }, function(S, b) {
    var w = S.className, x = S.style;
    return /* @__PURE__ */ T.createElement(h5, ze({}, e, {
      ref: t,
      title: n,
      ariaId: c,
      prefixCls: r,
      holderRef: b,
      style: re(re(re({}, x), i), y),
      className: pe(o, w)
    }));
  });
});
f5.displayName = "Content";
var Yte = function(t) {
  var r = t.prefixCls, n = t.style, i = t.visible, o = t.maskProps, a = t.motionName, s = t.className;
  return /* @__PURE__ */ T.createElement(ns, {
    key: "mask",
    visible: i,
    motionName: a,
    leavedClassName: "".concat(r, "-mask-hidden")
  }, function(l, u) {
    var c = l.className, d = l.style;
    return /* @__PURE__ */ T.createElement("div", ze({
      ref: u,
      style: re(re({}, d), n),
      className: pe("".concat(r, "-mask"), c, s)
    }, o));
  });
}, qte = function(t) {
  var r = t.prefixCls, n = r === void 0 ? "rc-dialog" : r, i = t.zIndex, o = t.visible, a = o === void 0 ? !1 : o, s = t.keyboard, l = s === void 0 ? !0 : s, u = t.focusTriggerAfterClose, c = u === void 0 ? !0 : u, d = t.wrapStyle, h = t.wrapClassName, f = t.wrapProps, p = t.onClose, g = t.afterOpenChange, v = t.afterClose, m = t.transitionName, y = t.animation, C = t.closable, S = C === void 0 ? !0 : C, b = t.mask, w = b === void 0 ? !0 : b, x = t.maskTransitionName, E = t.maskAnimation, R = t.maskClosable, _ = R === void 0 ? !0 : R, P = t.maskStyle, D = t.maskProps, I = t.rootClassName, A = t.classNames, O = t.styles;
  process.env.NODE_ENV !== "production" && (["wrapStyle", "bodyStyle", "maskStyle"].forEach(function(ie) {
    Ns(!(ie in t), "".concat(ie, " is deprecated, please use styles instead."));
  }), "wrapClassName" in t && Ns(!1, "wrapClassName is deprecated, please use classNames instead."));
  var L = le(), N = le(), F = le(), G = T.useState(a), M = ue(G, 2), V = M[0], z = M[1], k = d5();
  function $() {
    mE(N.current, document.activeElement) || (L.current = document.activeElement);
  }
  function W() {
    if (!mE(N.current, document.activeElement)) {
      var ie;
      (ie = F.current) === null || ie === void 0 || ie.focus();
    }
  }
  function j(ie) {
    if (ie)
      W();
    else {
      if (z(!1), w && L.current && c) {
        try {
          L.current.focus({
            preventScroll: !0
          });
        } catch {
        }
        L.current = null;
      }
      V && (v == null || v());
    }
    g == null || g(ie);
  }
  function U(ie) {
    p == null || p(ie);
  }
  var Z = le(!1), ee = le(), J = function() {
    clearTimeout(ee.current), Z.current = !0;
  }, X = function() {
    ee.current = setTimeout(function() {
      Z.current = !1;
    });
  }, Y = null;
  _ && (Y = function(Ce) {
    Z.current ? Z.current = !1 : N.current === Ce.target && U(Ce);
  });
  function de(ie) {
    if (l && ie.keyCode === Ue.ESC) {
      ie.stopPropagation(), U(ie);
      return;
    }
    a && ie.keyCode === Ue.TAB && F.current.changeActive(!ie.shiftKey);
  }
  It(function() {
    a && (z(!0), $());
  }, [a]), It(function() {
    return function() {
      clearTimeout(ee.current);
    };
  }, []);
  var K = re(re(re({
    zIndex: i
  }, d), O == null ? void 0 : O.wrapper), {}, {
    display: V ? null : "none"
  });
  return /* @__PURE__ */ T.createElement("div", ze({
    className: pe("".concat(n, "-root"), I)
  }, oS(t, {
    data: !0
  })), /* @__PURE__ */ T.createElement(Yte, {
    prefixCls: n,
    visible: w && a,
    motionName: S2(n, x, E),
    style: re(re({
      zIndex: i
    }, P), O == null ? void 0 : O.mask),
    maskProps: D,
    className: A == null ? void 0 : A.mask
  }), /* @__PURE__ */ T.createElement("div", ze({
    tabIndex: -1,
    onKeyDown: de,
    className: pe("".concat(n, "-wrap"), h, A == null ? void 0 : A.wrapper),
    ref: N,
    onClick: Y,
    style: K
  }, f), /* @__PURE__ */ T.createElement(f5, ze({}, t, {
    onMouseDown: J,
    onMouseUp: X,
    ref: F,
    closable: S,
    ariaId: k,
    prefixCls: n,
    visible: a && V,
    onClose: U,
    onVisibleChanged: j,
    motionName: S2(n, m, y)
  }))));
}, p5 = function(t) {
  var r = t.visible, n = t.getContainer, i = t.forceRender, o = t.destroyOnClose, a = o === void 0 ? !1 : o, s = t.afterClose, l = t.panelRef, u = T.useState(r), c = ue(u, 2), d = c[0], h = c[1], f = T.useMemo(function() {
    return {
      panel: l
    };
  }, [l]);
  return T.useEffect(function() {
    r && h(!0);
  }, [r]), !i && a && !d ? null : /* @__PURE__ */ T.createElement(c5.Provider, {
    value: f
  }, /* @__PURE__ */ T.createElement(cv, {
    open: r || i || d,
    autoDestroy: !1,
    getContainer: n,
    autoLock: r || d
  }, /* @__PURE__ */ T.createElement(qte, ze({}, t, {
    destroyOnClose: a,
    afterClose: function() {
      s == null || s(), h(!1);
    }
  }))));
};
p5.displayName = "Dialog";
var Ju = "RC_FORM_INTERNAL_HOOKS", Tr = function() {
  gr(!1, "Can not find FormContext. Please make sure you wrap Field under Form.");
}, Mh = /* @__PURE__ */ T.createContext({
  getFieldValue: Tr,
  getFieldsValue: Tr,
  getFieldError: Tr,
  getFieldWarning: Tr,
  getFieldsError: Tr,
  isFieldsTouched: Tr,
  isFieldTouched: Tr,
  isFieldValidating: Tr,
  isFieldsValidating: Tr,
  resetFields: Tr,
  setFields: Tr,
  setFieldValue: Tr,
  setFieldsValue: Tr,
  validateFields: Tr,
  submit: Tr,
  getInternalHooks: function() {
    return Tr(), {
      dispatch: Tr,
      initEntityValue: Tr,
      registerField: Tr,
      useSubscribe: Tr,
      setInitialValues: Tr,
      destroyForm: Tr,
      setCallbacks: Tr,
      registerWatch: Tr,
      getFields: Tr,
      setValidateMessages: Tr,
      setPreserve: Tr,
      getInitialValue: Tr
    };
  }
}), P0 = /* @__PURE__ */ T.createContext(null);
function WE(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function Zte(e) {
  return e && !!e._init;
}
function jE() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var UE = jE();
function Xte(e) {
  try {
    return Function.toString.call(e).indexOf("[native code]") !== -1;
  } catch {
    return typeof e == "function";
  }
}
function Qte(e, t, r) {
  if (HT()) return Reflect.construct.apply(null, arguments);
  var n = [null];
  n.push.apply(n, t);
  var i = new (e.bind.apply(e, n))();
  return r && gg(i, r.prototype), i;
}
function KE(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return KE = function(n) {
    if (n === null || !Xte(n)) return n;
    if (typeof n != "function") throw new TypeError("Super expression must either be null or a function");
    if (t !== void 0) {
      if (t.has(n)) return t.get(n);
      t.set(n, i);
    }
    function i() {
      return Qte(n, arguments, vg(this).constructor);
    }
    return i.prototype = Object.create(n.prototype, {
      constructor: {
        value: i,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), gg(i, n);
  }, KE(e);
}
var Jte = /%[sdj%]/g, g5 = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (g5 = function(t, r) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && r.every(function(n) {
    return typeof n == "string";
  }) && console.warn(t, r);
});
function YE(e) {
  if (!e || !e.length) return null;
  var t = {};
  return e.forEach(function(r) {
    var n = r.field;
    t[n] = t[n] || [], t[n].push(r);
  }), t;
}
function Xi(e) {
  for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
    r[n - 1] = arguments[n];
  var i = 0, o = r.length;
  if (typeof e == "function")
    return e.apply(null, r);
  if (typeof e == "string") {
    var a = e.replace(Jte, function(s) {
      if (s === "%%")
        return "%";
      if (i >= o)
        return s;
      switch (s) {
        case "%s":
          return String(r[i++]);
        case "%d":
          return Number(r[i++]);
        case "%j":
          try {
            return JSON.stringify(r[i++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return s;
      }
    });
    return a;
  }
  return e;
}
function ere(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function En(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || ere(t) && typeof e == "string" && !e);
}
function tre(e, t, r) {
  var n = [], i = 0, o = e.length;
  function a(s) {
    n.push.apply(n, rt(s || [])), i++, i === o && r(n);
  }
  e.forEach(function(s) {
    t(s, a);
  });
}
function x2(e, t, r) {
  var n = 0, i = e.length;
  function o(a) {
    if (a && a.length) {
      r(a);
      return;
    }
    var s = n;
    n = n + 1, s < i ? t(e[s], o) : r([]);
  }
  o([]);
}
function rre(e) {
  var t = [];
  return Object.keys(e).forEach(function(r) {
    t.push.apply(t, rt(e[r] || []));
  }), t;
}
var E2 = /* @__PURE__ */ function(e) {
  Ql(r, e);
  var t = Jl(r);
  function r(n, i) {
    var o;
    return Hn(this, r), o = t.call(this, "Async Validation Error"), te(qt(o), "errors", void 0), te(qt(o), "fields", void 0), o.errors = n, o.fields = i, o;
  }
  return zn(r);
}(/* @__PURE__ */ KE(Error));
function nre(e, t, r, n, i) {
  if (t.first) {
    var o = new Promise(function(h, f) {
      var p = function(m) {
        return n(m), m.length ? f(new E2(m, YE(m))) : h(i);
      }, g = rre(e);
      x2(g, r, p);
    });
    return o.catch(function(h) {
      return h;
    }), o;
  }
  var a = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], s = Object.keys(e), l = s.length, u = 0, c = [], d = new Promise(function(h, f) {
    var p = function(v) {
      if (c.push.apply(c, v), u++, u === l)
        return n(c), c.length ? f(new E2(c, YE(c))) : h(i);
    };
    s.length || (n(c), h(i)), s.forEach(function(g) {
      var v = e[g];
      a.indexOf(g) !== -1 ? x2(v, r, p) : tre(v, r, p);
    });
  });
  return d.catch(function(h) {
    return h;
  }), d;
}
function ire(e) {
  return !!(e && e.message !== void 0);
}
function ore(e, t) {
  for (var r = e, n = 0; n < t.length; n++) {
    if (r == null)
      return r;
    r = r[t[n]];
  }
  return r;
}
function R2(e, t) {
  return function(r) {
    var n;
    return e.fullFields ? n = ore(t, e.fullFields) : n = t[r.field || e.fullField], ire(r) ? (r.field = r.field || e.fullField, r.fieldValue = n, r) : {
      message: typeof r == "function" ? r() : r,
      fieldValue: n,
      field: r.field || e.fullField
    };
  };
}
function _2(e, t) {
  if (t) {
    for (var r in t)
      if (t.hasOwnProperty(r)) {
        var n = t[r];
        xt(n) === "object" && xt(e[r]) === "object" ? e[r] = re(re({}, e[r]), n) : e[r] = n;
      }
  }
  return e;
}
var sd = "enum", are = function(t, r, n, i, o) {
  t[sd] = Array.isArray(t[sd]) ? t[sd] : [], t[sd].indexOf(r) === -1 && i.push(Xi(o.messages[sd], t.fullField, t[sd].join(", ")));
}, sre = function(t, r, n, i, o) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(r) || i.push(Xi(o.messages.pattern.mismatch, t.fullField, r, t.pattern));
    else if (typeof t.pattern == "string") {
      var a = new RegExp(t.pattern);
      a.test(r) || i.push(Xi(o.messages.pattern.mismatch, t.fullField, r, t.pattern));
    }
  }
}, lre = function(t, r, n, i, o) {
  var a = typeof t.len == "number", s = typeof t.min == "number", l = typeof t.max == "number", u = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, c = r, d = null, h = typeof r == "number", f = typeof r == "string", p = Array.isArray(r);
  if (h ? d = "number" : f ? d = "string" : p && (d = "array"), !d)
    return !1;
  p && (c = r.length), f && (c = r.replace(u, "_").length), a ? c !== t.len && i.push(Xi(o.messages[d].len, t.fullField, t.len)) : s && !l && c < t.min ? i.push(Xi(o.messages[d].min, t.fullField, t.min)) : l && !s && c > t.max ? i.push(Xi(o.messages[d].max, t.fullField, t.max)) : s && l && (c < t.min || c > t.max) && i.push(Xi(o.messages[d].range, t.fullField, t.min, t.max));
}, v5 = function(t, r, n, i, o, a) {
  t.required && (!n.hasOwnProperty(t.field) || En(r, a || t.type)) && i.push(Xi(o.messages.required, t.fullField));
}, dm;
const ure = function() {
  if (dm)
    return dm;
  var e = "[a-fA-F\\d:]", t = function(w) {
    return w && w.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(e, ")|(?<=").concat(e, ")(?=\\s|$))") : "";
  }, r = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", n = "[a-fA-F\\d]{1,4}", i = [
    "(?:".concat(n, ":){7}(?:").concat(n, "|:)"),
    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
    "(?:".concat(n, ":){6}(?:").concat(r, "|:").concat(n, "|:)"),
    // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
    "(?:".concat(n, ":){5}(?::").concat(r, "|(?::").concat(n, "){1,2}|:)"),
    // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
    "(?:".concat(n, ":){4}(?:(?::").concat(n, "){0,1}:").concat(r, "|(?::").concat(n, "){1,3}|:)"),
    // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
    "(?:".concat(n, ":){3}(?:(?::").concat(n, "){0,2}:").concat(r, "|(?::").concat(n, "){1,4}|:)"),
    // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
    "(?:".concat(n, ":){2}(?:(?::").concat(n, "){0,3}:").concat(r, "|(?::").concat(n, "){1,5}|:)"),
    // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
    "(?:".concat(n, ":){1}(?:(?::").concat(n, "){0,4}:").concat(r, "|(?::").concat(n, "){1,6}|:)"),
    // 1::              1::3:4:5:6:7:8   1::8            1::
    "(?::(?:(?::".concat(n, "){0,5}:").concat(r, "|(?::").concat(n, "){1,7}|:))")
    // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
  ], o = "(?:%[0-9a-zA-Z]{1,})?", a = "(?:".concat(i.join("|"), ")").concat(o), s = new RegExp("(?:^".concat(r, "$)|(?:^").concat(a, "$)")), l = new RegExp("^".concat(r, "$")), u = new RegExp("^".concat(a, "$")), c = function(w) {
    return w && w.exact ? s : new RegExp("(?:".concat(t(w)).concat(r).concat(t(w), ")|(?:").concat(t(w)).concat(a).concat(t(w), ")"), "g");
  };
  c.v4 = function(b) {
    return b && b.exact ? l : new RegExp("".concat(t(b)).concat(r).concat(t(b)), "g");
  }, c.v6 = function(b) {
    return b && b.exact ? u : new RegExp("".concat(t(b)).concat(a).concat(t(b)), "g");
  };
  var d = "(?:(?:[a-z]+:)?//)", h = "(?:\\S+(?::\\S*)?@)?", f = c.v4().source, p = c.v6().source, g = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", v = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", m = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", y = "(?::\\d{2,5})?", C = '(?:[/?#][^\\s"]*)?', S = "(?:".concat(d, "|www\\.)").concat(h, "(?:localhost|").concat(f, "|").concat(p, "|").concat(g).concat(v).concat(m, ")").concat(y).concat(C);
  return dm = new RegExp("(?:^".concat(S, "$)"), "i"), dm;
};
var T2 = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, wp = {
  integer: function(t) {
    return wp.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return wp.number(t) && !wp.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(t);
    } catch {
      return !1;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? !1 : typeof t == "number";
  },
  object: function(t) {
    return xt(t) === "object" && !wp.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(T2.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(ure());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(T2.hex);
  }
}, cre = function(t, r, n, i, o) {
  if (t.required && r === void 0) {
    v5(t, r, n, i, o);
    return;
  }
  var a = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], s = t.type;
  a.indexOf(s) > -1 ? wp[s](r) || i.push(Xi(o.messages.types[s], t.fullField, t.type)) : s && xt(r) !== t.type && i.push(Xi(o.messages.types[s], t.fullField, t.type));
}, dre = function(t, r, n, i, o) {
  (/^\s+$/.test(r) || r === "") && i.push(Xi(o.messages.whitespace, t.fullField));
};
const tr = {
  required: v5,
  whitespace: dre,
  type: cre,
  range: lre,
  enum: are,
  pattern: sre
};
var hre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r) && !t.required)
      return n();
    tr.required(t, r, i, a, o);
  }
  n(a);
}, fre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (r == null && !t.required)
      return n();
    tr.required(t, r, i, a, o, "array"), r != null && (tr.type(t, r, i, a, o), tr.range(t, r, i, a, o));
  }
  n(a);
}, pre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r) && !t.required)
      return n();
    tr.required(t, r, i, a, o), r !== void 0 && tr.type(t, r, i, a, o);
  }
  n(a);
}, gre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r, "date") && !t.required)
      return n();
    if (tr.required(t, r, i, a, o), !En(r, "date")) {
      var l;
      r instanceof Date ? l = r : l = new Date(r), tr.type(t, l, i, a, o), l && tr.range(t, l.getTime(), i, a, o);
    }
  }
  n(a);
}, vre = "enum", mre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r) && !t.required)
      return n();
    tr.required(t, r, i, a, o), r !== void 0 && tr[vre](t, r, i, a, o);
  }
  n(a);
}, yre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r) && !t.required)
      return n();
    tr.required(t, r, i, a, o), r !== void 0 && (tr.type(t, r, i, a, o), tr.range(t, r, i, a, o));
  }
  n(a);
}, Cre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r) && !t.required)
      return n();
    tr.required(t, r, i, a, o), r !== void 0 && (tr.type(t, r, i, a, o), tr.range(t, r, i, a, o));
  }
  n(a);
}, Sre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r) && !t.required)
      return n();
    tr.required(t, r, i, a, o), r !== void 0 && tr.type(t, r, i, a, o);
  }
  n(a);
}, wre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (r === "" && (r = void 0), En(r) && !t.required)
      return n();
    tr.required(t, r, i, a, o), r !== void 0 && (tr.type(t, r, i, a, o), tr.range(t, r, i, a, o));
  }
  n(a);
}, bre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r) && !t.required)
      return n();
    tr.required(t, r, i, a, o), r !== void 0 && tr.type(t, r, i, a, o);
  }
  n(a);
}, xre = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r, "string") && !t.required)
      return n();
    tr.required(t, r, i, a, o), En(r, "string") || tr.pattern(t, r, i, a, o);
  }
  n(a);
}, Ere = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r) && !t.required)
      return n();
    tr.required(t, r, i, a, o), En(r) || tr.type(t, r, i, a, o);
  }
  n(a);
}, Rre = function(t, r, n, i, o) {
  var a = [], s = Array.isArray(r) ? "array" : xt(r);
  tr.required(t, r, i, a, o, s), n(a);
}, _re = function(t, r, n, i, o) {
  var a = [], s = t.required || !t.required && i.hasOwnProperty(t.field);
  if (s) {
    if (En(r, "string") && !t.required)
      return n();
    tr.required(t, r, i, a, o, "string"), En(r, "string") || (tr.type(t, r, i, a, o), tr.range(t, r, i, a, o), tr.pattern(t, r, i, a, o), t.whitespace === !0 && tr.whitespace(t, r, i, a, o));
  }
  n(a);
}, Hw = function(t, r, n, i, o) {
  var a = t.type, s = [], l = t.required || !t.required && i.hasOwnProperty(t.field);
  if (l) {
    if (En(r, a) && !t.required)
      return n();
    tr.required(t, r, i, s, o, a), En(r, a) || tr.type(t, r, i, s, o);
  }
  n(s);
};
const zp = {
  string: _re,
  method: Sre,
  number: wre,
  boolean: pre,
  regexp: Ere,
  integer: Cre,
  float: yre,
  array: fre,
  object: bre,
  enum: mre,
  pattern: xre,
  date: gre,
  url: Hw,
  hex: Hw,
  email: Hw,
  required: Rre,
  any: hre
};
var dv = /* @__PURE__ */ function() {
  function e(t) {
    Hn(this, e), te(this, "rules", null), te(this, "_messages", UE), this.define(t);
  }
  return zn(e, [{
    key: "define",
    value: function(r) {
      var n = this;
      if (!r)
        throw new Error("Cannot configure a schema with no rules");
      if (xt(r) !== "object" || Array.isArray(r))
        throw new Error("Rules must be an object");
      this.rules = {}, Object.keys(r).forEach(function(i) {
        var o = r[i];
        n.rules[i] = Array.isArray(o) ? o : [o];
      });
    }
  }, {
    key: "messages",
    value: function(r) {
      return r && (this._messages = _2(jE(), r)), this._messages;
    }
  }, {
    key: "validate",
    value: function(r) {
      var n = this, i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : function() {
      }, a = r, s = i, l = o;
      if (typeof s == "function" && (l = s, s = {}), !this.rules || Object.keys(this.rules).length === 0)
        return l && l(null, a), Promise.resolve(a);
      function u(p) {
        var g = [], v = {};
        function m(C) {
          if (Array.isArray(C)) {
            var S;
            g = (S = g).concat.apply(S, rt(C));
          } else
            g.push(C);
        }
        for (var y = 0; y < p.length; y++)
          m(p[y]);
        g.length ? (v = YE(g), l(g, v)) : l(null, a);
      }
      if (s.messages) {
        var c = this.messages();
        c === UE && (c = jE()), _2(c, s.messages), s.messages = c;
      } else
        s.messages = this.messages();
      var d = {}, h = s.keys || Object.keys(this.rules);
      h.forEach(function(p) {
        var g = n.rules[p], v = a[p];
        g.forEach(function(m) {
          var y = m;
          typeof y.transform == "function" && (a === r && (a = re({}, a)), v = a[p] = y.transform(v), v != null && (y.type = y.type || (Array.isArray(v) ? "array" : xt(v)))), typeof y == "function" ? y = {
            validator: y
          } : y = re({}, y), y.validator = n.getValidationMethod(y), y.validator && (y.field = p, y.fullField = y.fullField || p, y.type = n.getType(y), d[p] = d[p] || [], d[p].push({
            rule: y,
            value: v,
            source: a,
            field: p
          }));
        });
      });
      var f = {};
      return nre(d, s, function(p, g) {
        var v = p.rule, m = (v.type === "object" || v.type === "array") && (xt(v.fields) === "object" || xt(v.defaultField) === "object");
        m = m && (v.required || !v.required && p.value), v.field = p.field;
        function y(x, E) {
          return re(re({}, E), {}, {
            fullField: "".concat(v.fullField, ".").concat(x),
            fullFields: v.fullFields ? [].concat(rt(v.fullFields), [x]) : [x]
          });
        }
        function C() {
          var x = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], E = Array.isArray(x) ? x : [x];
          !s.suppressWarning && E.length && e.warning("async-validator:", E), E.length && v.message !== void 0 && (E = [].concat(v.message));
          var R = E.map(R2(v, a));
          if (s.first && R.length)
            return f[v.field] = 1, g(R);
          if (!m)
            g(R);
          else {
            if (v.required && !p.value)
              return v.message !== void 0 ? R = [].concat(v.message).map(R2(v, a)) : s.error && (R = [s.error(v, Xi(s.messages.required, v.field))]), g(R);
            var _ = {};
            v.defaultField && Object.keys(p.value).map(function(I) {
              _[I] = v.defaultField;
            }), _ = re(re({}, _), p.rule.fields);
            var P = {};
            Object.keys(_).forEach(function(I) {
              var A = _[I], O = Array.isArray(A) ? A : [A];
              P[I] = O.map(y.bind(null, I));
            });
            var D = new e(P);
            D.messages(s.messages), p.rule.options && (p.rule.options.messages = s.messages, p.rule.options.error = s.error), D.validate(p.value, p.rule.options || s, function(I) {
              var A = [];
              R && R.length && A.push.apply(A, rt(R)), I && I.length && A.push.apply(A, rt(I)), g(A.length ? A : null);
            });
          }
        }
        var S;
        if (v.asyncValidator)
          S = v.asyncValidator(v, p.value, C, p.source, s);
        else if (v.validator) {
          try {
            S = v.validator(v, p.value, C, p.source, s);
          } catch (x) {
            var b, w;
            (b = (w = console).error) === null || b === void 0 || b.call(w, x), s.suppressValidatorError || setTimeout(function() {
              throw x;
            }, 0), C(x.message);
          }
          S === !0 ? C() : S === !1 ? C(typeof v.message == "function" ? v.message(v.fullField || v.field) : v.message || "".concat(v.fullField || v.field, " fails")) : S instanceof Array ? C(S) : S instanceof Error && C(S.message);
        }
        S && S.then && S.then(function() {
          return C();
        }, function(x) {
          return C(x);
        });
      }, function(p) {
        u(p);
      }, a);
    }
  }, {
    key: "getType",
    value: function(r) {
      if (r.type === void 0 && r.pattern instanceof RegExp && (r.type = "pattern"), typeof r.validator != "function" && r.type && !zp.hasOwnProperty(r.type))
        throw new Error(Xi("Unknown rule type %s", r.type));
      return r.type || "string";
    }
  }, {
    key: "getValidationMethod",
    value: function(r) {
      if (typeof r.validator == "function")
        return r.validator;
      var n = Object.keys(r), i = n.indexOf("message");
      return i !== -1 && n.splice(i, 1), n.length === 1 && n[0] === "required" ? zp.required : zp[this.getType(r)] || void 0;
    }
  }]), e;
}();
te(dv, "register", function(t, r) {
  if (typeof r != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  zp[t] = r;
});
te(dv, "warning", g5);
te(dv, "messages", UE);
te(dv, "validators", zp);
var zi = "'${name}' is not a valid ${type}", m5 = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: zi,
    method: zi,
    array: zi,
    object: zi,
    number: zi,
    date: zi,
    boolean: zi,
    integer: zi,
    float: zi,
    regexp: zi,
    email: zi,
    url: zi,
    hex: zi
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
}, P2 = dv;
function Tre(e, t) {
  return e.replace(/\$\{\w+\}/g, function(r) {
    var n = r.slice(2, -1);
    return t[n];
  });
}
var M2 = "CODE_LOGIC_ERROR";
function qE(e, t, r, n, i) {
  return ZE.apply(this, arguments);
}
function ZE() {
  return ZE = Bc(/* @__PURE__ */ Si().mark(function e(t, r, n, i, o) {
    var a, s, l, u, c, d, h, f, p;
    return Si().wrap(function(v) {
      for (; ; ) switch (v.prev = v.next) {
        case 0:
          return a = re({}, n), delete a.ruleIndex, P2.warning = function() {
          }, a.validator && (s = a.validator, a.validator = function() {
            try {
              return s.apply(void 0, arguments);
            } catch (m) {
              return console.error(m), Promise.reject(M2);
            }
          }), l = null, a && a.type === "array" && a.defaultField && (l = a.defaultField, delete a.defaultField), u = new P2(te({}, t, [a])), c = Zd(m5, i.validateMessages), u.messages(c), d = [], v.prev = 10, v.next = 13, Promise.resolve(u.validate(te({}, t, r), re({}, i)));
        case 13:
          v.next = 18;
          break;
        case 15:
          v.prev = 15, v.t0 = v.catch(10), v.t0.errors && (d = v.t0.errors.map(function(m, y) {
            var C = m.message, S = C === M2 ? c.default : C;
            return /* @__PURE__ */ T.isValidElement(S) ? (
              // Wrap ReactNode with `key`
              /* @__PURE__ */ T.cloneElement(S, {
                key: "error_".concat(y)
              })
            ) : S;
          }));
        case 18:
          if (!(!d.length && l)) {
            v.next = 23;
            break;
          }
          return v.next = 21, Promise.all(r.map(function(m, y) {
            return qE("".concat(t, ".").concat(y), m, l, i, o);
          }));
        case 21:
          return h = v.sent, v.abrupt("return", h.reduce(function(m, y) {
            return [].concat(rt(m), rt(y));
          }, []));
        case 23:
          return f = re(re({}, n), {}, {
            name: t,
            enum: (n.enum || []).join(", ")
          }, o), p = d.map(function(m) {
            return typeof m == "string" ? Tre(m, f) : m;
          }), v.abrupt("return", p);
        case 26:
        case "end":
          return v.stop();
      }
    }, e, null, [[10, 15]]);
  })), ZE.apply(this, arguments);
}
function Pre(e, t, r, n, i, o) {
  var a = e.join("."), s = r.map(function(c, d) {
    var h = c.validator, f = re(re({}, c), {}, {
      ruleIndex: d
    });
    return h && (f.validator = function(p, g, v) {
      var m = !1, y = function() {
        for (var b = arguments.length, w = new Array(b), x = 0; x < b; x++)
          w[x] = arguments[x];
        Promise.resolve().then(function() {
          gr(!m, "Your validator function has already return a promise. `callback` will be ignored."), m || v.apply(void 0, w);
        });
      }, C = h(p, g, y);
      m = C && typeof C.then == "function" && typeof C.catch == "function", gr(m, "`callback` is deprecated. Please return a promise instead."), m && C.then(function() {
        v();
      }).catch(function(S) {
        v(S || " ");
      });
    }), f;
  }).sort(function(c, d) {
    var h = c.warningOnly, f = c.ruleIndex, p = d.warningOnly, g = d.ruleIndex;
    return !!h == !!p ? f - g : h ? 1 : -1;
  }), l;
  if (i === !0)
    l = new Promise(/* @__PURE__ */ function() {
      var c = Bc(/* @__PURE__ */ Si().mark(function d(h, f) {
        var p, g, v;
        return Si().wrap(function(y) {
          for (; ; ) switch (y.prev = y.next) {
            case 0:
              p = 0;
            case 1:
              if (!(p < s.length)) {
                y.next = 12;
                break;
              }
              return g = s[p], y.next = 5, qE(a, t, g, n, o);
            case 5:
              if (v = y.sent, !v.length) {
                y.next = 9;
                break;
              }
              return f([{
                errors: v,
                rule: g
              }]), y.abrupt("return");
            case 9:
              p += 1, y.next = 1;
              break;
            case 12:
              h([]);
            case 13:
            case "end":
              return y.stop();
          }
        }, d);
      }));
      return function(d, h) {
        return c.apply(this, arguments);
      };
    }());
  else {
    var u = s.map(function(c) {
      return qE(a, t, c, n, o).then(function(d) {
        return {
          errors: d,
          rule: c
        };
      });
    });
    l = (i ? Dre(u) : Mre(u)).then(function(c) {
      return Promise.reject(c);
    });
  }
  return l.catch(function(c) {
    return c;
  }), l;
}
function Mre(e) {
  return XE.apply(this, arguments);
}
function XE() {
  return XE = Bc(/* @__PURE__ */ Si().mark(function e(t) {
    return Si().wrap(function(n) {
      for (; ; ) switch (n.prev = n.next) {
        case 0:
          return n.abrupt("return", Promise.all(t).then(function(i) {
            var o, a = (o = []).concat.apply(o, rt(i));
            return a;
          }));
        case 1:
        case "end":
          return n.stop();
      }
    }, e);
  })), XE.apply(this, arguments);
}
function Dre(e) {
  return QE.apply(this, arguments);
}
function QE() {
  return QE = Bc(/* @__PURE__ */ Si().mark(function e(t) {
    var r;
    return Si().wrap(function(i) {
      for (; ; ) switch (i.prev = i.next) {
        case 0:
          return r = 0, i.abrupt("return", new Promise(function(o) {
            t.forEach(function(a) {
              a.then(function(s) {
                s.errors.length && o([s]), r += 1, r === t.length && o([]);
              });
            });
          }));
        case 2:
        case "end":
          return i.stop();
      }
    }, e);
  })), QE.apply(this, arguments);
}
function on(e) {
  return WE(e);
}
function D2(e, t) {
  var r = {};
  return t.forEach(function(n) {
    var i = Ha(e, n);
    r = ta(r, n, i);
  }), r;
}
function lh(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return e && e.some(function(n) {
    return y5(t, n, r);
  });
}
function y5(e, t) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  return !e || !t || !r && e.length !== t.length ? !1 : t.every(function(n, i) {
    return e[i] === n;
  });
}
function Are(e, t) {
  if (e === t)
    return !0;
  if (!e && t || e && !t || !e || !t || xt(e) !== "object" || xt(t) !== "object")
    return !1;
  var r = Object.keys(e), n = Object.keys(t), i = new Set([].concat(r, n));
  return rt(i).every(function(o) {
    var a = e[o], s = t[o];
    return typeof a == "function" && typeof s == "function" ? !0 : a === s;
  });
}
function Ire(e) {
  var t = arguments.length <= 1 ? void 0 : arguments[1];
  return t && t.target && xt(t.target) === "object" && e in t.target ? t.target[e] : t;
}
function A2(e, t, r) {
  var n = e.length;
  if (t < 0 || t >= n || r < 0 || r >= n)
    return e;
  var i = e[t], o = t - r;
  return o > 0 ? [].concat(rt(e.slice(0, r)), [i], rt(e.slice(r, t)), rt(e.slice(t + 1, n))) : o < 0 ? [].concat(rt(e.slice(0, t)), rt(e.slice(t + 1, r + 1)), [i], rt(e.slice(r + 1, n))) : e;
}
var Fre = ["name"], so = [];
function I2(e, t, r, n, i, o) {
  return typeof e == "function" ? e(t, r, "source" in o ? {
    source: o.source
  } : {}) : n !== i;
}
var lP = /* @__PURE__ */ function(e) {
  Ql(r, e);
  var t = Jl(r);
  function r(n) {
    var i;
    if (Hn(this, r), i = t.call(this, n), te(qt(i), "state", {
      resetCount: 0
    }), te(qt(i), "cancelRegisterFunc", null), te(qt(i), "mounted", !1), te(qt(i), "touched", !1), te(qt(i), "dirty", !1), te(qt(i), "validatePromise", void 0), te(qt(i), "prevValidating", void 0), te(qt(i), "errors", so), te(qt(i), "warnings", so), te(qt(i), "cancelRegister", function() {
      var l = i.props, u = l.preserve, c = l.isListField, d = l.name;
      i.cancelRegisterFunc && i.cancelRegisterFunc(c, u, on(d)), i.cancelRegisterFunc = null;
    }), te(qt(i), "getNamePath", function() {
      var l = i.props, u = l.name, c = l.fieldContext, d = c.prefixName, h = d === void 0 ? [] : d;
      return u !== void 0 ? [].concat(rt(h), rt(u)) : [];
    }), te(qt(i), "getRules", function() {
      var l = i.props, u = l.rules, c = u === void 0 ? [] : u, d = l.fieldContext;
      return c.map(function(h) {
        return typeof h == "function" ? h(d) : h;
      });
    }), te(qt(i), "refresh", function() {
      i.mounted && i.setState(function(l) {
        var u = l.resetCount;
        return {
          resetCount: u + 1
        };
      });
    }), te(qt(i), "metaCache", null), te(qt(i), "triggerMetaEvent", function(l) {
      var u = i.props.onMetaChange;
      if (u) {
        var c = re(re({}, i.getMeta()), {}, {
          destroy: l
        });
        xh(i.metaCache, c) || u(c), i.metaCache = c;
      } else
        i.metaCache = null;
    }), te(qt(i), "onStoreChange", function(l, u, c) {
      var d = i.props, h = d.shouldUpdate, f = d.dependencies, p = f === void 0 ? [] : f, g = d.onReset, v = c.store, m = i.getNamePath(), y = i.getValue(l), C = i.getValue(v), S = u && lh(u, m);
      switch (c.type === "valueUpdate" && c.source === "external" && !xh(y, C) && (i.touched = !0, i.dirty = !0, i.validatePromise = null, i.errors = so, i.warnings = so, i.triggerMetaEvent()), c.type) {
        case "reset":
          if (!u || S) {
            i.touched = !1, i.dirty = !1, i.validatePromise = void 0, i.errors = so, i.warnings = so, i.triggerMetaEvent(), g == null || g(), i.refresh();
            return;
          }
          break;
        case "remove": {
          if (h) {
            i.reRender();
            return;
          }
          break;
        }
        case "setField": {
          var b = c.data;
          if (S) {
            "touched" in b && (i.touched = b.touched), "validating" in b && !("originRCField" in b) && (i.validatePromise = b.validating ? Promise.resolve([]) : null), "errors" in b && (i.errors = b.errors || so), "warnings" in b && (i.warnings = b.warnings || so), i.dirty = !0, i.triggerMetaEvent(), i.reRender();
            return;
          } else if ("value" in b && lh(u, m, !0)) {
            i.reRender();
            return;
          }
          if (h && !m.length && I2(h, l, v, y, C, c)) {
            i.reRender();
            return;
          }
          break;
        }
        case "dependenciesUpdate": {
          var w = p.map(on);
          if (w.some(function(x) {
            return lh(c.relatedFields, x);
          })) {
            i.reRender();
            return;
          }
          break;
        }
        default:
          if (S || (!p.length || m.length || h) && I2(h, l, v, y, C, c)) {
            i.reRender();
            return;
          }
          break;
      }
      h === !0 && i.reRender();
    }), te(qt(i), "validateRules", function(l) {
      var u = i.getNamePath(), c = i.getValue(), d = l || {}, h = d.triggerName, f = d.validateOnly, p = f === void 0 ? !1 : f, g = Promise.resolve().then(/* @__PURE__ */ Bc(/* @__PURE__ */ Si().mark(function v() {
        var m, y, C, S, b, w, x;
        return Si().wrap(function(R) {
          for (; ; ) switch (R.prev = R.next) {
            case 0:
              if (i.mounted) {
                R.next = 2;
                break;
              }
              return R.abrupt("return", []);
            case 2:
              if (m = i.props, y = m.validateFirst, C = y === void 0 ? !1 : y, S = m.messageVariables, b = m.validateDebounce, w = i.getRules(), h && (w = w.filter(function(_) {
                return _;
              }).filter(function(_) {
                var P = _.validateTrigger;
                if (!P)
                  return !0;
                var D = WE(P);
                return D.includes(h);
              })), !(b && h)) {
                R.next = 10;
                break;
              }
              return R.next = 8, new Promise(function(_) {
                setTimeout(_, b);
              });
            case 8:
              if (i.validatePromise === g) {
                R.next = 10;
                break;
              }
              return R.abrupt("return", []);
            case 10:
              return x = Pre(u, c, w, l, C, S), x.catch(function(_) {
                return _;
              }).then(function() {
                var _ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : so;
                if (i.validatePromise === g) {
                  var P;
                  i.validatePromise = null;
                  var D = [], I = [];
                  (P = _.forEach) === null || P === void 0 || P.call(_, function(A) {
                    var O = A.rule.warningOnly, L = A.errors, N = L === void 0 ? so : L;
                    O ? I.push.apply(I, rt(N)) : D.push.apply(D, rt(N));
                  }), i.errors = D, i.warnings = I, i.triggerMetaEvent(), i.reRender();
                }
              }), R.abrupt("return", x);
            case 13:
            case "end":
              return R.stop();
          }
        }, v);
      })));
      return p || (i.validatePromise = g, i.dirty = !0, i.errors = so, i.warnings = so, i.triggerMetaEvent(), i.reRender()), g;
    }), te(qt(i), "isFieldValidating", function() {
      return !!i.validatePromise;
    }), te(qt(i), "isFieldTouched", function() {
      return i.touched;
    }), te(qt(i), "isFieldDirty", function() {
      if (i.dirty || i.props.initialValue !== void 0)
        return !0;
      var l = i.props.fieldContext, u = l.getInternalHooks(Ju), c = u.getInitialValue;
      return c(i.getNamePath()) !== void 0;
    }), te(qt(i), "getErrors", function() {
      return i.errors;
    }), te(qt(i), "getWarnings", function() {
      return i.warnings;
    }), te(qt(i), "isListField", function() {
      return i.props.isListField;
    }), te(qt(i), "isList", function() {
      return i.props.isList;
    }), te(qt(i), "isPreserve", function() {
      return i.props.preserve;
    }), te(qt(i), "getMeta", function() {
      i.prevValidating = i.isFieldValidating();
      var l = {
        touched: i.isFieldTouched(),
        validating: i.prevValidating,
        errors: i.errors,
        warnings: i.warnings,
        name: i.getNamePath(),
        validated: i.validatePromise === null
      };
      return l;
    }), te(qt(i), "getOnlyChild", function(l) {
      if (typeof l == "function") {
        var u = i.getMeta();
        return re(re({}, i.getOnlyChild(l(i.getControlled(), u, i.props.fieldContext))), {}, {
          isFunction: !0
        });
      }
      var c = Gl(l);
      return c.length !== 1 || !/* @__PURE__ */ T.isValidElement(c[0]) ? {
        child: c,
        isFunction: !1
      } : {
        child: c[0],
        isFunction: !1
      };
    }), te(qt(i), "getValue", function(l) {
      var u = i.props.fieldContext.getFieldsValue, c = i.getNamePath();
      return Ha(l || u(!0), c);
    }), te(qt(i), "getControlled", function() {
      var l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, u = i.props, c = u.name, d = u.trigger, h = u.validateTrigger, f = u.getValueFromEvent, p = u.normalize, g = u.valuePropName, v = u.getValueProps, m = u.fieldContext, y = h !== void 0 ? h : m.validateTrigger, C = i.getNamePath(), S = m.getInternalHooks, b = m.getFieldsValue, w = S(Ju), x = w.dispatch, E = i.getValue(), R = v || function(A) {
        return te({}, g, A);
      }, _ = l[d], P = c !== void 0 ? R(E) : {};
      process.env.NODE_ENV !== "production" && P && Object.keys(P).forEach(function(A) {
        gr(typeof P[A] != "function", "It's not recommended to generate dynamic function prop by `getValueProps`. Please pass it to child component directly (prop: ".concat(A, ")"));
      });
      var D = re(re({}, l), P);
      D[d] = function() {
        i.touched = !0, i.dirty = !0, i.triggerMetaEvent();
        for (var A, O = arguments.length, L = new Array(O), N = 0; N < O; N++)
          L[N] = arguments[N];
        f ? A = f.apply(void 0, L) : A = Ire.apply(void 0, [g].concat(L)), p && (A = p(A, E, b(!0))), x({
          type: "updateValue",
          namePath: C,
          value: A
        }), _ && _.apply(void 0, L);
      };
      var I = WE(y || []);
      return I.forEach(function(A) {
        var O = D[A];
        D[A] = function() {
          O && O.apply(void 0, arguments);
          var L = i.props.rules;
          L && L.length && x({
            type: "validateField",
            namePath: C,
            triggerName: A
          });
        };
      }), D;
    }), n.fieldContext) {
      var o = n.fieldContext.getInternalHooks, a = o(Ju), s = a.initEntityValue;
      s(qt(i));
    }
    return i;
  }
  return zn(r, [{
    key: "componentDidMount",
    value: function() {
      var i = this.props, o = i.shouldUpdate, a = i.fieldContext;
      if (this.mounted = !0, a) {
        var s = a.getInternalHooks, l = s(Ju), u = l.registerField;
        this.cancelRegisterFunc = u(this);
      }
      o === !0 && this.reRender();
    }
  }, {
    key: "componentWillUnmount",
    value: function() {
      this.cancelRegister(), this.triggerMetaEvent(!0), this.mounted = !1;
    }
  }, {
    key: "reRender",
    value: function() {
      this.mounted && this.forceUpdate();
    }
  }, {
    key: "render",
    value: function() {
      var i = this.state.resetCount, o = this.props.children, a = this.getOnlyChild(o), s = a.child, l = a.isFunction, u;
      return l ? u = s : /* @__PURE__ */ T.isValidElement(s) ? u = /* @__PURE__ */ T.cloneElement(s, this.getControlled(s.props)) : (gr(!s, "`children` of Field is not validate ReactElement."), u = s), /* @__PURE__ */ T.createElement(T.Fragment, {
        key: i
      }, u);
    }
  }]), r;
}(T.Component);
te(lP, "contextType", Mh);
te(lP, "defaultProps", {
  trigger: "onChange",
  valuePropName: "value"
});
function C5(e) {
  var t = e.name, r = zt(e, Fre), n = T.useContext(Mh), i = T.useContext(P0), o = t !== void 0 ? on(t) : void 0, a = "keep";
  return r.isListField || (a = "_".concat((o || []).join("_"))), process.env.NODE_ENV !== "production" && r.preserve === !1 && r.isListField && o.length <= 1 && gr(!1, "`preserve` should not apply on Form.List fields."), /* @__PURE__ */ T.createElement(lP, ze({
    key: a,
    name: o,
    isListField: !!i
  }, r, {
    fieldContext: n
  }));
}
function Lre(e) {
  var t = e.name, r = e.initialValue, n = e.children, i = e.rules, o = e.validateTrigger, a = e.isListField, s = T.useContext(Mh), l = T.useContext(P0), u = T.useRef({
    keys: [],
    id: 0
  }), c = u.current, d = T.useMemo(function() {
    var g = on(s.prefixName) || [];
    return [].concat(rt(g), rt(on(t)));
  }, [s.prefixName, t]), h = T.useMemo(function() {
    return re(re({}, s), {}, {
      prefixName: d
    });
  }, [s, d]), f = T.useMemo(function() {
    return {
      getKey: function(v) {
        var m = d.length, y = v[m];
        return [c.keys[y], v.slice(m + 1)];
      }
    };
  }, [d]);
  if (typeof n != "function")
    return gr(!1, "Form.List only accepts function as children."), null;
  var p = function(v, m, y) {
    var C = y.source;
    return C === "internal" ? !1 : v !== m;
  };
  return /* @__PURE__ */ T.createElement(P0.Provider, {
    value: f
  }, /* @__PURE__ */ T.createElement(Mh.Provider, {
    value: h
  }, /* @__PURE__ */ T.createElement(C5, {
    name: [],
    shouldUpdate: p,
    rules: i,
    validateTrigger: o,
    initialValue: r,
    isList: !0,
    isListField: a ?? !!l
  }, function(g, v) {
    var m = g.value, y = m === void 0 ? [] : m, C = g.onChange, S = s.getFieldValue, b = function() {
      var R = S(d || []);
      return R || [];
    }, w = {
      add: function(R, _) {
        var P = b();
        _ >= 0 && _ <= P.length ? (c.keys = [].concat(rt(c.keys.slice(0, _)), [c.id], rt(c.keys.slice(_))), C([].concat(rt(P.slice(0, _)), [R], rt(P.slice(_))))) : (process.env.NODE_ENV !== "production" && (_ < 0 || _ > P.length) && gr(!1, "The second parameter of the add function should be a valid positive number."), c.keys = [].concat(rt(c.keys), [c.id]), C([].concat(rt(P), [R]))), c.id += 1;
      },
      remove: function(R) {
        var _ = b(), P = new Set(Array.isArray(R) ? R : [R]);
        P.size <= 0 || (c.keys = c.keys.filter(function(D, I) {
          return !P.has(I);
        }), C(_.filter(function(D, I) {
          return !P.has(I);
        })));
      },
      move: function(R, _) {
        if (R !== _) {
          var P = b();
          R < 0 || R >= P.length || _ < 0 || _ >= P.length || (c.keys = A2(c.keys, R, _), C(A2(P, R, _)));
        }
      }
    }, x = y || [];
    return Array.isArray(x) || (x = [], process.env.NODE_ENV !== "production" && gr(!1, "Current value of '".concat(d.join(" > "), "' is not an array type."))), n(x.map(function(E, R) {
      var _ = c.keys[R];
      return _ === void 0 && (c.keys[R] = c.id, _ = c.keys[R], c.id += 1), {
        name: R,
        key: _,
        isListField: !0
      };
    }), w, v);
  })));
}
function Ore(e) {
  var t = !1, r = e.length, n = [];
  return e.length ? new Promise(function(i, o) {
    e.forEach(function(a, s) {
      a.catch(function(l) {
        return t = !0, l;
      }).then(function(l) {
        r -= 1, n[s] = l, !(r > 0) && (t && o(n), i(n));
      });
    });
  }) : Promise.resolve([]);
}
var S5 = "__@field_split__";
function zw(e) {
  return e.map(function(t) {
    return "".concat(xt(t), ":").concat(t);
  }).join(S5);
}
var ld = /* @__PURE__ */ function() {
  function e() {
    Hn(this, e), te(this, "kvs", /* @__PURE__ */ new Map());
  }
  return zn(e, [{
    key: "set",
    value: function(r, n) {
      this.kvs.set(zw(r), n);
    }
  }, {
    key: "get",
    value: function(r) {
      return this.kvs.get(zw(r));
    }
  }, {
    key: "update",
    value: function(r, n) {
      var i = this.get(r), o = n(i);
      o ? this.set(r, o) : this.delete(r);
    }
  }, {
    key: "delete",
    value: function(r) {
      this.kvs.delete(zw(r));
    }
    // Since we only use this in test, let simply realize this
  }, {
    key: "map",
    value: function(r) {
      return rt(this.kvs.entries()).map(function(n) {
        var i = ue(n, 2), o = i[0], a = i[1], s = o.split(S5);
        return r({
          key: s.map(function(l) {
            var u = l.match(/^([^:]*):(.*)$/), c = ue(u, 3), d = c[1], h = c[2];
            return d === "number" ? Number(h) : h;
          }),
          value: a
        });
      });
    }
  }, {
    key: "toJSON",
    value: function() {
      var r = {};
      return this.map(function(n) {
        var i = n.key, o = n.value;
        return r[i.join(".")] = o, null;
      }), r;
    }
  }]), e;
}(), Nre = ["name"], kre = /* @__PURE__ */ zn(function e(t) {
  var r = this;
  Hn(this, e), te(this, "formHooked", !1), te(this, "forceRootUpdate", void 0), te(this, "subscribable", !0), te(this, "store", {}), te(this, "fieldEntities", []), te(this, "initialValues", {}), te(this, "callbacks", {}), te(this, "validateMessages", null), te(this, "preserve", null), te(this, "lastValidatePromise", null), te(this, "getForm", function() {
    return {
      getFieldValue: r.getFieldValue,
      getFieldsValue: r.getFieldsValue,
      getFieldError: r.getFieldError,
      getFieldWarning: r.getFieldWarning,
      getFieldsError: r.getFieldsError,
      isFieldsTouched: r.isFieldsTouched,
      isFieldTouched: r.isFieldTouched,
      isFieldValidating: r.isFieldValidating,
      isFieldsValidating: r.isFieldsValidating,
      resetFields: r.resetFields,
      setFields: r.setFields,
      setFieldValue: r.setFieldValue,
      setFieldsValue: r.setFieldsValue,
      validateFields: r.validateFields,
      submit: r.submit,
      _init: !0,
      getInternalHooks: r.getInternalHooks
    };
  }), te(this, "getInternalHooks", function(n) {
    return n === Ju ? (r.formHooked = !0, {
      dispatch: r.dispatch,
      initEntityValue: r.initEntityValue,
      registerField: r.registerField,
      useSubscribe: r.useSubscribe,
      setInitialValues: r.setInitialValues,
      destroyForm: r.destroyForm,
      setCallbacks: r.setCallbacks,
      setValidateMessages: r.setValidateMessages,
      getFields: r.getFields,
      setPreserve: r.setPreserve,
      getInitialValue: r.getInitialValue,
      registerWatch: r.registerWatch
    }) : (gr(!1, "`getInternalHooks` is internal usage. Should not call directly."), null);
  }), te(this, "useSubscribe", function(n) {
    r.subscribable = n;
  }), te(this, "prevWithoutPreserves", null), te(this, "setInitialValues", function(n, i) {
    if (r.initialValues = n || {}, i) {
      var o, a = Zd(n, r.store);
      (o = r.prevWithoutPreserves) === null || o === void 0 || o.map(function(s) {
        var l = s.key;
        a = ta(a, l, Ha(n, l));
      }), r.prevWithoutPreserves = null, r.updateStore(a);
    }
  }), te(this, "destroyForm", function(n) {
    if (n)
      r.updateStore({});
    else {
      var i = new ld();
      r.getFieldEntities(!0).forEach(function(o) {
        r.isMergedPreserve(o.isPreserve()) || i.set(o.getNamePath(), !0);
      }), r.prevWithoutPreserves = i;
    }
  }), te(this, "getInitialValue", function(n) {
    var i = Ha(r.initialValues, n);
    return n.length ? Zd(i) : i;
  }), te(this, "setCallbacks", function(n) {
    r.callbacks = n;
  }), te(this, "setValidateMessages", function(n) {
    r.validateMessages = n;
  }), te(this, "setPreserve", function(n) {
    r.preserve = n;
  }), te(this, "watchList", []), te(this, "registerWatch", function(n) {
    return r.watchList.push(n), function() {
      r.watchList = r.watchList.filter(function(i) {
        return i !== n;
      });
    };
  }), te(this, "notifyWatch", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    if (r.watchList.length) {
      var i = r.getFieldsValue(), o = r.getFieldsValue(!0);
      r.watchList.forEach(function(a) {
        a(i, o, n);
      });
    }
  }), te(this, "timeoutId", null), te(this, "warningUnhooked", function() {
    process.env.NODE_ENV !== "production" && !r.timeoutId && typeof window < "u" && (r.timeoutId = setTimeout(function() {
      r.timeoutId = null, r.formHooked || gr(!1, "Instance created by `useForm` is not connected to any Form element. Forget to pass `form` prop?");
    }));
  }), te(this, "updateStore", function(n) {
    r.store = n;
  }), te(this, "getFieldEntities", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    return n ? r.fieldEntities.filter(function(i) {
      return i.getNamePath().length;
    }) : r.fieldEntities;
  }), te(this, "getFieldsMap", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, i = new ld();
    return r.getFieldEntities(n).forEach(function(o) {
      var a = o.getNamePath();
      i.set(a, o);
    }), i;
  }), te(this, "getFieldEntitiesForNamePathList", function(n) {
    if (!n)
      return r.getFieldEntities(!0);
    var i = r.getFieldsMap(!0);
    return n.map(function(o) {
      var a = on(o);
      return i.get(a) || {
        INVALIDATE_NAME_PATH: on(o)
      };
    });
  }), te(this, "getFieldsValue", function(n, i) {
    r.warningUnhooked();
    var o, a, s;
    if (n === !0 || Array.isArray(n) ? (o = n, a = i) : n && xt(n) === "object" && (s = n.strict, a = n.filter), o === !0 && !a)
      return r.store;
    var l = r.getFieldEntitiesForNamePathList(Array.isArray(o) ? o : null), u = [];
    return l.forEach(function(c) {
      var d, h, f = "INVALIDATE_NAME_PATH" in c ? c.INVALIDATE_NAME_PATH : c.getNamePath();
      if (s) {
        var p, g;
        if ((p = (g = c).isList) !== null && p !== void 0 && p.call(g))
          return;
      } else if (!o && (d = (h = c).isListField) !== null && d !== void 0 && d.call(h))
        return;
      if (!a)
        u.push(f);
      else {
        var v = "getMeta" in c ? c.getMeta() : null;
        a(v) && u.push(f);
      }
    }), D2(r.store, u.map(on));
  }), te(this, "getFieldValue", function(n) {
    r.warningUnhooked();
    var i = on(n);
    return Ha(r.store, i);
  }), te(this, "getFieldsError", function(n) {
    r.warningUnhooked();
    var i = r.getFieldEntitiesForNamePathList(n);
    return i.map(function(o, a) {
      return o && !("INVALIDATE_NAME_PATH" in o) ? {
        name: o.getNamePath(),
        errors: o.getErrors(),
        warnings: o.getWarnings()
      } : {
        name: on(n[a]),
        errors: [],
        warnings: []
      };
    });
  }), te(this, "getFieldError", function(n) {
    r.warningUnhooked();
    var i = on(n), o = r.getFieldsError([i])[0];
    return o.errors;
  }), te(this, "getFieldWarning", function(n) {
    r.warningUnhooked();
    var i = on(n), o = r.getFieldsError([i])[0];
    return o.warnings;
  }), te(this, "isFieldsTouched", function() {
    r.warningUnhooked();
    for (var n = arguments.length, i = new Array(n), o = 0; o < n; o++)
      i[o] = arguments[o];
    var a = i[0], s = i[1], l, u = !1;
    i.length === 0 ? l = null : i.length === 1 ? Array.isArray(a) ? (l = a.map(on), u = !1) : (l = null, u = a) : (l = a.map(on), u = s);
    var c = r.getFieldEntities(!0), d = function(v) {
      return v.isFieldTouched();
    };
    if (!l)
      return u ? c.every(function(g) {
        return d(g) || g.isList();
      }) : c.some(d);
    var h = new ld();
    l.forEach(function(g) {
      h.set(g, []);
    }), c.forEach(function(g) {
      var v = g.getNamePath();
      l.forEach(function(m) {
        m.every(function(y, C) {
          return v[C] === y;
        }) && h.update(m, function(y) {
          return [].concat(rt(y), [g]);
        });
      });
    });
    var f = function(v) {
      return v.some(d);
    }, p = h.map(function(g) {
      var v = g.value;
      return v;
    });
    return u ? p.every(f) : p.some(f);
  }), te(this, "isFieldTouched", function(n) {
    return r.warningUnhooked(), r.isFieldsTouched([n]);
  }), te(this, "isFieldsValidating", function(n) {
    r.warningUnhooked();
    var i = r.getFieldEntities();
    if (!n)
      return i.some(function(a) {
        return a.isFieldValidating();
      });
    var o = n.map(on);
    return i.some(function(a) {
      var s = a.getNamePath();
      return lh(o, s) && a.isFieldValidating();
    });
  }), te(this, "isFieldValidating", function(n) {
    return r.warningUnhooked(), r.isFieldsValidating([n]);
  }), te(this, "resetWithFieldInitialValue", function() {
    var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, i = new ld(), o = r.getFieldEntities(!0);
    o.forEach(function(l) {
      var u = l.props.initialValue, c = l.getNamePath();
      if (u !== void 0) {
        var d = i.get(c) || /* @__PURE__ */ new Set();
        d.add({
          entity: l,
          value: u
        }), i.set(c, d);
      }
    });
    var a = function(u) {
      u.forEach(function(c) {
        var d = c.props.initialValue;
        if (d !== void 0) {
          var h = c.getNamePath(), f = r.getInitialValue(h);
          if (f !== void 0)
            gr(!1, "Form already set 'initialValues' with path '".concat(h.join("."), "'. Field can not overwrite it."));
          else {
            var p = i.get(h);
            if (p && p.size > 1)
              gr(!1, "Multiple Field with path '".concat(h.join("."), "' set 'initialValue'. Can not decide which one to pick."));
            else if (p) {
              var g = r.getFieldValue(h), v = c.isListField();
              !v && (!n.skipExist || g === void 0) && r.updateStore(ta(r.store, h, rt(p)[0].value));
            }
          }
        }
      });
    }, s;
    n.entities ? s = n.entities : n.namePathList ? (s = [], n.namePathList.forEach(function(l) {
      var u = i.get(l);
      if (u) {
        var c;
        (c = s).push.apply(c, rt(rt(u).map(function(d) {
          return d.entity;
        })));
      }
    })) : s = o, a(s);
  }), te(this, "resetFields", function(n) {
    r.warningUnhooked();
    var i = r.store;
    if (!n) {
      r.updateStore(Zd(r.initialValues)), r.resetWithFieldInitialValue(), r.notifyObservers(i, null, {
        type: "reset"
      }), r.notifyWatch();
      return;
    }
    var o = n.map(on);
    o.forEach(function(a) {
      var s = r.getInitialValue(a);
      r.updateStore(ta(r.store, a, s));
    }), r.resetWithFieldInitialValue({
      namePathList: o
    }), r.notifyObservers(i, o, {
      type: "reset"
    }), r.notifyWatch(o);
  }), te(this, "setFields", function(n) {
    r.warningUnhooked();
    var i = r.store, o = [];
    n.forEach(function(a) {
      var s = a.name, l = zt(a, Nre), u = on(s);
      o.push(u), "value" in l && r.updateStore(ta(r.store, u, l.value)), r.notifyObservers(i, [u], {
        type: "setField",
        data: a
      });
    }), r.notifyWatch(o);
  }), te(this, "getFields", function() {
    var n = r.getFieldEntities(!0), i = n.map(function(o) {
      var a = o.getNamePath(), s = o.getMeta(), l = re(re({}, s), {}, {
        name: a,
        value: r.getFieldValue(a)
      });
      return Object.defineProperty(l, "originRCField", {
        value: !0
      }), l;
    });
    return i;
  }), te(this, "initEntityValue", function(n) {
    var i = n.props.initialValue;
    if (i !== void 0) {
      var o = n.getNamePath(), a = Ha(r.store, o);
      a === void 0 && r.updateStore(ta(r.store, o, i));
    }
  }), te(this, "isMergedPreserve", function(n) {
    var i = n !== void 0 ? n : r.preserve;
    return i ?? !0;
  }), te(this, "registerField", function(n) {
    r.fieldEntities.push(n);
    var i = n.getNamePath();
    if (r.notifyWatch([i]), n.props.initialValue !== void 0) {
      var o = r.store;
      r.resetWithFieldInitialValue({
        entities: [n],
        skipExist: !0
      }), r.notifyObservers(o, [n.getNamePath()], {
        type: "valueUpdate",
        source: "internal"
      });
    }
    return function(a, s) {
      var l = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      if (r.fieldEntities = r.fieldEntities.filter(function(d) {
        return d !== n;
      }), !r.isMergedPreserve(s) && (!a || l.length > 1)) {
        var u = a ? void 0 : r.getInitialValue(i);
        if (i.length && r.getFieldValue(i) !== u && r.fieldEntities.every(function(d) {
          return (
            // Only reset when no namePath exist
            !y5(d.getNamePath(), i)
          );
        })) {
          var c = r.store;
          r.updateStore(ta(c, i, u, !0)), r.notifyObservers(c, [i], {
            type: "remove"
          }), r.triggerDependenciesUpdate(c, i);
        }
      }
      r.notifyWatch([i]);
    };
  }), te(this, "dispatch", function(n) {
    switch (n.type) {
      case "updateValue": {
        var i = n.namePath, o = n.value;
        r.updateValue(i, o);
        break;
      }
      case "validateField": {
        var a = n.namePath, s = n.triggerName;
        r.validateFields([a], {
          triggerName: s
        });
        break;
      }
    }
  }), te(this, "notifyObservers", function(n, i, o) {
    if (r.subscribable) {
      var a = re(re({}, o), {}, {
        store: r.getFieldsValue(!0)
      });
      r.getFieldEntities().forEach(function(s) {
        var l = s.onStoreChange;
        l(n, i, a);
      });
    } else
      r.forceRootUpdate();
  }), te(this, "triggerDependenciesUpdate", function(n, i) {
    var o = r.getDependencyChildrenFields(i);
    return o.length && r.validateFields(o), r.notifyObservers(n, o, {
      type: "dependenciesUpdate",
      relatedFields: [i].concat(rt(o))
    }), o;
  }), te(this, "updateValue", function(n, i) {
    var o = on(n), a = r.store;
    r.updateStore(ta(r.store, o, i)), r.notifyObservers(a, [o], {
      type: "valueUpdate",
      source: "internal"
    }), r.notifyWatch([o]);
    var s = r.triggerDependenciesUpdate(a, o), l = r.callbacks.onValuesChange;
    if (l) {
      var u = D2(r.store, [o]);
      l(u, r.getFieldsValue());
    }
    r.triggerOnFieldsChange([o].concat(rt(s)));
  }), te(this, "setFieldsValue", function(n) {
    r.warningUnhooked();
    var i = r.store;
    if (n) {
      var o = Zd(r.store, n);
      r.updateStore(o);
    }
    r.notifyObservers(i, null, {
      type: "valueUpdate",
      source: "external"
    }), r.notifyWatch();
  }), te(this, "setFieldValue", function(n, i) {
    r.setFields([{
      name: n,
      value: i
    }]);
  }), te(this, "getDependencyChildrenFields", function(n) {
    var i = /* @__PURE__ */ new Set(), o = [], a = new ld();
    r.getFieldEntities().forEach(function(l) {
      var u = l.props.dependencies;
      (u || []).forEach(function(c) {
        var d = on(c);
        a.update(d, function() {
          var h = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
          return h.add(l), h;
        });
      });
    });
    var s = function l(u) {
      var c = a.get(u) || /* @__PURE__ */ new Set();
      c.forEach(function(d) {
        if (!i.has(d)) {
          i.add(d);
          var h = d.getNamePath();
          d.isFieldDirty() && h.length && (o.push(h), l(h));
        }
      });
    };
    return s(n), o;
  }), te(this, "triggerOnFieldsChange", function(n, i) {
    var o = r.callbacks.onFieldsChange;
    if (o) {
      var a = r.getFields();
      if (i) {
        var s = new ld();
        i.forEach(function(u) {
          var c = u.name, d = u.errors;
          s.set(c, d);
        }), a.forEach(function(u) {
          u.errors = s.get(u.name) || u.errors;
        });
      }
      var l = a.filter(function(u) {
        var c = u.name;
        return lh(n, c);
      });
      l.length && o(l, a);
    }
  }), te(this, "validateFields", function(n, i) {
    r.warningUnhooked();
    var o, a;
    Array.isArray(n) || typeof n == "string" || typeof i == "string" ? (o = n, a = i) : a = n;
    var s = !!o, l = s ? o.map(on) : [], u = [], c = String(Date.now()), d = /* @__PURE__ */ new Set(), h = a || {}, f = h.recursive, p = h.dirty;
    r.getFieldEntities(!0).forEach(function(y) {
      if (s || l.push(y.getNamePath()), !(!y.props.rules || !y.props.rules.length) && !(p && !y.isFieldDirty())) {
        var C = y.getNamePath();
        if (d.add(C.join(c)), !s || lh(l, C, f)) {
          var S = y.validateRules(re({
            validateMessages: re(re({}, m5), r.validateMessages)
          }, a));
          u.push(S.then(function() {
            return {
              name: C,
              errors: [],
              warnings: []
            };
          }).catch(function(b) {
            var w, x = [], E = [];
            return (w = b.forEach) === null || w === void 0 || w.call(b, function(R) {
              var _ = R.rule.warningOnly, P = R.errors;
              _ ? E.push.apply(E, rt(P)) : x.push.apply(x, rt(P));
            }), x.length ? Promise.reject({
              name: C,
              errors: x,
              warnings: E
            }) : {
              name: C,
              errors: x,
              warnings: E
            };
          }));
        }
      }
    });
    var g = Ore(u);
    r.lastValidatePromise = g, g.catch(function(y) {
      return y;
    }).then(function(y) {
      var C = y.map(function(S) {
        var b = S.name;
        return b;
      });
      r.notifyObservers(r.store, C, {
        type: "validateFinish"
      }), r.triggerOnFieldsChange(C, y);
    });
    var v = g.then(function() {
      return r.lastValidatePromise === g ? Promise.resolve(r.getFieldsValue(l)) : Promise.reject([]);
    }).catch(function(y) {
      var C = y.filter(function(S) {
        return S && S.errors.length;
      });
      return Promise.reject({
        values: r.getFieldsValue(l),
        errorFields: C,
        outOfDate: r.lastValidatePromise !== g
      });
    });
    v.catch(function(y) {
      return y;
    });
    var m = l.filter(function(y) {
      return d.has(y.join(c));
    });
    return r.triggerOnFieldsChange(m), v;
  }), te(this, "submit", function() {
    r.warningUnhooked(), r.validateFields().then(function(n) {
      var i = r.callbacks.onFinish;
      if (i)
        try {
          i(n);
        } catch (o) {
          console.error(o);
        }
    }).catch(function(n) {
      var i = r.callbacks.onFinishFailed;
      i && i(n);
    });
  }), this.forceRootUpdate = t;
});
function w5(e) {
  var t = T.useRef(), r = T.useState({}), n = ue(r, 2), i = n[1];
  if (!t.current)
    if (e)
      t.current = e;
    else {
      var o = function() {
        i({});
      }, a = new kre(o);
      t.current = a.getForm();
    }
  return [t.current];
}
var JE = /* @__PURE__ */ T.createContext({
  triggerFormChange: function() {
  },
  triggerFormFinish: function() {
  },
  registerForm: function() {
  },
  unregisterForm: function() {
  }
}), Vre = function(t) {
  var r = t.validateMessages, n = t.onFormChange, i = t.onFormFinish, o = t.children, a = T.useContext(JE), s = T.useRef({});
  return /* @__PURE__ */ T.createElement(JE.Provider, {
    value: re(re({}, a), {}, {
      validateMessages: re(re({}, a.validateMessages), r),
      // =========================================================
      // =                  Global Form Control                  =
      // =========================================================
      triggerFormChange: function(u, c) {
        n && n(u, {
          changedFields: c,
          forms: s.current
        }), a.triggerFormChange(u, c);
      },
      triggerFormFinish: function(u, c) {
        i && i(u, {
          values: c,
          forms: s.current
        }), a.triggerFormFinish(u, c);
      },
      registerForm: function(u, c) {
        u && (s.current = re(re({}, s.current), {}, te({}, u, c))), a.registerForm(u, c);
      },
      unregisterForm: function(u) {
        var c = re({}, s.current);
        delete c[u], s.current = c, a.unregisterForm(u);
      }
    })
  }, o);
}, Bre = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed", "clearOnDestroy"], Gre = function(t, r) {
  var n = t.name, i = t.initialValues, o = t.fields, a = t.form, s = t.preserve, l = t.children, u = t.component, c = u === void 0 ? "form" : u, d = t.validateMessages, h = t.validateTrigger, f = h === void 0 ? "onChange" : h, p = t.onValuesChange, g = t.onFieldsChange, v = t.onFinish, m = t.onFinishFailed, y = t.clearOnDestroy, C = zt(t, Bre), S = T.useRef(null), b = T.useContext(JE), w = w5(a), x = ue(w, 1), E = x[0], R = E.getInternalHooks(Ju), _ = R.useSubscribe, P = R.setInitialValues, D = R.setCallbacks, I = R.setValidateMessages, A = R.setPreserve, O = R.destroyForm;
  T.useImperativeHandle(r, function() {
    return re(re({}, E), {}, {
      nativeElement: S.current
    });
  }), T.useEffect(function() {
    return b.registerForm(n, E), function() {
      b.unregisterForm(n);
    };
  }, [b, E, n]), I(re(re({}, b.validateMessages), d)), D({
    onValuesChange: p,
    onFieldsChange: function($) {
      if (b.triggerFormChange(n, $), g) {
        for (var W = arguments.length, j = new Array(W > 1 ? W - 1 : 0), U = 1; U < W; U++)
          j[U - 1] = arguments[U];
        g.apply(void 0, [$].concat(j));
      }
    },
    onFinish: function($) {
      b.triggerFormFinish(n, $), v && v($);
    },
    onFinishFailed: m
  }), A(s);
  var L = T.useRef(null);
  P(i, !L.current), L.current || (L.current = !0), T.useEffect(
    function() {
      return function() {
        return O(y);
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  var N, F = typeof l == "function";
  if (F) {
    var G = E.getFieldsValue(!0);
    N = l(G, E);
  } else
    N = l;
  _(!F);
  var M = T.useRef();
  T.useEffect(function() {
    Are(M.current || [], o || []) || E.setFields(o || []), M.current = o;
  }, [o, E]);
  var V = T.useMemo(function() {
    return re(re({}, E), {}, {
      validateTrigger: f
    });
  }, [E, f]), z = /* @__PURE__ */ T.createElement(P0.Provider, {
    value: null
  }, /* @__PURE__ */ T.createElement(Mh.Provider, {
    value: V
  }, N));
  return c === !1 ? z : /* @__PURE__ */ T.createElement(c, ze({}, C, {
    ref: S,
    onSubmit: function($) {
      $.preventDefault(), $.stopPropagation(), E.submit();
    },
    onReset: function($) {
      var W;
      $.preventDefault(), E.resetFields(), (W = C.onReset) === null || W === void 0 || W.call(C, $);
    }
  }), z);
};
function F2(e) {
  try {
    return JSON.stringify(e);
  } catch {
    return Math.random();
  }
}
var Hre = process.env.NODE_ENV !== "production" ? function(e) {
  var t = e.join("__RC_FIELD_FORM_SPLIT__"), r = le(t);
  gr(r.current === t, "`useWatch` is not support dynamic `namePath`. Please provide static instead.");
} : function() {
};
function zre() {
  for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
    t[r] = arguments[r];
  var n = t[0], i = t[1], o = i === void 0 ? {} : i, a = Zte(o) ? {
    form: o
  } : o, s = a.form, l = Ee(), u = ue(l, 2), c = u[0], d = u[1], h = ct(function() {
    return F2(c);
  }, [c]), f = le(h);
  f.current = h;
  var p = rr(Mh), g = s || p, v = g && g._init;
  process.env.NODE_ENV !== "production" && gr(t.length === 2 ? s ? v : !0 : v, "useWatch requires a form instance since it can not auto detect from context.");
  var m = on(n), y = le(m);
  return y.current = m, Hre(m), It(
    function() {
      if (v) {
        var C = g.getFieldsValue, S = g.getInternalHooks, b = S(Ju), w = b.registerWatch, x = function(P, D) {
          var I = a.preserve ? D : P;
          return typeof n == "function" ? n(I) : Ha(I, y.current);
        }, E = w(function(_, P) {
          var D = x(_, P), I = F2(D);
          f.current !== I && (f.current = I, d(D));
        }), R = x(C(), C(!0));
        return c !== R && d(R), E;
      }
    },
    // We do not need re-register since namePath content is the same
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [v]
  ), c;
}
var $re = /* @__PURE__ */ T.forwardRef(Gre), hv = $re;
hv.FormProvider = Vre;
hv.Field = C5;
hv.List = Lre;
hv.useForm = w5;
hv.useWatch = zre;
const Bs = /* @__PURE__ */ T.createContext({});
process.env.NODE_ENV !== "production" && (Bs.displayName = "FormItemInputContext");
const Wre = (e) => {
  let {
    children: t,
    status: r,
    override: n
  } = e;
  const i = rr(Bs), o = ct(() => {
    const a = Object.assign({}, i);
    return n && delete a.isFormItemInput, r && (delete a.status, delete a.hasFeedback, delete a.feedbackIcon), a;
  }, [r, n, i]);
  return /* @__PURE__ */ T.createElement(Bs.Provider, {
    value: o
  }, t);
}, jre = /* @__PURE__ */ Xl(void 0), eR = (e) => {
  const {
    space: t,
    form: r,
    children: n
  } = e;
  if (n == null)
    return null;
  let i = n;
  return r && (i = /* @__PURE__ */ H.createElement(Wre, {
    override: !0,
    status: !0
  }, i)), t && (i = /* @__PURE__ */ H.createElement(ite, null, i)), i;
};
function L2(e) {
  if (e)
    return {
      closable: e.closable,
      closeIcon: e.closeIcon
    };
}
function O2(e) {
  const {
    closable: t,
    closeIcon: r
  } = e || {};
  return H.useMemo(() => {
    if (
      // If `closable`, whatever rest be should be true
      !t && (t === !1 || r === !1 || r === null)
    )
      return !1;
    if (t === void 0 && r === void 0)
      return null;
    let n = {
      closeIcon: typeof r != "boolean" && r !== null ? r : void 0
    };
    return t && typeof t == "object" && (n = Object.assign(Object.assign({}, n), t)), n;
  }, [t, r]);
}
function N2() {
  const e = {};
  for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
    r[n] = arguments[n];
  return r.forEach((i) => {
    i && Object.keys(i).forEach((o) => {
      i[o] !== void 0 && (e[o] = i[o]);
    });
  }), e;
}
const Ure = {};
function Kre(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Ure;
  const n = O2(e), i = O2(t), o = H.useMemo(() => Object.assign({
    closeIcon: /* @__PURE__ */ H.createElement(iS, null)
  }, r), [r]), a = H.useMemo(() => n === !1 ? !1 : n ? N2(o, i, n) : i === !1 ? !1 : i ? N2(o, i) : o.closable ? o : !1, [n, i, o]);
  return H.useMemo(() => {
    if (a === !1)
      return [!1, null];
    const {
      closeIconRender: s
    } = o, {
      closeIcon: l
    } = a;
    let u = l;
    if (u != null) {
      s && (u = s(l));
      const c = oS(a, !0);
      Object.keys(c).length && (u = /* @__PURE__ */ H.isValidElement(u) ? /* @__PURE__ */ H.cloneElement(u, c) : /* @__PURE__ */ H.createElement("span", Object.assign({}, c), u));
    }
    return [!0, u];
  }, [a, o]);
}
var b5 = function(t) {
  if (mi() && window.document.documentElement) {
    var r = Array.isArray(t) ? t : [t], n = window.document.documentElement;
    return r.some(function(i) {
      return i in n.style;
    });
  }
  return !1;
}, Yre = function(t, r) {
  if (!b5(t))
    return !1;
  var n = document.createElement("div"), i = n.style[t];
  return n.style[t] = r, n.style[t] !== i;
};
function k2(e, t) {
  return !Array.isArray(e) && t !== void 0 ? Yre(e, t) : b5(e);
}
const sS = (e) => {
  const {
    prefixCls: t,
    className: r,
    style: n,
    size: i,
    shape: o
  } = e, a = pe({
    [`${t}-lg`]: i === "large",
    [`${t}-sm`]: i === "small"
  }), s = pe({
    [`${t}-circle`]: o === "circle",
    [`${t}-square`]: o === "square",
    [`${t}-round`]: o === "round"
  }), l = T.useMemo(() => typeof i == "number" ? {
    width: i,
    height: i,
    lineHeight: `${i}px`
  } : {}, [i]);
  return /* @__PURE__ */ T.createElement("span", {
    className: pe(t, a, s, r),
    style: Object.assign(Object.assign({}, l), n)
  });
}, qre = new Yr("ant-skeleton-loading", {
  "0%": {
    backgroundPosition: "100% 50%"
  },
  "100%": {
    backgroundPosition: "0 50%"
  }
}), lS = (e) => ({
  height: e,
  lineHeight: xe(e)
}), uh = (e) => Object.assign({
  width: e
}, lS(e)), Zre = (e) => ({
  background: e.skeletonLoadingBackground,
  backgroundSize: "400% 100%",
  animationName: qre,
  animationDuration: e.skeletonLoadingMotionDuration,
  animationTimingFunction: "ease",
  animationIterationCount: "infinite"
}), $w = (e, t) => Object.assign({
  width: t(e).mul(5).equal(),
  minWidth: t(e).mul(5).equal()
}, lS(e)), Xre = (e) => {
  const {
    skeletonAvatarCls: t,
    gradientFromColor: r,
    controlHeight: n,
    controlHeightLG: i,
    controlHeightSM: o
  } = e;
  return {
    [`${t}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: r
    }, uh(n)),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    },
    [`${t}${t}-lg`]: Object.assign({}, uh(i)),
    [`${t}${t}-sm`]: Object.assign({}, uh(o))
  };
}, Qre = (e) => {
  const {
    controlHeight: t,
    borderRadiusSM: r,
    skeletonInputCls: n,
    controlHeightLG: i,
    controlHeightSM: o,
    gradientFromColor: a,
    calc: s
  } = e;
  return {
    [`${n}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: a,
      borderRadius: r
    }, $w(t, s)),
    [`${n}-lg`]: Object.assign({}, $w(i, s)),
    [`${n}-sm`]: Object.assign({}, $w(o, s))
  };
}, V2 = (e) => Object.assign({
  width: e
}, lS(e)), Jre = (e) => {
  const {
    skeletonImageCls: t,
    imageSizeBase: r,
    gradientFromColor: n,
    borderRadiusSM: i,
    calc: o
  } = e;
  return {
    [`${t}`]: Object.assign(Object.assign({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: n,
      borderRadius: i
    }, V2(o(r).mul(2).equal())), {
      [`${t}-path`]: {
        fill: "#bfbfbf"
      },
      [`${t}-svg`]: Object.assign(Object.assign({}, V2(r)), {
        maxWidth: o(r).mul(4).equal(),
        maxHeight: o(r).mul(4).equal()
      }),
      [`${t}-svg${t}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    }
  };
}, Ww = (e, t, r) => {
  const {
    skeletonButtonCls: n
  } = e;
  return {
    [`${r}${n}-circle`]: {
      width: t,
      minWidth: t,
      borderRadius: "50%"
    },
    [`${r}${n}-round`]: {
      borderRadius: t
    }
  };
}, jw = (e, t) => Object.assign({
  width: t(e).mul(2).equal(),
  minWidth: t(e).mul(2).equal()
}, lS(e)), ene = (e) => {
  const {
    borderRadiusSM: t,
    skeletonButtonCls: r,
    controlHeight: n,
    controlHeightLG: i,
    controlHeightSM: o,
    gradientFromColor: a,
    calc: s
  } = e;
  return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
    [`${r}`]: Object.assign({
      display: "inline-block",
      verticalAlign: "top",
      background: a,
      borderRadius: t,
      width: s(n).mul(2).equal(),
      minWidth: s(n).mul(2).equal()
    }, jw(n, s))
  }, Ww(e, n, r)), {
    [`${r}-lg`]: Object.assign({}, jw(i, s))
  }), Ww(e, i, `${r}-lg`)), {
    [`${r}-sm`]: Object.assign({}, jw(o, s))
  }), Ww(e, o, `${r}-sm`));
}, tne = (e) => {
  const {
    componentCls: t,
    skeletonAvatarCls: r,
    skeletonTitleCls: n,
    skeletonParagraphCls: i,
    skeletonButtonCls: o,
    skeletonInputCls: a,
    skeletonImageCls: s,
    controlHeight: l,
    controlHeightLG: u,
    controlHeightSM: c,
    gradientFromColor: d,
    padding: h,
    marginSM: f,
    borderRadius: p,
    titleHeight: g,
    blockRadius: v,
    paragraphLiHeight: m,
    controlHeightXS: y,
    paragraphMarginTop: C
  } = e;
  return {
    [`${t}`]: {
      display: "table",
      width: "100%",
      [`${t}-header`]: {
        display: "table-cell",
        paddingInlineEnd: h,
        verticalAlign: "top",
        // Avatar
        [`${r}`]: Object.assign({
          display: "inline-block",
          verticalAlign: "top",
          background: d
        }, uh(l)),
        [`${r}-circle`]: {
          borderRadius: "50%"
        },
        [`${r}-lg`]: Object.assign({}, uh(u)),
        [`${r}-sm`]: Object.assign({}, uh(c))
      },
      [`${t}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [`${n}`]: {
          width: "100%",
          height: g,
          background: d,
          borderRadius: v,
          [`+ ${i}`]: {
            marginBlockStart: c
          }
        },
        // paragraph
        [`${i}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: m,
            listStyle: "none",
            background: d,
            borderRadius: v,
            "+ li": {
              marginBlockStart: y
            }
          }
        },
        [`${i}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${t}-content`]: {
        [`${n}, ${i} > li`]: {
          borderRadius: p
        }
      }
    },
    [`${t}-with-avatar ${t}-content`]: {
      // Title
      [`${n}`]: {
        marginBlockStart: f,
        [`+ ${i}`]: {
          marginBlockStart: C
        }
      }
    },
    // Skeleton element
    [`${t}${t}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
      display: "inline-block",
      width: "auto"
    }, ene(e)), Xre(e)), Qre(e)), Jre(e)),
    // Skeleton Block Button, Input
    [`${t}${t}-block`]: {
      width: "100%",
      [`${o}`]: {
        width: "100%"
      },
      [`${a}`]: {
        width: "100%"
      }
    },
    // With active animation
    [`${t}${t}-active`]: {
      [`
        ${n},
        ${i} > li,
        ${r},
        ${o},
        ${a},
        ${s}
      `]: Object.assign({}, Zre(e))
    }
  };
}, rne = (e) => {
  const {
    colorFillContent: t,
    colorFill: r
  } = e, n = t, i = r;
  return {
    color: n,
    colorGradientEnd: i,
    gradientFromColor: n,
    gradientToColor: i,
    titleHeight: e.controlHeight / 2,
    blockRadius: e.borderRadiusSM,
    paragraphMarginTop: e.marginLG + e.marginXXS,
    paragraphLiHeight: e.controlHeight / 2
  };
}, Qh = Gi("Skeleton", (e) => {
  const {
    componentCls: t,
    calc: r
  } = e, n = dn(e, {
    skeletonAvatarCls: `${t}-avatar`,
    skeletonTitleCls: `${t}-title`,
    skeletonParagraphCls: `${t}-paragraph`,
    skeletonButtonCls: `${t}-button`,
    skeletonInputCls: `${t}-input`,
    skeletonImageCls: `${t}-image`,
    imageSizeBase: r(e.controlHeight).mul(1.5).equal(),
    borderRadius: 100,
    // Large number to make capsule shape
    skeletonLoadingBackground: `linear-gradient(90deg, ${e.gradientFromColor} 25%, ${e.gradientToColor} 37%, ${e.gradientFromColor} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [tne(n)];
}, rne, {
  deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
}), nne = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    active: i,
    shape: o = "circle",
    size: a = "default"
  } = e, {
    getPrefixCls: s
  } = T.useContext(Xt), l = s("skeleton", t), [u, c, d] = Qh(l), h = Bi(e, ["prefixCls", "className"]), f = pe(l, `${l}-element`, {
    [`${l}-active`]: i
  }, r, n, c, d);
  return u(/* @__PURE__ */ T.createElement("div", {
    className: f
  }, /* @__PURE__ */ T.createElement(sS, Object.assign({
    prefixCls: `${l}-avatar`,
    shape: o,
    size: a
  }, h))));
}, ine = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    active: i,
    block: o = !1,
    size: a = "default"
  } = e, {
    getPrefixCls: s
  } = T.useContext(Xt), l = s("skeleton", t), [u, c, d] = Qh(l), h = Bi(e, ["prefixCls"]), f = pe(l, `${l}-element`, {
    [`${l}-active`]: i,
    [`${l}-block`]: o
  }, r, n, c, d);
  return u(/* @__PURE__ */ T.createElement("div", {
    className: f
  }, /* @__PURE__ */ T.createElement(sS, Object.assign({
    prefixCls: `${l}-button`,
    size: a
  }, h))));
}, one = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z", ane = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    style: i,
    active: o
  } = e, {
    getPrefixCls: a
  } = T.useContext(Xt), s = a("skeleton", t), [l, u, c] = Qh(s), d = pe(s, `${s}-element`, {
    [`${s}-active`]: o
  }, r, n, u, c);
  return l(/* @__PURE__ */ T.createElement("div", {
    className: d
  }, /* @__PURE__ */ T.createElement("div", {
    className: pe(`${s}-image`, r),
    style: i
  }, /* @__PURE__ */ T.createElement("svg", {
    viewBox: "0 0 1098 1024",
    xmlns: "http://www.w3.org/2000/svg",
    className: `${s}-image-svg`
  }, /* @__PURE__ */ T.createElement("title", null, "Image placeholder"), /* @__PURE__ */ T.createElement("path", {
    d: one,
    className: `${s}-image-path`
  })))));
}, sne = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    active: i,
    block: o,
    size: a = "default"
  } = e, {
    getPrefixCls: s
  } = T.useContext(Xt), l = s("skeleton", t), [u, c, d] = Qh(l), h = Bi(e, ["prefixCls"]), f = pe(l, `${l}-element`, {
    [`${l}-active`]: i,
    [`${l}-block`]: o
  }, r, n, c, d);
  return u(/* @__PURE__ */ T.createElement("div", {
    className: f
  }, /* @__PURE__ */ T.createElement(sS, Object.assign({
    prefixCls: `${l}-input`,
    size: a
  }, h))));
};
var lne = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "dot-chart", theme: "outlined" }, une = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: lne
  }));
}, x5 = /* @__PURE__ */ T.forwardRef(une);
process.env.NODE_ENV !== "production" && (x5.displayName = "DotChartOutlined");
const cne = (e) => {
  const {
    prefixCls: t,
    className: r,
    rootClassName: n,
    style: i,
    active: o,
    children: a
  } = e, {
    getPrefixCls: s
  } = T.useContext(Xt), l = s("skeleton", t), [u, c, d] = Qh(l), h = pe(l, `${l}-element`, {
    [`${l}-active`]: o
  }, c, r, n, d), f = a ?? /* @__PURE__ */ T.createElement(x5, null);
  return u(/* @__PURE__ */ T.createElement("div", {
    className: h
  }, /* @__PURE__ */ T.createElement("div", {
    className: pe(`${l}-image`, r),
    style: i
  }, f)));
}, dne = (e, t) => {
  const {
    width: r,
    rows: n = 2
  } = t;
  if (Array.isArray(r))
    return r[e];
  if (n - 1 === e)
    return r;
}, hne = (e) => {
  const {
    prefixCls: t,
    className: r,
    style: n,
    rows: i
  } = e, o = rt(Array(i)).map((a, s) => (
    // eslint-disable-next-line react/no-array-index-key
    /* @__PURE__ */ T.createElement("li", {
      key: s,
      style: {
        width: dne(s, e)
      }
    })
  ));
  return /* @__PURE__ */ T.createElement("ul", {
    className: pe(t, r),
    style: n
  }, o);
}, fne = (e) => {
  let {
    prefixCls: t,
    className: r,
    width: n,
    style: i
  } = e;
  return (
    // biome-ignore lint/a11y/useHeadingContent: HOC here
    /* @__PURE__ */ T.createElement("h3", {
      className: pe(t, r),
      style: Object.assign({
        width: n
      }, i)
    })
  );
};
function Uw(e) {
  return e && typeof e == "object" ? e : {};
}
function pne(e, t) {
  return e && !t ? {
    size: "large",
    shape: "square"
  } : {
    size: "large",
    shape: "circle"
  };
}
function gne(e, t) {
  return !e && t ? {
    width: "38%"
  } : e && t ? {
    width: "50%"
  } : {};
}
function vne(e, t) {
  const r = {};
  return (!e || !t) && (r.width = "61%"), !e && t ? r.rows = 3 : r.rows = 2, r;
}
const eu = (e) => {
  const {
    prefixCls: t,
    loading: r,
    className: n,
    rootClassName: i,
    style: o,
    children: a,
    avatar: s = !1,
    title: l = !0,
    paragraph: u = !0,
    active: c,
    round: d
  } = e, {
    getPrefixCls: h,
    direction: f,
    skeleton: p
  } = T.useContext(Xt), g = h("skeleton", t), [v, m, y] = Qh(g);
  if (r || !("loading" in e)) {
    const C = !!s, S = !!l, b = !!u;
    let w;
    if (C) {
      const R = Object.assign(Object.assign({
        prefixCls: `${g}-avatar`
      }, pne(S, b)), Uw(s));
      w = /* @__PURE__ */ T.createElement("div", {
        className: `${g}-header`
      }, /* @__PURE__ */ T.createElement(sS, Object.assign({}, R)));
    }
    let x;
    if (S || b) {
      let R;
      if (S) {
        const P = Object.assign(Object.assign({
          prefixCls: `${g}-title`
        }, gne(C, b)), Uw(l));
        R = /* @__PURE__ */ T.createElement(fne, Object.assign({}, P));
      }
      let _;
      if (b) {
        const P = Object.assign(Object.assign({
          prefixCls: `${g}-paragraph`
        }, vne(C, S)), Uw(u));
        _ = /* @__PURE__ */ T.createElement(hne, Object.assign({}, P));
      }
      x = /* @__PURE__ */ T.createElement("div", {
        className: `${g}-content`
      }, R, _);
    }
    const E = pe(g, {
      [`${g}-with-avatar`]: C,
      [`${g}-active`]: c,
      [`${g}-rtl`]: f === "rtl",
      [`${g}-round`]: d
    }, p == null ? void 0 : p.className, n, i, m, y);
    return v(/* @__PURE__ */ T.createElement("div", {
      className: E,
      style: Object.assign(Object.assign({}, p == null ? void 0 : p.style), o)
    }, w, x));
  }
  return a ?? null;
};
eu.Button = ine;
eu.Avatar = nne;
eu.Input = sne;
eu.Image = ane;
eu.Node = cne;
process.env.NODE_ENV !== "production" && (eu.displayName = "Skeleton");
const mne = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), yne = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), uP = function(e, t, r, n) {
  const o = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
  return {
    [`
      ${o}${e}-enter,
      ${o}${e}-appear
    `]: Object.assign(Object.assign({}, mne(n)), {
      animationPlayState: "paused"
    }),
    [`${o}${e}-leave`]: Object.assign(Object.assign({}, yne(n)), {
      animationPlayState: "paused"
    }),
    [`
      ${o}${e}-enter${e}-enter-active,
      ${o}${e}-appear${e}-appear-active
    `]: {
      animationName: t,
      animationPlayState: "running"
    },
    [`${o}${e}-leave${e}-leave-active`]: {
      animationName: r,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, Cne = new Yr("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), Sne = new Yr("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
}), E5 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const {
    antCls: r
  } = e, n = `${r}-fade`, i = t ? "&" : "";
  return [uP(n, Cne, Sne, e.motionDurationMid, t), {
    [`
        ${i}${n}-enter,
        ${i}${n}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${i}${n}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
}, wne = new Yr("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), bne = new Yr("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), xne = new Yr("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
}), Ene = new Yr("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
}), Rne = new Yr("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), _ne = new Yr("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), Tne = new Yr("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
}), Pne = new Yr("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
}), Mne = {
  "slide-up": {
    inKeyframes: wne,
    outKeyframes: bne
  },
  "slide-down": {
    inKeyframes: xne,
    outKeyframes: Ene
  },
  "slide-left": {
    inKeyframes: Rne,
    outKeyframes: _ne
  },
  "slide-right": {
    inKeyframes: Tne,
    outKeyframes: Pne
  }
}, B2 = (e, t) => {
  const {
    antCls: r
  } = e, n = `${r}-${t}`, {
    inKeyframes: i,
    outKeyframes: o
  } = Mne[t];
  return [uP(n, i, o, e.motionDurationMid), {
    [`
      ${n}-enter,
      ${n}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutQuint,
      "&-prepare": {
        transform: "scale(1)"
      }
    },
    [`${n}-leave`]: {
      animationTimingFunction: e.motionEaseInQuint
    }
  }];
}, Dne = new Yr("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), Ane = new Yr("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
}), G2 = new Yr("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), H2 = new Yr("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
}), Ine = new Yr("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
}), Fne = new Yr("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
}), Lne = new Yr("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
}), One = new Yr("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
}), Nne = new Yr("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
}), kne = new Yr("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
}), Vne = new Yr("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
}), Bne = new Yr("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
}), Gne = {
  zoom: {
    inKeyframes: Dne,
    outKeyframes: Ane
  },
  "zoom-big": {
    inKeyframes: G2,
    outKeyframes: H2
  },
  "zoom-big-fast": {
    inKeyframes: G2,
    outKeyframes: H2
  },
  "zoom-left": {
    inKeyframes: Lne,
    outKeyframes: One
  },
  "zoom-right": {
    inKeyframes: Nne,
    outKeyframes: kne
  },
  "zoom-up": {
    inKeyframes: Ine,
    outKeyframes: Fne
  },
  "zoom-down": {
    inKeyframes: Vne,
    outKeyframes: Bne
  }
}, uS = (e, t) => {
  const {
    antCls: r
  } = e, n = `${r}-${t}`, {
    inKeyframes: i,
    outKeyframes: o
  } = Gne[t];
  return [uP(n, i, o, t === "zoom-big-fast" ? e.motionDurationFast : e.motionDurationMid), {
    [`
        ${n}-enter,
        ${n}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${n}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
};
function z2(e) {
  return {
    position: e,
    inset: 0
  };
}
const R5 = (e) => {
  const {
    componentCls: t,
    antCls: r
  } = e;
  return [{
    [`${t}-root`]: {
      [`${t}${r}-zoom-enter, ${t}${r}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: e.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      // https://github.com/ant-design/ant-design/issues/37329
      // https://github.com/ant-design/ant-design/issues/40272
      [`${t}${r}-zoom-leave ${t}-content`]: {
        pointerEvents: "none"
      },
      [`${t}-mask`]: Object.assign(Object.assign({}, z2("fixed")), {
        zIndex: e.zIndexPopupBase,
        height: "100%",
        backgroundColor: e.colorBgMask,
        pointerEvents: "none",
        [`${t}-hidden`]: {
          display: "none"
        }
      }),
      [`${t}-wrap`]: Object.assign(Object.assign({}, z2("fixed")), {
        zIndex: e.zIndexPopupBase,
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      })
    }
  }, {
    [`${t}-root`]: E5(e)
  }];
}, Hne = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    // ======================== Root =========================
    {
      [`${t}-root`]: {
        [`${t}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${t}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [t]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${e.screenSMMax}px)`]: {
          [t]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${xe(e.marginXS)} auto`
          },
          [`${t}-centered`]: {
            [t]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [t]: Object.assign(Object.assign({}, Xs(e)), {
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${xe(e.calc(e.margin).mul(2).equal())})`,
        margin: "0 auto",
        paddingBottom: e.paddingLG,
        [`${t}-title`]: {
          margin: 0,
          color: e.titleColor,
          fontWeight: e.fontWeightStrong,
          fontSize: e.titleFontSize,
          lineHeight: e.titleLineHeight,
          wordWrap: "break-word"
        },
        [`${t}-content`]: {
          position: "relative",
          backgroundColor: e.contentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: e.borderRadiusLG,
          boxShadow: e.boxShadow,
          pointerEvents: "auto",
          padding: e.contentPadding
        },
        [`${t}-close`]: Object.assign({
          position: "absolute",
          top: e.calc(e.modalHeaderHeight).sub(e.modalCloseBtnSize).div(2).equal(),
          insetInlineEnd: e.calc(e.modalHeaderHeight).sub(e.modalCloseBtnSize).div(2).equal(),
          zIndex: e.calc(e.zIndexPopupBase).add(10).equal(),
          padding: 0,
          color: e.modalCloseIconColor,
          fontWeight: e.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: e.borderRadiusSM,
          width: e.modalCloseBtnSize,
          height: e.modalCloseBtnSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${e.motionDurationMid}, background-color ${e.motionDurationMid}`,
          "&-x": {
            display: "flex",
            fontSize: e.fontSizeLG,
            fontStyle: "normal",
            lineHeight: `${xe(e.modalCloseBtnSize)}`,
            justifyContent: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:hover": {
            color: e.modalCloseIconHoverColor,
            backgroundColor: e.colorBgTextHover,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: e.colorBgTextActive
          }
        }, nS(e)),
        [`${t}-header`]: {
          color: e.colorText,
          background: e.headerBg,
          borderRadius: `${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)} 0 0`,
          marginBottom: e.headerMarginBottom,
          padding: e.headerPadding,
          borderBottom: e.headerBorderBottom
        },
        [`${t}-body`]: {
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          wordWrap: "break-word",
          padding: e.bodyPadding,
          [`${t}-body-skeleton`]: {
            width: "100%",
            height: "100%",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            margin: `${xe(e.margin)} auto`
          }
        },
        [`${t}-footer`]: {
          textAlign: "end",
          background: e.footerBg,
          marginTop: e.footerMarginTop,
          padding: e.footerPadding,
          borderTop: e.footerBorderTop,
          borderRadius: e.footerBorderRadius,
          [`> ${e.antCls}-btn + ${e.antCls}-btn`]: {
            marginInlineStart: e.marginXS
          }
        },
        [`${t}-open`]: {
          overflow: "hidden"
        }
      })
    },
    // ======================== Pure =========================
    {
      [`${t}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${t}-content,
          ${t}-body,
          ${t}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${t}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
}, zne = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-root`]: {
      [`${t}-wrap-rtl`]: {
        direction: "rtl",
        [`${t}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
}, $ne = (e) => {
  const t = e.padding, r = e.fontSizeHeading5, n = e.lineHeightHeading5;
  return dn(e, {
    modalHeaderHeight: e.calc(e.calc(n).mul(r).equal()).add(e.calc(t).mul(2).equal()).equal(),
    modalFooterBorderColorSplit: e.colorSplit,
    modalFooterBorderStyle: e.lineType,
    modalFooterBorderWidth: e.lineWidth,
    modalCloseIconColor: e.colorIcon,
    modalCloseIconHoverColor: e.colorIconHover,
    modalCloseBtnSize: e.controlHeight,
    modalConfirmIconSize: e.fontHeight,
    modalTitleHeight: e.calc(e.titleFontSize).mul(e.titleLineHeight).equal()
  });
}, Wne = (e) => ({
  footerBg: "transparent",
  headerBg: e.colorBgElevated,
  titleLineHeight: e.lineHeightHeading5,
  titleFontSize: e.fontSizeHeading5,
  contentBg: e.colorBgElevated,
  titleColor: e.colorTextHeading,
  // internal
  contentPadding: e.wireframe ? 0 : `${xe(e.paddingMD)} ${xe(e.paddingContentHorizontalLG)}`,
  headerPadding: e.wireframe ? `${xe(e.padding)} ${xe(e.paddingLG)}` : 0,
  headerBorderBottom: e.wireframe ? `${xe(e.lineWidth)} ${e.lineType} ${e.colorSplit}` : "none",
  headerMarginBottom: e.wireframe ? 0 : e.marginXS,
  bodyPadding: e.wireframe ? e.paddingLG : 0,
  footerPadding: e.wireframe ? `${xe(e.paddingXS)} ${xe(e.padding)}` : 0,
  footerBorderTop: e.wireframe ? `${xe(e.lineWidth)} ${e.lineType} ${e.colorSplit}` : "none",
  footerBorderRadius: e.wireframe ? `0 0 ${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)}` : 0,
  footerMarginTop: e.wireframe ? 0 : e.marginSM,
  confirmBodyPadding: e.wireframe ? `${xe(e.padding * 2)} ${xe(e.padding * 2)} ${xe(e.paddingLG)}` : 0,
  confirmIconMarginInlineEnd: e.wireframe ? e.margin : e.marginSM,
  confirmBtnsMarginTop: e.wireframe ? e.marginLG : e.marginSM
});
Gi("Modal", (e) => {
  const t = $ne(e);
  return [Hne(t), zne(t), R5(t), uS(t, "zoom")];
}, Wne, {
  unitless: {
    titleLineHeight: !0
  }
});
const _5 = function() {
  if (typeof navigator > "u" || typeof window > "u")
    return !1;
  var e = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e == null ? void 0 : e.substr(0, 4));
};
var jne = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"], ud = void 0;
function Une(e, t) {
  var r = e.prefixCls, n = e.invalidate, i = e.item, o = e.renderItem, a = e.responsive, s = e.responsiveDisabled, l = e.registerSize, u = e.itemKey, c = e.className, d = e.style, h = e.children, f = e.display, p = e.order, g = e.component, v = g === void 0 ? "div" : g, m = zt(e, jne), y = a && !f;
  function C(E) {
    l(u, E);
  }
  T.useEffect(function() {
    return function() {
      C(null);
    };
  }, []);
  var S = o && i !== ud ? o(i) : h, b;
  n || (b = {
    opacity: y ? 0 : 1,
    height: y ? 0 : ud,
    overflowY: y ? "hidden" : ud,
    order: a ? p : ud,
    pointerEvents: y ? "none" : ud,
    position: y ? "absolute" : ud
  });
  var w = {};
  y && (w["aria-hidden"] = !0);
  var x = /* @__PURE__ */ T.createElement(v, ze({
    className: pe(!n && r, c),
    style: re(re({}, b), d)
  }, w, m, {
    ref: t
  }), S);
  return a && (x = /* @__PURE__ */ T.createElement(la, {
    onResize: function(R) {
      var _ = R.offsetWidth;
      C(_);
    },
    disabled: s
  }, x)), x;
}
var $p = /* @__PURE__ */ T.forwardRef(Une);
$p.displayName = "Item";
function Kne(e) {
  if (typeof MessageChannel > "u")
    cn(e);
  else {
    var t = new MessageChannel();
    t.port1.onmessage = function() {
      return e();
    }, t.port2.postMessage(void 0);
  }
}
function Yne() {
  var e = T.useRef(null), t = function(n) {
    e.current || (e.current = [], Kne(function() {
      aq(function() {
        e.current.forEach(function(i) {
          i();
        }), e.current = null;
      });
    })), e.current.push(n);
  };
  return t;
}
function kf(e, t) {
  var r = T.useState(t), n = ue(r, 2), i = n[0], o = n[1], a = Mn(function(s) {
    e(function() {
      o(s);
    });
  });
  return [i, a];
}
var M0 = /* @__PURE__ */ H.createContext(null), qne = ["component"], Zne = ["className"], Xne = ["className"], Qne = function(t, r) {
  var n = T.useContext(M0);
  if (!n) {
    var i = t.component, o = i === void 0 ? "div" : i, a = zt(t, qne);
    return /* @__PURE__ */ T.createElement(o, ze({}, a, {
      ref: r
    }));
  }
  var s = n.className, l = zt(n, Zne), u = t.className, c = zt(t, Xne);
  return /* @__PURE__ */ T.createElement(M0.Provider, {
    value: null
  }, /* @__PURE__ */ T.createElement($p, ze({
    ref: r,
    className: pe(s, u)
  }, l, c)));
}, T5 = /* @__PURE__ */ T.forwardRef(Qne);
T5.displayName = "RawItem";
var Jne = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"], P5 = "responsive", M5 = "invalidate";
function eie(e) {
  return "+ ".concat(e.length, " ...");
}
function tie(e, t) {
  var r = e.prefixCls, n = r === void 0 ? "rc-overflow" : r, i = e.data, o = i === void 0 ? [] : i, a = e.renderItem, s = e.renderRawItem, l = e.itemKey, u = e.itemWidth, c = u === void 0 ? 10 : u, d = e.ssr, h = e.style, f = e.className, p = e.maxCount, g = e.renderRest, v = e.renderRawRest, m = e.suffix, y = e.component, C = y === void 0 ? "div" : y, S = e.itemComponent, b = e.onVisibleChange, w = zt(e, Jne), x = d === "full", E = Yne(), R = kf(E, null), _ = ue(R, 2), P = _[0], D = _[1], I = P || 0, A = kf(E, /* @__PURE__ */ new Map()), O = ue(A, 2), L = O[0], N = O[1], F = kf(E, 0), G = ue(F, 2), M = G[0], V = G[1], z = kf(E, 0), k = ue(z, 2), $ = k[0], W = k[1], j = kf(E, 0), U = ue(j, 2), Z = U[0], ee = U[1], J = Ee(null), X = ue(J, 2), Y = X[0], de = X[1], K = Ee(null), ie = ue(K, 2), Ce = ie[0], Te = ie[1], Ie = T.useMemo(function() {
    return Ce === null && x ? Number.MAX_SAFE_INTEGER : Ce || 0;
  }, [Ce, P]), we = Ee(!1), Re = ue(we, 2), _e = Re[0], He = Re[1], Ve = "".concat(n, "-item"), $e = Math.max(M, $), Je = p === P5, Q = o.length && Je, ye = p === M5, Ge = Q || typeof p == "number" && o.length > p, Pe = ct(function() {
    var gt = o;
    return Q ? P === null && x ? gt = o : gt = o.slice(0, Math.min(o.length, I / c)) : typeof p == "number" && (gt = o.slice(0, p)), gt;
  }, [o, c, P, p, Q]), Le = ct(function() {
    return Q ? o.slice(Ie + 1) : o.slice(Pe.length);
  }, [o, Pe, Q, Ie]), me = Wt(function(gt, nt) {
    var Qt;
    return typeof l == "function" ? l(gt) : (Qt = l && (gt == null ? void 0 : gt[l])) !== null && Qt !== void 0 ? Qt : nt;
  }, [l]), De = Wt(a || function(gt) {
    return gt;
  }, [a]);
  function qe(gt, nt, Qt) {
    Ce === gt && (nt === void 0 || nt === Y) || (Te(gt), Qt || (He(gt < o.length - 1), b == null || b(gt)), nt !== void 0 && de(nt));
  }
  function ht(gt, nt) {
    D(nt.clientWidth);
  }
  function Tt(gt, nt) {
    N(function(Qt) {
      var kr = new Map(Qt);
      return nt === null ? kr.delete(gt) : kr.set(gt, nt), kr;
    });
  }
  function lt(gt, nt) {
    W(nt), V($);
  }
  function tt(gt, nt) {
    ee(nt);
  }
  function Oe(gt) {
    return L.get(me(Pe[gt], gt));
  }
  Wr(function() {
    if (I && typeof $e == "number" && Pe) {
      var gt = Z, nt = Pe.length, Qt = nt - 1;
      if (!nt) {
        qe(0, null);
        return;
      }
      for (var kr = 0; kr < nt; kr += 1) {
        var Kt = Oe(kr);
        if (x && (Kt = Kt || 0), Kt === void 0) {
          qe(kr - 1, void 0, !0);
          break;
        }
        if (gt += Kt, // Only one means `totalWidth` is the final width
        Qt === 0 && gt <= I || // Last two width will be the final width
        kr === Qt - 1 && gt + Oe(Qt) <= I) {
          qe(Qt, null);
          break;
        } else if (gt + $e > I) {
          qe(kr - 1, gt - Kt - Z + $);
          break;
        }
      }
      m && Oe(0) + Z > I && de(null);
    }
  }, [I, L, $, Z, me, Pe]);
  var je = _e && !!Le.length, pt = {};
  Y !== null && Q && (pt = {
    position: "absolute",
    left: Y,
    top: 0
  });
  var wt = {
    prefixCls: Ve,
    responsive: Q,
    component: S,
    invalidate: ye
  }, $r = s ? function(gt, nt) {
    var Qt = me(gt, nt);
    return /* @__PURE__ */ T.createElement(M0.Provider, {
      key: Qt,
      value: re(re({}, wt), {}, {
        order: nt,
        item: gt,
        itemKey: Qt,
        registerSize: Tt,
        display: nt <= Ie
      })
    }, s(gt, nt));
  } : function(gt, nt) {
    var Qt = me(gt, nt);
    return /* @__PURE__ */ T.createElement($p, ze({}, wt, {
      order: nt,
      key: Qt,
      item: gt,
      renderItem: De,
      itemKey: Qt,
      registerSize: Tt,
      display: nt <= Ie
    }));
  }, xr, Ut = {
    order: je ? Ie : Number.MAX_SAFE_INTEGER,
    className: "".concat(Ve, "-rest"),
    registerSize: lt,
    display: je
  };
  if (v)
    v && (xr = /* @__PURE__ */ T.createElement(M0.Provider, {
      value: re(re({}, wt), Ut)
    }, v(Le)));
  else {
    var Ht = g || eie;
    xr = /* @__PURE__ */ T.createElement($p, ze({}, wt, Ut), typeof Ht == "function" ? Ht(Le) : Ht);
  }
  var Lt = /* @__PURE__ */ T.createElement(C, ze({
    className: pe(!ye && n, f),
    style: h,
    ref: t
  }, w), Pe.map($r), Ge ? xr : null, m && /* @__PURE__ */ T.createElement($p, ze({}, wt, {
    responsive: Je,
    responsiveDisabled: !Q,
    order: Ie,
    className: "".concat(Ve, "-suffix"),
    registerSize: tt,
    display: !0,
    style: pt
  }), m));
  return Je && (Lt = /* @__PURE__ */ T.createElement(la, {
    onResize: ht,
    disabled: !Q
  }, Lt)), Lt;
}
var Ds = /* @__PURE__ */ T.forwardRef(tie);
Ds.displayName = "Overflow";
Ds.Item = T5;
Ds.RESPONSIVE = P5;
Ds.INVALIDATE = M5;
function rie(e) {
  var t = e.prefixCls, r = e.align, n = e.arrow, i = e.arrowPos, o = n || {}, a = o.className, s = o.content, l = i.x, u = l === void 0 ? 0 : l, c = i.y, d = c === void 0 ? 0 : c, h = T.useRef();
  if (!r || !r.points)
    return null;
  var f = {
    position: "absolute"
  };
  if (r.autoArrow !== !1) {
    var p = r.points[0], g = r.points[1], v = p[0], m = p[1], y = g[0], C = g[1];
    v === y || !["t", "b"].includes(v) ? f.top = d : v === "t" ? f.top = 0 : f.bottom = 0, m === C || !["l", "r"].includes(m) ? f.left = u : m === "l" ? f.left = 0 : f.right = 0;
  }
  return /* @__PURE__ */ T.createElement("div", {
    ref: h,
    className: pe("".concat(t, "-arrow"), a),
    style: f
  }, s);
}
function nie(e) {
  var t = e.prefixCls, r = e.open, n = e.zIndex, i = e.mask, o = e.motion;
  return i ? /* @__PURE__ */ T.createElement(ns, ze({}, o, {
    motionAppear: !0,
    visible: r,
    removeOnLeave: !0
  }), function(a) {
    var s = a.className;
    return /* @__PURE__ */ T.createElement("div", {
      style: {
        zIndex: n
      },
      className: pe("".concat(t, "-mask"), s)
    });
  }) : null;
}
var D5 = /* @__PURE__ */ T.memo(function(e) {
  var t = e.children;
  return t;
}, function(e, t) {
  return t.cache;
});
process.env.NODE_ENV !== "production" && (D5.displayName = "PopupContent");
var A5 = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.popup, n = e.className, i = e.prefixCls, o = e.style, a = e.target, s = e.onVisibleChanged, l = e.open, u = e.keepDom, c = e.fresh, d = e.onClick, h = e.mask, f = e.arrow, p = e.arrowPos, g = e.align, v = e.motion, m = e.maskMotion, y = e.forceRender, C = e.getPopupContainer, S = e.autoDestroy, b = e.portal, w = e.zIndex, x = e.onMouseEnter, E = e.onMouseLeave, R = e.onPointerEnter, _ = e.ready, P = e.offsetX, D = e.offsetY, I = e.offsetR, A = e.offsetB, O = e.onAlign, L = e.onPrepare, N = e.stretch, F = e.targetWidth, G = e.targetHeight, M = typeof r == "function" ? r() : r, V = l || u, z = (C == null ? void 0 : C.length) > 0, k = T.useState(!C || !z), $ = ue(k, 2), W = $[0], j = $[1];
  if (Wr(function() {
    !W && z && a && j(!0);
  }, [W, z, a]), !W)
    return null;
  var U = "auto", Z = {
    left: "-1000vw",
    top: "-1000vh",
    right: U,
    bottom: U
  };
  if (_ || !l) {
    var ee, J = g.points, X = g.dynamicInset || ((ee = g._experimental) === null || ee === void 0 ? void 0 : ee.dynamicInset), Y = X && J[0][1] === "r", de = X && J[0][0] === "b";
    Y ? (Z.right = I, Z.left = U) : (Z.left = P, Z.right = U), de ? (Z.bottom = A, Z.top = U) : (Z.top = D, Z.bottom = U);
  }
  var K = {};
  return N && (N.includes("height") && G ? K.height = G : N.includes("minHeight") && G && (K.minHeight = G), N.includes("width") && F ? K.width = F : N.includes("minWidth") && F && (K.minWidth = F)), l || (K.pointerEvents = "none"), /* @__PURE__ */ T.createElement(b, {
    open: y || V,
    getContainer: C && function() {
      return C(a);
    },
    autoDestroy: S
  }, /* @__PURE__ */ T.createElement(nie, {
    prefixCls: i,
    open: l,
    zIndex: w,
    mask: h,
    motion: m
  }), /* @__PURE__ */ T.createElement(la, {
    onResize: O,
    disabled: !l
  }, function(ie) {
    return /* @__PURE__ */ T.createElement(ns, ze({
      motionAppear: !0,
      motionEnter: !0,
      motionLeave: !0,
      removeOnLeave: !1,
      forceRender: y,
      leavedClassName: "".concat(i, "-hidden")
    }, v, {
      onAppearPrepare: L,
      onEnterPrepare: L,
      visible: l,
      onVisibleChanged: function(Te) {
        var Ie;
        v == null || (Ie = v.onVisibleChanged) === null || Ie === void 0 || Ie.call(v, Te), s(Te);
      }
    }), function(Ce, Te) {
      var Ie = Ce.className, we = Ce.style, Re = pe(i, Ie, n);
      return /* @__PURE__ */ T.createElement("div", {
        ref: Vo(ie, t, Te),
        className: Re,
        style: re(re(re(re({
          "--arrow-x": "".concat(p.x || 0, "px"),
          "--arrow-y": "".concat(p.y || 0, "px")
        }, Z), K), we), {}, {
          boxSizing: "border-box",
          zIndex: w
        }, o),
        onMouseEnter: x,
        onMouseLeave: E,
        onPointerEnter: R,
        onClick: d
      }, f && /* @__PURE__ */ T.createElement(rie, {
        prefixCls: i,
        arrow: f,
        arrowPos: p,
        align: g
      }), /* @__PURE__ */ T.createElement(D5, {
        cache: !l && !c
      }, M));
    });
  }));
});
process.env.NODE_ENV !== "production" && (A5.displayName = "Popup");
var I5 = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.children, n = e.getTriggerDOMNode, i = kc(r), o = T.useCallback(function(s) {
    GT(t, n ? n(s) : s);
  }, [n]), a = Kh(o, r.ref);
  return i ? /* @__PURE__ */ T.cloneElement(r, {
    ref: a
  }) : r;
});
process.env.NODE_ENV !== "production" && (I5.displayName = "TriggerWrapper");
var $2 = /* @__PURE__ */ T.createContext(null);
function W2(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
function iie(e, t, r, n) {
  return T.useMemo(function() {
    var i = W2(r ?? t), o = W2(n ?? t), a = new Set(i), s = new Set(o);
    return e && (a.has("hover") && (a.delete("hover"), a.add("click")), s.has("hover") && (s.delete("hover"), s.add("click"))), [a, s];
  }, [e, t, r, n]);
}
function oie() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], r = arguments.length > 2 ? arguments[2] : void 0;
  return r ? e[0] === t[0] : e[0] === t[0] && e[1] === t[1];
}
function aie(e, t, r, n) {
  for (var i = r.points, o = Object.keys(e), a = 0; a < o.length; a += 1) {
    var s, l = o[a];
    if (oie((s = e[l]) === null || s === void 0 ? void 0 : s.points, i, n))
      return "".concat(t, "-placement-").concat(l);
  }
  return "";
}
function j2(e, t, r, n) {
  return t || (r ? {
    motionName: "".concat(e, "-").concat(r)
  } : n ? {
    motionName: n
  } : null);
}
function fv(e) {
  return e.ownerDocument.defaultView;
}
function tR(e) {
  for (var t = [], r = e == null ? void 0 : e.parentElement, n = ["hidden", "scroll", "clip", "auto"]; r; ) {
    var i = fv(r).getComputedStyle(r), o = i.overflowX, a = i.overflowY, s = i.overflow;
    [o, a, s].some(function(l) {
      return n.includes(l);
    }) && t.push(r), r = r.parentElement;
  }
  return t;
}
function Rg(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  return Number.isNaN(e) ? t : e;
}
function Vf(e) {
  return Rg(parseFloat(e), 0);
}
function U2(e, t) {
  var r = re({}, e);
  return (t || []).forEach(function(n) {
    if (!(n instanceof HTMLBodyElement || n instanceof HTMLHtmlElement)) {
      var i = fv(n).getComputedStyle(n), o = i.overflow, a = i.overflowClipMargin, s = i.borderTopWidth, l = i.borderBottomWidth, u = i.borderLeftWidth, c = i.borderRightWidth, d = n.getBoundingClientRect(), h = n.offsetHeight, f = n.clientHeight, p = n.offsetWidth, g = n.clientWidth, v = Vf(s), m = Vf(l), y = Vf(u), C = Vf(c), S = Rg(Math.round(d.width / p * 1e3) / 1e3), b = Rg(Math.round(d.height / h * 1e3) / 1e3), w = (p - g - y - C) * S, x = (h - f - v - m) * b, E = v * b, R = m * b, _ = y * S, P = C * S, D = 0, I = 0;
      if (o === "clip") {
        var A = Vf(a);
        D = A * S, I = A * b;
      }
      var O = d.x + _ - D, L = d.y + E - I, N = O + d.width + 2 * D - _ - P - w, F = L + d.height + 2 * I - E - R - x;
      r.left = Math.max(r.left, O), r.top = Math.max(r.top, L), r.right = Math.min(r.right, N), r.bottom = Math.min(r.bottom, F);
    }
  }), r;
}
function K2(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, r = "".concat(t), n = r.match(/^(.*)\%$/);
  return n ? e * (parseFloat(n[1]) / 100) : parseFloat(r);
}
function Y2(e, t) {
  var r = t || [], n = ue(r, 2), i = n[0], o = n[1];
  return [K2(e.width, i), K2(e.height, o)];
}
function q2() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  return [e[0], e[1]];
}
function cd(e, t) {
  var r = t[0], n = t[1], i, o;
  return r === "t" ? o = e.y : r === "b" ? o = e.y + e.height : o = e.y + e.height / 2, n === "l" ? i = e.x : n === "r" ? i = e.x + e.width : i = e.x + e.width / 2, {
    x: i,
    y: o
  };
}
function al(e, t) {
  var r = {
    t: "b",
    b: "t",
    l: "r",
    r: "l"
  };
  return e.map(function(n, i) {
    return i === t ? r[n] || "c" : n;
  }).join("");
}
function sie(e, t, r, n, i, o, a) {
  var s = T.useState({
    ready: !1,
    offsetX: 0,
    offsetY: 0,
    offsetR: 0,
    offsetB: 0,
    arrowX: 0,
    arrowY: 0,
    scaleX: 1,
    scaleY: 1,
    align: i[n] || {}
  }), l = ue(s, 2), u = l[0], c = l[1], d = T.useRef(0), h = T.useMemo(function() {
    return t ? tR(t) : [];
  }, [t]), f = T.useRef({}), p = function() {
    f.current = {};
  };
  e || p();
  var g = Mn(function() {
    if (t && r && e) {
      let ai = function(si, Ko) {
        var ol = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Re, od = M.x + si, Af = M.y + Ko, If = od + ee, Xv = Af + Z, Sw = Math.max(od, ol.left), ww = Math.max(Af, ol.top), bw = Math.min(If, ol.right), xw = Math.min(Xv, ol.bottom);
        return Math.max(0, (bw - Sw) * (xw - ww));
      }, uu = function() {
        q = M.y + Ht, ve = q + Z, be = M.x + Ut, Ke = be + ee;
      };
      var y, C, S = t, b = S.ownerDocument, w = fv(S), x = w.getComputedStyle(S), E = x.width, R = x.height, _ = x.position, P = S.style.left, D = S.style.top, I = S.style.right, A = S.style.bottom, O = S.style.overflow, L = re(re({}, i[n]), o), N = b.createElement("div");
      (y = S.parentElement) === null || y === void 0 || y.appendChild(N), N.style.left = "".concat(S.offsetLeft, "px"), N.style.top = "".concat(S.offsetTop, "px"), N.style.position = _, N.style.height = "".concat(S.offsetHeight, "px"), N.style.width = "".concat(S.offsetWidth, "px"), S.style.left = "0", S.style.top = "0", S.style.right = "auto", S.style.bottom = "auto", S.style.overflow = "hidden";
      var F;
      if (Array.isArray(r))
        F = {
          x: r[0],
          y: r[1],
          width: 0,
          height: 0
        };
      else {
        var G = r.getBoundingClientRect();
        F = {
          x: G.x,
          y: G.y,
          width: G.width,
          height: G.height
        };
      }
      var M = S.getBoundingClientRect(), V = b.documentElement, z = V.clientWidth, k = V.clientHeight, $ = V.scrollWidth, W = V.scrollHeight, j = V.scrollTop, U = V.scrollLeft, Z = M.height, ee = M.width, J = F.height, X = F.width, Y = {
        left: 0,
        top: 0,
        right: z,
        bottom: k
      }, de = {
        left: -U,
        top: -j,
        right: $ - U,
        bottom: W - j
      }, K = L.htmlRegion, ie = "visible", Ce = "visibleFirst";
      K !== "scroll" && K !== Ce && (K = ie);
      var Te = K === Ce, Ie = U2(de, h), we = U2(Y, h), Re = K === ie ? we : Ie, _e = Te ? we : Re;
      S.style.left = "auto", S.style.top = "auto", S.style.right = "0", S.style.bottom = "0";
      var He = S.getBoundingClientRect();
      S.style.left = P, S.style.top = D, S.style.right = I, S.style.bottom = A, S.style.overflow = O, (C = S.parentElement) === null || C === void 0 || C.removeChild(N);
      var Ve = Rg(Math.round(ee / parseFloat(E) * 1e3) / 1e3), $e = Rg(Math.round(Z / parseFloat(R) * 1e3) / 1e3);
      if (Ve === 0 || $e === 0 || pg(r) && !nP(r))
        return;
      var Je = L.offset, Q = L.targetOffset, ye = Y2(M, Je), Ge = ue(ye, 2), Pe = Ge[0], Le = Ge[1], me = Y2(F, Q), De = ue(me, 2), qe = De[0], ht = De[1];
      F.x -= qe, F.y -= ht;
      var Tt = L.points || [], lt = ue(Tt, 2), tt = lt[0], Oe = lt[1], je = q2(Oe), pt = q2(tt), wt = cd(F, je), $r = cd(M, pt), xr = re({}, L), Ut = wt.x - $r.x + Pe, Ht = wt.y - $r.y + Le, Lt = ai(Ut, Ht), gt = ai(Ut, Ht, we), nt = cd(F, ["t", "l"]), Qt = cd(M, ["t", "l"]), kr = cd(F, ["b", "r"]), Kt = cd(M, ["b", "r"]), Yt = L.overflow || {}, vr = Yt.adjustX, Br = Yt.adjustY, yn = Yt.shiftX, $n = Yt.shiftY, ni = function(Ko) {
        return typeof Ko == "boolean" ? Ko : Ko >= 0;
      }, q, ve, be, Ke;
      uu();
      var vt = ni(Br), ut = pt[0] === je[0];
      if (vt && pt[0] === "t" && (ve > _e.bottom || f.current.bt)) {
        var mt = Ht;
        ut ? mt -= Z - J : mt = nt.y - Kt.y - Le;
        var Pt = ai(Ut, mt), Dr = ai(Ut, mt, we);
        // Of course use larger one
        Pt > Lt || Pt === Lt && (!Te || // Choose recommend one
        Dr >= gt) ? (f.current.bt = !0, Ht = mt, Le = -Le, xr.points = [al(pt, 0), al(je, 0)]) : f.current.bt = !1;
      }
      if (vt && pt[0] === "b" && (q < _e.top || f.current.tb)) {
        var or = Ht;
        ut ? or += Z - J : or = kr.y - Qt.y - Le;
        var Ot = ai(Ut, or), nn = ai(Ut, or, we);
        // Of course use larger one
        Ot > Lt || Ot === Lt && (!Te || // Choose recommend one
        nn >= gt) ? (f.current.tb = !0, Ht = or, Le = -Le, xr.points = [al(pt, 0), al(je, 0)]) : f.current.tb = !1;
      }
      var ii = ni(vr), Wn = pt[1] === je[1];
      if (ii && pt[1] === "l" && (Ke > _e.right || f.current.rl)) {
        var Ir = Ut;
        Wn ? Ir -= ee - X : Ir = nt.x - Kt.x - Pe;
        var ba = ai(Ir, Ht), rl = ai(Ir, Ht, we);
        // Of course use larger one
        ba > Lt || ba === Lt && (!Te || // Choose recommend one
        rl >= gt) ? (f.current.rl = !0, Ut = Ir, Pe = -Pe, xr.points = [al(pt, 1), al(je, 1)]) : f.current.rl = !1;
      }
      if (ii && pt[1] === "r" && (be < _e.left || f.current.lr)) {
        var oi = Ut;
        Wn ? oi += ee - X : oi = kr.x - Qt.x - Pe;
        var nl = ai(oi, Ht), _f = ai(oi, Ht, we);
        // Of course use larger one
        nl > Lt || nl === Lt && (!Te || // Choose recommend one
        _f >= gt) ? (f.current.lr = !0, Ut = oi, Pe = -Pe, xr.points = [al(pt, 1), al(je, 1)]) : f.current.lr = !1;
      }
      uu();
      var ao = yn === !0 ? 0 : yn;
      typeof ao == "number" && (be < we.left && (Ut -= be - we.left - Pe, F.x + X < we.left + ao && (Ut += F.x - we.left + X - ao)), Ke > we.right && (Ut -= Ke - we.right - Pe, F.x > we.right - ao && (Ut += F.x - we.right + ao)));
      var jo = $n === !0 ? 0 : $n;
      typeof jo == "number" && (q < we.top && (Ht -= q - we.top - Le, F.y + J < we.top + jo && (Ht += F.y - we.top + J - jo)), ve > we.bottom && (Ht -= ve - we.bottom - Le, F.y > we.bottom - jo && (Ht += F.y - we.bottom + jo)));
      var il = M.x + Ut, ls = il + ee, xa = M.y + Ht, us = xa + Z, lu = F.x, cs = lu + X, Uo = F.y, Tf = Uo + J, Pf = Math.max(il, lu), Mf = Math.min(ls, cs), id = (Pf + Mf) / 2, Fr = id - il, lr = Math.max(xa, Uo), _r = Math.min(us, Tf), Tn = (lr + _r) / 2, Fn = Tn - xa;
      a == null || a(t, xr);
      var Ea = He.right - M.x - (Ut + M.width), Ra = He.bottom - M.y - (Ht + M.height);
      Ve === 1 && (Ut = Math.round(Ut), Ea = Math.round(Ea)), $e === 1 && (Ht = Math.round(Ht), Ra = Math.round(Ra));
      var Df = {
        ready: !0,
        offsetX: Ut / Ve,
        offsetY: Ht / $e,
        offsetR: Ea / Ve,
        offsetB: Ra / $e,
        arrowX: Fr / Ve,
        arrowY: Fn / $e,
        scaleX: Ve,
        scaleY: $e,
        align: xr
      };
      c(Df);
    }
  }), v = function() {
    d.current += 1;
    var C = d.current;
    Promise.resolve().then(function() {
      d.current === C && g();
    });
  }, m = function() {
    c(function(C) {
      return re(re({}, C), {}, {
        ready: !1
      });
    });
  };
  return Wr(m, [n]), Wr(function() {
    e || m();
  }, [e]), [u.ready, u.offsetX, u.offsetY, u.offsetR, u.offsetB, u.arrowX, u.arrowY, u.scaleX, u.scaleY, u.align, v];
}
function lie(e, t, r, n, i) {
  Wr(function() {
    if (e && t && r) {
      let d = function() {
        n(), i();
      };
      var o = t, a = r, s = tR(o), l = tR(a), u = fv(a), c = new Set([u].concat(rt(s), rt(l)));
      return c.forEach(function(h) {
        h.addEventListener("scroll", d, {
          passive: !0
        });
      }), u.addEventListener("resize", d, {
        passive: !0
      }), n(), function() {
        c.forEach(function(h) {
          h.removeEventListener("scroll", d), u.removeEventListener("resize", d);
        });
      };
    }
  }, [e, t, r]);
}
function uie(e, t, r, n, i, o, a, s) {
  var l = T.useRef(e);
  l.current = e, T.useEffect(function() {
    if (t && n && (!i || o)) {
      var u = function(m) {
        var y = m.target;
        l.current && !a(y) && s(!1);
      }, c = fv(n);
      c.addEventListener("mousedown", u, !0), c.addEventListener("contextmenu", u, !0);
      var d = R0(r);
      if (d && (d.addEventListener("mousedown", u, !0), d.addEventListener("contextmenu", u, !0)), process.env.NODE_ENV !== "production") {
        var h, f, p = r == null || (h = r.getRootNode) === null || h === void 0 ? void 0 : h.call(r), g = (f = n.getRootNode) === null || f === void 0 ? void 0 : f.call(n);
        Ns(p === g, "trigger element and popup element should in same shadow root.");
      }
      return function() {
        c.removeEventListener("mousedown", u, !0), c.removeEventListener("contextmenu", u, !0), d && (d.removeEventListener("mousedown", u, !0), d.removeEventListener("contextmenu", u, !0));
      };
    }
  }, [t, r, n, i, o]);
}
var cie = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "fresh", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
function die() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : cv, t = /* @__PURE__ */ T.forwardRef(function(r, n) {
    var i = r.prefixCls, o = i === void 0 ? "rc-trigger-popup" : i, a = r.children, s = r.action, l = s === void 0 ? "hover" : s, u = r.showAction, c = r.hideAction, d = r.popupVisible, h = r.defaultPopupVisible, f = r.onPopupVisibleChange, p = r.afterPopupVisibleChange, g = r.mouseEnterDelay, v = r.mouseLeaveDelay, m = v === void 0 ? 0.1 : v, y = r.focusDelay, C = r.blurDelay, S = r.mask, b = r.maskClosable, w = b === void 0 ? !0 : b, x = r.getPopupContainer, E = r.forceRender, R = r.autoDestroy, _ = r.destroyPopupOnHide, P = r.popup, D = r.popupClassName, I = r.popupStyle, A = r.popupPlacement, O = r.builtinPlacements, L = O === void 0 ? {} : O, N = r.popupAlign, F = r.zIndex, G = r.stretch, M = r.getPopupClassNameFromAlign, V = r.fresh, z = r.alignPoint, k = r.onPopupClick, $ = r.onPopupAlign, W = r.arrow, j = r.popupMotion, U = r.maskMotion, Z = r.popupTransitionName, ee = r.popupAnimation, J = r.maskTransitionName, X = r.maskAnimation, Y = r.className, de = r.getTriggerDOMNode, K = zt(r, cie), ie = R || _ || !1, Ce = T.useState(!1), Te = ue(Ce, 2), Ie = Te[0], we = Te[1];
    Wr(function() {
      we(_5());
    }, []);
    var Re = T.useRef({}), _e = T.useContext($2), He = T.useMemo(function() {
      return {
        registerSubPopup: function(Ft, Zr) {
          Re.current[Ft] = Zr, _e == null || _e.registerSubPopup(Ft, Zr);
        }
      };
    }, [_e]), Ve = d5(), $e = T.useState(null), Je = ue($e, 2), Q = Je[0], ye = Je[1], Ge = T.useRef(null), Pe = Mn(function(at) {
      Ge.current = at, pg(at) && Q !== at && ye(at), _e == null || _e.registerSubPopup(Ve, at);
    }), Le = T.useState(null), me = ue(Le, 2), De = me[0], qe = me[1], ht = T.useRef(null), Tt = Mn(function(at) {
      pg(at) && De !== at && (qe(at), ht.current = at);
    }), lt = T.Children.only(a), tt = (lt == null ? void 0 : lt.props) || {}, Oe = {}, je = Mn(function(at) {
      var Ft, Zr, Cn = De;
      return (Cn == null ? void 0 : Cn.contains(at)) || ((Ft = R0(Cn)) === null || Ft === void 0 ? void 0 : Ft.host) === at || at === Cn || (Q == null ? void 0 : Q.contains(at)) || ((Zr = R0(Q)) === null || Zr === void 0 ? void 0 : Zr.host) === at || at === Q || Object.values(Re.current).some(function(Xr) {
        return (Xr == null ? void 0 : Xr.contains(at)) || at === Xr;
      });
    }), pt = j2(o, j, ee, Z), wt = j2(o, U, X, J), $r = T.useState(h || !1), xr = ue($r, 2), Ut = xr[0], Ht = xr[1], Lt = d ?? Ut, gt = Mn(function(at) {
      d === void 0 && Ht(at);
    });
    Wr(function() {
      Ht(d || !1);
    }, [d]);
    var nt = T.useRef(Lt);
    nt.current = Lt;
    var Qt = T.useRef([]);
    Qt.current = [];
    var kr = Mn(function(at) {
      var Ft;
      gt(at), ((Ft = Qt.current[Qt.current.length - 1]) !== null && Ft !== void 0 ? Ft : Lt) !== at && (Qt.current.push(at), f == null || f(at));
    }), Kt = T.useRef(), Yt = function() {
      clearTimeout(Kt.current);
    }, vr = function(Ft) {
      var Zr = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      Yt(), Zr === 0 ? kr(Ft) : Kt.current = setTimeout(function() {
        kr(Ft);
      }, Zr * 1e3);
    };
    T.useEffect(function() {
      return Yt;
    }, []);
    var Br = T.useState(!1), yn = ue(Br, 2), $n = yn[0], ni = yn[1];
    Wr(function(at) {
      (!at || Lt) && ni(!0);
    }, [Lt]);
    var q = T.useState(null), ve = ue(q, 2), be = ve[0], Ke = ve[1], vt = T.useState([0, 0]), ut = ue(vt, 2), mt = ut[0], Pt = ut[1], Dr = function(Ft) {
      Pt([Ft.clientX, Ft.clientY]);
    }, or = sie(Lt, Q, z ? mt : De, A, L, N, $), Ot = ue(or, 11), nn = Ot[0], ii = Ot[1], Wn = Ot[2], Ir = Ot[3], ba = Ot[4], rl = Ot[5], oi = Ot[6], nl = Ot[7], _f = Ot[8], ao = Ot[9], jo = Ot[10], il = iie(Ie, l, u, c), ls = ue(il, 2), xa = ls[0], us = ls[1], lu = xa.has("click"), cs = us.has("click") || us.has("contextMenu"), Uo = Mn(function() {
      $n || jo();
    }), Tf = function() {
      nt.current && z && cs && vr(!1);
    };
    lie(Lt, De, Q, Uo, Tf), Wr(function() {
      Uo();
    }, [mt, A]), Wr(function() {
      Lt && !(L != null && L[A]) && Uo();
    }, [JSON.stringify(N)]);
    var Pf = T.useMemo(function() {
      var at = aie(L, o, ao, z);
      return pe(at, M == null ? void 0 : M(ao));
    }, [ao, M, L, o, z]);
    T.useImperativeHandle(n, function() {
      return {
        nativeElement: ht.current,
        popupElement: Ge.current,
        forceAlign: Uo
      };
    });
    var Mf = T.useState(0), id = ue(Mf, 2), Fr = id[0], lr = id[1], _r = T.useState(0), Tn = ue(_r, 2), Fn = Tn[0], Ea = Tn[1], Ra = function() {
      if (G && De) {
        var Ft = De.getBoundingClientRect();
        lr(Ft.width), Ea(Ft.height);
      }
    }, Df = function() {
      Ra(), Uo();
    }, ai = function(Ft) {
      ni(!1), jo(), p == null || p(Ft);
    }, uu = function() {
      return new Promise(function(Ft) {
        Ra(), Ke(function() {
          return Ft;
        });
      });
    };
    Wr(function() {
      be && (jo(), be(), Ke(null));
    }, [be]);
    function si(at, Ft, Zr, Cn) {
      Oe[at] = function(Xr) {
        var Qv;
        Cn == null || Cn(Xr), vr(Ft, Zr);
        for (var Ew = arguments.length, XA = new Array(Ew > 1 ? Ew - 1 : 0), Jv = 1; Jv < Ew; Jv++)
          XA[Jv - 1] = arguments[Jv];
        (Qv = tt[at]) === null || Qv === void 0 || Qv.call.apply(Qv, [tt, Xr].concat(XA));
      };
    }
    (lu || cs) && (Oe.onClick = function(at) {
      var Ft;
      nt.current && cs ? vr(!1) : !nt.current && lu && (Dr(at), vr(!0));
      for (var Zr = arguments.length, Cn = new Array(Zr > 1 ? Zr - 1 : 0), Xr = 1; Xr < Zr; Xr++)
        Cn[Xr - 1] = arguments[Xr];
      (Ft = tt.onClick) === null || Ft === void 0 || Ft.call.apply(Ft, [tt, at].concat(Cn));
    }), uie(Lt, cs, De, Q, S, w, je, vr);
    var Ko = xa.has("hover"), ol = us.has("hover"), od, Af;
    Ko && (si("onMouseEnter", !0, g, function(at) {
      Dr(at);
    }), si("onPointerEnter", !0, g, function(at) {
      Dr(at);
    }), od = function(Ft) {
      (Lt || $n) && Q !== null && Q !== void 0 && Q.contains(Ft.target) && vr(!0, g);
    }, z && (Oe.onMouseMove = function(at) {
      var Ft;
      (Ft = tt.onMouseMove) === null || Ft === void 0 || Ft.call(tt, at);
    })), ol && (si("onMouseLeave", !1, m), si("onPointerLeave", !1, m), Af = function() {
      vr(!1, m);
    }), xa.has("focus") && si("onFocus", !0, y), us.has("focus") && si("onBlur", !1, C), xa.has("contextMenu") && (Oe.onContextMenu = function(at) {
      var Ft;
      nt.current && us.has("contextMenu") ? vr(!1) : (Dr(at), vr(!0)), at.preventDefault();
      for (var Zr = arguments.length, Cn = new Array(Zr > 1 ? Zr - 1 : 0), Xr = 1; Xr < Zr; Xr++)
        Cn[Xr - 1] = arguments[Xr];
      (Ft = tt.onContextMenu) === null || Ft === void 0 || Ft.call.apply(Ft, [tt, at].concat(Cn));
    }), Y && (Oe.className = pe(tt.className, Y));
    var If = re(re({}, tt), Oe), Xv = {}, Sw = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
    Sw.forEach(function(at) {
      K[at] && (Xv[at] = function() {
        for (var Ft, Zr = arguments.length, Cn = new Array(Zr), Xr = 0; Xr < Zr; Xr++)
          Cn[Xr] = arguments[Xr];
        (Ft = If[at]) === null || Ft === void 0 || Ft.call.apply(Ft, [If].concat(Cn)), K[at].apply(K, Cn);
      });
    });
    var ww = /* @__PURE__ */ T.cloneElement(lt, re(re({}, If), Xv)), bw = {
      x: rl,
      y: oi
    }, xw = W ? re({}, W !== !0 ? W : {}) : null;
    return /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(la, {
      disabled: !Lt,
      ref: Tt,
      onResize: Df
    }, /* @__PURE__ */ T.createElement(I5, {
      getTriggerDOMNode: de
    }, ww)), /* @__PURE__ */ T.createElement($2.Provider, {
      value: He
    }, /* @__PURE__ */ T.createElement(A5, {
      portal: e,
      ref: Pe,
      prefixCls: o,
      popup: P,
      className: pe(D, Pf),
      style: I,
      target: De,
      onMouseEnter: od,
      onMouseLeave: Af,
      onPointerEnter: od,
      zIndex: F,
      open: Lt,
      keepDom: $n,
      fresh: V,
      onClick: k,
      mask: S,
      motion: pt,
      maskMotion: wt,
      onVisibleChanged: ai,
      onPrepare: uu,
      forceRender: E,
      autoDestroy: ie,
      getPopupContainer: x,
      align: ao,
      arrow: xw,
      arrowPos: bw,
      ready: nn,
      offsetX: ii,
      offsetY: Wn,
      offsetR: Ir,
      offsetB: ba,
      onAlign: Uo,
      stretch: G,
      targetWidth: Fr / nl,
      targetHeight: Fn / _f
    })));
  });
  return process.env.NODE_ENV !== "production" && (t.displayName = "Trigger"), t;
}
const cP = die(cv);
function rR(e, t, r) {
  return pe({
    [`${e}-status-success`]: t === "success",
    [`${e}-status-warning`]: t === "warning",
    [`${e}-status-error`]: t === "error",
    [`${e}-status-validating`]: t === "validating",
    [`${e}-has-feedback`]: r
  });
}
const dP = (e, t) => t || e, F5 = function(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
  var n, i;
  const {
    variant: o,
    [e]: a
  } = rr(Xt), s = rr(jre), l = a == null ? void 0 : a.variant;
  let u;
  typeof t < "u" ? u = t : r === !1 ? u = "borderless" : u = (i = (n = s ?? l) !== null && n !== void 0 ? n : o) !== null && i !== void 0 ? i : "outlined";
  const c = fJ.includes(u);
  return [u, c];
};
var hie = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" }, fie = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: hie
  }));
}, L5 = /* @__PURE__ */ T.forwardRef(fie);
process.env.NODE_ENV !== "production" && (L5.displayName = "CheckOutlined");
var pie = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" }, gie = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: pie
  }));
}, O5 = /* @__PURE__ */ T.forwardRef(gie);
process.env.NODE_ENV !== "production" && (O5.displayName = "SearchOutlined");
const Dh = (e) => e ? typeof e == "function" ? e() : e : null;
function hP(e) {
  var t = e.children, r = e.prefixCls, n = e.id, i = e.overlayInnerStyle, o = e.className, a = e.style;
  return /* @__PURE__ */ T.createElement("div", {
    className: pe("".concat(r, "-content"), o),
    style: a
  }, /* @__PURE__ */ T.createElement("div", {
    className: "".concat(r, "-inner"),
    id: n,
    role: "tooltip",
    style: i
  }, typeof t == "function" ? t() : t));
}
var dd = {
  shiftX: 64,
  adjustY: 1
}, hd = {
  adjustX: 1,
  shiftY: !0
}, lo = [0, 0], vie = {
  left: {
    points: ["cr", "cl"],
    overflow: hd,
    offset: [-4, 0],
    targetOffset: lo
  },
  right: {
    points: ["cl", "cr"],
    overflow: hd,
    offset: [4, 0],
    targetOffset: lo
  },
  top: {
    points: ["bc", "tc"],
    overflow: dd,
    offset: [0, -4],
    targetOffset: lo
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: dd,
    offset: [0, 4],
    targetOffset: lo
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: dd,
    offset: [0, -4],
    targetOffset: lo
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: hd,
    offset: [-4, 0],
    targetOffset: lo
  },
  topRight: {
    points: ["br", "tr"],
    overflow: dd,
    offset: [0, -4],
    targetOffset: lo
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: hd,
    offset: [4, 0],
    targetOffset: lo
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: dd,
    offset: [0, 4],
    targetOffset: lo
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: hd,
    offset: [4, 0],
    targetOffset: lo
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: dd,
    offset: [0, 4],
    targetOffset: lo
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: hd,
    offset: [-4, 0],
    targetOffset: lo
  }
}, mie = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"], yie = function(t, r) {
  var n = t.overlayClassName, i = t.trigger, o = i === void 0 ? ["hover"] : i, a = t.mouseEnterDelay, s = a === void 0 ? 0 : a, l = t.mouseLeaveDelay, u = l === void 0 ? 0.1 : l, c = t.overlayStyle, d = t.prefixCls, h = d === void 0 ? "rc-tooltip" : d, f = t.children, p = t.onVisibleChange, g = t.afterVisibleChange, v = t.transitionName, m = t.animation, y = t.motion, C = t.placement, S = C === void 0 ? "right" : C, b = t.align, w = b === void 0 ? {} : b, x = t.destroyTooltipOnHide, E = x === void 0 ? !1 : x, R = t.defaultVisible, _ = t.getTooltipContainer, P = t.overlayInnerStyle;
  t.arrowContent;
  var D = t.overlay, I = t.id, A = t.showArrow, O = A === void 0 ? !0 : A, L = zt(t, mie), N = le(null);
  Nc(r, function() {
    return N.current;
  });
  var F = re({}, L);
  "visible" in t && (F.popupVisible = t.visible);
  var G = function() {
    return /* @__PURE__ */ T.createElement(hP, {
      key: "content",
      prefixCls: h,
      id: I,
      overlayInnerStyle: P
    }, D);
  };
  return /* @__PURE__ */ T.createElement(cP, ze({
    popupClassName: n,
    prefixCls: h,
    popup: G,
    action: o,
    builtinPlacements: vie,
    popupPlacement: S,
    ref: N,
    popupAlign: w,
    getPopupContainer: _,
    onPopupVisibleChange: p,
    afterPopupVisibleChange: g,
    popupTransitionName: v,
    popupAnimation: m,
    popupMotion: y,
    defaultPopupVisible: R,
    autoDestroy: E,
    mouseLeaveDelay: u,
    popupStyle: c,
    mouseEnterDelay: s,
    arrow: O
  }, F), f);
};
const Cie = /* @__PURE__ */ fn(yie);
function N5(e) {
  const {
    sizePopupArrow: t,
    borderRadiusXS: r,
    borderRadiusOuter: n
  } = e, i = t / 2, o = 0, a = i, s = n * 1 / Math.sqrt(2), l = i - n * (1 - 1 / Math.sqrt(2)), u = i - r * (1 / Math.sqrt(2)), c = n * (Math.sqrt(2) - 1) + r * (1 / Math.sqrt(2)), d = 2 * i - u, h = c, f = 2 * i - s, p = l, g = 2 * i - o, v = a, m = i * Math.sqrt(2) + n * (Math.sqrt(2) - 2), y = n * (Math.sqrt(2) - 1), C = `polygon(${y}px 100%, 50% ${y}px, ${2 * i - y}px 100%, ${y}px 100%)`, S = `path('M ${o} ${a} A ${n} ${n} 0 0 0 ${s} ${l} L ${u} ${c} A ${r} ${r} 0 0 1 ${d} ${h} L ${f} ${p} A ${n} ${n} 0 0 0 ${g} ${v} Z')`;
  return {
    arrowShadowWidth: m,
    arrowPath: S,
    arrowPolygon: C
  };
}
const Sie = (e, t, r) => {
  const {
    sizePopupArrow: n,
    arrowPolygon: i,
    arrowPath: o,
    arrowShadowWidth: a,
    borderRadiusXS: s,
    calc: l
  } = e;
  return {
    pointerEvents: "none",
    width: n,
    height: n,
    overflow: "hidden",
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: n,
      height: l(n).div(2).equal(),
      background: t,
      clipPath: {
        _multi_value_: !0,
        value: [i, o]
      },
      content: '""'
    },
    "&::after": {
      content: '""',
      position: "absolute",
      width: a,
      height: a,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: !0,
        value: `0 0 ${xe(s)} 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow: r,
      zIndex: 0,
      background: "transparent"
    }
  };
}, k5 = 8;
function fP(e) {
  const {
    contentRadius: t,
    limitVerticalRadius: r
  } = e, n = t > 12 ? t + 2 : 12;
  return {
    arrowOffsetHorizontal: n,
    arrowOffsetVertical: r ? k5 : n
  };
}
function hm(e, t) {
  return e ? t : {};
}
function V5(e, t, r) {
  const {
    componentCls: n,
    boxShadowPopoverArrow: i,
    arrowOffsetVertical: o,
    arrowOffsetHorizontal: a
  } = e, {
    arrowDistance: s = 0,
    arrowPlacement: l = {
      left: !0,
      right: !0,
      top: !0,
      bottom: !0
    }
  } = {};
  return {
    [n]: Object.assign(Object.assign(Object.assign(Object.assign({
      // ============================ Basic ============================
      [`${n}-arrow`]: [Object.assign(Object.assign({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, Sie(e, t, i)), {
        "&:before": {
          background: t
        }
      })]
    }, hm(!!l.top, {
      [[`&-placement-top > ${n}-arrow`, `&-placement-topLeft > ${n}-arrow`, `&-placement-topRight > ${n}-arrow`].join(",")]: {
        bottom: s,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top > ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft > ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: a
        }
      },
      [`&-placement-topRight > ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: a
        }
      }
    })), hm(!!l.bottom, {
      [[`&-placement-bottom > ${n}-arrow`, `&-placement-bottomLeft > ${n}-arrow`, `&-placement-bottomRight > ${n}-arrow`].join(",")]: {
        top: s,
        transform: "translateY(-100%)"
      },
      [`&-placement-bottom > ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(-100%)"
      },
      [`&-placement-bottomLeft > ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: a
        }
      },
      [`&-placement-bottomRight > ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: a
        }
      }
    })), hm(!!l.left, {
      [[`&-placement-left > ${n}-arrow`, `&-placement-leftTop > ${n}-arrow`, `&-placement-leftBottom > ${n}-arrow`].join(",")]: {
        right: {
          _skip_check_: !0,
          value: s
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left > ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop > ${n}-arrow`]: {
        top: o
      },
      [`&-placement-leftBottom > ${n}-arrow`]: {
        bottom: o
      }
    })), hm(!!l.right, {
      [[`&-placement-right > ${n}-arrow`, `&-placement-rightTop > ${n}-arrow`, `&-placement-rightBottom > ${n}-arrow`].join(",")]: {
        left: {
          _skip_check_: !0,
          value: s
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right > ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop > ${n}-arrow`]: {
        top: o
      },
      [`&-placement-rightBottom > ${n}-arrow`]: {
        bottom: o
      }
    }))
  };
}
function wie(e, t, r, n) {
  if (n === !1)
    return {
      adjustX: !1,
      adjustY: !1
    };
  const i = n && typeof n == "object" ? n : {}, o = {};
  switch (e) {
    case "top":
    case "bottom":
      o.shiftX = t.arrowOffsetHorizontal * 2 + r, o.shiftY = !0, o.adjustY = !0;
      break;
    case "left":
    case "right":
      o.shiftY = t.arrowOffsetVertical * 2 + r, o.shiftX = !0, o.adjustX = !0;
      break;
  }
  const a = Object.assign(Object.assign({}, o), i);
  return a.shiftX || (a.adjustX = !0), a.shiftY || (a.adjustY = !0), a;
}
const Z2 = {
  left: {
    points: ["cr", "cl"]
  },
  right: {
    points: ["cl", "cr"]
  },
  top: {
    points: ["bc", "tc"]
  },
  bottom: {
    points: ["tc", "bc"]
  },
  topLeft: {
    points: ["bl", "tl"]
  },
  leftTop: {
    points: ["tr", "tl"]
  },
  topRight: {
    points: ["br", "tr"]
  },
  rightTop: {
    points: ["tl", "tr"]
  },
  bottomRight: {
    points: ["tr", "br"]
  },
  rightBottom: {
    points: ["bl", "br"]
  },
  bottomLeft: {
    points: ["tl", "bl"]
  },
  leftBottom: {
    points: ["br", "bl"]
  }
}, bie = {
  topLeft: {
    points: ["bl", "tc"]
  },
  leftTop: {
    points: ["tr", "cl"]
  },
  topRight: {
    points: ["br", "tc"]
  },
  rightTop: {
    points: ["tl", "cr"]
  },
  bottomRight: {
    points: ["tr", "bc"]
  },
  rightBottom: {
    points: ["bl", "cr"]
  },
  bottomLeft: {
    points: ["tl", "bc"]
  },
  leftBottom: {
    points: ["br", "cl"]
  }
}, xie = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
function Eie(e) {
  const {
    arrowWidth: t,
    autoAdjustOverflow: r,
    arrowPointAtCenter: n,
    offset: i,
    borderRadius: o,
    visibleFirst: a
  } = e, s = t / 2, l = {};
  return Object.keys(Z2).forEach((u) => {
    const c = n && bie[u] || Z2[u], d = Object.assign(Object.assign({}, c), {
      offset: [0, 0],
      dynamicInset: !0
    });
    switch (l[u] = d, xie.has(u) && (d.autoArrow = !1), u) {
      case "top":
      case "topLeft":
      case "topRight":
        d.offset[1] = -s - i;
        break;
      case "bottom":
      case "bottomLeft":
      case "bottomRight":
        d.offset[1] = s + i;
        break;
      case "left":
      case "leftTop":
      case "leftBottom":
        d.offset[0] = -s - i;
        break;
      case "right":
      case "rightTop":
      case "rightBottom":
        d.offset[0] = s + i;
        break;
    }
    const h = fP({
      contentRadius: o,
      limitVerticalRadius: !0
    });
    if (n)
      switch (u) {
        case "topLeft":
        case "bottomLeft":
          d.offset[0] = -h.arrowOffsetHorizontal - s;
          break;
        case "topRight":
        case "bottomRight":
          d.offset[0] = h.arrowOffsetHorizontal + s;
          break;
        case "leftTop":
        case "rightTop":
          d.offset[1] = -h.arrowOffsetHorizontal - s;
          break;
        case "leftBottom":
        case "rightBottom":
          d.offset[1] = h.arrowOffsetHorizontal + s;
          break;
      }
    d.overflow = wie(u, h, t, r), a && (d.htmlRegion = "visibleFirst");
  }), l;
}
const Rie = (e) => {
  const {
    componentCls: t,
    // ant-tooltip
    tooltipMaxWidth: r,
    tooltipColor: n,
    tooltipBg: i,
    tooltipBorderRadius: o,
    zIndexPopup: a,
    controlHeight: s,
    boxShadowSecondary: l,
    paddingSM: u,
    paddingXS: c
  } = e;
  return [
    {
      [t]: Object.assign(Object.assign(Object.assign(Object.assign({}, Xs(e)), {
        position: "absolute",
        zIndex: a,
        display: "block",
        width: "max-content",
        maxWidth: r,
        visibility: "visible",
        transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": i,
        // Wrapper for the tooltip content
        [`${t}-inner`]: {
          minWidth: "1em",
          minHeight: s,
          padding: `${xe(e.calc(u).div(2).equal())} ${xe(c)}`,
          color: n,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: i,
          borderRadius: o,
          boxShadow: l,
          boxSizing: "border-box"
        },
        // Limit left and right placement radius
        [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
          [`${t}-inner`]: {
            borderRadius: e.min(o, k5)
          }
        },
        [`${t}-content`]: {
          position: "relative"
        }
      }), Az(e, (d, h) => {
        let {
          darkColor: f
        } = h;
        return {
          [`&${t}-${d}`]: {
            [`${t}-inner`]: {
              backgroundColor: f
            },
            [`${t}-arrow`]: {
              "--antd-arrow-background-color": f
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    V5(e, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: e.sizePopupArrow
      }
    }
  ];
}, _ie = (e) => Object.assign(Object.assign({
  zIndexPopup: e.zIndexPopupBase + 70
}, fP({
  contentRadius: e.borderRadius,
  limitVerticalRadius: !0
})), N5(dn(e, {
  borderRadiusOuter: Math.min(e.borderRadiusOuter, 4)
}))), B5 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return Gi("Tooltip", (n) => {
    const {
      borderRadius: i,
      colorTextLightSolid: o,
      colorBgSpotlight: a
    } = n, s = dn(n, {
      // default variables
      tooltipMaxWidth: 250,
      tooltipColor: o,
      tooltipBorderRadius: i,
      tooltipBg: a
    });
    return [Rie(s), uS(n, "zoom-big-fast")];
  }, _ie, {
    resetStyle: !1,
    // Popover use Tooltip as internal component. We do not need to handle this.
    injectStyle: t
  })(e);
}, Tie = xg.map((e) => `${e}-inverse`), Pie = ["success", "processing", "error", "default", "warning"];
function G5(e) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [].concat(rt(Tie), rt(xg)).includes(e) : xg.includes(e);
}
function Mie(e) {
  return Pie.includes(e);
}
function H5(e, t) {
  const r = G5(t), n = pe({
    [`${e}-${t}`]: t && r
  }), i = {}, o = {};
  return t && !r && (i.background = t, o["--antd-arrow-background-color"] = t), {
    className: n,
    overlayStyle: i,
    arrowStyle: o
  };
}
const Die = (e) => {
  const {
    prefixCls: t,
    className: r,
    placement: n = "top",
    title: i,
    color: o,
    overlayInnerStyle: a
  } = e, {
    getPrefixCls: s
  } = T.useContext(Xt), l = s("tooltip", t), [u, c, d] = B5(l), h = H5(l, o), f = h.arrowStyle, p = Object.assign(Object.assign({}, a), h.overlayStyle), g = pe(c, d, l, `${l}-pure`, `${l}-placement-${n}`, r, h.className);
  return u(/* @__PURE__ */ T.createElement("div", {
    className: g,
    style: f
  }, /* @__PURE__ */ T.createElement("div", {
    className: `${l}-arrow`
  }), /* @__PURE__ */ T.createElement(hP, Object.assign({}, e, {
    className: c,
    prefixCls: l,
    overlayInnerStyle: p
  }), i)));
};
var Aie = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Iie = /* @__PURE__ */ T.forwardRef((e, t) => {
  var r, n;
  const {
    prefixCls: i,
    openClassName: o,
    getTooltipContainer: a,
    overlayClassName: s,
    color: l,
    overlayInnerStyle: u,
    children: c,
    afterOpenChange: d,
    afterVisibleChange: h,
    destroyTooltipOnHide: f,
    arrow: p = !0,
    title: g,
    overlay: v,
    builtinPlacements: m,
    arrowPointAtCenter: y = !1,
    autoAdjustOverflow: C = !0
  } = e, S = !!p, [, b] = Xa(), {
    getPopupContainer: w,
    getPrefixCls: x,
    direction: E
  } = T.useContext(Xt), R = mn("Tooltip"), _ = T.useRef(null), P = () => {
    var Ve;
    (Ve = _.current) === null || Ve === void 0 || Ve.forceAlign();
  };
  T.useImperativeHandle(t, () => {
    var Ve;
    return {
      forceAlign: P,
      forcePopupAlign: () => {
        R.deprecated(!1, "forcePopupAlign", "forceAlign"), P();
      },
      nativeElement: (Ve = _.current) === null || Ve === void 0 ? void 0 : Ve.nativeElement
    };
  }), process.env.NODE_ENV !== "production" && ([["visible", "open"], ["defaultVisible", "defaultOpen"], ["onVisibleChange", "onOpenChange"], ["afterVisibleChange", "afterOpenChange"], ["arrowPointAtCenter", "arrow={{ pointAtCenter: true }}"]].forEach((Ve) => {
    let [$e, Je] = Ve;
    R.deprecated(!($e in e), $e, Je);
  }), process.env.NODE_ENV !== "production" && R(!f || typeof f == "boolean", "usage", "`destroyTooltipOnHide` no need config `keepParent` anymore. Please use `boolean` value directly."), process.env.NODE_ENV !== "production" && R(!p || typeof p == "boolean" || !("arrowPointAtCenter" in p), "deprecated", "`arrowPointAtCenter` in `arrow` is deprecated. Please use `pointAtCenter` instead."));
  const [D, I] = Nn(!1, {
    value: (r = e.open) !== null && r !== void 0 ? r : e.visible,
    defaultValue: (n = e.defaultOpen) !== null && n !== void 0 ? n : e.defaultVisible
  }), A = !g && !v && g !== 0, O = (Ve) => {
    var $e, Je;
    I(A ? !1 : Ve), A || (($e = e.onOpenChange) === null || $e === void 0 || $e.call(e, Ve), (Je = e.onVisibleChange) === null || Je === void 0 || Je.call(e, Ve));
  }, L = T.useMemo(() => {
    var Ve, $e;
    let Je = y;
    return typeof p == "object" && (Je = ($e = (Ve = p.pointAtCenter) !== null && Ve !== void 0 ? Ve : p.arrowPointAtCenter) !== null && $e !== void 0 ? $e : y), m || Eie({
      arrowPointAtCenter: Je,
      autoAdjustOverflow: C,
      arrowWidth: S ? b.sizePopupArrow : 0,
      borderRadius: b.borderRadius,
      offset: b.marginXXS,
      visibleFirst: !0
    });
  }, [y, p, m, b]), N = T.useMemo(() => g === 0 ? g : v || g || "", [v, g]), F = /* @__PURE__ */ T.createElement(eR, {
    space: !0
  }, typeof N == "function" ? N() : N), {
    getPopupContainer: G,
    placement: M = "top",
    mouseEnterDelay: V = 0.1,
    mouseLeaveDelay: z = 0.1,
    overlayStyle: k,
    rootClassName: $
  } = e, W = Aie(e, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]), j = x("tooltip", i), U = x(), Z = e["data-popover-inject"];
  let ee = D;
  !("open" in e) && !("visible" in e) && A && (ee = !1);
  const J = /* @__PURE__ */ T.isValidElement(c) && !Zz(c) ? c : /* @__PURE__ */ T.createElement("span", null, c), X = J.props, Y = !X.className || typeof X.className == "string" ? pe(X.className, o || `${j}-open`) : X.className, [de, K, ie] = B5(j, !Z), Ce = H5(j, l), Te = Ce.arrowStyle, Ie = Object.assign(Object.assign({}, u), Ce.overlayStyle), we = pe(s, {
    [`${j}-rtl`]: E === "rtl"
  }, Ce.className, $, K, ie), [Re, _e] = rP("Tooltip", W.zIndex), He = /* @__PURE__ */ T.createElement(Cie, Object.assign({}, W, {
    zIndex: Re,
    showArrow: S,
    placement: M,
    mouseEnterDelay: V,
    mouseLeaveDelay: z,
    prefixCls: j,
    overlayClassName: we,
    overlayStyle: Object.assign(Object.assign({}, Te), k),
    getTooltipContainer: G || a || w,
    ref: _,
    builtinPlacements: L,
    overlay: F,
    visible: ee,
    onVisibleChange: O,
    afterVisibleChange: d ?? h,
    overlayInnerStyle: Ie,
    arrowContent: /* @__PURE__ */ T.createElement("span", {
      className: `${j}-arrow-content`
    }),
    motion: {
      motionName: _c(U, "zoom-big-fast", e.transitionName),
      motionDeadline: 1e3
    },
    destroyTooltipOnHide: !!f
  }), ee ? Rc(J, {
    className: Y
  }) : J);
  return de(/* @__PURE__ */ T.createElement(tP.Provider, {
    value: _e
  }, He));
}), Hc = Iie;
process.env.NODE_ENV !== "production" && (Hc.displayName = "Tooltip");
Hc._InternalPanelDoNotUseOrYouWillBeFired = Die;
const Fie = (e) => {
  const {
    componentCls: t,
    popoverColor: r,
    titleMinWidth: n,
    fontWeightStrong: i,
    innerPadding: o,
    boxShadowSecondary: a,
    colorTextHeading: s,
    borderRadiusLG: l,
    zIndexPopup: u,
    titleMarginBottom: c,
    colorBgElevated: d,
    popoverBg: h,
    titleBorderBottom: f,
    innerContentPadding: p,
    titlePadding: g
  } = e;
  return [
    {
      [t]: Object.assign(Object.assign({}, Xs(e)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: !0,
          value: 0
        },
        zIndex: u,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        transformOrigin: "var(--arrow-x, 50%) var(--arrow-y, 50%)",
        "--antd-arrow-background-color": d,
        width: "max-content",
        maxWidth: "100vw",
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${t}-content`]: {
          position: "relative"
        },
        [`${t}-inner`]: {
          backgroundColor: h,
          backgroundClip: "padding-box",
          borderRadius: l,
          boxShadow: a,
          padding: o
        },
        [`${t}-title`]: {
          minWidth: n,
          marginBottom: c,
          color: s,
          fontWeight: i,
          borderBottom: f,
          padding: g
        },
        [`${t}-inner-content`]: {
          color: r,
          padding: p
        }
      })
    },
    // Arrow Style
    V5(e, "var(--antd-arrow-background-color)"),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none",
        margin: e.sizePopupArrow,
        display: "inline-block",
        [`${t}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
}, Lie = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: xg.map((r) => {
      const n = e[`${r}6`];
      return {
        [`&${t}-${r}`]: {
          "--antd-arrow-background-color": n,
          [`${t}-inner`]: {
            backgroundColor: n
          },
          [`${t}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
}, Oie = (e) => {
  const {
    lineWidth: t,
    controlHeight: r,
    fontHeight: n,
    padding: i,
    wireframe: o,
    zIndexPopupBase: a,
    borderRadiusLG: s,
    marginXS: l,
    lineType: u,
    colorSplit: c,
    paddingSM: d
  } = e, h = r - n, f = h / 2, p = h / 2 - t, g = i;
  return Object.assign(Object.assign(Object.assign({
    titleMinWidth: 177,
    zIndexPopup: a + 30
  }, N5(e)), fP({
    contentRadius: s,
    limitVerticalRadius: !0
  })), {
    // internal
    innerPadding: o ? 0 : 12,
    titleMarginBottom: o ? 0 : l,
    titlePadding: o ? `${f}px ${g}px ${p}px` : 0,
    titleBorderBottom: o ? `${t}px ${u} ${c}` : "none",
    innerContentPadding: o ? `${d}px ${g}px` : 0
  });
}, z5 = Gi("Popover", (e) => {
  const {
    colorBgElevated: t,
    colorText: r
  } = e, n = dn(e, {
    popoverBg: t,
    popoverColor: r
  });
  return [Fie(n), Lie(n), uS(n, "zoom-big")];
}, Oie, {
  resetStyle: !1,
  deprecatedTokens: [["width", "titleMinWidth"], ["minWidth", "titleMinWidth"]]
});
var Nie = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const kie = (e, t, r) => !t && !r ? null : /* @__PURE__ */ T.createElement(T.Fragment, null, t && /* @__PURE__ */ T.createElement("div", {
  className: `${e}-title`
}, Dh(t)), /* @__PURE__ */ T.createElement("div", {
  className: `${e}-inner-content`
}, Dh(r))), Vie = (e) => {
  const {
    hashId: t,
    prefixCls: r,
    className: n,
    style: i,
    placement: o = "top",
    title: a,
    content: s,
    children: l
  } = e;
  return /* @__PURE__ */ T.createElement("div", {
    className: pe(t, r, `${r}-pure`, `${r}-placement-${o}`, n),
    style: i
  }, /* @__PURE__ */ T.createElement("div", {
    className: `${r}-arrow`
  }), /* @__PURE__ */ T.createElement(hP, Object.assign({}, e, {
    className: t,
    prefixCls: r
  }), l || kie(r, a, s)));
}, $5 = (e) => {
  const {
    prefixCls: t,
    className: r
  } = e, n = Nie(e, ["prefixCls", "className"]), {
    getPrefixCls: i
  } = T.useContext(Xt), o = i("popover", t), [a, s, l] = z5(o);
  return a(/* @__PURE__ */ T.createElement(Vie, Object.assign({}, n, {
    prefixCls: o,
    hashId: s,
    className: pe(r, l)
  })));
};
var Bie = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Gie = (e) => {
  let {
    title: t,
    content: r,
    prefixCls: n
  } = e;
  return /* @__PURE__ */ T.createElement(T.Fragment, null, t && /* @__PURE__ */ T.createElement("div", {
    className: `${n}-title`
  }, Dh(t)), /* @__PURE__ */ T.createElement("div", {
    className: `${n}-inner-content`
  }, Dh(r)));
}, Hie = /* @__PURE__ */ T.forwardRef((e, t) => {
  var r, n;
  const {
    prefixCls: i,
    title: o,
    content: a,
    overlayClassName: s,
    placement: l = "top",
    trigger: u = "hover",
    children: c,
    mouseEnterDelay: d = 0.1,
    mouseLeaveDelay: h = 0.1,
    onOpenChange: f,
    overlayStyle: p = {}
  } = e, g = Bie(e, ["prefixCls", "title", "content", "overlayClassName", "placement", "trigger", "children", "mouseEnterDelay", "mouseLeaveDelay", "onOpenChange", "overlayStyle"]), {
    getPrefixCls: v
  } = T.useContext(Xt), m = v("popover", i), [y, C, S] = z5(m), b = v(), w = pe(s, C, S), [x, E] = Nn(!1, {
    value: (r = e.open) !== null && r !== void 0 ? r : e.visible,
    defaultValue: (n = e.defaultOpen) !== null && n !== void 0 ? n : e.defaultVisible
  }), R = (D, I) => {
    E(D, !0), f == null || f(D, I);
  }, _ = (D) => {
    D.keyCode === Ue.ESC && R(!1, D);
  }, P = (D) => {
    R(D);
  };
  return y(/* @__PURE__ */ T.createElement(Hc, Object.assign({
    placement: l,
    trigger: u,
    mouseEnterDelay: d,
    mouseLeaveDelay: h,
    overlayStyle: p
  }, g, {
    prefixCls: m,
    overlayClassName: w,
    ref: t,
    open: x,
    onOpenChange: P,
    overlay: o || a ? /* @__PURE__ */ T.createElement(Gie, {
      prefixCls: m,
      title: o,
      content: a
    }) : null,
    transitionName: _c(b, "zoom-big", g.transitionName),
    "data-popover-inject": !0
  }), Rc(c, {
    onKeyDown: (D) => {
      var I, A;
      /* @__PURE__ */ T.isValidElement(c) && ((A = c == null ? void 0 : (I = c.props).onKeyDown) === null || A === void 0 || A.call(I, D)), _(D);
    }
  })));
}), pP = Hie;
pP._InternalPanelDoNotUseOrYouWillBeFired = $5;
process.env.NODE_ENV !== "production" && (pP.displayName = "Popover");
var zie = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, name: "right", theme: "outlined" }, $ie = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: zie
  }));
}, W5 = /* @__PURE__ */ T.forwardRef($ie);
process.env.NODE_ENV !== "production" && (W5.displayName = "RightOutlined");
var Wie = Ue.ESC, jie = Ue.TAB;
function Uie(e) {
  var t = e.visible, r = e.triggerRef, n = e.onVisibleChange, i = e.autoFocus, o = e.overlayRef, a = T.useRef(!1), s = function() {
    if (t) {
      var d, h;
      (d = r.current) === null || d === void 0 || (h = d.focus) === null || h === void 0 || h.call(d), n == null || n(!1);
    }
  }, l = function() {
    var d;
    return (d = o.current) !== null && d !== void 0 && d.focus ? (o.current.focus(), a.current = !0, !0) : !1;
  }, u = function(d) {
    switch (d.keyCode) {
      case Wie:
        s();
        break;
      case jie: {
        var h = !1;
        a.current || (h = l()), h ? d.preventDefault() : s();
        break;
      }
    }
  };
  T.useEffect(function() {
    return t ? (window.addEventListener("keydown", u), i && cn(l, 3), function() {
      window.removeEventListener("keydown", u), a.current = !1;
    }) : function() {
      a.current = !1;
    };
  }, [t]);
}
var Kie = /* @__PURE__ */ fn(function(e, t) {
  var r = e.overlay, n = e.arrow, i = e.prefixCls, o = ct(function() {
    var s;
    return typeof r == "function" ? s = r() : s = r, s;
  }, [r]), a = Vo(t, o == null ? void 0 : o.ref);
  return /* @__PURE__ */ H.createElement(H.Fragment, null, n && /* @__PURE__ */ H.createElement("div", {
    className: "".concat(i, "-arrow")
  }), /* @__PURE__ */ H.cloneElement(o, {
    ref: kc(o) ? a : void 0
  }));
}), fd = {
  adjustX: 1,
  adjustY: 1
}, pd = [0, 0], Yie = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: fd,
    offset: [0, -4],
    targetOffset: pd
  },
  top: {
    points: ["bc", "tc"],
    overflow: fd,
    offset: [0, -4],
    targetOffset: pd
  },
  topRight: {
    points: ["br", "tr"],
    overflow: fd,
    offset: [0, -4],
    targetOffset: pd
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: fd,
    offset: [0, 4],
    targetOffset: pd
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: fd,
    offset: [0, 4],
    targetOffset: pd
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: fd,
    offset: [0, 4],
    targetOffset: pd
  }
}, qie = ["arrow", "prefixCls", "transitionName", "animation", "align", "placement", "placements", "getPopupContainer", "showAction", "hideAction", "overlayClassName", "overlayStyle", "visible", "trigger", "autoFocus", "overlay", "children", "onVisibleChange"];
function Zie(e, t) {
  var r, n = e.arrow, i = n === void 0 ? !1 : n, o = e.prefixCls, a = o === void 0 ? "rc-dropdown" : o, s = e.transitionName, l = e.animation, u = e.align, c = e.placement, d = c === void 0 ? "bottomLeft" : c, h = e.placements, f = h === void 0 ? Yie : h, p = e.getPopupContainer, g = e.showAction, v = e.hideAction, m = e.overlayClassName, y = e.overlayStyle, C = e.visible, S = e.trigger, b = S === void 0 ? ["hover"] : S, w = e.autoFocus, x = e.overlay, E = e.children, R = e.onVisibleChange, _ = zt(e, qie), P = H.useState(), D = ue(P, 2), I = D[0], A = D[1], O = "visible" in e ? C : I, L = H.useRef(null), N = H.useRef(null), F = H.useRef(null);
  H.useImperativeHandle(t, function() {
    return L.current;
  });
  var G = function(Z) {
    A(Z), R == null || R(Z);
  };
  Uie({
    visible: O,
    triggerRef: F,
    onVisibleChange: G,
    autoFocus: w,
    overlayRef: N
  });
  var M = function(Z) {
    var ee = e.onOverlayClick;
    A(!1), ee && ee(Z);
  }, V = function() {
    return /* @__PURE__ */ H.createElement(Kie, {
      ref: N,
      overlay: x,
      prefixCls: a,
      arrow: i
    });
  }, z = function() {
    return typeof x == "function" ? V : V();
  }, k = function() {
    var Z = e.minOverlayWidthMatchTrigger, ee = e.alignPoint;
    return "minOverlayWidthMatchTrigger" in e ? Z : !ee;
  }, $ = function() {
    var Z = e.openClassName;
    return Z !== void 0 ? Z : "".concat(a, "-open");
  }, W = /* @__PURE__ */ H.cloneElement(E, {
    className: pe((r = E.props) === null || r === void 0 ? void 0 : r.className, O && $()),
    ref: kc(E) ? Vo(F, E.ref) : void 0
  }), j = v;
  return !j && b.indexOf("contextMenu") !== -1 && (j = ["click"]), /* @__PURE__ */ H.createElement(cP, ze({
    builtinPlacements: f
  }, _, {
    prefixCls: a,
    ref: L,
    popupClassName: pe(m, te({}, "".concat(a, "-show-arrow"), i)),
    popupStyle: y,
    action: b,
    showAction: g,
    hideAction: j,
    popupPlacement: d,
    popupAlign: u,
    popupTransitionName: s,
    popupAnimation: l,
    popupVisible: O,
    stretch: k() ? "minWidth" : "",
    popup: z(),
    onPopupVisibleChange: G,
    onPopupClick: M,
    getPopupContainer: p
  }), W);
}
const Xie = /* @__PURE__ */ H.forwardRef(Zie);
var j5 = /* @__PURE__ */ T.createContext(null);
function U5(e, t) {
  return e === void 0 ? null : "".concat(e, "-").concat(t);
}
function K5(e) {
  var t = T.useContext(j5);
  return U5(t, e);
}
var Qie = ["children", "locked"], ga = /* @__PURE__ */ T.createContext(null);
function Jie(e, t) {
  var r = re({}, e);
  return Object.keys(t).forEach(function(n) {
    var i = t[n];
    i !== void 0 && (r[n] = i);
  }), r;
}
function _g(e) {
  var t = e.children, r = e.locked, n = zt(e, Qie), i = T.useContext(ga), o = qC(function() {
    return Jie(i, n);
  }, [i, n], function(a, s) {
    return !r && (a[0] !== s[0] || !xh(a[1], s[1], !0));
  });
  return /* @__PURE__ */ T.createElement(ga.Provider, {
    value: o
  }, t);
}
var eoe = [], Y5 = /* @__PURE__ */ T.createContext(null);
function cS() {
  return T.useContext(Y5);
}
var q5 = /* @__PURE__ */ T.createContext(eoe);
function pv(e) {
  var t = T.useContext(q5);
  return T.useMemo(function() {
    return e !== void 0 ? [].concat(rt(t), [e]) : t;
  }, [t, e]);
}
var Z5 = /* @__PURE__ */ T.createContext(null), gP = /* @__PURE__ */ T.createContext({});
function X2(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  if (nP(e)) {
    var r = e.nodeName.toLowerCase(), n = (
      // Focusable element
      ["input", "select", "textarea", "button"].includes(r) || // Editable element
      e.isContentEditable || // Anchor with href element
      r === "a" && !!e.getAttribute("href")
    ), i = e.getAttribute("tabindex"), o = Number(i), a = null;
    return i && !Number.isNaN(o) ? a = o : n && a === null && (a = 0), n && e.disabled && (a = null), a !== null && (a >= 0 || t && a < 0);
  }
  return !1;
}
function toe(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = rt(e.querySelectorAll("*")).filter(function(n) {
    return X2(n, t);
  });
  return X2(e, t) && r.unshift(e), r;
}
var nR = Ue.LEFT, iR = Ue.RIGHT, oR = Ue.UP, jy = Ue.DOWN, Uy = Ue.ENTER, X5 = Ue.ESC, Bf = Ue.HOME, Gf = Ue.END, Q2 = [oR, jy, nR, iR];
function roe(e, t, r, n) {
  var i, o, a, s, l = "prev", u = "next", c = "children", d = "parent";
  if (e === "inline" && n === Uy)
    return {
      inlineTrigger: !0
    };
  var h = (i = {}, te(i, oR, l), te(i, jy, u), i), f = (o = {}, te(o, nR, r ? u : l), te(o, iR, r ? l : u), te(o, jy, c), te(o, Uy, c), o), p = (a = {}, te(a, oR, l), te(a, jy, u), te(a, Uy, c), te(a, X5, d), te(a, nR, r ? c : d), te(a, iR, r ? d : c), a), g = {
    inline: h,
    horizontal: f,
    vertical: p,
    inlineSub: h,
    horizontalSub: p,
    verticalSub: p
  }, v = (s = g["".concat(e).concat(t ? "" : "Sub")]) === null || s === void 0 ? void 0 : s[n];
  switch (v) {
    case l:
      return {
        offset: -1,
        sibling: !0
      };
    case u:
      return {
        offset: 1,
        sibling: !0
      };
    case d:
      return {
        offset: -1,
        sibling: !1
      };
    case c:
      return {
        offset: 1,
        sibling: !1
      };
    default:
      return null;
  }
}
function noe(e) {
  for (var t = e; t; ) {
    if (t.getAttribute("data-menu-list"))
      return t;
    t = t.parentElement;
  }
  return null;
}
function ioe(e, t) {
  for (var r = e || document.activeElement; r; ) {
    if (t.has(r))
      return r;
    r = r.parentElement;
  }
  return null;
}
function vP(e, t) {
  var r = toe(e, !0);
  return r.filter(function(n) {
    return t.has(n);
  });
}
function J2(e, t, r) {
  var n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  if (!e)
    return null;
  var i = vP(e, t), o = i.length, a = i.findIndex(function(s) {
    return r === s;
  });
  return n < 0 ? a === -1 ? a = o - 1 : a -= 1 : n > 0 && (a += 1), a = (a + o) % o, i[a];
}
var aR = function(t, r) {
  var n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  return t.forEach(function(a) {
    var s = document.querySelector("[data-menu-id='".concat(U5(r, a), "']"));
    s && (n.add(s), o.set(s, a), i.set(a, s));
  }), {
    elements: n,
    key2element: i,
    element2key: o
  };
};
function ooe(e, t, r, n, i, o, a, s, l, u) {
  var c = T.useRef(), d = T.useRef();
  d.current = t;
  var h = function() {
    cn.cancel(c.current);
  };
  return T.useEffect(function() {
    return function() {
      h();
    };
  }, []), function(f) {
    var p = f.which;
    if ([].concat(Q2, [Uy, X5, Bf, Gf]).includes(p)) {
      var g = o(), v = aR(g, n), m = v, y = m.elements, C = m.key2element, S = m.element2key, b = C.get(t), w = ioe(b, y), x = S.get(w), E = roe(e, a(x, !0).length === 1, r, p);
      if (!E && p !== Bf && p !== Gf)
        return;
      (Q2.includes(p) || [Bf, Gf].includes(p)) && f.preventDefault();
      var R = function(N) {
        if (N) {
          var F = N, G = N.querySelector("a");
          G != null && G.getAttribute("href") && (F = G);
          var M = S.get(N);
          s(M), h(), c.current = cn(function() {
            d.current === M && F.focus();
          });
        }
      };
      if ([Bf, Gf].includes(p) || E.sibling || !w) {
        var _;
        !w || e === "inline" ? _ = i.current : _ = noe(w);
        var P, D = vP(_, y);
        p === Bf ? P = D[0] : p === Gf ? P = D[D.length - 1] : P = J2(_, y, w, E.offset), R(P);
      } else if (E.inlineTrigger)
        l(x);
      else if (E.offset > 0)
        l(x, !0), h(), c.current = cn(function() {
          v = aR(g, n);
          var L = w.getAttribute("aria-controls"), N = document.getElementById(L), F = J2(N, v.elements);
          R(F);
        }, 5);
      else if (E.offset < 0) {
        var I = a(x, !0), A = I[I.length - 2], O = C.get(A);
        l(A, !1), R(O);
      }
    }
    u == null || u(f);
  };
}
function aoe(e) {
  Promise.resolve().then(e);
}
var mP = "__RC_UTIL_PATH_SPLIT__", eF = function(t) {
  return t.join(mP);
}, soe = function(t) {
  return t.split(mP);
}, sR = "rc-menu-more";
function loe() {
  var e = T.useState({}), t = ue(e, 2), r = t[1], n = le(/* @__PURE__ */ new Map()), i = le(/* @__PURE__ */ new Map()), o = T.useState([]), a = ue(o, 2), s = a[0], l = a[1], u = le(0), c = le(!1), d = function() {
    c.current || r({});
  }, h = Wt(function(C, S) {
    process.env.NODE_ENV !== "production" && gr(!n.current.has(C), "Duplicated key '".concat(C, "' used in Menu by path [").concat(S.join(" > "), "]"));
    var b = eF(S);
    i.current.set(b, C), n.current.set(C, b), u.current += 1;
    var w = u.current;
    aoe(function() {
      w === u.current && d();
    });
  }, []), f = Wt(function(C, S) {
    var b = eF(S);
    i.current.delete(b), n.current.delete(C);
  }, []), p = Wt(function(C) {
    l(C);
  }, []), g = Wt(function(C, S) {
    var b = n.current.get(C) || "", w = soe(b);
    return S && s.includes(w[0]) && w.unshift(sR), w;
  }, [s]), v = Wt(function(C, S) {
    return C.filter(function(b) {
      return b !== void 0;
    }).some(function(b) {
      var w = g(b, !0);
      return w.includes(S);
    });
  }, [g]), m = function() {
    var S = rt(n.current.keys());
    return s.length && S.push(sR), S;
  }, y = Wt(function(C) {
    var S = "".concat(n.current.get(C)).concat(mP), b = /* @__PURE__ */ new Set();
    return rt(i.current.keys()).forEach(function(w) {
      w.startsWith(S) && b.add(i.current.get(w));
    }), b;
  }, []);
  return T.useEffect(function() {
    return function() {
      c.current = !0;
    };
  }, []), {
    // Register
    registerPath: h,
    unregisterPath: f,
    refreshOverflowKeys: p,
    // Util
    isSubPathKey: v,
    getKeyPath: g,
    getKeys: m,
    getSubPathKeys: y
  };
}
function bp(e) {
  var t = T.useRef(e);
  t.current = e;
  var r = T.useCallback(function() {
    for (var n, i = arguments.length, o = new Array(i), a = 0; a < i; a++)
      o[a] = arguments[a];
    return (n = t.current) === null || n === void 0 ? void 0 : n.call.apply(n, [t].concat(o));
  }, []);
  return e ? r : void 0;
}
var uoe = Math.random().toFixed(5).toString().slice(2), tF = 0;
function coe(e) {
  var t = Nn(e, {
    value: e
  }), r = ue(t, 2), n = r[0], i = r[1];
  return T.useEffect(function() {
    tF += 1;
    var o = process.env.NODE_ENV === "test" ? "test" : "".concat(uoe, "-").concat(tF);
    i("rc-menu-uuid-".concat(o));
  }, []), n;
}
function Q5(e, t, r, n) {
  var i = T.useContext(ga), o = i.activeKey, a = i.onActive, s = i.onInactive, l = {
    active: o === e
  };
  return t || (l.onMouseEnter = function(u) {
    r == null || r({
      key: e,
      domEvent: u
    }), a(e);
  }, l.onMouseLeave = function(u) {
    n == null || n({
      key: e,
      domEvent: u
    }), s(e);
  }), l;
}
function J5(e) {
  var t = T.useContext(ga), r = t.mode, n = t.rtl, i = t.inlineIndent;
  if (r !== "inline")
    return null;
  var o = e;
  return n ? {
    paddingRight: o * i
  } : {
    paddingLeft: o * i
  };
}
function e8(e) {
  var t = e.icon, r = e.props, n = e.children, i;
  return t === null || t === !1 ? null : (typeof t == "function" ? i = /* @__PURE__ */ T.createElement(t, re({}, r)) : typeof t != "boolean" && (i = t), i || n || null);
}
var doe = ["item"];
function D0(e) {
  var t = e.item, r = zt(e, doe);
  return Object.defineProperty(r, "item", {
    get: function() {
      return gr(!1, "`info.item` is deprecated since we will move to function component that not provides React Node instance in future."), t;
    }
  }), r;
}
var hoe = ["title", "attribute", "elementRef"], foe = ["style", "className", "eventKey", "warnKey", "disabled", "itemIcon", "children", "role", "onMouseEnter", "onMouseLeave", "onClick", "onKeyDown", "onFocus"], poe = ["active"], goe = /* @__PURE__ */ function(e) {
  Ql(r, e);
  var t = Jl(r);
  function r() {
    return Hn(this, r), t.apply(this, arguments);
  }
  return zn(r, [{
    key: "render",
    value: function() {
      var i = this.props, o = i.title, a = i.attribute, s = i.elementRef, l = zt(i, hoe), u = Bi(l, ["eventKey", "popupClassName", "popupOffset", "onTitleClick"]);
      return gr(!a, "`attribute` of Menu.Item is deprecated. Please pass attribute directly."), /* @__PURE__ */ T.createElement(Ds.Item, ze({}, a, {
        title: typeof o == "string" ? o : void 0
      }, u, {
        ref: s
      }));
    }
  }]), r;
}(T.Component), voe = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r, n = e.style, i = e.className, o = e.eventKey, a = e.warnKey, s = e.disabled, l = e.itemIcon, u = e.children, c = e.role, d = e.onMouseEnter, h = e.onMouseLeave, f = e.onClick, p = e.onKeyDown, g = e.onFocus, v = zt(e, foe), m = K5(o), y = T.useContext(ga), C = y.prefixCls, S = y.onItemClick, b = y.disabled, w = y.overflowDisabled, x = y.itemIcon, E = y.selectedKeys, R = y.onActive, _ = T.useContext(gP), P = _._internalRenderMenuItem, D = "".concat(C, "-item"), I = T.useRef(), A = T.useRef(), O = b || s, L = Kh(t, A), N = pv(o);
  process.env.NODE_ENV !== "production" && a && gr(!1, "MenuItem should not leave undefined `key`.");
  var F = function(X) {
    return {
      key: o,
      // Note: For legacy code is reversed which not like other antd component
      keyPath: rt(N).reverse(),
      item: I.current,
      domEvent: X
    };
  }, G = l || x, M = Q5(o, O, d, h), V = M.active, z = zt(M, poe), k = E.includes(o), $ = J5(N.length), W = function(X) {
    if (!O) {
      var Y = F(X);
      f == null || f(D0(Y)), S(Y);
    }
  }, j = function(X) {
    if (p == null || p(X), X.which === Ue.ENTER) {
      var Y = F(X);
      f == null || f(D0(Y)), S(Y);
    }
  }, U = function(X) {
    R(o), g == null || g(X);
  }, Z = {};
  e.role === "option" && (Z["aria-selected"] = k);
  var ee = /* @__PURE__ */ T.createElement(goe, ze({
    ref: I,
    elementRef: L,
    role: c === null ? "none" : c || "menuitem",
    tabIndex: s ? null : -1,
    "data-menu-id": w && m ? null : m
  }, v, z, Z, {
    component: "li",
    "aria-disabled": s,
    style: re(re({}, $), n),
    className: pe(D, (r = {}, te(r, "".concat(D, "-active"), V), te(r, "".concat(D, "-selected"), k), te(r, "".concat(D, "-disabled"), O), r), i),
    onClick: W,
    onKeyDown: j,
    onFocus: U
  }), u, /* @__PURE__ */ T.createElement(e8, {
    props: re(re({}, e), {}, {
      isSelected: k
    }),
    icon: G
  }));
  return P && (ee = P(ee, e, {
    selected: k
  })), ee;
});
function moe(e, t) {
  var r = e.eventKey, n = cS(), i = pv(r);
  return T.useEffect(function() {
    if (n)
      return n.registerPath(r, i), function() {
        n.unregisterPath(r, i);
      };
  }, [i]), n ? null : /* @__PURE__ */ T.createElement(voe, ze({}, e, {
    ref: t
  }));
}
const dS = /* @__PURE__ */ T.forwardRef(moe);
var yoe = ["className", "children"], Coe = function(t, r) {
  var n = t.className, i = t.children, o = zt(t, yoe), a = T.useContext(ga), s = a.prefixCls, l = a.mode, u = a.rtl;
  return /* @__PURE__ */ T.createElement("ul", ze({
    className: pe(s, u && "".concat(s, "-rtl"), "".concat(s, "-sub"), "".concat(s, "-").concat(l === "inline" ? "inline" : "vertical"), n),
    role: "menu"
  }, o, {
    "data-menu-list": !0,
    ref: r
  }), i);
}, yP = /* @__PURE__ */ T.forwardRef(Coe);
yP.displayName = "SubMenuList";
function CP(e, t) {
  return Gl(e).map(function(r, n) {
    if (/* @__PURE__ */ T.isValidElement(r)) {
      var i, o, a = r.key, s = (i = (o = r.props) === null || o === void 0 ? void 0 : o.eventKey) !== null && i !== void 0 ? i : a, l = s == null;
      l && (s = "tmp_key-".concat([].concat(rt(t), [n]).join("-")));
      var u = {
        key: s,
        eventKey: s
      };
      return process.env.NODE_ENV !== "production" && l && (u.warnKey = !0), /* @__PURE__ */ T.cloneElement(r, u);
    }
    return r;
  });
}
var Yn = {
  adjustX: 1,
  adjustY: 1
}, Soe = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: Yn
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Yn
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Yn
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Yn
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: Yn
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: Yn
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: Yn
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: Yn
  }
}, woe = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: Yn
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Yn
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Yn
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Yn
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: Yn
  },
  rightBottom: {
    points: ["br", "bl"],
    overflow: Yn
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: Yn
  },
  leftBottom: {
    points: ["bl", "br"],
    overflow: Yn
  }
};
function t8(e, t, r) {
  if (t)
    return t;
  if (r)
    return r[e] || r.other;
}
var boe = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
};
function xoe(e) {
  var t = e.prefixCls, r = e.visible, n = e.children, i = e.popup, o = e.popupStyle, a = e.popupClassName, s = e.popupOffset, l = e.disabled, u = e.mode, c = e.onVisibleChange, d = T.useContext(ga), h = d.getPopupContainer, f = d.rtl, p = d.subMenuOpenDelay, g = d.subMenuCloseDelay, v = d.builtinPlacements, m = d.triggerSubMenuAction, y = d.forceSubMenuRender, C = d.rootClassName, S = d.motion, b = d.defaultMotions, w = T.useState(!1), x = ue(w, 2), E = x[0], R = x[1], _ = re(f ? re({}, woe) : re({}, Soe), v), P = boe[u], D = t8(u, S, b), I = T.useRef(D);
  u !== "inline" && (I.current = D);
  var A = re(re({}, I.current), {}, {
    leavedClassName: "".concat(t, "-hidden"),
    removeOnLeave: !1,
    motionAppear: !0
  }), O = T.useRef();
  return T.useEffect(function() {
    return O.current = cn(function() {
      R(r);
    }), function() {
      cn.cancel(O.current);
    };
  }, [r]), /* @__PURE__ */ T.createElement(cP, {
    prefixCls: t,
    popupClassName: pe("".concat(t, "-popup"), te({}, "".concat(t, "-rtl"), f), a, C),
    stretch: u === "horizontal" ? "minWidth" : null,
    getPopupContainer: h,
    builtinPlacements: _,
    popupPlacement: P,
    popupVisible: E,
    popup: i,
    popupStyle: o,
    popupAlign: s && {
      offset: s
    },
    action: l ? [] : [m],
    mouseEnterDelay: p,
    mouseLeaveDelay: g,
    onPopupVisibleChange: c,
    forceRender: y,
    popupMotion: A,
    fresh: !0
  }, n);
}
function Eoe(e) {
  var t = e.id, r = e.open, n = e.keyPath, i = e.children, o = "inline", a = T.useContext(ga), s = a.prefixCls, l = a.forceSubMenuRender, u = a.motion, c = a.defaultMotions, d = a.mode, h = T.useRef(!1);
  h.current = d === o;
  var f = T.useState(!h.current), p = ue(f, 2), g = p[0], v = p[1], m = h.current ? r : !1;
  T.useEffect(function() {
    h.current && v(!1);
  }, [d]);
  var y = re({}, t8(o, u, c));
  n.length > 1 && (y.motionAppear = !1);
  var C = y.onVisibleChanged;
  return y.onVisibleChanged = function(S) {
    return !h.current && !S && v(!0), C == null ? void 0 : C(S);
  }, g ? null : /* @__PURE__ */ T.createElement(_g, {
    mode: o,
    locked: !h.current
  }, /* @__PURE__ */ T.createElement(ns, ze({
    visible: m
  }, y, {
    forceRender: l,
    removeOnLeave: !1,
    leavedClassName: "".concat(s, "-hidden")
  }), function(S) {
    var b = S.className, w = S.style;
    return /* @__PURE__ */ T.createElement(yP, {
      id: t,
      className: b,
      style: w
    }, i);
  }));
}
var Roe = ["style", "className", "title", "eventKey", "warnKey", "disabled", "internalPopupClose", "children", "itemIcon", "expandIcon", "popupClassName", "popupOffset", "popupStyle", "onClick", "onMouseEnter", "onMouseLeave", "onTitleClick", "onTitleMouseEnter", "onTitleMouseLeave"], _oe = ["active"], Toe = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r, n = e.style, i = e.className, o = e.title, a = e.eventKey, s = e.warnKey, l = e.disabled, u = e.internalPopupClose, c = e.children, d = e.itemIcon, h = e.expandIcon, f = e.popupClassName, p = e.popupOffset, g = e.popupStyle, v = e.onClick, m = e.onMouseEnter, y = e.onMouseLeave, C = e.onTitleClick, S = e.onTitleMouseEnter, b = e.onTitleMouseLeave, w = zt(e, Roe), x = K5(a), E = T.useContext(ga), R = E.prefixCls, _ = E.mode, P = E.openKeys, D = E.disabled, I = E.overflowDisabled, A = E.activeKey, O = E.selectedKeys, L = E.itemIcon, N = E.expandIcon, F = E.onItemClick, G = E.onOpenChange, M = E.onActive, V = T.useContext(gP), z = V._internalRenderSubMenuItem, k = T.useContext(Z5), $ = k.isSubPathKey, W = pv(), j = "".concat(R, "-submenu"), U = D || l, Z = T.useRef(), ee = T.useRef();
  process.env.NODE_ENV !== "production" && s && gr(!1, "SubMenu should not leave undefined `key`.");
  var J = d ?? L, X = h ?? N, Y = P.includes(a), de = !I && Y, K = $(O, a), ie = Q5(a, U, S, b), Ce = ie.active, Te = zt(ie, _oe), Ie = T.useState(!1), we = ue(Ie, 2), Re = we[0], _e = we[1], He = function(tt) {
    U || _e(tt);
  }, Ve = function(tt) {
    He(!0), m == null || m({
      key: a,
      domEvent: tt
    });
  }, $e = function(tt) {
    He(!1), y == null || y({
      key: a,
      domEvent: tt
    });
  }, Je = T.useMemo(function() {
    return Ce || (_ !== "inline" ? Re || $([A], a) : !1);
  }, [_, Ce, A, Re, a, $]), Q = J5(W.length), ye = function(tt) {
    U || (C == null || C({
      key: a,
      domEvent: tt
    }), _ === "inline" && G(a, !Y));
  }, Ge = bp(function(lt) {
    v == null || v(D0(lt)), F(lt);
  }), Pe = function(tt) {
    _ !== "inline" && G(a, tt);
  }, Le = function() {
    M(a);
  }, me = x && "".concat(x, "-popup"), De = /* @__PURE__ */ T.createElement("div", ze({
    role: "menuitem",
    style: Q,
    className: "".concat(j, "-title"),
    tabIndex: U ? null : -1,
    ref: Z,
    title: typeof o == "string" ? o : null,
    "data-menu-id": I && x ? null : x,
    "aria-expanded": de,
    "aria-haspopup": !0,
    "aria-controls": me,
    "aria-disabled": U,
    onClick: ye,
    onFocus: Le
  }, Te), o, /* @__PURE__ */ T.createElement(e8, {
    icon: _ !== "horizontal" ? X : void 0,
    props: re(re({}, e), {}, {
      isOpen: de,
      // [Legacy] Not sure why need this mark
      isSubMenu: !0
    })
  }, /* @__PURE__ */ T.createElement("i", {
    className: "".concat(j, "-arrow")
  }))), qe = T.useRef(_);
  if (_ !== "inline" && W.length > 1 ? qe.current = "vertical" : qe.current = _, !I) {
    var ht = qe.current;
    De = /* @__PURE__ */ T.createElement(xoe, {
      mode: ht,
      prefixCls: j,
      visible: !u && de && _ !== "inline",
      popupClassName: f,
      popupOffset: p,
      popupStyle: g,
      popup: /* @__PURE__ */ T.createElement(
        _g,
        {
          mode: ht === "horizontal" ? "vertical" : ht
        },
        /* @__PURE__ */ T.createElement(yP, {
          id: me,
          ref: ee
        }, c)
      ),
      disabled: U,
      onVisibleChange: Pe
    }, De);
  }
  var Tt = /* @__PURE__ */ T.createElement(Ds.Item, ze({
    ref: t,
    role: "none"
  }, w, {
    component: "li",
    style: n,
    className: pe(j, "".concat(j, "-").concat(_), i, (r = {}, te(r, "".concat(j, "-open"), de), te(r, "".concat(j, "-active"), Je), te(r, "".concat(j, "-selected"), K), te(r, "".concat(j, "-disabled"), U), r)),
    onMouseEnter: Ve,
    onMouseLeave: $e
  }), De, !I && /* @__PURE__ */ T.createElement(Eoe, {
    id: me,
    open: de,
    keyPath: W
  }, c));
  return z && (Tt = z(Tt, e, {
    selected: K,
    active: Je,
    open: de,
    disabled: U
  })), /* @__PURE__ */ T.createElement(_g, {
    onItemClick: Ge,
    mode: _ === "horizontal" ? "vertical" : _,
    itemIcon: J,
    expandIcon: X
  }, Tt);
}), hS = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.eventKey, n = e.children, i = pv(r), o = CP(n, i), a = cS();
  T.useEffect(function() {
    if (a)
      return a.registerPath(r, i), function() {
        a.unregisterPath(r, i);
      };
  }, [i]);
  var s;
  return a ? s = o : s = /* @__PURE__ */ T.createElement(Toe, ze({
    ref: t
  }, e), o), /* @__PURE__ */ T.createElement(q5.Provider, {
    value: i
  }, s);
});
process.env.NODE_ENV !== "production" && (hS.displayName = "SubMenu");
function r8(e) {
  var t = e.className, r = e.style, n = T.useContext(ga), i = n.prefixCls, o = cS();
  return o ? null : /* @__PURE__ */ T.createElement("li", {
    role: "separator",
    className: pe("".concat(i, "-item-divider"), t),
    style: r
  });
}
var Poe = ["className", "title", "eventKey", "children"], Moe = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.className, n = e.title;
  e.eventKey;
  var i = e.children, o = zt(e, Poe), a = T.useContext(ga), s = a.prefixCls, l = "".concat(s, "-item-group");
  return /* @__PURE__ */ T.createElement("li", ze({
    ref: t,
    role: "presentation"
  }, o, {
    onClick: function(c) {
      return c.stopPropagation();
    },
    className: pe(l, r)
  }), /* @__PURE__ */ T.createElement("div", {
    role: "presentation",
    className: "".concat(l, "-title"),
    title: typeof n == "string" ? n : void 0
  }, n), /* @__PURE__ */ T.createElement("ul", {
    role: "group",
    className: "".concat(l, "-list")
  }, i));
}), SP = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.eventKey, n = e.children, i = pv(r), o = CP(n, i), a = cS();
  return a ? o : /* @__PURE__ */ T.createElement(Moe, ze({
    ref: t
  }, Bi(e, ["warnKey"])), o);
});
process.env.NODE_ENV !== "production" && (SP.displayName = "MenuItemGroup");
var Doe = ["label", "children", "key", "type"];
function lR(e, t) {
  var r = t.item, n = t.group, i = t.submenu, o = t.divider;
  return (e || []).map(function(a, s) {
    if (a && xt(a) === "object") {
      var l = a, u = l.label, c = l.children, d = l.key, h = l.type, f = zt(l, Doe), p = d ?? "tmp-".concat(s);
      return c || h === "group" ? h === "group" ? /* @__PURE__ */ T.createElement(n, ze({
        key: p
      }, f, {
        title: u
      }), lR(c, t)) : /* @__PURE__ */ T.createElement(i, ze({
        key: p
      }, f, {
        title: u
      }), lR(c, t)) : h === "divider" ? /* @__PURE__ */ T.createElement(o, ze({
        key: p
      }, f)) : /* @__PURE__ */ T.createElement(r, ze({
        key: p
      }, f), u);
    }
    return null;
  }).filter(function(a) {
    return a;
  });
}
function rF(e, t, r, n) {
  var i = e, o = re({
    divider: r8,
    item: dS,
    group: SP,
    submenu: hS
  }, n);
  return t && (i = lR(t, o)), CP(i, r);
}
var Aoe = ["prefixCls", "rootClassName", "style", "className", "tabIndex", "items", "children", "direction", "id", "mode", "inlineCollapsed", "disabled", "disabledOverflow", "subMenuOpenDelay", "subMenuCloseDelay", "forceSubMenuRender", "defaultOpenKeys", "openKeys", "activeKey", "defaultActiveFirst", "selectable", "multiple", "defaultSelectedKeys", "selectedKeys", "onSelect", "onDeselect", "inlineIndent", "motion", "defaultMotions", "triggerSubMenuAction", "builtinPlacements", "itemIcon", "expandIcon", "overflowedIndicator", "overflowedIndicatorPopupClassName", "getPopupContainer", "onClick", "onOpenChange", "onKeyDown", "openAnimation", "openTransitionName", "_internalRenderMenuItem", "_internalRenderSubMenuItem", "_internalComponents"], cu = [], Ioe = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r, n, i = e, o = i.prefixCls, a = o === void 0 ? "rc-menu" : o, s = i.rootClassName, l = i.style, u = i.className, c = i.tabIndex, d = c === void 0 ? 0 : c, h = i.items, f = i.children, p = i.direction, g = i.id, v = i.mode, m = v === void 0 ? "vertical" : v, y = i.inlineCollapsed, C = i.disabled, S = i.disabledOverflow, b = i.subMenuOpenDelay, w = b === void 0 ? 0.1 : b, x = i.subMenuCloseDelay, E = x === void 0 ? 0.1 : x, R = i.forceSubMenuRender, _ = i.defaultOpenKeys, P = i.openKeys, D = i.activeKey, I = i.defaultActiveFirst, A = i.selectable, O = A === void 0 ? !0 : A, L = i.multiple, N = L === void 0 ? !1 : L, F = i.defaultSelectedKeys, G = i.selectedKeys, M = i.onSelect, V = i.onDeselect, z = i.inlineIndent, k = z === void 0 ? 24 : z, $ = i.motion, W = i.defaultMotions, j = i.triggerSubMenuAction, U = j === void 0 ? "hover" : j, Z = i.builtinPlacements, ee = i.itemIcon, J = i.expandIcon, X = i.overflowedIndicator, Y = X === void 0 ? "..." : X, de = i.overflowedIndicatorPopupClassName, K = i.getPopupContainer, ie = i.onClick, Ce = i.onOpenChange, Te = i.onKeyDown, Ie = i.openAnimation, we = i.openTransitionName, Re = i._internalRenderMenuItem, _e = i._internalRenderSubMenuItem, He = i._internalComponents, Ve = zt(i, Aoe), $e = T.useMemo(function() {
    return [rF(f, h, cu, He), rF(f, h, cu, {})];
  }, [f, h, He]), Je = ue($e, 2), Q = Je[0], ye = Je[1], Ge = T.useState(!1), Pe = ue(Ge, 2), Le = Pe[0], me = Pe[1], De = T.useRef(), qe = coe(g), ht = p === "rtl";
  process.env.NODE_ENV !== "production" && gr(!Ie && !we, "`openAnimation` and `openTransitionName` is removed. Please use `motion` or `defaultMotion` instead.");
  var Tt = Nn(_, {
    value: P,
    postState: function(lr) {
      return lr || cu;
    }
  }), lt = ue(Tt, 2), tt = lt[0], Oe = lt[1], je = function(lr) {
    var _r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    function Tn() {
      Oe(lr), Ce == null || Ce(lr);
    }
    _r ? sq(Tn) : Tn();
  }, pt = T.useState(tt), wt = ue(pt, 2), $r = wt[0], xr = wt[1], Ut = T.useRef(!1), Ht = T.useMemo(function() {
    return (m === "inline" || m === "vertical") && y ? ["vertical", y] : [m, !1];
  }, [m, y]), Lt = ue(Ht, 2), gt = Lt[0], nt = Lt[1], Qt = gt === "inline", kr = T.useState(gt), Kt = ue(kr, 2), Yt = Kt[0], vr = Kt[1], Br = T.useState(nt), yn = ue(Br, 2), $n = yn[0], ni = yn[1];
  T.useEffect(function() {
    vr(gt), ni(nt), Ut.current && (Qt ? Oe($r) : je(cu));
  }, [gt, nt]);
  var q = T.useState(0), ve = ue(q, 2), be = ve[0], Ke = ve[1], vt = be >= Q.length - 1 || Yt !== "horizontal" || S;
  T.useEffect(function() {
    Qt && xr(tt);
  }, [tt]), T.useEffect(function() {
    return Ut.current = !0, function() {
      Ut.current = !1;
    };
  }, []);
  var ut = loe(), mt = ut.registerPath, Pt = ut.unregisterPath, Dr = ut.refreshOverflowKeys, or = ut.isSubPathKey, Ot = ut.getKeyPath, nn = ut.getKeys, ii = ut.getSubPathKeys, Wn = T.useMemo(function() {
    return {
      registerPath: mt,
      unregisterPath: Pt
    };
  }, [mt, Pt]), Ir = T.useMemo(function() {
    return {
      isSubPathKey: or
    };
  }, [or]);
  T.useEffect(function() {
    Dr(vt ? cu : Q.slice(be + 1).map(function(Fr) {
      return Fr.key;
    }));
  }, [be, vt]);
  var ba = Nn(D || I && ((r = Q[0]) === null || r === void 0 ? void 0 : r.key), {
    value: D
  }), rl = ue(ba, 2), oi = rl[0], nl = rl[1], _f = bp(function(Fr) {
    nl(Fr);
  }), ao = bp(function() {
    nl(void 0);
  });
  Nc(t, function() {
    return {
      list: De.current,
      focus: function(lr) {
        var _r, Tn = nn(), Fn = aR(Tn, qe), Ea = Fn.elements, Ra = Fn.key2element, Df = Fn.element2key, ai = vP(De.current, Ea), uu = oi ?? (ai[0] ? Df.get(ai[0]) : (_r = Q.find(function(ol) {
          return !ol.props.disabled;
        })) === null || _r === void 0 ? void 0 : _r.key), si = Ra.get(uu);
        if (uu && si) {
          var Ko;
          si == null || (Ko = si.focus) === null || Ko === void 0 || Ko.call(si, lr);
        }
      }
    };
  });
  var jo = Nn(F || [], {
    value: G,
    // Legacy convert key to array
    postState: function(lr) {
      return Array.isArray(lr) ? lr : lr == null ? cu : [lr];
    }
  }), il = ue(jo, 2), ls = il[0], xa = il[1], us = function(lr) {
    if (O) {
      var _r = lr.key, Tn = ls.includes(_r), Fn;
      N ? Tn ? Fn = ls.filter(function(Ra) {
        return Ra !== _r;
      }) : Fn = [].concat(rt(ls), [_r]) : Fn = [_r], xa(Fn);
      var Ea = re(re({}, lr), {}, {
        selectedKeys: Fn
      });
      Tn ? V == null || V(Ea) : M == null || M(Ea);
    }
    !N && tt.length && Yt !== "inline" && je(cu);
  }, lu = bp(function(Fr) {
    ie == null || ie(D0(Fr)), us(Fr);
  }), cs = bp(function(Fr, lr) {
    var _r = tt.filter(function(Fn) {
      return Fn !== Fr;
    });
    if (lr)
      _r.push(Fr);
    else if (Yt !== "inline") {
      var Tn = ii(Fr);
      _r = _r.filter(function(Fn) {
        return !Tn.has(Fn);
      });
    }
    xh(tt, _r, !0) || je(_r, !0);
  }), Uo = function(lr, _r) {
    var Tn = _r ?? !tt.includes(lr);
    cs(lr, Tn);
  }, Tf = ooe(Yt, oi, ht, qe, De, nn, Ot, nl, Uo, Te);
  T.useEffect(function() {
    me(!0);
  }, []);
  var Pf = T.useMemo(function() {
    return {
      _internalRenderMenuItem: Re,
      _internalRenderSubMenuItem: _e
    };
  }, [Re, _e]), Mf = Yt !== "horizontal" || S ? Q : (
    // Need wrap for overflow dropdown that do not response for open
    Q.map(function(Fr, lr) {
      return (
        // Always wrap provider to avoid sub node re-mount
        /* @__PURE__ */ T.createElement(_g, {
          key: Fr.key,
          overflowDisabled: lr > be
        }, Fr)
      );
    })
  ), id = /* @__PURE__ */ T.createElement(Ds, ze({
    id: g,
    ref: De,
    prefixCls: "".concat(a, "-overflow"),
    component: "ul",
    itemComponent: dS,
    className: pe(a, "".concat(a, "-root"), "".concat(a, "-").concat(Yt), u, (n = {}, te(n, "".concat(a, "-inline-collapsed"), $n), te(n, "".concat(a, "-rtl"), ht), n), s),
    dir: p,
    style: l,
    role: "menu",
    tabIndex: d,
    data: Mf,
    renderRawItem: function(lr) {
      return lr;
    },
    renderRawRest: function(lr) {
      var _r = lr.length, Tn = _r ? Q.slice(-_r) : null;
      return /* @__PURE__ */ T.createElement(hS, {
        eventKey: sR,
        title: Y,
        disabled: vt,
        internalPopupClose: _r === 0,
        popupClassName: de
      }, Tn);
    },
    maxCount: Yt !== "horizontal" || S ? Ds.INVALIDATE : Ds.RESPONSIVE,
    ssr: "full",
    "data-menu-list": !0,
    onVisibleChange: function(lr) {
      Ke(lr);
    },
    onKeyDown: Tf
  }, Ve));
  return /* @__PURE__ */ T.createElement(gP.Provider, {
    value: Pf
  }, /* @__PURE__ */ T.createElement(j5.Provider, {
    value: qe
  }, /* @__PURE__ */ T.createElement(_g, {
    prefixCls: a,
    rootClassName: s,
    mode: Yt,
    openKeys: tt,
    rtl: ht,
    disabled: C,
    motion: Le ? $ : null,
    defaultMotions: Le ? W : null,
    activeKey: oi,
    onActive: _f,
    onInactive: ao,
    selectedKeys: ls,
    inlineIndent: k,
    subMenuOpenDelay: w,
    subMenuCloseDelay: E,
    forceSubMenuRender: R,
    builtinPlacements: Z,
    triggerSubMenuAction: U,
    getPopupContainer: K,
    itemIcon: ee,
    expandIcon: J,
    onItemClick: lu,
    onOpenChange: cs
  }, /* @__PURE__ */ T.createElement(Z5.Provider, {
    value: Ir
  }, id), /* @__PURE__ */ T.createElement("div", {
    style: {
      display: "none"
    },
    "aria-hidden": !0
  }, /* @__PURE__ */ T.createElement(Y5.Provider, {
    value: Wn
  }, ye)))));
}), gv = Ioe;
gv.Item = dS;
gv.SubMenu = hS;
gv.ItemGroup = SP;
gv.Divider = r8;
var Foe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, name: "left", theme: "outlined" }, Loe = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: Foe
  }));
}, n8 = /* @__PURE__ */ T.forwardRef(Loe);
process.env.NODE_ENV !== "production" && (n8.displayName = "LeftOutlined");
var Ooe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "ellipsis", theme: "outlined" }, Noe = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: Ooe
  }));
}, i8 = /* @__PURE__ */ T.forwardRef(Noe);
process.env.NODE_ENV !== "production" && (i8.displayName = "EllipsisOutlined");
var o8 = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(S0, function() {
    var r = 1e3, n = 6e4, i = 36e5, o = "millisecond", a = "second", s = "minute", l = "hour", u = "day", c = "week", d = "month", h = "quarter", f = "year", p = "date", g = "Invalid Date", v = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, m = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, y = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(A) {
      var O = ["th", "st", "nd", "rd"], L = A % 100;
      return "[" + A + (O[(L - 20) % 10] || O[L] || O[0]) + "]";
    } }, C = function(A, O, L) {
      var N = String(A);
      return !N || N.length >= O ? A : "" + Array(O + 1 - N.length).join(L) + A;
    }, S = { s: C, z: function(A) {
      var O = -A.utcOffset(), L = Math.abs(O), N = Math.floor(L / 60), F = L % 60;
      return (O <= 0 ? "+" : "-") + C(N, 2, "0") + ":" + C(F, 2, "0");
    }, m: function A(O, L) {
      if (O.date() < L.date()) return -A(L, O);
      var N = 12 * (L.year() - O.year()) + (L.month() - O.month()), F = O.clone().add(N, d), G = L - F < 0, M = O.clone().add(N + (G ? -1 : 1), d);
      return +(-(N + (L - F) / (G ? F - M : M - F)) || 0);
    }, a: function(A) {
      return A < 0 ? Math.ceil(A) || 0 : Math.floor(A);
    }, p: function(A) {
      return { M: d, y: f, w: c, d: u, D: p, h: l, m: s, s: a, ms: o, Q: h }[A] || String(A || "").toLowerCase().replace(/s$/, "");
    }, u: function(A) {
      return A === void 0;
    } }, b = "en", w = {};
    w[b] = y;
    var x = "$isDayjsObject", E = function(A) {
      return A instanceof D || !(!A || !A[x]);
    }, R = function A(O, L, N) {
      var F;
      if (!O) return b;
      if (typeof O == "string") {
        var G = O.toLowerCase();
        w[G] && (F = G), L && (w[G] = L, F = G);
        var M = O.split("-");
        if (!F && M.length > 1) return A(M[0]);
      } else {
        var V = O.name;
        w[V] = O, F = V;
      }
      return !N && F && (b = F), F || !N && b;
    }, _ = function(A, O) {
      if (E(A)) return A.clone();
      var L = typeof O == "object" ? O : {};
      return L.date = A, L.args = arguments, new D(L);
    }, P = S;
    P.l = R, P.i = E, P.w = function(A, O) {
      return _(A, { locale: O.$L, utc: O.$u, x: O.$x, $offset: O.$offset });
    };
    var D = function() {
      function A(L) {
        this.$L = R(L.locale, null, !0), this.parse(L), this.$x = this.$x || L.x || {}, this[x] = !0;
      }
      var O = A.prototype;
      return O.parse = function(L) {
        this.$d = function(N) {
          var F = N.date, G = N.utc;
          if (F === null) return /* @__PURE__ */ new Date(NaN);
          if (P.u(F)) return /* @__PURE__ */ new Date();
          if (F instanceof Date) return new Date(F);
          if (typeof F == "string" && !/Z$/i.test(F)) {
            var M = F.match(v);
            if (M) {
              var V = M[2] - 1 || 0, z = (M[7] || "0").substring(0, 3);
              return G ? new Date(Date.UTC(M[1], V, M[3] || 1, M[4] || 0, M[5] || 0, M[6] || 0, z)) : new Date(M[1], V, M[3] || 1, M[4] || 0, M[5] || 0, M[6] || 0, z);
            }
          }
          return new Date(F);
        }(L), this.init();
      }, O.init = function() {
        var L = this.$d;
        this.$y = L.getFullYear(), this.$M = L.getMonth(), this.$D = L.getDate(), this.$W = L.getDay(), this.$H = L.getHours(), this.$m = L.getMinutes(), this.$s = L.getSeconds(), this.$ms = L.getMilliseconds();
      }, O.$utils = function() {
        return P;
      }, O.isValid = function() {
        return this.$d.toString() !== g;
      }, O.isSame = function(L, N) {
        var F = _(L);
        return this.startOf(N) <= F && F <= this.endOf(N);
      }, O.isAfter = function(L, N) {
        return _(L) < this.startOf(N);
      }, O.isBefore = function(L, N) {
        return this.endOf(N) < _(L);
      }, O.$g = function(L, N, F) {
        return P.u(L) ? this[N] : this.set(F, L);
      }, O.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, O.valueOf = function() {
        return this.$d.getTime();
      }, O.startOf = function(L, N) {
        var F = this, G = !!P.u(N) || N, M = P.p(L), V = function(ee, J) {
          var X = P.w(F.$u ? Date.UTC(F.$y, J, ee) : new Date(F.$y, J, ee), F);
          return G ? X : X.endOf(u);
        }, z = function(ee, J) {
          return P.w(F.toDate()[ee].apply(F.toDate("s"), (G ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(J)), F);
        }, k = this.$W, $ = this.$M, W = this.$D, j = "set" + (this.$u ? "UTC" : "");
        switch (M) {
          case f:
            return G ? V(1, 0) : V(31, 11);
          case d:
            return G ? V(1, $) : V(0, $ + 1);
          case c:
            var U = this.$locale().weekStart || 0, Z = (k < U ? k + 7 : k) - U;
            return V(G ? W - Z : W + (6 - Z), $);
          case u:
          case p:
            return z(j + "Hours", 0);
          case l:
            return z(j + "Minutes", 1);
          case s:
            return z(j + "Seconds", 2);
          case a:
            return z(j + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, O.endOf = function(L) {
        return this.startOf(L, !1);
      }, O.$set = function(L, N) {
        var F, G = P.p(L), M = "set" + (this.$u ? "UTC" : ""), V = (F = {}, F[u] = M + "Date", F[p] = M + "Date", F[d] = M + "Month", F[f] = M + "FullYear", F[l] = M + "Hours", F[s] = M + "Minutes", F[a] = M + "Seconds", F[o] = M + "Milliseconds", F)[G], z = G === u ? this.$D + (N - this.$W) : N;
        if (G === d || G === f) {
          var k = this.clone().set(p, 1);
          k.$d[V](z), k.init(), this.$d = k.set(p, Math.min(this.$D, k.daysInMonth())).$d;
        } else V && this.$d[V](z);
        return this.init(), this;
      }, O.set = function(L, N) {
        return this.clone().$set(L, N);
      }, O.get = function(L) {
        return this[P.p(L)]();
      }, O.add = function(L, N) {
        var F, G = this;
        L = Number(L);
        var M = P.p(N), V = function($) {
          var W = _(G);
          return P.w(W.date(W.date() + Math.round($ * L)), G);
        };
        if (M === d) return this.set(d, this.$M + L);
        if (M === f) return this.set(f, this.$y + L);
        if (M === u) return V(1);
        if (M === c) return V(7);
        var z = (F = {}, F[s] = n, F[l] = i, F[a] = r, F)[M] || 1, k = this.$d.getTime() + L * z;
        return P.w(k, this);
      }, O.subtract = function(L, N) {
        return this.add(-1 * L, N);
      }, O.format = function(L) {
        var N = this, F = this.$locale();
        if (!this.isValid()) return F.invalidDate || g;
        var G = L || "YYYY-MM-DDTHH:mm:ssZ", M = P.z(this), V = this.$H, z = this.$m, k = this.$M, $ = F.weekdays, W = F.months, j = F.meridiem, U = function(J, X, Y, de) {
          return J && (J[X] || J(N, G)) || Y[X].slice(0, de);
        }, Z = function(J) {
          return P.s(V % 12 || 12, J, "0");
        }, ee = j || function(J, X, Y) {
          var de = J < 12 ? "AM" : "PM";
          return Y ? de.toLowerCase() : de;
        };
        return G.replace(m, function(J, X) {
          return X || function(Y) {
            switch (Y) {
              case "YY":
                return String(N.$y).slice(-2);
              case "YYYY":
                return P.s(N.$y, 4, "0");
              case "M":
                return k + 1;
              case "MM":
                return P.s(k + 1, 2, "0");
              case "MMM":
                return U(F.monthsShort, k, W, 3);
              case "MMMM":
                return U(W, k);
              case "D":
                return N.$D;
              case "DD":
                return P.s(N.$D, 2, "0");
              case "d":
                return String(N.$W);
              case "dd":
                return U(F.weekdaysMin, N.$W, $, 2);
              case "ddd":
                return U(F.weekdaysShort, N.$W, $, 3);
              case "dddd":
                return $[N.$W];
              case "H":
                return String(V);
              case "HH":
                return P.s(V, 2, "0");
              case "h":
                return Z(1);
              case "hh":
                return Z(2);
              case "a":
                return ee(V, z, !0);
              case "A":
                return ee(V, z, !1);
              case "m":
                return String(z);
              case "mm":
                return P.s(z, 2, "0");
              case "s":
                return String(N.$s);
              case "ss":
                return P.s(N.$s, 2, "0");
              case "SSS":
                return P.s(N.$ms, 3, "0");
              case "Z":
                return M;
            }
            return null;
          }(J) || M.replace(":", "");
        });
      }, O.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, O.diff = function(L, N, F) {
        var G, M = this, V = P.p(N), z = _(L), k = (z.utcOffset() - this.utcOffset()) * n, $ = this - z, W = function() {
          return P.m(M, z);
        };
        switch (V) {
          case f:
            G = W() / 12;
            break;
          case d:
            G = W();
            break;
          case h:
            G = W() / 3;
            break;
          case c:
            G = ($ - k) / 6048e5;
            break;
          case u:
            G = ($ - k) / 864e5;
            break;
          case l:
            G = $ / i;
            break;
          case s:
            G = $ / n;
            break;
          case a:
            G = $ / r;
            break;
          default:
            G = $;
        }
        return F ? G : P.a(G);
      }, O.daysInMonth = function() {
        return this.endOf(d).$D;
      }, O.$locale = function() {
        return w[this.$L];
      }, O.locale = function(L, N) {
        if (!L) return this.$L;
        var F = this.clone(), G = R(L, N, !0);
        return G && (F.$L = G), F;
      }, O.clone = function() {
        return P.w(this.$d, this);
      }, O.toDate = function() {
        return new Date(this.valueOf());
      }, O.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, O.toISOString = function() {
        return this.$d.toISOString();
      }, O.toString = function() {
        return this.$d.toUTCString();
      }, A;
    }(), I = D.prototype;
    return _.prototype = I, [["$ms", o], ["$s", a], ["$m", s], ["$H", l], ["$W", u], ["$M", d], ["$y", f], ["$D", p]].forEach(function(A) {
      I[A[1]] = function(O) {
        return this.$g(O, A[0], A[1]);
      };
    }), _.extend = function(A, O) {
      return A.$i || (A(O, D, _), A.$i = !0), _;
    }, _.locale = R, _.isDayjs = E, _.unix = function(A) {
      return _(1e3 * A);
    }, _.en = w[b], _.Ls = w, _.p = {}, _;
  });
})(o8);
var koe = o8.exports;
const Li = /* @__PURE__ */ Uh(koe);
var a8 = { exports: {} };
(function(e, t) {
  (function(r, n) {
    e.exports = n();
  })(S0, function() {
    return function(r, n) {
      var i = n.prototype, o = i.format;
      i.format = function(a) {
        var s = this, l = this.$locale();
        if (!this.isValid()) return o.bind(this)(a);
        var u = this.$utils(), c = (a || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(d) {
          switch (d) {
            case "Q":
              return Math.ceil((s.$M + 1) / 3);
            case "Do":
              return l.ordinal(s.$D);
            case "gggg":
              return s.weekYear();
            case "GGGG":
              return s.isoWeekYear();
            case "wo":
              return l.ordinal(s.week(), "W");
            case "w":
            case "ww":
              return u.s(s.week(), d === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return u.s(s.isoWeek(), d === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return u.s(String(s.$H === 0 ? 24 : s.$H), d === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(s.$d.getTime() / 1e3);
            case "x":
              return s.$d.getTime();
            case "z":
              return "[" + s.offsetName() + "]";
            case "zzz":
              return "[" + s.offsetName("long") + "]";
            default:
              return d;
          }
        });
        return o.bind(this)(c);
      };
    };
  });
})(a8);
var Voe = a8.exports;
const s8 = /* @__PURE__ */ Uh(Voe);
function l8(e) {
  return dn(e, {
    inputAffixPadding: e.paddingXXS
  });
}
const u8 = (e) => {
  const {
    controlHeight: t,
    fontSize: r,
    lineHeight: n,
    lineWidth: i,
    controlHeightSM: o,
    controlHeightLG: a,
    fontSizeLG: s,
    lineHeightLG: l,
    paddingSM: u,
    controlPaddingHorizontalSM: c,
    controlPaddingHorizontal: d,
    colorFillAlter: h,
    colorPrimaryHover: f,
    colorPrimary: p,
    controlOutlineWidth: g,
    controlOutline: v,
    colorErrorOutline: m,
    colorWarningOutline: y,
    colorBgContainer: C
  } = e;
  return {
    paddingBlock: Math.max(Math.round((t - r * n) / 2 * 10) / 10 - i, 0),
    paddingBlockSM: Math.max(Math.round((o - r * n) / 2 * 10) / 10 - i, 0),
    paddingBlockLG: Math.ceil((a - s * l) / 2 * 10) / 10 - i,
    paddingInline: u - i,
    paddingInlineSM: c - i,
    paddingInlineLG: d - i,
    addonBg: h,
    activeBorderColor: p,
    hoverBorderColor: f,
    activeShadow: `0 0 0 ${g}px ${v}`,
    errorActiveShadow: `0 0 0 ${g}px ${m}`,
    warningActiveShadow: `0 0 0 ${g}px ${y}`,
    hoverBg: C,
    activeBg: C,
    inputFontSize: r,
    inputFontSizeLG: s,
    inputFontSizeSM: r
  };
}, Boe = (e) => ({
  borderColor: e.hoverBorderColor,
  backgroundColor: e.hoverBg
}), wP = (e) => ({
  color: e.colorTextDisabled,
  backgroundColor: e.colorBgContainerDisabled,
  borderColor: e.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "input[disabled], textarea[disabled]": {
    cursor: "not-allowed"
  },
  "&:hover:not([disabled])": Object.assign({}, Boe(dn(e, {
    hoverBorderColor: e.colorBorder,
    hoverBg: e.colorBgContainerDisabled
  })))
}), c8 = (e, t) => ({
  background: e.colorBgContainer,
  borderWidth: e.lineWidth,
  borderStyle: e.lineType,
  borderColor: t.borderColor,
  "&:hover": {
    borderColor: t.hoverBorderColor,
    backgroundColor: e.hoverBg
  },
  "&:focus, &:focus-within": {
    borderColor: t.activeBorderColor,
    boxShadow: t.activeShadow,
    outline: 0,
    backgroundColor: e.activeBg
  }
}), nF = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}:not(${e.componentCls}-disabled)`]: Object.assign(Object.assign({}, c8(e, t)), {
    [`${e.componentCls}-prefix, ${e.componentCls}-suffix`]: {
      color: t.affixColor
    }
  }),
  [`&${e.componentCls}-status-${t.status}${e.componentCls}-disabled`]: {
    borderColor: t.borderColor
  }
}), Goe = (e, t) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, c8(e, {
    borderColor: e.colorBorder,
    hoverBorderColor: e.hoverBorderColor,
    activeBorderColor: e.activeBorderColor,
    activeShadow: e.activeShadow
  })), {
    [`&${e.componentCls}-disabled, &[disabled]`]: Object.assign({}, wP(e))
  }), nF(e, {
    status: "error",
    borderColor: e.colorError,
    hoverBorderColor: e.colorErrorBorderHover,
    activeBorderColor: e.colorError,
    activeShadow: e.errorActiveShadow,
    affixColor: e.colorError
  })), nF(e, {
    status: "warning",
    borderColor: e.colorWarning,
    hoverBorderColor: e.colorWarningBorderHover,
    activeBorderColor: e.colorWarning,
    activeShadow: e.warningActiveShadow,
    affixColor: e.colorWarning
  })), t)
}), iF = (e, t) => ({
  [`&${e.componentCls}-group-wrapper-status-${t.status}`]: {
    [`${e.componentCls}-group-addon`]: {
      borderColor: t.addonBorderColor,
      color: t.addonColor
    }
  }
}), Hoe = (e) => ({
  "&-outlined": Object.assign(Object.assign(Object.assign({
    [`${e.componentCls}-group`]: {
      "&-addon": {
        background: e.addonBg,
        border: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    }
  }, iF(e, {
    status: "error",
    addonBorderColor: e.colorError,
    addonColor: e.colorErrorText
  })), iF(e, {
    status: "warning",
    addonBorderColor: e.colorWarning,
    addonColor: e.colorWarningText
  })), {
    [`&${e.componentCls}-group-wrapper-disabled`]: {
      [`${e.componentCls}-group-addon`]: Object.assign({}, wP(e))
    }
  })
}), zoe = (e, t) => {
  const {
    componentCls: r
  } = e;
  return {
    "&-borderless": Object.assign({
      background: "transparent",
      border: "none",
      "&:focus, &:focus-within": {
        outline: "none"
      },
      // >>>>> Disabled
      [`&${r}-disabled, &[disabled]`]: {
        color: e.colorTextDisabled
      },
      // >>>>> Status
      [`&${r}-status-error`]: {
        "&, & input, & textarea": {
          color: e.colorError
        }
      },
      [`&${r}-status-warning`]: {
        "&, & input, & textarea": {
          color: e.colorWarning
        }
      }
    }, t)
  };
}, d8 = (e, t) => ({
  background: t.bg,
  borderWidth: e.lineWidth,
  borderStyle: e.lineType,
  borderColor: "transparent",
  "input&, & input, textarea&, & textarea": {
    color: t == null ? void 0 : t.inputColor
  },
  "&:hover": {
    background: t.hoverBg
  },
  "&:focus, &:focus-within": {
    outline: 0,
    borderColor: t.activeBorderColor,
    backgroundColor: e.activeBg
  }
}), oF = (e, t) => ({
  [`&${e.componentCls}-status-${t.status}:not(${e.componentCls}-disabled)`]: Object.assign(Object.assign({}, d8(e, t)), {
    [`${e.componentCls}-prefix, ${e.componentCls}-suffix`]: {
      color: t.affixColor
    }
  })
}), $oe = (e, t) => ({
  "&-filled": Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, d8(e, {
    bg: e.colorFillTertiary,
    hoverBg: e.colorFillSecondary,
    activeBorderColor: e.colorPrimary
  })), {
    [`&${e.componentCls}-disabled, &[disabled]`]: Object.assign({}, wP(e))
  }), oF(e, {
    status: "error",
    bg: e.colorErrorBg,
    hoverBg: e.colorErrorBgHover,
    activeBorderColor: e.colorError,
    inputColor: e.colorErrorText,
    affixColor: e.colorError
  })), oF(e, {
    status: "warning",
    bg: e.colorWarningBg,
    hoverBg: e.colorWarningBgHover,
    activeBorderColor: e.colorWarning,
    inputColor: e.colorWarningText,
    affixColor: e.colorWarning
  })), t)
}), aF = (e, t) => ({
  [`&${e.componentCls}-group-wrapper-status-${t.status}`]: {
    [`${e.componentCls}-group-addon`]: {
      background: t.addonBg,
      color: t.addonColor
    }
  }
}), Woe = (e) => ({
  "&-filled": Object.assign(Object.assign(Object.assign({
    [`${e.componentCls}-group`]: {
      "&-addon": {
        background: e.colorFillTertiary
      },
      [`${e.componentCls}-filled:not(:focus):not(:focus-within)`]: {
        "&:not(:first-child)": {
          borderInlineStart: `${xe(e.lineWidth)} ${e.lineType} ${e.colorSplit}`
        },
        "&:not(:last-child)": {
          borderInlineEnd: `${xe(e.lineWidth)} ${e.lineType} ${e.colorSplit}`
        }
      }
    }
  }, aF(e, {
    status: "error",
    addonBg: e.colorErrorBg,
    addonColor: e.colorErrorText
  })), aF(e, {
    status: "warning",
    addonBg: e.colorWarningBg,
    addonColor: e.colorWarningText
  })), {
    [`&${e.componentCls}-group-wrapper-disabled`]: {
      [`${e.componentCls}-group`]: {
        "&-addon": {
          background: e.colorFillTertiary,
          color: e.colorTextDisabled
        },
        "&-addon:first-child": {
          borderInlineStart: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderTop: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderBottom: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        },
        "&-addon:last-child": {
          borderInlineEnd: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderTop: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
          borderBottom: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        }
      }
    }
  })
}), joe = (e) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: e,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), h8 = (e) => {
  const {
    paddingBlockLG: t,
    lineHeightLG: r,
    borderRadiusLG: n,
    paddingInlineLG: i
  } = e;
  return {
    padding: `${xe(t)} ${xe(i)}`,
    fontSize: e.inputFontSizeLG,
    lineHeight: r,
    borderRadius: n
  };
}, f8 = (e) => ({
  padding: `${xe(e.paddingBlockSM)} ${xe(e.paddingInlineSM)}`,
  fontSize: e.inputFontSizeSM,
  borderRadius: e.borderRadiusSM
}), p8 = (e) => Object.assign(Object.assign({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${xe(e.paddingBlock)} ${xe(e.paddingInline)}`,
  color: e.colorText,
  fontSize: e.inputFontSize,
  lineHeight: e.lineHeight,
  borderRadius: e.borderRadius,
  transition: `all ${e.motionDurationMid}`
}, joe(e.colorTextPlaceholder)), {
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    // prevent textarea resize from coming out of its container
    height: "auto",
    minHeight: e.controlHeight,
    lineHeight: e.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${e.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": Object.assign({}, h8(e)),
  "&-sm": Object.assign({}, f8(e)),
  // RTL
  "&-rtl, &-textarea-rtl": {
    direction: "rtl"
  }
}), Uoe = (e) => {
  const {
    componentCls: t,
    antCls: r
  } = e;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: e.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${t}, &-lg > ${t}-group-addon`]: Object.assign({}, h8(e)),
    [`&-sm ${t}, &-sm > ${t}-group-addon`]: Object.assign({}, f8(e)),
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&-lg ${r}-select-single ${r}-select-selector`]: {
      height: e.controlHeightLG
    },
    [`&-sm ${r}-select-single ${r}-select-selector`]: {
      height: e.controlHeightSM
    },
    [`> ${t}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${t}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${xe(e.paddingInline)}`,
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.inputFontSize,
        textAlign: "center",
        borderRadius: e.borderRadius,
        transition: `all ${e.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${r}-select`]: {
          margin: `${xe(e.calc(e.paddingBlock).add(1).mul(-1).equal())} ${xe(e.calc(e.paddingInline).mul(-1).equal())}`,
          [`&${r}-select-single:not(${r}-select-customize-input):not(${r}-pagination-size-changer)`]: {
            [`${r}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${xe(e.lineWidth)} ${e.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${r}-select-selector`]: {
              color: e.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${r}-cascader-picker`]: {
          margin: `-9px ${xe(e.calc(e.paddingInline).mul(-1).equal())}`,
          backgroundColor: "transparent",
          [`${r}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      }
    },
    [`${t}`]: {
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${t}:first-child, ${t}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${r}-select ${r}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}-affix-wrapper`]: {
      [`&:not(:first-child) ${t}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${t}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}:last-child, ${t}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${r}-select ${r}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${t}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${t}-search &`]: {
          borderStartStartRadius: e.borderRadius,
          borderEndStartRadius: e.borderRadius
        }
      },
      [`&:not(:first-child), ${t}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${t}-group-compact`]: Object.assign(Object.assign({
      display: "block"
    }, lv()), {
      [`${t}-group-addon, ${t}-group-wrap, > ${t}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: e.lineWidth,
          "&:hover, &:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-flex",
        float: "none",
        verticalAlign: "top",
        // https://github.com/ant-design/ant-design-pro/issues/139
        borderRadius: 0
      },
      [`
        & > ${t}-affix-wrapper,
        & > ${t}-number-affix-wrapper,
        & > ${r}-picker-range
      `]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal(),
        borderInlineEndWidth: e.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${t}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${r}-select > ${r}-select-selector,
      & > ${r}-select-auto-complete ${t},
      & > ${r}-cascader-picker ${t},
      & > ${t}-group-wrapper ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderRadius: 0,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`& > ${r}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${r}-select > ${r}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${r}-select:first-child > ${r}-select-selector,
      & > ${r}-select-auto-complete:first-child ${t},
      & > ${r}-cascader-picker:first-child ${t}`]: {
        borderStartStartRadius: e.borderRadius,
        borderEndStartRadius: e.borderRadius
      },
      [`& > *:last-child,
      & > ${r}-select:last-child > ${r}-select-selector,
      & > ${r}-cascader-picker:last-child ${t},
      & > ${r}-cascader-picker-focused:last-child ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderStartEndRadius: e.borderRadius,
        borderEndEndRadius: e.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${r}-select-auto-complete ${t}`]: {
        verticalAlign: "top"
      },
      [`${t}-group-wrapper + ${t}-group-wrapper`]: {
        marginInlineStart: e.calc(e.lineWidth).mul(-1).equal(),
        [`${t}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${t}-group-wrapper:not(:last-child)`]: {
        [`&${t}-search > ${t}-group`]: {
          [`& > ${t}-group-addon > ${t}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${t}`]: {
            borderStartStartRadius: e.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: e.borderRadius
          }
        }
      }
    })
  };
}, Koe = (e) => {
  const {
    componentCls: t,
    controlHeightSM: r,
    lineWidth: n,
    calc: i
  } = e, a = i(r).sub(i(n).mul(2)).sub(16).div(2).equal();
  return {
    [t]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, Xs(e)), p8(e)), Goe(e)), $oe(e)), zoe(e)), {
      '&[type="color"]': {
        height: e.controlHeight,
        [`&${t}-lg`]: {
          height: e.controlHeightLG
        },
        [`&${t}-sm`]: {
          height: r,
          paddingTop: a,
          paddingBottom: a
        }
      },
      '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
        "-webkit-appearance": "none"
      }
    })
  };
}, Yoe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ========================= Input =========================
    [`${t}-clear-icon`]: {
      margin: 0,
      color: e.colorTextQuaternary,
      fontSize: e.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${e.motionDurationSlow}`,
      "&:hover": {
        color: e.colorTextTertiary
      },
      "&:active": {
        color: e.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${xe(e.inputAffixPadding)}`
      }
    }
  };
}, qoe = (e) => {
  const {
    componentCls: t,
    inputAffixPadding: r,
    colorTextDescription: n,
    motionDurationSlow: i,
    colorIcon: o,
    colorIconHover: a,
    iconCls: s
  } = e;
  return {
    [`${t}-affix-wrapper`]: Object.assign(Object.assign(Object.assign(Object.assign({}, p8(e)), {
      display: "inline-flex",
      [`&:not(${t}-disabled):hover`]: {
        zIndex: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      },
      "&-focused, &:focus": {
        zIndex: 1
      },
      [`> input${t}`]: {
        padding: 0
      },
      [`> input${t}, > textarea${t}`]: {
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        background: "transparent",
        color: "inherit",
        "&::-ms-reveal": {
          display: "none"
        },
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        display: "inline-block",
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: e.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: n
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: e.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: r
        },
        "&-suffix": {
          marginInlineStart: r
        }
      }
    }), Yoe(e)), {
      // password
      [`${s}${t}-password-icon`]: {
        color: o,
        cursor: "pointer",
        transition: `all ${i}`,
        "&:hover": {
          color: a
        }
      }
    })
  };
}, Zoe = (e) => {
  const {
    componentCls: t,
    borderRadiusLG: r,
    borderRadiusSM: n
  } = e;
  return {
    [`${t}-group`]: Object.assign(Object.assign(Object.assign({}, Xs(e)), Uoe(e)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": Object.assign(Object.assign(Object.assign({
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${t}-group-addon`]: {
            borderRadius: r,
            fontSize: e.inputFontSizeLG
          }
        },
        "&-sm": {
          [`${t}-group-addon`]: {
            borderRadius: n
          }
        }
      }, Hoe(e)), Woe(e)), {
        // '&-disabled': {
        //   [`${componentCls}-group-addon`]: {
        //     ...genDisabledStyle(token),
        //   },
        // },
        // Fix the issue of using icons in Space Compact mode
        // https://github.com/ant-design/ant-design/issues/42122
        [`&:not(${t}-compact-first-item):not(${t}-compact-last-item)${t}-compact-item`]: {
          [`${t}, ${t}-group-addon`]: {
            borderRadius: 0
          }
        },
        [`&:not(${t}-compact-last-item)${t}-compact-first-item`]: {
          [`${t}, ${t}-group-addon`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&:not(${t}-compact-first-item)${t}-compact-last-item`]: {
          [`${t}, ${t}-group-addon`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        // Fix the issue of input use show-count param in space compact mode
        // https://github.com/ant-design/ant-design/issues/46872
        [`&:not(${t}-compact-last-item)${t}-compact-item`]: {
          [`${t}-affix-wrapper`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      })
    })
  };
}, Xoe = (e) => {
  const {
    componentCls: t,
    antCls: r
  } = e, n = `${t}-search`;
  return {
    [n]: {
      [`${t}`]: {
        "&:hover, &:focus": {
          borderColor: e.colorPrimaryHover,
          [`+ ${t}-group-addon ${n}-button:not(${r}-btn-primary)`]: {
            borderInlineStartColor: e.colorPrimaryHover
          }
        }
      },
      [`${t}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${t}-lg`]: {
        lineHeight: e.calc(e.lineHeightLG).sub(2e-4).equal()
      },
      [`> ${t}-group`]: {
        [`> ${t}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${n}-button`]: {
            // Fix https://github.com/ant-design/ant-design/issues/47150
            marginInlineEnd: -1,
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: e.borderRadius,
            borderEndEndRadius: e.borderRadius,
            borderEndStartRadius: 0,
            boxShadow: "none"
          },
          [`${n}-button:not(${r}-btn-primary)`]: {
            color: e.colorTextDescription,
            "&:hover": {
              color: e.colorPrimaryHover
            },
            "&:active": {
              color: e.colorPrimaryActive
            },
            [`&${r}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${n}-button`]: {
        height: e.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${n}-button`]: {
        height: e.controlHeightLG
      },
      [`&-small ${n}-button`]: {
        height: e.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${t}-compact-item`]: {
        [`&:not(${t}-compact-last-item)`]: {
          [`${t}-group-addon`]: {
            [`${t}-search-button`]: {
              marginInlineEnd: e.calc(e.lineWidth).mul(-1).equal(),
              borderRadius: 0
            }
          }
        },
        [`&:not(${t}-compact-first-item)`]: {
          [`${t},${t}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${t}-group-addon ${t}-search-button,
        > ${t},
        ${t}-affix-wrapper`]: {
          "&:hover, &:focus, &:active": {
            zIndex: 2
          }
        },
        [`> ${t}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
}, Qoe = (e) => {
  const {
    componentCls: t,
    paddingLG: r
  } = e, n = `${t}-textarea`;
  return {
    [n]: {
      position: "relative",
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${t}`]: {
          height: "100%"
        },
        [`${t}-data-count`]: {
          position: "absolute",
          bottom: e.calc(e.fontSize).mul(e.lineHeight).mul(-1).equal(),
          insetInlineEnd: 0,
          color: e.colorTextDescription,
          whiteSpace: "nowrap",
          pointerEvents: "none"
        }
      },
      [`
        &-allow-clear > ${t},
        &-affix-wrapper${n}-has-feedback ${t}
      `]: {
        paddingInlineEnd: r
      },
      [`&-affix-wrapper${t}-affix-wrapper`]: {
        padding: 0,
        [`> textarea${t}`]: {
          fontSize: "inherit",
          border: "none",
          outline: "none",
          background: "transparent",
          "&:focus": {
            boxShadow: "none !important"
          }
        },
        [`${t}-suffix`]: {
          margin: 0,
          "> *:not(:last-child)": {
            marginInline: 0
          },
          // Clear Icon
          [`${t}-clear-icon`]: {
            position: "absolute",
            insetInlineEnd: e.paddingXS,
            insetBlockStart: e.paddingXS
          },
          // Feedback Icon
          [`${n}-suffix`]: {
            position: "absolute",
            top: 0,
            insetInlineEnd: e.paddingInline,
            bottom: 0,
            zIndex: 1,
            display: "inline-flex",
            alignItems: "center",
            margin: "auto",
            pointerEvents: "none"
          }
        }
      }
    }
  };
}, Joe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-out-of-range`]: {
      [`&, & input, & textarea, ${t}-show-count-suffix, ${t}-data-count`]: {
        color: e.colorError
      }
    }
  };
}, bP = Gi("Input", (e) => {
  const t = dn(e, l8(e));
  return [
    Koe(t),
    Qoe(t),
    qoe(t),
    Zoe(t),
    Xoe(t),
    Joe(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    l5(t)
  ];
}, u8, {
  resetFont: !1
});
var eae = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { tag: "path", attrs: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, name: "plus", theme: "outlined" }, tae = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: eae
  }));
}, g8 = /* @__PURE__ */ T.forwardRef(tae);
process.env.NODE_ENV !== "production" && (g8.displayName = "PlusOutlined");
const fS = /* @__PURE__ */ Xl(null);
var rae = function(t) {
  var r = t.activeTabOffset, n = t.horizontal, i = t.rtl, o = t.indicator, a = o === void 0 ? {} : o, s = a.size, l = a.align, u = l === void 0 ? "center" : l, c = Ee(), d = ue(c, 2), h = d[0], f = d[1], p = le(), g = H.useCallback(function(m) {
    return typeof s == "function" ? s(m) : typeof s == "number" ? s : m;
  }, [s]);
  function v() {
    cn.cancel(p.current);
  }
  return It(function() {
    var m = {};
    if (r)
      if (n) {
        m.width = g(r.width);
        var y = i ? "right" : "left";
        u === "start" && (m[y] = r[y]), u === "center" && (m[y] = r[y] + r.width / 2, m.transform = i ? "translateX(50%)" : "translateX(-50%)"), u === "end" && (m[y] = r[y] + r.width, m.transform = "translateX(-100%)");
      } else
        m.height = g(r.height), u === "start" && (m.top = r.top), u === "center" && (m.top = r.top + r.height / 2, m.transform = "translateY(-50%)"), u === "end" && (m.top = r.top + r.height, m.transform = "translateY(-100%)");
    return v(), p.current = cn(function() {
      f(m);
    }), v;
  }, [r, n, i, u, g]), {
    style: h
  };
}, sF = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function nae(e, t, r) {
  return ct(function() {
    for (var n, i = /* @__PURE__ */ new Map(), o = t.get((n = e[0]) === null || n === void 0 ? void 0 : n.key) || sF, a = o.left + o.width, s = 0; s < e.length; s += 1) {
      var l = e[s].key, u = t.get(l);
      if (!u) {
        var c;
        u = t.get((c = e[s - 1]) === null || c === void 0 ? void 0 : c.key) || sF;
      }
      var d = i.get(l) || re({}, u);
      d.right = a - d.left - d.width, i.set(l, d);
    }
    return i;
  }, [e.map(function(n) {
    return n.key;
  }).join("_"), t, r]);
}
function lF(e, t) {
  var r = T.useRef(e), n = T.useState({}), i = ue(n, 2), o = i[1];
  function a(s) {
    var l = typeof s == "function" ? s(r.current) : s;
    l !== r.current && t(l, r.current), r.current = l, o({});
  }
  return [r.current, a];
}
var iae = 0.1, uF = 0.01, Ky = 20, cF = Math.pow(0.995, Ky);
function oae(e, t) {
  var r = Ee(), n = ue(r, 2), i = n[0], o = n[1], a = Ee(0), s = ue(a, 2), l = s[0], u = s[1], c = Ee(0), d = ue(c, 2), h = d[0], f = d[1], p = Ee(), g = ue(p, 2), v = g[0], m = g[1], y = le();
  function C(R) {
    var _ = R.touches[0], P = _.screenX, D = _.screenY;
    o({
      x: P,
      y: D
    }), window.clearInterval(y.current);
  }
  function S(R) {
    if (i) {
      R.preventDefault();
      var _ = R.touches[0], P = _.screenX, D = _.screenY;
      o({
        x: P,
        y: D
      });
      var I = P - i.x, A = D - i.y;
      t(I, A);
      var O = Date.now();
      u(O), f(O - l), m({
        x: I,
        y: A
      });
    }
  }
  function b() {
    if (i && (o(null), m(null), v)) {
      var R = v.x / h, _ = v.y / h, P = Math.abs(R), D = Math.abs(_);
      if (Math.max(P, D) < iae) return;
      var I = R, A = _;
      y.current = window.setInterval(function() {
        if (Math.abs(I) < uF && Math.abs(A) < uF) {
          window.clearInterval(y.current);
          return;
        }
        I *= cF, A *= cF, t(I * Ky, A * Ky);
      }, Ky);
    }
  }
  var w = le();
  function x(R) {
    var _ = R.deltaX, P = R.deltaY, D = 0, I = Math.abs(_), A = Math.abs(P);
    I === A ? D = w.current === "x" ? _ : P : I > A ? (D = _, w.current = "x") : (D = P, w.current = "y"), t(-D, -D) && R.preventDefault();
  }
  var E = le(null);
  E.current = {
    onTouchStart: C,
    onTouchMove: S,
    onTouchEnd: b,
    onWheel: x
  }, T.useEffect(function() {
    function R(I) {
      E.current.onTouchStart(I);
    }
    function _(I) {
      E.current.onTouchMove(I);
    }
    function P(I) {
      E.current.onTouchEnd(I);
    }
    function D(I) {
      E.current.onWheel(I);
    }
    return document.addEventListener("touchmove", _, {
      passive: !1
    }), document.addEventListener("touchend", P, {
      passive: !0
    }), e.current.addEventListener("touchstart", R, {
      passive: !0
    }), e.current.addEventListener("wheel", D, {
      passive: !1
    }), function() {
      document.removeEventListener("touchmove", _), document.removeEventListener("touchend", P);
    };
  }, []);
}
function v8(e) {
  var t = Ee(0), r = ue(t, 2), n = r[0], i = r[1], o = le(0), a = le();
  return a.current = e, bE(function() {
    var s;
    (s = a.current) === null || s === void 0 || s.call(a);
  }, [n]), function() {
    o.current === n && (o.current += 1, i(o.current));
  };
}
function aae(e) {
  var t = le([]), r = Ee({}), n = ue(r, 2), i = n[1], o = le(typeof e == "function" ? e() : e), a = v8(function() {
    var l = o.current;
    t.current.forEach(function(u) {
      l = u(l);
    }), t.current = [], o.current = l, i({});
  });
  function s(l) {
    t.current.push(l), a();
  }
  return [o.current, s];
}
var dF = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
};
function sae(e, t, r, n, i, o, a) {
  var s = a.tabs, l = a.tabPosition, u = a.rtl, c, d, h;
  return ["top", "bottom"].includes(l) ? (c = "width", d = u ? "right" : "left", h = Math.abs(r)) : (c = "height", d = "top", h = -r), ct(function() {
    if (!s.length)
      return [0, 0];
    for (var f = s.length, p = f, g = 0; g < f; g += 1) {
      var v = e.get(s[g].key) || dF;
      if (v[d] + v[c] > h + t) {
        p = g - 1;
        break;
      }
    }
    for (var m = 0, y = f - 1; y >= 0; y -= 1) {
      var C = e.get(s[y].key) || dF;
      if (C[d] < h) {
        m = y + 1;
        break;
      }
    }
    return m >= p ? [0, 0] : [m, p];
  }, [e, t, n, i, o, h, l, s.map(function(f) {
    return f.key;
  }).join("_"), u]);
}
function hF(e) {
  var t;
  return e instanceof Map ? (t = {}, e.forEach(function(r, n) {
    t[n] = r;
  })) : t = e, JSON.stringify(t);
}
var lae = "TABS_DQ";
function m8(e) {
  return String(e).replace(/"/g, lae);
}
function y8(e, t, r, n) {
  return (
    // Only editable tabs can be removed
    !(!r || // Tabs cannot be removed when disabled
    n || // closable is false
    e === !1 || // If closable is undefined, the remove button should be hidden when closeIcon is null or false
    e === void 0 && (t === !1 || t === null))
  );
}
var C8 = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.editable, i = e.locale, o = e.style;
  return !n || n.showAdd === !1 ? null : /* @__PURE__ */ T.createElement("button", {
    ref: t,
    type: "button",
    className: "".concat(r, "-nav-add"),
    style: o,
    "aria-label": (i == null ? void 0 : i.addAriaLabel) || "Add tab",
    onClick: function(s) {
      n.onEdit("add", {
        event: s
      });
    }
  }, n.addIcon || "+");
}), uR = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.position, n = e.prefixCls, i = e.extra;
  if (!i)
    return null;
  var o, a = {};
  return xt(i) === "object" && !/* @__PURE__ */ T.isValidElement(i) ? a = i : a.right = i, r === "right" && (o = a.right), r === "left" && (o = a.left), o ? /* @__PURE__ */ T.createElement("div", {
    className: "".concat(n, "-extra-content"),
    ref: t
  }, o) : null;
});
process.env.NODE_ENV !== "production" && (uR.displayName = "ExtraContent");
var uae = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.id, i = e.tabs, o = e.locale, a = e.mobile, s = e.more, l = s === void 0 ? {} : s, u = e.style, c = e.className, d = e.editable, h = e.tabBarGutter, f = e.rtl, p = e.removeAriaLabel, g = e.onTabClick, v = e.getPopupContainer, m = e.popupClassName, y = Ee(!1), C = ue(y, 2), S = C[0], b = C[1], w = Ee(null), x = ue(w, 2), E = x[0], R = x[1], _ = l.icon, P = _ === void 0 ? "More" : _, D = "".concat(n, "-more-popup"), I = "".concat(r, "-dropdown"), A = E !== null ? "".concat(D, "-").concat(E) : null, O = o == null ? void 0 : o.dropdownAriaLabel;
  function L(k, $) {
    k.preventDefault(), k.stopPropagation(), d.onEdit("remove", {
      key: $,
      event: k
    });
  }
  var N = /* @__PURE__ */ T.createElement(gv, {
    onClick: function($) {
      var W = $.key, j = $.domEvent;
      g(W, j), b(!1);
    },
    prefixCls: "".concat(I, "-menu"),
    id: D,
    tabIndex: -1,
    role: "listbox",
    "aria-activedescendant": A,
    selectedKeys: [E],
    "aria-label": O !== void 0 ? O : "expanded dropdown"
  }, i.map(function(k) {
    var $ = k.closable, W = k.disabled, j = k.closeIcon, U = k.key, Z = k.label, ee = y8($, j, d, W);
    return /* @__PURE__ */ T.createElement(dS, {
      key: U,
      id: "".concat(D, "-").concat(U),
      role: "option",
      "aria-controls": n && "".concat(n, "-panel-").concat(U),
      disabled: W
    }, /* @__PURE__ */ T.createElement("span", null, Z), ee && /* @__PURE__ */ T.createElement("button", {
      type: "button",
      "aria-label": p || "remove",
      tabIndex: 0,
      className: "".concat(I, "-menu-item-remove"),
      onClick: function(X) {
        X.stopPropagation(), L(X, U);
      }
    }, j || d.removeIcon || "×"));
  }));
  function F(k) {
    for (var $ = i.filter(function(ee) {
      return !ee.disabled;
    }), W = $.findIndex(function(ee) {
      return ee.key === E;
    }) || 0, j = $.length, U = 0; U < j; U += 1) {
      W = (W + k + j) % j;
      var Z = $[W];
      if (!Z.disabled) {
        R(Z.key);
        return;
      }
    }
  }
  function G(k) {
    var $ = k.which;
    if (!S) {
      [Ue.DOWN, Ue.SPACE, Ue.ENTER].includes($) && (b(!0), k.preventDefault());
      return;
    }
    switch ($) {
      case Ue.UP:
        F(-1), k.preventDefault();
        break;
      case Ue.DOWN:
        F(1), k.preventDefault();
        break;
      case Ue.ESC:
        b(!1);
        break;
      case Ue.SPACE:
      case Ue.ENTER:
        E !== null && g(E, k);
        break;
    }
  }
  It(function() {
    var k = document.getElementById(A);
    k && k.scrollIntoView && k.scrollIntoView(!1);
  }, [E]), It(function() {
    S || R(null);
  }, [S]);
  var M = te({}, f ? "marginRight" : "marginLeft", h);
  i.length || (M.visibility = "hidden", M.order = 1);
  var V = pe(te({}, "".concat(I, "-rtl"), f)), z = a ? null : /* @__PURE__ */ T.createElement(Xie, ze({
    prefixCls: I,
    overlay: N,
    visible: i.length ? S : !1,
    onVisibleChange: b,
    overlayClassName: pe(V, m),
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    getPopupContainer: v
  }, l), /* @__PURE__ */ T.createElement("button", {
    type: "button",
    className: "".concat(r, "-nav-more"),
    style: M,
    tabIndex: -1,
    "aria-hidden": "true",
    "aria-haspopup": "listbox",
    "aria-controls": D,
    id: "".concat(n, "-more"),
    "aria-expanded": S,
    onKeyDown: G
  }, P));
  return /* @__PURE__ */ T.createElement("div", {
    className: pe("".concat(r, "-nav-operations"), c),
    style: u,
    ref: t
  }, z, /* @__PURE__ */ T.createElement(C8, {
    prefixCls: r,
    locale: o,
    editable: d
  }));
});
const cae = /* @__PURE__ */ T.memo(uae, function(e, t) {
  return (
    // https://github.com/ant-design/ant-design/issues/32544
    // We'd better remove syntactic sugar in `rc-menu` since this has perf issue
    t.tabMoving
  );
});
var dae = function(t) {
  var r = t.prefixCls, n = t.id, i = t.active, o = t.tab, a = o.key, s = o.label, l = o.disabled, u = o.closeIcon, c = o.icon, d = t.closable, h = t.renderWrapper, f = t.removeAriaLabel, p = t.editable, g = t.onClick, v = t.onFocus, m = t.style, y = "".concat(r, "-tab"), C = y8(d, u, p, l);
  function S(E) {
    l || g(E);
  }
  function b(E) {
    E.preventDefault(), E.stopPropagation(), p.onEdit("remove", {
      key: a,
      event: E
    });
  }
  var w = T.useMemo(function() {
    return c && typeof s == "string" ? /* @__PURE__ */ T.createElement("span", null, s) : s;
  }, [s, c]), x = /* @__PURE__ */ T.createElement("div", {
    key: a,
    "data-node-key": m8(a),
    className: pe(y, te(te(te({}, "".concat(y, "-with-remove"), C), "".concat(y, "-active"), i), "".concat(y, "-disabled"), l)),
    style: m,
    onClick: S
  }, /* @__PURE__ */ T.createElement("div", {
    role: "tab",
    "aria-selected": i,
    id: n && "".concat(n, "-tab-").concat(a),
    className: "".concat(y, "-btn"),
    "aria-controls": n && "".concat(n, "-panel-").concat(a),
    "aria-disabled": l,
    tabIndex: l ? null : 0,
    onClick: function(R) {
      R.stopPropagation(), S(R);
    },
    onKeyDown: function(R) {
      [Ue.SPACE, Ue.ENTER].includes(R.which) && (R.preventDefault(), S(R));
    },
    onFocus: v
  }, c && /* @__PURE__ */ T.createElement("span", {
    className: "".concat(y, "-icon")
  }, c), s && w), C && /* @__PURE__ */ T.createElement("button", {
    type: "button",
    "aria-label": f || "remove",
    tabIndex: 0,
    className: "".concat(y, "-remove"),
    onClick: function(R) {
      R.stopPropagation(), b(R);
    }
  }, u || p.removeIcon || "×"));
  return h ? h(x) : x;
}, hae = function(t, r) {
  var n = t.offsetWidth, i = t.offsetHeight, o = t.offsetTop, a = t.offsetLeft, s = t.getBoundingClientRect(), l = s.width, u = s.height, c = s.x, d = s.y;
  return Math.abs(l - n) < 1 ? [l, u, c - r.x, d - r.y] : [n, i, a, o];
}, gd = function(t) {
  var r = t.current || {}, n = r.offsetWidth, i = n === void 0 ? 0 : n, o = r.offsetHeight, a = o === void 0 ? 0 : o;
  if (t.current) {
    var s = t.current.getBoundingClientRect(), l = s.width, u = s.height;
    if (Math.abs(l - i) < 1)
      return [l, u];
  }
  return [i, a];
}, fm = function(t, r) {
  return t[r ? 0 : 1];
}, fF = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.className, n = e.style, i = e.id, o = e.animated, a = e.activeKey, s = e.rtl, l = e.extra, u = e.editable, c = e.locale, d = e.tabPosition, h = e.tabBarGutter, f = e.children, p = e.onTabClick, g = e.onTabScroll, v = e.indicator, m = T.useContext(fS), y = m.prefixCls, C = m.tabs, S = le(null), b = le(null), w = le(null), x = le(null), E = le(null), R = le(null), _ = le(null), P = d === "top" || d === "bottom", D = lF(0, function(ve, be) {
    P && g && g({
      direction: ve > be ? "left" : "right"
    });
  }), I = ue(D, 2), A = I[0], O = I[1], L = lF(0, function(ve, be) {
    !P && g && g({
      direction: ve > be ? "top" : "bottom"
    });
  }), N = ue(L, 2), F = N[0], G = N[1], M = Ee([0, 0]), V = ue(M, 2), z = V[0], k = V[1], $ = Ee([0, 0]), W = ue($, 2), j = W[0], U = W[1], Z = Ee([0, 0]), ee = ue(Z, 2), J = ee[0], X = ee[1], Y = Ee([0, 0]), de = ue(Y, 2), K = de[0], ie = de[1], Ce = aae(/* @__PURE__ */ new Map()), Te = ue(Ce, 2), Ie = Te[0], we = Te[1], Re = nae(C, Ie, j[0]), _e = fm(z, P), He = fm(j, P), Ve = fm(J, P), $e = fm(K, P), Je = _e < He + Ve, Q = Je ? _e - $e : _e - Ve, ye = "".concat(y, "-nav-operations-hidden"), Ge = 0, Pe = 0;
  P && s ? (Ge = 0, Pe = Math.max(0, He - Q)) : (Ge = Math.min(0, Q - He), Pe = 0);
  function Le(ve) {
    return ve < Ge ? Ge : ve > Pe ? Pe : ve;
  }
  var me = le(null), De = Ee(), qe = ue(De, 2), ht = qe[0], Tt = qe[1];
  function lt() {
    Tt(Date.now());
  }
  function tt() {
    me.current && clearTimeout(me.current);
  }
  oae(x, function(ve, be) {
    function Ke(vt, ut) {
      vt(function(mt) {
        var Pt = Le(mt + ut);
        return Pt;
      });
    }
    return Je ? (P ? Ke(O, ve) : Ke(G, be), tt(), lt(), !0) : !1;
  }), It(function() {
    return tt(), ht && (me.current = setTimeout(function() {
      Tt(0);
    }, 100)), tt;
  }, [ht]);
  var Oe = sae(
    Re,
    // Container
    Q,
    // Transform
    P ? A : F,
    // Tabs
    He,
    // Add
    Ve,
    // Operation
    $e,
    re(re({}, e), {}, {
      tabs: C
    })
  ), je = ue(Oe, 2), pt = je[0], wt = je[1], $r = Mn(function() {
    var ve = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : a, be = Re.get(ve) || {
      width: 0,
      height: 0,
      left: 0,
      right: 0,
      top: 0
    };
    if (P) {
      var Ke = A;
      s ? be.right < A ? Ke = be.right : be.right + be.width > A + Q && (Ke = be.right + be.width - Q) : be.left < -A ? Ke = -be.left : be.left + be.width > -A + Q && (Ke = -(be.left + be.width - Q)), G(0), O(Le(Ke));
    } else {
      var vt = F;
      be.top < -F ? vt = -be.top : be.top + be.height > -F + Q && (vt = -(be.top + be.height - Q)), O(0), G(Le(vt));
    }
  }), xr = {};
  d === "top" || d === "bottom" ? xr[s ? "marginRight" : "marginLeft"] = h : xr.marginTop = h;
  var Ut = C.map(function(ve, be) {
    var Ke = ve.key;
    return /* @__PURE__ */ T.createElement(dae, {
      id: i,
      prefixCls: y,
      key: Ke,
      tab: ve,
      style: be === 0 ? void 0 : xr,
      closable: ve.closable,
      editable: u,
      active: Ke === a,
      renderWrapper: f,
      removeAriaLabel: c == null ? void 0 : c.removeAriaLabel,
      onClick: function(ut) {
        p(Ke, ut);
      },
      onFocus: function() {
        $r(Ke), lt(), x.current && (s || (x.current.scrollLeft = 0), x.current.scrollTop = 0);
      }
    });
  }), Ht = function() {
    return we(function() {
      var be, Ke = /* @__PURE__ */ new Map(), vt = (be = E.current) === null || be === void 0 ? void 0 : be.getBoundingClientRect();
      return C.forEach(function(ut) {
        var mt, Pt = ut.key, Dr = (mt = E.current) === null || mt === void 0 ? void 0 : mt.querySelector('[data-node-key="'.concat(m8(Pt), '"]'));
        if (Dr) {
          var or = hae(Dr, vt), Ot = ue(or, 4), nn = Ot[0], ii = Ot[1], Wn = Ot[2], Ir = Ot[3];
          Ke.set(Pt, {
            width: nn,
            height: ii,
            left: Wn,
            top: Ir
          });
        }
      }), Ke;
    });
  };
  It(function() {
    Ht();
  }, [C.map(function(ve) {
    return ve.key;
  }).join("_")]);
  var Lt = v8(function() {
    var ve = gd(S), be = gd(b), Ke = gd(w);
    k([ve[0] - be[0] - Ke[0], ve[1] - be[1] - Ke[1]]);
    var vt = gd(_);
    X(vt);
    var ut = gd(R);
    ie(ut);
    var mt = gd(E);
    U([mt[0] - vt[0], mt[1] - vt[1]]), Ht();
  }), gt = C.slice(0, pt), nt = C.slice(wt + 1), Qt = [].concat(rt(gt), rt(nt)), kr = Re.get(a), Kt = rae({
    activeTabOffset: kr,
    horizontal: P,
    indicator: v,
    rtl: s
  }), Yt = Kt.style;
  It(function() {
    $r();
  }, [a, Ge, Pe, hF(kr), hF(Re), P]), It(function() {
    Lt();
  }, [s]);
  var vr = !!Qt.length, Br = "".concat(y, "-nav-wrap"), yn, $n, ni, q;
  return P ? s ? ($n = A > 0, yn = A !== Pe) : (yn = A < 0, $n = A !== Ge) : (ni = F < 0, q = F !== Ge), /* @__PURE__ */ T.createElement(la, {
    onResize: Lt
  }, /* @__PURE__ */ T.createElement("div", {
    ref: Kh(t, S),
    role: "tablist",
    className: pe("".concat(y, "-nav"), r),
    style: n,
    onKeyDown: function() {
      lt();
    }
  }, /* @__PURE__ */ T.createElement(uR, {
    ref: b,
    position: "left",
    extra: l,
    prefixCls: y
  }), /* @__PURE__ */ T.createElement(la, {
    onResize: Lt
  }, /* @__PURE__ */ T.createElement("div", {
    className: pe(Br, te(te(te(te({}, "".concat(Br, "-ping-left"), yn), "".concat(Br, "-ping-right"), $n), "".concat(Br, "-ping-top"), ni), "".concat(Br, "-ping-bottom"), q)),
    ref: x
  }, /* @__PURE__ */ T.createElement(la, {
    onResize: Lt
  }, /* @__PURE__ */ T.createElement("div", {
    ref: E,
    className: "".concat(y, "-nav-list"),
    style: {
      transform: "translate(".concat(A, "px, ").concat(F, "px)"),
      transition: ht ? "none" : void 0
    }
  }, Ut, /* @__PURE__ */ T.createElement(C8, {
    ref: _,
    prefixCls: y,
    locale: c,
    editable: u,
    style: re(re({}, Ut.length === 0 ? void 0 : xr), {}, {
      visibility: vr ? "hidden" : null
    })
  }), /* @__PURE__ */ T.createElement("div", {
    className: pe("".concat(y, "-ink-bar"), te({}, "".concat(y, "-ink-bar-animated"), o.inkBar)),
    style: Yt
  }))))), /* @__PURE__ */ T.createElement(cae, ze({}, e, {
    removeAriaLabel: c == null ? void 0 : c.removeAriaLabel,
    ref: R,
    prefixCls: y,
    tabs: Qt,
    className: !vr && ye,
    tabMoving: !!ht
  })), /* @__PURE__ */ T.createElement(uR, {
    ref: w,
    position: "right",
    extra: l,
    prefixCls: y
  })));
}), xP = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.prefixCls, n = e.className, i = e.style, o = e.id, a = e.active, s = e.tabKey, l = e.children;
  return /* @__PURE__ */ T.createElement("div", {
    id: o && "".concat(o, "-panel-").concat(s),
    role: "tabpanel",
    tabIndex: a ? 0 : -1,
    "aria-labelledby": o && "".concat(o, "-tab-").concat(s),
    "aria-hidden": !a,
    style: i,
    className: pe(r, a && "".concat(r, "-active"), n),
    ref: t
  }, l);
});
process.env.NODE_ENV !== "production" && (xP.displayName = "TabPane");
var fae = ["renderTabBar"], pae = ["label", "key"], S8 = function(t) {
  var r = t.renderTabBar, n = zt(t, fae), i = T.useContext(fS), o = i.tabs;
  if (r) {
    var a = re(re({}, n), {}, {
      // Legacy support. We do not use this actually
      panes: o.map(function(s) {
        var l = s.label, u = s.key, c = zt(s, pae);
        return /* @__PURE__ */ T.createElement(xP, ze({
          tab: l,
          key: u,
          tabKey: u
        }, c));
      })
    });
    return r(a, fF);
  }
  return /* @__PURE__ */ T.createElement(fF, n);
};
process.env.NODE_ENV !== "production" && (S8.displayName = "TabNavListWrapper");
var gae = ["key", "forceRender", "style", "className", "destroyInactiveTabPane"], vae = function(t) {
  var r = t.id, n = t.activeKey, i = t.animated, o = t.tabPosition, a = t.destroyInactiveTabPane, s = T.useContext(fS), l = s.prefixCls, u = s.tabs, c = i.tabPane, d = "".concat(l, "-tabpane");
  return /* @__PURE__ */ T.createElement("div", {
    className: pe("".concat(l, "-content-holder"))
  }, /* @__PURE__ */ T.createElement("div", {
    className: pe("".concat(l, "-content"), "".concat(l, "-content-").concat(o), te({}, "".concat(l, "-content-animated"), c))
  }, u.map(function(h) {
    var f = h.key, p = h.forceRender, g = h.style, v = h.className, m = h.destroyInactiveTabPane, y = zt(h, gae), C = f === n;
    return /* @__PURE__ */ T.createElement(ns, ze({
      key: f,
      visible: C,
      forceRender: p,
      removeOnLeave: !!(a || m),
      leavedClassName: "".concat(d, "-hidden")
    }, i.tabPaneMotion), function(S, b) {
      var w = S.style, x = S.className;
      return /* @__PURE__ */ T.createElement(xP, ze({}, y, {
        prefixCls: d,
        id: r,
        tabKey: f,
        animated: c,
        active: C,
        style: re(re({}, g), w),
        className: pe(v, x),
        ref: b
      }));
    });
  })));
};
function mae() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
    inkBar: !0,
    tabPane: !1
  }, t;
  return e === !1 ? t = {
    inkBar: !1,
    tabPane: !1
  } : e === !0 ? t = {
    inkBar: !0,
    tabPane: !1
  } : t = re({
    inkBar: !0
  }, xt(e) === "object" ? e : {}), t.tabPaneMotion && t.tabPane === void 0 && (t.tabPane = !0), !t.tabPaneMotion && t.tabPane && (process.env.NODE_ENV !== "production" && gr(!1, "`animated.tabPane` is true but `animated.tabPaneMotion` is not provided. Motion will not work."), t.tabPane = !1), t;
}
var yae = ["id", "prefixCls", "className", "items", "direction", "activeKey", "defaultActiveKey", "editable", "animated", "tabPosition", "tabBarGutter", "tabBarStyle", "tabBarExtraContent", "locale", "more", "destroyInactiveTabPane", "renderTabBar", "onChange", "onTabClick", "onTabScroll", "getPopupContainer", "popupClassName", "indicator"], pF = 0, w8 = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e.id, n = e.prefixCls, i = n === void 0 ? "rc-tabs" : n, o = e.className, a = e.items, s = e.direction, l = e.activeKey, u = e.defaultActiveKey, c = e.editable, d = e.animated, h = e.tabPosition, f = h === void 0 ? "top" : h, p = e.tabBarGutter, g = e.tabBarStyle, v = e.tabBarExtraContent, m = e.locale, y = e.more, C = e.destroyInactiveTabPane, S = e.renderTabBar, b = e.onChange, w = e.onTabClick, x = e.onTabScroll, E = e.getPopupContainer, R = e.popupClassName, _ = e.indicator, P = zt(e, yae), D = T.useMemo(function() {
    return (a || []).filter(function(K) {
      return K && xt(K) === "object" && "key" in K;
    });
  }, [a]), I = s === "rtl", A = mae(d), O = Ee(!1), L = ue(O, 2), N = L[0], F = L[1];
  It(function() {
    F(_5());
  }, []);
  var G = Nn(function() {
    var K;
    return (K = D[0]) === null || K === void 0 ? void 0 : K.key;
  }, {
    value: l,
    defaultValue: u
  }), M = ue(G, 2), V = M[0], z = M[1], k = Ee(function() {
    return D.findIndex(function(K) {
      return K.key === V;
    });
  }), $ = ue(k, 2), W = $[0], j = $[1];
  It(function() {
    var K = D.findIndex(function(Ce) {
      return Ce.key === V;
    });
    if (K === -1) {
      var ie;
      K = Math.max(0, Math.min(W, D.length - 1)), z((ie = D[K]) === null || ie === void 0 ? void 0 : ie.key);
    }
    j(K);
  }, [D.map(function(K) {
    return K.key;
  }).join("_"), V, W]);
  var U = Nn(null, {
    value: r
  }), Z = ue(U, 2), ee = Z[0], J = Z[1];
  It(function() {
    r || (J("rc-tabs-".concat(process.env.NODE_ENV === "test" ? "test" : pF)), pF += 1);
  }, []);
  function X(K, ie) {
    w == null || w(K, ie);
    var Ce = K !== V;
    z(K), Ce && (b == null || b(K));
  }
  var Y = {
    id: ee,
    activeKey: V,
    animated: A,
    tabPosition: f,
    rtl: I,
    mobile: N
  }, de = re(re({}, Y), {}, {
    editable: c,
    locale: m,
    more: y,
    tabBarGutter: p,
    onTabClick: X,
    onTabScroll: x,
    extra: v,
    style: g,
    panes: null,
    getPopupContainer: E,
    popupClassName: R,
    indicator: _
  });
  return /* @__PURE__ */ T.createElement(fS.Provider, {
    value: {
      tabs: D,
      prefixCls: i
    }
  }, /* @__PURE__ */ T.createElement("div", ze({
    ref: t,
    id: r,
    className: pe(i, "".concat(i, "-").concat(f), te(te(te({}, "".concat(i, "-mobile"), N), "".concat(i, "-editable"), c), "".concat(i, "-rtl"), I), o)
  }, P), /* @__PURE__ */ T.createElement(S8, ze({}, de, {
    renderTabBar: S
  })), /* @__PURE__ */ T.createElement(vae, ze({
    destroyInactiveTabPane: C
  }, Y, {
    animated: A
  }))));
});
process.env.NODE_ENV !== "production" && (w8.displayName = "Tabs");
const Cae = {
  motionAppear: !1,
  motionEnter: !0,
  motionLeave: !0
};
function Sae(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inkBar: !0,
    tabPane: !1
  }, r;
  return t === !1 ? r = {
    inkBar: !1,
    tabPane: !1
  } : t === !0 ? r = {
    inkBar: !0,
    tabPane: !0
  } : r = Object.assign({
    inkBar: !0
  }, typeof t == "object" ? t : {}), r.tabPane && (r.tabPaneMotion = Object.assign(Object.assign({}, Cae), {
    motionName: _c(e, "switch")
  })), r;
}
var wae = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function bae(e) {
  return e.filter((t) => t);
}
function xae(e, t) {
  if (process.env.NODE_ENV !== "production" && mn("Tabs").deprecated(!t, "Tabs.TabPane", "items"), e)
    return e;
  const r = Gl(t).map((n) => {
    if (/* @__PURE__ */ T.isValidElement(n)) {
      const {
        key: i,
        props: o
      } = n, a = o || {}, {
        tab: s
      } = a, l = wae(a, ["tab"]);
      return Object.assign(Object.assign({
        key: String(i)
      }, l), {
        label: s
      });
    }
    return null;
  });
  return bae(r);
}
const Eae = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: r
  } = e;
  return [
    {
      [t]: {
        [`${t}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${r}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${r}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [B2(e, "slide-up"), B2(e, "slide-down")]
  ];
}, Rae = (e) => {
  const {
    componentCls: t,
    tabsCardPadding: r,
    cardBg: n,
    cardGutter: i,
    colorBorderSecondary: o,
    itemSelectedColor: a
  } = e;
  return {
    [`${t}-card`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-tab`]: {
          margin: 0,
          padding: r,
          background: n,
          border: `${xe(e.lineWidth)} ${e.lineType} ${o}`,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`
        },
        [`${t}-tab-active`]: {
          color: a,
          background: e.colorBgContainer
        },
        [`${t}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${t}-top, &${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginLeft: {
              _skip_check_: !0,
              value: xe(i)
            }
          }
        }
      },
      [`&${t}-top`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)} 0 0`
          },
          [`${t}-tab-active`]: {
            borderBottomColor: e.colorBgContainer
          }
        }
      },
      [`&${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `0 0 ${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)}`
          },
          [`${t}-tab-active`]: {
            borderTopColor: e.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${t}-left, &${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginTop: xe(i)
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${xe(e.borderRadiusLG)} 0 0 ${xe(e.borderRadiusLG)}`
            }
          },
          [`${t}-tab-active`]: {
            borderRightColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)} 0`
            }
          },
          [`${t}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      }
    }
  };
}, _ae = (e) => {
  const {
    componentCls: t,
    itemHoverColor: r,
    dropdownEdgeChildVerticalPadding: n
  } = e;
  return {
    [`${t}-dropdown`]: Object.assign(Object.assign({}, Xs(e)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: !0,
        value: -9999
      },
      zIndex: e.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${t}-dropdown-menu`]: {
        maxHeight: e.tabsDropdownHeight,
        margin: 0,
        padding: `${xe(n)} 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: !0,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: e.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        "&-item": Object.assign(Object.assign({}, rS), {
          display: "flex",
          alignItems: "center",
          minWidth: e.tabsDropdownWidth,
          margin: 0,
          padding: `${xe(e.paddingXXS)} ${xe(e.paddingSM)}`,
          color: e.colorText,
          fontWeight: "normal",
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          cursor: "pointer",
          transition: `all ${e.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: !0,
              value: e.marginSM
            },
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: r
            }
          },
          "&:hover": {
            background: e.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: e.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
}, Tae = (e) => {
  const {
    componentCls: t,
    margin: r,
    colorBorderSecondary: n,
    horizontalMargin: i,
    verticalItemPadding: o,
    verticalItemMargin: a,
    calc: s
  } = e;
  return {
    // ========================== Top & Bottom ==========================
    [`${t}-top, ${t}-bottom`]: {
      flexDirection: "column",
      [`> ${t}-nav, > div > ${t}-nav`]: {
        margin: i,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: !0,
            value: 0
          },
          left: {
            _skip_check_: !0,
            value: 0
          },
          borderBottom: `${xe(e.lineWidth)} ${e.lineType} ${n}`,
          content: "''"
        },
        [`${t}-ink-bar`]: {
          height: e.lineWidthBold,
          "&-animated": {
            transition: `width ${e.motionDurationSlow}, left ${e.motionDurationSlow},
            right ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: e.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowRight
          },
          [`&${t}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${t}-top`]: {
      [`> ${t}-nav,
        > div > ${t}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${t}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${t}-bottom`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        marginTop: r,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${t}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${t}-left, ${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        flexDirection: "column",
        minWidth: s(e.controlHeight).mul(1.25).equal(),
        // >>>>>>>>>>> Tab
        [`${t}-tab`]: {
          padding: o,
          textAlign: "center"
        },
        [`${t}-tab + ${t}-tab`]: {
          margin: a
        },
        // >>>>>>>>>>> Nav
        [`${t}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: e.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: e.boxShadowTabsOverflowBottom
          },
          [`&${t}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${t}-ink-bar`]: {
          width: e.lineWidthBold,
          "&-animated": {
            transition: `height ${e.motionDurationSlow}, top ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-list, ${t}-nav-operations`]: {
          flex: "1 0 auto",
          // fix safari scroll problem
          flexDirection: "column"
        }
      }
    },
    [`${t}-left`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-ink-bar`]: {
          right: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        marginLeft: {
          _skip_check_: !0,
          value: xe(s(e.lineWidth).mul(-1).equal())
        },
        borderLeft: {
          _skip_check_: !0,
          value: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingLeft: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    },
    [`${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        [`${t}-ink-bar`]: {
          left: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: !0,
          value: s(e.lineWidth).mul(-1).equal()
        },
        borderRight: {
          _skip_check_: !0,
          value: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingRight: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    }
  };
}, Pae = (e) => {
  const {
    componentCls: t,
    cardPaddingSM: r,
    cardPaddingLG: n,
    horizontalItemPaddingSM: i,
    horizontalItemPaddingLG: o
  } = e;
  return {
    [t]: {
      "&-small": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: i,
            fontSize: e.titleFontSizeSM
          }
        }
      },
      "&-large": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: o,
            fontSize: e.titleFontSizeLG
          }
        }
      }
    },
    [`${t}-card`]: {
      [`&${t}-small`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: r
          }
        },
        [`&${t}-bottom`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `0 0 ${xe(e.borderRadius)} ${xe(e.borderRadius)}`
          }
        },
        [`&${t}-top`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `${xe(e.borderRadius)} ${xe(e.borderRadius)} 0 0`
          }
        },
        [`&${t}-right`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${xe(e.borderRadius)} ${xe(e.borderRadius)} 0`
            }
          }
        },
        [`&${t}-left`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${xe(e.borderRadius)} 0 0 ${xe(e.borderRadius)}`
            }
          }
        }
      },
      [`&${t}-large`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: n
          }
        }
      }
    }
  };
}, Mae = (e) => {
  const {
    componentCls: t,
    itemActiveColor: r,
    itemHoverColor: n,
    iconCls: i,
    tabsHorizontalItemMargin: o,
    horizontalItemPadding: a,
    itemSelectedColor: s,
    itemColor: l
  } = e, u = `${t}-tab`;
  return {
    [u]: {
      position: "relative",
      WebkitTouchCallout: "none",
      WebkitTapHighlightColor: "transparent",
      display: "inline-flex",
      alignItems: "center",
      padding: a,
      fontSize: e.titleFontSize,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      color: l,
      "&-btn, &-remove": Object.assign({
        "&:focus:not(:focus-visible), &:active": {
          color: r
        }
      }, nS(e)),
      "&-btn": {
        outline: "none",
        transition: `all ${e.motionDurationSlow}`,
        [`${u}-icon:not(:last-child)`]: {
          marginInlineEnd: e.marginSM
        }
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: !0,
          value: e.calc(e.marginXXS).mul(-1).equal()
        },
        marginLeft: {
          _skip_check_: !0,
          value: e.marginXS
        },
        color: e.colorTextDescription,
        fontSize: e.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      "&:hover": {
        color: n
      },
      [`&${u}-active ${u}-btn`]: {
        color: s,
        textShadow: e.tabsActiveTextShadow
      },
      [`&${u}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${u}-disabled ${u}-btn, &${u}-disabled ${t}-remove`]: {
        "&:focus, &:active": {
          color: e.colorTextDisabled
        }
      },
      [`& ${u}-remove ${i}`]: {
        margin: 0
      },
      [`${i}:not(:last-child)`]: {
        marginRight: {
          _skip_check_: !0,
          value: e.marginSM
        }
      }
    },
    [`${u} + ${u}`]: {
      margin: {
        _skip_check_: !0,
        value: o
      }
    }
  };
}, Dae = (e) => {
  const {
    componentCls: t,
    tabsHorizontalItemMarginRTL: r,
    iconCls: n,
    cardGutter: i,
    calc: o
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl",
      [`${t}-nav`]: {
        [`${t}-tab`]: {
          margin: {
            _skip_check_: !0,
            value: r
          },
          [`${t}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          },
          [n]: {
            marginRight: {
              _skip_check_: !0,
              value: 0
            },
            marginLeft: {
              _skip_check_: !0,
              value: xe(e.marginSM)
            }
          },
          [`${t}-tab-remove`]: {
            marginRight: {
              _skip_check_: !0,
              value: xe(e.marginXS)
            },
            marginLeft: {
              _skip_check_: !0,
              value: xe(o(e.marginXXS).mul(-1).equal())
            },
            [n]: {
              margin: 0
            }
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav`]: {
          order: 1
        },
        [`> ${t}-content-holder`]: {
          order: 0
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav`]: {
          order: 0
        },
        [`> ${t}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${t}-card${t}-top, &${t}-card${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginRight: {
              _skip_check_: !0,
              value: i
            },
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          }
        }
      }
    },
    [`${t}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${t}-menu-item`]: {
      [`${t}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: !0,
          value: "right"
        }
      }
    }
  };
}, Aae = (e) => {
  const {
    componentCls: t,
    tabsCardPadding: r,
    cardHeight: n,
    cardGutter: i,
    itemHoverColor: o,
    itemActiveColor: a,
    colorBorderSecondary: s
  } = e;
  return {
    [t]: Object.assign(Object.assign(Object.assign(Object.assign({}, Xs(e)), {
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${t}-nav, > div > ${t}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${t}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // Fix chrome render bug
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${e.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${t}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${e.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${t}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${t}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${t}-nav-more`]: {
          position: "relative",
          padding: r,
          background: "transparent",
          border: 0,
          color: e.colorText,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: !0,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.calc(e.controlHeightLG).div(8).equal(),
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${t}-nav-add`]: Object.assign({
          minWidth: n,
          minHeight: n,
          marginLeft: {
            _skip_check_: !0,
            value: i
          },
          padding: `0 ${xe(e.paddingXS)}`,
          background: "transparent",
          border: `${xe(e.lineWidth)} ${e.lineType} ${s}`,
          borderRadius: `${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)} 0 0`,
          outline: "none",
          cursor: "pointer",
          color: e.colorText,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`,
          "&:hover": {
            color: o
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: a
          }
        }, nS(e))
      },
      [`${t}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${t}-ink-bar`]: {
        position: "absolute",
        background: e.inkBarColor,
        pointerEvents: "none"
      }
    }), Mae(e)), {
      // =========================== TabPanes ===========================
      [`${t}-content`]: {
        position: "relative",
        width: "100%"
      },
      [`${t}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${t}-tabpane`]: {
        outline: "none",
        "&-hidden": {
          display: "none"
        }
      }
    }),
    [`${t}-centered`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-nav-wrap`]: {
          [`&:not([class*='${t}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
}, Iae = (e) => {
  const t = e.controlHeightLG;
  return {
    zIndexPopup: e.zIndexPopupBase + 50,
    cardBg: e.colorFillAlter,
    cardHeight: t,
    // Initialize with empty string, because cardPadding will be calculated with cardHeight by default.
    cardPadding: `${(t - Math.round(e.fontSize * e.lineHeight)) / 2 - e.lineWidth}px ${e.padding}px`,
    cardPaddingSM: `${e.paddingXXS * 1.5}px ${e.padding}px`,
    cardPaddingLG: `${e.paddingXS}px ${e.padding}px ${e.paddingXXS * 1.5}px`,
    titleFontSize: e.fontSize,
    titleFontSizeLG: e.fontSizeLG,
    titleFontSizeSM: e.fontSize,
    inkBarColor: e.colorPrimary,
    horizontalMargin: `0 0 ${e.margin}px 0`,
    horizontalItemGutter: 32,
    // Fixed Value
    // Initialize with empty string, because horizontalItemMargin will be calculated with horizontalItemGutter by default.
    horizontalItemMargin: "",
    horizontalItemMarginRTL: "",
    horizontalItemPadding: `${e.paddingSM}px 0`,
    horizontalItemPaddingSM: `${e.paddingXS}px 0`,
    horizontalItemPaddingLG: `${e.padding}px 0`,
    verticalItemPadding: `${e.paddingXS}px ${e.paddingLG}px`,
    verticalItemMargin: `${e.margin}px 0 0 0`,
    itemColor: e.colorText,
    itemSelectedColor: e.colorPrimary,
    itemHoverColor: e.colorPrimaryHover,
    itemActiveColor: e.colorPrimaryActive,
    cardGutter: e.marginXXS / 2
  };
}, Fae = Gi("Tabs", (e) => {
  const t = dn(e, {
    // `cardPadding` is empty by default, so we could calculate with dynamic `cardHeight`
    tabsCardPadding: e.cardPadding,
    dropdownEdgeChildVerticalPadding: e.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120,
    tabsHorizontalItemMargin: `0 0 0 ${xe(e.horizontalItemGutter)}`,
    tabsHorizontalItemMarginRTL: `0 0 0 ${xe(e.horizontalItemGutter)}`
  });
  return [Pae(t), Dae(t), Tae(t), _ae(t), Rae(t), Aae(t), Eae(t)];
}, Iae), b8 = () => null;
process.env.NODE_ENV !== "production" && (b8.displayName = "DeprecatedTabPane");
var Lae = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const EP = (e) => {
  var t, r, n, i, o, a, s, l, u, c, d;
  const {
    type: h,
    className: f,
    rootClassName: p,
    size: g,
    onEdit: v,
    hideAdd: m,
    centered: y,
    addIcon: C,
    removeIcon: S,
    moreIcon: b,
    more: w,
    popupClassName: x,
    children: E,
    items: R,
    animated: _,
    style: P,
    indicatorSize: D,
    indicator: I
  } = e, A = Lae(e, ["type", "className", "rootClassName", "size", "onEdit", "hideAdd", "centered", "addIcon", "removeIcon", "moreIcon", "more", "popupClassName", "children", "items", "animated", "style", "indicatorSize", "indicator"]), {
    prefixCls: O
  } = A, {
    direction: L,
    tabs: N,
    getPrefixCls: F,
    getPopupContainer: G
  } = T.useContext(Xt), M = F("tabs", O), V = Xh(M), [z, k, $] = Fae(M, V);
  let W;
  h === "editable-card" && (W = {
    onEdit: (Y, de) => {
      let {
        key: K,
        event: ie
      } = de;
      v == null || v(Y === "add" ? ie : K, Y);
    },
    removeIcon: (t = S ?? (N == null ? void 0 : N.removeIcon)) !== null && t !== void 0 ? t : /* @__PURE__ */ T.createElement(iS, null),
    addIcon: (C ?? (N == null ? void 0 : N.addIcon)) || /* @__PURE__ */ T.createElement(g8, null),
    showAdd: m !== !0
  });
  const j = F();
  if (process.env.NODE_ENV !== "production") {
    const Y = mn("Tabs");
    process.env.NODE_ENV !== "production" && Y(!("onPrevClick" in e) && !("onNextClick" in e), "breaking", "`onPrevClick` and `onNextClick` has been removed. Please use `onTabScroll` instead."), process.env.NODE_ENV !== "production" && Y(!(D || N != null && N.indicatorSize), "deprecated", "`indicatorSize` has been deprecated. Please use `indicator={{ size: ... }}` instead.");
  }
  const U = Gc(g), Z = xae(R, E), ee = Sae(M, _), J = Object.assign(Object.assign({}, N == null ? void 0 : N.style), P), X = {
    align: (r = I == null ? void 0 : I.align) !== null && r !== void 0 ? r : (n = N == null ? void 0 : N.indicator) === null || n === void 0 ? void 0 : n.align,
    size: (s = (o = (i = I == null ? void 0 : I.size) !== null && i !== void 0 ? i : D) !== null && o !== void 0 ? o : (a = N == null ? void 0 : N.indicator) === null || a === void 0 ? void 0 : a.size) !== null && s !== void 0 ? s : N == null ? void 0 : N.indicatorSize
  };
  return z(/* @__PURE__ */ T.createElement(w8, Object.assign({
    direction: L,
    getPopupContainer: G
  }, A, {
    items: Z,
    className: pe({
      [`${M}-${U}`]: U,
      [`${M}-card`]: ["card", "editable-card"].includes(h),
      [`${M}-editable-card`]: h === "editable-card",
      [`${M}-centered`]: y
    }, N == null ? void 0 : N.className, f, p, k, $, V),
    popupClassName: pe(x, k, $, V),
    style: J,
    editable: W,
    more: Object.assign({
      icon: (d = (c = (u = (l = N == null ? void 0 : N.more) === null || l === void 0 ? void 0 : l.icon) !== null && u !== void 0 ? u : N == null ? void 0 : N.moreIcon) !== null && c !== void 0 ? c : b) !== null && d !== void 0 ? d : /* @__PURE__ */ T.createElement(i8, null),
      transitionName: `${j}-slide-up`
    }, w),
    prefixCls: M,
    animated: ee,
    indicator: X
  })));
};
EP.TabPane = b8;
process.env.NODE_ENV !== "production" && (EP.displayName = "Tabs");
var Oae = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const x8 = (e) => {
  var {
    prefixCls: t,
    className: r,
    hoverable: n = !0
  } = e, i = Oae(e, ["prefixCls", "className", "hoverable"]);
  const {
    getPrefixCls: o
  } = T.useContext(Xt), a = o("card", t), s = pe(`${a}-grid`, r, {
    [`${a}-grid-hoverable`]: n
  });
  return /* @__PURE__ */ T.createElement("div", Object.assign({}, i, {
    className: s
  }));
}, Nae = (e) => {
  const {
    antCls: t,
    componentCls: r,
    headerHeight: n,
    cardPaddingBase: i,
    tabsMarginBottom: o
  } = e;
  return Object.assign(Object.assign({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: n,
    marginBottom: -1,
    padding: `0 ${xe(i)}`,
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.headerFontSize,
    background: e.headerBg,
    borderBottom: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorderSecondary}`,
    borderRadius: `${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)} 0 0`
  }, lv()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": Object.assign(Object.assign({
      display: "inline-block",
      flex: 1
    }, rS), {
      [`
          > ${r}-typography,
          > ${r}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${t}-tabs-top`]: {
      clear: "both",
      marginBottom: o,
      color: e.colorText,
      fontWeight: "normal",
      fontSize: e.fontSize,
      "&-bar": {
        borderBottom: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorderSecondary}`
      }
    }
  });
}, kae = (e) => {
  const {
    cardPaddingBase: t,
    colorBorderSecondary: r,
    cardShadow: n,
    lineWidth: i
  } = e;
  return {
    width: "33.33%",
    padding: t,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${xe(i)} 0 0 0 ${r},
      0 ${xe(i)} 0 0 ${r},
      ${xe(i)} ${xe(i)} 0 0 ${r},
      ${xe(i)} 0 0 0 ${r} inset,
      0 ${xe(i)} 0 0 ${r} inset;
    `,
    transition: `all ${e.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: n
    }
  };
}, Vae = (e) => {
  const {
    componentCls: t,
    iconCls: r,
    actionsLiMargin: n,
    cardActionsIconSize: i,
    colorBorderSecondary: o,
    actionsBg: a
  } = e;
  return Object.assign(Object.assign({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: a,
    borderTop: `${xe(e.lineWidth)} ${e.lineType} ${o}`,
    display: "flex",
    borderRadius: `0 0 ${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)}`
  }, lv()), {
    "& > li": {
      margin: n,
      color: e.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: e.calc(e.cardActionsIconSize).mul(2).equal(),
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: e.colorPrimary,
          transition: `color ${e.motionDurationMid}`
        },
        [`a:not(${t}-btn), > ${r}`]: {
          display: "inline-block",
          width: "100%",
          color: e.colorTextDescription,
          lineHeight: xe(e.fontHeight),
          transition: `color ${e.motionDurationMid}`,
          "&:hover": {
            color: e.colorPrimary
          }
        },
        [`> ${r}`]: {
          fontSize: i,
          lineHeight: xe(e.calc(i).mul(e.lineHeight).equal())
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${xe(e.lineWidth)} ${e.lineType} ${o}`
      }
    }
  });
}, Bae = (e) => Object.assign(Object.assign({
  margin: `${xe(e.calc(e.marginXXS).mul(-1).equal())} 0`,
  display: "flex"
}, lv()), {
  "&-avatar": {
    paddingInlineEnd: e.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: e.marginXS
    }
  },
  "&-title": Object.assign({
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.fontSizeLG
  }, rS),
  "&-description": {
    color: e.colorTextDescription
  }
}), Gae = (e) => {
  const {
    componentCls: t,
    cardPaddingBase: r,
    colorFillAlter: n
  } = e;
  return {
    [`${t}-head`]: {
      padding: `0 ${xe(r)}`,
      background: n,
      "&-title": {
        fontSize: e.fontSize
      }
    },
    [`${t}-body`]: {
      padding: `${xe(e.padding)} ${xe(r)}`
    }
  };
}, Hae = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    overflow: "hidden",
    [`${t}-body`]: {
      userSelect: "none"
    }
  };
}, zae = (e) => {
  const {
    antCls: t,
    componentCls: r,
    cardShadow: n,
    cardHeadPadding: i,
    colorBorderSecondary: o,
    boxShadowTertiary: a,
    cardPaddingBase: s,
    extraColor: l
  } = e;
  return {
    [r]: Object.assign(Object.assign({}, Xs(e)), {
      position: "relative",
      background: e.colorBgContainer,
      borderRadius: e.borderRadiusLG,
      [`&:not(${r}-bordered)`]: {
        boxShadow: a
      },
      [`${r}-head`]: Nae(e),
      [`${r}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: l,
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`${r}-body`]: Object.assign({
        padding: s,
        borderRadius: `0 0 ${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)}`
      }, lv()),
      [`${r}-grid`]: kae(e),
      [`${r}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        [`img, img + ${t}-image-mask`]: {
          borderRadius: `${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)} 0 0`
        }
      },
      [`${r}-actions`]: Vae(e),
      [`${r}-meta`]: Bae(e)
    }),
    [`${r}-bordered`]: {
      border: `${xe(e.lineWidth)} ${e.lineType} ${o}`,
      [`${r}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${r}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${e.motionDurationMid}, border-color ${e.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: n
      }
    },
    [`${r}-contain-grid`]: {
      borderRadius: `${xe(e.borderRadiusLG)} ${xe(e.borderRadiusLG)} 0 0 `,
      [`${r}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${r}-loading) ${r}-body`]: {
        marginBlockStart: e.calc(e.lineWidth).mul(-1).equal(),
        marginInlineStart: e.calc(e.lineWidth).mul(-1).equal(),
        padding: 0
      }
    },
    [`${r}-contain-tabs`]: {
      [`> div${r}-head`]: {
        minHeight: 0,
        [`${r}-head-title, ${r}-extra`]: {
          paddingTop: i
        }
      }
    },
    [`${r}-type-inner`]: Gae(e),
    [`${r}-loading`]: Hae(e),
    [`${r}-rtl`]: {
      direction: "rtl"
    }
  };
}, $ae = (e) => {
  const {
    componentCls: t,
    cardPaddingSM: r,
    headerHeightSM: n,
    headerFontSizeSM: i
  } = e;
  return {
    [`${t}-small`]: {
      [`> ${t}-head`]: {
        minHeight: n,
        padding: `0 ${xe(r)}`,
        fontSize: i,
        [`> ${t}-head-wrapper`]: {
          [`> ${t}-extra`]: {
            fontSize: e.fontSize
          }
        }
      },
      [`> ${t}-body`]: {
        padding: r
      }
    },
    [`${t}-small${t}-contain-tabs`]: {
      [`> ${t}-head`]: {
        [`${t}-head-title, ${t}-extra`]: {
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
}, Wae = (e) => ({
  headerBg: "transparent",
  headerFontSize: e.fontSizeLG,
  headerFontSizeSM: e.fontSize,
  headerHeight: e.fontSizeLG * e.lineHeightLG + e.padding * 2,
  headerHeightSM: e.fontSize * e.lineHeight + e.paddingXS * 2,
  actionsBg: e.colorBgContainer,
  actionsLiMargin: `${e.paddingSM}px 0`,
  tabsMarginBottom: -e.padding - e.lineWidth,
  extraColor: e.colorText
}), jae = Gi("Card", (e) => {
  const t = dn(e, {
    cardShadow: e.boxShadowCard,
    cardHeadPadding: e.padding,
    cardPaddingBase: e.paddingLG,
    cardActionsIconSize: e.fontSize,
    cardPaddingSM: 12
    // Fixed padding.
  });
  return [
    // Style
    zae(t),
    // Size
    $ae(t)
  ];
}, Wae);
var gF = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Uae = (e) => {
  const {
    actionClasses: t,
    actions: r = [],
    actionStyle: n
  } = e;
  return /* @__PURE__ */ T.createElement("ul", {
    className: t,
    style: n
  }, r.map((i, o) => {
    const a = `action-${o}`;
    return /* @__PURE__ */ T.createElement("li", {
      style: {
        width: `${100 / r.length}%`
      },
      key: a
    }, /* @__PURE__ */ T.createElement("span", null, i));
  }));
}, Kae = /* @__PURE__ */ T.forwardRef((e, t) => {
  const {
    prefixCls: r,
    className: n,
    rootClassName: i,
    style: o,
    extra: a,
    headStyle: s = {},
    bodyStyle: l = {},
    title: u,
    loading: c,
    bordered: d = !0,
    size: h,
    type: f,
    cover: p,
    actions: g,
    tabList: v,
    children: m,
    activeTabKey: y,
    defaultActiveTabKey: C,
    tabBarExtraContent: S,
    hoverable: b,
    tabProps: w = {},
    classNames: x,
    styles: E
  } = e, R = gF(e, ["prefixCls", "className", "rootClassName", "style", "extra", "headStyle", "bodyStyle", "title", "loading", "bordered", "size", "type", "cover", "actions", "tabList", "children", "activeTabKey", "defaultActiveTabKey", "tabBarExtraContent", "hoverable", "tabProps", "classNames", "styles"]), {
    getPrefixCls: _,
    direction: P,
    card: D
  } = T.useContext(Xt);
  if (process.env.NODE_ENV !== "production") {
    const Ie = mn("Card");
    [["headStyle", "styles.header"], ["bodyStyle", "styles.body"]].forEach((we) => {
      let [Re, _e] = we;
      Ie.deprecated(!(Re in e), Re, _e);
    });
  }
  const I = (Ie) => {
    var we;
    (we = e.onTabChange) === null || we === void 0 || we.call(e, Ie);
  }, A = (Ie) => {
    var we;
    return pe((we = D == null ? void 0 : D.classNames) === null || we === void 0 ? void 0 : we[Ie], x == null ? void 0 : x[Ie]);
  }, O = (Ie) => {
    var we;
    return Object.assign(Object.assign({}, (we = D == null ? void 0 : D.styles) === null || we === void 0 ? void 0 : we[Ie]), E == null ? void 0 : E[Ie]);
  }, L = T.useMemo(() => {
    let Ie = !1;
    return T.Children.forEach(m, (we) => {
      (we == null ? void 0 : we.type) === x8 && (Ie = !0);
    }), Ie;
  }, [m]), N = _("card", r), [F, G, M] = jae(N), V = /* @__PURE__ */ T.createElement(eu, {
    loading: !0,
    active: !0,
    paragraph: {
      rows: 4
    },
    title: !1
  }, m), z = y !== void 0, k = Object.assign(Object.assign({}, w), {
    [z ? "activeKey" : "defaultActiveKey"]: z ? y : C,
    tabBarExtraContent: S
  });
  let $;
  const W = Gc(h), j = !W || W === "default" ? "large" : W, U = v ? /* @__PURE__ */ T.createElement(EP, Object.assign({
    size: j
  }, k, {
    className: `${N}-head-tabs`,
    onChange: I,
    items: v.map((Ie) => {
      var {
        tab: we
      } = Ie, Re = gF(Ie, ["tab"]);
      return Object.assign({
        label: we
      }, Re);
    })
  })) : null;
  if (u || a || U) {
    const Ie = pe(`${N}-head`, A("header")), we = pe(`${N}-head-title`, A("title")), Re = pe(`${N}-extra`, A("extra")), _e = Object.assign(Object.assign({}, s), O("header"));
    $ = /* @__PURE__ */ T.createElement("div", {
      className: Ie,
      style: _e
    }, /* @__PURE__ */ T.createElement("div", {
      className: `${N}-head-wrapper`
    }, u && /* @__PURE__ */ T.createElement("div", {
      className: we,
      style: O("title")
    }, u), a && /* @__PURE__ */ T.createElement("div", {
      className: Re,
      style: O("extra")
    }, a)), U);
  }
  const Z = pe(`${N}-cover`, A("cover")), ee = p ? /* @__PURE__ */ T.createElement("div", {
    className: Z,
    style: O("cover")
  }, p) : null, J = pe(`${N}-body`, A("body")), X = Object.assign(Object.assign({}, l), O("body")), Y = /* @__PURE__ */ T.createElement("div", {
    className: J,
    style: X
  }, c ? V : m), de = pe(`${N}-actions`, A("actions")), K = g != null && g.length ? /* @__PURE__ */ T.createElement(Uae, {
    actionClasses: de,
    actionStyle: O("actions"),
    actions: g
  }) : null, ie = Bi(R, ["onTabChange"]), Ce = pe(N, D == null ? void 0 : D.className, {
    [`${N}-loading`]: c,
    [`${N}-bordered`]: d,
    [`${N}-hoverable`]: b,
    [`${N}-contain-grid`]: L,
    [`${N}-contain-tabs`]: v == null ? void 0 : v.length,
    [`${N}-${W}`]: W,
    [`${N}-type-${f}`]: !!f,
    [`${N}-rtl`]: P === "rtl"
  }, n, i, G, M), Te = Object.assign(Object.assign({}, D == null ? void 0 : D.style), o);
  return F(/* @__PURE__ */ T.createElement("div", Object.assign({
    ref: t
  }, ie, {
    className: Ce,
    style: Te
  }), $, ee, Y, K));
});
var Yae = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const qae = (e) => {
  const {
    prefixCls: t,
    className: r,
    avatar: n,
    title: i,
    description: o
  } = e, a = Yae(e, ["prefixCls", "className", "avatar", "title", "description"]), {
    getPrefixCls: s
  } = T.useContext(Xt), l = s("card", t), u = pe(`${l}-meta`, r), c = n ? /* @__PURE__ */ T.createElement("div", {
    className: `${l}-meta-avatar`
  }, n) : null, d = i ? /* @__PURE__ */ T.createElement("div", {
    className: `${l}-meta-title`
  }, i) : null, h = o ? /* @__PURE__ */ T.createElement("div", {
    className: `${l}-meta-description`
  }, o) : null, f = d || h ? /* @__PURE__ */ T.createElement("div", {
    className: `${l}-meta-detail`
  }, d, h) : null;
  return /* @__PURE__ */ T.createElement("div", Object.assign({}, a, {
    className: u
  }), c, f);
}, Lo = Kae;
Lo.Grid = x8;
Lo.Meta = qae;
process.env.NODE_ENV !== "production" && (Lo.displayName = "Card");
function Zae(e) {
  return !!(e.addonBefore || e.addonAfter);
}
function Xae(e) {
  return !!(e.prefix || e.suffix || e.allowClear);
}
function vF(e, t, r) {
  var n = t.cloneNode(!0), i = Object.create(e, {
    target: {
      value: n
    },
    currentTarget: {
      value: n
    }
  });
  return n.value = r, typeof t.selectionStart == "number" && typeof t.selectionEnd == "number" && (n.selectionStart = t.selectionStart, n.selectionEnd = t.selectionEnd), n.setSelectionRange = function() {
    t.setSelectionRange.apply(t, arguments);
  }, i;
}
function A0(e, t, r, n) {
  if (r) {
    var i = t;
    if (t.type === "click") {
      i = vF(t, e, ""), r(i);
      return;
    }
    if (e.type !== "file" && n !== void 0) {
      i = vF(t, e, n), r(i);
      return;
    }
    r(i);
  }
}
function Qae(e, t) {
  if (e) {
    e.focus(t);
    var r = t || {}, n = r.cursor;
    if (n) {
      var i = e.value.length;
      switch (n) {
        case "start":
          e.setSelectionRange(0, 0);
          break;
        case "end":
          e.setSelectionRange(i, i);
          break;
        default:
          e.setSelectionRange(0, i);
      }
    }
  }
}
var E8 = /* @__PURE__ */ H.forwardRef(function(e, t) {
  var r, n, i = e.inputElement, o = e.children, a = e.prefixCls, s = e.prefix, l = e.suffix, u = e.addonBefore, c = e.addonAfter, d = e.className, h = e.style, f = e.disabled, p = e.readOnly, g = e.focused, v = e.triggerFocus, m = e.allowClear, y = e.value, C = e.handleReset, S = e.hidden, b = e.classes, w = e.classNames, x = e.dataAttrs, E = e.styles, R = e.components, _ = o ?? i, P = (R == null ? void 0 : R.affixWrapper) || "span", D = (R == null ? void 0 : R.groupWrapper) || "span", I = (R == null ? void 0 : R.wrapper) || "span", A = (R == null ? void 0 : R.groupAddon) || "span", O = le(null), L = function(ie) {
    var Ce;
    (Ce = O.current) !== null && Ce !== void 0 && Ce.contains(ie.target) && (v == null || v());
  }, N = Xae(e), F = /* @__PURE__ */ eq(_, {
    value: y,
    className: pe(_.props.className, !N && (w == null ? void 0 : w.variant)) || null
  }), G = le(null);
  if (H.useImperativeHandle(t, function() {
    return {
      nativeElement: G.current || O.current
    };
  }), N) {
    var M, V = null;
    if (m) {
      var z, k = !f && !p && y, $ = "".concat(a, "-clear-icon"), W = xt(m) === "object" && m !== null && m !== void 0 && m.clearIcon ? m.clearIcon : "✖";
      V = /* @__PURE__ */ H.createElement("span", {
        onClick: C,
        onMouseDown: function(ie) {
          return ie.preventDefault();
        },
        className: pe($, (z = {}, te(z, "".concat($, "-hidden"), !k), te(z, "".concat($, "-has-suffix"), !!l), z)),
        role: "button",
        tabIndex: -1
      }, W);
    }
    var j = "".concat(a, "-affix-wrapper"), U = pe(j, (M = {}, te(M, "".concat(a, "-disabled"), f), te(M, "".concat(j, "-disabled"), f), te(M, "".concat(j, "-focused"), g), te(M, "".concat(j, "-readonly"), p), te(M, "".concat(j, "-input-with-clear-btn"), l && m && y), M), b == null ? void 0 : b.affixWrapper, w == null ? void 0 : w.affixWrapper, w == null ? void 0 : w.variant), Z = (l || m) && /* @__PURE__ */ H.createElement("span", {
      className: pe("".concat(a, "-suffix"), w == null ? void 0 : w.suffix),
      style: E == null ? void 0 : E.suffix
    }, V, l);
    F = /* @__PURE__ */ H.createElement(P, ze({
      className: U,
      style: E == null ? void 0 : E.affixWrapper,
      onClick: L
    }, x == null ? void 0 : x.affixWrapper, {
      ref: O
    }), s && /* @__PURE__ */ H.createElement("span", {
      className: pe("".concat(a, "-prefix"), w == null ? void 0 : w.prefix),
      style: E == null ? void 0 : E.prefix
    }, s), F, Z);
  }
  if (Zae(e)) {
    var ee = "".concat(a, "-group"), J = "".concat(ee, "-addon"), X = "".concat(ee, "-wrapper"), Y = pe("".concat(a, "-wrapper"), ee, b == null ? void 0 : b.wrapper, w == null ? void 0 : w.wrapper), de = pe(X, te({}, "".concat(X, "-disabled"), f), b == null ? void 0 : b.group, w == null ? void 0 : w.groupWrapper);
    F = /* @__PURE__ */ H.createElement(D, {
      className: de,
      ref: G
    }, /* @__PURE__ */ H.createElement(I, {
      className: Y
    }, u && /* @__PURE__ */ H.createElement(A, {
      className: J
    }, u), F, c && /* @__PURE__ */ H.createElement(A, {
      className: J
    }, c)));
  }
  return /* @__PURE__ */ H.cloneElement(F, {
    className: pe((r = F.props) === null || r === void 0 ? void 0 : r.className, d) || null,
    style: re(re({}, (n = F.props) === null || n === void 0 ? void 0 : n.style), h),
    hidden: S
  });
}), Jae = ["show"];
function R8(e, t) {
  return T.useMemo(function() {
    var r = {};
    t && (r.show = xt(t) === "object" && t.formatter ? t.formatter : !!t), r = re(re({}, r), e);
    var n = r, i = n.show, o = zt(n, Jae);
    return re(re({}, o), {}, {
      show: !!i,
      showFormatter: typeof i == "function" ? i : void 0,
      strategy: o.strategy || function(a) {
        return a.length;
      }
    });
  }, [e, t]);
}
var ese = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"], tse = /* @__PURE__ */ fn(function(e, t) {
  var r = e.autoComplete, n = e.onChange, i = e.onFocus, o = e.onBlur, a = e.onPressEnter, s = e.onKeyDown, l = e.prefixCls, u = l === void 0 ? "rc-input" : l, c = e.disabled, d = e.htmlSize, h = e.className, f = e.maxLength, p = e.suffix, g = e.showCount, v = e.count, m = e.type, y = m === void 0 ? "text" : m, C = e.classes, S = e.classNames, b = e.styles, w = e.onCompositionStart, x = e.onCompositionEnd, E = zt(e, ese), R = Ee(!1), _ = ue(R, 2), P = _[0], D = _[1], I = le(!1), A = le(null), O = le(null), L = function(_e) {
    A.current && Qae(A.current, _e);
  }, N = Nn(e.defaultValue, {
    value: e.value
  }), F = ue(N, 2), G = F[0], M = F[1], V = G == null ? "" : String(G), z = Ee(null), k = ue(z, 2), $ = k[0], W = k[1], j = R8(v, g), U = j.max || f, Z = j.strategy(V), ee = !!U && Z > U;
  Nc(t, function() {
    var Re;
    return {
      focus: L,
      blur: function() {
        var He;
        (He = A.current) === null || He === void 0 || He.blur();
      },
      setSelectionRange: function(He, Ve, $e) {
        var Je;
        (Je = A.current) === null || Je === void 0 || Je.setSelectionRange(He, Ve, $e);
      },
      select: function() {
        var He;
        (He = A.current) === null || He === void 0 || He.select();
      },
      input: A.current,
      nativeElement: ((Re = O.current) === null || Re === void 0 ? void 0 : Re.nativeElement) || A.current
    };
  }), It(function() {
    D(function(Re) {
      return Re && c ? !1 : Re;
    });
  }, [c]);
  var J = function(_e, He, Ve) {
    var $e = He;
    if (!I.current && j.exceedFormatter && j.max && j.strategy(He) > j.max) {
      if ($e = j.exceedFormatter(He, {
        max: j.max
      }), He !== $e) {
        var Je, Q;
        W([((Je = A.current) === null || Je === void 0 ? void 0 : Je.selectionStart) || 0, ((Q = A.current) === null || Q === void 0 ? void 0 : Q.selectionEnd) || 0]);
      }
    } else if (Ve.source === "compositionEnd")
      return;
    M($e), A.current && A0(A.current, _e, n, $e);
  };
  It(function() {
    if ($) {
      var Re;
      (Re = A.current) === null || Re === void 0 || Re.setSelectionRange.apply(Re, rt($));
    }
  }, [$]);
  var X = function(_e) {
    J(_e, _e.target.value, {
      source: "change"
    });
  }, Y = function(_e) {
    I.current = !1, J(_e, _e.currentTarget.value, {
      source: "compositionEnd"
    }), x == null || x(_e);
  }, de = function(_e) {
    a && _e.key === "Enter" && a(_e), s == null || s(_e);
  }, K = function(_e) {
    D(!0), i == null || i(_e);
  }, ie = function(_e) {
    D(!1), o == null || o(_e);
  }, Ce = function(_e) {
    M(""), L(), A.current && A0(A.current, _e, n);
  }, Te = ee && "".concat(u, "-out-of-range"), Ie = function() {
    var _e = Bi(e, [
      "prefixCls",
      "onPressEnter",
      "addonBefore",
      "addonAfter",
      "prefix",
      "suffix",
      "allowClear",
      // Input elements must be either controlled or uncontrolled,
      // specify either the value prop, or the defaultValue prop, but not both.
      "defaultValue",
      "showCount",
      "count",
      "classes",
      "htmlSize",
      "styles",
      "classNames"
    ]);
    return /* @__PURE__ */ H.createElement("input", ze({
      autoComplete: r
    }, _e, {
      onChange: X,
      onFocus: K,
      onBlur: ie,
      onKeyDown: de,
      className: pe(u, te({}, "".concat(u, "-disabled"), c), S == null ? void 0 : S.input),
      style: b == null ? void 0 : b.input,
      ref: A,
      size: d,
      type: y,
      onCompositionStart: function(Ve) {
        I.current = !0, w == null || w(Ve);
      },
      onCompositionEnd: Y
    }));
  }, we = function() {
    var _e = Number(U) > 0;
    if (p || j.show) {
      var He = j.showFormatter ? j.showFormatter({
        value: V,
        count: Z,
        maxLength: U
      }) : "".concat(Z).concat(_e ? " / ".concat(U) : "");
      return /* @__PURE__ */ H.createElement(H.Fragment, null, j.show && /* @__PURE__ */ H.createElement("span", {
        className: pe("".concat(u, "-show-count-suffix"), te({}, "".concat(u, "-show-count-has-suffix"), !!p), S == null ? void 0 : S.count),
        style: re({}, b == null ? void 0 : b.count)
      }, He), p);
    }
    return null;
  };
  return /* @__PURE__ */ H.createElement(E8, ze({}, E, {
    prefixCls: u,
    className: pe(h, Te),
    handleReset: Ce,
    value: V,
    focused: P,
    triggerFocus: L,
    suffix: we(),
    disabled: c,
    classes: C,
    classNames: S,
    styles: b
  }), Ie());
});
const rse = (e) => {
  const {
    getPrefixCls: t,
    direction: r
  } = rr(Xt), {
    prefixCls: n,
    className: i
  } = e, o = t("input-group", n), a = t("input"), [s, l] = bP(a), u = pe(o, {
    [`${o}-lg`]: e.size === "large",
    [`${o}-sm`]: e.size === "small",
    [`${o}-compact`]: e.compact,
    [`${o}-rtl`]: r === "rtl"
  }, l, i), c = rr(Bs), d = ct(() => Object.assign(Object.assign({}, c), {
    isFormItemInput: !1
  }), [c]);
  return process.env.NODE_ENV !== "production" && mn("Input.Group").deprecated(!1, "Input.Group", "Space.Compact"), s(/* @__PURE__ */ T.createElement("span", {
    className: u,
    style: e.style,
    onMouseEnter: e.onMouseEnter,
    onMouseLeave: e.onMouseLeave,
    onFocus: e.onFocus,
    onBlur: e.onBlur
  }, /* @__PURE__ */ T.createElement(Bs.Provider, {
    value: d
  }, e.children)));
}, _8 = (e) => {
  let t;
  return typeof e == "object" && (e != null && e.clearIcon) ? t = e : e && (t = {
    clearIcon: /* @__PURE__ */ H.createElement(qz, null)
  }), t;
};
function T8(e, t) {
  const r = le([]), n = () => {
    r.current.push(setTimeout(() => {
      var i, o, a, s;
      !((i = e.current) === null || i === void 0) && i.input && ((o = e.current) === null || o === void 0 ? void 0 : o.input.getAttribute("type")) === "password" && (!((a = e.current) === null || a === void 0) && a.input.hasAttribute("value")) && ((s = e.current) === null || s === void 0 || s.input.removeAttribute("value"));
    }));
  };
  return It(() => (t && n(), () => r.current.forEach((i) => {
    i && clearTimeout(i);
  })), []), n;
}
function nse(e) {
  return !!(e.prefix || e.suffix || e.allowClear || e.showCount);
}
var ise = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function ose(e, t) {
  if (!e)
    return;
  e.focus(t);
  const {
    cursor: r
  } = t || {};
  if (r) {
    const n = e.value.length;
    switch (r) {
      case "start":
        e.setSelectionRange(0, 0);
        break;
      case "end":
        e.setSelectionRange(n, n);
        break;
      default:
        e.setSelectionRange(0, n);
    }
  }
}
const vv = /* @__PURE__ */ fn((e, t) => {
  var r;
  const {
    prefixCls: n,
    bordered: i = !0,
    status: o,
    size: a,
    disabled: s,
    onBlur: l,
    onFocus: u,
    suffix: c,
    allowClear: d,
    addonAfter: h,
    addonBefore: f,
    className: p,
    style: g,
    styles: v,
    rootClassName: m,
    onChange: y,
    classNames: C,
    variant: S
  } = e, b = ise(e, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated: K
    } = mn("Input");
    K(!("bordered" in e), "bordered", "variant");
  }
  const {
    getPrefixCls: w,
    direction: x,
    input: E
  } = H.useContext(Xt), R = w("input", n), _ = le(null), P = Xh(R), [D, I, A] = bP(R, P), {
    compactSize: O,
    compactItemClassnames: L
  } = oP(R, x), N = Gc((K) => {
    var ie;
    return (ie = a ?? O) !== null && ie !== void 0 ? ie : K;
  }), F = H.useContext(_h), G = s ?? F, {
    status: M,
    hasFeedback: V,
    feedbackIcon: z
  } = rr(Bs), k = dP(M, o), $ = nse(e) || !!V, W = le($);
  if (process.env.NODE_ENV !== "production") {
    const K = mn("Input");
    It(() => {
      var ie;
      $ && !W.current && process.env.NODE_ENV !== "production" && K(document.activeElement === ((ie = _.current) === null || ie === void 0 ? void 0 : ie.input), "usage", "When Input is focused, dynamic add or remove prefix / suffix will make it lose focus caused by dom structure change. Read more: https://ant.design/components/input/#FAQ"), W.current = $;
    }, [$]);
  }
  const j = T8(_, !0), U = (K) => {
    j(), l == null || l(K);
  }, Z = (K) => {
    j(), u == null || u(K);
  }, ee = (K) => {
    j(), y == null || y(K);
  }, J = (V || c) && /* @__PURE__ */ H.createElement(H.Fragment, null, c, V && z), X = _8(d ?? (E == null ? void 0 : E.allowClear)), [Y, de] = F5("input", S, i);
  return D(/* @__PURE__ */ H.createElement(tse, Object.assign({
    ref: Vo(t, _),
    prefixCls: R,
    autoComplete: E == null ? void 0 : E.autoComplete
  }, b, {
    disabled: G,
    onBlur: U,
    onFocus: Z,
    style: Object.assign(Object.assign({}, E == null ? void 0 : E.style), g),
    styles: Object.assign(Object.assign({}, E == null ? void 0 : E.styles), v),
    suffix: J,
    allowClear: X,
    className: pe(p, m, A, P, L, E == null ? void 0 : E.className),
    onChange: ee,
    addonBefore: f && /* @__PURE__ */ H.createElement(eR, {
      form: !0,
      space: !0
    }, f),
    addonAfter: h && /* @__PURE__ */ H.createElement(eR, {
      form: !0,
      space: !0
    }, h),
    classNames: Object.assign(Object.assign(Object.assign({}, C), E == null ? void 0 : E.classNames), {
      input: pe({
        [`${R}-sm`]: N === "small",
        [`${R}-lg`]: N === "large",
        [`${R}-rtl`]: x === "rtl"
      }, C == null ? void 0 : C.input, (r = E == null ? void 0 : E.classNames) === null || r === void 0 ? void 0 : r.input, I),
      variant: pe({
        [`${R}-${Y}`]: de
      }, rR(R, k)),
      affixWrapper: pe({
        [`${R}-affix-wrapper-sm`]: N === "small",
        [`${R}-affix-wrapper-lg`]: N === "large",
        [`${R}-affix-wrapper-rtl`]: x === "rtl"
      }, I),
      wrapper: pe({
        [`${R}-group-rtl`]: x === "rtl"
      }, I),
      groupWrapper: pe({
        [`${R}-group-wrapper-sm`]: N === "small",
        [`${R}-group-wrapper-lg`]: N === "large",
        [`${R}-group-wrapper-rtl`]: x === "rtl",
        [`${R}-group-wrapper-${Y}`]: de
      }, rR(`${R}-group-wrapper`, k, V), I)
    })
  })));
});
process.env.NODE_ENV !== "production" && (vv.displayName = "Input");
const ase = (e) => {
  const {
    componentCls: t,
    paddingXS: r
  } = e;
  return {
    [`${t}`]: {
      display: "inline-flex",
      alignItems: "center",
      flexWrap: "nowrap",
      columnGap: r,
      "&-rtl": {
        direction: "rtl"
      },
      [`${t}-input`]: {
        textAlign: "center",
        paddingInline: e.paddingXXS
      },
      // ================= Size =================
      [`&${t}-sm ${t}-input`]: {
        paddingInline: e.calc(e.paddingXXS).div(2).equal()
      },
      [`&${t}-lg ${t}-input`]: {
        paddingInline: e.paddingXS
      }
    }
  };
}, sse = Gi(["Input", "OTP"], (e) => {
  const t = dn(e, l8(e));
  return [ase(t)];
}, u8);
var lse = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const use = /* @__PURE__ */ T.forwardRef((e, t) => {
  const {
    value: r,
    onChange: n,
    onActiveChange: i,
    index: o,
    mask: a
  } = e, s = lse(e, ["value", "onChange", "onActiveChange", "index", "mask"]), l = r && typeof a == "string" ? a : r, u = (p) => {
    n(o, p.target.value);
  }, c = T.useRef(null);
  T.useImperativeHandle(t, () => c.current);
  const d = () => {
    cn(() => {
      var p;
      const g = (p = c.current) === null || p === void 0 ? void 0 : p.input;
      document.activeElement === g && g && g.select();
    });
  }, h = (p) => {
    let {
      key: g
    } = p;
    g === "ArrowLeft" ? i(o - 1) : g === "ArrowRight" && i(o + 1), d();
  }, f = (p) => {
    p.key === "Backspace" && !r && i(o - 1), d();
  };
  return /* @__PURE__ */ T.createElement(vv, Object.assign({}, s, {
    ref: c,
    value: l,
    onInput: u,
    onFocus: d,
    onKeyDown: h,
    onKeyUp: f,
    onMouseDown: d,
    onMouseUp: d,
    type: a === !0 ? "password" : "text"
  }));
});
var cse = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function pm(e) {
  return (e || "").split("");
}
const dse = /* @__PURE__ */ T.forwardRef((e, t) => {
  const {
    prefixCls: r,
    length: n = 6,
    size: i,
    defaultValue: o,
    value: a,
    onChange: s,
    formatter: l,
    variant: u,
    disabled: c,
    status: d,
    autoFocus: h,
    mask: f
  } = e, p = cse(e, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "variant", "disabled", "status", "autoFocus", "mask"]);
  if (process.env.NODE_ENV !== "production") {
    const V = mn("Input.OTP");
    process.env.NODE_ENV !== "production" && V(!(typeof f == "string" && f.length > 1), "usage", "`mask` prop should be a single character.");
  }
  const {
    getPrefixCls: g,
    direction: v
  } = T.useContext(Xt), m = g("otp", r), y = oS(p, {
    aria: !0,
    data: !0,
    attr: !0
  }), C = Xh(m), [S, b, w] = sse(m, C), x = Gc((V) => i ?? V), E = T.useContext(Bs), R = dP(E.status, d), _ = T.useMemo(() => Object.assign(Object.assign({}, E), {
    status: R,
    hasFeedback: !1,
    feedbackIcon: null
  }), [E, R]), P = T.useRef(null), D = T.useRef({});
  T.useImperativeHandle(t, () => ({
    focus: () => {
      var V;
      (V = D.current[0]) === null || V === void 0 || V.focus();
    },
    blur: () => {
      var V;
      for (let z = 0; z < n; z += 1)
        (V = D.current[z]) === null || V === void 0 || V.blur();
    },
    nativeElement: P.current
  }));
  const I = (V) => l ? l(V) : V, [A, O] = T.useState(pm(I(o || "")));
  T.useEffect(() => {
    a !== void 0 && O(pm(a));
  }, [a]);
  const L = Mn((V) => {
    O(V), s && V.length === n && V.every((z) => z) && V.some((z, k) => A[k] !== z) && s(V.join(""));
  }), N = Mn((V, z) => {
    let k = rt(A);
    for (let W = 0; W < V; W += 1)
      k[W] || (k[W] = "");
    z.length <= 1 ? k[V] = z : k = k.slice(0, V).concat(pm(z)), k = k.slice(0, n);
    for (let W = k.length - 1; W >= 0 && !k[W]; W -= 1)
      k.pop();
    const $ = I(k.map((W) => W || " ").join(""));
    return k = pm($).map((W, j) => W === " " && !k[j] ? k[j] : W), k;
  }), F = (V, z) => {
    var k;
    const $ = N(V, z), W = Math.min(V + z.length, n - 1);
    W !== V && ((k = D.current[W]) === null || k === void 0 || k.focus()), L($);
  }, G = (V) => {
    var z;
    (z = D.current[V]) === null || z === void 0 || z.focus();
  }, M = {
    variant: u,
    disabled: c,
    status: R,
    mask: f
  };
  return S(/* @__PURE__ */ T.createElement("div", Object.assign({}, y, {
    ref: P,
    className: pe(m, {
      [`${m}-sm`]: x === "small",
      [`${m}-lg`]: x === "large",
      [`${m}-rtl`]: v === "rtl"
    }, w, b)
  }), /* @__PURE__ */ T.createElement(Bs.Provider, {
    value: _
  }, Array.from({
    length: n
  }).map((V, z) => {
    const k = `otp-${z}`, $ = A[z] || "";
    return /* @__PURE__ */ T.createElement(use, Object.assign({
      ref: (W) => {
        D.current[z] = W;
      },
      key: k,
      index: z,
      size: x,
      htmlSize: 1,
      className: `${m}-input`,
      onChange: F,
      value: $,
      onActiveChange: G,
      autoFocus: z === 0 && h
    }, M));
  }))));
});
var hse = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" }, fse = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: hse
  }));
}, P8 = /* @__PURE__ */ T.forwardRef(fse);
process.env.NODE_ENV !== "production" && (P8.displayName = "EyeInvisibleOutlined");
var pse = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" }, gse = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: pse
  }));
}, RP = /* @__PURE__ */ T.forwardRef(gse);
process.env.NODE_ENV !== "production" && (RP.displayName = "EyeOutlined");
var vse = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const mse = (e) => e ? /* @__PURE__ */ T.createElement(RP, null) : /* @__PURE__ */ T.createElement(P8, null), yse = {
  click: "onClick",
  hover: "onMouseOver"
}, M8 = /* @__PURE__ */ T.forwardRef((e, t) => {
  const {
    disabled: r,
    action: n = "click",
    visibilityToggle: i = !0,
    iconRender: o = mse
  } = e, a = typeof i == "object" && i.visible !== void 0, [s, l] = Ee(() => a ? i.visible : !1), u = le(null);
  T.useEffect(() => {
    a && l(i.visible);
  }, [a, i]);
  const c = T8(u), d = () => {
    r || (s && c(), l((E) => {
      var R;
      const _ = !E;
      return typeof i == "object" && ((R = i.onVisibleChange) === null || R === void 0 || R.call(i, _)), _;
    }));
  }, h = (E) => {
    const R = yse[n] || "", _ = o(s), P = {
      [R]: d,
      className: `${E}-icon`,
      key: "passwordIcon",
      onMouseDown: (D) => {
        D.preventDefault();
      },
      onMouseUp: (D) => {
        D.preventDefault();
      }
    };
    return /* @__PURE__ */ T.cloneElement(/* @__PURE__ */ T.isValidElement(_) ? _ : /* @__PURE__ */ T.createElement("span", null, _), P);
  }, {
    className: f,
    prefixCls: p,
    inputPrefixCls: g,
    size: v
  } = e, m = vse(e, ["className", "prefixCls", "inputPrefixCls", "size"]), {
    getPrefixCls: y
  } = T.useContext(Xt), C = y("input", g), S = y("input-password", p), b = i && h(S), w = pe(S, f, {
    [`${S}-${v}`]: !!v
  }), x = Object.assign(Object.assign({}, Bi(m, ["suffix", "iconRender", "visibilityToggle"])), {
    type: s ? "text" : "password",
    className: w,
    prefixCls: C,
    suffix: b
  });
  return v && (x.size = v), /* @__PURE__ */ T.createElement(vv, Object.assign({
    ref: Vo(t, u)
  }, x));
});
process.env.NODE_ENV !== "production" && (M8.displayName = "Input.Password");
var Cse = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const D8 = /* @__PURE__ */ T.forwardRef((e, t) => {
  const {
    prefixCls: r,
    inputPrefixCls: n,
    className: i,
    size: o,
    suffix: a,
    enterButton: s = !1,
    addonAfter: l,
    loading: u,
    disabled: c,
    onSearch: d,
    onChange: h,
    onCompositionStart: f,
    onCompositionEnd: p
  } = e, g = Cse(e, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]), {
    getPrefixCls: v,
    direction: m
  } = T.useContext(Xt), y = T.useRef(!1), C = v("input-search", r), S = v("input", n), {
    compactSize: b
  } = oP(C, m), w = Gc((M) => {
    var V;
    return (V = o ?? b) !== null && V !== void 0 ? V : M;
  }), x = T.useRef(null), E = (M) => {
    M != null && M.target && M.type === "click" && d && d(M.target.value, M, {
      source: "clear"
    }), h == null || h(M);
  }, R = (M) => {
    var V;
    document.activeElement === ((V = x.current) === null || V === void 0 ? void 0 : V.input) && M.preventDefault();
  }, _ = (M) => {
    var V, z;
    d && d((z = (V = x.current) === null || V === void 0 ? void 0 : V.input) === null || z === void 0 ? void 0 : z.value, M, {
      source: "input"
    });
  }, P = (M) => {
    y.current || u || _(M);
  }, D = typeof s == "boolean" ? /* @__PURE__ */ T.createElement(O5, null) : null, I = `${C}-button`;
  let A;
  const O = s || {}, L = O.type && O.type.__ANT_BUTTON === !0;
  L || O.type === "button" ? A = Rc(O, Object.assign({
    onMouseDown: R,
    onClick: (M) => {
      var V, z;
      (z = (V = O == null ? void 0 : O.props) === null || V === void 0 ? void 0 : V.onClick) === null || z === void 0 || z.call(V, M), _(M);
    },
    key: "enterButton"
  }, L ? {
    className: I,
    size: w
  } : {})) : A = /* @__PURE__ */ T.createElement(Qn, {
    className: I,
    type: s ? "primary" : void 0,
    size: w,
    disabled: c,
    key: "enterButton",
    onMouseDown: R,
    onClick: _,
    loading: u,
    icon: D
  }, s), l && (A = [A, Rc(l, {
    key: "addonAfter"
  })]);
  const N = pe(C, {
    [`${C}-rtl`]: m === "rtl",
    [`${C}-${w}`]: !!w,
    [`${C}-with-button`]: !!s
  }, i), F = (M) => {
    y.current = !0, f == null || f(M);
  }, G = (M) => {
    y.current = !1, p == null || p(M);
  };
  return /* @__PURE__ */ T.createElement(vv, Object.assign({
    ref: Vo(x, t),
    onPressEnter: P
  }, g, {
    size: w,
    onCompositionStart: F,
    onCompositionEnd: G,
    prefixCls: S,
    addonAfter: A,
    suffix: a,
    onChange: E,
    className: N,
    disabled: c
  }));
});
process.env.NODE_ENV !== "production" && (D8.displayName = "Search");
var Sse = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, wse = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], Kw = {}, uo;
function bse(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = e.getAttribute("id") || e.getAttribute("data-reactid") || e.getAttribute("name");
  if (t && Kw[r])
    return Kw[r];
  var n = window.getComputedStyle(e), i = n.getPropertyValue("box-sizing") || n.getPropertyValue("-moz-box-sizing") || n.getPropertyValue("-webkit-box-sizing"), o = parseFloat(n.getPropertyValue("padding-bottom")) + parseFloat(n.getPropertyValue("padding-top")), a = parseFloat(n.getPropertyValue("border-bottom-width")) + parseFloat(n.getPropertyValue("border-top-width")), s = wse.map(function(u) {
    return "".concat(u, ":").concat(n.getPropertyValue(u));
  }).join(";"), l = {
    sizingStyle: s,
    paddingSize: o,
    borderSize: a,
    boxSizing: i
  };
  return t && r && (Kw[r] = l), l;
}
function xse(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  uo || (uo = document.createElement("textarea"), uo.setAttribute("tab-index", "-1"), uo.setAttribute("aria-hidden", "true"), document.body.appendChild(uo)), e.getAttribute("wrap") ? uo.setAttribute("wrap", e.getAttribute("wrap")) : uo.removeAttribute("wrap");
  var i = bse(e, t), o = i.paddingSize, a = i.borderSize, s = i.boxSizing, l = i.sizingStyle;
  uo.setAttribute("style", "".concat(l, ";").concat(Sse)), uo.value = e.value || e.placeholder || "";
  var u = void 0, c = void 0, d, h = uo.scrollHeight;
  if (s === "border-box" ? h += a : s === "content-box" && (h -= o), r !== null || n !== null) {
    uo.value = " ";
    var f = uo.scrollHeight - o;
    r !== null && (u = f * r, s === "border-box" && (u = u + o + a), h = Math.max(u, h)), n !== null && (c = f * n, s === "border-box" && (c = c + o + a), d = h > c ? "" : "hidden", h = Math.min(c, h));
  }
  var p = {
    height: h,
    overflowY: d,
    resize: "none"
  };
  return u && (p.minHeight = u), c && (p.maxHeight = c), p;
}
var Ese = ["prefixCls", "onPressEnter", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"], Yw = 0, qw = 1, Zw = 2, Rse = /* @__PURE__ */ T.forwardRef(function(e, t) {
  var r = e, n = r.prefixCls;
  r.onPressEnter;
  var i = r.defaultValue, o = r.value, a = r.autoSize, s = r.onResize, l = r.className, u = r.style, c = r.disabled, d = r.onChange, h = r.onInternalAutoSize, f = zt(r, Ese), p = Nn(i, {
    value: o,
    postState: function(W) {
      return W ?? "";
    }
  }), g = ue(p, 2), v = g[0], m = g[1], y = function(W) {
    m(W.target.value), d == null || d(W);
  }, C = T.useRef();
  T.useImperativeHandle(t, function() {
    return {
      textArea: C.current
    };
  });
  var S = T.useMemo(function() {
    return a && xt(a) === "object" ? [a.minRows, a.maxRows] : [];
  }, [a]), b = ue(S, 2), w = b[0], x = b[1], E = !!a, R = function() {
    try {
      if (document.activeElement === C.current) {
        var W = C.current, j = W.selectionStart, U = W.selectionEnd, Z = W.scrollTop;
        C.current.setSelectionRange(j, U), C.current.scrollTop = Z;
      }
    } catch {
    }
  }, _ = T.useState(Zw), P = ue(_, 2), D = P[0], I = P[1], A = T.useState(), O = ue(A, 2), L = O[0], N = O[1], F = function() {
    I(Yw), process.env.NODE_ENV === "test" && (h == null || h());
  };
  Wr(function() {
    E && F();
  }, [o, w, x, E]), Wr(function() {
    if (D === Yw)
      I(qw);
    else if (D === qw) {
      var $ = xse(C.current, !1, w, x);
      I(Zw), N($);
    } else
      R();
  }, [D]);
  var G = T.useRef(), M = function() {
    cn.cancel(G.current);
  }, V = function(W) {
    D === Zw && (s == null || s(W), a && (M(), G.current = cn(function() {
      F();
    })));
  };
  T.useEffect(function() {
    return M;
  }, []);
  var z = E ? L : null, k = re(re({}, u), z);
  return (D === Yw || D === qw) && (k.overflowY = "hidden", k.overflowX = "hidden"), /* @__PURE__ */ T.createElement(la, {
    onResize: V,
    disabled: !(a || s)
  }, /* @__PURE__ */ T.createElement("textarea", ze({}, f, {
    ref: C,
    style: k,
    className: pe(n, l, te({}, "".concat(n, "-disabled"), c)),
    disabled: c,
    value: v,
    onChange: y
  })));
}), _se = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize", "readOnly"], Tse = /* @__PURE__ */ H.forwardRef(function(e, t) {
  var r, n = e.defaultValue, i = e.value, o = e.onFocus, a = e.onBlur, s = e.onChange, l = e.allowClear, u = e.maxLength, c = e.onCompositionStart, d = e.onCompositionEnd, h = e.suffix, f = e.prefixCls, p = f === void 0 ? "rc-textarea" : f, g = e.showCount, v = e.count, m = e.className, y = e.style, C = e.disabled, S = e.hidden, b = e.classNames, w = e.styles, x = e.onResize, E = e.readOnly, R = zt(e, _se), _ = Nn(n, {
    value: i,
    defaultValue: n
  }), P = ue(_, 2), D = P[0], I = P[1], A = D == null ? "" : String(D), O = H.useState(!1), L = ue(O, 2), N = L[0], F = L[1], G = H.useRef(!1), M = H.useState(null), V = ue(M, 2), z = V[0], k = V[1], $ = le(null), W = le(null), j = function() {
    var Le;
    return (Le = W.current) === null || Le === void 0 ? void 0 : Le.textArea;
  }, U = function() {
    j().focus();
  };
  Nc(t, function() {
    var Pe;
    return {
      resizableTextArea: W.current,
      focus: U,
      blur: function() {
        j().blur();
      },
      nativeElement: ((Pe = $.current) === null || Pe === void 0 ? void 0 : Pe.nativeElement) || j()
    };
  }), It(function() {
    F(function(Pe) {
      return !C && Pe;
    });
  }, [C]);
  var Z = H.useState(null), ee = ue(Z, 2), J = ee[0], X = ee[1];
  H.useEffect(function() {
    if (J) {
      var Pe;
      (Pe = j()).setSelectionRange.apply(Pe, rt(J));
    }
  }, [J]);
  var Y = R8(v, g), de = (r = Y.max) !== null && r !== void 0 ? r : u, K = Number(de) > 0, ie = Y.strategy(A), Ce = !!de && ie > de, Te = function(Le, me) {
    var De = me;
    !G.current && Y.exceedFormatter && Y.max && Y.strategy(me) > Y.max && (De = Y.exceedFormatter(me, {
      max: Y.max
    }), me !== De && X([j().selectionStart || 0, j().selectionEnd || 0])), I(De), A0(Le.currentTarget, Le, s, De);
  }, Ie = function(Le) {
    G.current = !0, c == null || c(Le);
  }, we = function(Le) {
    G.current = !1, Te(Le, Le.currentTarget.value), d == null || d(Le);
  }, Re = function(Le) {
    Te(Le, Le.target.value);
  }, _e = function(Le) {
    var me = R.onPressEnter, De = R.onKeyDown;
    Le.key === "Enter" && me && me(Le), De == null || De(Le);
  }, He = function(Le) {
    F(!0), o == null || o(Le);
  }, Ve = function(Le) {
    F(!1), a == null || a(Le);
  }, $e = function(Le) {
    I(""), U(), A0(j(), Le, s);
  }, Je = h, Q;
  Y.show && (Y.showFormatter ? Q = Y.showFormatter({
    value: A,
    count: ie,
    maxLength: de
  }) : Q = "".concat(ie).concat(K ? " / ".concat(de) : ""), Je = /* @__PURE__ */ H.createElement(H.Fragment, null, Je, /* @__PURE__ */ H.createElement("span", {
    className: pe("".concat(p, "-data-count"), b == null ? void 0 : b.count),
    style: w == null ? void 0 : w.count
  }, Q)));
  var ye = function(Le) {
    var me;
    x == null || x(Le), (me = j()) !== null && me !== void 0 && me.style.height && k(!0);
  }, Ge = !R.autoSize && !g && !l;
  return /* @__PURE__ */ H.createElement(E8, {
    ref: $,
    value: A,
    allowClear: l,
    handleReset: $e,
    suffix: Je,
    prefixCls: p,
    classNames: re(re({}, b), {}, {
      affixWrapper: pe(b == null ? void 0 : b.affixWrapper, te(te({}, "".concat(p, "-show-count"), g), "".concat(p, "-textarea-allow-clear"), l))
    }),
    disabled: C,
    focused: N,
    className: pe(m, Ce && "".concat(p, "-out-of-range")),
    style: re(re({}, y), z && !Ge ? {
      height: "auto"
    } : {}),
    dataAttrs: {
      affixWrapper: {
        "data-count": typeof Q == "string" ? Q : void 0
      }
    },
    hidden: S,
    readOnly: E
  }, /* @__PURE__ */ H.createElement(Rse, ze({}, R, {
    maxLength: u,
    onKeyDown: _e,
    onChange: Re,
    onFocus: He,
    onBlur: Ve,
    onCompositionStart: Ie,
    onCompositionEnd: we,
    className: pe(b == null ? void 0 : b.textarea),
    style: re(re({}, w == null ? void 0 : w.textarea), {}, {
      resize: y == null ? void 0 : y.resize
    }),
    disabled: C,
    prefixCls: p,
    onResize: ye,
    ref: W,
    readOnly: E
  })));
}), Pse = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const _P = /* @__PURE__ */ fn((e, t) => {
  var r, n;
  const {
    prefixCls: i,
    bordered: o = !0,
    size: a,
    disabled: s,
    status: l,
    allowClear: u,
    classNames: c,
    rootClassName: d,
    className: h,
    style: f,
    styles: p,
    variant: g
  } = e, v = Pse(e, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant"]);
  if (process.env.NODE_ENV !== "production") {
    const {
      deprecated: M
    } = mn("TextArea");
    M(!("bordered" in e), "bordered", "variant");
  }
  const {
    getPrefixCls: m,
    direction: y,
    textArea: C
  } = T.useContext(Xt), S = Gc(a), b = T.useContext(_h), w = s ?? b, {
    status: x,
    hasFeedback: E,
    feedbackIcon: R
  } = T.useContext(Bs), _ = dP(x, l), P = T.useRef(null);
  T.useImperativeHandle(t, () => {
    var M;
    return {
      resizableTextArea: (M = P.current) === null || M === void 0 ? void 0 : M.resizableTextArea,
      focus: (V) => {
        var z, k;
        ose((k = (z = P.current) === null || z === void 0 ? void 0 : z.resizableTextArea) === null || k === void 0 ? void 0 : k.textArea, V);
      },
      blur: () => {
        var V;
        return (V = P.current) === null || V === void 0 ? void 0 : V.blur();
      }
    };
  });
  const D = m("input", i), I = Xh(D), [A, O, L] = bP(D, I), [N, F] = F5("textArea", g, o), G = _8(u ?? (C == null ? void 0 : C.allowClear));
  return A(/* @__PURE__ */ T.createElement(Tse, Object.assign({
    autoComplete: C == null ? void 0 : C.autoComplete
  }, v, {
    style: Object.assign(Object.assign({}, C == null ? void 0 : C.style), f),
    styles: Object.assign(Object.assign({}, C == null ? void 0 : C.styles), p),
    disabled: w,
    allowClear: G,
    className: pe(L, I, h, d, C == null ? void 0 : C.className),
    classNames: Object.assign(Object.assign(Object.assign({}, c), C == null ? void 0 : C.classNames), {
      textarea: pe({
        [`${D}-sm`]: S === "small",
        [`${D}-lg`]: S === "large"
      }, O, c == null ? void 0 : c.textarea, (r = C == null ? void 0 : C.classNames) === null || r === void 0 ? void 0 : r.textarea),
      variant: pe({
        [`${D}-${N}`]: F
      }, rR(D, _)),
      affixWrapper: pe(`${D}-textarea-affix-wrapper`, {
        [`${D}-affix-wrapper-rtl`]: y === "rtl",
        [`${D}-affix-wrapper-sm`]: S === "small",
        [`${D}-affix-wrapper-lg`]: S === "large",
        [`${D}-textarea-show-count`]: e.showCount || ((n = e.count) === null || n === void 0 ? void 0 : n.show)
      }, O)
    }),
    prefixCls: D,
    suffix: E && /* @__PURE__ */ T.createElement("span", {
      className: `${D}-textarea-suffix`
    }, R),
    ref: P
  })));
}), Jh = vv;
Jh.Group = rse;
Jh.Search = D8;
Jh.TextArea = _P;
Jh.Password = M8;
Jh.OTP = dse;
function mF(e) {
  return ["small", "middle", "large"].includes(e);
}
const A8 = ["wrap", "nowrap", "wrap-reverse"], I8 = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"], F8 = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"], Mse = (e, t) => {
  const r = t.wrap === !0 ? "wrap" : t.wrap;
  return {
    [`${e}-wrap-${r}`]: r && A8.includes(r)
  };
}, Dse = (e, t) => {
  const r = {};
  return F8.forEach((n) => {
    r[`${e}-align-${n}`] = t.align === n;
  }), r[`${e}-align-stretch`] = !t.align && !!t.vertical, r;
}, Ase = (e, t) => {
  const r = {};
  return I8.forEach((n) => {
    r[`${e}-justify-${n}`] = t.justify === n;
  }), r;
};
function Ise(e, t) {
  return pe(Object.assign(Object.assign(Object.assign({}, Mse(e, t)), Dse(e, t)), Ase(e, t)));
}
const Fse = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "flex",
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      },
      "&:empty": {
        display: "none"
      }
    }
  };
}, Lse = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      "&-gap-small": {
        gap: e.flexGapSM
      },
      "&-gap-middle": {
        gap: e.flexGap
      },
      "&-gap-large": {
        gap: e.flexGapLG
      }
    }
  };
}, Ose = (e) => {
  const {
    componentCls: t
  } = e, r = {};
  return A8.forEach((n) => {
    r[`${t}-wrap-${n}`] = {
      flexWrap: n
    };
  }), r;
}, Nse = (e) => {
  const {
    componentCls: t
  } = e, r = {};
  return F8.forEach((n) => {
    r[`${t}-align-${n}`] = {
      alignItems: n
    };
  }), r;
}, kse = (e) => {
  const {
    componentCls: t
  } = e, r = {};
  return I8.forEach((n) => {
    r[`${t}-justify-${n}`] = {
      justifyContent: n
    };
  }), r;
}, Vse = () => ({}), Bse = Gi("Flex", (e) => {
  const {
    paddingXS: t,
    padding: r,
    paddingLG: n
  } = e, i = dn(e, {
    flexGapSM: t,
    flexGap: r,
    flexGapLG: n
  });
  return [Fse(i), Lse(i), Ose(i), Nse(i), kse(i)];
}, Vse, {
  // Flex component don't apply extra font style
  // https://github.com/ant-design/ant-design/issues/46403
  resetStyle: !1
});
var Gse = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const fr = /* @__PURE__ */ H.forwardRef((e, t) => {
  const {
    prefixCls: r,
    rootClassName: n,
    className: i,
    style: o,
    flex: a,
    gap: s,
    children: l,
    vertical: u = !1,
    component: c = "div"
  } = e, d = Gse(e, ["prefixCls", "rootClassName", "className", "style", "flex", "gap", "children", "vertical", "component"]), {
    flex: h,
    direction: f,
    getPrefixCls: p
  } = H.useContext(Xt), g = p("flex", r), [v, m, y] = Bse(g), C = u ?? (h == null ? void 0 : h.vertical), S = pe(i, n, h == null ? void 0 : h.className, g, m, y, Ise(g, e), {
    [`${g}-rtl`]: f === "rtl",
    [`${g}-gap-${s}`]: mF(s),
    [`${g}-vertical`]: C
  }), b = Object.assign(Object.assign({}, h == null ? void 0 : h.style), o);
  return a && (b.flex = a), s && !mF(s) && (b.gap = s), v(/* @__PURE__ */ H.createElement(c, Object.assign({
    ref: t,
    className: S,
    style: b
  }, Bi(d, ["justify", "wrap", "align"])), l));
});
process.env.NODE_ENV !== "production" && (fr.displayName = "Flex");
function L8() {
  var e = document.documentElement.clientWidth, t = window.innerHeight || document.documentElement.clientHeight;
  return {
    width: e,
    height: t
  };
}
function Hse(e) {
  var t = e.getBoundingClientRect(), r = document.documentElement;
  return {
    left: t.left + (window.pageXOffset || r.scrollLeft) - (r.clientLeft || document.body.clientLeft || 0),
    top: t.top + (window.pageYOffset || r.scrollTop) - (r.clientTop || document.body.clientTop || 0)
  };
}
function Jd(e, t, r, n) {
  var i = Ec.unstable_batchedUpdates ? function(a) {
    Ec.unstable_batchedUpdates(r, a);
  } : r;
  return e != null && e.addEventListener && e.addEventListener(t, i, n), {
    remove: function() {
      e != null && e.removeEventListener && e.removeEventListener(t, i, n);
    }
  };
}
var mv = /* @__PURE__ */ T.createContext(null), zse = function(t) {
  var r = t.visible, n = t.maskTransitionName, i = t.getContainer, o = t.prefixCls, a = t.rootClassName, s = t.icons, l = t.countRender, u = t.showSwitch, c = t.showProgress, d = t.current, h = t.transform, f = t.count, p = t.scale, g = t.minScale, v = t.maxScale, m = t.closeIcon, y = t.onSwitchLeft, C = t.onSwitchRight, S = t.onClose, b = t.onZoomIn, w = t.onZoomOut, x = t.onRotateRight, E = t.onRotateLeft, R = t.onFlipX, _ = t.onFlipY, P = t.onReset, D = t.toolbarRender, I = t.zIndex, A = t.image, O = rr(mv), L = s.rotateLeft, N = s.rotateRight, F = s.zoomIn, G = s.zoomOut, M = s.close, V = s.left, z = s.right, k = s.flipX, $ = s.flipY, W = "".concat(o, "-operations-operation");
  T.useEffect(function() {
    var ee = function(X) {
      X.keyCode === Ue.ESC && S();
    };
    return r && window.addEventListener("keydown", ee), function() {
      window.removeEventListener("keydown", ee);
    };
  }, [r]);
  var j = [{
    icon: $,
    onClick: _,
    type: "flipY"
  }, {
    icon: k,
    onClick: R,
    type: "flipX"
  }, {
    icon: L,
    onClick: E,
    type: "rotateLeft"
  }, {
    icon: N,
    onClick: x,
    type: "rotateRight"
  }, {
    icon: G,
    onClick: w,
    type: "zoomOut",
    disabled: p <= g
  }, {
    icon: F,
    onClick: b,
    type: "zoomIn",
    disabled: p === v
  }], U = j.map(function(ee) {
    var J, X = ee.icon, Y = ee.onClick, de = ee.type, K = ee.disabled;
    return /* @__PURE__ */ T.createElement("div", {
      className: pe(W, (J = {}, te(J, "".concat(o, "-operations-operation-").concat(de), !0), te(J, "".concat(o, "-operations-operation-disabled"), !!K), J)),
      onClick: Y,
      key: de
    }, X);
  }), Z = /* @__PURE__ */ T.createElement("div", {
    className: "".concat(o, "-operations")
  }, U);
  return /* @__PURE__ */ T.createElement(ns, {
    visible: r,
    motionName: n
  }, function(ee) {
    var J = ee.className, X = ee.style;
    return /* @__PURE__ */ T.createElement(cv, {
      open: !0,
      getContainer: i ?? document.body
    }, /* @__PURE__ */ T.createElement("div", {
      className: pe("".concat(o, "-operations-wrapper"), J, a),
      style: re(re({}, X), {}, {
        zIndex: I
      })
    }, m === null ? null : /* @__PURE__ */ T.createElement("button", {
      className: "".concat(o, "-close"),
      onClick: S
    }, m || M), u && /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement("div", {
      className: pe("".concat(o, "-switch-left"), te({}, "".concat(o, "-switch-left-disabled"), d === 0)),
      onClick: y
    }, V), /* @__PURE__ */ T.createElement("div", {
      className: pe("".concat(o, "-switch-right"), te({}, "".concat(o, "-switch-right-disabled"), d === f - 1)),
      onClick: C
    }, z)), /* @__PURE__ */ T.createElement("div", {
      className: "".concat(o, "-footer")
    }, c && /* @__PURE__ */ T.createElement("div", {
      className: "".concat(o, "-progress")
    }, l ? l(d + 1, f) : "".concat(d + 1, " / ").concat(f)), D ? D(Z, re(re({
      icons: {
        flipYIcon: U[0],
        flipXIcon: U[1],
        rotateLeftIcon: U[2],
        rotateRightIcon: U[3],
        zoomOutIcon: U[4],
        zoomInIcon: U[5]
      },
      actions: {
        onFlipY: _,
        onFlipX: R,
        onRotateLeft: E,
        onRotateRight: x,
        onZoomOut: w,
        onZoomIn: b,
        onReset: P,
        onClose: S
      },
      transform: h
    }, O ? {
      current: d,
      total: f
    } : {}), {}, {
      image: A
    })) : Z)));
  });
}, gm = {
  x: 0,
  y: 0,
  rotate: 0,
  scale: 1,
  flipX: !1,
  flipY: !1
};
function $se(e, t, r, n) {
  var i = le(null), o = le([]), a = Ee(gm), s = ue(a, 2), l = s[0], u = s[1], c = function(p) {
    u(gm), xh(gm, l) || n == null || n({
      transform: gm,
      action: p
    });
  }, d = function(p, g) {
    i.current === null && (o.current = [], i.current = cn(function() {
      u(function(v) {
        var m = v;
        return o.current.forEach(function(y) {
          m = re(re({}, m), y);
        }), i.current = null, n == null || n({
          transform: m,
          action: g
        }), m;
      });
    })), o.current.push(re(re({}, l), p));
  }, h = function(p, g, v, m, y) {
    var C = e.current, S = C.width, b = C.height, w = C.offsetWidth, x = C.offsetHeight, E = C.offsetLeft, R = C.offsetTop, _ = p, P = l.scale * p;
    P > r ? (P = r, _ = r / l.scale) : P < t && (P = y ? P : t, _ = P / l.scale);
    var D = v ?? innerWidth / 2, I = m ?? innerHeight / 2, A = _ - 1, O = A * S * 0.5, L = A * b * 0.5, N = A * (D - l.x - E), F = A * (I - l.y - R), G = l.x - (N - O), M = l.y - (F - L);
    if (p < 1 && P === 1) {
      var V = w * P, z = x * P, k = L8(), $ = k.width, W = k.height;
      V <= $ && z <= W && (G = 0, M = 0);
    }
    d({
      x: G,
      y: M,
      scale: P
    }, g);
  };
  return {
    transform: l,
    resetTransform: c,
    updateTransform: d,
    dispatchZoomChange: h
  };
}
function yF(e, t, r, n) {
  var i = t + r, o = (r - n) / 2;
  if (r > n) {
    if (t > 0)
      return te({}, e, o);
    if (t < 0 && i < n)
      return te({}, e, -o);
  } else if (t < 0 || i > n)
    return te({}, e, t < 0 ? o : -o);
  return {};
}
function O8(e, t, r, n) {
  var i = L8(), o = i.width, a = i.height, s = null;
  return e <= o && t <= a ? s = {
    x: 0,
    y: 0
  } : (e > o || t > a) && (s = re(re({}, yF("x", r, e, o)), yF("y", n, t, a))), s;
}
var eh = 1, Wse = 1;
function jse(e, t, r, n, i, o, a) {
  var s = i.rotate, l = i.scale, u = i.x, c = i.y, d = Ee(!1), h = ue(d, 2), f = h[0], p = h[1], g = le({
    diffX: 0,
    diffY: 0,
    transformX: 0,
    transformY: 0
  }), v = function(b) {
    !t || b.button !== 0 || (b.preventDefault(), b.stopPropagation(), g.current = {
      diffX: b.pageX - u,
      diffY: b.pageY - c,
      transformX: u,
      transformY: c
    }, p(!0));
  }, m = function(b) {
    r && f && o({
      x: b.pageX - g.current.diffX,
      y: b.pageY - g.current.diffY
    }, "move");
  }, y = function() {
    if (r && f) {
      p(!1);
      var b = g.current, w = b.transformX, x = b.transformY, E = u !== w && c !== x;
      if (!E) return;
      var R = e.current.offsetWidth * l, _ = e.current.offsetHeight * l, P = e.current.getBoundingClientRect(), D = P.left, I = P.top, A = s % 180 !== 0, O = O8(A ? _ : R, A ? R : _, D, I);
      O && o(re({}, O), "dragRebound");
    }
  }, C = function(b) {
    if (!(!r || b.deltaY == 0)) {
      var w = Math.abs(b.deltaY / 100), x = Math.min(w, Wse), E = eh + x * n;
      b.deltaY > 0 && (E = eh / E), a(E, "wheel", b.clientX, b.clientY);
    }
  };
  return It(function() {
    var S, b, w, x;
    if (t) {
      w = Jd(window, "mouseup", y, !1), x = Jd(window, "mousemove", m, !1);
      try {
        window.top !== window.self && (S = Jd(window.top, "mouseup", y, !1), b = Jd(window.top, "mousemove", m, !1));
      } catch (E) {
        Ns(!1, "[rc-image] ".concat(E));
      }
    }
    return function() {
      var E, R, _, P;
      (E = w) === null || E === void 0 || E.remove(), (R = x) === null || R === void 0 || R.remove(), (_ = S) === null || _ === void 0 || _.remove(), (P = b) === null || P === void 0 || P.remove();
    };
  }, [r, f, u, c, s, t]), {
    isMoving: f,
    onMouseDown: v,
    onMouseMove: m,
    onMouseUp: y,
    onWheel: C
  };
}
function Use(e) {
  return new Promise(function(t) {
    var r = document.createElement("img");
    r.onerror = function() {
      return t(!1);
    }, r.onload = function() {
      return t(!0);
    }, r.src = e;
  });
}
function N8(e) {
  var t = e.src, r = e.isCustomPlaceholder, n = e.fallback, i = Ee(r ? "loading" : "normal"), o = ue(i, 2), a = o[0], s = o[1], l = le(!1), u = a === "error";
  It(function() {
    var f = !0;
    return Use(t).then(function(p) {
      !p && f && s("error");
    }), function() {
      f = !1;
    };
  }, [t]), It(function() {
    r && !l.current ? s("loading") : u && s("normal");
  }, [t]);
  var c = function() {
    s("normal");
  }, d = function(p) {
    l.current = !1, a === "loading" && p !== null && p !== void 0 && p.complete && (p.naturalWidth || p.naturalHeight) && (l.current = !0, c());
  }, h = u && n ? {
    src: n
  } : {
    onLoad: c,
    src: t
  };
  return [d, h, a];
}
function I0(e, t) {
  var r = e.x - t.x, n = e.y - t.y;
  return Math.hypot(r, n);
}
function Kse(e, t, r, n) {
  var i = I0(e, r), o = I0(t, n);
  if (i === 0 && o === 0)
    return [e.x, e.y];
  var a = i / (i + o), s = e.x + a * (t.x - e.x), l = e.y + a * (t.y - e.y);
  return [s, l];
}
function Yse(e, t, r, n, i, o, a) {
  var s = i.rotate, l = i.scale, u = i.x, c = i.y, d = Ee(!1), h = ue(d, 2), f = h[0], p = h[1], g = le({
    point1: {
      x: 0,
      y: 0
    },
    point2: {
      x: 0,
      y: 0
    },
    eventType: "none"
  }), v = function(b) {
    g.current = re(re({}, g.current), b);
  }, m = function(b) {
    if (t) {
      b.stopPropagation(), p(!0);
      var w = b.touches, x = w === void 0 ? [] : w;
      x.length > 1 ? v({
        point1: {
          x: x[0].clientX,
          y: x[0].clientY
        },
        point2: {
          x: x[1].clientX,
          y: x[1].clientY
        },
        eventType: "touchZoom"
      }) : v({
        point1: {
          x: x[0].clientX - u,
          y: x[0].clientY - c
        },
        eventType: "move"
      });
    }
  }, y = function(b) {
    var w = b.touches, x = w === void 0 ? [] : w, E = g.current, R = E.point1, _ = E.point2, P = E.eventType;
    if (x.length > 1 && P === "touchZoom") {
      var D = {
        x: x[0].clientX,
        y: x[0].clientY
      }, I = {
        x: x[1].clientX,
        y: x[1].clientY
      }, A = Kse(R, _, D, I), O = ue(A, 2), L = O[0], N = O[1], F = I0(D, I) / I0(R, _);
      a(F, "touchZoom", L, N, !0), v({
        point1: D,
        point2: I,
        eventType: "touchZoom"
      });
    } else P === "move" && (o({
      x: x[0].clientX - R.x,
      y: x[0].clientY - R.y
    }, "move"), v({
      eventType: "move"
    }));
  }, C = function() {
    if (r) {
      if (f && p(!1), v({
        eventType: "none"
      }), n > l)
        return o({
          x: 0,
          y: 0,
          scale: n
        }, "touchZoom");
      var b = e.current.offsetWidth * l, w = e.current.offsetHeight * l, x = e.current.getBoundingClientRect(), E = x.left, R = x.top, _ = s % 180 !== 0, P = O8(_ ? w : b, _ ? b : w, E, R);
      P && o(re({}, P), "dragRebound");
    }
  };
  return It(function() {
    var S;
    return r && t && (S = Jd(window, "touchmove", function(b) {
      return b.preventDefault();
    }, {
      passive: !1
    })), function() {
      var b;
      (b = S) === null || b === void 0 || b.remove();
    };
  }, [r, t]), {
    isTouching: f,
    onTouchStart: m,
    onTouchMove: y,
    onTouchEnd: C
  };
}
var qse = ["fallback", "src", "imgRef"], Zse = ["prefixCls", "src", "alt", "imageInfo", "fallback", "movable", "onClose", "visible", "icons", "rootClassName", "closeIcon", "getContainer", "current", "count", "countRender", "scaleStep", "minScale", "maxScale", "transitionName", "maskTransitionName", "imageRender", "imgCommonProps", "toolbarRender", "onTransform", "onChange"], Xse = function(t) {
  var r = t.fallback, n = t.src, i = t.imgRef, o = zt(t, qse), a = N8({
    src: n,
    fallback: r
  }), s = ue(a, 2), l = s[0], u = s[1];
  return /* @__PURE__ */ H.createElement("img", ze({
    ref: function(d) {
      i.current = d, l(d);
    }
  }, o, u));
}, k8 = function(t) {
  var r = t.prefixCls, n = t.src, i = t.alt, o = t.imageInfo, a = t.fallback, s = t.movable, l = s === void 0 ? !0 : s, u = t.onClose, c = t.visible, d = t.icons, h = d === void 0 ? {} : d, f = t.rootClassName, p = t.closeIcon, g = t.getContainer, v = t.current, m = v === void 0 ? 0 : v, y = t.count, C = y === void 0 ? 1 : y, S = t.countRender, b = t.scaleStep, w = b === void 0 ? 0.5 : b, x = t.minScale, E = x === void 0 ? 1 : x, R = t.maxScale, _ = R === void 0 ? 50 : R, P = t.transitionName, D = P === void 0 ? "zoom" : P, I = t.maskTransitionName, A = I === void 0 ? "fade" : I, O = t.imageRender, L = t.imgCommonProps, N = t.toolbarRender, F = t.onTransform, G = t.onChange, M = zt(t, Zse), V = le(), z = rr(mv), k = z && C > 1, $ = z && C >= 1, W = Ee(!0), j = ue(W, 2), U = j[0], Z = j[1], ee = $se(V, E, _, F), J = ee.transform, X = ee.resetTransform, Y = ee.updateTransform, de = ee.dispatchZoomChange, K = jse(V, l, c, w, J, Y, de), ie = K.isMoving, Ce = K.onMouseDown, Te = K.onWheel, Ie = Yse(V, l, c, E, J, Y, de), we = Ie.isTouching, Re = Ie.onTouchStart, _e = Ie.onTouchMove, He = Ie.onTouchEnd, Ve = J.rotate, $e = J.scale, Je = pe(te({}, "".concat(r, "-moving"), ie));
  It(function() {
    U || Z(!0);
  }, [U]);
  var Q = function() {
    X("close");
  }, ye = function() {
    de(eh + w, "zoomIn");
  }, Ge = function() {
    de(eh / (eh + w), "zoomOut");
  }, Pe = function() {
    Y({
      rotate: Ve + 90
    }, "rotateRight");
  }, Le = function() {
    Y({
      rotate: Ve - 90
    }, "rotateLeft");
  }, me = function() {
    Y({
      flipX: !J.flipX
    }, "flipX");
  }, De = function() {
    Y({
      flipY: !J.flipY
    }, "flipY");
  }, qe = function() {
    X("reset");
  }, ht = function(wt) {
    wt == null || wt.preventDefault(), wt == null || wt.stopPropagation(), m > 0 && (Z(!1), X("prev"), G == null || G(m - 1, m));
  }, Tt = function(wt) {
    wt == null || wt.preventDefault(), wt == null || wt.stopPropagation(), m < C - 1 && (Z(!1), X("next"), G == null || G(m + 1, m));
  }, lt = function(wt) {
    !c || !k || (wt.keyCode === Ue.LEFT ? ht() : wt.keyCode === Ue.RIGHT && Tt());
  }, tt = function(wt) {
    c && ($e !== 1 ? Y({
      x: 0,
      y: 0,
      scale: 1
    }, "doubleClick") : de(eh + w, "doubleClick", wt.clientX, wt.clientY));
  };
  It(function() {
    var pt = Jd(window, "keydown", lt, !1);
    return function() {
      pt.remove();
    };
  }, [c, k, m]);
  var Oe = /* @__PURE__ */ H.createElement(Xse, ze({}, L, {
    width: t.width,
    height: t.height,
    imgRef: V,
    className: "".concat(r, "-img"),
    alt: i,
    style: {
      transform: "translate3d(".concat(J.x, "px, ").concat(J.y, "px, 0) scale3d(").concat(J.flipX ? "-" : "").concat($e, ", ").concat(J.flipY ? "-" : "").concat($e, ", 1) rotate(").concat(Ve, "deg)"),
      transitionDuration: (!U || we) && "0s"
    },
    fallback: a,
    src: n,
    onWheel: Te,
    onMouseDown: Ce,
    onDoubleClick: tt,
    onTouchStart: Re,
    onTouchMove: _e,
    onTouchEnd: He,
    onTouchCancel: He
  })), je = re({
    url: n,
    alt: i
  }, o);
  return /* @__PURE__ */ H.createElement(H.Fragment, null, /* @__PURE__ */ H.createElement(p5, ze({
    transitionName: D,
    maskTransitionName: A,
    closable: !1,
    keyboard: !0,
    prefixCls: r,
    onClose: u,
    visible: c,
    classNames: {
      wrapper: Je
    },
    rootClassName: f,
    getContainer: g
  }, M, {
    afterClose: Q
  }), /* @__PURE__ */ H.createElement("div", {
    className: "".concat(r, "-img-wrapper")
  }, O ? O(Oe, re({
    transform: J,
    image: je
  }, z ? {
    current: m
  } : {})) : Oe)), /* @__PURE__ */ H.createElement(zse, {
    visible: c,
    transform: J,
    maskTransitionName: A,
    closeIcon: p,
    getContainer: g,
    prefixCls: r,
    rootClassName: f,
    icons: h,
    countRender: S,
    showSwitch: k,
    showProgress: $,
    current: m,
    count: C,
    scale: $e,
    minScale: E,
    maxScale: _,
    toolbarRender: N,
    onSwitchLeft: ht,
    onSwitchRight: Tt,
    onZoomIn: ye,
    onZoomOut: Ge,
    onRotateRight: Pe,
    onRotateLeft: Le,
    onFlipX: me,
    onFlipY: De,
    onClose: u,
    onReset: qe,
    zIndex: M.zIndex !== void 0 ? M.zIndex + 1 : void 0,
    image: je
  }));
}, cR = ["crossOrigin", "decoding", "draggable", "loading", "referrerPolicy", "sizes", "srcSet", "useMap", "alt"];
function Qse(e) {
  var t = T.useState({}), r = ue(t, 2), n = r[0], i = r[1], o = T.useCallback(function(s, l) {
    return i(function(u) {
      return re(re({}, u), {}, te({}, s, l));
    }), function() {
      i(function(u) {
        var c = re({}, u);
        return delete c[s], c;
      });
    };
  }, []), a = T.useMemo(function() {
    return e ? e.map(function(s) {
      if (typeof s == "string")
        return {
          data: {
            src: s
          }
        };
      var l = {};
      return Object.keys(s).forEach(function(u) {
        ["src"].concat(rt(cR)).includes(u) && (l[u] = s[u]);
      }), {
        data: l
      };
    }) : Object.keys(n).reduce(function(s, l) {
      var u = n[l], c = u.canPreview, d = u.data;
      return c && s.push({
        data: d,
        id: l
      }), s;
    }, []);
  }, [e, n]);
  return [a, o, !!e];
}
var Jse = ["visible", "onVisibleChange", "getContainer", "current", "movable", "minScale", "maxScale", "countRender", "closeIcon", "onChange", "onTransform", "toolbarRender", "imageRender"], ele = ["src"], tle = function(t) {
  var r, n = t.previewPrefixCls, i = n === void 0 ? "rc-image-preview" : n, o = t.children, a = t.icons, s = a === void 0 ? {} : a, l = t.items, u = t.preview, c = t.fallback, d = xt(u) === "object" ? u : {}, h = d.visible, f = d.onVisibleChange, p = d.getContainer, g = d.current, v = d.movable, m = d.minScale, y = d.maxScale, C = d.countRender, S = d.closeIcon, b = d.onChange, w = d.onTransform, x = d.toolbarRender, E = d.imageRender, R = zt(d, Jse), _ = Qse(l), P = ue(_, 3), D = P[0], I = P[1], A = P[2], O = Nn(0, {
    value: g
  }), L = ue(O, 2), N = L[0], F = L[1], G = Ee(!1), M = ue(G, 2), V = M[0], z = M[1], k = ((r = D[N]) === null || r === void 0 ? void 0 : r.data) || {}, $ = k.src, W = zt(k, ele), j = Nn(!!h, {
    value: h,
    onChange: function(we, Re) {
      f == null || f(we, Re, N);
    }
  }), U = ue(j, 2), Z = U[0], ee = U[1], J = Ee(null), X = ue(J, 2), Y = X[0], de = X[1], K = T.useCallback(function(Ie, we, Re, _e) {
    var He = A ? D.findIndex(function(Ve) {
      return Ve.data.src === we;
    }) : D.findIndex(function(Ve) {
      return Ve.id === Ie;
    });
    F(He < 0 ? 0 : He), ee(!0), de({
      x: Re,
      y: _e
    }), z(!0);
  }, [D, A]);
  T.useEffect(function() {
    Z ? V || F(0) : z(!1);
  }, [Z]);
  var ie = function(we, Re) {
    F(we), b == null || b(we, Re);
  }, Ce = function() {
    ee(!1), de(null);
  }, Te = T.useMemo(function() {
    return {
      register: I,
      onPreview: K
    };
  }, [I, K]);
  return /* @__PURE__ */ T.createElement(mv.Provider, {
    value: Te
  }, o, /* @__PURE__ */ T.createElement(k8, ze({
    "aria-hidden": !Z,
    movable: v,
    visible: Z,
    prefixCls: i,
    closeIcon: S,
    onClose: Ce,
    mousePosition: Y,
    imgCommonProps: W,
    src: $,
    fallback: c,
    icons: s,
    minScale: m,
    maxScale: y,
    getContainer: p,
    current: N,
    count: D.length,
    countRender: C,
    onTransform: w,
    toolbarRender: x,
    imageRender: E,
    onChange: ie
  }, R)));
}, CF = 0;
function rle(e, t) {
  var r = T.useState(function() {
    return CF += 1, String(CF);
  }), n = ue(r, 1), i = n[0], o = T.useContext(mv), a = {
    data: t,
    canPreview: e
  };
  return T.useEffect(function() {
    if (o)
      return o.register(i, a);
  }, []), T.useEffect(function() {
    o && o.register(i, a);
  }, [e, t]), i;
}
var nle = ["src", "alt", "onPreviewClose", "prefixCls", "previewPrefixCls", "placeholder", "fallback", "width", "height", "style", "preview", "className", "onClick", "onError", "wrapperClassName", "wrapperStyle", "rootClassName"], ile = ["src", "visible", "onVisibleChange", "getContainer", "mask", "maskClassName", "movable", "icons", "scaleStep", "minScale", "maxScale", "imageRender", "toolbarRender"], pS = function(t) {
  var r = t.src, n = t.alt, i = t.onPreviewClose, o = t.prefixCls, a = o === void 0 ? "rc-image" : o, s = t.previewPrefixCls, l = s === void 0 ? "".concat(a, "-preview") : s, u = t.placeholder, c = t.fallback, d = t.width, h = t.height, f = t.style, p = t.preview, g = p === void 0 ? !0 : p, v = t.className, m = t.onClick, y = t.onError, C = t.wrapperClassName, S = t.wrapperStyle, b = t.rootClassName, w = zt(t, nle), x = u && u !== !0, E = xt(g) === "object" ? g : {}, R = E.src, _ = E.visible, P = _ === void 0 ? void 0 : _, D = E.onVisibleChange, I = D === void 0 ? i : D, A = E.getContainer, O = A === void 0 ? void 0 : A, L = E.mask, N = E.maskClassName, F = E.movable, G = E.icons, M = E.scaleStep, V = E.minScale, z = E.maxScale, k = E.imageRender, $ = E.toolbarRender, W = zt(E, ile), j = R ?? r, U = Nn(!!P, {
    value: P,
    onChange: I
  }), Z = ue(U, 2), ee = Z[0], J = Z[1], X = N8({
    src: r,
    isCustomPlaceholder: x,
    fallback: c
  }), Y = ue(X, 3), de = Y[0], K = Y[1], ie = Y[2], Ce = Ee(null), Te = ue(Ce, 2), Ie = Te[0], we = Te[1], Re = rr(mv), _e = !!g, He = function() {
    J(!1), we(null);
  }, Ve = pe(a, C, b, te({}, "".concat(a, "-error"), ie === "error")), $e = ct(function() {
    var Ge = {};
    return cR.forEach(function(Pe) {
      t[Pe] !== void 0 && (Ge[Pe] = t[Pe]);
    }), Ge;
  }, cR.map(function(Ge) {
    return t[Ge];
  })), Je = ct(function() {
    return re(re({}, $e), {}, {
      src: j
    });
  }, [j, $e]), Q = rle(_e, Je), ye = function(Pe) {
    var Le = Hse(Pe.target), me = Le.left, De = Le.top;
    Re ? Re.onPreview(Q, j, me, De) : (we({
      x: me,
      y: De
    }), J(!0)), m == null || m(Pe);
  };
  return /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement("div", ze({}, w, {
    className: Ve,
    onClick: _e ? ye : m,
    style: re({
      width: d,
      height: h
    }, S)
  }), /* @__PURE__ */ T.createElement("img", ze({}, $e, {
    className: pe("".concat(a, "-img"), te({}, "".concat(a, "-img-placeholder"), u === !0), v),
    style: re({
      height: h
    }, f),
    ref: de
  }, K, {
    width: d,
    height: h,
    onError: y
  })), ie === "loading" && /* @__PURE__ */ T.createElement("div", {
    "aria-hidden": "true",
    className: "".concat(a, "-placeholder")
  }, u), L && _e && /* @__PURE__ */ T.createElement("div", {
    className: pe("".concat(a, "-mask"), N),
    style: {
      display: (f == null ? void 0 : f.display) === "none" ? "none" : void 0
    }
  }, L)), !Re && _e && /* @__PURE__ */ T.createElement(k8, ze({
    "aria-hidden": !ee,
    visible: ee,
    prefixCls: l,
    onClose: He,
    mousePosition: Ie,
    src: j,
    alt: n,
    imageInfo: {
      width: d,
      height: h
    },
    fallback: c,
    getContainer: O,
    icons: G,
    movable: F,
    scaleStep: M,
    minScale: V,
    maxScale: z,
    rootClassName: b,
    imageRender: k,
    imgCommonProps: $e,
    toolbarRender: $
  }, W)));
};
pS.PreviewGroup = tle;
process.env.NODE_ENV !== "production" && (pS.displayName = "Image");
var ole = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { tag: "path", attrs: { d: "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, name: "rotate-left", theme: "outlined" }, ale = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: ole
  }));
}, V8 = /* @__PURE__ */ T.forwardRef(ale);
process.env.NODE_ENV !== "production" && (V8.displayName = "RotateLeftOutlined");
var sle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { tag: "path", attrs: { d: "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, name: "rotate-right", theme: "outlined" }, lle = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: sle
  }));
}, B8 = /* @__PURE__ */ T.forwardRef(lle);
process.env.NODE_ENV !== "production" && (B8.displayName = "RotateRightOutlined");
var ule = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, name: "swap", theme: "outlined" }, cle = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: ule
  }));
}, dR = /* @__PURE__ */ T.forwardRef(cle);
process.env.NODE_ENV !== "production" && (dR.displayName = "SwapOutlined");
var dle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-in", theme: "outlined" }, hle = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: dle
  }));
}, G8 = /* @__PURE__ */ T.forwardRef(hle);
process.env.NODE_ENV !== "production" && (G8.displayName = "ZoomInOutlined");
var fle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-out", theme: "outlined" }, ple = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: fle
  }));
}, H8 = /* @__PURE__ */ T.forwardRef(ple);
process.env.NODE_ENV !== "production" && (H8.displayName = "ZoomOutOutlined");
const hR = (e) => ({
  position: e || "absolute",
  inset: 0
}), gle = (e) => {
  const {
    iconCls: t,
    motionDurationSlow: r,
    paddingXXS: n,
    marginXXS: i,
    prefixCls: o,
    colorTextLightSolid: a
  } = e;
  return {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: a,
    background: new ln("#000").setAlpha(0.5).toRgbString(),
    cursor: "pointer",
    opacity: 0,
    transition: `opacity ${r}`,
    [`.${o}-mask-info`]: Object.assign(Object.assign({}, rS), {
      padding: `0 ${xe(n)}`,
      [t]: {
        marginInlineEnd: i,
        svg: {
          verticalAlign: "baseline"
        }
      }
    })
  };
}, vle = (e) => {
  const {
    previewCls: t,
    modalMaskBg: r,
    paddingSM: n,
    marginXL: i,
    margin: o,
    paddingLG: a,
    previewOperationColorDisabled: s,
    previewOperationHoverColor: l,
    motionDurationSlow: u,
    iconCls: c,
    colorTextLightSolid: d
  } = e, h = new ln(r).setAlpha(0.1), f = h.clone().setAlpha(0.2);
  return {
    [`${t}-footer`]: {
      position: "fixed",
      bottom: i,
      left: {
        _skip_check_: !0,
        value: 0
      },
      width: "100%",
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      color: e.previewOperationColor
    },
    [`${t}-progress`]: {
      marginBottom: o
    },
    [`${t}-close`]: {
      position: "fixed",
      top: i,
      right: {
        _skip_check_: !0,
        value: i
      },
      display: "flex",
      color: d,
      backgroundColor: h.toRgbString(),
      borderRadius: "50%",
      padding: n,
      outline: 0,
      border: 0,
      cursor: "pointer",
      transition: `all ${u}`,
      "&:hover": {
        backgroundColor: f.toRgbString()
      },
      [`& > ${c}`]: {
        fontSize: e.previewOperationSize
      }
    },
    [`${t}-operations`]: {
      display: "flex",
      alignItems: "center",
      padding: `0 ${xe(a)}`,
      backgroundColor: h.toRgbString(),
      borderRadius: 100,
      "&-operation": {
        marginInlineStart: n,
        padding: n,
        cursor: "pointer",
        transition: `all ${u}`,
        userSelect: "none",
        [`&:not(${t}-operations-operation-disabled):hover > ${c}`]: {
          color: l
        },
        "&-disabled": {
          color: s,
          cursor: "not-allowed"
        },
        "&:first-of-type": {
          marginInlineStart: 0
        },
        [`& > ${c}`]: {
          fontSize: e.previewOperationSize
        }
      }
    }
  };
}, mle = (e) => {
  const {
    modalMaskBg: t,
    iconCls: r,
    previewOperationColorDisabled: n,
    previewCls: i,
    zIndexPopup: o,
    motionDurationSlow: a
  } = e, s = new ln(t).setAlpha(0.1), l = s.clone().setAlpha(0.2);
  return {
    [`${i}-switch-left, ${i}-switch-right`]: {
      position: "fixed",
      insetBlockStart: "50%",
      zIndex: e.calc(o).add(1).equal(),
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: e.imagePreviewSwitchSize,
      height: e.imagePreviewSwitchSize,
      marginTop: e.calc(e.imagePreviewSwitchSize).mul(-1).div(2).equal(),
      color: e.previewOperationColor,
      background: s.toRgbString(),
      borderRadius: "50%",
      transform: "translateY(-50%)",
      cursor: "pointer",
      transition: `all ${a}`,
      userSelect: "none",
      "&:hover": {
        background: l.toRgbString()
      },
      "&-disabled": {
        "&, &:hover": {
          color: n,
          background: "transparent",
          cursor: "not-allowed",
          [`> ${r}`]: {
            cursor: "not-allowed"
          }
        }
      },
      [`> ${r}`]: {
        fontSize: e.previewOperationSize
      }
    },
    [`${i}-switch-left`]: {
      insetInlineStart: e.marginSM
    },
    [`${i}-switch-right`]: {
      insetInlineEnd: e.marginSM
    }
  };
}, yle = (e) => {
  const {
    motionEaseOut: t,
    previewCls: r,
    motionDurationSlow: n,
    componentCls: i
  } = e;
  return [
    {
      [`${i}-preview-root`]: {
        [r]: {
          height: "100%",
          textAlign: "center",
          pointerEvents: "none"
        },
        [`${r}-body`]: Object.assign(Object.assign({}, hR()), {
          overflow: "hidden"
        }),
        [`${r}-img`]: {
          maxWidth: "100%",
          maxHeight: "70%",
          verticalAlign: "middle",
          transform: "scale3d(1, 1, 1)",
          cursor: "grab",
          transition: `transform ${n} ${t} 0s`,
          userSelect: "none",
          "&-wrapper": Object.assign(Object.assign({}, hR()), {
            transition: `transform ${n} ${t} 0s`,
            // https://github.com/ant-design/ant-design/issues/39913
            // TailwindCSS will reset img default style.
            // Let's set back.
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "& > *": {
              pointerEvents: "auto"
            },
            "&::before": {
              display: "inline-block",
              width: 1,
              height: "50%",
              marginInlineEnd: -1,
              content: '""'
            }
          })
        },
        [`${r}-moving`]: {
          [`${r}-preview-img`]: {
            cursor: "grabbing",
            "&-wrapper": {
              transitionDuration: "0s"
            }
          }
        }
      }
    },
    // Override
    {
      [`${i}-preview-root`]: {
        [`${r}-wrap`]: {
          zIndex: e.zIndexPopup
        }
      }
    },
    // Preview operations & switch
    {
      [`${i}-preview-operations-wrapper`]: {
        position: "fixed",
        zIndex: e.calc(e.zIndexPopup).add(1).equal()
      },
      "&": [vle(e), mle(e)]
    }
  ];
}, Cle = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ============================== image ==============================
    [t]: {
      position: "relative",
      display: "inline-block",
      [`${t}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${t}-img-placeholder`]: {
        backgroundColor: e.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${t}-mask`]: Object.assign({}, gle(e)),
      [`${t}-mask:hover`]: {
        opacity: 1
      },
      [`${t}-placeholder`]: Object.assign({}, hR())
    }
  };
}, Sle = (e) => {
  const {
    previewCls: t
  } = e;
  return {
    [`${t}-root`]: uS(e, "zoom"),
    "&": E5(e, !0)
  };
}, wle = (e) => ({
  zIndexPopup: e.zIndexPopupBase + 80,
  previewOperationColor: new ln(e.colorTextLightSolid).setAlpha(0.65).toRgbString(),
  previewOperationHoverColor: new ln(e.colorTextLightSolid).setAlpha(0.85).toRgbString(),
  previewOperationColorDisabled: new ln(e.colorTextLightSolid).setAlpha(0.25).toRgbString(),
  previewOperationSize: e.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
}), z8 = Gi("Image", (e) => {
  const t = `${e.componentCls}-preview`, r = dn(e, {
    previewCls: t,
    modalMaskBg: new ln("#000").setAlpha(0.45).toRgbString(),
    // FIXME: Shared Token
    imagePreviewSwitchSize: e.controlHeightLG
  });
  return [Cle(r), yle(r), R5(dn(r, {
    componentCls: t
  })), Sle(r)];
}, wle);
var ble = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const $8 = {
  rotateLeft: /* @__PURE__ */ T.createElement(V8, null),
  rotateRight: /* @__PURE__ */ T.createElement(B8, null),
  zoomIn: /* @__PURE__ */ T.createElement(G8, null),
  zoomOut: /* @__PURE__ */ T.createElement(H8, null),
  close: /* @__PURE__ */ T.createElement(iS, null),
  left: /* @__PURE__ */ T.createElement(n8, null),
  right: /* @__PURE__ */ T.createElement(W5, null),
  flipX: /* @__PURE__ */ T.createElement(dR, null),
  flipY: /* @__PURE__ */ T.createElement(dR, {
    rotate: 90
  })
}, xle = (e) => {
  var {
    previewPrefixCls: t,
    preview: r
  } = e, n = ble(e, ["previewPrefixCls", "preview"]);
  const {
    getPrefixCls: i
  } = T.useContext(Xt), o = i("image", t), a = `${o}-preview`, s = i(), l = Xh(o), [u, c, d] = z8(o, l), [h] = rP("ImagePreview", typeof r == "object" ? r.zIndex : void 0), f = T.useMemo(() => {
    var p;
    if (r === !1)
      return r;
    const g = typeof r == "object" ? r : {}, v = pe(c, d, l, (p = g.rootClassName) !== null && p !== void 0 ? p : "");
    return Object.assign(Object.assign({}, g), {
      transitionName: _c(s, "zoom", g.transitionName),
      maskTransitionName: _c(s, "fade", g.maskTransitionName),
      rootClassName: v,
      zIndex: h
    });
  }, [r]);
  return u(/* @__PURE__ */ T.createElement(pS.PreviewGroup, Object.assign({
    preview: f,
    previewPrefixCls: a,
    icons: $8
  }, n)));
}, Ele = xle;
var SF = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const yv = (e) => {
  var t;
  const {
    prefixCls: r,
    preview: n,
    className: i,
    rootClassName: o,
    style: a
  } = e, s = SF(e, ["prefixCls", "preview", "className", "rootClassName", "style"]), {
    getPrefixCls: l,
    locale: u = ks,
    getPopupContainer: c,
    image: d
  } = T.useContext(Xt), h = l("image", r), f = l(), p = u.Image || ks.Image, g = Xh(h), [v, m, y] = z8(h, g), C = pe(o, m, y, g), S = pe(i, m, d == null ? void 0 : d.className), [b] = rP("ImagePreview", typeof n == "object" ? n.zIndex : void 0), w = T.useMemo(() => {
    var E;
    if (n === !1)
      return n;
    const R = typeof n == "object" ? n : {}, {
      getContainer: _,
      closeIcon: P
    } = R, D = SF(R, ["getContainer", "closeIcon"]);
    return Object.assign(Object.assign({
      mask: /* @__PURE__ */ T.createElement("div", {
        className: `${h}-mask-info`
      }, /* @__PURE__ */ T.createElement(RP, null), p == null ? void 0 : p.preview),
      icons: $8
    }, D), {
      getContainer: _ ?? c,
      transitionName: _c(f, "zoom", R.transitionName),
      maskTransitionName: _c(f, "fade", R.maskTransitionName),
      zIndex: b,
      closeIcon: P ?? ((E = d == null ? void 0 : d.preview) === null || E === void 0 ? void 0 : E.closeIcon)
    });
  }, [n, p, (t = d == null ? void 0 : d.preview) === null || t === void 0 ? void 0 : t.closeIcon]), x = Object.assign(Object.assign({}, d == null ? void 0 : d.style), a);
  return v(/* @__PURE__ */ T.createElement(pS, Object.assign({
    prefixCls: h,
    preview: w,
    rootClassName: C,
    className: S,
    style: x
  }, s)));
};
yv.PreviewGroup = Ele;
process.env.NODE_ENV !== "production" && (yv.displayName = "Image");
const Rle = (e) => {
  const {
    componentCls: t,
    iconCls: r,
    antCls: n,
    zIndexPopup: i,
    colorText: o,
    colorWarning: a,
    marginXXS: s,
    marginXS: l,
    fontSize: u,
    fontWeightStrong: c,
    colorTextHeading: d
  } = e;
  return {
    [t]: {
      zIndex: i,
      [`&${n}-popover`]: {
        fontSize: u
      },
      [`${t}-message`]: {
        marginBottom: l,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${t}-message-icon ${r}`]: {
          color: a,
          fontSize: u,
          lineHeight: 1,
          marginInlineEnd: l
        },
        [`${t}-title`]: {
          fontWeight: c,
          color: d,
          "&:only-child": {
            fontWeight: "normal"
          }
        },
        [`${t}-description`]: {
          marginTop: s,
          color: o
        }
      },
      [`${t}-buttons`]: {
        textAlign: "end",
        whiteSpace: "nowrap",
        button: {
          marginInlineStart: l
        }
      }
    }
  };
}, _le = (e) => {
  const {
    zIndexPopupBase: t
  } = e;
  return {
    zIndexPopup: t + 60
  };
}, W8 = Gi("Popconfirm", (e) => Rle(e), _le, {
  resetStyle: !1
});
var Tle = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const j8 = (e) => {
  const {
    prefixCls: t,
    okButtonProps: r,
    cancelButtonProps: n,
    title: i,
    description: o,
    cancelText: a,
    okText: s,
    okType: l = "primary",
    icon: u = /* @__PURE__ */ T.createElement(JT, null),
    showCancel: c = !0,
    close: d,
    onConfirm: h,
    onCancel: f,
    onPopupClick: p
  } = e, {
    getPrefixCls: g
  } = T.useContext(Xt), [v] = hz("Popconfirm", ks.Popconfirm), m = Dh(i), y = Dh(o);
  return /* @__PURE__ */ T.createElement("div", {
    className: `${t}-inner-content`,
    onClick: p
  }, /* @__PURE__ */ T.createElement("div", {
    className: `${t}-message`
  }, u && /* @__PURE__ */ T.createElement("span", {
    className: `${t}-message-icon`
  }, u), /* @__PURE__ */ T.createElement("div", {
    className: `${t}-message-text`
  }, m && /* @__PURE__ */ T.createElement("div", {
    className: pe(`${t}-title`)
  }, m), y && /* @__PURE__ */ T.createElement("div", {
    className: `${t}-description`
  }, y))), /* @__PURE__ */ T.createElement("div", {
    className: `${t}-buttons`
  }, c && /* @__PURE__ */ T.createElement(Qn, Object.assign({
    onClick: f,
    size: "small"
  }, n), a || (v == null ? void 0 : v.cancelText)), /* @__PURE__ */ T.createElement(Ote, {
    buttonProps: Object.assign(Object.assign({
      size: "small"
    }, r5(l)), r),
    actionFn: h,
    close: d,
    prefixCls: g("btn"),
    quitOnNullishReturnValue: !0,
    emitEvent: !0
  }, s || (v == null ? void 0 : v.okText))));
}, Ple = (e) => {
  const {
    prefixCls: t,
    placement: r,
    className: n,
    style: i
  } = e, o = Tle(e, ["prefixCls", "placement", "className", "style"]), {
    getPrefixCls: a
  } = T.useContext(Xt), s = a("popconfirm", t), [l] = W8(s);
  return l(/* @__PURE__ */ T.createElement($5, {
    placement: r,
    className: pe(s, n),
    style: i,
    content: /* @__PURE__ */ T.createElement(j8, Object.assign({
      prefixCls: s
    }, o))
  }));
};
var Mle = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Dle = /* @__PURE__ */ T.forwardRef((e, t) => {
  var r, n;
  const {
    prefixCls: i,
    placement: o = "top",
    trigger: a = "click",
    okType: s = "primary",
    icon: l = /* @__PURE__ */ T.createElement(JT, null),
    children: u,
    overlayClassName: c,
    onOpenChange: d,
    onVisibleChange: h
  } = e, f = Mle(e, ["prefixCls", "placement", "trigger", "okType", "icon", "children", "overlayClassName", "onOpenChange", "onVisibleChange"]), {
    getPrefixCls: p
  } = T.useContext(Xt), [g, v] = Nn(!1, {
    value: (r = e.open) !== null && r !== void 0 ? r : e.visible,
    defaultValue: (n = e.defaultOpen) !== null && n !== void 0 ? n : e.defaultVisible
  }), m = (R, _) => {
    v(R, !0), h == null || h(R), d == null || d(R, _);
  }, y = (R) => {
    m(!1, R);
  }, C = (R) => {
    var _;
    return (_ = e.onConfirm) === null || _ === void 0 ? void 0 : _.call(void 0, R);
  }, S = (R) => {
    var _;
    m(!1, R), (_ = e.onCancel) === null || _ === void 0 || _.call(void 0, R);
  }, b = (R, _) => {
    const {
      disabled: P = !1
    } = e;
    P || m(R, _);
  }, w = p("popconfirm", i), x = pe(w, c), [E] = W8(w);
  return E(/* @__PURE__ */ T.createElement(pP, Object.assign({}, Bi(f, ["title"]), {
    trigger: a,
    placement: o,
    onOpenChange: b,
    open: g,
    ref: t,
    overlayClassName: x,
    content: /* @__PURE__ */ T.createElement(j8, Object.assign({
      okType: s,
      icon: l
    }, e, {
      prefixCls: w,
      close: y,
      onConfirm: C,
      onCancel: S
    })),
    "data-popover-inject": !0
  }), u));
}), TP = Dle;
TP._InternalPanelDoNotUseOrYouWillBeFired = Ple;
process.env.NODE_ENV !== "production" && (TP.displayName = "Popconfirm");
const Ale = (e) => {
  const {
    paddingXXS: t,
    lineWidth: r,
    tagPaddingHorizontal: n,
    componentCls: i,
    calc: o
  } = e, a = o(n).sub(r).equal(), s = o(t).sub(r).equal();
  return {
    // Result
    [i]: Object.assign(Object.assign({}, Xs(e)), {
      display: "inline-block",
      height: "auto",
      // https://github.com/ant-design/ant-design/pull/47504
      marginInlineEnd: e.marginXS,
      paddingInline: a,
      fontSize: e.tagFontSize,
      lineHeight: e.tagLineHeight,
      whiteSpace: "nowrap",
      background: e.defaultBg,
      border: `${xe(e.lineWidth)} ${e.lineType} ${e.colorBorder}`,
      borderRadius: e.borderRadiusSM,
      opacity: 1,
      transition: `all ${e.motionDurationMid}`,
      textAlign: "start",
      position: "relative",
      // RTL
      [`&${i}-rtl`]: {
        direction: "rtl"
      },
      "&, a, a:hover": {
        color: e.defaultColor
      },
      [`${i}-close-icon`]: {
        marginInlineStart: s,
        fontSize: e.tagIconSize,
        color: e.colorTextDescription,
        cursor: "pointer",
        transition: `all ${e.motionDurationMid}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      [`&${i}-has-color`]: {
        borderColor: "transparent",
        [`&, a, a:hover, ${e.iconCls}-close, ${e.iconCls}-close:hover`]: {
          color: e.colorTextLightSolid
        }
      },
      "&-checkable": {
        backgroundColor: "transparent",
        borderColor: "transparent",
        cursor: "pointer",
        [`&:not(${i}-checkable-checked):hover`]: {
          color: e.colorPrimary,
          backgroundColor: e.colorFillSecondary
        },
        "&:active, &-checked": {
          color: e.colorTextLightSolid
        },
        "&-checked": {
          backgroundColor: e.colorPrimary,
          "&:hover": {
            backgroundColor: e.colorPrimaryHover
          }
        },
        "&:active": {
          backgroundColor: e.colorPrimaryActive
        }
      },
      "&-hidden": {
        display: "none"
      },
      // To ensure that a space will be placed between character and `Icon`.
      [`> ${e.iconCls} + span, > span + ${e.iconCls}`]: {
        marginInlineStart: a
      }
    }),
    [`${i}-borderless`]: {
      borderColor: "transparent",
      background: e.tagBorderlessBg
    }
  };
}, PP = (e) => {
  const {
    lineWidth: t,
    fontSizeIcon: r,
    calc: n
  } = e, i = e.fontSizeSM;
  return dn(e, {
    tagFontSize: i,
    tagLineHeight: xe(n(e.lineHeightSM).mul(i).equal()),
    tagIconSize: n(r).sub(n(t).mul(2)).equal(),
    // Tag icon is much smaller
    tagPaddingHorizontal: 8,
    // Fixed padding.
    tagBorderlessBg: e.defaultBg
  });
}, MP = (e) => ({
  defaultBg: new ln(e.colorFillQuaternary).onBackground(e.colorBgContainer).toHexString(),
  defaultColor: e.colorText
}), U8 = Gi("Tag", (e) => {
  const t = PP(e);
  return Ale(t);
}, MP);
var Ile = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Fle = /* @__PURE__ */ T.forwardRef((e, t) => {
  const {
    prefixCls: r,
    style: n,
    className: i,
    checked: o,
    onChange: a,
    onClick: s
  } = e, l = Ile(e, ["prefixCls", "style", "className", "checked", "onChange", "onClick"]), {
    getPrefixCls: u,
    tag: c
  } = T.useContext(Xt), d = (m) => {
    a == null || a(!o), s == null || s(m);
  }, h = u("tag", r), [f, p, g] = U8(h), v = pe(h, `${h}-checkable`, {
    [`${h}-checkable-checked`]: o
  }, c == null ? void 0 : c.className, i, p, g);
  return f(/* @__PURE__ */ T.createElement("span", Object.assign({}, l, {
    ref: t,
    style: Object.assign(Object.assign({}, n), c == null ? void 0 : c.style),
    className: v,
    onClick: d
  })));
}), Lle = (e) => Az(e, (t, r) => {
  let {
    textColor: n,
    lightBorderColor: i,
    lightColor: o,
    darkColor: a
  } = r;
  return {
    [`${e.componentCls}${e.componentCls}-${t}`]: {
      color: n,
      background: o,
      borderColor: i,
      // Inverse color
      "&-inverse": {
        color: e.colorTextLightSolid,
        background: a,
        borderColor: a
      },
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}), Ole = XT(["Tag", "preset"], (e) => {
  const t = PP(e);
  return Lle(t);
}, MP);
function Nle(e) {
  return typeof e != "string" ? e : e.charAt(0).toUpperCase() + e.slice(1);
}
const vm = (e, t, r) => {
  const n = Nle(r);
  return {
    [`${e.componentCls}${e.componentCls}-${t}`]: {
      color: e[`color${r}`],
      background: e[`color${n}Bg`],
      borderColor: e[`color${n}Border`],
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}, kle = XT(["Tag", "status"], (e) => {
  const t = PP(e);
  return [vm(t, "success", "Success"), vm(t, "processing", "Info"), vm(t, "error", "Error"), vm(t, "warning", "Warning")];
}, MP);
var Vle = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Ble = /* @__PURE__ */ T.forwardRef((e, t) => {
  const {
    prefixCls: r,
    className: n,
    rootClassName: i,
    style: o,
    children: a,
    icon: s,
    color: l,
    onClose: u,
    bordered: c = !0,
    visible: d
  } = e, h = Vle(e, ["prefixCls", "className", "rootClassName", "style", "children", "icon", "color", "onClose", "bordered", "visible"]), {
    getPrefixCls: f,
    direction: p,
    tag: g
  } = T.useContext(Xt), [v, m] = T.useState(!0), y = Bi(h, ["closeIcon", "closable"]);
  process.env.NODE_ENV !== "production" && mn("Tag").deprecated(!("visible" in e), "visible", "visible && <Tag />"), T.useEffect(() => {
    d !== void 0 && m(d);
  }, [d]);
  const C = G5(l), S = Mie(l), b = C || S, w = Object.assign(Object.assign({
    backgroundColor: l && !b ? l : void 0
  }, g == null ? void 0 : g.style), o), x = f("tag", r), [E, R, _] = U8(x), P = pe(x, g == null ? void 0 : g.className, {
    [`${x}-${l}`]: b,
    [`${x}-has-color`]: l && !b,
    [`${x}-hidden`]: !v,
    [`${x}-rtl`]: p === "rtl",
    [`${x}-borderless`]: !c
  }, n, i, R, _), D = (F) => {
    F.stopPropagation(), u == null || u(F), !F.defaultPrevented && m(!1);
  }, [, I] = Kre(L2(e), L2(g), {
    closable: !1,
    closeIconRender: (F) => {
      const G = /* @__PURE__ */ T.createElement("span", {
        className: `${x}-close-icon`,
        onClick: D
      }, F);
      return Xz(F, G, (M) => ({
        onClick: (V) => {
          var z;
          (z = M == null ? void 0 : M.onClick) === null || z === void 0 || z.call(M, V), D(V);
        },
        className: pe(M == null ? void 0 : M.className, `${x}-close-icon`)
      }));
    }
  }), A = typeof h.onClick == "function" || a && a.type === "a", O = s || null, L = O ? /* @__PURE__ */ T.createElement(T.Fragment, null, O, a && /* @__PURE__ */ T.createElement("span", null, a)) : a, N = /* @__PURE__ */ T.createElement("span", Object.assign({}, y, {
    ref: t,
    className: P,
    style: w
  }), L, I, C && /* @__PURE__ */ T.createElement(Ole, {
    key: "preset",
    prefixCls: x
  }), S && /* @__PURE__ */ T.createElement(kle, {
    key: "status",
    prefixCls: x
  }));
  return E(A ? /* @__PURE__ */ T.createElement(iP, {
    component: "Tag"
  }, N) : N);
}), DP = Ble;
process.env.NODE_ENV !== "production" && (DP.displayName = "Tag");
DP.CheckableTag = Fle;
var Gle = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const Hle = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-flex"
}, fR = /* @__PURE__ */ T.forwardRef((e, t) => {
  const r = (c) => {
    const {
      keyCode: d
    } = c;
    d === Ue.ENTER && c.preventDefault();
  }, n = (c) => {
    const {
      keyCode: d
    } = c, {
      onClick: h
    } = e;
    d === Ue.ENTER && h && h();
  }, {
    style: i,
    noStyle: o,
    disabled: a,
    tabIndex: s = 0
  } = e, l = Gle(e, ["style", "noStyle", "disabled", "tabIndex"]);
  let u = {};
  return o || (u = Object.assign({}, Hle)), a && (u.pointerEvents = "none"), u = Object.assign(Object.assign({}, u), i), /* @__PURE__ */ T.createElement("div", Object.assign({
    role: "button",
    tabIndex: s,
    ref: t
  }, l, {
    onKeyDown: r,
    onKeyUp: n,
    style: u
  }));
});
var zle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, name: "edit", theme: "outlined" }, $le = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: zle
  }));
}, K8 = /* @__PURE__ */ T.forwardRef($le);
process.env.NODE_ENV !== "production" && (K8.displayName = "EditOutlined");
var Wle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, name: "enter", theme: "outlined" }, jle = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: Wle
  }));
}, Y8 = /* @__PURE__ */ T.forwardRef(jle);
process.env.NODE_ENV !== "production" && (Y8.displayName = "EnterOutlined");
const Ule = (e, t, r, n) => {
  const {
    titleMarginBottom: i,
    fontWeightStrong: o
  } = n;
  return {
    marginBottom: i,
    color: r,
    fontWeight: o,
    fontSize: e,
    lineHeight: t
  };
}, Kle = (e) => {
  const t = [1, 2, 3, 4, 5], r = {};
  return t.forEach((n) => {
    r[`
      h${n}&,
      div&-h${n},
      div&-h${n} > textarea,
      h${n}
    `] = Ule(e[`fontSizeHeading${n}`], e[`lineHeightHeading${n}`], e.colorTextHeading, e);
  }), r;
}, Yle = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    "a&, a": Object.assign(Object.assign({}, _z(e)), {
      textDecoration: e.linkDecoration,
      "&:active, &:hover": {
        textDecoration: e.linkHoverDecoration
      },
      [`&[disabled], &${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: e.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    })
  };
}, qle = (e) => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    fontFamily: e.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    fontFamily: e.fontFamilyCode,
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: AE[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    fontFamily: e.fontFamilyCode,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
}), Zle = (e) => {
  const {
    componentCls: t,
    paddingSM: r
  } = e, n = r;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: e.calc(e.paddingSM).mul(-1).equal(),
        marginTop: e.calc(n).mul(-1).equal(),
        marginBottom: `calc(1em - ${xe(n)})`
      },
      [`${t}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: e.calc(e.marginXS).add(2).equal(),
        insetBlockEnd: e.marginXS,
        color: e.colorTextDescription,
        // default style
        fontWeight: "normal",
        fontSize: e.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
}, Xle = (e) => ({
  [`${e.componentCls}-copy-success`]: {
    "\n    &,\n    &:hover,\n    &:focus": {
      color: e.colorSuccess
    }
  },
  [`${e.componentCls}-copy-icon-only`]: {
    marginInlineStart: 0
  }
}), Qle = () => ({
  "\n  a&-ellipsis,\n  span&-ellipsis\n  ": {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-ellipsis-single-line": {
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    },
    "> code": {
      paddingBlock: 0,
      maxWidth: "calc(100% - 1.2em)",
      display: "inline-block",
      overflow: "hidden",
      textOverflow: "ellipsis",
      verticalAlign: "bottom",
      // https://github.com/ant-design/ant-design/issues/45953
      boxSizing: "content-box"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
}), Jle = (e) => {
  const {
    componentCls: t,
    titleMarginTop: r
  } = e;
  return {
    [t]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: e.colorText,
      wordBreak: "break-word",
      lineHeight: e.lineHeight,
      [`&${t}-secondary`]: {
        color: e.colorTextDescription
      },
      [`&${t}-success`]: {
        color: e.colorSuccess
      },
      [`&${t}-warning`]: {
        color: e.colorWarning
      },
      [`&${t}-danger`]: {
        color: e.colorError,
        "a&:active, a&:focus": {
          color: e.colorErrorActive
        },
        "a&:hover": {
          color: e.colorErrorHover
        }
      },
      [`&${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      "\n        div&,\n        p\n      ": {
        marginBottom: "1em"
      }
    }, Kle(e)), {
      [`
      & + h1${t},
      & + h2${t},
      & + h3${t},
      & + h4${t},
      & + h5${t}
      `]: {
        marginTop: r
      },
      "\n      div,\n      ul,\n      li,\n      p,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5": {
        "\n        + h1,\n        + h2,\n        + h3,\n        + h4,\n        + h5\n        ": {
          marginTop: r
        }
      }
    }), qle(e)), Yle(e)), {
      // Operation
      [`
        ${t}-expand,
        ${t}-collapse,
        ${t}-edit,
        ${t}-copy
      `]: Object.assign(Object.assign({}, _z(e)), {
        marginInlineStart: e.marginXXS
      })
    }), Zle(e)), Xle(e)), Qle()), {
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, eue = () => ({
  titleMarginTop: "1.2em",
  titleMarginBottom: "0.5em"
}), q8 = Gi("Typography", (e) => [Jle(e)], eue), tue = (e) => {
  const {
    prefixCls: t,
    "aria-label": r,
    className: n,
    style: i,
    direction: o,
    maxLength: a,
    autoSize: s = !0,
    value: l,
    onSave: u,
    onCancel: c,
    onEnd: d,
    component: h,
    enterIcon: f = /* @__PURE__ */ T.createElement(Y8, null)
  } = e, p = T.useRef(null), g = T.useRef(!1), v = T.useRef(), [m, y] = T.useState(l);
  T.useEffect(() => {
    y(l);
  }, [l]), T.useEffect(() => {
    var O;
    if (!((O = p.current) === null || O === void 0) && O.resizableTextArea) {
      const {
        textArea: L
      } = p.current.resizableTextArea;
      L.focus();
      const {
        length: N
      } = L.value;
      L.setSelectionRange(N, N);
    }
  }, []);
  const C = (O) => {
    let {
      target: L
    } = O;
    y(L.value.replace(/[\n\r]/g, ""));
  }, S = () => {
    g.current = !0;
  }, b = () => {
    g.current = !1;
  }, w = (O) => {
    let {
      keyCode: L
    } = O;
    g.current || (v.current = L);
  }, x = () => {
    u(m.trim());
  }, E = (O) => {
    let {
      keyCode: L,
      ctrlKey: N,
      altKey: F,
      metaKey: G,
      shiftKey: M
    } = O;
    v.current === L && !g.current && !N && !F && !G && !M && (L === Ue.ENTER ? (x(), d == null || d()) : L === Ue.ESC && c());
  }, R = () => {
    x();
  }, _ = h ? `${t}-${h}` : "", [P, D, I] = q8(t), A = pe(t, `${t}-edit-content`, {
    [`${t}-rtl`]: o === "rtl"
  }, n, _, D, I);
  return P(/* @__PURE__ */ T.createElement("div", {
    className: A,
    style: i
  }, /* @__PURE__ */ T.createElement(_P, {
    ref: p,
    maxLength: a,
    value: m,
    onChange: C,
    onKeyDown: w,
    onKeyUp: E,
    onCompositionStart: S,
    onCompositionEnd: b,
    onBlur: R,
    "aria-label": r,
    rows: 1,
    autoSize: s
  }), f !== null ? Rc(f, {
    className: `${t}-edit-content-confirm`
  }) : null));
};
var rue = function() {
  var e = document.getSelection();
  if (!e.rangeCount)
    return function() {
    };
  for (var t = document.activeElement, r = [], n = 0; n < e.rangeCount; n++)
    r.push(e.getRangeAt(n));
  switch (t.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      t.blur();
      break;
    default:
      t = null;
      break;
  }
  return e.removeAllRanges(), function() {
    e.type === "Caret" && e.removeAllRanges(), e.rangeCount || r.forEach(function(i) {
      e.addRange(i);
    }), t && t.focus();
  };
}, nue = rue, wF = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, iue = "Copy to clipboard: #{key}, Enter";
function oue(e) {
  var t = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return e.replace(/#{\s*key\s*}/g, t);
}
function aue(e, t) {
  var r, n, i, o, a, s, l = !1;
  t || (t = {}), r = t.debug || !1;
  try {
    i = nue(), o = document.createRange(), a = document.getSelection(), s = document.createElement("span"), s.textContent = e, s.ariaHidden = "true", s.style.all = "unset", s.style.position = "fixed", s.style.top = 0, s.style.clip = "rect(0, 0, 0, 0)", s.style.whiteSpace = "pre", s.style.webkitUserSelect = "text", s.style.MozUserSelect = "text", s.style.msUserSelect = "text", s.style.userSelect = "text", s.addEventListener("copy", function(c) {
      if (c.stopPropagation(), t.format)
        if (c.preventDefault(), typeof c.clipboardData > "u") {
          r && console.warn("unable to use e.clipboardData"), r && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          var d = wF[t.format] || wF.default;
          window.clipboardData.setData(d, e);
        } else
          c.clipboardData.clearData(), c.clipboardData.setData(t.format, e);
      t.onCopy && (c.preventDefault(), t.onCopy(c.clipboardData));
    }), document.body.appendChild(s), o.selectNodeContents(s), a.addRange(o);
    var u = document.execCommand("copy");
    if (!u)
      throw new Error("copy command was unsuccessful");
    l = !0;
  } catch (c) {
    r && console.error("unable to copy using execCommand: ", c), r && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(t.format || "text", e), t.onCopy && t.onCopy(window.clipboardData), l = !0;
    } catch (d) {
      r && console.error("unable to copy using clipboardData: ", d), r && console.error("falling back to prompt"), n = oue("message" in t ? t.message : iue), window.prompt(n, e);
    }
  } finally {
    a && (typeof a.removeRange == "function" ? a.removeRange(o) : a.removeAllRanges()), s && document.body.removeChild(s), i();
  }
  return l;
}
var sue = aue;
const lue = /* @__PURE__ */ Uh(sue);
var uue = function(e, t, r, n) {
  function i(o) {
    return o instanceof r ? o : new r(function(a) {
      a(o);
    });
  }
  return new (r || (r = Promise))(function(o, a) {
    function s(c) {
      try {
        u(n.next(c));
      } catch (d) {
        a(d);
      }
    }
    function l(c) {
      try {
        u(n.throw(c));
      } catch (d) {
        a(d);
      }
    }
    function u(c) {
      c.done ? o(c.value) : i(c.value).then(s, l);
    }
    u((n = n.apply(e, t || [])).next());
  });
};
const cue = (e) => {
  let {
    copyConfig: t,
    children: r
  } = e;
  const [n, i] = T.useState(!1), [o, a] = T.useState(!1), s = T.useRef(null), l = () => {
    s.current && clearTimeout(s.current);
  }, u = {};
  t.format && (u.format = t.format), T.useEffect(() => l, []);
  const c = Mn((d) => uue(void 0, void 0, void 0, function* () {
    var h;
    d == null || d.preventDefault(), d == null || d.stopPropagation(), a(!0);
    try {
      const f = typeof t.text == "function" ? yield t.text() : t.text;
      lue(f || String(r) || "", u), a(!1), i(!0), l(), s.current = setTimeout(() => {
        i(!1);
      }, 3e3), (h = t.onCopy) === null || h === void 0 || h.call(t, d);
    } catch (f) {
      throw a(!1), f;
    }
  }));
  return {
    copied: n,
    copyLoading: o,
    onClick: c
  };
};
function Xw(e, t) {
  return T.useMemo(() => {
    const r = !!e;
    return [r, Object.assign(Object.assign({}, t), r && typeof e == "object" ? e : null)];
  }, [e]);
}
const due = (e) => {
  const t = le();
  return It(() => {
    t.current = e;
  }), t.current;
}, hue = (e, t) => {
  const r = T.useRef(!1);
  T.useEffect(() => {
    r.current ? e() : r.current = !0;
  }, t);
};
var fue = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const AP = /* @__PURE__ */ T.forwardRef((e, t) => {
  const {
    prefixCls: r,
    component: n = "article",
    className: i,
    rootClassName: o,
    setContentRef: a,
    children: s,
    direction: l,
    style: u
  } = e, c = fue(e, ["prefixCls", "component", "className", "rootClassName", "setContentRef", "children", "direction", "style"]), {
    getPrefixCls: d,
    direction: h,
    typography: f
  } = T.useContext(Xt), p = l ?? h;
  let g = t;
  a && (g = Vo(t, a)), process.env.NODE_ENV !== "production" && mn("Typography").deprecated(!a, "setContentRef", "ref");
  const v = d("typography", r), [m, y, C] = q8(v), S = pe(v, f == null ? void 0 : f.className, {
    [`${v}-rtl`]: p === "rtl"
  }, i, o, y, C), b = Object.assign(Object.assign({}, f == null ? void 0 : f.style), u);
  return m(
    // @ts-expect-error: Expression produces a union type that is too complex to represent.
    /* @__PURE__ */ T.createElement(n, Object.assign({
      className: S,
      style: b,
      ref: g
    }, c), s)
  );
});
process.env.NODE_ENV !== "production" && (AP.displayName = "Typography");
var pue = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, name: "copy", theme: "outlined" }, gue = function(t, r) {
  return /* @__PURE__ */ T.createElement(zr, ze({}, t, {
    ref: r,
    icon: pue
  }));
}, Z8 = /* @__PURE__ */ T.forwardRef(gue);
process.env.NODE_ENV !== "production" && (Z8.displayName = "CopyOutlined");
function bF(e) {
  return e === !1 ? [!1, !1] : Array.isArray(e) ? e : [e];
}
function mm(e, t, r) {
  return e === !0 || e === void 0 ? t : e || r && t;
}
const vue = (e) => {
  const {
    prefixCls: t,
    copied: r,
    locale: n,
    iconOnly: i,
    tooltips: o,
    icon: a,
    loading: s,
    tabIndex: l,
    onCopy: u
  } = e, c = bF(o), d = bF(a), {
    copied: h,
    copy: f
  } = n ?? {}, p = r ? mm(c[1], h) : mm(c[0], f), v = typeof p == "string" ? p : r ? h : f;
  return /* @__PURE__ */ T.createElement(Hc, {
    key: "copy",
    title: p
  }, /* @__PURE__ */ T.createElement(fR, {
    className: pe(`${t}-copy`, {
      [`${t}-copy-success`]: r,
      [`${t}-copy-icon-only`]: i
    }),
    onClick: u,
    "aria-label": v,
    tabIndex: l
  }, r ? mm(d[1], /* @__PURE__ */ T.createElement(L5, null), !0) : mm(d[0], s ? /* @__PURE__ */ T.createElement(eP, null) : /* @__PURE__ */ T.createElement(Z8, null), !0)));
}, ym = /* @__PURE__ */ T.forwardRef((e, t) => {
  let {
    style: r,
    children: n
  } = e;
  const i = T.useRef(null);
  return T.useImperativeHandle(t, () => ({
    isExceed: () => {
      const o = i.current;
      return o.scrollHeight > o.clientHeight;
    },
    getHeight: () => i.current.clientHeight
  })), /* @__PURE__ */ T.createElement("span", {
    "aria-hidden": !0,
    ref: i,
    style: Object.assign({
      position: "fixed",
      display: "block",
      left: 0,
      top: 0,
      pointerEvents: "none",
      backgroundColor: "rgba(255, 0, 0, 0.65)"
    }, r)
  }, n);
});
function X8(e) {
  const t = typeof e;
  return t === "string" || t === "number";
}
function mue(e) {
  let t = 0;
  return e.forEach((r) => {
    X8(r) ? t += String(r).length : t += 1;
  }), t;
}
function xF(e, t) {
  let r = 0;
  const n = [];
  for (let i = 0; i < e.length; i += 1) {
    if (r === t)
      return n;
    const o = e[i], s = X8(o) ? String(o).length : 1, l = r + s;
    if (l > t) {
      const u = t - r;
      return n.push(String(o).slice(0, u)), n;
    }
    n.push(o), r = l;
  }
  return e;
}
const Qw = 0, Jw = 1, eb = 2, tb = 3, EF = 4, Cm = {
  display: "-webkit-box",
  overflow: "hidden",
  WebkitBoxOrient: "vertical"
};
function yue(e) {
  const {
    enableMeasure: t,
    width: r,
    text: n,
    children: i,
    rows: o,
    expanded: a,
    miscDeps: s,
    onEllipsis: l
  } = e, u = T.useMemo(() => Gl(n), [n]), c = T.useMemo(() => mue(u), [n]), d = T.useMemo(() => i(u, !1), [n]), [h, f] = T.useState(null), p = T.useRef(null), g = T.useRef(null), v = T.useRef(null), m = T.useRef(null), y = T.useRef(null), [C, S] = T.useState(!1), [b, w] = T.useState(Qw), [x, E] = T.useState(0), [R, _] = T.useState(null);
  Wr(() => {
    w(t && r && c ? Jw : Qw);
  }, [r, n, o, t, u]), Wr(() => {
    var A, O, L, N;
    if (b === Jw) {
      w(eb);
      const F = g.current && getComputedStyle(g.current).whiteSpace;
      _(F);
    } else if (b === eb) {
      const F = !!(!((A = v.current) === null || A === void 0) && A.isExceed());
      w(F ? tb : EF), f(F ? [0, c] : null), S(F);
      const G = ((O = v.current) === null || O === void 0 ? void 0 : O.getHeight()) || 0, M = o === 1 ? 0 : ((L = m.current) === null || L === void 0 ? void 0 : L.getHeight()) || 0, V = ((N = y.current) === null || N === void 0 ? void 0 : N.getHeight()) || 0, z = M + V, k = Math.max(G, z);
      E(k + 1), l(F);
    }
  }, [b]);
  const P = h ? Math.ceil((h[0] + h[1]) / 2) : 0;
  Wr(() => {
    var A;
    const [O, L] = h || [0, 0];
    if (O !== L) {
      const F = (((A = p.current) === null || A === void 0 ? void 0 : A.getHeight()) || 0) > x;
      let G = P;
      L - O === 1 && (G = F ? O : L), f(F ? [O, G] : [G, L]);
    }
  }, [h, P]);
  const D = T.useMemo(() => {
    if (b !== tb || !h || h[0] !== h[1]) {
      const A = i(u, !1);
      return b !== EF && b !== Qw ? /* @__PURE__ */ T.createElement("span", {
        style: Object.assign(Object.assign({}, Cm), {
          WebkitLineClamp: o
        })
      }, A) : A;
    }
    return i(a ? u : xF(u, h[0]), C);
  }, [a, b, h, u].concat(rt(s))), I = {
    width: r,
    margin: 0,
    padding: 0,
    whiteSpace: R === "nowrap" ? "normal" : "inherit"
  };
  return /* @__PURE__ */ T.createElement(T.Fragment, null, D, b === eb && /* @__PURE__ */ T.createElement(T.Fragment, null, /* @__PURE__ */ T.createElement(ym, {
    style: Object.assign(Object.assign(Object.assign({}, I), Cm), {
      WebkitLineClamp: o
    }),
    ref: v
  }, d), /* @__PURE__ */ T.createElement(ym, {
    style: Object.assign(Object.assign(Object.assign({}, I), Cm), {
      WebkitLineClamp: o - 1
    }),
    ref: m
  }, d), /* @__PURE__ */ T.createElement(ym, {
    style: Object.assign(Object.assign(Object.assign({}, I), Cm), {
      WebkitLineClamp: 1
    }),
    ref: y
  }, i([], !0))), b === tb && h && h[0] !== h[1] && /* @__PURE__ */ T.createElement(ym, {
    style: Object.assign(Object.assign({}, I), {
      top: 400
    }),
    ref: p
  }, i(xF(u, P), !0)), b === Jw && /* @__PURE__ */ T.createElement("span", {
    style: {
      whiteSpace: "inherit"
    },
    ref: g
  }));
}
const Q8 = (e) => {
  let {
    enableEllipsis: t,
    isEllipsis: r,
    children: n,
    tooltipProps: i
  } = e;
  return !(i != null && i.title) || !t ? n : /* @__PURE__ */ T.createElement(Hc, Object.assign({
    open: r ? void 0 : !1
  }, i), n);
};
process.env.NODE_ENV !== "production" && (Q8.displayName = "EllipsisTooltip");
var Cue = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
function Sue(e, t) {
  let {
    mark: r,
    code: n,
    underline: i,
    delete: o,
    strong: a,
    keyboard: s,
    italic: l
  } = e, u = t;
  function c(d, h) {
    h && (u = /* @__PURE__ */ T.createElement(d, {}, u));
  }
  return c("strong", a), c("u", i), c("del", o), c("code", n), c("mark", r), c("kbd", s), c("i", l), u;
}
const wue = "...", gS = /* @__PURE__ */ T.forwardRef((e, t) => {
  var r, n, i;
  const {
    prefixCls: o,
    className: a,
    style: s,
    type: l,
    disabled: u,
    children: c,
    ellipsis: d,
    editable: h,
    copyable: f,
    component: p,
    title: g
  } = e, v = Cue(e, ["prefixCls", "className", "style", "type", "disabled", "children", "ellipsis", "editable", "copyable", "component", "title"]), {
    getPrefixCls: m,
    direction: y
  } = T.useContext(Xt), [C] = hz("Text"), S = T.useRef(null), b = T.useRef(null), w = m("typography", o), x = Bi(v, ["mark", "code", "delete", "underline", "strong", "keyboard", "italic"]), [E, R] = Xw(h), [_, P] = Nn(!1, {
    value: R.editing
  }), {
    triggerType: D = ["icon"]
  } = R, I = (Oe) => {
    var je;
    Oe && ((je = R.onStart) === null || je === void 0 || je.call(R)), P(Oe);
  }, A = due(_);
  hue(() => {
    var Oe;
    !_ && A && ((Oe = b.current) === null || Oe === void 0 || Oe.focus());
  }, [_]);
  const O = (Oe) => {
    Oe == null || Oe.preventDefault(), I(!0);
  }, L = (Oe) => {
    var je;
    (je = R.onChange) === null || je === void 0 || je.call(R, Oe), I(!1);
  }, N = () => {
    var Oe;
    (Oe = R.onCancel) === null || Oe === void 0 || Oe.call(R), I(!1);
  }, [F, G] = Xw(f), {
    copied: M,
    copyLoading: V,
    onClick: z
  } = cue({
    copyConfig: G,
    children: c
  }), [k, $] = T.useState(!1), [W, j] = T.useState(!1), [U, Z] = T.useState(!1), [ee, J] = T.useState(!1), [X, Y] = T.useState(!0), [de, K] = Xw(d, {
    expandable: !1,
    symbol: (Oe) => Oe ? C == null ? void 0 : C.collapse : C == null ? void 0 : C.expand
  }), [ie, Ce] = Nn(K.defaultExpanded || !1, {
    value: K.expanded
  }), Te = de && (!ie || K.expandable === "collapsible"), {
    rows: Ie = 1
  } = K, we = T.useMemo(() => (
    // Disable ellipsis
    Te && // Provide suffix
    (K.suffix !== void 0 || K.onEllipsis || // Can't use css ellipsis since we need to provide the place for button
    K.expandable || E || F)
  ), [Te, K, E, F]);
  Wr(() => {
    de && !we && ($(k2("webkitLineClamp")), j(k2("textOverflow")));
  }, [we, de]);
  const [Re, _e] = T.useState(Te), He = T.useMemo(() => we ? !1 : Ie === 1 ? W : k, [we, W, k]);
  Wr(() => {
    _e(He && Te);
  }, [He, Te]);
  const Ve = Te && (Re ? ee : U), $e = Te && Ie === 1 && Re, Je = Te && Ie > 1 && Re, Q = (Oe, je) => {
    var pt;
    Ce(je.expanded), (pt = K.onExpand) === null || pt === void 0 || pt.call(K, Oe, je);
  }, [ye, Ge] = T.useState(0), Pe = (Oe) => {
    let {
      offsetWidth: je
    } = Oe;
    Ge(je);
  }, Le = (Oe) => {
    var je;
    Z(Oe), U !== Oe && ((je = K.onEllipsis) === null || je === void 0 || je.call(K, Oe));
  };
  T.useEffect(() => {
    const Oe = S.current;
    if (de && Re && Oe) {
      const je = Je ? Oe.offsetHeight < Oe.scrollHeight : Oe.offsetWidth < Oe.scrollWidth;
      ee !== je && J(je);
    }
  }, [de, Re, c, Je, X, ye]), T.useEffect(() => {
    const Oe = S.current;
    if (typeof IntersectionObserver > "u" || !Oe || !Re || !Te)
      return;
    const je = new IntersectionObserver(() => {
      Y(!!Oe.offsetParent);
    });
    return je.observe(Oe), () => {
      je.disconnect();
    };
  }, [Re, Te]);
  let me = {};
  K.tooltip === !0 ? me = {
    title: (r = R.text) !== null && r !== void 0 ? r : c
  } : /* @__PURE__ */ T.isValidElement(K.tooltip) ? me = {
    title: K.tooltip
  } : typeof K.tooltip == "object" ? me = Object.assign({
    title: (n = R.text) !== null && n !== void 0 ? n : c
  }, K.tooltip) : me = {
    title: K.tooltip
  };
  const De = T.useMemo(() => {
    const Oe = (je) => ["string", "number"].includes(typeof je);
    if (!(!de || Re)) {
      if (Oe(R.text))
        return R.text;
      if (Oe(c))
        return c;
      if (Oe(g))
        return g;
      if (Oe(me.title))
        return me.title;
    }
  }, [de, Re, g, me.title, Ve]);
  if (_)
    return /* @__PURE__ */ T.createElement(tue, {
      value: (i = R.text) !== null && i !== void 0 ? i : typeof c == "string" ? c : "",
      onSave: L,
      onCancel: N,
      onEnd: R.onEnd,
      prefixCls: w,
      className: a,
      style: s,
      direction: y,
      component: p,
      maxLength: R.maxLength,
      autoSize: R.autoSize,
      enterIcon: R.enterIcon
    });
  const qe = () => {
    const {
      expandable: Oe,
      symbol: je
    } = K;
    return !Oe || ie && Oe !== "collapsible" ? null : /* @__PURE__ */ T.createElement(fR, {
      key: "expand",
      className: `${w}-${ie ? "collapse" : "expand"}`,
      onClick: (pt) => Q(pt, {
        expanded: !ie
      }),
      "aria-label": ie ? C.collapse : C == null ? void 0 : C.expand
    }, typeof je == "function" ? je(ie) : je);
  }, ht = () => {
    if (!E)
      return;
    const {
      icon: Oe,
      tooltip: je,
      tabIndex: pt
    } = R, wt = Gl(je)[0] || (C == null ? void 0 : C.edit), $r = typeof wt == "string" ? wt : "";
    return D.includes("icon") ? /* @__PURE__ */ T.createElement(Hc, {
      key: "edit",
      title: je === !1 ? "" : wt
    }, /* @__PURE__ */ T.createElement(fR, {
      ref: b,
      className: `${w}-edit`,
      onClick: O,
      "aria-label": $r,
      tabIndex: pt
    }, Oe || /* @__PURE__ */ T.createElement(K8, {
      role: "button"
    }))) : null;
  }, Tt = () => F ? /* @__PURE__ */ T.createElement(vue, Object.assign({
    key: "copy"
  }, G, {
    prefixCls: w,
    copied: M,
    locale: C,
    onCopy: z,
    loading: V,
    iconOnly: c == null
  })) : null, lt = (Oe) => [
    // (renderExpanded || ellipsisConfig.collapsible) && renderExpand(),
    Oe && qe(),
    ht(),
    Tt()
  ], tt = (Oe) => [Oe && !ie && /* @__PURE__ */ T.createElement("span", {
    "aria-hidden": !0,
    key: "ellipsis"
  }, wue), K.suffix, lt(Oe)];
  return /* @__PURE__ */ T.createElement(la, {
    onResize: Pe,
    disabled: !Te
  }, (Oe) => /* @__PURE__ */ T.createElement(Q8, {
    tooltipProps: me,
    enableEllipsis: Te,
    isEllipsis: Ve
  }, /* @__PURE__ */ T.createElement(AP, Object.assign({
    className: pe({
      [`${w}-${l}`]: l,
      [`${w}-disabled`]: u,
      [`${w}-ellipsis`]: de,
      [`${w}-ellipsis-single-line`]: $e,
      [`${w}-ellipsis-multiple-line`]: Je
    }, a),
    prefixCls: o,
    style: Object.assign(Object.assign({}, s), {
      WebkitLineClamp: Je ? Ie : void 0
    }),
    component: p,
    ref: Vo(Oe, S, t),
    direction: y,
    onClick: D.includes("text") ? O : void 0,
    "aria-label": De == null ? void 0 : De.toString(),
    title: g
  }, x), /* @__PURE__ */ T.createElement(yue, {
    enableMeasure: Te && !Re,
    text: c,
    rows: Ie,
    width: ye,
    onEllipsis: Le,
    expanded: ie,
    miscDeps: [M, ie, V, E, F]
  }, (je, pt) => Sue(e, /* @__PURE__ */ T.createElement(T.Fragment, null, je.length > 0 && pt && !ie && De ? /* @__PURE__ */ T.createElement("span", {
    key: "show-content",
    "aria-hidden": !0
  }, je) : je, tt(pt)))))));
});
var bue = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const xue = /* @__PURE__ */ T.forwardRef((e, t) => {
  var {
    ellipsis: r,
    rel: n
  } = e, i = bue(e, ["ellipsis", "rel"]);
  if (process.env.NODE_ENV !== "production") {
    const a = mn("Typography.Link");
    process.env.NODE_ENV !== "production" && a(typeof r != "object", "usage", "`ellipsis` only supports boolean value.");
  }
  const o = Object.assign(Object.assign({}, i), {
    rel: n === void 0 && i.target === "_blank" ? "noopener noreferrer" : n
  });
  return delete o.navigate, /* @__PURE__ */ T.createElement(gS, Object.assign({}, o, {
    ref: t,
    ellipsis: !!r,
    component: "a"
  }));
}), Eue = /* @__PURE__ */ T.forwardRef((e, t) => /* @__PURE__ */ T.createElement(gS, Object.assign({
  ref: t
}, e, {
  component: "div"
})));
var Rue = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const _ue = (e, t) => {
  var {
    ellipsis: r
  } = e, n = Rue(e, ["ellipsis"]);
  const i = T.useMemo(() => r && typeof r == "object" ? Bi(r, ["expandable", "rows"]) : r, [r]);
  if (process.env.NODE_ENV !== "production") {
    const o = mn("Typography.Text");
    process.env.NODE_ENV !== "production" && o(typeof r != "object" || !r || !("expandable" in r) && !("rows" in r), "usage", "`ellipsis` do not support `expandable` or `rows` props.");
  }
  return /* @__PURE__ */ T.createElement(gS, Object.assign({
    ref: t
  }, n, {
    ellipsis: i,
    component: "span"
  }));
}, Tue = /* @__PURE__ */ T.forwardRef(_ue);
var Pue = function(e, t) {
  var r = {};
  for (var n in e) Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0 && (r[n] = e[n]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var i = 0, n = Object.getOwnPropertySymbols(e); i < n.length; i++)
    t.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[i]) && (r[n[i]] = e[n[i]]);
  return r;
};
const RF = [1, 2, 3, 4, 5], Mue = /* @__PURE__ */ T.forwardRef((e, t) => {
  const {
    level: r = 1
  } = e, n = Pue(e, ["level"]);
  let i;
  if (process.env.NODE_ENV !== "production") {
    const o = mn("Typography.Title");
    process.env.NODE_ENV !== "production" && o(RF.includes(r), "usage", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value. And `5` need 4.6.0+ version.");
  }
  return RF.includes(r) ? i = `h${r}` : i = "h1", /* @__PURE__ */ T.createElement(gS, Object.assign({
    ref: t
  }, n, {
    component: i
  }));
}), Ur = AP;
Ur.Text = Tue;
Ur.Link = xue;
Ur.Title = Mue;
Ur.Paragraph = Eue;
const J8 = ({
  inputRef: e,
  placeholder: t = "Ask me anything about your product data",
  userQuery: r,
  setUserQuery: n,
  handleSendMessage: i,
  isFollowupDisabled: o = !1
}) => {
  const a = r.trim().length === 0 || o, s = (l) => {
    l.key === "Enter" && !l.shiftKey && (l.stopPropagation(), l.preventDefault(), a || i());
  };
  return /* @__PURE__ */ ce.jsxs(
    fr,
    {
      vertical: !0,
      style: {
        position: "absolute",
        bottom: 0,
        left: 0,
        right: 0,
        marginLeft: "auto",
        marginRight: "auto",
        width: "60vw"
      },
      children: [
        /* @__PURE__ */ ce.jsx(
          "div",
          {
            style: {
              backgroundImage: "linear-gradient(180deg, transparent 23%, var(--background) 97%)",
              height: "6vh"
            }
          }
        ),
        /* @__PURE__ */ ce.jsx(
          Lo,
          {
            size: "small",
            bordered: !0,
            style: {
              width: "100%",
              borderBottomLeftRadius: 0,
              borderBottomRightRadius: 0
            },
            styles: {
              body: {
                padding: 16
              }
            },
            children: /* @__PURE__ */ ce.jsxs(fr, { vertical: !0, gap: 16, children: [
              /* @__PURE__ */ ce.jsxs(fr, { align: "flex-start", gap: 12, children: [
                /* @__PURE__ */ ce.jsx(
                  _P,
                  {
                    ref: e,
                    value: r,
                    onChange: (l) => n(l.target.value),
                    autoSize: { minRows: 1, maxRows: 8 },
                    size: "large",
                    variant: "borderless",
                    placeholder: t,
                    onKeyDown: s
                  }
                ),
                /* @__PURE__ */ ce.jsx(
                  Qn,
                  {
                    disabled: a,
                    size: "large",
                    type: "primary",
                    shape: "circle",
                    onClick: i,
                    icon: /* @__PURE__ */ ce.jsx(VT, { weight: "bold" })
                  }
                )
              ] }),
              /* @__PURE__ */ ce.jsx(fr, { align: "flex-end", justify: "flex-end", children: /* @__PURE__ */ ce.jsxs(
                Ur.Text,
                {
                  type: "secondary",
                  style: {
                    fontWeight: 500,
                    fontSize: "0.75rem",
                    visibility: r.trim().length > 0 ? "visible" : "hidden"
                  },
                  children: [
                    "Use",
                    " ",
                    /* @__PURE__ */ ce.jsx(
                      Ur.Text,
                      {
                        type: "secondary",
                        style: {
                          backgroundColor: "var(--background)",
                          fontWeight: 500,
                          fontSize: "0.75rem",
                          padding: "3px 6px",
                          borderRadius: 4
                        },
                        children: "shift + enter"
                      }
                    ),
                    " ",
                    "for new line"
                  ]
                }
              ) })
            ] })
          }
        )
      ]
    }
  );
};
var pR = { exports: {} }, rb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _F;
function Due() {
  return _F || (_F = 1, function(e) {
    function t(F, G) {
      var M = F.length;
      F.push(G);
      e: for (; 0 < M; ) {
        var V = M - 1 >>> 1, z = F[V];
        if (0 < i(z, G)) F[V] = G, F[M] = z, M = V;
        else break e;
      }
    }
    function r(F) {
      return F.length === 0 ? null : F[0];
    }
    function n(F) {
      if (F.length === 0) return null;
      var G = F[0], M = F.pop();
      if (M !== G) {
        F[0] = M;
        e: for (var V = 0, z = F.length, k = z >>> 1; V < k; ) {
          var $ = 2 * (V + 1) - 1, W = F[$], j = $ + 1, U = F[j];
          if (0 > i(W, M)) j < z && 0 > i(U, W) ? (F[V] = U, F[j] = M, V = j) : (F[V] = W, F[$] = M, V = $);
          else if (j < z && 0 > i(U, M)) F[V] = U, F[j] = M, V = j;
          else break e;
        }
      }
      return G;
    }
    function i(F, G) {
      var M = F.sortIndex - G.sortIndex;
      return M !== 0 ? M : F.id - G.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var o = performance;
      e.unstable_now = function() {
        return o.now();
      };
    } else {
      var a = Date, s = a.now();
      e.unstable_now = function() {
        return a.now() - s;
      };
    }
    var l = [], u = [], c = 1, d = null, h = 3, f = !1, p = !1, g = !1, v = typeof setTimeout == "function" ? setTimeout : null, m = typeof clearTimeout == "function" ? clearTimeout : null, y = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function C(F) {
      for (var G = r(u); G !== null; ) {
        if (G.callback === null) n(u);
        else if (G.startTime <= F) n(u), G.sortIndex = G.expirationTime, t(l, G);
        else break;
        G = r(u);
      }
    }
    function S(F) {
      if (g = !1, C(F), !p) if (r(l) !== null) p = !0, L(b);
      else {
        var G = r(u);
        G !== null && N(S, G.startTime - F);
      }
    }
    function b(F, G) {
      p = !1, g && (g = !1, m(E), E = -1), f = !0;
      var M = h;
      try {
        for (C(G), d = r(l); d !== null && (!(d.expirationTime > G) || F && !P()); ) {
          var V = d.callback;
          if (typeof V == "function") {
            d.callback = null, h = d.priorityLevel;
            var z = V(d.expirationTime <= G);
            G = e.unstable_now(), typeof z == "function" ? d.callback = z : d === r(l) && n(l), C(G);
          } else n(l);
          d = r(l);
        }
        if (d !== null) var k = !0;
        else {
          var $ = r(u);
          $ !== null && N(S, $.startTime - G), k = !1;
        }
        return k;
      } finally {
        d = null, h = M, f = !1;
      }
    }
    var w = !1, x = null, E = -1, R = 5, _ = -1;
    function P() {
      return !(e.unstable_now() - _ < R);
    }
    function D() {
      if (x !== null) {
        var F = e.unstable_now();
        _ = F;
        var G = !0;
        try {
          G = x(!0, F);
        } finally {
          G ? I() : (w = !1, x = null);
        }
      } else w = !1;
    }
    var I;
    if (typeof y == "function") I = function() {
      y(D);
    };
    else if (typeof MessageChannel < "u") {
      var A = new MessageChannel(), O = A.port2;
      A.port1.onmessage = D, I = function() {
        O.postMessage(null);
      };
    } else I = function() {
      v(D, 0);
    };
    function L(F) {
      x = F, w || (w = !0, I());
    }
    function N(F, G) {
      E = v(function() {
        F(e.unstable_now());
      }, G);
    }
    e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function(F) {
      F.callback = null;
    }, e.unstable_continueExecution = function() {
      p || f || (p = !0, L(b));
    }, e.unstable_forceFrameRate = function(F) {
      0 > F || 125 < F ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : R = 0 < F ? Math.floor(1e3 / F) : 5;
    }, e.unstable_getCurrentPriorityLevel = function() {
      return h;
    }, e.unstable_getFirstCallbackNode = function() {
      return r(l);
    }, e.unstable_next = function(F) {
      switch (h) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = h;
      }
      var M = h;
      h = G;
      try {
        return F();
      } finally {
        h = M;
      }
    }, e.unstable_pauseExecution = function() {
    }, e.unstable_requestPaint = function() {
    }, e.unstable_runWithPriority = function(F, G) {
      switch (F) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          F = 3;
      }
      var M = h;
      h = F;
      try {
        return G();
      } finally {
        h = M;
      }
    }, e.unstable_scheduleCallback = function(F, G, M) {
      var V = e.unstable_now();
      switch (typeof M == "object" && M !== null ? (M = M.delay, M = typeof M == "number" && 0 < M ? V + M : V) : M = V, F) {
        case 1:
          var z = -1;
          break;
        case 2:
          z = 250;
          break;
        case 5:
          z = 1073741823;
          break;
        case 4:
          z = 1e4;
          break;
        default:
          z = 5e3;
      }
      return z = M + z, F = { id: c++, callback: G, priorityLevel: F, startTime: M, expirationTime: z, sortIndex: -1 }, M > V ? (F.sortIndex = M, t(u, F), r(l) === null && F === r(u) && (g ? (m(E), E = -1) : g = !0, N(S, M - V))) : (F.sortIndex = z, t(l, F), p || f || (p = !0, L(b))), F;
    }, e.unstable_shouldYield = P, e.unstable_wrapCallback = function(F) {
      var G = h;
      return function() {
        var M = h;
        h = G;
        try {
          return F.apply(this, arguments);
        } finally {
          h = M;
        }
      };
    };
  }(rb)), rb;
}
var nb = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TF;
function Aue() {
  return TF || (TF = 1, function(e) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, r = !1, n = 5;
      function i(me, De) {
        var qe = me.length;
        me.push(De), s(me, De, qe);
      }
      function o(me) {
        return me.length === 0 ? null : me[0];
      }
      function a(me) {
        if (me.length === 0)
          return null;
        var De = me[0], qe = me.pop();
        return qe !== De && (me[0] = qe, l(me, qe, 0)), De;
      }
      function s(me, De, qe) {
        for (var ht = qe; ht > 0; ) {
          var Tt = ht - 1 >>> 1, lt = me[Tt];
          if (u(lt, De) > 0)
            me[Tt] = De, me[ht] = lt, ht = Tt;
          else
            return;
        }
      }
      function l(me, De, qe) {
        for (var ht = qe, Tt = me.length, lt = Tt >>> 1; ht < lt; ) {
          var tt = (ht + 1) * 2 - 1, Oe = me[tt], je = tt + 1, pt = me[je];
          if (u(Oe, De) < 0)
            je < Tt && u(pt, Oe) < 0 ? (me[ht] = pt, me[je] = De, ht = je) : (me[ht] = Oe, me[tt] = De, ht = tt);
          else if (je < Tt && u(pt, De) < 0)
            me[ht] = pt, me[je] = De, ht = je;
          else
            return;
        }
      }
      function u(me, De) {
        var qe = me.sortIndex - De.sortIndex;
        return qe !== 0 ? qe : me.id - De.id;
      }
      var c = 1, d = 2, h = 3, f = 4, p = 5;
      function g(me, De) {
      }
      var v = typeof performance == "object" && typeof performance.now == "function";
      if (v) {
        var m = performance;
        e.unstable_now = function() {
          return m.now();
        };
      } else {
        var y = Date, C = y.now();
        e.unstable_now = function() {
          return y.now() - C;
        };
      }
      var S = 1073741823, b = -1, w = 250, x = 5e3, E = 1e4, R = S, _ = [], P = [], D = 1, I = null, A = h, O = !1, L = !1, N = !1, F = typeof setTimeout == "function" ? setTimeout : null, G = typeof clearTimeout == "function" ? clearTimeout : null, M = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function V(me) {
        for (var De = o(P); De !== null; ) {
          if (De.callback === null)
            a(P);
          else if (De.startTime <= me)
            a(P), De.sortIndex = De.expirationTime, i(_, De);
          else
            return;
          De = o(P);
        }
      }
      function z(me) {
        if (N = !1, V(me), !L)
          if (o(_) !== null)
            L = !0, Q(k);
          else {
            var De = o(P);
            De !== null && ye(z, De.startTime - me);
          }
      }
      function k(me, De) {
        L = !1, N && (N = !1, Ge()), O = !0;
        var qe = A;
        try {
          var ht;
          if (!r) return $(me, De);
        } finally {
          I = null, A = qe, O = !1;
        }
      }
      function $(me, De) {
        var qe = De;
        for (V(qe), I = o(_); I !== null && !t && !(I.expirationTime > qe && (!me || we())); ) {
          var ht = I.callback;
          if (typeof ht == "function") {
            I.callback = null, A = I.priorityLevel;
            var Tt = I.expirationTime <= qe, lt = ht(Tt);
            qe = e.unstable_now(), typeof lt == "function" ? I.callback = lt : I === o(_) && a(_), V(qe);
          } else
            a(_);
          I = o(_);
        }
        if (I !== null)
          return !0;
        var tt = o(P);
        return tt !== null && ye(z, tt.startTime - qe), !1;
      }
      function W(me, De) {
        switch (me) {
          case c:
          case d:
          case h:
          case f:
          case p:
            break;
          default:
            me = h;
        }
        var qe = A;
        A = me;
        try {
          return De();
        } finally {
          A = qe;
        }
      }
      function j(me) {
        var De;
        switch (A) {
          case c:
          case d:
          case h:
            De = h;
            break;
          default:
            De = A;
            break;
        }
        var qe = A;
        A = De;
        try {
          return me();
        } finally {
          A = qe;
        }
      }
      function U(me) {
        var De = A;
        return function() {
          var qe = A;
          A = De;
          try {
            return me.apply(this, arguments);
          } finally {
            A = qe;
          }
        };
      }
      function Z(me, De, qe) {
        var ht = e.unstable_now(), Tt;
        if (typeof qe == "object" && qe !== null) {
          var lt = qe.delay;
          typeof lt == "number" && lt > 0 ? Tt = ht + lt : Tt = ht;
        } else
          Tt = ht;
        var tt;
        switch (me) {
          case c:
            tt = b;
            break;
          case d:
            tt = w;
            break;
          case p:
            tt = R;
            break;
          case f:
            tt = E;
            break;
          case h:
          default:
            tt = x;
            break;
        }
        var Oe = Tt + tt, je = {
          id: D++,
          callback: De,
          priorityLevel: me,
          startTime: Tt,
          expirationTime: Oe,
          sortIndex: -1
        };
        return Tt > ht ? (je.sortIndex = Tt, i(P, je), o(_) === null && je === o(P) && (N ? Ge() : N = !0, ye(z, Tt - ht))) : (je.sortIndex = Oe, i(_, je), !L && !O && (L = !0, Q(k))), je;
      }
      function ee() {
      }
      function J() {
        !L && !O && (L = !0, Q(k));
      }
      function X() {
        return o(_);
      }
      function Y(me) {
        me.callback = null;
      }
      function de() {
        return A;
      }
      var K = !1, ie = null, Ce = -1, Te = n, Ie = -1;
      function we() {
        var me = e.unstable_now() - Ie;
        return !(me < Te);
      }
      function Re() {
      }
      function _e(me) {
        if (me < 0 || me > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        me > 0 ? Te = Math.floor(1e3 / me) : Te = n;
      }
      var He = function() {
        if (ie !== null) {
          var me = e.unstable_now();
          Ie = me;
          var De = !0, qe = !0;
          try {
            qe = ie(De, me);
          } finally {
            qe ? Ve() : (K = !1, ie = null);
          }
        } else
          K = !1;
      }, Ve;
      if (typeof M == "function")
        Ve = function() {
          M(He);
        };
      else if (typeof MessageChannel < "u") {
        var $e = new MessageChannel(), Je = $e.port2;
        $e.port1.onmessage = He, Ve = function() {
          Je.postMessage(null);
        };
      } else
        Ve = function() {
          F(He, 0);
        };
      function Q(me) {
        ie = me, K || (K = !0, Ve());
      }
      function ye(me, De) {
        Ce = F(function() {
          me(e.unstable_now());
        }, De);
      }
      function Ge() {
        G(Ce), Ce = -1;
      }
      var Pe = Re, Le = null;
      e.unstable_IdlePriority = p, e.unstable_ImmediatePriority = c, e.unstable_LowPriority = f, e.unstable_NormalPriority = h, e.unstable_Profiling = Le, e.unstable_UserBlockingPriority = d, e.unstable_cancelCallback = Y, e.unstable_continueExecution = J, e.unstable_forceFrameRate = _e, e.unstable_getCurrentPriorityLevel = de, e.unstable_getFirstCallbackNode = X, e.unstable_next = j, e.unstable_pauseExecution = ee, e.unstable_requestPaint = Pe, e.unstable_runWithPriority = W, e.unstable_scheduleCallback = Z, e.unstable_shouldYield = we, e.unstable_wrapCallback = U, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(nb)), nb;
}
process.env.NODE_ENV === "production" ? pR.exports = Due() : pR.exports = Aue();
var ib = pR.exports;
const F0 = Symbol(), Iue = Symbol(), Fue = typeof window > "u" || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent), e3 = Fue ? It : ja, Lue = ib.unstable_runWithPriority ? (e) => {
  try {
    ib.unstable_runWithPriority(ib.unstable_NormalPriority, e);
  } catch (t) {
    if (t.message === "Not implemented.")
      e();
    else
      throw t;
  }
} : (e) => e(), Oue = (e) => ({ value: r, children: n }) => {
  const i = le(r), o = le(0), [a, s] = Ee(null);
  a && (a(r), s(null));
  const l = le();
  if (!l.current) {
    const u = /* @__PURE__ */ new Set(), c = (d, h) => {
      o.current += 1;
      const f = {
        n: o.current
      };
      h != null && h.suspense && (f.n *= -1, f.p = new Promise((p) => {
        s(() => (g) => {
          f.v = g, delete f.p, p(g);
        });
      })), u.forEach((p) => p(f)), d();
    };
    l.current = {
      [F0]: {
        /* "v"alue     */
        v: i,
        /* versio"n"   */
        n: o,
        /* "l"isteners */
        l: u,
        /* "u"pdate    */
        u: c
      }
    };
  }
  return e3(() => {
    i.current = r, o.current += 1, Lue(() => {
      l.current[F0].l.forEach((u) => {
        u({ n: o.current, v: r });
      });
    });
  }, [r]), uH(e, { value: l.current }, n);
}, Nue = (e) => e;
function kue(e) {
  const t = Xl({
    [F0]: {
      /* "v"alue     */
      v: { current: e },
      /* versio"n"   */
      n: { current: -1 },
      /* "l"isteners */
      l: /* @__PURE__ */ new Set(),
      /* "u"pdate    */
      u: (r) => r()
    }
  });
  return t[Iue] = t.Provider, t.Provider = Oue(t.Provider), delete t.Consumer, t;
}
function Vue(e, t) {
  const r = rr(e)[F0];
  if (typeof process == "object" && process.env.NODE_ENV !== "production" && !r)
    throw new Error("useContextSelector requires special context");
  const {
    /* "v"alue     */
    v: { current: n },
    /* versio"n"   */
    n: { current: i },
    /* "l"isteners */
    l: o
  } = r, a = t(n), [s, l] = tq((u, c) => {
    if (!c)
      return [n, a];
    if ("p" in c)
      throw c.p;
    if (c.n === i)
      return Object.is(u[1], a) ? u : [n, a];
    try {
      if ("v" in c) {
        if (Object.is(u[0], c.v))
          return u;
        const d = t(c.v);
        return Object.is(u[1], d) ? u : [c.v, d];
      }
    } catch {
    }
    return [...u];
  }, [n, a]);
  return Object.is(s[1], a) || l(), e3(() => (o.add(l), () => {
    o.delete(l);
  }), [o]), s[1];
}
function Bue(e) {
  return Vue(e, Nue);
}
const Gue = {
  light: {
    "--primary-color": "#49a5aa",
    // Always keep this in hex format
    "--cta-text": "white",
    "--background": "#FEFBF3",
    "--primary-text": "#3c3838",
    "--border": "#e9e0d6",
    "--secondary-text": "#9D9D9D",
    "--foreground": "#f9f4e8",
    "--chart-colors": [
      "rgb(136, 204, 238)",
      "rgb(204, 102, 119)",
      "rgb(221, 204, 119)",
      "rgb(17, 119, 51)",
      "rgb(51, 34, 136)",
      "rgb(170, 68, 153)",
      "rgb(68, 170, 153)",
      "rgb(153, 153, 51)",
      "rgb(136, 34, 85)",
      "rgb(102, 17, 0)",
      "rgb(136, 136, 136)"
    ]
  },
  dark: {
    "--primary-color": "#76ABAE",
    // Always keep this in hex format
    "--cta-text": "#222831",
    "--background": "#222831",
    "--primary-text": "#f7f7f7",
    "--border": "#484848",
    "--secondary-text": "#bfbfbf",
    "--foreground": "#31363F",
    "--chart-colors": [
      "rgb(102, 197, 204)",
      "rgb(246, 207, 113)",
      "rgb(248, 156, 116)",
      "rgb(220, 176, 242)",
      "rgb(135, 197, 95)",
      "rgb(158, 185, 243)",
      "rgb(254, 136, 177)",
      "rgb(201, 219, 116)",
      "rgb(139, 224, 164)",
      "rgb(180, 151, 231)",
      "rgb(179, 179, 179)"
    ]
  }
}, t3 = kue(
  void 0
);
function w3e({
  children: e,
  appTheme: t = Gue
}) {
  const r = (localStorage == null ? void 0 : localStorage.getItem("appThemeMode")) || "light", [n, i] = Ee(r), o = t[n];
  return It(() => {
    Object.entries(o).forEach(([a, s]) => {
      typeof s == "string" && document.documentElement.style.setProperty(`${a}`, s);
    });
  }, [o]), /* @__PURE__ */ ce.jsx(
    t3.Provider,
    {
      value: {
        appThemeMode: n,
        setAppThemeMode: i,
        themeColors: o
      },
      children: /* @__PURE__ */ ce.jsx(
        Vc,
        {
          theme: {
            token: {
              colorPrimary: o["--primary-color"],
              colorBgBase: o["--background"],
              colorText: o["--primary-text"],
              colorTextDescription: o["--secondary-text"],
              colorTextHeading: o["--primary-text"],
              colorTextSecondary: o["--secondary-text"],
              fontFamily: "HousewareFont",
              colorLink: o["--primary-color"],
              colorBorder: o["--border"],
              colorBorderSecondary: o["--border"],
              colorSplit: o["--border"]
            },
            components: {
              Card: {
                colorBgContainer: o["--foreground"],
                colorBorder: o["--border"]
              },
              Input: {
                colorTextPlaceholder: o["--secondary-text"]
              },
              Button: {
                primaryColor: o["--cta-text"],
                primaryShadow: "none",
                defaultHoverColor: o["--cta-text"]
              },
              Layout: {
                bodyBg: o["--background"]
              }
            }
          },
          children: e
        }
      )
    }
  );
}
const Hue = () => {
  const e = Bue(t3);
  if (!e)
    throw new Error("useTheme must be used within a ThemeProvider");
  return e;
}, Cv = () => {
  const { appThemeMode: e, setAppThemeMode: t, themeColors: r } = Hue();
  return {
    currentTheme: e,
    themeColors: r,
    setTheme: t,
    toggleTheme: () => {
      t(e === "light" ? "dark" : "light");
    }
  };
}, r3 = () => {
  const [e, t] = Ee({ x: 0, y: 0 }), r = le(null), { themeColors: n } = Cv(), o = ((a) => {
    const s = parseInt(a.slice(1, 3), 16), l = parseInt(a.slice(3, 5), 16), u = parseInt(a.slice(5, 7), 16);
    return { r: s, g: l, b: u };
  })(n["--primary-color"]);
  return It(() => {
    const a = r.current;
    if (!a) return;
    const s = a.getContext("2d");
    if (!s) return;
    const l = 20, u = 70, c = () => {
      if (!(!a || !s)) {
        a.width = window.innerWidth, a.height = window.innerHeight, s.strokeStyle = `rgba(${o.r}, ${o.g}, ${o.b}, 0.05)`, s.lineWidth = 1;
        for (let f = 0; f <= a.width; f += l)
          s.beginPath(), s.moveTo(f, 0), s.lineTo(f, a.height), s.stroke();
        for (let f = 0; f <= a.height; f += l)
          s.beginPath(), s.moveTo(0, f), s.lineTo(a.width, f), s.stroke();
        for (let f = 0; f <= a.width; f += l)
          for (let p = 0; p <= a.height; p += l) {
            const g = Math.sqrt(
              Math.pow(f - e.x, 2) + Math.pow(p - e.y, 2)
            );
            if (g <= u) {
              const v = Math.cos(
                g / u * (Math.PI / 2)
              );
              s.strokeStyle = `rgba(${o.r}, ${o.g}, ${o.b}, ${v * 0.5})`, f % l === 0 && (s.beginPath(), s.moveTo(f, Math.max(0, p - l)), s.lineTo(f, Math.min(a.height, p + l)), s.stroke()), p % l === 0 && (s.beginPath(), s.moveTo(Math.max(0, f - l), p), s.lineTo(Math.min(a.width, f + l), p), s.stroke());
            }
          }
      }
    }, d = (f) => {
      t({ x: f.clientX, y: f.clientY });
    }, h = () => {
      c();
    };
    return window.addEventListener("mousemove", d), window.addEventListener("resize", h), c(), () => {
      window.removeEventListener("mousemove", d), window.removeEventListener("resize", h);
    };
  }, [e, o]), /* @__PURE__ */ ce.jsx("div", { style: { position: "absolute", top: 0, left: 0 }, children: /* @__PURE__ */ ce.jsx("canvas", { ref: r, className: "absolute inset-0" }) });
}, b3e = ({
  suggestions: e,
  handleSendMessage: t,
  heading: r,
  subHeading: n
}) => {
  const [i, o] = Ee(""), { themeColors: a } = Cv(), s = le(null);
  return /* @__PURE__ */ ce.jsxs(
    fr,
    {
      justify: "space-evenly",
      align: "center",
      vertical: !0,
      style: { height: "90vh" },
      children: [
        /* @__PURE__ */ ce.jsx(r3, {}),
        /* @__PURE__ */ ce.jsxs(
          fr,
          {
            vertical: !0,
            align: "center",
            gap: 12,
            style: {
              zIndex: 1
            },
            children: [
              /* @__PURE__ */ ce.jsx(
                Ur.Title,
                {
                  level: 2,
                  style: {
                    width: "30vw",
                    textAlign: "center",
                    fontFamily: "Sedan"
                  },
                  children: r
                }
              ),
              /* @__PURE__ */ ce.jsx(
                Ur.Text,
                {
                  style: {
                    width: "40vw",
                    textAlign: "center"
                  },
                  children: n
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ ce.jsxs(
          Lo,
          {
            style: {
              position: "relative",
              maxWidth: "40vw"
            },
            children: [
              /* @__PURE__ */ ce.jsx(
                DP,
                {
                  style: {
                    position: "absolute",
                    top: "-0.7rem",
                    left: 0,
                    right: 0,
                    marginLeft: "auto",
                    marginRight: "auto",
                    width: "max-content",
                    borderColor: a["--primary-color"],
                    backgroundColor: a["--background"],
                    color: a["--primary-color"]
                  },
                  children: "Suggestions"
                }
              ),
              /* @__PURE__ */ ce.jsxs(fr, { vertical: !0, align: "center", gap: 18, children: [
                /* @__PURE__ */ ce.jsx(
                  Ur.Text,
                  {
                    style: {
                      marginTop: 0
                    },
                    type: "secondary",
                    children: "Get started with an example below"
                  }
                ),
                /* @__PURE__ */ ce.jsx(
                  fr,
                  {
                    gap: 12,
                    style: {
                      width: "100%"
                    },
                    children: e.map((l) => /* @__PURE__ */ ce.jsx(
                      Lo,
                      {
                        style: {
                          width: `calc(100% / ${e.length})`,
                          overflow: "hidden",
                          cursor: "pointer"
                        },
                        onClick: () => {
                          var u;
                          o(l.content), (u = s == null ? void 0 : s.current) == null || u.focus();
                        },
                        rootClassName: "hoverable-card",
                        styles: {
                          body: {
                            padding: 12
                          }
                        },
                        children: /* @__PURE__ */ ce.jsxs(
                          Ur.Text,
                          {
                            rootClassName: "three-line-ellipsis",
                            style: {
                              textAlign: "center"
                            },
                            children: [
                              " ",
                              l.title
                            ]
                          }
                        )
                      },
                      l.title
                    ))
                  }
                )
              ] })
            ]
          }
        ),
        /* @__PURE__ */ ce.jsx(
          J8,
          {
            inputRef: s,
            userQuery: i,
            setUserQuery: o,
            handleSendMessage: () => {
              t(i), o("");
            }
          }
        )
      ]
    }
  );
}, zue = ({
  inputRef: e,
  placeholder: t = "Keywords related to your products separated by commas...",
  userQuery: r,
  setUserQuery: n,
  handleSendMessage: i,
  isFollowupDisabled: o = !1
}) => {
  const a = r.trim().length === 0 || o;
  return /* @__PURE__ */ ce.jsx(
    fr,
    {
      vertical: !0,
      style: {
        width: "40vw"
      },
      children: /* @__PURE__ */ ce.jsx(
        Lo,
        {
          size: "small",
          bordered: !0,
          style: {
            width: "100%"
          },
          styles: {
            body: {
              padding: 16
            }
          },
          children: /* @__PURE__ */ ce.jsx(fr, { justify: "space-between", gap: 12, children: /* @__PURE__ */ ce.jsxs(fr, { vertical: !0, style: { width: "100%" }, gap: 24, children: [
            /* @__PURE__ */ ce.jsxs(
              fr,
              {
                vertical: !0,
                gap: 4,
                style: {
                  width: "100%"
                },
                children: [
                  /* @__PURE__ */ ce.jsx(
                    Ur.Text,
                    {
                      type: "secondary",
                      style: {
                        fontSize: "0.8rem"
                      },
                      children: "I want to run my campaign for"
                    }
                  ),
                  /* @__PURE__ */ ce.jsx(
                    Jh,
                    {
                      style: { width: "100%" },
                      ref: e,
                      onChange: (s) => n(s.target.value),
                      value: r,
                      size: "large",
                      variant: "outlined",
                      placeholder: t
                    }
                  )
                ]
              }
            ),
            /* @__PURE__ */ ce.jsxs(fr, { align: "center", justify: "space-between", children: [
              /* @__PURE__ */ ce.jsxs(fr, { gap: 4, align: "center", children: [
                /* @__PURE__ */ ce.jsx(
                  Ur.Text,
                  {
                    type: "secondary",
                    style: {
                      fontSize: "0.8rem"
                    },
                    children: "Targetting users in"
                  }
                ),
                /* @__PURE__ */ ce.jsx(
                  Qn,
                  {
                    type: "text",
                    style: {
                      fontSize: "0.8rem"
                    },
                    size: "small",
                    icon: /* @__PURE__ */ ce.jsx(mH, {}),
                    children: "India"
                  }
                ),
                /* @__PURE__ */ ce.jsx(
                  Ur.Text,
                  {
                    type: "secondary",
                    style: {
                      fontSize: "0.8rem"
                    },
                    children: "speaking"
                  }
                ),
                /* @__PURE__ */ ce.jsx(
                  Qn,
                  {
                    type: "text",
                    style: {
                      fontSize: "0.8rem"
                    },
                    size: "small",
                    icon: /* @__PURE__ */ ce.jsx(CH, {}),
                    children: "English"
                  }
                )
              ] }),
              /* @__PURE__ */ ce.jsx(
                Qn,
                {
                  disabled: a,
                  size: "middle",
                  type: "primary",
                  onClick: i,
                  icon: /* @__PURE__ */ ce.jsx(VT, { weight: "bold" }),
                  children: "Search"
                }
              )
            ] })
          ] }) })
        }
      )
    }
  );
}, x3e = ({
  handleSendMessage: e,
  heading: t,
  subHeading: r
}) => {
  const [n, i] = Ee(""), o = le(null);
  return /* @__PURE__ */ ce.jsxs(
    fr,
    {
      justify: "space-evenly",
      align: "center",
      vertical: !0,
      style: { height: "100vh" },
      children: [
        /* @__PURE__ */ ce.jsx(r3, {}),
        /* @__PURE__ */ ce.jsxs(
          fr,
          {
            vertical: !0,
            align: "center",
            gap: 12,
            style: {
              zIndex: 1
            },
            children: [
              /* @__PURE__ */ ce.jsx(
                Ur.Title,
                {
                  level: 2,
                  style: {
                    width: "30vw",
                    textAlign: "center",
                    fontFamily: "Sedan"
                  },
                  children: t
                }
              ),
              /* @__PURE__ */ ce.jsx(
                Ur.Text,
                {
                  style: {
                    width: "40vw",
                    textAlign: "center"
                  },
                  children: r
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ ce.jsx(
          zue,
          {
            inputRef: o,
            userQuery: n,
            setUserQuery: i,
            handleSendMessage: () => {
              e(n), i("");
            }
          }
        )
      ]
    }
  );
};
function $ue() {
  return /* @__PURE__ */ ce.jsxs(fr, { style: { width: "90%" }, align: "flex-start", gap: 8, children: [
    /* @__PURE__ */ ce.jsx(
      yv,
      {
        className: "ai-icon-rotate",
        src: "/ai-icon.svg",
        height: 40,
        width: 40,
        style: {
          height: "2rem",
          width: "2rem"
        }
      }
    ),
    /* @__PURE__ */ ce.jsx(eu, { active: !0 })
  ] });
}
function Wue(e, t) {
  const r = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (r.padRight ? " " : "") + "," + (r.padLeft === !1 ? "" : " ")
  ).trim();
}
const jue = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Uue = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Kue = {};
function PF(e, t) {
  return (Kue.jsx ? Uue : jue).test(e);
}
const Yue = /[ \t\n\f\r]/g;
function que(e) {
  return typeof e == "object" ? e.type === "text" ? MF(e.value) : !1 : MF(e);
}
function MF(e) {
  return e.replace(Yue, "") === "";
}
class Sv {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, r, n) {
    this.property = t, this.normal = r, n && (this.space = n);
  }
}
Sv.prototype.property = {};
Sv.prototype.normal = {};
Sv.prototype.space = null;
function n3(e, t) {
  const r = {}, n = {};
  let i = -1;
  for (; ++i < e.length; )
    Object.assign(r, e[i].property), Object.assign(n, e[i].normal);
  return new Sv(r, n, t);
}
function gR(e) {
  return e.toLowerCase();
}
class Bo {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, r) {
    this.property = t, this.attribute = r;
  }
}
Bo.prototype.space = null;
Bo.prototype.boolean = !1;
Bo.prototype.booleanish = !1;
Bo.prototype.overloadedBoolean = !1;
Bo.prototype.number = !1;
Bo.prototype.commaSeparated = !1;
Bo.prototype.spaceSeparated = !1;
Bo.prototype.commaOrSpaceSeparated = !1;
Bo.prototype.mustUseProperty = !1;
Bo.prototype.defined = !1;
let Zue = 0;
const Nt = zc(), pn = zc(), i3 = zc(), Ne = zc(), Lr = zc(), ch = zc(), Ui = zc();
function zc() {
  return 2 ** ++Zue;
}
const vR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: Nt,
  booleanish: pn,
  commaOrSpaceSeparated: Ui,
  commaSeparated: ch,
  number: Ne,
  overloadedBoolean: i3,
  spaceSeparated: Lr
}, Symbol.toStringTag, { value: "Module" })), ob = Object.keys(vR);
class IP extends Bo {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, r, n, i) {
    let o = -1;
    if (super(t, r), DF(this, "space", i), typeof n == "number")
      for (; ++o < ob.length; ) {
        const a = ob[o];
        DF(this, ob[o], (n & vR[a]) === vR[a]);
      }
  }
}
IP.prototype.defined = !0;
function DF(e, t, r) {
  r && (e[t] = r);
}
const Xue = {}.hasOwnProperty;
function ef(e) {
  const t = {}, r = {};
  let n;
  for (n in e.properties)
    if (Xue.call(e.properties, n)) {
      const i = e.properties[n], o = new IP(
        n,
        e.transform(e.attributes || {}, n),
        i,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(n) && (o.mustUseProperty = !0), t[n] = o, r[gR(n)] = n, r[gR(o.attribute)] = n;
    }
  return new Sv(t, r, e.space);
}
const o3 = ef({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), a3 = ef({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function s3(e, t) {
  return t in e ? e[t] : t;
}
function l3(e, t) {
  return s3(e, t.toLowerCase());
}
const u3 = ef({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: l3,
  properties: { xmlns: null, xmlnsXLink: null }
}), c3 = ef({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: pn,
    ariaAutoComplete: null,
    ariaBusy: pn,
    ariaChecked: pn,
    ariaColCount: Ne,
    ariaColIndex: Ne,
    ariaColSpan: Ne,
    ariaControls: Lr,
    ariaCurrent: null,
    ariaDescribedBy: Lr,
    ariaDetails: null,
    ariaDisabled: pn,
    ariaDropEffect: Lr,
    ariaErrorMessage: null,
    ariaExpanded: pn,
    ariaFlowTo: Lr,
    ariaGrabbed: pn,
    ariaHasPopup: null,
    ariaHidden: pn,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: Lr,
    ariaLevel: Ne,
    ariaLive: null,
    ariaModal: pn,
    ariaMultiLine: pn,
    ariaMultiSelectable: pn,
    ariaOrientation: null,
    ariaOwns: Lr,
    ariaPlaceholder: null,
    ariaPosInSet: Ne,
    ariaPressed: pn,
    ariaReadOnly: pn,
    ariaRelevant: null,
    ariaRequired: pn,
    ariaRoleDescription: Lr,
    ariaRowCount: Ne,
    ariaRowIndex: Ne,
    ariaRowSpan: Ne,
    ariaSelected: pn,
    ariaSetSize: Ne,
    ariaSort: null,
    ariaValueMax: Ne,
    ariaValueMin: Ne,
    ariaValueNow: Ne,
    ariaValueText: null,
    role: null
  }
}), Que = ef({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: l3,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: ch,
    acceptCharset: Lr,
    accessKey: Lr,
    action: null,
    allow: null,
    allowFullScreen: Nt,
    allowPaymentRequest: Nt,
    allowUserMedia: Nt,
    alt: null,
    as: null,
    async: Nt,
    autoCapitalize: null,
    autoComplete: Lr,
    autoFocus: Nt,
    autoPlay: Nt,
    blocking: Lr,
    capture: null,
    charSet: null,
    checked: Nt,
    cite: null,
    className: Lr,
    cols: Ne,
    colSpan: null,
    content: null,
    contentEditable: pn,
    controls: Nt,
    controlsList: Lr,
    coords: Ne | ch,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: Nt,
    defer: Nt,
    dir: null,
    dirName: null,
    disabled: Nt,
    download: i3,
    draggable: pn,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: Nt,
    formTarget: null,
    headers: Lr,
    height: Ne,
    hidden: Nt,
    high: Ne,
    href: null,
    hrefLang: null,
    htmlFor: Lr,
    httpEquiv: Lr,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: Nt,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: Nt,
    itemId: null,
    itemProp: Lr,
    itemRef: Lr,
    itemScope: Nt,
    itemType: Lr,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: Nt,
    low: Ne,
    manifest: null,
    max: null,
    maxLength: Ne,
    media: null,
    method: null,
    min: null,
    minLength: Ne,
    multiple: Nt,
    muted: Nt,
    name: null,
    nonce: null,
    noModule: Nt,
    noValidate: Nt,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: Nt,
    optimum: Ne,
    pattern: null,
    ping: Lr,
    placeholder: null,
    playsInline: Nt,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: Nt,
    referrerPolicy: null,
    rel: Lr,
    required: Nt,
    reversed: Nt,
    rows: Ne,
    rowSpan: Ne,
    sandbox: Lr,
    scope: null,
    scoped: Nt,
    seamless: Nt,
    selected: Nt,
    shadowRootClonable: Nt,
    shadowRootDelegatesFocus: Nt,
    shadowRootMode: null,
    shape: null,
    size: Ne,
    sizes: null,
    slot: null,
    span: Ne,
    spellCheck: pn,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: Ne,
    step: null,
    style: null,
    tabIndex: Ne,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: Nt,
    useMap: null,
    value: pn,
    width: Ne,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: Lr,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: Ne,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: Ne,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: Nt,
    // Lists. Use CSS to reduce space between items instead
    declare: Nt,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: Ne,
    // `<img>` and `<object>`
    leftMargin: Ne,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: Ne,
    // `<body>`
    marginWidth: Ne,
    // `<body>`
    noResize: Nt,
    // `<frame>`
    noHref: Nt,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: Nt,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: Nt,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: Ne,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: pn,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: Ne,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: Ne,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: Nt,
    disableRemotePlayback: Nt,
    prefix: null,
    property: null,
    results: Ne,
    security: null,
    unselectable: null
  }
}), Jue = ef({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: s3,
  properties: {
    about: Ui,
    accentHeight: Ne,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: Ne,
    amplitude: Ne,
    arabicForm: null,
    ascent: Ne,
    attributeName: null,
    attributeType: null,
    azimuth: Ne,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: Ne,
    by: null,
    calcMode: null,
    capHeight: Ne,
    className: Lr,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: Ne,
    diffuseConstant: Ne,
    direction: null,
    display: null,
    dur: null,
    divisor: Ne,
    dominantBaseline: null,
    download: Nt,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: Ne,
    enableBackground: null,
    end: null,
    event: null,
    exponent: Ne,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: Ne,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: ch,
    g2: ch,
    glyphName: ch,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: Ne,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: Ne,
    horizOriginX: Ne,
    horizOriginY: Ne,
    id: null,
    ideographic: Ne,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: Ne,
    k: Ne,
    k1: Ne,
    k2: Ne,
    k3: Ne,
    k4: Ne,
    kernelMatrix: Ui,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: Ne,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: Ne,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: Ne,
    overlineThickness: Ne,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: Ne,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: Lr,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: Ne,
    pointsAtY: Ne,
    pointsAtZ: Ne,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ui,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ui,
    rev: Ui,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ui,
    requiredFeatures: Ui,
    requiredFonts: Ui,
    requiredFormats: Ui,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: Ne,
    specularExponent: Ne,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: Ne,
    strikethroughThickness: Ne,
    string: null,
    stroke: null,
    strokeDashArray: Ui,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: Ne,
    strokeOpacity: Ne,
    strokeWidth: null,
    style: null,
    surfaceScale: Ne,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ui,
    tabIndex: Ne,
    tableValues: null,
    target: null,
    targetX: Ne,
    targetY: Ne,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ui,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: Ne,
    underlineThickness: Ne,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: Ne,
    values: null,
    vAlphabetic: Ne,
    vMathematical: Ne,
    vectorEffect: null,
    vHanging: Ne,
    vIdeographic: Ne,
    version: null,
    vertAdvY: Ne,
    vertOriginX: Ne,
    vertOriginY: Ne,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: Ne,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), ece = /^data[-\w.:]+$/i, AF = /-[a-z]/g, tce = /[A-Z]/g;
function rce(e, t) {
  const r = gR(t);
  let n = t, i = Bo;
  if (r in e.normal)
    return e.property[e.normal[r]];
  if (r.length > 4 && r.slice(0, 4) === "data" && ece.test(t)) {
    if (t.charAt(4) === "-") {
      const o = t.slice(5).replace(AF, ice);
      n = "data" + o.charAt(0).toUpperCase() + o.slice(1);
    } else {
      const o = t.slice(4);
      if (!AF.test(o)) {
        let a = o.replace(tce, nce);
        a.charAt(0) !== "-" && (a = "-" + a), t = "data" + a;
      }
    }
    i = IP;
  }
  return new i(n, t);
}
function nce(e) {
  return "-" + e.toLowerCase();
}
function ice(e) {
  return e.charAt(1).toUpperCase();
}
const oce = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, ace = n3([a3, o3, u3, c3, Que], "html"), FP = n3([a3, o3, u3, c3, Jue], "svg");
function sce(e) {
  return e.join(" ").trim();
}
var d3 = {}, IF = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, lce = /\n/g, uce = /^\s*/, cce = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, dce = /^:\s*/, hce = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, fce = /^[;\s]*/, pce = /^\s+|\s+$/g, gce = `
`, FF = "/", LF = "*", ju = "", vce = "comment", mce = "declaration", yce = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var r = 1, n = 1;
  function i(p) {
    var g = p.match(lce);
    g && (r += g.length);
    var v = p.lastIndexOf(gce);
    n = ~v ? p.length - v : n + p.length;
  }
  function o() {
    var p = { line: r, column: n };
    return function(g) {
      return g.position = new a(p), u(), g;
    };
  }
  function a(p) {
    this.start = p, this.end = { line: r, column: n }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(p) {
    var g = new Error(
      t.source + ":" + r + ":" + n + ": " + p
    );
    if (g.reason = p, g.filename = t.source, g.line = r, g.column = n, g.source = e, !t.silent) throw g;
  }
  function l(p) {
    var g = p.exec(e);
    if (g) {
      var v = g[0];
      return i(v), e = e.slice(v.length), g;
    }
  }
  function u() {
    l(uce);
  }
  function c(p) {
    var g;
    for (p = p || []; g = d(); )
      g !== !1 && p.push(g);
    return p;
  }
  function d() {
    var p = o();
    if (!(FF != e.charAt(0) || LF != e.charAt(1))) {
      for (var g = 2; ju != e.charAt(g) && (LF != e.charAt(g) || FF != e.charAt(g + 1)); )
        ++g;
      if (g += 2, ju === e.charAt(g - 1))
        return s("End of comment missing");
      var v = e.slice(2, g - 2);
      return n += 2, i(v), e = e.slice(g), n += 2, p({
        type: vce,
        comment: v
      });
    }
  }
  function h() {
    var p = o(), g = l(cce);
    if (g) {
      if (d(), !l(dce)) return s("property missing ':'");
      var v = l(hce), m = p({
        type: mce,
        property: OF(g[0].replace(IF, ju)),
        value: v ? OF(v[0].replace(IF, ju)) : ju
      });
      return l(fce), m;
    }
  }
  function f() {
    var p = [];
    c(p);
    for (var g; g = h(); )
      g !== !1 && (p.push(g), c(p));
    return p;
  }
  return u(), f();
};
function OF(e) {
  return e ? e.replace(pce, ju) : ju;
}
var Cce = S0 && S0.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(d3, "__esModule", { value: !0 });
var Sce = Cce(yce);
function wce(e, t) {
  var r = null;
  if (!e || typeof e != "string")
    return r;
  var n = (0, Sce.default)(e), i = typeof t == "function";
  return n.forEach(function(o) {
    if (o.type === "declaration") {
      var a = o.property, s = o.value;
      i ? t(a, s, o) : s && (r = r || {}, r[a] = s);
    }
  }), r;
}
var NF = d3.default = wce;
const bce = NF.default || NF, h3 = f3("end"), LP = f3("start");
function f3(e) {
  return t;
  function t(r) {
    const n = r && r.position && r.position[e] || {};
    if (typeof n.line == "number" && n.line > 0 && typeof n.column == "number" && n.column > 0)
      return {
        line: n.line,
        column: n.column,
        offset: typeof n.offset == "number" && n.offset > -1 ? n.offset : void 0
      };
  }
}
function xce(e) {
  const t = LP(e), r = h3(e);
  if (t && r)
    return { start: t, end: r };
}
function Wp(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? kF(e.position) : "start" in e || "end" in e ? kF(e) : "line" in e || "column" in e ? mR(e) : "";
}
function mR(e) {
  return VF(e && e.line) + ":" + VF(e && e.column);
}
function kF(e) {
  return mR(e && e.start) + "-" + mR(e && e.end);
}
function VF(e) {
  return e && typeof e == "number" ? e : 1;
}
class ri extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, r, n) {
    super(), typeof r == "string" && (n = r, r = void 0);
    let i = "", o = {}, a = !1;
    if (r && ("line" in r && "column" in r ? o = { place: r } : "start" in r && "end" in r ? o = { place: r } : "type" in r ? o = {
      ancestors: [r],
      place: r.position
    } : o = { ...r }), typeof t == "string" ? i = t : !o.cause && t && (a = !0, i = t.message, o.cause = t), !o.ruleId && !o.source && typeof n == "string") {
      const l = n.indexOf(":");
      l === -1 ? o.ruleId = n : (o.source = n.slice(0, l), o.ruleId = n.slice(l + 1));
    }
    if (!o.place && o.ancestors && o.ancestors) {
      const l = o.ancestors[o.ancestors.length - 1];
      l && (o.place = l.position);
    }
    const s = o.place && "start" in o.place ? o.place.start : o.place;
    this.ancestors = o.ancestors || void 0, this.cause = o.cause || void 0, this.column = s ? s.column : void 0, this.fatal = void 0, this.file, this.message = i, this.line = s ? s.line : void 0, this.name = Wp(o.place) || "1:1", this.place = o.place || void 0, this.reason = this.message, this.ruleId = o.ruleId || void 0, this.source = o.source || void 0, this.stack = a && o.cause && typeof o.cause.stack == "string" ? o.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
ri.prototype.file = "";
ri.prototype.name = "";
ri.prototype.reason = "";
ri.prototype.message = "";
ri.prototype.stack = "";
ri.prototype.column = void 0;
ri.prototype.line = void 0;
ri.prototype.ancestors = void 0;
ri.prototype.cause = void 0;
ri.prototype.fatal = void 0;
ri.prototype.place = void 0;
ri.prototype.ruleId = void 0;
ri.prototype.source = void 0;
const OP = {}.hasOwnProperty, Ece = /* @__PURE__ */ new Map(), Rce = /[A-Z]/g, _ce = /-([a-z])/g, Tce = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), Pce = /* @__PURE__ */ new Set(["td", "th"]), p3 = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function Mce(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const r = t.filePath || void 0;
  let n;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    n = kce(r, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    n = Nce(r, t.jsx, t.jsxs);
  }
  const i = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: n,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: r,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? FP : ace,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, o = g3(i, e, void 0);
  return o && typeof o != "string" ? o : i.create(
    e,
    i.Fragment,
    { children: o || void 0 },
    void 0
  );
}
function g3(e, t, r) {
  if (t.type === "element")
    return Dce(e, t, r);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return Ace(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return Fce(e, t, r);
  if (t.type === "mdxjsEsm")
    return Ice(e, t);
  if (t.type === "root")
    return Lce(e, t, r);
  if (t.type === "text")
    return Oce(e, t);
}
function Dce(e, t, r) {
  const n = e.schema;
  let i = n;
  t.tagName.toLowerCase() === "svg" && n.space === "html" && (i = FP, e.schema = i), e.ancestors.push(t);
  const o = m3(e, t.tagName, !1), a = Vce(e, t);
  let s = kP(e, t);
  return Tce.has(t.tagName) && (s = s.filter(function(l) {
    return typeof l == "string" ? !que(l) : !0;
  })), v3(e, a, o, t), NP(a, s), e.ancestors.pop(), e.schema = n, e.create(t, o, a, r);
}
function Ace(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const n = t.data.estree.body[0];
    return n.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(n.expression);
  }
  Tg(e, t.position);
}
function Ice(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Tg(e, t.position);
}
function Fce(e, t, r) {
  const n = e.schema;
  let i = n;
  t.name === "svg" && n.space === "html" && (i = FP, e.schema = i), e.ancestors.push(t);
  const o = t.name === null ? e.Fragment : m3(e, t.name, !0), a = Bce(e, t), s = kP(e, t);
  return v3(e, a, o, t), NP(a, s), e.ancestors.pop(), e.schema = n, e.create(t, o, a, r);
}
function Lce(e, t, r) {
  const n = {};
  return NP(n, kP(e, t)), e.create(t, e.Fragment, n, r);
}
function Oce(e, t) {
  return t.value;
}
function v3(e, t, r, n) {
  typeof r != "string" && r !== e.Fragment && e.passNode && (t.node = n);
}
function NP(e, t) {
  if (t.length > 0) {
    const r = t.length > 1 ? t : t[0];
    r && (e.children = r);
  }
}
function Nce(e, t, r) {
  return n;
  function n(i, o, a, s) {
    const u = Array.isArray(a.children) ? r : t;
    return s ? u(o, a, s) : u(o, a);
  }
}
function kce(e, t) {
  return r;
  function r(n, i, o, a) {
    const s = Array.isArray(o.children), l = LP(n);
    return t(
      i,
      o,
      a,
      s,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function Vce(e, t) {
  const r = {};
  let n, i;
  for (i in t.properties)
    if (i !== "children" && OP.call(t.properties, i)) {
      const o = Gce(e, i, t.properties[i]);
      if (o) {
        const [a, s] = o;
        e.tableCellAlignToStyle && a === "align" && typeof s == "string" && Pce.has(t.tagName) ? n = s : r[a] = s;
      }
    }
  if (n) {
    const o = (
      /** @type {Style} */
      r.style || (r.style = {})
    );
    o[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = n;
  }
  return r;
}
function Bce(e, t) {
  const r = {};
  for (const n of t.attributes)
    if (n.type === "mdxJsxExpressionAttribute")
      if (n.data && n.data.estree && e.evaluater) {
        const o = n.data.estree.body[0];
        o.type;
        const a = o.expression;
        a.type;
        const s = a.properties[0];
        s.type, Object.assign(
          r,
          e.evaluater.evaluateExpression(s.argument)
        );
      } else
        Tg(e, t.position);
    else {
      const i = n.name;
      let o;
      if (n.value && typeof n.value == "object")
        if (n.value.data && n.value.data.estree && e.evaluater) {
          const s = n.value.data.estree.body[0];
          s.type, o = e.evaluater.evaluateExpression(s.expression);
        } else
          Tg(e, t.position);
      else
        o = n.value === null ? !0 : n.value;
      r[i] = /** @type {Props[keyof Props]} */
      o;
    }
  return r;
}
function kP(e, t) {
  const r = [];
  let n = -1;
  const i = e.passKeys ? /* @__PURE__ */ new Map() : Ece;
  for (; ++n < t.children.length; ) {
    const o = t.children[n];
    let a;
    if (e.passKeys) {
      const l = o.type === "element" ? o.tagName : o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement" ? o.name : void 0;
      if (l) {
        const u = i.get(l) || 0;
        a = l + "-" + u, i.set(l, u + 1);
      }
    }
    const s = g3(e, o, a);
    s !== void 0 && r.push(s);
  }
  return r;
}
function Gce(e, t, r) {
  const n = rce(e.schema, t);
  if (!(r == null || typeof r == "number" && Number.isNaN(r))) {
    if (Array.isArray(r) && (r = n.commaSeparated ? Wue(r) : sce(r)), n.property === "style") {
      let i = typeof r == "object" ? r : Hce(e, String(r));
      return e.stylePropertyNameCase === "css" && (i = zce(i)), ["style", i];
    }
    return [
      e.elementAttributeNameCase === "react" && n.space ? oce[n.property] || n.property : n.attribute,
      r
    ];
  }
}
function Hce(e, t) {
  const r = {};
  try {
    bce(t, n);
  } catch (i) {
    if (!e.ignoreInvalidStyle) {
      const o = (
        /** @type {Error} */
        i
      ), a = new ri("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: o,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw a.file = e.filePath || void 0, a.url = p3 + "#cannot-parse-style-attribute", a;
    }
  }
  return r;
  function n(i, o) {
    let a = i;
    a.slice(0, 2) !== "--" && (a.slice(0, 4) === "-ms-" && (a = "ms-" + a.slice(4)), a = a.replace(_ce, Wce)), r[a] = o;
  }
}
function m3(e, t, r) {
  let n;
  if (!r)
    n = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const i = t.split(".");
    let o = -1, a;
    for (; ++o < i.length; ) {
      const s = PF(i[o]) ? { type: "Identifier", name: i[o] } : { type: "Literal", value: i[o] };
      a = a ? {
        type: "MemberExpression",
        object: a,
        property: s,
        computed: !!(o && s.type === "Literal"),
        optional: !1
      } : s;
    }
    n = a;
  } else
    n = PF(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (n.type === "Literal") {
    const i = (
      /** @type {keyof JSX.IntrinsicElements} */
      n.value
    );
    return OP.call(e.components, i) ? e.components[i] : i;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(n);
  Tg(e);
}
function Tg(e, t) {
  const r = new ri(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw r.file = e.filePath || void 0, r.url = p3 + "#cannot-handle-mdx-estrees-without-createevaluater", r;
}
function zce(e) {
  const t = {};
  let r;
  for (r in e)
    OP.call(e, r) && (t[$ce(r)] = e[r]);
  return t;
}
function $ce(e) {
  let t = e.replace(Rce, jce);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function Wce(e, t) {
  return t.toUpperCase();
}
function jce(e) {
  return "-" + e.toLowerCase();
}
const ab = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, Uce = {};
function Kce(e, t) {
  const r = Uce, n = typeof r.includeImageAlt == "boolean" ? r.includeImageAlt : !0, i = typeof r.includeHtml == "boolean" ? r.includeHtml : !0;
  return y3(e, n, i);
}
function y3(e, t, r) {
  if (Yce(e)) {
    if ("value" in e)
      return e.type === "html" && !r ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return BF(e.children, t, r);
  }
  return Array.isArray(e) ? BF(e, t, r) : "";
}
function BF(e, t, r) {
  const n = [];
  let i = -1;
  for (; ++i < e.length; )
    n[i] = y3(e[i], t, r);
  return n.join("");
}
function Yce(e) {
  return !!(e && typeof e == "object");
}
const GF = document.createElement("i");
function VP(e) {
  const t = "&" + e + ";";
  GF.innerHTML = t;
  const r = GF.textContent;
  return r.charCodeAt(r.length - 1) === 59 && e !== "semi" || r === t ? !1 : r;
}
function Gs(e, t, r, n) {
  const i = e.length;
  let o = 0, a;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, r = r > 0 ? r : 0, n.length < 1e4)
    a = Array.from(n), a.unshift(t, r), e.splice(...a);
  else
    for (r && e.splice(t, r); o < n.length; )
      a = n.slice(o, o + 1e4), a.unshift(t, 0), e.splice(...a), o += 1e4, t += 1e4;
}
function bo(e, t) {
  return e.length > 0 ? (Gs(e, e.length, 0, t), e) : t;
}
const HF = {}.hasOwnProperty;
function qce(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    Zce(t, e[r]);
  return t;
}
function Zce(e, t) {
  let r;
  for (r in t) {
    const i = (HF.call(e, r) ? e[r] : void 0) || (e[r] = {}), o = t[r];
    let a;
    if (o)
      for (a in o) {
        HF.call(i, a) || (i[a] = []);
        const s = o[a];
        Xce(
          // @ts-expect-error Looks like a list.
          i[a],
          Array.isArray(s) ? s : s ? [s] : []
        );
      }
  }
}
function Xce(e, t) {
  let r = -1;
  const n = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : n).push(t[r]);
  Gs(e, 0, 0, n);
}
function C3(e, t) {
  const r = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    r < 9 || r === 11 || r > 13 && r < 32 || // Control character (DEL) of C0, and C1 controls.
    r > 126 && r < 160 || // Lone high surrogates and low surrogates.
    r > 55295 && r < 57344 || // Noncharacters.
    r > 64975 && r < 65008 || /* eslint-disable no-bitwise */
    (r & 65535) === 65535 || (r & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    r > 1114111 ? "�" : String.fromCodePoint(r)
  );
}
function dh(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const Va = tu(/[A-Za-z]/), Qi = tu(/[\dA-Za-z]/), Qce = tu(/[#-'*+\--9=?A-Z^-~]/);
function yR(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const CR = tu(/\d/), Jce = tu(/[\dA-Fa-f]/), ede = tu(/[!-/:-@[-`{-~]/);
function Dt(e) {
  return e !== null && e < -2;
}
function Ni(e) {
  return e !== null && (e < 0 || e === 32);
}
function pr(e) {
  return e === -2 || e === -1 || e === 32;
}
const tde = tu(new RegExp("\\p{P}|\\p{S}", "u")), rde = tu(/\s/);
function tu(e) {
  return t;
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r));
  }
}
function tf(e) {
  const t = [];
  let r = -1, n = 0, i = 0;
  for (; ++r < e.length; ) {
    const o = e.charCodeAt(r);
    let a = "";
    if (o === 37 && Qi(e.charCodeAt(r + 1)) && Qi(e.charCodeAt(r + 2)))
      i = 2;
    else if (o < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(o)) || (a = String.fromCharCode(o));
    else if (o > 55295 && o < 57344) {
      const s = e.charCodeAt(r + 1);
      o < 56320 && s > 56319 && s < 57344 ? (a = String.fromCharCode(o, s), i = 1) : a = "�";
    } else
      a = String.fromCharCode(o);
    a && (t.push(e.slice(n, r), encodeURIComponent(a)), n = r + i + 1, a = ""), i && (r += i, i = 0);
  }
  return t.join("") + e.slice(n);
}
function Or(e, t, r, n) {
  const i = n ? n - 1 : Number.POSITIVE_INFINITY;
  let o = 0;
  return a;
  function a(l) {
    return pr(l) ? (e.enter(r), s(l)) : t(l);
  }
  function s(l) {
    return pr(l) && o++ < i ? (e.consume(l), s) : (e.exit(r), t(l));
  }
}
const nde = {
  tokenize: ide
};
function ide(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    n,
    i
  );
  let r;
  return t;
  function n(s) {
    if (s === null) {
      e.consume(s);
      return;
    }
    return e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), Or(e, t, "linePrefix");
  }
  function i(s) {
    return e.enter("paragraph"), o(s);
  }
  function o(s) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: r
    });
    return r && (r.next = l), r = l, a(s);
  }
  function a(s) {
    if (s === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(s);
      return;
    }
    return Dt(s) ? (e.consume(s), e.exit("chunkText"), o) : (e.consume(s), a);
  }
}
const ode = {
  tokenize: ade
}, zF = {
  tokenize: sde
};
function ade(e) {
  const t = this, r = [];
  let n = 0, i, o, a;
  return s;
  function s(C) {
    if (n < r.length) {
      const S = r[n];
      return t.containerState = S[1], e.attempt(
        S[0].continuation,
        l,
        u
      )(C);
    }
    return u(C);
  }
  function l(C) {
    if (n++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, i && y();
      const S = t.events.length;
      let b = S, w;
      for (; b--; )
        if (t.events[b][0] === "exit" && t.events[b][1].type === "chunkFlow") {
          w = t.events[b][1].end;
          break;
        }
      m(n);
      let x = S;
      for (; x < t.events.length; )
        t.events[x][1].end = Object.assign({}, w), x++;
      return Gs(
        t.events,
        b + 1,
        0,
        t.events.slice(S)
      ), t.events.length = x, u(C);
    }
    return s(C);
  }
  function u(C) {
    if (n === r.length) {
      if (!i)
        return h(C);
      if (i.currentConstruct && i.currentConstruct.concrete)
        return p(C);
      t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      zF,
      c,
      d
    )(C);
  }
  function c(C) {
    return i && y(), m(n), h(C);
  }
  function d(C) {
    return t.parser.lazy[t.now().line] = n !== r.length, a = t.now().offset, p(C);
  }
  function h(C) {
    return t.containerState = {}, e.attempt(
      zF,
      f,
      p
    )(C);
  }
  function f(C) {
    return n++, r.push([t.currentConstruct, t.containerState]), h(C);
  }
  function p(C) {
    if (C === null) {
      i && y(), m(0), e.consume(C);
      return;
    }
    return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: o,
      _tokenizer: i
    }), g(C);
  }
  function g(C) {
    if (C === null) {
      v(e.exit("chunkFlow"), !0), m(0), e.consume(C);
      return;
    }
    return Dt(C) ? (e.consume(C), v(e.exit("chunkFlow")), n = 0, t.interrupt = void 0, s) : (e.consume(C), g);
  }
  function v(C, S) {
    const b = t.sliceStream(C);
    if (S && b.push(null), C.previous = o, o && (o.next = C), o = C, i.defineSkip(C.start), i.write(b), t.parser.lazy[C.start.line]) {
      let w = i.events.length;
      for (; w--; )
        if (
          // The token starts before the line ending…
          i.events[w][1].start.offset < a && // …and either is not ended yet…
          (!i.events[w][1].end || // …or ends after it.
          i.events[w][1].end.offset > a)
        )
          return;
      const x = t.events.length;
      let E = x, R, _;
      for (; E--; )
        if (t.events[E][0] === "exit" && t.events[E][1].type === "chunkFlow") {
          if (R) {
            _ = t.events[E][1].end;
            break;
          }
          R = !0;
        }
      for (m(n), w = x; w < t.events.length; )
        t.events[w][1].end = Object.assign({}, _), w++;
      Gs(
        t.events,
        E + 1,
        0,
        t.events.slice(x)
      ), t.events.length = w;
    }
  }
  function m(C) {
    let S = r.length;
    for (; S-- > C; ) {
      const b = r[S];
      t.containerState = b[1], b[0].exit.call(t, e);
    }
    r.length = C;
  }
  function y() {
    i.write([null]), o = void 0, i = void 0, t.containerState._closeFlow = void 0;
  }
}
function sde(e, t, r) {
  return Or(
    e,
    e.attempt(this.parser.constructs.document, t, r),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function $F(e) {
  if (e === null || Ni(e) || rde(e))
    return 1;
  if (tde(e))
    return 2;
}
function BP(e, t, r) {
  const n = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const o = e[i].resolveAll;
    o && !n.includes(o) && (t = o(t, r), n.push(o));
  }
  return t;
}
const SR = {
  name: "attention",
  tokenize: ude,
  resolveAll: lde
};
function lde(e, t) {
  let r = -1, n, i, o, a, s, l, u, c;
  for (; ++r < e.length; )
    if (e[r][0] === "enter" && e[r][1].type === "attentionSequence" && e[r][1]._close) {
      for (n = r; n--; )
        if (e[n][0] === "exit" && e[n][1].type === "attentionSequence" && e[n][1]._open && // If the markers are the same:
        t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[r][1]).charCodeAt(0)) {
          if ((e[n][1]._close || e[r][1]._open) && (e[r][1].end.offset - e[r][1].start.offset) % 3 && !((e[n][1].end.offset - e[n][1].start.offset + e[r][1].end.offset - e[r][1].start.offset) % 3))
            continue;
          l = e[n][1].end.offset - e[n][1].start.offset > 1 && e[r][1].end.offset - e[r][1].start.offset > 1 ? 2 : 1;
          const d = Object.assign({}, e[n][1].end), h = Object.assign({}, e[r][1].start);
          WF(d, -l), WF(h, l), a = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: Object.assign({}, e[n][1].end)
          }, s = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[r][1].start),
            end: h
          }, o = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[n][1].end),
            end: Object.assign({}, e[r][1].start)
          }, i = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, a.start),
            end: Object.assign({}, s.end)
          }, e[n][1].end = Object.assign({}, a.start), e[r][1].start = Object.assign({}, s.end), u = [], e[n][1].end.offset - e[n][1].start.offset && (u = bo(u, [["enter", e[n][1], t], ["exit", e[n][1], t]])), u = bo(u, [["enter", i, t], ["enter", a, t], ["exit", a, t], ["enter", o, t]]), u = bo(u, BP(t.parser.constructs.insideSpan.null, e.slice(n + 1, r), t)), u = bo(u, [["exit", o, t], ["enter", s, t], ["exit", s, t], ["exit", i, t]]), e[r][1].end.offset - e[r][1].start.offset ? (c = 2, u = bo(u, [["enter", e[r][1], t], ["exit", e[r][1], t]])) : c = 0, Gs(e, n - 1, r - n + 3, u), r = n + u.length - c - 2;
          break;
        }
    }
  for (r = -1; ++r < e.length; )
    e[r][1].type === "attentionSequence" && (e[r][1].type = "data");
  return e;
}
function ude(e, t) {
  const r = this.parser.constructs.attentionMarkers.null, n = this.previous, i = $F(n);
  let o;
  return a;
  function a(l) {
    return o = l, e.enter("attentionSequence"), s(l);
  }
  function s(l) {
    if (l === o)
      return e.consume(l), s;
    const u = e.exit("attentionSequence"), c = $F(l), d = !c || c === 2 && i || r.includes(l), h = !i || i === 2 && c || r.includes(n);
    return u._open = !!(o === 42 ? d : d && (i || !h)), u._close = !!(o === 42 ? h : h && (c || !d)), t(l);
  }
}
function WF(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const cde = {
  name: "autolink",
  tokenize: dde
};
function dde(e, t, r) {
  let n = 0;
  return i;
  function i(f) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), o;
  }
  function o(f) {
    return Va(f) ? (e.consume(f), a) : f === 64 ? r(f) : u(f);
  }
  function a(f) {
    return f === 43 || f === 45 || f === 46 || Qi(f) ? (n = 1, s(f)) : u(f);
  }
  function s(f) {
    return f === 58 ? (e.consume(f), n = 0, l) : (f === 43 || f === 45 || f === 46 || Qi(f)) && n++ < 32 ? (e.consume(f), s) : (n = 0, u(f));
  }
  function l(f) {
    return f === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : f === null || f === 32 || f === 60 || yR(f) ? r(f) : (e.consume(f), l);
  }
  function u(f) {
    return f === 64 ? (e.consume(f), c) : Qce(f) ? (e.consume(f), u) : r(f);
  }
  function c(f) {
    return Qi(f) ? d(f) : r(f);
  }
  function d(f) {
    return f === 46 ? (e.consume(f), n = 0, c) : f === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(f), e.exit("autolinkMarker"), e.exit("autolink"), t) : h(f);
  }
  function h(f) {
    if ((f === 45 || Qi(f)) && n++ < 63) {
      const p = f === 45 ? h : d;
      return e.consume(f), p;
    }
    return r(f);
  }
}
const vS = {
  tokenize: hde,
  partial: !0
};
function hde(e, t, r) {
  return n;
  function n(o) {
    return pr(o) ? Or(e, i, "linePrefix")(o) : i(o);
  }
  function i(o) {
    return o === null || Dt(o) ? t(o) : r(o);
  }
}
const S3 = {
  name: "blockQuote",
  tokenize: fde,
  continuation: {
    tokenize: pde
  },
  exit: gde
};
function fde(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    if (a === 62) {
      const s = n.containerState;
      return s.open || (e.enter("blockQuote", {
        _container: !0
      }), s.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(a), e.exit("blockQuoteMarker"), o;
    }
    return r(a);
  }
  function o(a) {
    return pr(a) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(a), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(a));
  }
}
function pde(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return pr(a) ? Or(e, o, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) : o(a);
  }
  function o(a) {
    return e.attempt(S3, t, r)(a);
  }
}
function gde(e) {
  e.exit("blockQuote");
}
const w3 = {
  name: "characterEscape",
  tokenize: vde
};
function vde(e, t, r) {
  return n;
  function n(o) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(o), e.exit("escapeMarker"), i;
  }
  function i(o) {
    return ede(o) ? (e.enter("characterEscapeValue"), e.consume(o), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : r(o);
  }
}
const b3 = {
  name: "characterReference",
  tokenize: mde
};
function mde(e, t, r) {
  const n = this;
  let i = 0, o, a;
  return s;
  function s(d) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), l;
  }
  function l(d) {
    return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), u) : (e.enter("characterReferenceValue"), o = 31, a = Qi, c(d));
  }
  function u(d) {
    return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), o = 6, a = Jce, c) : (e.enter("characterReferenceValue"), o = 7, a = CR, c(d));
  }
  function c(d) {
    if (d === 59 && i) {
      const h = e.exit("characterReferenceValue");
      return a === Qi && !VP(n.sliceSerialize(h)) ? r(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return a(d) && i++ < o ? (e.consume(d), c) : r(d);
  }
}
const jF = {
  tokenize: Cde,
  partial: !0
}, UF = {
  name: "codeFenced",
  tokenize: yde,
  concrete: !0
};
function yde(e, t, r) {
  const n = this, i = {
    tokenize: b,
    partial: !0
  };
  let o = 0, a = 0, s;
  return l;
  function l(w) {
    return u(w);
  }
  function u(w) {
    const x = n.events[n.events.length - 1];
    return o = x && x[1].type === "linePrefix" ? x[2].sliceSerialize(x[1], !0).length : 0, s = w, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), c(w);
  }
  function c(w) {
    return w === s ? (a++, e.consume(w), c) : a < 3 ? r(w) : (e.exit("codeFencedFenceSequence"), pr(w) ? Or(e, d, "whitespace")(w) : d(w));
  }
  function d(w) {
    return w === null || Dt(w) ? (e.exit("codeFencedFence"), n.interrupt ? t(w) : e.check(jF, g, S)(w)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), h(w));
  }
  function h(w) {
    return w === null || Dt(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(w)) : pr(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), Or(e, f, "whitespace")(w)) : w === 96 && w === s ? r(w) : (e.consume(w), h);
  }
  function f(w) {
    return w === null || Dt(w) ? d(w) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), p(w));
  }
  function p(w) {
    return w === null || Dt(w) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(w)) : w === 96 && w === s ? r(w) : (e.consume(w), p);
  }
  function g(w) {
    return e.attempt(i, S, v)(w);
  }
  function v(w) {
    return e.enter("lineEnding"), e.consume(w), e.exit("lineEnding"), m;
  }
  function m(w) {
    return o > 0 && pr(w) ? Or(e, y, "linePrefix", o + 1)(w) : y(w);
  }
  function y(w) {
    return w === null || Dt(w) ? e.check(jF, g, S)(w) : (e.enter("codeFlowValue"), C(w));
  }
  function C(w) {
    return w === null || Dt(w) ? (e.exit("codeFlowValue"), y(w)) : (e.consume(w), C);
  }
  function S(w) {
    return e.exit("codeFenced"), t(w);
  }
  function b(w, x, E) {
    let R = 0;
    return _;
    function _(O) {
      return w.enter("lineEnding"), w.consume(O), w.exit("lineEnding"), P;
    }
    function P(O) {
      return w.enter("codeFencedFence"), pr(O) ? Or(w, D, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(O) : D(O);
    }
    function D(O) {
      return O === s ? (w.enter("codeFencedFenceSequence"), I(O)) : E(O);
    }
    function I(O) {
      return O === s ? (R++, w.consume(O), I) : R >= a ? (w.exit("codeFencedFenceSequence"), pr(O) ? Or(w, A, "whitespace")(O) : A(O)) : E(O);
    }
    function A(O) {
      return O === null || Dt(O) ? (w.exit("codeFencedFence"), x(O)) : E(O);
    }
  }
}
function Cde(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return a === null ? r(a) : (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o);
  }
  function o(a) {
    return n.parser.lazy[n.now().line] ? r(a) : t(a);
  }
}
const sb = {
  name: "codeIndented",
  tokenize: wde
}, Sde = {
  tokenize: bde,
  partial: !0
};
function wde(e, t, r) {
  const n = this;
  return i;
  function i(u) {
    return e.enter("codeIndented"), Or(e, o, "linePrefix", 5)(u);
  }
  function o(u) {
    const c = n.events[n.events.length - 1];
    return c && c[1].type === "linePrefix" && c[2].sliceSerialize(c[1], !0).length >= 4 ? a(u) : r(u);
  }
  function a(u) {
    return u === null ? l(u) : Dt(u) ? e.attempt(Sde, a, l)(u) : (e.enter("codeFlowValue"), s(u));
  }
  function s(u) {
    return u === null || Dt(u) ? (e.exit("codeFlowValue"), a(u)) : (e.consume(u), s);
  }
  function l(u) {
    return e.exit("codeIndented"), t(u);
  }
}
function bde(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return n.parser.lazy[n.now().line] ? r(a) : Dt(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), i) : Or(e, o, "linePrefix", 5)(a);
  }
  function o(a) {
    const s = n.events[n.events.length - 1];
    return s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : Dt(a) ? i(a) : r(a);
  }
}
const xde = {
  name: "codeText",
  tokenize: _de,
  resolve: Ede,
  previous: Rde
};
function Ede(e) {
  let t = e.length - 4, r = 3, n, i;
  if ((e[r][1].type === "lineEnding" || e[r][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (n = r; ++n < t; )
      if (e[n][1].type === "codeTextData") {
        e[r][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", r += 2, t -= 2;
        break;
      }
  }
  for (n = r - 1, t++; ++n <= t; )
    i === void 0 ? n !== t && e[n][1].type !== "lineEnding" && (i = n) : (n === t || e[n][1].type === "lineEnding") && (e[i][1].type = "codeTextData", n !== i + 2 && (e[i][1].end = e[n - 1][1].end, e.splice(i + 2, n - i - 2), t -= n - i - 2, n = i + 2), i = void 0);
  return e;
}
function Rde(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function _de(e, t, r) {
  let n = 0, i, o;
  return a;
  function a(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), s(d);
  }
  function s(d) {
    return d === 96 ? (e.consume(d), n++, s) : (e.exit("codeTextSequence"), l(d));
  }
  function l(d) {
    return d === null ? r(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), l) : d === 96 ? (o = e.enter("codeTextSequence"), i = 0, c(d)) : Dt(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), l) : (e.enter("codeTextData"), u(d));
  }
  function u(d) {
    return d === null || d === 32 || d === 96 || Dt(d) ? (e.exit("codeTextData"), l(d)) : (e.consume(d), u);
  }
  function c(d) {
    return d === 96 ? (e.consume(d), i++, c) : i === n ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (o.type = "codeTextData", u(d));
  }
}
class Tde {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(t) {
    this.left = t ? [...t] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(t) {
    if (t < 0 || t >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(t, r) {
    const n = r ?? Number.POSITIVE_INFINITY;
    return n < this.left.length ? this.left.slice(t, n) : t > this.left.length ? this.right.slice(this.right.length - n + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - n + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(t, r, n) {
    const i = r || 0;
    this.setCursor(Math.trunc(t));
    const o = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY);
    return n && Hf(this.left, n), o.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(t) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(t) {
    this.setCursor(Number.POSITIVE_INFINITY), Hf(this.left, t);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(t) {
    this.setCursor(0), this.right.push(t);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(t) {
    this.setCursor(0), Hf(this.right, t.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(t) {
    if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0))
      if (t < this.left.length) {
        const r = this.left.splice(t, Number.POSITIVE_INFINITY);
        Hf(this.right, r.reverse());
      } else {
        const r = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY);
        Hf(this.left, r.reverse());
      }
  }
}
function Hf(e, t) {
  let r = 0;
  if (t.length < 1e4)
    e.push(...t);
  else
    for (; r < t.length; )
      e.push(...t.slice(r, r + 1e4)), r += 1e4;
}
function x3(e) {
  const t = {};
  let r = -1, n, i, o, a, s, l, u;
  const c = new Tde(e);
  for (; ++r < c.length; ) {
    for (; r in t; )
      r = t[r];
    if (n = c.get(r), r && n[1].type === "chunkFlow" && c.get(r - 1)[1].type === "listItemPrefix" && (l = n[1]._tokenizer.events, o = 0, o < l.length && l[o][1].type === "lineEndingBlank" && (o += 2), o < l.length && l[o][1].type === "content"))
      for (; ++o < l.length && l[o][1].type !== "content"; )
        l[o][1].type === "chunkText" && (l[o][1]._isInFirstContentOfListItem = !0, o++);
    if (n[0] === "enter")
      n[1].contentType && (Object.assign(t, Pde(c, r)), r = t[r], u = !0);
    else if (n[1]._container) {
      for (o = r, i = void 0; o-- && (a = c.get(o), a[1].type === "lineEnding" || a[1].type === "lineEndingBlank"); )
        a[0] === "enter" && (i && (c.get(i)[1].type = "lineEndingBlank"), a[1].type = "lineEnding", i = o);
      i && (n[1].end = Object.assign({}, c.get(i)[1].start), s = c.slice(i, r), s.unshift(n), c.splice(i, r - i + 1, s));
    }
  }
  return Gs(e, 0, Number.POSITIVE_INFINITY, c.slice(0)), !u;
}
function Pde(e, t) {
  const r = e.get(t)[1], n = e.get(t)[2];
  let i = t - 1;
  const o = [], a = r._tokenizer || n.parser[r.contentType](r.start), s = a.events, l = [], u = {};
  let c, d, h = -1, f = r, p = 0, g = 0;
  const v = [g];
  for (; f; ) {
    for (; e.get(++i)[1] !== f; )
      ;
    o.push(i), f._tokenizer || (c = n.sliceStream(f), f.next || c.push(null), d && a.defineSkip(f.start), f._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = !0), a.write(c), f._isInFirstContentOfListItem && (a._gfmTasklistFirstContentOfListItem = void 0)), d = f, f = f.next;
  }
  for (f = r; ++h < s.length; )
    // Find a void token that includes a break.
    s[h][0] === "exit" && s[h - 1][0] === "enter" && s[h][1].type === s[h - 1][1].type && s[h][1].start.line !== s[h][1].end.line && (g = h + 1, v.push(g), f._tokenizer = void 0, f.previous = void 0, f = f.next);
  for (a.events = [], f ? (f._tokenizer = void 0, f.previous = void 0) : v.pop(), h = v.length; h--; ) {
    const m = s.slice(v[h], v[h + 1]), y = o.pop();
    l.push([y, y + m.length - 1]), e.splice(y, 2, m);
  }
  for (l.reverse(), h = -1; ++h < l.length; )
    u[p + l[h][0]] = p + l[h][1], p += l[h][1] - l[h][0] - 1;
  return u;
}
const Mde = {
  tokenize: Ide,
  resolve: Ade
}, Dde = {
  tokenize: Fde,
  partial: !0
};
function Ade(e) {
  return x3(e), e;
}
function Ide(e, t) {
  let r;
  return n;
  function n(s) {
    return e.enter("content"), r = e.enter("chunkContent", {
      contentType: "content"
    }), i(s);
  }
  function i(s) {
    return s === null ? o(s) : Dt(s) ? e.check(Dde, a, o)(s) : (e.consume(s), i);
  }
  function o(s) {
    return e.exit("chunkContent"), e.exit("content"), t(s);
  }
  function a(s) {
    return e.consume(s), e.exit("chunkContent"), r.next = e.enter("chunkContent", {
      contentType: "content",
      previous: r
    }), r = r.next, i;
  }
}
function Fde(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), Or(e, o, "linePrefix");
  }
  function o(a) {
    if (a === null || Dt(a))
      return r(a);
    const s = n.events[n.events.length - 1];
    return !n.parser.constructs.disable.null.includes("codeIndented") && s && s[1].type === "linePrefix" && s[2].sliceSerialize(s[1], !0).length >= 4 ? t(a) : e.interrupt(n.parser.constructs.flow, r, t)(a);
  }
}
function E3(e, t, r, n, i, o, a, s, l) {
  const u = l || Number.POSITIVE_INFINITY;
  let c = 0;
  return d;
  function d(m) {
    return m === 60 ? (e.enter(n), e.enter(i), e.enter(o), e.consume(m), e.exit(o), h) : m === null || m === 32 || m === 41 || yR(m) ? r(m) : (e.enter(n), e.enter(a), e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), g(m));
  }
  function h(m) {
    return m === 62 ? (e.enter(o), e.consume(m), e.exit(o), e.exit(i), e.exit(n), t) : (e.enter(s), e.enter("chunkString", {
      contentType: "string"
    }), f(m));
  }
  function f(m) {
    return m === 62 ? (e.exit("chunkString"), e.exit(s), h(m)) : m === null || m === 60 || Dt(m) ? r(m) : (e.consume(m), m === 92 ? p : f);
  }
  function p(m) {
    return m === 60 || m === 62 || m === 92 ? (e.consume(m), f) : f(m);
  }
  function g(m) {
    return !c && (m === null || m === 41 || Ni(m)) ? (e.exit("chunkString"), e.exit(s), e.exit(a), e.exit(n), t(m)) : c < u && m === 40 ? (e.consume(m), c++, g) : m === 41 ? (e.consume(m), c--, g) : m === null || m === 32 || m === 40 || yR(m) ? r(m) : (e.consume(m), m === 92 ? v : g);
  }
  function v(m) {
    return m === 40 || m === 41 || m === 92 ? (e.consume(m), g) : g(m);
  }
}
function R3(e, t, r, n, i, o) {
  const a = this;
  let s = 0, l;
  return u;
  function u(f) {
    return e.enter(n), e.enter(i), e.consume(f), e.exit(i), e.enter(o), c;
  }
  function c(f) {
    return s > 999 || f === null || f === 91 || f === 93 && !l || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    f === 94 && !s && "_hiddenFootnoteSupport" in a.parser.constructs ? r(f) : f === 93 ? (e.exit(o), e.enter(i), e.consume(f), e.exit(i), e.exit(n), t) : Dt(f) ? (e.enter("lineEnding"), e.consume(f), e.exit("lineEnding"), c) : (e.enter("chunkString", {
      contentType: "string"
    }), d(f));
  }
  function d(f) {
    return f === null || f === 91 || f === 93 || Dt(f) || s++ > 999 ? (e.exit("chunkString"), c(f)) : (e.consume(f), l || (l = !pr(f)), f === 92 ? h : d);
  }
  function h(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), s++, d) : d(f);
  }
}
function _3(e, t, r, n, i, o) {
  let a;
  return s;
  function s(h) {
    return h === 34 || h === 39 || h === 40 ? (e.enter(n), e.enter(i), e.consume(h), e.exit(i), a = h === 40 ? 41 : h, l) : r(h);
  }
  function l(h) {
    return h === a ? (e.enter(i), e.consume(h), e.exit(i), e.exit(n), t) : (e.enter(o), u(h));
  }
  function u(h) {
    return h === a ? (e.exit(o), l(a)) : h === null ? r(h) : Dt(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), Or(e, u, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), c(h));
  }
  function c(h) {
    return h === a || h === null || Dt(h) ? (e.exit("chunkString"), u(h)) : (e.consume(h), h === 92 ? d : c);
  }
  function d(h) {
    return h === a || h === 92 ? (e.consume(h), c) : c(h);
  }
}
function jp(e, t) {
  let r;
  return n;
  function n(i) {
    return Dt(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), r = !0, n) : pr(i) ? Or(
      e,
      n,
      r ? "linePrefix" : "lineSuffix"
    )(i) : t(i);
  }
}
const Lde = {
  name: "definition",
  tokenize: Nde
}, Ode = {
  tokenize: kde,
  partial: !0
};
function Nde(e, t, r) {
  const n = this;
  let i;
  return o;
  function o(f) {
    return e.enter("definition"), a(f);
  }
  function a(f) {
    return R3.call(
      n,
      e,
      s,
      // Note: we don’t need to reset the way `markdown-rs` does.
      r,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(f);
  }
  function s(f) {
    return i = dh(n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1)), f === 58 ? (e.enter("definitionMarker"), e.consume(f), e.exit("definitionMarker"), l) : r(f);
  }
  function l(f) {
    return Ni(f) ? jp(e, u)(f) : u(f);
  }
  function u(f) {
    return E3(
      e,
      c,
      // Note: we don’t need to reset the way `markdown-rs` does.
      r,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(f);
  }
  function c(f) {
    return e.attempt(Ode, d, d)(f);
  }
  function d(f) {
    return pr(f) ? Or(e, h, "whitespace")(f) : h(f);
  }
  function h(f) {
    return f === null || Dt(f) ? (e.exit("definition"), n.parser.defined.push(i), t(f)) : r(f);
  }
}
function kde(e, t, r) {
  return n;
  function n(s) {
    return Ni(s) ? jp(e, i)(s) : r(s);
  }
  function i(s) {
    return _3(e, o, r, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(s);
  }
  function o(s) {
    return pr(s) ? Or(e, a, "whitespace")(s) : a(s);
  }
  function a(s) {
    return s === null || Dt(s) ? t(s) : r(s);
  }
}
const Vde = {
  name: "hardBreakEscape",
  tokenize: Bde
};
function Bde(e, t, r) {
  return n;
  function n(o) {
    return e.enter("hardBreakEscape"), e.consume(o), i;
  }
  function i(o) {
    return Dt(o) ? (e.exit("hardBreakEscape"), t(o)) : r(o);
  }
}
const Gde = {
  name: "headingAtx",
  tokenize: zde,
  resolve: Hde
};
function Hde(e, t) {
  let r = e.length - 2, n = 3, i, o;
  return e[n][1].type === "whitespace" && (n += 2), r - 2 > n && e[r][1].type === "whitespace" && (r -= 2), e[r][1].type === "atxHeadingSequence" && (n === r - 1 || r - 4 > n && e[r - 2][1].type === "whitespace") && (r -= n + 1 === r ? 2 : 4), r > n && (i = {
    type: "atxHeadingText",
    start: e[n][1].start,
    end: e[r][1].end
  }, o = {
    type: "chunkText",
    start: e[n][1].start,
    end: e[r][1].end,
    contentType: "text"
  }, Gs(e, n, r - n + 1, [["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t]])), e;
}
function zde(e, t, r) {
  let n = 0;
  return i;
  function i(c) {
    return e.enter("atxHeading"), o(c);
  }
  function o(c) {
    return e.enter("atxHeadingSequence"), a(c);
  }
  function a(c) {
    return c === 35 && n++ < 6 ? (e.consume(c), a) : c === null || Ni(c) ? (e.exit("atxHeadingSequence"), s(c)) : r(c);
  }
  function s(c) {
    return c === 35 ? (e.enter("atxHeadingSequence"), l(c)) : c === null || Dt(c) ? (e.exit("atxHeading"), t(c)) : pr(c) ? Or(e, s, "whitespace")(c) : (e.enter("atxHeadingText"), u(c));
  }
  function l(c) {
    return c === 35 ? (e.consume(c), l) : (e.exit("atxHeadingSequence"), s(c));
  }
  function u(c) {
    return c === null || c === 35 || Ni(c) ? (e.exit("atxHeadingText"), s(c)) : (e.consume(c), u);
  }
}
const $de = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], KF = ["pre", "script", "style", "textarea"], Wde = {
  name: "htmlFlow",
  tokenize: Yde,
  resolveTo: Kde,
  concrete: !0
}, jde = {
  tokenize: Zde,
  partial: !0
}, Ude = {
  tokenize: qde,
  partial: !0
};
function Kde(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function Yde(e, t, r) {
  const n = this;
  let i, o, a, s, l;
  return u;
  function u(k) {
    return c(k);
  }
  function c(k) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(k), d;
  }
  function d(k) {
    return k === 33 ? (e.consume(k), h) : k === 47 ? (e.consume(k), o = !0, g) : k === 63 ? (e.consume(k), i = 3, n.interrupt ? t : M) : Va(k) ? (e.consume(k), a = String.fromCharCode(k), v) : r(k);
  }
  function h(k) {
    return k === 45 ? (e.consume(k), i = 2, f) : k === 91 ? (e.consume(k), i = 5, s = 0, p) : Va(k) ? (e.consume(k), i = 4, n.interrupt ? t : M) : r(k);
  }
  function f(k) {
    return k === 45 ? (e.consume(k), n.interrupt ? t : M) : r(k);
  }
  function p(k) {
    const $ = "CDATA[";
    return k === $.charCodeAt(s++) ? (e.consume(k), s === $.length ? n.interrupt ? t : D : p) : r(k);
  }
  function g(k) {
    return Va(k) ? (e.consume(k), a = String.fromCharCode(k), v) : r(k);
  }
  function v(k) {
    if (k === null || k === 47 || k === 62 || Ni(k)) {
      const $ = k === 47, W = a.toLowerCase();
      return !$ && !o && KF.includes(W) ? (i = 1, n.interrupt ? t(k) : D(k)) : $de.includes(a.toLowerCase()) ? (i = 6, $ ? (e.consume(k), m) : n.interrupt ? t(k) : D(k)) : (i = 7, n.interrupt && !n.parser.lazy[n.now().line] ? r(k) : o ? y(k) : C(k));
    }
    return k === 45 || Qi(k) ? (e.consume(k), a += String.fromCharCode(k), v) : r(k);
  }
  function m(k) {
    return k === 62 ? (e.consume(k), n.interrupt ? t : D) : r(k);
  }
  function y(k) {
    return pr(k) ? (e.consume(k), y) : _(k);
  }
  function C(k) {
    return k === 47 ? (e.consume(k), _) : k === 58 || k === 95 || Va(k) ? (e.consume(k), S) : pr(k) ? (e.consume(k), C) : _(k);
  }
  function S(k) {
    return k === 45 || k === 46 || k === 58 || k === 95 || Qi(k) ? (e.consume(k), S) : b(k);
  }
  function b(k) {
    return k === 61 ? (e.consume(k), w) : pr(k) ? (e.consume(k), b) : C(k);
  }
  function w(k) {
    return k === null || k === 60 || k === 61 || k === 62 || k === 96 ? r(k) : k === 34 || k === 39 ? (e.consume(k), l = k, x) : pr(k) ? (e.consume(k), w) : E(k);
  }
  function x(k) {
    return k === l ? (e.consume(k), l = null, R) : k === null || Dt(k) ? r(k) : (e.consume(k), x);
  }
  function E(k) {
    return k === null || k === 34 || k === 39 || k === 47 || k === 60 || k === 61 || k === 62 || k === 96 || Ni(k) ? b(k) : (e.consume(k), E);
  }
  function R(k) {
    return k === 47 || k === 62 || pr(k) ? C(k) : r(k);
  }
  function _(k) {
    return k === 62 ? (e.consume(k), P) : r(k);
  }
  function P(k) {
    return k === null || Dt(k) ? D(k) : pr(k) ? (e.consume(k), P) : r(k);
  }
  function D(k) {
    return k === 45 && i === 2 ? (e.consume(k), L) : k === 60 && i === 1 ? (e.consume(k), N) : k === 62 && i === 4 ? (e.consume(k), V) : k === 63 && i === 3 ? (e.consume(k), M) : k === 93 && i === 5 ? (e.consume(k), G) : Dt(k) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(jde, z, I)(k)) : k === null || Dt(k) ? (e.exit("htmlFlowData"), I(k)) : (e.consume(k), D);
  }
  function I(k) {
    return e.check(Ude, A, z)(k);
  }
  function A(k) {
    return e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), O;
  }
  function O(k) {
    return k === null || Dt(k) ? I(k) : (e.enter("htmlFlowData"), D(k));
  }
  function L(k) {
    return k === 45 ? (e.consume(k), M) : D(k);
  }
  function N(k) {
    return k === 47 ? (e.consume(k), a = "", F) : D(k);
  }
  function F(k) {
    if (k === 62) {
      const $ = a.toLowerCase();
      return KF.includes($) ? (e.consume(k), V) : D(k);
    }
    return Va(k) && a.length < 8 ? (e.consume(k), a += String.fromCharCode(k), F) : D(k);
  }
  function G(k) {
    return k === 93 ? (e.consume(k), M) : D(k);
  }
  function M(k) {
    return k === 62 ? (e.consume(k), V) : k === 45 && i === 2 ? (e.consume(k), M) : D(k);
  }
  function V(k) {
    return k === null || Dt(k) ? (e.exit("htmlFlowData"), z(k)) : (e.consume(k), V);
  }
  function z(k) {
    return e.exit("htmlFlow"), t(k);
  }
}
function qde(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return Dt(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), o) : r(a);
  }
  function o(a) {
    return n.parser.lazy[n.now().line] ? r(a) : t(a);
  }
}
function Zde(e, t, r) {
  return n;
  function n(i) {
    return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(vS, t, r);
  }
}
const Xde = {
  name: "htmlText",
  tokenize: Qde
};
function Qde(e, t, r) {
  const n = this;
  let i, o, a;
  return s;
  function s(M) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(M), l;
  }
  function l(M) {
    return M === 33 ? (e.consume(M), u) : M === 47 ? (e.consume(M), b) : M === 63 ? (e.consume(M), C) : Va(M) ? (e.consume(M), E) : r(M);
  }
  function u(M) {
    return M === 45 ? (e.consume(M), c) : M === 91 ? (e.consume(M), o = 0, p) : Va(M) ? (e.consume(M), y) : r(M);
  }
  function c(M) {
    return M === 45 ? (e.consume(M), f) : r(M);
  }
  function d(M) {
    return M === null ? r(M) : M === 45 ? (e.consume(M), h) : Dt(M) ? (a = d, N(M)) : (e.consume(M), d);
  }
  function h(M) {
    return M === 45 ? (e.consume(M), f) : d(M);
  }
  function f(M) {
    return M === 62 ? L(M) : M === 45 ? h(M) : d(M);
  }
  function p(M) {
    const V = "CDATA[";
    return M === V.charCodeAt(o++) ? (e.consume(M), o === V.length ? g : p) : r(M);
  }
  function g(M) {
    return M === null ? r(M) : M === 93 ? (e.consume(M), v) : Dt(M) ? (a = g, N(M)) : (e.consume(M), g);
  }
  function v(M) {
    return M === 93 ? (e.consume(M), m) : g(M);
  }
  function m(M) {
    return M === 62 ? L(M) : M === 93 ? (e.consume(M), m) : g(M);
  }
  function y(M) {
    return M === null || M === 62 ? L(M) : Dt(M) ? (a = y, N(M)) : (e.consume(M), y);
  }
  function C(M) {
    return M === null ? r(M) : M === 63 ? (e.consume(M), S) : Dt(M) ? (a = C, N(M)) : (e.consume(M), C);
  }
  function S(M) {
    return M === 62 ? L(M) : C(M);
  }
  function b(M) {
    return Va(M) ? (e.consume(M), w) : r(M);
  }
  function w(M) {
    return M === 45 || Qi(M) ? (e.consume(M), w) : x(M);
  }
  function x(M) {
    return Dt(M) ? (a = x, N(M)) : pr(M) ? (e.consume(M), x) : L(M);
  }
  function E(M) {
    return M === 45 || Qi(M) ? (e.consume(M), E) : M === 47 || M === 62 || Ni(M) ? R(M) : r(M);
  }
  function R(M) {
    return M === 47 ? (e.consume(M), L) : M === 58 || M === 95 || Va(M) ? (e.consume(M), _) : Dt(M) ? (a = R, N(M)) : pr(M) ? (e.consume(M), R) : L(M);
  }
  function _(M) {
    return M === 45 || M === 46 || M === 58 || M === 95 || Qi(M) ? (e.consume(M), _) : P(M);
  }
  function P(M) {
    return M === 61 ? (e.consume(M), D) : Dt(M) ? (a = P, N(M)) : pr(M) ? (e.consume(M), P) : R(M);
  }
  function D(M) {
    return M === null || M === 60 || M === 61 || M === 62 || M === 96 ? r(M) : M === 34 || M === 39 ? (e.consume(M), i = M, I) : Dt(M) ? (a = D, N(M)) : pr(M) ? (e.consume(M), D) : (e.consume(M), A);
  }
  function I(M) {
    return M === i ? (e.consume(M), i = void 0, O) : M === null ? r(M) : Dt(M) ? (a = I, N(M)) : (e.consume(M), I);
  }
  function A(M) {
    return M === null || M === 34 || M === 39 || M === 60 || M === 61 || M === 96 ? r(M) : M === 47 || M === 62 || Ni(M) ? R(M) : (e.consume(M), A);
  }
  function O(M) {
    return M === 47 || M === 62 || Ni(M) ? R(M) : r(M);
  }
  function L(M) {
    return M === 62 ? (e.consume(M), e.exit("htmlTextData"), e.exit("htmlText"), t) : r(M);
  }
  function N(M) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(M), e.exit("lineEnding"), F;
  }
  function F(M) {
    return pr(M) ? Or(e, G, "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(M) : G(M);
  }
  function G(M) {
    return e.enter("htmlTextData"), a(M);
  }
}
const GP = {
  name: "labelEnd",
  tokenize: ihe,
  resolveTo: nhe,
  resolveAll: rhe
}, Jde = {
  tokenize: ohe
}, ehe = {
  tokenize: ahe
}, the = {
  tokenize: she
};
function rhe(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const r = e[t][1];
    (r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") && (e.splice(t + 1, r.type === "labelImage" ? 4 : 2), r.type = "data", t++);
  }
  return e;
}
function nhe(e, t) {
  let r = e.length, n = 0, i, o, a, s;
  for (; r--; )
    if (i = e[r][1], o) {
      if (i.type === "link" || i.type === "labelLink" && i._inactive)
        break;
      e[r][0] === "enter" && i.type === "labelLink" && (i._inactive = !0);
    } else if (a) {
      if (e[r][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (o = r, i.type !== "labelLink")) {
        n = 2;
        break;
      }
    } else i.type === "labelEnd" && (a = r);
  const l = {
    type: e[o][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, u = {
    type: "label",
    start: Object.assign({}, e[o][1].start),
    end: Object.assign({}, e[a][1].end)
  }, c = {
    type: "labelText",
    start: Object.assign({}, e[o + n + 2][1].end),
    end: Object.assign({}, e[a - 2][1].start)
  };
  return s = [["enter", l, t], ["enter", u, t]], s = bo(s, e.slice(o + 1, o + n + 3)), s = bo(s, [["enter", c, t]]), s = bo(s, BP(t.parser.constructs.insideSpan.null, e.slice(o + n + 4, a - 3), t)), s = bo(s, [["exit", c, t], e[a - 2], e[a - 1], ["exit", u, t]]), s = bo(s, e.slice(a + 1)), s = bo(s, [["exit", l, t]]), Gs(e, o, e.length, s), e;
}
function ihe(e, t, r) {
  const n = this;
  let i = n.events.length, o, a;
  for (; i--; )
    if ((n.events[i][1].type === "labelImage" || n.events[i][1].type === "labelLink") && !n.events[i][1]._balanced) {
      o = n.events[i][1];
      break;
    }
  return s;
  function s(h) {
    return o ? o._inactive ? d(h) : (a = n.parser.defined.includes(dh(n.sliceSerialize({
      start: o.end,
      end: n.now()
    }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(h), e.exit("labelMarker"), e.exit("labelEnd"), l) : r(h);
  }
  function l(h) {
    return h === 40 ? e.attempt(Jde, c, a ? c : d)(h) : h === 91 ? e.attempt(ehe, c, a ? u : d)(h) : a ? c(h) : d(h);
  }
  function u(h) {
    return e.attempt(the, c, d)(h);
  }
  function c(h) {
    return t(h);
  }
  function d(h) {
    return o._balanced = !0, r(h);
  }
}
function ohe(e, t, r) {
  return n;
  function n(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), i;
  }
  function i(d) {
    return Ni(d) ? jp(e, o)(d) : o(d);
  }
  function o(d) {
    return d === 41 ? c(d) : E3(e, a, s, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d);
  }
  function a(d) {
    return Ni(d) ? jp(e, l)(d) : c(d);
  }
  function s(d) {
    return r(d);
  }
  function l(d) {
    return d === 34 || d === 39 || d === 40 ? _3(e, u, r, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : c(d);
  }
  function u(d) {
    return Ni(d) ? jp(e, c)(d) : c(d);
  }
  function c(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : r(d);
  }
}
function ahe(e, t, r) {
  const n = this;
  return i;
  function i(s) {
    return R3.call(n, e, o, a, "reference", "referenceMarker", "referenceString")(s);
  }
  function o(s) {
    return n.parser.defined.includes(dh(n.sliceSerialize(n.events[n.events.length - 1][1]).slice(1, -1))) ? t(s) : r(s);
  }
  function a(s) {
    return r(s);
  }
}
function she(e, t, r) {
  return n;
  function n(o) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), i;
  }
  function i(o) {
    return o === 93 ? (e.enter("referenceMarker"), e.consume(o), e.exit("referenceMarker"), e.exit("reference"), t) : r(o);
  }
}
const lhe = {
  name: "labelStartImage",
  tokenize: uhe,
  resolveAll: GP.resolveAll
};
function uhe(e, t, r) {
  const n = this;
  return i;
  function i(s) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(s), e.exit("labelImageMarker"), o;
  }
  function o(s) {
    return s === 91 ? (e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelImage"), a) : r(s);
  }
  function a(s) {
    return s === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? r(s) : t(s);
  }
}
const che = {
  name: "labelStartLink",
  tokenize: dhe,
  resolveAll: GP.resolveAll
};
function dhe(e, t, r) {
  const n = this;
  return i;
  function i(a) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelLink"), o;
  }
  function o(a) {
    return a === 94 && "_hiddenFootnoteSupport" in n.parser.constructs ? r(a) : t(a);
  }
}
const lb = {
  name: "lineEnding",
  tokenize: hhe
};
function hhe(e, t) {
  return r;
  function r(n) {
    return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), Or(e, t, "linePrefix");
  }
}
const Yy = {
  name: "thematicBreak",
  tokenize: fhe
};
function fhe(e, t, r) {
  let n = 0, i;
  return o;
  function o(u) {
    return e.enter("thematicBreak"), a(u);
  }
  function a(u) {
    return i = u, s(u);
  }
  function s(u) {
    return u === i ? (e.enter("thematicBreakSequence"), l(u)) : n >= 3 && (u === null || Dt(u)) ? (e.exit("thematicBreak"), t(u)) : r(u);
  }
  function l(u) {
    return u === i ? (e.consume(u), n++, l) : (e.exit("thematicBreakSequence"), pr(u) ? Or(e, s, "whitespace")(u) : s(u));
  }
}
const Di = {
  name: "list",
  tokenize: vhe,
  continuation: {
    tokenize: mhe
  },
  exit: Che
}, phe = {
  tokenize: She,
  partial: !0
}, ghe = {
  tokenize: yhe,
  partial: !0
};
function vhe(e, t, r) {
  const n = this, i = n.events[n.events.length - 1];
  let o = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, a = 0;
  return s;
  function s(f) {
    const p = n.containerState.type || (f === 42 || f === 43 || f === 45 ? "listUnordered" : "listOrdered");
    if (p === "listUnordered" ? !n.containerState.marker || f === n.containerState.marker : CR(f)) {
      if (n.containerState.type || (n.containerState.type = p, e.enter(p, {
        _container: !0
      })), p === "listUnordered")
        return e.enter("listItemPrefix"), f === 42 || f === 45 ? e.check(Yy, r, u)(f) : u(f);
      if (!n.interrupt || f === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(f);
    }
    return r(f);
  }
  function l(f) {
    return CR(f) && ++a < 10 ? (e.consume(f), l) : (!n.interrupt || a < 2) && (n.containerState.marker ? f === n.containerState.marker : f === 41 || f === 46) ? (e.exit("listItemValue"), u(f)) : r(f);
  }
  function u(f) {
    return e.enter("listItemMarker"), e.consume(f), e.exit("listItemMarker"), n.containerState.marker = n.containerState.marker || f, e.check(
      vS,
      // Can’t be empty when interrupting.
      n.interrupt ? r : c,
      e.attempt(phe, h, d)
    );
  }
  function c(f) {
    return n.containerState.initialBlankLine = !0, o++, h(f);
  }
  function d(f) {
    return pr(f) ? (e.enter("listItemPrefixWhitespace"), e.consume(f), e.exit("listItemPrefixWhitespace"), h) : r(f);
  }
  function h(f) {
    return n.containerState.size = o + n.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(f);
  }
}
function mhe(e, t, r) {
  const n = this;
  return n.containerState._closeFlow = void 0, e.check(vS, i, o);
  function i(s) {
    return n.containerState.furtherBlankLines = n.containerState.furtherBlankLines || n.containerState.initialBlankLine, Or(e, t, "listItemIndent", n.containerState.size + 1)(s);
  }
  function o(s) {
    return n.containerState.furtherBlankLines || !pr(s) ? (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0, a(s)) : (n.containerState.furtherBlankLines = void 0, n.containerState.initialBlankLine = void 0, e.attempt(ghe, t, a)(s));
  }
  function a(s) {
    return n.containerState._closeFlow = !0, n.interrupt = void 0, Or(e, e.attempt(Di, t, r), "linePrefix", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s);
  }
}
function yhe(e, t, r) {
  const n = this;
  return Or(e, i, "listItemIndent", n.containerState.size + 1);
  function i(o) {
    const a = n.events[n.events.length - 1];
    return a && a[1].type === "listItemIndent" && a[2].sliceSerialize(a[1], !0).length === n.containerState.size ? t(o) : r(o);
  }
}
function Che(e) {
  e.exit(this.containerState.type);
}
function She(e, t, r) {
  const n = this;
  return Or(e, i, "listItemPrefixWhitespace", n.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function i(o) {
    const a = n.events[n.events.length - 1];
    return !pr(o) && a && a[1].type === "listItemPrefixWhitespace" ? t(o) : r(o);
  }
}
const YF = {
  name: "setextUnderline",
  tokenize: bhe,
  resolveTo: whe
};
function whe(e, t) {
  let r = e.length, n, i, o;
  for (; r--; )
    if (e[r][0] === "enter") {
      if (e[r][1].type === "content") {
        n = r;
        break;
      }
      e[r][1].type === "paragraph" && (i = r);
    } else
      e[r][1].type === "content" && e.splice(r, 1), !o && e[r][1].type === "definition" && (o = r);
  const a = {
    type: "setextHeading",
    start: Object.assign({}, e[i][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[i][1].type = "setextHeadingText", o ? (e.splice(i, 0, ["enter", a, t]), e.splice(o + 1, 0, ["exit", e[n][1], t]), e[n][1].end = Object.assign({}, e[o][1].end)) : e[n][1] = a, e.push(["exit", a, t]), e;
}
function bhe(e, t, r) {
  const n = this;
  let i;
  return o;
  function o(u) {
    let c = n.events.length, d;
    for (; c--; )
      if (n.events[c][1].type !== "lineEnding" && n.events[c][1].type !== "linePrefix" && n.events[c][1].type !== "content") {
        d = n.events[c][1].type === "paragraph";
        break;
      }
    return !n.parser.lazy[n.now().line] && (n.interrupt || d) ? (e.enter("setextHeadingLine"), i = u, a(u)) : r(u);
  }
  function a(u) {
    return e.enter("setextHeadingLineSequence"), s(u);
  }
  function s(u) {
    return u === i ? (e.consume(u), s) : (e.exit("setextHeadingLineSequence"), pr(u) ? Or(e, l, "lineSuffix")(u) : l(u));
  }
  function l(u) {
    return u === null || Dt(u) ? (e.exit("setextHeadingLine"), t(u)) : r(u);
  }
}
const xhe = {
  tokenize: Ehe
};
function Ehe(e) {
  const t = this, r = e.attempt(
    // Try to parse a blank line.
    vS,
    n,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      i,
      Or(
        e,
        e.attempt(
          this.parser.constructs.flow,
          i,
          e.attempt(Mde, i)
        ),
        "linePrefix"
      )
    )
  );
  return r;
  function n(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(o), e.exit("lineEndingBlank"), t.currentConstruct = void 0, r;
  }
  function i(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), t.currentConstruct = void 0, r;
  }
}
const Rhe = {
  resolveAll: P3()
}, _he = T3("string"), The = T3("text");
function T3(e) {
  return {
    tokenize: t,
    resolveAll: P3(
      e === "text" ? Phe : void 0
    )
  };
  function t(r) {
    const n = this, i = this.parser.constructs[e], o = r.attempt(i, a, s);
    return a;
    function a(c) {
      return u(c) ? o(c) : s(c);
    }
    function s(c) {
      if (c === null) {
        r.consume(c);
        return;
      }
      return r.enter("data"), r.consume(c), l;
    }
    function l(c) {
      return u(c) ? (r.exit("data"), o(c)) : (r.consume(c), l);
    }
    function u(c) {
      if (c === null)
        return !0;
      const d = i[c];
      let h = -1;
      if (d)
        for (; ++h < d.length; ) {
          const f = d[h];
          if (!f.previous || f.previous.call(n, n.previous))
            return !0;
        }
      return !1;
    }
  }
}
function P3(e) {
  return t;
  function t(r, n) {
    let i = -1, o;
    for (; ++i <= r.length; )
      o === void 0 ? r[i] && r[i][1].type === "data" && (o = i, i++) : (!r[i] || r[i][1].type !== "data") && (i !== o + 2 && (r[o][1].end = r[i - 1][1].end, r.splice(o + 2, i - o - 2), i = o + 2), o = void 0);
    return e ? e(r, n) : r;
  }
}
function Phe(e, t) {
  let r = 0;
  for (; ++r <= e.length; )
    if ((r === e.length || e[r][1].type === "lineEnding") && e[r - 1][1].type === "data") {
      const n = e[r - 1][1], i = t.sliceStream(n);
      let o = i.length, a = -1, s = 0, l;
      for (; o--; ) {
        const u = i[o];
        if (typeof u == "string") {
          for (a = u.length; u.charCodeAt(a - 1) === 32; )
            s++, a--;
          if (a) break;
          a = -1;
        } else if (u === -2)
          l = !0, s++;
        else if (u !== -1) {
          o++;
          break;
        }
      }
      if (s) {
        const u = {
          type: r === e.length || l || s < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: n.end.line,
            column: n.end.column - s,
            offset: n.end.offset - s,
            _index: n.start._index + o,
            _bufferIndex: o ? a : n.start._bufferIndex + a
          },
          end: Object.assign({}, n.end)
        };
        n.end = Object.assign({}, u.start), n.start.offset === n.end.offset ? Object.assign(n, u) : (e.splice(
          r,
          0,
          ["enter", u, t],
          ["exit", u, t]
        ), r += 2);
      }
      r++;
    }
  return e;
}
function Mhe(e, t, r) {
  let n = Object.assign(
    r ? Object.assign({}, r) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const i = {}, o = [];
  let a = [], s = [];
  const l = {
    consume: y,
    enter: C,
    exit: S,
    attempt: x(b),
    check: x(w),
    interrupt: x(w, {
      interrupt: !0
    })
  }, u = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: f,
    sliceSerialize: h,
    now: p,
    defineSkip: g,
    write: d
  };
  let c = t.tokenize.call(u, l);
  return t.resolveAll && o.push(t), u;
  function d(P) {
    return a = bo(a, P), v(), a[a.length - 1] !== null ? [] : (E(t, 0), u.events = BP(o, u.events, u), u.events);
  }
  function h(P, D) {
    return Ahe(f(P), D);
  }
  function f(P) {
    return Dhe(a, P);
  }
  function p() {
    const { line: P, column: D, offset: I, _index: A, _bufferIndex: O } = n;
    return {
      line: P,
      column: D,
      offset: I,
      _index: A,
      _bufferIndex: O
    };
  }
  function g(P) {
    i[P.line] = P.column, _();
  }
  function v() {
    let P;
    for (; n._index < a.length; ) {
      const D = a[n._index];
      if (typeof D == "string")
        for (P = n._index, n._bufferIndex < 0 && (n._bufferIndex = 0); n._index === P && n._bufferIndex < D.length; )
          m(D.charCodeAt(n._bufferIndex));
      else
        m(D);
    }
  }
  function m(P) {
    c = c(P);
  }
  function y(P) {
    Dt(P) ? (n.line++, n.column = 1, n.offset += P === -3 ? 2 : 1, _()) : P !== -1 && (n.column++, n.offset++), n._bufferIndex < 0 ? n._index++ : (n._bufferIndex++, n._bufferIndex === a[n._index].length && (n._bufferIndex = -1, n._index++)), u.previous = P;
  }
  function C(P, D) {
    const I = D || {};
    return I.type = P, I.start = p(), u.events.push(["enter", I, u]), s.push(I), I;
  }
  function S(P) {
    const D = s.pop();
    return D.end = p(), u.events.push(["exit", D, u]), D;
  }
  function b(P, D) {
    E(P, D.from);
  }
  function w(P, D) {
    D.restore();
  }
  function x(P, D) {
    return I;
    function I(A, O, L) {
      let N, F, G, M;
      return Array.isArray(A) ? z(A) : "tokenize" in A ? (
        // @ts-expect-error Looks like a construct.
        z([A])
      ) : V(A);
      function V(j) {
        return U;
        function U(Z) {
          const ee = Z !== null && j[Z], J = Z !== null && j.null, X = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ee) ? ee : ee ? [ee] : [],
            ...Array.isArray(J) ? J : J ? [J] : []
          ];
          return z(X)(Z);
        }
      }
      function z(j) {
        return N = j, F = 0, j.length === 0 ? L : k(j[F]);
      }
      function k(j) {
        return U;
        function U(Z) {
          return M = R(), G = j, j.partial || (u.currentConstruct = j), j.name && u.parser.constructs.disable.null.includes(j.name) ? W() : j.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            D ? Object.assign(Object.create(u), D) : u,
            l,
            $,
            W
          )(Z);
        }
      }
      function $(j) {
        return P(G, M), O;
      }
      function W(j) {
        return M.restore(), ++F < N.length ? k(N[F]) : L;
      }
    }
  }
  function E(P, D) {
    P.resolveAll && !o.includes(P) && o.push(P), P.resolve && Gs(
      u.events,
      D,
      u.events.length - D,
      P.resolve(u.events.slice(D), u)
    ), P.resolveTo && (u.events = P.resolveTo(u.events, u));
  }
  function R() {
    const P = p(), D = u.previous, I = u.currentConstruct, A = u.events.length, O = Array.from(s);
    return {
      restore: L,
      from: A
    };
    function L() {
      n = P, u.previous = D, u.currentConstruct = I, u.events.length = A, s = O, _();
    }
  }
  function _() {
    n.line in i && n.column < 2 && (n.column = i[n.line], n.offset += i[n.line] - 1);
  }
}
function Dhe(e, t) {
  const r = t.start._index, n = t.start._bufferIndex, i = t.end._index, o = t.end._bufferIndex;
  let a;
  if (r === i)
    a = [e[r].slice(n, o)];
  else {
    if (a = e.slice(r, i), n > -1) {
      const s = a[0];
      typeof s == "string" ? a[0] = s.slice(n) : a.shift();
    }
    o > 0 && a.push(e[i].slice(0, o));
  }
  return a;
}
function Ahe(e, t) {
  let r = -1;
  const n = [];
  let i;
  for (; ++r < e.length; ) {
    const o = e[r];
    let a;
    if (typeof o == "string")
      a = o;
    else
      switch (o) {
        case -5: {
          a = "\r";
          break;
        }
        case -4: {
          a = `
`;
          break;
        }
        case -3: {
          a = `\r
`;
          break;
        }
        case -2: {
          a = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && i) continue;
          a = " ";
          break;
        }
        default:
          a = String.fromCharCode(o);
      }
    i = o === -2, n.push(a);
  }
  return n.join("");
}
const Ihe = {
  42: Di,
  43: Di,
  45: Di,
  48: Di,
  49: Di,
  50: Di,
  51: Di,
  52: Di,
  53: Di,
  54: Di,
  55: Di,
  56: Di,
  57: Di,
  62: S3
}, Fhe = {
  91: Lde
}, Lhe = {
  [-2]: sb,
  [-1]: sb,
  32: sb
}, Ohe = {
  35: Gde,
  42: Yy,
  45: [YF, Yy],
  60: Wde,
  61: YF,
  95: Yy,
  96: UF,
  126: UF
}, Nhe = {
  38: b3,
  92: w3
}, khe = {
  [-5]: lb,
  [-4]: lb,
  [-3]: lb,
  33: lhe,
  38: b3,
  42: SR,
  60: [cde, Xde],
  91: che,
  92: [Vde, w3],
  93: GP,
  95: SR,
  96: xde
}, Vhe = {
  null: [SR, Rhe]
}, Bhe = {
  null: [42, 95]
}, Ghe = {
  null: []
}, Hhe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: Bhe,
  contentInitial: Fhe,
  disable: Ghe,
  document: Ihe,
  flow: Ohe,
  flowInitial: Lhe,
  insideSpan: Vhe,
  string: Nhe,
  text: khe
}, Symbol.toStringTag, { value: "Module" }));
function zhe(e) {
  const r = (
    /** @type {FullNormalizedExtension} */
    qce([Hhe, ...(e || {}).extensions || []])
  ), n = {
    defined: [],
    lazy: {},
    constructs: r,
    content: i(nde),
    document: i(ode),
    flow: i(xhe),
    string: i(_he),
    text: i(The)
  };
  return n;
  function i(o) {
    return a;
    function a(s) {
      return Mhe(n, o, s);
    }
  }
}
function $he(e) {
  for (; !x3(e); )
    ;
  return e;
}
const qF = /[\0\t\n\r]/g;
function Whe() {
  let e = 1, t = "", r = !0, n;
  return i;
  function i(o, a, s) {
    const l = [];
    let u, c, d, h, f;
    for (o = t + (typeof o == "string" ? o.toString() : new TextDecoder(a || void 0).decode(o)), d = 0, t = "", r && (o.charCodeAt(0) === 65279 && d++, r = void 0); d < o.length; ) {
      if (qF.lastIndex = d, u = qF.exec(o), h = u && u.index !== void 0 ? u.index : o.length, f = o.charCodeAt(h), !u) {
        t = o.slice(d);
        break;
      }
      if (f === 10 && d === h && n)
        l.push(-3), n = void 0;
      else
        switch (n && (l.push(-5), n = void 0), d < h && (l.push(o.slice(d, h)), e += h - d), f) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (c = Math.ceil(e / 4) * 4, l.push(-2); e++ < c; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            n = !0, e = 1;
        }
      d = h + 1;
    }
    return s && (n && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const jhe = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Uhe(e) {
  return e.replace(jhe, Khe);
}
function Khe(e, t, r) {
  if (t)
    return t;
  if (r.charCodeAt(0) === 35) {
    const i = r.charCodeAt(1), o = i === 120 || i === 88;
    return C3(r.slice(o ? 2 : 1), o ? 16 : 10);
  }
  return VP(r) || e;
}
const M3 = {}.hasOwnProperty;
function Yhe(e, t, r) {
  return typeof t != "string" && (r = t, t = void 0), qhe(r)($he(zhe(r).document().write(Whe()(e, t, !0))));
}
function qhe(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: o(we),
      autolinkProtocol: R,
      autolinkEmail: R,
      atxHeading: o(ie),
      blockQuote: o(J),
      characterEscape: R,
      characterReference: R,
      codeFenced: o(X),
      codeFencedFenceInfo: a,
      codeFencedFenceMeta: a,
      codeIndented: o(X, a),
      codeText: o(Y, a),
      codeTextData: R,
      data: R,
      codeFlowValue: R,
      definition: o(de),
      definitionDestinationString: a,
      definitionLabelString: a,
      definitionTitleString: a,
      emphasis: o(K),
      hardBreakEscape: o(Ce),
      hardBreakTrailing: o(Ce),
      htmlFlow: o(Te, a),
      htmlFlowData: R,
      htmlText: o(Te, a),
      htmlTextData: R,
      image: o(Ie),
      label: a,
      link: o(we),
      listItem: o(_e),
      listItemValue: h,
      listOrdered: o(Re, d),
      listUnordered: o(Re),
      paragraph: o(He),
      reference: k,
      referenceString: a,
      resourceDestinationString: a,
      resourceTitleString: a,
      setextHeading: o(ie),
      strong: o(Ve),
      thematicBreak: o(Je)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: b,
      autolink: l(),
      autolinkEmail: ee,
      autolinkProtocol: Z,
      blockQuote: l(),
      characterEscapeValue: _,
      characterReferenceMarkerHexadecimal: W,
      characterReferenceMarkerNumeric: W,
      characterReferenceValue: j,
      characterReference: U,
      codeFenced: l(v),
      codeFencedFence: g,
      codeFencedFenceInfo: f,
      codeFencedFenceMeta: p,
      codeFlowValue: _,
      codeIndented: l(m),
      codeText: l(O),
      codeTextData: _,
      data: _,
      definition: l(),
      definitionDestinationString: S,
      definitionLabelString: y,
      definitionTitleString: C,
      emphasis: l(),
      hardBreakEscape: l(D),
      hardBreakTrailing: l(D),
      htmlFlow: l(I),
      htmlFlowData: _,
      htmlText: l(A),
      htmlTextData: _,
      image: l(N),
      label: G,
      labelText: F,
      lineEnding: P,
      link: l(L),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: $,
      resourceDestinationString: M,
      resourceTitleString: V,
      resource: z,
      setextHeading: l(E),
      setextHeadingLineSequence: x,
      setextHeadingText: w,
      strong: l(),
      thematicBreak: l()
    }
  };
  D3(t, (e || {}).mdastExtensions || []);
  const r = {};
  return n;
  function n(Q) {
    let ye = {
      type: "root",
      children: []
    };
    const Ge = {
      stack: [ye],
      tokenStack: [],
      config: t,
      enter: s,
      exit: u,
      buffer: a,
      resume: c,
      data: r
    }, Pe = [];
    let Le = -1;
    for (; ++Le < Q.length; )
      if (Q[Le][1].type === "listOrdered" || Q[Le][1].type === "listUnordered")
        if (Q[Le][0] === "enter")
          Pe.push(Le);
        else {
          const me = Pe.pop();
          Le = i(Q, me, Le);
        }
    for (Le = -1; ++Le < Q.length; ) {
      const me = t[Q[Le][0]];
      M3.call(me, Q[Le][1].type) && me[Q[Le][1].type].call(Object.assign({
        sliceSerialize: Q[Le][2].sliceSerialize
      }, Ge), Q[Le][1]);
    }
    if (Ge.tokenStack.length > 0) {
      const me = Ge.tokenStack[Ge.tokenStack.length - 1];
      (me[1] || ZF).call(Ge, void 0, me[0]);
    }
    for (ye.position = {
      start: sl(Q.length > 0 ? Q[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: sl(Q.length > 0 ? Q[Q.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, Le = -1; ++Le < t.transforms.length; )
      ye = t.transforms[Le](ye) || ye;
    return ye;
  }
  function i(Q, ye, Ge) {
    let Pe = ye - 1, Le = -1, me = !1, De, qe, ht, Tt;
    for (; ++Pe <= Ge; ) {
      const lt = Q[Pe];
      switch (lt[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          lt[0] === "enter" ? Le++ : Le--, Tt = void 0;
          break;
        }
        case "lineEndingBlank": {
          lt[0] === "enter" && (De && !Tt && !Le && !ht && (ht = Pe), Tt = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Tt = void 0;
      }
      if (!Le && lt[0] === "enter" && lt[1].type === "listItemPrefix" || Le === -1 && lt[0] === "exit" && (lt[1].type === "listUnordered" || lt[1].type === "listOrdered")) {
        if (De) {
          let tt = Pe;
          for (qe = void 0; tt--; ) {
            const Oe = Q[tt];
            if (Oe[1].type === "lineEnding" || Oe[1].type === "lineEndingBlank") {
              if (Oe[0] === "exit") continue;
              qe && (Q[qe][1].type = "lineEndingBlank", me = !0), Oe[1].type = "lineEnding", qe = tt;
            } else if (!(Oe[1].type === "linePrefix" || Oe[1].type === "blockQuotePrefix" || Oe[1].type === "blockQuotePrefixWhitespace" || Oe[1].type === "blockQuoteMarker" || Oe[1].type === "listItemIndent")) break;
          }
          ht && (!qe || ht < qe) && (De._spread = !0), De.end = Object.assign({}, qe ? Q[qe][1].start : lt[1].end), Q.splice(qe || Pe, 0, ["exit", De, lt[2]]), Pe++, Ge++;
        }
        if (lt[1].type === "listItemPrefix") {
          const tt = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, lt[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          De = tt, Q.splice(Pe, 0, ["enter", tt, lt[2]]), Pe++, Ge++, ht = void 0, Tt = !0;
        }
      }
    }
    return Q[ye][1]._spread = me, Ge;
  }
  function o(Q, ye) {
    return Ge;
    function Ge(Pe) {
      s.call(this, Q(Pe), Pe), ye && ye.call(this, Pe);
    }
  }
  function a() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function s(Q, ye, Ge) {
    this.stack[this.stack.length - 1].children.push(Q), this.stack.push(Q), this.tokenStack.push([ye, Ge]), Q.position = {
      start: sl(ye.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(Q) {
    return ye;
    function ye(Ge) {
      Q && Q.call(this, Ge), u.call(this, Ge);
    }
  }
  function u(Q, ye) {
    const Ge = this.stack.pop(), Pe = this.tokenStack.pop();
    if (Pe)
      Pe[0].type !== Q.type && (ye ? ye.call(this, Q, Pe[0]) : (Pe[1] || ZF).call(this, Q, Pe[0]));
    else throw new Error("Cannot close `" + Q.type + "` (" + Wp({
      start: Q.start,
      end: Q.end
    }) + "): it’s not open");
    Ge.position.end = sl(Q.end);
  }
  function c() {
    return Kce(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function h(Q) {
    if (this.data.expectingFirstListItemValue) {
      const ye = this.stack[this.stack.length - 2];
      ye.start = Number.parseInt(this.sliceSerialize(Q), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function f() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.lang = Q;
  }
  function p() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.meta = Q;
  }
  function g() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function v() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = Q.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function m() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = Q.replace(/(\r?\n|\r)$/g, "");
  }
  function y(Q) {
    const ye = this.resume(), Ge = this.stack[this.stack.length - 1];
    Ge.label = ye, Ge.identifier = dh(this.sliceSerialize(Q)).toLowerCase();
  }
  function C() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.title = Q;
  }
  function S() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.url = Q;
  }
  function b(Q) {
    const ye = this.stack[this.stack.length - 1];
    if (!ye.depth) {
      const Ge = this.sliceSerialize(Q).length;
      ye.depth = Ge;
    }
  }
  function w() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function x(Q) {
    const ye = this.stack[this.stack.length - 1];
    ye.depth = this.sliceSerialize(Q).codePointAt(0) === 61 ? 1 : 2;
  }
  function E() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function R(Q) {
    const Ge = this.stack[this.stack.length - 1].children;
    let Pe = Ge[Ge.length - 1];
    (!Pe || Pe.type !== "text") && (Pe = $e(), Pe.position = {
      start: sl(Q.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, Ge.push(Pe)), this.stack.push(Pe);
  }
  function _(Q) {
    const ye = this.stack.pop();
    ye.value += this.sliceSerialize(Q), ye.position.end = sl(Q.end);
  }
  function P(Q) {
    const ye = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const Ge = ye.children[ye.children.length - 1];
      Ge.position.end = sl(Q.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(ye.type) && (R.call(this, Q), _.call(this, Q));
  }
  function D() {
    this.data.atHardBreak = !0;
  }
  function I() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = Q;
  }
  function A() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = Q;
  }
  function O() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.value = Q;
  }
  function L() {
    const Q = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ye = this.data.referenceType || "shortcut";
      Q.type += "Reference", Q.referenceType = ye, delete Q.url, delete Q.title;
    } else
      delete Q.identifier, delete Q.label;
    this.data.referenceType = void 0;
  }
  function N() {
    const Q = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const ye = this.data.referenceType || "shortcut";
      Q.type += "Reference", Q.referenceType = ye, delete Q.url, delete Q.title;
    } else
      delete Q.identifier, delete Q.label;
    this.data.referenceType = void 0;
  }
  function F(Q) {
    const ye = this.sliceSerialize(Q), Ge = this.stack[this.stack.length - 2];
    Ge.label = Uhe(ye), Ge.identifier = dh(ye).toLowerCase();
  }
  function G() {
    const Q = this.stack[this.stack.length - 1], ye = this.resume(), Ge = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, Ge.type === "link") {
      const Pe = Q.children;
      Ge.children = Pe;
    } else
      Ge.alt = ye;
  }
  function M() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.url = Q;
  }
  function V() {
    const Q = this.resume(), ye = this.stack[this.stack.length - 1];
    ye.title = Q;
  }
  function z() {
    this.data.inReference = void 0;
  }
  function k() {
    this.data.referenceType = "collapsed";
  }
  function $(Q) {
    const ye = this.resume(), Ge = this.stack[this.stack.length - 1];
    Ge.label = ye, Ge.identifier = dh(this.sliceSerialize(Q)).toLowerCase(), this.data.referenceType = "full";
  }
  function W(Q) {
    this.data.characterReferenceType = Q.type;
  }
  function j(Q) {
    const ye = this.sliceSerialize(Q), Ge = this.data.characterReferenceType;
    let Pe;
    Ge ? (Pe = C3(ye, Ge === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Pe = VP(ye);
    const Le = this.stack[this.stack.length - 1];
    Le.value += Pe;
  }
  function U(Q) {
    const ye = this.stack.pop();
    ye.position.end = sl(Q.end);
  }
  function Z(Q) {
    _.call(this, Q);
    const ye = this.stack[this.stack.length - 1];
    ye.url = this.sliceSerialize(Q);
  }
  function ee(Q) {
    _.call(this, Q);
    const ye = this.stack[this.stack.length - 1];
    ye.url = "mailto:" + this.sliceSerialize(Q);
  }
  function J() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function X() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Y() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function de() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function K() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function ie() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Ce() {
    return {
      type: "break"
    };
  }
  function Te() {
    return {
      type: "html",
      value: ""
    };
  }
  function Ie() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function we() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Re(Q) {
    return {
      type: "list",
      ordered: Q.type === "listOrdered",
      start: null,
      spread: Q._spread,
      children: []
    };
  }
  function _e(Q) {
    return {
      type: "listItem",
      spread: Q._spread,
      checked: null,
      children: []
    };
  }
  function He() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Ve() {
    return {
      type: "strong",
      children: []
    };
  }
  function $e() {
    return {
      type: "text",
      value: ""
    };
  }
  function Je() {
    return {
      type: "thematicBreak"
    };
  }
}
function sl(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function D3(e, t) {
  let r = -1;
  for (; ++r < t.length; ) {
    const n = t[r];
    Array.isArray(n) ? D3(e, n) : Zhe(e, n);
  }
}
function Zhe(e, t) {
  let r;
  for (r in t)
    if (M3.call(t, r))
      switch (r) {
        case "canContainEols": {
          const n = t[r];
          n && e[r].push(...n);
          break;
        }
        case "transforms": {
          const n = t[r];
          n && e[r].push(...n);
          break;
        }
        case "enter":
        case "exit": {
          const n = t[r];
          n && Object.assign(e[r], n);
          break;
        }
      }
}
function ZF(e, t) {
  throw e ? new Error("Cannot close `" + e.type + "` (" + Wp({
    start: e.start,
    end: e.end
  }) + "): a different token (`" + t.type + "`, " + Wp({
    start: t.start,
    end: t.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + Wp({
    start: t.start,
    end: t.end
  }) + ") is still open");
}
function Xhe(e) {
  const t = this;
  t.parser = r;
  function r(n) {
    return Yhe(n, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Qhe(e, t) {
  const r = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Jhe(e, t) {
  const r = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, r), [e.applyData(t, r), { type: "text", value: `
` }];
}
function efe(e, t) {
  const r = t.value ? t.value + `
` : "", n = {};
  t.lang && (n.className = ["language-" + t.lang]);
  let i = {
    type: "element",
    tagName: "code",
    properties: n,
    children: [{ type: "text", value: r }]
  };
  return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i;
}
function tfe(e, t) {
  const r = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function rfe(e, t) {
  const r = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function nfe(e, t) {
  const r = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = String(t.identifier).toUpperCase(), i = tf(n.toLowerCase()), o = e.footnoteOrder.indexOf(n);
  let a, s = e.footnoteCounts.get(n);
  s === void 0 ? (s = 0, e.footnoteOrder.push(n), a = e.footnoteOrder.length) : a = o + 1, s += 1, e.footnoteCounts.set(n, s);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + r + "fn-" + i,
      id: r + "fnref-" + i + (s > 1 ? "-" + s : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(a) }]
  };
  e.patch(t, l);
  const u = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, u), e.applyData(t, u);
}
function ife(e, t) {
  const r = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function ofe(e, t) {
  if (e.options.allowDangerousHtml) {
    const r = { type: "raw", value: t.value };
    return e.patch(t, r), e.applyData(t, r);
  }
}
function A3(e, t) {
  const r = t.referenceType;
  let n = "]";
  if (r === "collapsed" ? n += "[]" : r === "full" && (n += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + n }];
  const i = e.all(t), o = i[0];
  o && o.type === "text" ? o.value = "[" + o.value : i.unshift({ type: "text", value: "[" });
  const a = i[i.length - 1];
  return a && a.type === "text" ? a.value += n : i.push({ type: "text", value: n }), i;
}
function afe(e, t) {
  const r = String(t.identifier).toUpperCase(), n = e.definitionById.get(r);
  if (!n)
    return A3(e, t);
  const i = { src: tf(n.url || ""), alt: t.alt };
  n.title !== null && n.title !== void 0 && (i.title = n.title);
  const o = { type: "element", tagName: "img", properties: i, children: [] };
  return e.patch(t, o), e.applyData(t, o);
}
function sfe(e, t) {
  const r = { src: tf(t.url) };
  t.alt !== null && t.alt !== void 0 && (r.alt = t.alt), t.title !== null && t.title !== void 0 && (r.title = t.title);
  const n = { type: "element", tagName: "img", properties: r, children: [] };
  return e.patch(t, n), e.applyData(t, n);
}
function lfe(e, t) {
  const r = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, r);
  const n = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [r]
  };
  return e.patch(t, n), e.applyData(t, n);
}
function ufe(e, t) {
  const r = String(t.identifier).toUpperCase(), n = e.definitionById.get(r);
  if (!n)
    return A3(e, t);
  const i = { href: tf(n.url || "") };
  n.title !== null && n.title !== void 0 && (i.title = n.title);
  const o = {
    type: "element",
    tagName: "a",
    properties: i,
    children: e.all(t)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function cfe(e, t) {
  const r = { href: tf(t.url) };
  t.title !== null && t.title !== void 0 && (r.title = t.title);
  const n = {
    type: "element",
    tagName: "a",
    properties: r,
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function dfe(e, t, r) {
  const n = e.all(t), i = r ? hfe(r) : I3(t), o = {}, a = [];
  if (typeof t.checked == "boolean") {
    const c = n[0];
    let d;
    c && c.type === "element" && c.tagName === "p" ? d = c : (d = { type: "element", tagName: "p", properties: {}, children: [] }, n.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), o.className = ["task-list-item"];
  }
  let s = -1;
  for (; ++s < n.length; ) {
    const c = n[s];
    (i || s !== 0 || c.type !== "element" || c.tagName !== "p") && a.push({ type: "text", value: `
` }), c.type === "element" && c.tagName === "p" && !i ? a.push(...c.children) : a.push(c);
  }
  const l = n[n.length - 1];
  l && (i || l.type !== "element" || l.tagName !== "p") && a.push({ type: "text", value: `
` });
  const u = { type: "element", tagName: "li", properties: o, children: a };
  return e.patch(t, u), e.applyData(t, u);
}
function hfe(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const r = e.children;
    let n = -1;
    for (; !t && ++n < r.length; )
      t = I3(r[n]);
  }
  return t;
}
function I3(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function ffe(e, t) {
  const r = {}, n = e.all(t);
  let i = -1;
  for (typeof t.start == "number" && t.start !== 1 && (r.start = t.start); ++i < n.length; ) {
    const a = n[i];
    if (a.type === "element" && a.tagName === "li" && a.properties && Array.isArray(a.properties.className) && a.properties.className.includes("task-list-item")) {
      r.className = ["contains-task-list"];
      break;
    }
  }
  const o = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: r,
    children: e.wrap(n, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function pfe(e, t) {
  const r = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function gfe(e, t) {
  const r = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, r), e.applyData(t, r);
}
function vfe(e, t) {
  const r = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function mfe(e, t) {
  const r = e.all(t), n = r.shift(), i = [];
  if (n) {
    const a = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([n], !0)
    };
    e.patch(t.children[0], a), i.push(a);
  }
  if (r.length > 0) {
    const a = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(r, !0)
    }, s = LP(t.children[1]), l = h3(t.children[t.children.length - 1]);
    s && l && (a.position = { start: s, end: l }), i.push(a);
  }
  const o = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(i, !0)
  };
  return e.patch(t, o), e.applyData(t, o);
}
function yfe(e, t, r) {
  const n = r ? r.children : void 0, o = (n ? n.indexOf(t) : 1) === 0 ? "th" : "td", a = r && r.type === "table" ? r.align : void 0, s = a ? a.length : t.children.length;
  let l = -1;
  const u = [];
  for (; ++l < s; ) {
    const d = t.children[l], h = {}, f = a ? a[l] : void 0;
    f && (h.align = f);
    let p = { type: "element", tagName: o, properties: h, children: [] };
    d && (p.children = e.all(d), e.patch(d, p), p = e.applyData(d, p)), u.push(p);
  }
  const c = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(u, !0)
  };
  return e.patch(t, c), e.applyData(t, c);
}
function Cfe(e, t) {
  const r = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
const XF = 9, QF = 32;
function Sfe(e) {
  const t = String(e), r = /\r?\n|\r/g;
  let n = r.exec(t), i = 0;
  const o = [];
  for (; n; )
    o.push(
      JF(t.slice(i, n.index), i > 0, !0),
      n[0]
    ), i = n.index + n[0].length, n = r.exec(t);
  return o.push(JF(t.slice(i), i > 0, !1)), o.join("");
}
function JF(e, t, r) {
  let n = 0, i = e.length;
  if (t) {
    let o = e.codePointAt(n);
    for (; o === XF || o === QF; )
      n++, o = e.codePointAt(n);
  }
  if (r) {
    let o = e.codePointAt(i - 1);
    for (; o === XF || o === QF; )
      i--, o = e.codePointAt(i - 1);
  }
  return i > n ? e.slice(n, i) : "";
}
function wfe(e, t) {
  const r = { type: "text", value: Sfe(String(t.value)) };
  return e.patch(t, r), e.applyData(t, r);
}
function bfe(e, t) {
  const r = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, r), e.applyData(t, r);
}
const xfe = {
  blockquote: Qhe,
  break: Jhe,
  code: efe,
  delete: tfe,
  emphasis: rfe,
  footnoteReference: nfe,
  heading: ife,
  html: ofe,
  imageReference: afe,
  image: sfe,
  inlineCode: lfe,
  linkReference: ufe,
  link: cfe,
  listItem: dfe,
  list: ffe,
  paragraph: pfe,
  // @ts-expect-error: root is different, but hard to type.
  root: gfe,
  strong: vfe,
  table: mfe,
  tableCell: Cfe,
  tableRow: yfe,
  text: wfe,
  thematicBreak: bfe,
  toml: Sm,
  yaml: Sm,
  definition: Sm,
  footnoteDefinition: Sm
};
function Sm() {
}
const F3 = -1, mS = 0, L0 = 1, O0 = 2, HP = 3, zP = 4, $P = 5, WP = 6, L3 = 7, O3 = 8, eL = typeof self == "object" ? self : globalThis, Efe = (e, t) => {
  const r = (i, o) => (e.set(o, i), i), n = (i) => {
    if (e.has(i))
      return e.get(i);
    const [o, a] = t[i];
    switch (o) {
      case mS:
      case F3:
        return r(a, i);
      case L0: {
        const s = r([], i);
        for (const l of a)
          s.push(n(l));
        return s;
      }
      case O0: {
        const s = r({}, i);
        for (const [l, u] of a)
          s[n(l)] = n(u);
        return s;
      }
      case HP:
        return r(new Date(a), i);
      case zP: {
        const { source: s, flags: l } = a;
        return r(new RegExp(s, l), i);
      }
      case $P: {
        const s = r(/* @__PURE__ */ new Map(), i);
        for (const [l, u] of a)
          s.set(n(l), n(u));
        return s;
      }
      case WP: {
        const s = r(/* @__PURE__ */ new Set(), i);
        for (const l of a)
          s.add(n(l));
        return s;
      }
      case L3: {
        const { name: s, message: l } = a;
        return r(new eL[s](l), i);
      }
      case O3:
        return r(BigInt(a), i);
      case "BigInt":
        return r(Object(BigInt(a)), i);
    }
    return r(new eL[o](a), i);
  };
  return n;
}, tL = (e) => Efe(/* @__PURE__ */ new Map(), e)(0), vd = "", { toString: Rfe } = {}, { keys: _fe } = Object, zf = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [mS, t];
  const r = Rfe.call(e).slice(8, -1);
  switch (r) {
    case "Array":
      return [L0, vd];
    case "Object":
      return [O0, vd];
    case "Date":
      return [HP, vd];
    case "RegExp":
      return [zP, vd];
    case "Map":
      return [$P, vd];
    case "Set":
      return [WP, vd];
  }
  return r.includes("Array") ? [L0, r] : r.includes("Error") ? [L3, r] : [O0, r];
}, wm = ([e, t]) => e === mS && (t === "function" || t === "symbol"), Tfe = (e, t, r, n) => {
  const i = (a, s) => {
    const l = n.push(a) - 1;
    return r.set(s, l), l;
  }, o = (a) => {
    if (r.has(a))
      return r.get(a);
    let [s, l] = zf(a);
    switch (s) {
      case mS: {
        let c = a;
        switch (l) {
          case "bigint":
            s = O3, c = a.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            c = null;
            break;
          case "undefined":
            return i([F3], a);
        }
        return i([s, c], a);
      }
      case L0: {
        if (l)
          return i([l, [...a]], a);
        const c = [], d = i([s, c], a);
        for (const h of a)
          c.push(o(h));
        return d;
      }
      case O0: {
        if (l)
          switch (l) {
            case "BigInt":
              return i([l, a.toString()], a);
            case "Boolean":
            case "Number":
            case "String":
              return i([l, a.valueOf()], a);
          }
        if (t && "toJSON" in a)
          return o(a.toJSON());
        const c = [], d = i([s, c], a);
        for (const h of _fe(a))
          (e || !wm(zf(a[h]))) && c.push([o(h), o(a[h])]);
        return d;
      }
      case HP:
        return i([s, a.toISOString()], a);
      case zP: {
        const { source: c, flags: d } = a;
        return i([s, { source: c, flags: d }], a);
      }
      case $P: {
        const c = [], d = i([s, c], a);
        for (const [h, f] of a)
          (e || !(wm(zf(h)) || wm(zf(f)))) && c.push([o(h), o(f)]);
        return d;
      }
      case WP: {
        const c = [], d = i([s, c], a);
        for (const h of a)
          (e || !wm(zf(h))) && c.push(o(h));
        return d;
      }
    }
    const { message: u } = a;
    return i([s, { name: l, message: u }], a);
  };
  return o;
}, rL = (e, { json: t, lossy: r } = {}) => {
  const n = [];
  return Tfe(!(t || r), !!t, /* @__PURE__ */ new Map(), n)(e), n;
}, N0 = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? tL(rL(e, t)) : structuredClone(e)
) : (e, t) => tL(rL(e, t));
function Pfe(e, t) {
  const r = [{ type: "text", value: "↩" }];
  return t > 1 && r.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), r;
}
function Mfe(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function Dfe(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = e.options.footnoteBackContent || Pfe, n = e.options.footnoteBackLabel || Mfe, i = e.options.footnoteLabel || "Footnotes", o = e.options.footnoteLabelTagName || "h2", a = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, s = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const u = e.footnoteById.get(
      e.footnoteOrder[l]
    );
    if (!u)
      continue;
    const c = e.all(u), d = String(u.identifier).toUpperCase(), h = tf(d.toLowerCase());
    let f = 0;
    const p = [], g = e.footnoteCounts.get(d);
    for (; g !== void 0 && ++f <= g; ) {
      p.length > 0 && p.push({ type: "text", value: " " });
      let y = typeof r == "string" ? r : r(l, f);
      typeof y == "string" && (y = { type: "text", value: y }), p.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + h + (f > 1 ? "-" + f : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof n == "string" ? n : n(l, f),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(y) ? y : [y]
      });
    }
    const v = c[c.length - 1];
    if (v && v.type === "element" && v.tagName === "p") {
      const y = v.children[v.children.length - 1];
      y && y.type === "text" ? y.value += " " : v.children.push({ type: "text", value: " " }), v.children.push(...p);
    } else
      c.push(...p);
    const m = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + h },
      children: e.wrap(c, !0)
    };
    e.patch(u, m), s.push(m);
  }
  if (s.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: o,
          properties: {
            ...N0(a),
            id: "footnote-label"
          },
          children: [{ type: "text", value: i }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(s, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const N3 = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return Lfe;
    if (typeof e == "function")
      return yS(e);
    if (typeof e == "object")
      return Array.isArray(e) ? Afe(e) : Ife(e);
    if (typeof e == "string")
      return Ffe(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function Afe(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = N3(e[r]);
  return yS(n);
  function n(...i) {
    let o = -1;
    for (; ++o < t.length; )
      if (t[o].apply(this, i)) return !0;
    return !1;
  }
}
function Ife(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return yS(r);
  function r(n) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      n
    );
    let o;
    for (o in e)
      if (i[o] !== t[o]) return !1;
    return !0;
  }
}
function Ffe(e) {
  return yS(t);
  function t(r) {
    return r && r.type === e;
  }
}
function yS(e) {
  return t;
  function t(r, n, i) {
    return !!(Ofe(r) && e.call(
      this,
      r,
      typeof n == "number" ? n : void 0,
      i || void 0
    ));
  }
}
function Lfe() {
  return !0;
}
function Ofe(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const k3 = [], Nfe = !0, nL = !1, kfe = "skip";
function Vfe(e, t, r, n) {
  let i;
  typeof t == "function" && typeof r != "function" ? (n = r, r = t) : i = t;
  const o = N3(i), a = n ? -1 : 1;
  s(e, void 0, [])();
  function s(l, u, c) {
    const d = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof d.type == "string") {
      const f = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(h, "name", {
        value: "node (" + (l.type + (f ? "<" + f + ">" : "")) + ")"
      });
    }
    return h;
    function h() {
      let f = k3, p, g, v;
      if ((!t || o(l, u, c[c.length - 1] || void 0)) && (f = Bfe(r(l, c)), f[0] === nL))
        return f;
      if ("children" in l && l.children) {
        const m = (
          /** @type {UnistParent} */
          l
        );
        if (m.children && f[0] !== kfe)
          for (g = (n ? m.children.length : -1) + a, v = c.concat(m); g > -1 && g < m.children.length; ) {
            const y = m.children[g];
            if (p = s(y, g, v)(), p[0] === nL)
              return p;
            g = typeof p[1] == "number" ? p[1] : g + a;
          }
      }
      return f;
    }
  }
}
function Bfe(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [Nfe, e] : e == null ? k3 : [e];
}
function V3(e, t, r, n) {
  let i, o, a;
  typeof t == "function" && typeof r != "function" ? (o = void 0, a = t, i = r) : (o = t, a = r, i = n), Vfe(e, o, s, i);
  function s(l, u) {
    const c = u[u.length - 1], d = c ? c.children.indexOf(l) : void 0;
    return a(l, d, c);
  }
}
const wR = {}.hasOwnProperty, Gfe = {};
function Hfe(e, t) {
  const r = t || Gfe, n = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), a = { ...xfe, ...r.handlers }, s = {
    all: u,
    applyData: $fe,
    definitionById: n,
    footnoteById: i,
    footnoteCounts: o,
    footnoteOrder: [],
    handlers: a,
    one: l,
    options: r,
    patch: zfe,
    wrap: jfe
  };
  return V3(e, function(c) {
    if (c.type === "definition" || c.type === "footnoteDefinition") {
      const d = c.type === "definition" ? n : i, h = String(c.identifier).toUpperCase();
      d.has(h) || d.set(h, c);
    }
  }), s;
  function l(c, d) {
    const h = c.type, f = s.handlers[h];
    if (wR.call(s.handlers, h) && f)
      return f(s, c, d);
    if (s.options.passThrough && s.options.passThrough.includes(h)) {
      if ("children" in c) {
        const { children: g, ...v } = c, m = N0(v);
        return m.children = s.all(c), m;
      }
      return N0(c);
    }
    return (s.options.unknownHandler || Wfe)(s, c, d);
  }
  function u(c) {
    const d = [];
    if ("children" in c) {
      const h = c.children;
      let f = -1;
      for (; ++f < h.length; ) {
        const p = s.one(h[f], c);
        if (p) {
          if (f && h[f - 1].type === "break" && (!Array.isArray(p) && p.type === "text" && (p.value = iL(p.value)), !Array.isArray(p) && p.type === "element")) {
            const g = p.children[0];
            g && g.type === "text" && (g.value = iL(g.value));
          }
          Array.isArray(p) ? d.push(...p) : d.push(p);
        }
      }
    }
    return d;
  }
}
function zfe(e, t) {
  e.position && (t.position = xce(e));
}
function $fe(e, t) {
  let r = t;
  if (e && e.data) {
    const n = e.data.hName, i = e.data.hChildren, o = e.data.hProperties;
    if (typeof n == "string")
      if (r.type === "element")
        r.tagName = n;
      else {
        const a = "children" in r ? r.children : [r];
        r = { type: "element", tagName: n, properties: {}, children: a };
      }
    r.type === "element" && o && Object.assign(r.properties, N0(o)), "children" in r && r.children && i !== null && i !== void 0 && (r.children = i);
  }
  return r;
}
function Wfe(e, t) {
  const r = t.data || {}, n = "value" in t && !(wR.call(r, "hProperties") || wR.call(r, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function jfe(e, t) {
  const r = [];
  let n = -1;
  for (t && r.push({ type: "text", value: `
` }); ++n < e.length; )
    n && r.push({ type: "text", value: `
` }), r.push(e[n]);
  return t && e.length > 0 && r.push({ type: "text", value: `
` }), r;
}
function iL(e) {
  let t = 0, r = e.charCodeAt(t);
  for (; r === 9 || r === 32; )
    t++, r = e.charCodeAt(t);
  return e.slice(t);
}
function oL(e, t) {
  const r = Hfe(e, t), n = r.one(e, void 0), i = Dfe(r), o = Array.isArray(n) ? { type: "root", children: n } : n || { type: "root", children: [] };
  return i && o.children.push({ type: "text", value: `
` }, i), o;
}
function Ufe(e, t) {
  return e && "run" in e ? async function(r, n) {
    const i = (
      /** @type {HastRoot} */
      oL(r, { file: n, ...t })
    );
    await e.run(i, n);
  } : function(r, n) {
    return (
      /** @type {HastRoot} */
      oL(r, { file: n, ...t || e })
    );
  };
}
function aL(e) {
  if (e)
    throw e;
}
var qy = Object.prototype.hasOwnProperty, B3 = Object.prototype.toString, sL = Object.defineProperty, lL = Object.getOwnPropertyDescriptor, uL = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : B3.call(t) === "[object Array]";
}, cL = function(t) {
  if (!t || B3.call(t) !== "[object Object]")
    return !1;
  var r = qy.call(t, "constructor"), n = t.constructor && t.constructor.prototype && qy.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !r && !n)
    return !1;
  var i;
  for (i in t)
    ;
  return typeof i > "u" || qy.call(t, i);
}, dL = function(t, r) {
  sL && r.name === "__proto__" ? sL(t, r.name, {
    enumerable: !0,
    configurable: !0,
    value: r.newValue,
    writable: !0
  }) : t[r.name] = r.newValue;
}, hL = function(t, r) {
  if (r === "__proto__")
    if (qy.call(t, r)) {
      if (lL)
        return lL(t, r).value;
    } else return;
  return t[r];
}, Kfe = function e() {
  var t, r, n, i, o, a, s = arguments[0], l = 1, u = arguments.length, c = !1;
  for (typeof s == "boolean" && (c = s, s = arguments[1] || {}, l = 2), (s == null || typeof s != "object" && typeof s != "function") && (s = {}); l < u; ++l)
    if (t = arguments[l], t != null)
      for (r in t)
        n = hL(s, r), i = hL(t, r), s !== i && (c && i && (cL(i) || (o = uL(i))) ? (o ? (o = !1, a = n && uL(n) ? n : []) : a = n && cL(n) ? n : {}, dL(s, { name: r, newValue: e(c, a, i) })) : typeof i < "u" && dL(s, { name: r, newValue: i }));
  return s;
};
const ub = /* @__PURE__ */ Uh(Kfe);
function bR(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function Yfe() {
  const e = [], t = { run: r, use: n };
  return t;
  function r(...i) {
    let o = -1;
    const a = i.pop();
    if (typeof a != "function")
      throw new TypeError("Expected function as last argument, not " + a);
    s(null, ...i);
    function s(l, ...u) {
      const c = e[++o];
      let d = -1;
      if (l) {
        a(l);
        return;
      }
      for (; ++d < i.length; )
        (u[d] === null || u[d] === void 0) && (u[d] = i[d]);
      i = u, c ? qfe(c, s)(...u) : a(null, ...u);
    }
  }
  function n(i) {
    if (typeof i != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + i
      );
    return e.push(i), t;
  }
}
function qfe(e, t) {
  let r;
  return n;
  function n(...a) {
    const s = e.length > a.length;
    let l;
    s && a.push(i);
    try {
      l = e.apply(this, a);
    } catch (u) {
      const c = (
        /** @type {Error} */
        u
      );
      if (s && r)
        throw c;
      return i(c);
    }
    s || (l && l.then && typeof l.then == "function" ? l.then(o, i) : l instanceof Error ? i(l) : o(l));
  }
  function i(a, ...s) {
    r || (r = !0, t(a, ...s));
  }
  function o(a) {
    i(null, a);
  }
}
const Na = { basename: Zfe, dirname: Xfe, extname: Qfe, join: Jfe, sep: "/" };
function Zfe(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  wv(e);
  let r = 0, n = -1, i = e.length, o;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; i--; )
      if (e.codePointAt(i) === 47) {
        if (o) {
          r = i + 1;
          break;
        }
      } else n < 0 && (o = !0, n = i + 1);
    return n < 0 ? "" : e.slice(r, n);
  }
  if (t === e)
    return "";
  let a = -1, s = t.length - 1;
  for (; i--; )
    if (e.codePointAt(i) === 47) {
      if (o) {
        r = i + 1;
        break;
      }
    } else
      a < 0 && (o = !0, a = i + 1), s > -1 && (e.codePointAt(i) === t.codePointAt(s--) ? s < 0 && (n = i) : (s = -1, n = a));
  return r === n ? n = a : n < 0 && (n = e.length), e.slice(r, n);
}
function Xfe(e) {
  if (wv(e), e.length === 0)
    return ".";
  let t = -1, r = e.length, n;
  for (; --r; )
    if (e.codePointAt(r) === 47) {
      if (n) {
        t = r;
        break;
      }
    } else n || (n = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function Qfe(e) {
  wv(e);
  let t = e.length, r = -1, n = 0, i = -1, o = 0, a;
  for (; t--; ) {
    const s = e.codePointAt(t);
    if (s === 47) {
      if (a) {
        n = t + 1;
        break;
      }
      continue;
    }
    r < 0 && (a = !0, r = t + 1), s === 46 ? i < 0 ? i = t : o !== 1 && (o = 1) : i > -1 && (o = -1);
  }
  return i < 0 || r < 0 || // We saw a non-dot character immediately before the dot.
  o === 0 || // The (right-most) trimmed path component is exactly `..`.
  o === 1 && i === r - 1 && i === n + 1 ? "" : e.slice(i, r);
}
function Jfe(...e) {
  let t = -1, r;
  for (; ++t < e.length; )
    wv(e[t]), e[t] && (r = r === void 0 ? e[t] : r + "/" + e[t]);
  return r === void 0 ? "." : epe(r);
}
function epe(e) {
  wv(e);
  const t = e.codePointAt(0) === 47;
  let r = tpe(e, !t);
  return r.length === 0 && !t && (r = "."), r.length > 0 && e.codePointAt(e.length - 1) === 47 && (r += "/"), t ? "/" + r : r;
}
function tpe(e, t) {
  let r = "", n = 0, i = -1, o = 0, a = -1, s, l;
  for (; ++a <= e.length; ) {
    if (a < e.length)
      s = e.codePointAt(a);
    else {
      if (s === 47)
        break;
      s = 47;
    }
    if (s === 47) {
      if (!(i === a - 1 || o === 1)) if (i !== a - 1 && o === 2) {
        if (r.length < 2 || n !== 2 || r.codePointAt(r.length - 1) !== 46 || r.codePointAt(r.length - 2) !== 46) {
          if (r.length > 2) {
            if (l = r.lastIndexOf("/"), l !== r.length - 1) {
              l < 0 ? (r = "", n = 0) : (r = r.slice(0, l), n = r.length - 1 - r.lastIndexOf("/")), i = a, o = 0;
              continue;
            }
          } else if (r.length > 0) {
            r = "", n = 0, i = a, o = 0;
            continue;
          }
        }
        t && (r = r.length > 0 ? r + "/.." : "..", n = 2);
      } else
        r.length > 0 ? r += "/" + e.slice(i + 1, a) : r = e.slice(i + 1, a), n = a - i - 1;
      i = a, o = 0;
    } else s === 46 && o > -1 ? o++ : o = -1;
  }
  return r;
}
function wv(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const rpe = { cwd: npe };
function npe() {
  return "/";
}
function xR(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function ipe(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!xR(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return ope(e);
}
function ope(e) {
  if (e.hostname !== "") {
    const n = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw n.code = "ERR_INVALID_FILE_URL_HOST", n;
  }
  const t = e.pathname;
  let r = -1;
  for (; ++r < t.length; )
    if (t.codePointAt(r) === 37 && t.codePointAt(r + 1) === 50) {
      const n = t.codePointAt(r + 2);
      if (n === 70 || n === 102) {
        const i = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw i.code = "ERR_INVALID_FILE_URL_PATH", i;
      }
    }
  return decodeURIComponent(t);
}
const cb = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class G3 {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let r;
    t ? xR(t) ? r = { path: t } : typeof t == "string" || ape(t) ? r = { value: t } : r = t : r = {}, this.cwd = rpe.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let n = -1;
    for (; ++n < cb.length; ) {
      const o = cb[n];
      o in r && r[o] !== void 0 && r[o] !== null && (this[o] = o === "history" ? [...r[o]] : r[o]);
    }
    let i;
    for (i in r)
      cb.includes(i) || (this[i] = r[i]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? Na.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    hb(t, "basename"), db(t, "basename"), this.path = Na.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? Na.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    fL(this.basename, "dirname"), this.path = Na.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? Na.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (db(t, "extname"), fL(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = Na.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    xR(t) && (t = ipe(t)), hb(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? Na.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    hb(t, "stem"), db(t, "stem"), this.path = Na.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, r, n) {
    const i = this.message(t, r, n);
    throw i.fatal = !0, i;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, r, n) {
    const i = this.message(t, r, n);
    return i.fatal = void 0, i;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, r, n) {
    const i = new ri(
      // @ts-expect-error: the overloads are fine.
      t,
      r,
      n
    );
    return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function db(e, t) {
  if (e && e.includes(Na.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + Na.sep + "`"
    );
}
function hb(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function fL(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function ape(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const spe = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const n = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), i = n[e], o = function() {
      return i.apply(o, arguments);
    };
    return Object.setPrototypeOf(o, n), o;
  }
), lpe = {}.hasOwnProperty;
class jP extends spe {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = Yfe();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new jP()
    );
    let r = -1;
    for (; ++r < this.attachers.length; ) {
      const n = this.attachers[r];
      t.use(...n);
    }
    return t.data(ub(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, r) {
    return typeof t == "string" ? arguments.length === 2 ? (gb("data", this.frozen), this.namespace[t] = r, this) : lpe.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (gb("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [r, ...n] = this.attachers[this.freezeIndex];
      if (n[0] === !1)
        continue;
      n[0] === !0 && (n[0] = void 0);
      const i = r.call(t, ...n);
      typeof i == "function" && this.transformers.use(i);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const r = bm(t), n = this.parser || this.Parser;
    return fb("parse", n), n(String(r), r);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, r) {
    const n = this;
    return this.freeze(), fb("process", this.parser || this.Parser), pb("process", this.compiler || this.Compiler), r ? i(void 0, r) : new Promise(i);
    function i(o, a) {
      const s = bm(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        n.parse(s)
      );
      n.run(l, s, function(c, d, h) {
        if (c || !d || !h)
          return u(c);
        const f = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), p = n.stringify(f, h);
        dpe(p) ? h.value = p : h.result = p, u(
          c,
          /** @type {VFileWithOutput<CompileResult>} */
          h
        );
      });
      function u(c, d) {
        c || !d ? a(c) : o ? o(d) : r(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let r = !1, n;
    return this.freeze(), fb("processSync", this.parser || this.Parser), pb("processSync", this.compiler || this.Compiler), this.process(t, i), gL("processSync", "process", r), n;
    function i(o, a) {
      r = !0, aL(o), n = a;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, r, n) {
    pL(t), this.freeze();
    const i = this.transformers;
    return !n && typeof r == "function" && (n = r, r = void 0), n ? o(void 0, n) : new Promise(o);
    function o(a, s) {
      const l = bm(r);
      i.run(t, l, u);
      function u(c, d, h) {
        const f = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || t
        );
        c ? s(c) : a ? a(f) : n(void 0, f, h);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, r) {
    let n = !1, i;
    return this.run(t, r, o), gL("runSync", "run", n), i;
    function o(a, s) {
      aL(a), i = s, n = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, r) {
    this.freeze();
    const n = bm(r), i = this.compiler || this.Compiler;
    return pb("stringify", i), pL(t), i(t, n);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...r) {
    const n = this.attachers, i = this.namespace;
    if (gb("use", this.frozen), t != null) if (typeof t == "function")
      l(t, r);
    else if (typeof t == "object")
      Array.isArray(t) ? s(t) : a(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function o(u) {
      if (typeof u == "function")
        l(u, []);
      else if (typeof u == "object")
        if (Array.isArray(u)) {
          const [c, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            u
          );
          l(c, d);
        } else
          a(u);
      else
        throw new TypeError("Expected usable value, not `" + u + "`");
    }
    function a(u) {
      if (!("plugins" in u) && !("settings" in u))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      s(u.plugins), u.settings && (i.settings = ub(!0, i.settings, u.settings));
    }
    function s(u) {
      let c = -1;
      if (u != null) if (Array.isArray(u))
        for (; ++c < u.length; ) {
          const d = u[c];
          o(d);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + u + "`");
    }
    function l(u, c) {
      let d = -1, h = -1;
      for (; ++d < n.length; )
        if (n[d][0] === u) {
          h = d;
          break;
        }
      if (h === -1)
        n.push([u, ...c]);
      else if (c.length > 0) {
        let [f, ...p] = c;
        const g = n[h][1];
        bR(g) && bR(f) && (f = ub(!0, g, f)), n[h] = [u, f, ...p];
      }
    }
  }
}
const upe = new jP().freeze();
function fb(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function pb(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function gb(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function pL(e) {
  if (!bR(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function gL(e, t, r) {
  if (!r)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function bm(e) {
  return cpe(e) ? e : new G3(e);
}
function cpe(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function dpe(e) {
  return typeof e == "string" || hpe(e);
}
function hpe(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const fpe = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", vL = [], mL = { allowDangerousHtml: !0 }, ppe = /^(https?|ircs?|mailto|xmpp)$/i, gpe = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function CS(e) {
  const t = e.allowedElements, r = e.allowElement, n = e.children || "", i = e.className, o = e.components, a = e.disallowedElements, s = e.rehypePlugins || vL, l = e.remarkPlugins || vL, u = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...mL } : mL, c = e.skipHtml, d = e.unwrapDisallowed, h = e.urlTransform || vpe, f = upe().use(Xhe).use(l).use(Ufe, u).use(s), p = new G3();
  typeof n == "string" && (p.value = n);
  for (const y of gpe)
    Object.hasOwn(e, y.from) && ("" + y.from + (y.to ? "use `" + y.to + "` instead" : "remove it") + fpe + y.id, void 0);
  const g = f.parse(p);
  let v = f.runSync(g, p);
  return i && (v = {
    type: "element",
    tagName: "div",
    properties: { className: i },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      v.type === "root" ? v.children : [v]
    )
  }), V3(v, m), Mce(v, {
    Fragment: ce.Fragment,
    components: o,
    ignoreInvalidStyle: !0,
    jsx: ce.jsx,
    jsxs: ce.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function m(y, C, S) {
    if (y.type === "raw" && S && typeof C == "number")
      return c ? S.children.splice(C, 1) : S.children[C] = { type: "text", value: y.value }, C;
    if (y.type === "element") {
      let b;
      for (b in ab)
        if (Object.hasOwn(ab, b) && Object.hasOwn(y.properties, b)) {
          const w = y.properties[b], x = ab[b];
          (x === null || x.includes(y.tagName)) && (y.properties[b] = h(String(w || ""), b, y));
        }
    }
    if (y.type === "element") {
      let b = t ? !t.includes(y.tagName) : a ? a.includes(y.tagName) : !1;
      if (!b && r && typeof C == "number" && (b = !r(y, C, S)), b && S && typeof C == "number")
        return d && y.children ? S.children.splice(C, 1, ...y.children) : S.children.splice(C, 1), C;
    }
  }
}
function vpe(e) {
  const t = e.indexOf(":"), r = e.indexOf("?"), n = e.indexOf("#"), i = e.indexOf("/");
  return (
    // If there is no protocol, it’s relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    i > -1 && t > i || r > -1 && t > r || n > -1 && t > n || // It is a protocol, it should be allowed.
    ppe.test(e.slice(0, t)) ? e : ""
  );
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var ER = function(e, t) {
  return ER = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) n.hasOwnProperty(i) && (r[i] = n[i]);
  }, ER(e, t);
};
function H3(e, t) {
  ER(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var RR = function() {
  return RR = Object.assign || function(t) {
    for (var r, n = 1, i = arguments.length; n < i; n++) {
      r = arguments[n];
      for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o]);
    }
    return t;
  }, RR.apply(this, arguments);
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var _R = function(e, t) {
  return _R = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i]);
  }, _R(e, t);
};
function ne(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  _R(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
var mpe = /* @__PURE__ */ function() {
  function e() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return e;
}(), ype = /* @__PURE__ */ function() {
  function e() {
    this.browser = new mpe(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return e;
}(), Nu = new ype();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (Nu.wxa = !0, Nu.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? Nu.worker = !0 : typeof navigator > "u" || navigator.userAgent.indexOf("Node.js") === 0 ? (Nu.node = !0, Nu.svgSupported = !0) : Cpe(navigator.userAgent, Nu);
function Cpe(e, t) {
  var r = t.browser, n = e.match(/Firefox\/([\d.]+)/), i = e.match(/MSIE\s([\d.]+)/) || e.match(/Trident\/.+?rv:(([\d.]+))/), o = e.match(/Edge?\/([\d.]+)/), a = /micromessenger/i.test(e);
  n && (r.firefox = !0, r.version = n[1]), i && (r.ie = !0, r.version = i[1]), o && (r.edge = !0, r.version = o[1], r.newEdge = +o[1].split(".")[0] > 18), a && (r.weChat = !0), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !r.ie && !r.edge, t.pointerEventsSupported = "onpointerdown" in window && (r.edge || r.ie && +r.version >= 11), t.domSupported = typeof document < "u";
  var s = document.documentElement.style;
  t.transform3dSupported = (r.ie && "transition" in s || r.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), t.transformSupported = t.transform3dSupported || r.ie && +r.version >= 9;
}
const kt = Nu;
var UP = 12, z3 = "sans-serif", Hl = UP + "px " + z3, Spe = 20, wpe = 100, bpe = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function xpe(e) {
  var t = {};
  if (typeof JSON > "u")
    return t;
  for (var r = 0; r < e.length; r++) {
    var n = String.fromCharCode(r + 32), i = (e.charCodeAt(r) - Spe) / wpe;
    t[n] = i;
  }
  return t;
}
var Epe = xpe(bpe), va = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ function() {
    var e, t;
    return function(r, n) {
      if (!e) {
        var i = va.createCanvas();
        e = i && i.getContext("2d");
      }
      if (e)
        return t !== n && (t = e.font = n || Hl), e.measureText(r);
      r = r || "", n = n || Hl;
      var o = /((?:\d+)?\.?\d*)px/.exec(n), a = o && +o[1] || UP, s = 0;
      if (n.indexOf("mono") >= 0)
        s = a * r.length;
      else
        for (var l = 0; l < r.length; l++) {
          var u = Epe[r[l]];
          s += u == null ? a : u * a;
        }
      return { width: s };
    };
  }(),
  loadImage: function(e, t, r) {
    var n = new Image();
    return n.onload = t, n.onerror = r, n.src = e, n;
  }
};
function $3(e) {
  for (var t in va)
    e[t] && (va[t] = e[t]);
}
var W3 = Oo([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(e, t) {
  return e["[object " + t + "]"] = !0, e;
}, {}), j3 = Oo([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(e, t) {
  return e["[object " + t + "Array]"] = !0, e;
}, {}), rf = Object.prototype.toString, SS = Array.prototype, Rpe = SS.forEach, _pe = SS.filter, KP = SS.slice, Tpe = SS.map, yL = (function() {
}).constructor, xm = yL ? yL.prototype : null, YP = "__proto__", Ppe = 2311;
function qP() {
  return Ppe++;
}
function Mo() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  typeof console < "u" && console.error.apply(console, e);
}
function et(e) {
  if (e == null || typeof e != "object")
    return e;
  var t = e, r = rf.call(e);
  if (r === "[object Array]") {
    if (!hh(e)) {
      t = [];
      for (var n = 0, i = e.length; n < i; n++)
        t[n] = et(e[n]);
    }
  } else if (j3[r]) {
    if (!hh(e)) {
      var o = e.constructor;
      if (o.from)
        t = o.from(e);
      else {
        t = new o(e.length);
        for (var n = 0, i = e.length; n < i; n++)
          t[n] = e[n];
      }
    }
  } else if (!W3[r] && !hh(e) && !zl(e)) {
    t = {};
    for (var a in e)
      e.hasOwnProperty(a) && a !== YP && (t[a] = et(e[a]));
  }
  return t;
}
function yt(e, t, r) {
  if (!Ze(t) || !Ze(e))
    return r ? et(t) : e;
  for (var n in t)
    if (t.hasOwnProperty(n) && n !== YP) {
      var i = e[n], o = t[n];
      Ze(o) && Ze(i) && !fe(o) && !fe(i) && !zl(o) && !zl(i) && !TR(o) && !TR(i) && !hh(o) && !hh(i) ? yt(i, o, r) : (r || !(n in e)) && (e[n] = et(t[n]));
    }
  return e;
}
function wS(e, t) {
  for (var r = e[0], n = 1, i = e.length; n < i; n++)
    r = yt(r, e[n], t);
  return r;
}
function se(e, t) {
  if (Object.assign)
    Object.assign(e, t);
  else
    for (var r in t)
      t.hasOwnProperty(r) && r !== YP && (e[r] = t[r]);
  return e;
}
function Xe(e, t, r) {
  for (var n = At(t), i = 0; i < n.length; i++) {
    var o = n[i];
    (r ? t[o] != null : e[o] == null) && (e[o] = t[o]);
  }
  return e;
}
var Mpe = va.createCanvas;
function bt(e, t) {
  if (e) {
    if (e.indexOf)
      return e.indexOf(t);
    for (var r = 0, n = e.length; r < n; r++)
      if (e[r] === t)
        return r;
  }
  return -1;
}
function ZP(e, t) {
  var r = e.prototype;
  function n() {
  }
  n.prototype = t.prototype, e.prototype = new n();
  for (var i in r)
    r.hasOwnProperty(i) && (e.prototype[i] = r[i]);
  e.prototype.constructor = e, e.superClass = t;
}
function qr(e, t, r) {
  if (e = "prototype" in e ? e.prototype : e, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames)
    for (var n = Object.getOwnPropertyNames(t), i = 0; i < n.length; i++) {
      var o = n[i];
      o !== "constructor" && (r ? t[o] != null : e[o] == null) && (e[o] = t[o]);
    }
  else
    Xe(e, t, r);
}
function kn(e) {
  return !e || typeof e == "string" ? !1 : typeof e.length == "number";
}
function B(e, t, r) {
  if (e && t)
    if (e.forEach && e.forEach === Rpe)
      e.forEach(t, r);
    else if (e.length === +e.length)
      for (var n = 0, i = e.length; n < i; n++)
        t.call(r, e[n], n, e);
    else
      for (var o in e)
        e.hasOwnProperty(o) && t.call(r, e[o], o, e);
}
function ge(e, t, r) {
  if (!e)
    return [];
  if (!t)
    return bS(e);
  if (e.map && e.map === Tpe)
    return e.map(t, r);
  for (var n = [], i = 0, o = e.length; i < o; i++)
    n.push(t.call(r, e[i], i, e));
  return n;
}
function Oo(e, t, r, n) {
  if (e && t) {
    for (var i = 0, o = e.length; i < o; i++)
      r = t.call(n, r, e[i], i, e);
    return r;
  }
}
function ir(e, t, r) {
  if (!e)
    return [];
  if (!t)
    return bS(e);
  if (e.filter && e.filter === _pe)
    return e.filter(t, r);
  for (var n = [], i = 0, o = e.length; i < o; i++)
    t.call(r, e[i], i, e) && n.push(e[i]);
  return n;
}
function U3(e, t, r) {
  if (e && t) {
    for (var n = 0, i = e.length; n < i; n++)
      if (t.call(r, e[n], n, e))
        return e[n];
  }
}
function At(e) {
  if (!e)
    return [];
  if (Object.keys)
    return Object.keys(e);
  var t = [];
  for (var r in e)
    e.hasOwnProperty(r) && t.push(r);
  return t;
}
function Dpe(e, t) {
  for (var r = [], n = 2; n < arguments.length; n++)
    r[n - 2] = arguments[n];
  return function() {
    return e.apply(t, r.concat(KP.call(arguments)));
  };
}
var ke = xm && Ye(xm.bind) ? xm.call.bind(xm.bind) : Dpe;
function dt(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  return function() {
    return e.apply(this, t.concat(KP.call(arguments)));
  };
}
function fe(e) {
  return Array.isArray ? Array.isArray(e) : rf.call(e) === "[object Array]";
}
function Ye(e) {
  return typeof e == "function";
}
function Fe(e) {
  return typeof e == "string";
}
function Pg(e) {
  return rf.call(e) === "[object String]";
}
function $t(e) {
  return typeof e == "number";
}
function Ze(e) {
  var t = typeof e;
  return t === "function" || !!e && t === "object";
}
function TR(e) {
  return !!W3[rf.call(e)];
}
function ei(e) {
  return !!j3[rf.call(e)];
}
function zl(e) {
  return typeof e == "object" && typeof e.nodeType == "number" && typeof e.ownerDocument == "object";
}
function bv(e) {
  return e.colorStops != null;
}
function K3(e) {
  return e.image != null;
}
function XP(e) {
  return rf.call(e) === "[object RegExp]";
}
function $l(e) {
  return e !== e;
}
function tn() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  for (var r = 0, n = e.length; r < n; r++)
    if (e[r] != null)
      return e[r];
}
function st(e, t) {
  return e ?? t;
}
function ro(e, t, r) {
  return e ?? t ?? r;
}
function bS(e) {
  for (var t = [], r = 1; r < arguments.length; r++)
    t[r - 1] = arguments[r];
  return KP.apply(e, t);
}
function xS(e) {
  if (typeof e == "number")
    return [e, e, e, e];
  var t = e.length;
  return t === 2 ? [e[0], e[1], e[0], e[1]] : t === 3 ? [e[0], e[1], e[2], e[1]] : e;
}
function Qe(e, t) {
  if (!e)
    throw new Error(t);
}
function _o(e) {
  return e == null ? null : typeof e.trim == "function" ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var Y3 = "__ec_primitive__";
function Mg(e) {
  e[Y3] = !0;
}
function hh(e) {
  return e[Y3];
}
var Ape = function() {
  function e() {
    this.data = {};
  }
  return e.prototype.delete = function(t) {
    var r = this.has(t);
    return r && delete this.data[t], r;
  }, e.prototype.has = function(t) {
    return this.data.hasOwnProperty(t);
  }, e.prototype.get = function(t) {
    return this.data[t];
  }, e.prototype.set = function(t, r) {
    return this.data[t] = r, this;
  }, e.prototype.keys = function() {
    return At(this.data);
  }, e.prototype.forEach = function(t) {
    var r = this.data;
    for (var n in r)
      r.hasOwnProperty(n) && t(r[n], n);
  }, e;
}(), q3 = typeof Map == "function";
function Ipe() {
  return q3 ? /* @__PURE__ */ new Map() : new Ape();
}
var Z3 = function() {
  function e(t) {
    var r = fe(t);
    this.data = Ipe();
    var n = this;
    t instanceof e ? t.each(i) : t && B(t, i);
    function i(o, a) {
      r ? n.set(o, a) : n.set(a, o);
    }
  }
  return e.prototype.hasKey = function(t) {
    return this.data.has(t);
  }, e.prototype.get = function(t) {
    return this.data.get(t);
  }, e.prototype.set = function(t, r) {
    return this.data.set(t, r), r;
  }, e.prototype.each = function(t, r) {
    this.data.forEach(function(n, i) {
      t.call(r, n, i);
    });
  }, e.prototype.keys = function() {
    var t = this.data.keys();
    return q3 ? Array.from(t) : t;
  }, e.prototype.removeKey = function(t) {
    this.data.delete(t);
  }, e;
}();
function We(e) {
  return new Z3(e);
}
function Dg(e, t) {
  for (var r = new e.constructor(e.length + t.length), n = 0; n < e.length; n++)
    r[n] = e[n];
  for (var i = e.length, n = 0; n < t.length; n++)
    r[n + i] = t[n];
  return r;
}
function xv(e, t) {
  var r;
  if (Object.create)
    r = Object.create(e);
  else {
    var n = function() {
    };
    n.prototype = e, r = new n();
  }
  return t && se(r, t), r;
}
function QP(e) {
  var t = e.style;
  t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
}
function Be(e, t) {
  return e.hasOwnProperty(t);
}
function Kr() {
}
var Up = 180 / Math.PI;
const Fpe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  HashMap: Z3,
  RADIAN_TO_DEGREE: Up,
  assert: Qe,
  bind: ke,
  clone: et,
  concatArray: Dg,
  createCanvas: Mpe,
  createHashMap: We,
  createObject: xv,
  curry: dt,
  defaults: Xe,
  disableUserSelect: QP,
  each: B,
  eqNaN: $l,
  extend: se,
  filter: ir,
  find: U3,
  guid: qP,
  hasOwn: Be,
  indexOf: bt,
  inherits: ZP,
  isArray: fe,
  isArrayLike: kn,
  isBuiltInObject: TR,
  isDom: zl,
  isFunction: Ye,
  isGradientObject: bv,
  isImagePatternObject: K3,
  isNumber: $t,
  isObject: Ze,
  isPrimitive: hh,
  isRegExp: XP,
  isString: Fe,
  isStringSafe: Pg,
  isTypedArray: ei,
  keys: At,
  logError: Mo,
  map: ge,
  merge: yt,
  mergeAll: wS,
  mixin: qr,
  noop: Kr,
  normalizeCssArray: xS,
  reduce: Oo,
  retrieve: tn,
  retrieve2: st,
  retrieve3: ro,
  setAsPrimitive: Mg,
  slice: bS,
  trim: _o
}, Symbol.toStringTag, { value: "Module" }));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var PR = function(e, t) {
  return PR = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, n) {
    r.__proto__ = n;
  } || function(r, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i]);
  }, PR(e, t);
};
function Mr(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  PR(e, t);
  function r() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (r.prototype = t.prototype, new r());
}
function ru(e, t) {
  return e == null && (e = 0), t == null && (t = 0), [e, t];
}
function Kn(e, t) {
  return e[0] = t[0], e[1] = t[1], e;
}
function Ua(e) {
  return [e[0], e[1]];
}
function X3(e, t, r) {
  return e[0] = t, e[1] = r, e;
}
function MR(e, t, r) {
  return e[0] = t[0] + r[0], e[1] = t[1] + r[1], e;
}
function k0(e, t, r, n) {
  return e[0] = t[0] + r[0] * n, e[1] = t[1] + r[1] * n, e;
}
function El(e, t, r) {
  return e[0] = t[0] - r[0], e[1] = t[1] - r[1], e;
}
function Ag(e) {
  return Math.sqrt(JP(e));
}
var Lpe = Ag;
function JP(e) {
  return e[0] * e[0] + e[1] * e[1];
}
var Ope = JP;
function Npe(e, t, r) {
  return e[0] = t[0] * r[0], e[1] = t[1] * r[1], e;
}
function kpe(e, t, r) {
  return e[0] = t[0] / r[0], e[1] = t[1] / r[1], e;
}
function Vpe(e, t) {
  return e[0] * t[0] + e[1] * t[1];
}
function Kp(e, t, r) {
  return e[0] = t[0] * r, e[1] = t[1] * r, e;
}
function $c(e, t) {
  var r = Ag(t);
  return r === 0 ? (e[0] = 0, e[1] = 0) : (e[0] = t[0] / r, e[1] = t[1] / r), e;
}
function V0(e, t) {
  return Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]));
}
var Es = V0;
function Q3(e, t) {
  return (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]);
}
var Al = Q3;
function Bpe(e, t) {
  return e[0] = -t[0], e[1] = -t[1], e;
}
function Yp(e, t, r, n) {
  return e[0] = t[0] + n * (r[0] - t[0]), e[1] = t[1] + n * (r[1] - t[1]), e;
}
function An(e, t, r) {
  var n = t[0], i = t[1];
  return e[0] = r[0] * n + r[2] * i + r[4], e[1] = r[1] * n + r[3] * i + r[5], e;
}
function Rs(e, t, r) {
  return e[0] = Math.min(t[0], r[0]), e[1] = Math.min(t[1], r[1]), e;
}
function _s(e, t, r) {
  return e[0] = Math.max(t[0], r[0]), e[1] = Math.max(t[1], r[1]), e;
}
const Gpe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  add: MR,
  applyTransform: An,
  clone: Ua,
  copy: Kn,
  create: ru,
  dist: Es,
  distSquare: Al,
  distance: V0,
  distanceSquare: Q3,
  div: kpe,
  dot: Vpe,
  len: Ag,
  lenSquare: JP,
  length: Lpe,
  lengthSquare: Ope,
  lerp: Yp,
  max: _s,
  min: Rs,
  mul: Npe,
  negate: Bpe,
  normalize: $c,
  scale: Kp,
  scaleAndAdd: k0,
  set: X3,
  sub: El
}, Symbol.toStringTag, { value: "Module" }));
var md = /* @__PURE__ */ function() {
  function e(t, r) {
    this.target = t, this.topTarget = r && r.topTarget;
  }
  return e;
}(), Hpe = function() {
  function e(t) {
    this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
  }
  return e.prototype._dragStart = function(t) {
    for (var r = t.target; r && !r.draggable; )
      r = r.parent || r.__hostTarget;
    r && (this._draggingTarget = r, r.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new md(r, t), "dragstart", t.event));
  }, e.prototype._drag = function(t) {
    var r = this._draggingTarget;
    if (r) {
      var n = t.offsetX, i = t.offsetY, o = n - this._x, a = i - this._y;
      this._x = n, this._y = i, r.drift(o, a, t), this.handler.dispatchToElement(new md(r, t), "drag", t.event);
      var s = this.handler.findHover(n, i, r).target, l = this._dropTarget;
      this._dropTarget = s, r !== s && (l && s !== l && this.handler.dispatchToElement(new md(l, t), "dragleave", t.event), s && s !== l && this.handler.dispatchToElement(new md(s, t), "dragenter", t.event));
    }
  }, e.prototype._dragEnd = function(t) {
    var r = this._draggingTarget;
    r && (r.dragging = !1), this.handler.dispatchToElement(new md(r, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new md(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
  }, e;
}(), Go = function() {
  function e(t) {
    t && (this._$eventProcessor = t);
  }
  return e.prototype.on = function(t, r, n, i) {
    this._$handlers || (this._$handlers = {});
    var o = this._$handlers;
    if (typeof r == "function" && (i = n, n = r, r = null), !n || !t)
      return this;
    var a = this._$eventProcessor;
    r != null && a && a.normalizeQuery && (r = a.normalizeQuery(r)), o[t] || (o[t] = []);
    for (var s = 0; s < o[t].length; s++)
      if (o[t][s].h === n)
        return this;
    var l = {
      h: n,
      query: r,
      ctx: i || this,
      callAtLast: n.zrEventfulCallAtLast
    }, u = o[t].length - 1, c = o[t][u];
    return c && c.callAtLast ? o[t].splice(u, 0, l) : o[t].push(l), this;
  }, e.prototype.isSilent = function(t) {
    var r = this._$handlers;
    return !r || !r[t] || !r[t].length;
  }, e.prototype.off = function(t, r) {
    var n = this._$handlers;
    if (!n)
      return this;
    if (!t)
      return this._$handlers = {}, this;
    if (r) {
      if (n[t]) {
        for (var i = [], o = 0, a = n[t].length; o < a; o++)
          n[t][o].h !== r && i.push(n[t][o]);
        n[t] = i;
      }
      n[t] && n[t].length === 0 && delete n[t];
    } else
      delete n[t];
    return this;
  }, e.prototype.trigger = function(t) {
    for (var r = [], n = 1; n < arguments.length; n++)
      r[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[t], o = this._$eventProcessor;
    if (i)
      for (var a = r.length, s = i.length, l = 0; l < s; l++) {
        var u = i[l];
        if (!(o && o.filter && u.query != null && !o.filter(t, u.query)))
          switch (a) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, r[0]);
              break;
            case 2:
              u.h.call(u.ctx, r[0], r[1]);
              break;
            default:
              u.h.apply(u.ctx, r);
              break;
          }
      }
    return o && o.afterTrigger && o.afterTrigger(t), this;
  }, e.prototype.triggerWithContext = function(t) {
    for (var r = [], n = 1; n < arguments.length; n++)
      r[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var i = this._$handlers[t], o = this._$eventProcessor;
    if (i)
      for (var a = r.length, s = r[a - 1], l = i.length, u = 0; u < l; u++) {
        var c = i[u];
        if (!(o && o.filter && c.query != null && !o.filter(t, c.query)))
          switch (a) {
            case 0:
              c.h.call(s);
              break;
            case 1:
              c.h.call(s, r[0]);
              break;
            case 2:
              c.h.call(s, r[0], r[1]);
              break;
            default:
              c.h.apply(s, r.slice(1, a - 1));
              break;
          }
      }
    return o && o.afterTrigger && o.afterTrigger(t), this;
  }, e;
}(), zpe = Math.log(2);
function DR(e, t, r, n, i, o) {
  var a = n + "-" + i, s = e.length;
  if (o.hasOwnProperty(a))
    return o[a];
  if (t === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~i) / zpe);
    return e[r][l];
  }
  for (var u = n | 1 << r, c = r + 1; n & 1 << c; )
    c++;
  for (var d = 0, h = 0, f = 0; h < s; h++) {
    var p = 1 << h;
    p & i || (d += (f % 2 ? -1 : 1) * e[r][h] * DR(e, t - 1, c, u, i | p, o), f++);
  }
  return o[a] = d, d;
}
function CL(e, t) {
  var r = [
    [e[0], e[1], 1, 0, 0, 0, -t[0] * e[0], -t[0] * e[1]],
    [0, 0, 0, e[0], e[1], 1, -t[1] * e[0], -t[1] * e[1]],
    [e[2], e[3], 1, 0, 0, 0, -t[2] * e[2], -t[2] * e[3]],
    [0, 0, 0, e[2], e[3], 1, -t[3] * e[2], -t[3] * e[3]],
    [e[4], e[5], 1, 0, 0, 0, -t[4] * e[4], -t[4] * e[5]],
    [0, 0, 0, e[4], e[5], 1, -t[5] * e[4], -t[5] * e[5]],
    [e[6], e[7], 1, 0, 0, 0, -t[6] * e[6], -t[6] * e[7]],
    [0, 0, 0, e[6], e[7], 1, -t[7] * e[6], -t[7] * e[7]]
  ], n = {}, i = DR(r, 8, 0, 0, 0, n);
  if (i !== 0) {
    for (var o = [], a = 0; a < 8; a++)
      for (var s = 0; s < 8; s++)
        o[s] == null && (o[s] = 0), o[s] += ((a + s) % 2 ? -1 : 1) * DR(r, 7, a === 0 ? 1 : 0, 1 << a, 1 << s, n) / i * t[a];
    return function(l, u, c) {
      var d = u * o[6] + c * o[7] + 1;
      l[0] = (u * o[0] + c * o[1] + o[2]) / d, l[1] = (u * o[3] + c * o[4] + o[5]) / d;
    };
  }
}
var SL = "___zrEVENTSAVED", vb = [];
function $pe(e, t, r, n, i) {
  return AR(vb, t, n, i, !0) && AR(e, r, vb[0], vb[1]);
}
function AR(e, t, r, n, i) {
  if (t.getBoundingClientRect && kt.domSupported && !J3(t)) {
    var o = t[SL] || (t[SL] = {}), a = Wpe(t, o), s = jpe(a, o, i);
    if (s)
      return s(e, r, n), !0;
  }
  return !1;
}
function Wpe(e, t) {
  var r = t.markers;
  if (r)
    return r;
  r = t.markers = [];
  for (var n = ["left", "right"], i = ["top", "bottom"], o = 0; o < 4; o++) {
    var a = document.createElement("div"), s = a.style, l = o % 2, u = (o >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      n[l] + ":0",
      i[u] + ":0",
      n[1 - l] + ":auto",
      i[1 - u] + ":auto",
      ""
    ].join("!important;"), e.appendChild(a), r.push(a);
  }
  return r;
}
function jpe(e, t, r) {
  for (var n = r ? "invTrans" : "trans", i = t[n], o = t.srcCoords, a = [], s = [], l = !0, u = 0; u < 4; u++) {
    var c = e[u].getBoundingClientRect(), d = 2 * u, h = c.left, f = c.top;
    a.push(h, f), l = l && o && h === o[d] && f === o[d + 1], s.push(e[u].offsetLeft, e[u].offsetTop);
  }
  return l && i ? i : (t.srcCoords = a, t[n] = r ? CL(s, a) : CL(a, s));
}
function J3(e) {
  return e.nodeName.toUpperCase() === "CANVAS";
}
var Upe = /([&<>"'])/g, Kpe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function fi(e) {
  return e == null ? "" : (e + "").replace(Upe, function(t, r) {
    return Kpe[r];
  });
}
var Ype = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, mb = [], qpe = kt.browser.firefox && +kt.browser.version.split(".")[0] < 39;
function IR(e, t, r, n) {
  return r = r || {}, n ? wL(e, t, r) : qpe && t.layerX != null && t.layerX !== t.offsetX ? (r.zrX = t.layerX, r.zrY = t.layerY) : t.offsetX != null ? (r.zrX = t.offsetX, r.zrY = t.offsetY) : wL(e, t, r), r;
}
function wL(e, t, r) {
  if (kt.domSupported && e.getBoundingClientRect) {
    var n = t.clientX, i = t.clientY;
    if (J3(e)) {
      var o = e.getBoundingClientRect();
      r.zrX = n - o.left, r.zrY = i - o.top;
      return;
    } else if (AR(mb, e, n, i)) {
      r.zrX = mb[0], r.zrY = mb[1];
      return;
    }
  }
  r.zrX = r.zrY = 0;
}
function eM(e) {
  return e || window.event;
}
function yo(e, t, r) {
  if (t = eM(t), t.zrX != null)
    return t;
  var n = t.type, i = n && n.indexOf("touch") >= 0;
  if (i) {
    var a = n !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
    a && IR(e, a, t, r);
  } else {
    IR(e, t, t, r);
    var o = Zpe(t);
    t.zrDelta = o ? o / 120 : -(t.detail || 0) / 3;
  }
  var s = t.button;
  return t.which == null && s !== void 0 && Ype.test(t.type) && (t.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), t;
}
function Zpe(e) {
  var t = e.wheelDelta;
  if (t)
    return t;
  var r = e.deltaX, n = e.deltaY;
  if (r == null || n == null)
    return t;
  var i = Math.abs(n !== 0 ? n : r), o = n > 0 ? -1 : n < 0 ? 1 : r > 0 ? -1 : 1;
  return 3 * i * o;
}
function FR(e, t, r, n) {
  e.addEventListener(t, r, n);
}
function Xpe(e, t, r, n) {
  e.removeEventListener(t, r, n);
}
var Hs = function(e) {
  e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0;
};
function bL(e) {
  return e.which === 2 || e.which === 3;
}
var Qpe = function() {
  function e() {
    this._track = [];
  }
  return e.prototype.recognize = function(t, r, n) {
    return this._doTrack(t, r, n), this._recognize(t);
  }, e.prototype.clear = function() {
    return this._track.length = 0, this;
  }, e.prototype._doTrack = function(t, r, n) {
    var i = t.touches;
    if (i) {
      for (var o = {
        points: [],
        touches: [],
        target: r,
        event: t
      }, a = 0, s = i.length; a < s; a++) {
        var l = i[a], u = IR(n, l, {});
        o.points.push([u.zrX, u.zrY]), o.touches.push(l);
      }
      this._track.push(o);
    }
  }, e.prototype._recognize = function(t) {
    for (var r in yb)
      if (yb.hasOwnProperty(r)) {
        var n = yb[r](this._track, t);
        if (n)
          return n;
      }
  }, e;
}();
function xL(e) {
  var t = e[1][0] - e[0][0], r = e[1][1] - e[0][1];
  return Math.sqrt(t * t + r * r);
}
function Jpe(e) {
  return [
    (e[0][0] + e[1][0]) / 2,
    (e[0][1] + e[1][1]) / 2
  ];
}
var yb = {
  pinch: function(e, t) {
    var r = e.length;
    if (r) {
      var n = (e[r - 1] || {}).points, i = (e[r - 2] || {}).points || n;
      if (i && i.length > 1 && n && n.length > 1) {
        var o = xL(n) / xL(i);
        !isFinite(o) && (o = 1), t.pinchScale = o;
        var a = Jpe(n);
        return t.pinchX = a[0], t.pinchY = a[1], {
          type: "pinch",
          target: e[0].target,
          event: t
        };
      }
    }
  }
};
function ki() {
  return [1, 0, 0, 1, 0, 0];
}
function Ev(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
}
function ES(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function Ka(e, t, r) {
  var n = t[0] * r[0] + t[2] * r[1], i = t[1] * r[0] + t[3] * r[1], o = t[0] * r[2] + t[2] * r[3], a = t[1] * r[2] + t[3] * r[3], s = t[0] * r[4] + t[2] * r[5] + t[4], l = t[1] * r[4] + t[3] * r[5] + t[5];
  return e[0] = n, e[1] = i, e[2] = o, e[3] = a, e[4] = s, e[5] = l, e;
}
function ma(e, t, r) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4] + r[0], e[5] = t[5] + r[1], e;
}
function nu(e, t, r, n) {
  n === void 0 && (n = [0, 0]);
  var i = t[0], o = t[2], a = t[4], s = t[1], l = t[3], u = t[5], c = Math.sin(r), d = Math.cos(r);
  return e[0] = i * d + s * c, e[1] = -i * c + s * d, e[2] = o * d + l * c, e[3] = -o * c + d * l, e[4] = d * (a - n[0]) + c * (u - n[1]) + n[0], e[5] = d * (u - n[1]) - c * (a - n[0]) + n[1], e;
}
function RS(e, t, r) {
  var n = r[0], i = r[1];
  return e[0] = t[0] * n, e[1] = t[1] * i, e[2] = t[2] * n, e[3] = t[3] * i, e[4] = t[4] * n, e[5] = t[5] * i, e;
}
function Wc(e, t) {
  var r = t[0], n = t[2], i = t[4], o = t[1], a = t[3], s = t[5], l = r * a - o * n;
  return l ? (l = 1 / l, e[0] = a * l, e[1] = -o * l, e[2] = -n * l, e[3] = r * l, e[4] = (n * s - a * i) * l, e[5] = (o * i - r * s) * l, e) : null;
}
function e$(e) {
  var t = ki();
  return ES(t, e), t;
}
const ege = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  clone: e$,
  copy: ES,
  create: ki,
  identity: Ev,
  invert: Wc,
  mul: Ka,
  rotate: nu,
  scale: RS,
  translate: ma
}, Symbol.toStringTag, { value: "Module" }));
var Ct = function() {
  function e(t, r) {
    this.x = t || 0, this.y = r || 0;
  }
  return e.prototype.copy = function(t) {
    return this.x = t.x, this.y = t.y, this;
  }, e.prototype.clone = function() {
    return new e(this.x, this.y);
  }, e.prototype.set = function(t, r) {
    return this.x = t, this.y = r, this;
  }, e.prototype.equal = function(t) {
    return t.x === this.x && t.y === this.y;
  }, e.prototype.add = function(t) {
    return this.x += t.x, this.y += t.y, this;
  }, e.prototype.scale = function(t) {
    this.x *= t, this.y *= t;
  }, e.prototype.scaleAndAdd = function(t, r) {
    this.x += t.x * r, this.y += t.y * r;
  }, e.prototype.sub = function(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }, e.prototype.dot = function(t) {
    return this.x * t.x + this.y * t.y;
  }, e.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, e.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, e.prototype.normalize = function() {
    var t = this.len();
    return this.x /= t, this.y /= t, this;
  }, e.prototype.distance = function(t) {
    var r = this.x - t.x, n = this.y - t.y;
    return Math.sqrt(r * r + n * n);
  }, e.prototype.distanceSquare = function(t) {
    var r = this.x - t.x, n = this.y - t.y;
    return r * r + n * n;
  }, e.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, e.prototype.transform = function(t) {
    if (t) {
      var r = this.x, n = this.y;
      return this.x = t[0] * r + t[2] * n + t[4], this.y = t[1] * r + t[3] * n + t[5], this;
    }
  }, e.prototype.toArray = function(t) {
    return t[0] = this.x, t[1] = this.y, t;
  }, e.prototype.fromArray = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.set = function(t, r, n) {
    t.x = r, t.y = n;
  }, e.copy = function(t, r) {
    t.x = r.x, t.y = r.y;
  }, e.len = function(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y);
  }, e.lenSquare = function(t) {
    return t.x * t.x + t.y * t.y;
  }, e.dot = function(t, r) {
    return t.x * r.x + t.y * r.y;
  }, e.add = function(t, r, n) {
    t.x = r.x + n.x, t.y = r.y + n.y;
  }, e.sub = function(t, r, n) {
    t.x = r.x - n.x, t.y = r.y - n.y;
  }, e.scale = function(t, r, n) {
    t.x = r.x * n, t.y = r.y * n;
  }, e.scaleAndAdd = function(t, r, n, i) {
    t.x = r.x + n.x * i, t.y = r.y + n.y * i;
  }, e.lerp = function(t, r, n, i) {
    var o = 1 - i;
    t.x = o * r.x + i * n.x, t.y = o * r.y + i * n.y;
  }, e;
}(), Em = Math.min, Rm = Math.max, du = new Ct(), hu = new Ct(), fu = new Ct(), pu = new Ct(), $f = new Ct(), Wf = new Ct(), tge = function() {
  function e(t, r, n, i) {
    n < 0 && (t = t + n, n = -n), i < 0 && (r = r + i, i = -i), this.x = t, this.y = r, this.width = n, this.height = i;
  }
  return e.prototype.union = function(t) {
    var r = Em(t.x, this.x), n = Em(t.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Rm(t.x + t.width, this.x + this.width) - r : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Rm(t.y + t.height, this.y + this.height) - n : this.height = t.height, this.x = r, this.y = n;
  }, e.prototype.applyTransform = function(t) {
    e.applyTransform(this, this, t);
  }, e.prototype.calculateTransform = function(t) {
    var r = this, n = t.width / r.width, i = t.height / r.height, o = ki();
    return ma(o, o, [-r.x, -r.y]), RS(o, o, [n, i]), ma(o, o, [t.x, t.y]), o;
  }, e.prototype.intersect = function(t, r) {
    if (!t)
      return !1;
    t instanceof e || (t = e.create(t));
    var n = this, i = n.x, o = n.x + n.width, a = n.y, s = n.y + n.height, l = t.x, u = t.x + t.width, c = t.y, d = t.y + t.height, h = !(o < l || u < i || s < c || d < a);
    if (r) {
      var f = 1 / 0, p = 0, g = Math.abs(o - l), v = Math.abs(u - i), m = Math.abs(s - c), y = Math.abs(d - a), C = Math.min(g, v), S = Math.min(m, y);
      o < l || u < i ? C > p && (p = C, g < v ? Ct.set(Wf, -g, 0) : Ct.set(Wf, v, 0)) : C < f && (f = C, g < v ? Ct.set($f, g, 0) : Ct.set($f, -v, 0)), s < c || d < a ? S > p && (p = S, m < y ? Ct.set(Wf, 0, -m) : Ct.set(Wf, 0, y)) : C < f && (f = C, m < y ? Ct.set($f, 0, m) : Ct.set($f, 0, -y));
    }
    return r && Ct.copy(r, h ? $f : Wf), h;
  }, e.prototype.contain = function(t, r) {
    var n = this;
    return t >= n.x && t <= n.x + n.width && r >= n.y && r <= n.y + n.height;
  }, e.prototype.clone = function() {
    return new e(this.x, this.y, this.width, this.height);
  }, e.prototype.copy = function(t) {
    e.copy(this, t);
  }, e.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, e.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, e.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, e.create = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e.copy = function(t, r) {
    t.x = r.x, t.y = r.y, t.width = r.width, t.height = r.height;
  }, e.applyTransform = function(t, r, n) {
    if (!n) {
      t !== r && e.copy(t, r);
      return;
    }
    if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
      var i = n[0], o = n[3], a = n[4], s = n[5];
      t.x = r.x * i + a, t.y = r.y * o + s, t.width = r.width * i, t.height = r.height * o, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
      return;
    }
    du.x = fu.x = r.x, du.y = pu.y = r.y, hu.x = pu.x = r.x + r.width, hu.y = fu.y = r.y + r.height, du.transform(n), pu.transform(n), hu.transform(n), fu.transform(n), t.x = Em(du.x, hu.x, fu.x, pu.x), t.y = Em(du.y, hu.y, fu.y, pu.y);
    var l = Rm(du.x, hu.x, fu.x, pu.x), u = Rm(du.y, hu.y, fu.y, pu.y);
    t.width = l - t.x, t.height = u - t.y;
  }, e;
}();
const St = tge;
var t$ = "silent";
function rge(e, t, r) {
  return {
    type: e,
    event: r,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: r.zrX,
    offsetY: r.zrY,
    gestureEvent: r.gestureEvent,
    pinchX: r.pinchX,
    pinchY: r.pinchY,
    pinchScale: r.pinchScale,
    wheelDelta: r.zrDelta,
    zrByTouch: r.zrByTouch,
    which: r.which,
    stop: nge
  };
}
function nge() {
  Hs(this.event);
}
var ige = function(e) {
  Mr(t, e);
  function t() {
    var r = e !== null && e.apply(this, arguments) || this;
    return r.handler = null, r;
  }
  return t.prototype.dispose = function() {
  }, t.prototype.setCursor = function() {
  }, t;
}(Go), jf = /* @__PURE__ */ function() {
  function e(t, r) {
    this.x = t, this.y = r;
  }
  return e;
}(), oge = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], Cb = new St(0, 0, 0, 0), r$ = function(e) {
  Mr(t, e);
  function t(r, n, i, o, a) {
    var s = e.call(this) || this;
    return s._hovered = new jf(0, 0), s.storage = r, s.painter = n, s.painterRoot = o, s._pointerSize = a, i = i || new ige(), s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new Hpe(s), s;
  }
  return t.prototype.setHandlerProxy = function(r) {
    this.proxy && this.proxy.dispose(), r && (B(oge, function(n) {
      r.on && r.on(n, this[n], this);
    }, this), r.handler = this), this.proxy = r;
  }, t.prototype.mousemove = function(r) {
    var n = r.zrX, i = r.zrY, o = n$(this, n, i), a = this._hovered, s = a.target;
    s && !s.__zr && (a = this.findHover(a.x, a.y), s = a.target);
    var l = this._hovered = o ? new jf(n, i) : this.findHover(n, i), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(a, "mouseout", r), this.dispatchToElement(l, "mousemove", r), u && u !== s && this.dispatchToElement(l, "mouseover", r);
  }, t.prototype.mouseout = function(r) {
    var n = r.zrEventControl;
    n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", r), n !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: r });
  }, t.prototype.resize = function() {
    this._hovered = new jf(0, 0);
  }, t.prototype.dispatch = function(r, n) {
    var i = this[r];
    i && i.call(this, n);
  }, t.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, t.prototype.setCursorStyle = function(r) {
    var n = this.proxy;
    n.setCursor && n.setCursor(r);
  }, t.prototype.dispatchToElement = function(r, n, i) {
    r = r || {};
    var o = r.target;
    if (!(o && o.silent)) {
      for (var a = "on" + n, s = rge(n, r, i); o && (o[a] && (s.cancelBubble = !!o[a].call(o, s)), o.trigger(n, s), o = o.__hostTarget ? o.__hostTarget : o.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(n, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[a] == "function" && l[a].call(l, s), l.trigger && l.trigger(n, s);
      }));
    }
  }, t.prototype.findHover = function(r, n, i) {
    var o = this.storage.getDisplayList(), a = new jf(r, n);
    if (EL(o, a, r, n, i), this._pointerSize && !a.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, c = new St(r - u, n - u, l, l), d = o.length - 1; d >= 0; d--) {
        var h = o[d];
        h !== i && !h.ignore && !h.ignoreCoarsePointer && (!h.parent || !h.parent.ignoreCoarsePointer) && (Cb.copy(h.getBoundingRect()), h.transform && Cb.applyTransform(h.transform), Cb.intersect(c) && s.push(h));
      }
      if (s.length)
        for (var f = 4, p = Math.PI / 12, g = Math.PI * 2, v = 0; v < u; v += f)
          for (var m = 0; m < g; m += p) {
            var y = r + v * Math.cos(m), C = n + v * Math.sin(m);
            if (EL(s, a, y, C, i), a.target)
              return a;
          }
    }
    return a;
  }, t.prototype.processGesture = function(r, n) {
    this._gestureMgr || (this._gestureMgr = new Qpe());
    var i = this._gestureMgr;
    n === "start" && i.clear();
    var o = i.recognize(r, this.findHover(r.zrX, r.zrY, null).target, this.proxy.dom);
    if (n === "end" && i.clear(), o) {
      var a = o.type;
      r.gestureEvent = a;
      var s = new jf();
      s.target = o.target, this.dispatchToElement(s, a, o.event);
    }
  }, t;
}(Go);
B(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(e) {
  r$.prototype[e] = function(t) {
    var r = t.zrX, n = t.zrY, i = n$(this, r, n), o, a;
    if ((e !== "mouseup" || !i) && (o = this.findHover(r, n), a = o.target), e === "mousedown")
      this._downEl = a, this._downPoint = [t.zrX, t.zrY], this._upEl = a;
    else if (e === "mouseup")
      this._upEl = a;
    else if (e === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || Es(this._downPoint, [t.zrX, t.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(o, e, t);
  };
});
function age(e, t, r) {
  if (e[e.rectHover ? "rectContain" : "contain"](t, r)) {
    for (var n = e, i = void 0, o = !1; n; ) {
      if (n.ignoreClip && (o = !0), !o) {
        var a = n.getClipPath();
        if (a && !a.contain(t, r))
          return !1;
      }
      n.silent && (i = !0);
      var s = n.__hostTarget;
      n = s || n.parent;
    }
    return i ? t$ : !0;
  }
  return !1;
}
function EL(e, t, r, n, i) {
  for (var o = e.length - 1; o >= 0; o--) {
    var a = e[o], s = void 0;
    if (a !== i && !a.ignore && (s = age(a, r, n)) && (!t.topTarget && (t.topTarget = a), s !== t$)) {
      t.target = a;
      break;
    }
  }
}
function n$(e, t, r) {
  var n = e.painter;
  return t < 0 || t > n.getWidth() || r < 0 || r > n.getHeight();
}
var i$ = 32, Uf = 7;
function sge(e) {
  for (var t = 0; e >= i$; )
    t |= e & 1, e >>= 1;
  return e + t;
}
function RL(e, t, r, n) {
  var i = t + 1;
  if (i === r)
    return 1;
  if (n(e[i++], e[t]) < 0) {
    for (; i < r && n(e[i], e[i - 1]) < 0; )
      i++;
    lge(e, t, i);
  } else
    for (; i < r && n(e[i], e[i - 1]) >= 0; )
      i++;
  return i - t;
}
function lge(e, t, r) {
  for (r--; t < r; ) {
    var n = e[t];
    e[t++] = e[r], e[r--] = n;
  }
}
function _L(e, t, r, n, i) {
  for (n === t && n++; n < r; n++) {
    for (var o = e[n], a = t, s = n, l; a < s; )
      l = a + s >>> 1, i(o, e[l]) < 0 ? s = l : a = l + 1;
    var u = n - a;
    switch (u) {
      case 3:
        e[a + 3] = e[a + 2];
      case 2:
        e[a + 2] = e[a + 1];
      case 1:
        e[a + 1] = e[a];
        break;
      default:
        for (; u > 0; )
          e[a + u] = e[a + u - 1], u--;
    }
    e[a] = o;
  }
}
function Sb(e, t, r, n, i, o) {
  var a = 0, s = 0, l = 1;
  if (o(e, t[r + i]) > 0) {
    for (s = n - i; l < s && o(e, t[r + i + l]) > 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), a += i, l += i;
  } else {
    for (s = i + 1; l < s && o(e, t[r + i - l]) <= 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = a;
    a = i - l, l = i - u;
  }
  for (a++; a < l; ) {
    var c = a + (l - a >>> 1);
    o(e, t[r + c]) > 0 ? a = c + 1 : l = c;
  }
  return l;
}
function wb(e, t, r, n, i, o) {
  var a = 0, s = 0, l = 1;
  if (o(e, t[r + i]) < 0) {
    for (s = i + 1; l < s && o(e, t[r + i - l]) < 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = a;
    a = i - l, l = i - u;
  } else {
    for (s = n - i; l < s && o(e, t[r + i + l]) >= 0; )
      a = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), a += i, l += i;
  }
  for (a++; a < l; ) {
    var c = a + (l - a >>> 1);
    o(e, t[r + c]) < 0 ? l = c : a = c + 1;
  }
  return l;
}
function uge(e, t) {
  var r = Uf, n, i, o = 0, a = [];
  n = [], i = [];
  function s(f, p) {
    n[o] = f, i[o] = p, o += 1;
  }
  function l() {
    for (; o > 1; ) {
      var f = o - 2;
      if (f >= 1 && i[f - 1] <= i[f] + i[f + 1] || f >= 2 && i[f - 2] <= i[f] + i[f - 1])
        i[f - 1] < i[f + 1] && f--;
      else if (i[f] > i[f + 1])
        break;
      c(f);
    }
  }
  function u() {
    for (; o > 1; ) {
      var f = o - 2;
      f > 0 && i[f - 1] < i[f + 1] && f--, c(f);
    }
  }
  function c(f) {
    var p = n[f], g = i[f], v = n[f + 1], m = i[f + 1];
    i[f] = g + m, f === o - 3 && (n[f + 1] = n[f + 2], i[f + 1] = i[f + 2]), o--;
    var y = wb(e[v], e, p, g, 0, t);
    p += y, g -= y, g !== 0 && (m = Sb(e[p + g - 1], e, v, m, m - 1, t), m !== 0 && (g <= m ? d(p, g, v, m) : h(p, g, v, m)));
  }
  function d(f, p, g, v) {
    var m = 0;
    for (m = 0; m < p; m++)
      a[m] = e[f + m];
    var y = 0, C = g, S = f;
    if (e[S++] = e[C++], --v === 0) {
      for (m = 0; m < p; m++)
        e[S + m] = a[y + m];
      return;
    }
    if (p === 1) {
      for (m = 0; m < v; m++)
        e[S + m] = e[C + m];
      e[S + v] = a[y];
      return;
    }
    for (var b = r, w, x, E; ; ) {
      w = 0, x = 0, E = !1;
      do
        if (t(e[C], a[y]) < 0) {
          if (e[S++] = e[C++], x++, w = 0, --v === 0) {
            E = !0;
            break;
          }
        } else if (e[S++] = a[y++], w++, x = 0, --p === 1) {
          E = !0;
          break;
        }
      while ((w | x) < b);
      if (E)
        break;
      do {
        if (w = wb(e[C], a, y, p, 0, t), w !== 0) {
          for (m = 0; m < w; m++)
            e[S + m] = a[y + m];
          if (S += w, y += w, p -= w, p <= 1) {
            E = !0;
            break;
          }
        }
        if (e[S++] = e[C++], --v === 0) {
          E = !0;
          break;
        }
        if (x = Sb(a[y], e, C, v, 0, t), x !== 0) {
          for (m = 0; m < x; m++)
            e[S + m] = e[C + m];
          if (S += x, C += x, v -= x, v === 0) {
            E = !0;
            break;
          }
        }
        if (e[S++] = a[y++], --p === 1) {
          E = !0;
          break;
        }
        b--;
      } while (w >= Uf || x >= Uf);
      if (E)
        break;
      b < 0 && (b = 0), b += 2;
    }
    if (r = b, r < 1 && (r = 1), p === 1) {
      for (m = 0; m < v; m++)
        e[S + m] = e[C + m];
      e[S + v] = a[y];
    } else {
      if (p === 0)
        throw new Error();
      for (m = 0; m < p; m++)
        e[S + m] = a[y + m];
    }
  }
  function h(f, p, g, v) {
    var m = 0;
    for (m = 0; m < v; m++)
      a[m] = e[g + m];
    var y = f + p - 1, C = v - 1, S = g + v - 1, b = 0, w = 0;
    if (e[S--] = e[y--], --p === 0) {
      for (b = S - (v - 1), m = 0; m < v; m++)
        e[b + m] = a[m];
      return;
    }
    if (v === 1) {
      for (S -= p, y -= p, w = S + 1, b = y + 1, m = p - 1; m >= 0; m--)
        e[w + m] = e[b + m];
      e[S] = a[C];
      return;
    }
    for (var x = r; ; ) {
      var E = 0, R = 0, _ = !1;
      do
        if (t(a[C], e[y]) < 0) {
          if (e[S--] = e[y--], E++, R = 0, --p === 0) {
            _ = !0;
            break;
          }
        } else if (e[S--] = a[C--], R++, E = 0, --v === 1) {
          _ = !0;
          break;
        }
      while ((E | R) < x);
      if (_)
        break;
      do {
        if (E = p - wb(a[C], e, f, p, p - 1, t), E !== 0) {
          for (S -= E, y -= E, p -= E, w = S + 1, b = y + 1, m = E - 1; m >= 0; m--)
            e[w + m] = e[b + m];
          if (p === 0) {
            _ = !0;
            break;
          }
        }
        if (e[S--] = a[C--], --v === 1) {
          _ = !0;
          break;
        }
        if (R = v - Sb(e[y], a, 0, v, v - 1, t), R !== 0) {
          for (S -= R, C -= R, v -= R, w = S + 1, b = C + 1, m = 0; m < R; m++)
            e[w + m] = a[b + m];
          if (v <= 1) {
            _ = !0;
            break;
          }
        }
        if (e[S--] = e[y--], --p === 0) {
          _ = !0;
          break;
        }
        x--;
      } while (E >= Uf || R >= Uf);
      if (_)
        break;
      x < 0 && (x = 0), x += 2;
    }
    if (r = x, r < 1 && (r = 1), v === 1) {
      for (S -= p, y -= p, w = S + 1, b = y + 1, m = p - 1; m >= 0; m--)
        e[w + m] = e[b + m];
      e[S] = a[C];
    } else {
      if (v === 0)
        throw new Error();
      for (b = S - (v - 1), m = 0; m < v; m++)
        e[b + m] = a[m];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function Zy(e, t, r, n) {
  r || (r = 0), n || (n = e.length);
  var i = n - r;
  if (!(i < 2)) {
    var o = 0;
    if (i < i$) {
      o = RL(e, r, n, t), _L(e, r, n, r + o, t);
      return;
    }
    var a = uge(e, t), s = sge(i);
    do {
      if (o = RL(e, r, n, t), o < s) {
        var l = i;
        l > s && (l = s), _L(e, r, r + l, r + o, t), o = l;
      }
      a.pushRun(r, o), a.mergeRuns(), i -= o, r += o;
    } while (i !== 0);
    a.forceMergeRuns();
  }
}
var qi = 1, xp = 2, Wd = 4, TL = !1;
function bb() {
  TL || (TL = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function PL(e, t) {
  return e.zlevel === t.zlevel ? e.z === t.z ? e.z2 - t.z2 : e.z - t.z : e.zlevel - t.zlevel;
}
var cge = function() {
  function e() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = PL;
  }
  return e.prototype.traverse = function(t, r) {
    for (var n = 0; n < this._roots.length; n++)
      this._roots[n].traverse(t, r);
  }, e.prototype.getDisplayList = function(t, r) {
    r = r || !1;
    var n = this._displayList;
    return (t || !n.length) && this.updateDisplayList(r), n;
  }, e.prototype.updateDisplayList = function(t) {
    this._displayListLen = 0;
    for (var r = this._roots, n = this._displayList, i = 0, o = r.length; i < o; i++)
      this._updateAndAddDisplayable(r[i], null, t);
    n.length = this._displayListLen, Zy(n, PL);
  }, e.prototype._updateAndAddDisplayable = function(t, r, n) {
    if (!(t.ignore && !n)) {
      t.beforeUpdate(), t.update(), t.afterUpdate();
      var i = t.getClipPath();
      if (t.ignoreClip)
        r = null;
      else if (i) {
        r ? r = r.slice() : r = [];
        for (var o = i, a = t; o; )
          o.parent = a, o.updateTransform(), r.push(o), a = o, o = o.getClipPath();
      }
      if (t.childrenRef) {
        for (var s = t.childrenRef(), l = 0; l < s.length; l++) {
          var u = s[l];
          t.__dirty && (u.__dirty |= qi), this._updateAndAddDisplayable(u, r, n);
        }
        t.__dirty = 0;
      } else {
        var c = t;
        r && r.length ? c.__clipPaths = r : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []), isNaN(c.z) && (bb(), c.z = 0), isNaN(c.z2) && (bb(), c.z2 = 0), isNaN(c.zlevel) && (bb(), c.zlevel = 0), this._displayList[this._displayListLen++] = c;
      }
      var d = t.getDecalElement && t.getDecalElement();
      d && this._updateAndAddDisplayable(d, r, n);
      var h = t.getTextGuideLine();
      h && this._updateAndAddDisplayable(h, r, n);
      var f = t.getTextContent();
      f && this._updateAndAddDisplayable(f, r, n);
    }
  }, e.prototype.addRoot = function(t) {
    t.__zr && t.__zr.storage === this || this._roots.push(t);
  }, e.prototype.delRoot = function(t) {
    if (t instanceof Array) {
      for (var r = 0, n = t.length; r < n; r++)
        this.delRoot(t[r]);
      return;
    }
    var i = bt(this._roots, t);
    i >= 0 && this._roots.splice(i, 1);
  }, e.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, e.prototype.getRoots = function() {
    return this._roots;
  }, e.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, e;
}(), B0;
B0 = kt.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(e) {
  return setTimeout(e, 16);
};
var qp = {
  linear: function(e) {
    return e;
  },
  quadraticIn: function(e) {
    return e * e;
  },
  quadraticOut: function(e) {
    return e * (2 - e);
  },
  quadraticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
  },
  cubicIn: function(e) {
    return e * e * e;
  },
  cubicOut: function(e) {
    return --e * e * e + 1;
  },
  cubicInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
  },
  quarticIn: function(e) {
    return e * e * e * e;
  },
  quarticOut: function(e) {
    return 1 - --e * e * e * e;
  },
  quarticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
  },
  quinticIn: function(e) {
    return e * e * e * e * e;
  },
  quinticOut: function(e) {
    return --e * e * e * e * e + 1;
  },
  quinticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
  },
  sinusoidalIn: function(e) {
    return 1 - Math.cos(e * Math.PI / 2);
  },
  sinusoidalOut: function(e) {
    return Math.sin(e * Math.PI / 2);
  },
  sinusoidalInOut: function(e) {
    return 0.5 * (1 - Math.cos(Math.PI * e));
  },
  exponentialIn: function(e) {
    return e === 0 ? 0 : Math.pow(1024, e - 1);
  },
  exponentialOut: function(e) {
    return e === 1 ? 1 : 1 - Math.pow(2, -10 * e);
  },
  exponentialInOut: function(e) {
    return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? 0.5 * Math.pow(1024, e - 1) : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2);
  },
  circularIn: function(e) {
    return 1 - Math.sqrt(1 - e * e);
  },
  circularOut: function(e) {
    return Math.sqrt(1 - --e * e);
  },
  circularInOut: function(e) {
    return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
  },
  elasticIn: function(e) {
    var t, r = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!r || r < 1 ? (r = 1, t = n / 4) : t = n * Math.asin(1 / r) / (2 * Math.PI), -(r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)));
  },
  elasticOut: function(e) {
    var t, r = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!r || r < 1 ? (r = 1, t = n / 4) : t = n * Math.asin(1 / r) / (2 * Math.PI), r * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / n) + 1);
  },
  elasticInOut: function(e) {
    var t, r = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!r || r < 1 ? (r = 1, t = n / 4) : t = n * Math.asin(1 / r) / (2 * Math.PI), (e *= 2) < 1 ? -0.5 * (r * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)) : r * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n) * 0.5 + 1);
  },
  backIn: function(e) {
    var t = 1.70158;
    return e * e * ((t + 1) * e - t);
  },
  backOut: function(e) {
    var t = 1.70158;
    return --e * e * ((t + 1) * e + t) + 1;
  },
  backInOut: function(e) {
    var t = 2.5949095;
    return (e *= 2) < 1 ? 0.5 * (e * e * ((t + 1) * e - t)) : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
  },
  bounceIn: function(e) {
    return 1 - qp.bounceOut(1 - e);
  },
  bounceOut: function(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  bounceInOut: function(e) {
    return e < 0.5 ? qp.bounceIn(e * 2) * 0.5 : qp.bounceOut(e * 2 - 1) * 0.5 + 0.5;
  }
}, _m = Math.pow, Il = Math.sqrt, G0 = 1e-8, o$ = 1e-4, ML = Il(3), Tm = 1 / 3, Ba = ru(), xo = ru(), fh = ru();
function Rl(e) {
  return e > -G0 && e < G0;
}
function a$(e) {
  return e > G0 || e < -G0;
}
function Sn(e, t, r, n, i) {
  var o = 1 - i;
  return o * o * (o * e + 3 * i * t) + i * i * (i * n + 3 * o * r);
}
function DL(e, t, r, n, i) {
  var o = 1 - i;
  return 3 * (((t - e) * o + 2 * (r - t) * i) * o + (n - r) * i * i);
}
function H0(e, t, r, n, i, o) {
  var a = n + 3 * (t - r) - e, s = 3 * (r - t * 2 + e), l = 3 * (t - e), u = e - i, c = s * s - 3 * a * l, d = s * l - 9 * a * u, h = l * l - 3 * s * u, f = 0;
  if (Rl(c) && Rl(d))
    if (Rl(s))
      o[0] = 0;
    else {
      var p = -l / s;
      p >= 0 && p <= 1 && (o[f++] = p);
    }
  else {
    var g = d * d - 4 * c * h;
    if (Rl(g)) {
      var v = d / c, p = -s / a + v, m = -v / 2;
      p >= 0 && p <= 1 && (o[f++] = p), m >= 0 && m <= 1 && (o[f++] = m);
    } else if (g > 0) {
      var y = Il(g), C = c * s + 1.5 * a * (-d + y), S = c * s + 1.5 * a * (-d - y);
      C < 0 ? C = -_m(-C, Tm) : C = _m(C, Tm), S < 0 ? S = -_m(-S, Tm) : S = _m(S, Tm);
      var p = (-s - (C + S)) / (3 * a);
      p >= 0 && p <= 1 && (o[f++] = p);
    } else {
      var b = (2 * c * s - 3 * a * d) / (2 * Il(c * c * c)), w = Math.acos(b) / 3, x = Il(c), E = Math.cos(w), p = (-s - 2 * x * E) / (3 * a), m = (-s + x * (E + ML * Math.sin(w))) / (3 * a), R = (-s + x * (E - ML * Math.sin(w))) / (3 * a);
      p >= 0 && p <= 1 && (o[f++] = p), m >= 0 && m <= 1 && (o[f++] = m), R >= 0 && R <= 1 && (o[f++] = R);
    }
  }
  return f;
}
function s$(e, t, r, n, i) {
  var o = 6 * r - 12 * t + 6 * e, a = 9 * t + 3 * n - 3 * e - 9 * r, s = 3 * t - 3 * e, l = 0;
  if (Rl(a)) {
    if (a$(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = o * o - 4 * a * s;
    if (Rl(c))
      i[0] = -o / (2 * a);
    else if (c > 0) {
      var d = Il(c), u = (-o + d) / (2 * a), h = (-o - d) / (2 * a);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function Wl(e, t, r, n, i, o) {
  var a = (t - e) * i + e, s = (r - t) * i + t, l = (n - r) * i + r, u = (s - a) * i + a, c = (l - s) * i + s, d = (c - u) * i + u;
  o[0] = e, o[1] = a, o[2] = u, o[3] = d, o[4] = d, o[5] = c, o[6] = l, o[7] = n;
}
function l$(e, t, r, n, i, o, a, s, l, u, c) {
  var d, h = 5e-3, f = 1 / 0, p, g, v, m;
  Ba[0] = l, Ba[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    xo[0] = Sn(e, r, i, a, y), xo[1] = Sn(t, n, o, s, y), v = Al(Ba, xo), v < f && (d = y, f = v);
  f = 1 / 0;
  for (var C = 0; C < 32 && !(h < o$); C++)
    p = d - h, g = d + h, xo[0] = Sn(e, r, i, a, p), xo[1] = Sn(t, n, o, s, p), v = Al(xo, Ba), p >= 0 && v < f ? (d = p, f = v) : (fh[0] = Sn(e, r, i, a, g), fh[1] = Sn(t, n, o, s, g), m = Al(fh, Ba), g <= 1 && m < f ? (d = g, f = m) : h *= 0.5);
  return c && (c[0] = Sn(e, r, i, a, d), c[1] = Sn(t, n, o, s, d)), Il(f);
}
function dge(e, t, r, n, i, o, a, s, l) {
  for (var u = e, c = t, d = 0, h = 1 / l, f = 1; f <= l; f++) {
    var p = f * h, g = Sn(e, r, i, a, p), v = Sn(t, n, o, s, p), m = g - u, y = v - c;
    d += Math.sqrt(m * m + y * y), u = g, c = v;
  }
  return d;
}
function Pn(e, t, r, n) {
  var i = 1 - n;
  return i * (i * e + 2 * n * t) + n * n * r;
}
function LR(e, t, r, n) {
  return 2 * ((1 - n) * (t - e) + n * (r - t));
}
function hge(e, t, r, n, i) {
  var o = e - 2 * t + r, a = 2 * (t - e), s = e - n, l = 0;
  if (Rl(o)) {
    if (a$(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (i[l++] = u);
    }
  } else {
    var c = a * a - 4 * o * s;
    if (Rl(c)) {
      var u = -a / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u);
    } else if (c > 0) {
      var d = Il(c), u = (-a + d) / (2 * o), h = (-a - d) / (2 * o);
      u >= 0 && u <= 1 && (i[l++] = u), h >= 0 && h <= 1 && (i[l++] = h);
    }
  }
  return l;
}
function u$(e, t, r) {
  var n = e + r - 2 * t;
  return n === 0 ? 0.5 : (e - t) / n;
}
function Ig(e, t, r, n, i) {
  var o = (t - e) * n + e, a = (r - t) * n + t, s = (a - o) * n + o;
  i[0] = e, i[1] = o, i[2] = s, i[3] = s, i[4] = a, i[5] = r;
}
function c$(e, t, r, n, i, o, a, s, l) {
  var u, c = 5e-3, d = 1 / 0;
  Ba[0] = a, Ba[1] = s;
  for (var h = 0; h < 1; h += 0.05) {
    xo[0] = Pn(e, r, i, h), xo[1] = Pn(t, n, o, h);
    var f = Al(Ba, xo);
    f < d && (u = h, d = f);
  }
  d = 1 / 0;
  for (var p = 0; p < 32 && !(c < o$); p++) {
    var g = u - c, v = u + c;
    xo[0] = Pn(e, r, i, g), xo[1] = Pn(t, n, o, g);
    var f = Al(xo, Ba);
    if (g >= 0 && f < d)
      u = g, d = f;
    else {
      fh[0] = Pn(e, r, i, v), fh[1] = Pn(t, n, o, v);
      var m = Al(fh, Ba);
      v <= 1 && m < d ? (u = v, d = m) : c *= 0.5;
    }
  }
  return l && (l[0] = Pn(e, r, i, u), l[1] = Pn(t, n, o, u)), Il(d);
}
function fge(e, t, r, n, i, o, a) {
  for (var s = e, l = t, u = 0, c = 1 / a, d = 1; d <= a; d++) {
    var h = d * c, f = Pn(e, r, i, h), p = Pn(t, n, o, h), g = f - s, v = p - l;
    u += Math.sqrt(g * g + v * v), s = f, l = p;
  }
  return u;
}
var pge = /cubic-bezier\(([0-9,\.e ]+)\)/;
function tM(e) {
  var t = e && pge.exec(e);
  if (t) {
    var r = t[1].split(","), n = +_o(r[0]), i = +_o(r[1]), o = +_o(r[2]), a = +_o(r[3]);
    if (isNaN(n + i + o + a))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : H0(0, n, o, 1, l, s) && Sn(0, i, a, 1, s[0]);
    };
  }
}
var gge = function() {
  function e(t) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || Kr, this.ondestroy = t.ondestroy || Kr, this.onrestart = t.onrestart || Kr, t.easing && this.setEasing(t.easing);
  }
  return e.prototype.step = function(t, r) {
    if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += r;
      return;
    }
    var n = this._life, i = t - this._startTime - this._pausedTime, o = i / n;
    o < 0 && (o = 0), o = Math.min(o, 1);
    var a = this.easingFunc, s = a ? a(o) : o;
    if (this.onframe(s), o === 1)
      if (this.loop) {
        var l = i % n;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, e.prototype.pause = function() {
    this._paused = !0;
  }, e.prototype.resume = function() {
    this._paused = !1;
  }, e.prototype.setEasing = function(t) {
    this.easing = t, this.easingFunc = Ye(t) ? t : qp[t] || tM(t);
  }, e;
}(), d$ = /* @__PURE__ */ function() {
  function e(t) {
    this.value = t;
  }
  return e;
}(), vge = function() {
  function e() {
    this._len = 0;
  }
  return e.prototype.insert = function(t) {
    var r = new d$(t);
    return this.insertEntry(r), r;
  }, e.prototype.insertEntry = function(t) {
    this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, e.prototype.remove = function(t) {
    var r = t.prev, n = t.next;
    r ? r.next = n : this.head = n, n ? n.prev = r : this.tail = r, t.next = t.prev = null, this._len--;
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, e;
}(), Rv = function() {
  function e(t) {
    this._list = new vge(), this._maxSize = 10, this._map = {}, this._maxSize = t;
  }
  return e.prototype.put = function(t, r) {
    var n = this._list, i = this._map, o = null;
    if (i[t] == null) {
      var a = n.len(), s = this._lastRemovedEntry;
      if (a >= this._maxSize && a > 0) {
        var l = n.head;
        n.remove(l), delete i[l.key], o = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = r : s = new d$(r), s.key = t, n.insertEntry(s), i[t] = s;
    }
    return o;
  }, e.prototype.get = function(t) {
    var r = this._map[t], n = this._list;
    if (r != null)
      return r !== n.tail && (n.remove(r), n.insertEntry(r)), r.value;
  }, e.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, e.prototype.len = function() {
    return this._list.len();
  }, e;
}(), AL = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function da(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 255 ? 255 : e;
}
function mge(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 360 ? 360 : e;
}
function Fg(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function xb(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? da(parseFloat(t) / 100 * 255) : da(parseInt(t, 10));
}
function dc(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? Fg(parseFloat(t) / 100) : Fg(parseFloat(t));
}
function Eb(e, t, r) {
  return r < 0 ? r += 1 : r > 1 && (r -= 1), r * 6 < 1 ? e + (t - e) * r * 6 : r * 2 < 1 ? t : r * 3 < 2 ? e + (t - e) * (2 / 3 - r) * 6 : e;
}
function _l(e, t, r) {
  return e + (t - e) * r;
}
function mo(e, t, r, n, i) {
  return e[0] = t, e[1] = r, e[2] = n, e[3] = i, e;
}
function OR(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
}
var h$ = new Rv(20), Pm = null;
function yd(e, t) {
  Pm && OR(Pm, t), Pm = h$.put(e, Pm || t.slice());
}
function yi(e, t) {
  if (e) {
    t = t || [];
    var r = h$.get(e);
    if (r)
      return OR(t, r);
    e = e + "";
    var n = e.replace(/ /g, "").toLowerCase();
    if (n in AL)
      return OR(t, AL[n]), yd(e, t), t;
    var i = n.length;
    if (n.charAt(0) === "#") {
      if (i === 4 || i === 5) {
        var o = parseInt(n.slice(1, 4), 16);
        if (!(o >= 0 && o <= 4095)) {
          mo(t, 0, 0, 0, 1);
          return;
        }
        return mo(t, (o & 3840) >> 4 | (o & 3840) >> 8, o & 240 | (o & 240) >> 4, o & 15 | (o & 15) << 4, i === 5 ? parseInt(n.slice(4), 16) / 15 : 1), yd(e, t), t;
      } else if (i === 7 || i === 9) {
        var o = parseInt(n.slice(1, 7), 16);
        if (!(o >= 0 && o <= 16777215)) {
          mo(t, 0, 0, 0, 1);
          return;
        }
        return mo(t, (o & 16711680) >> 16, (o & 65280) >> 8, o & 255, i === 9 ? parseInt(n.slice(7), 16) / 255 : 1), yd(e, t), t;
      }
      return;
    }
    var a = n.indexOf("("), s = n.indexOf(")");
    if (a !== -1 && s + 1 === i) {
      var l = n.substr(0, a), u = n.substr(a + 1, s - (a + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? mo(t, +u[0], +u[1], +u[2], 1) : mo(t, 0, 0, 0, 1);
          c = dc(u.pop());
        case "rgb":
          if (u.length >= 3)
            return mo(t, xb(u[0]), xb(u[1]), xb(u[2]), u.length === 3 ? c : dc(u[3])), yd(e, t), t;
          mo(t, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            mo(t, 0, 0, 0, 1);
            return;
          }
          return u[3] = dc(u[3]), NR(u, t), yd(e, t), t;
        case "hsl":
          if (u.length !== 3) {
            mo(t, 0, 0, 0, 1);
            return;
          }
          return NR(u, t), yd(e, t), t;
        default:
          return;
      }
    }
    mo(t, 0, 0, 0, 1);
  }
}
function NR(e, t) {
  var r = (parseFloat(e[0]) % 360 + 360) % 360 / 360, n = dc(e[1]), i = dc(e[2]), o = i <= 0.5 ? i * (n + 1) : i + n - i * n, a = i * 2 - o;
  return t = t || [], mo(t, da(Eb(a, o, r + 1 / 3) * 255), da(Eb(a, o, r) * 255), da(Eb(a, o, r - 1 / 3) * 255), 1), e.length === 4 && (t[3] = e[3]), t;
}
function yge(e) {
  if (e) {
    var t = e[0] / 255, r = e[1] / 255, n = e[2] / 255, i = Math.min(t, r, n), o = Math.max(t, r, n), a = o - i, s = (o + i) / 2, l, u;
    if (a === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = a / (o + i) : u = a / (2 - o - i);
      var c = ((o - t) / 6 + a / 2) / a, d = ((o - r) / 6 + a / 2) / a, h = ((o - n) / 6 + a / 2) / a;
      t === o ? l = h - d : r === o ? l = 1 / 3 + c - h : n === o && (l = 2 / 3 + d - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var f = [l * 360, u, s];
    return e[3] != null && f.push(e[3]), f;
  }
}
function z0(e, t) {
  var r = yi(e);
  if (r) {
    for (var n = 0; n < 3; n++)
      t < 0 ? r[n] = r[n] * (1 - t) | 0 : r[n] = (255 - r[n]) * t + r[n] | 0, r[n] > 255 ? r[n] = 255 : r[n] < 0 && (r[n] = 0);
    return ha(r, r.length === 4 ? "rgba" : "rgb");
  }
}
function Cge(e) {
  var t = yi(e);
  if (t)
    return ((1 << 24) + (t[0] << 16) + (t[1] << 8) + +t[2]).toString(16).slice(1);
}
function Zp(e, t, r) {
  if (!(!(t && t.length) || !(e >= 0 && e <= 1))) {
    r = r || [];
    var n = e * (t.length - 1), i = Math.floor(n), o = Math.ceil(n), a = t[i], s = t[o], l = n - i;
    return r[0] = da(_l(a[0], s[0], l)), r[1] = da(_l(a[1], s[1], l)), r[2] = da(_l(a[2], s[2], l)), r[3] = Fg(_l(a[3], s[3], l)), r;
  }
}
var Sge = Zp;
function rM(e, t, r) {
  if (!(!(t && t.length) || !(e >= 0 && e <= 1))) {
    var n = e * (t.length - 1), i = Math.floor(n), o = Math.ceil(n), a = yi(t[i]), s = yi(t[o]), l = n - i, u = ha([
      da(_l(a[0], s[0], l)),
      da(_l(a[1], s[1], l)),
      da(_l(a[2], s[2], l)),
      Fg(_l(a[3], s[3], l))
    ], "rgba");
    return r ? {
      color: u,
      leftIndex: i,
      rightIndex: o,
      value: n
    } : u;
  }
}
var wge = rM;
function ph(e, t, r, n) {
  var i = yi(e);
  if (e)
    return i = yge(i), t != null && (i[0] = mge(t)), r != null && (i[1] = dc(r)), n != null && (i[2] = dc(n)), ha(NR(i), "rgba");
}
function Lg(e, t) {
  var r = yi(e);
  if (r && t != null)
    return r[3] = Fg(t), ha(r, "rgba");
}
function ha(e, t) {
  if (!(!e || !e.length)) {
    var r = e[0] + "," + e[1] + "," + e[2];
    return (t === "rgba" || t === "hsva" || t === "hsla") && (r += "," + e[3]), t + "(" + r + ")";
  }
}
function Og(e, t) {
  var r = yi(e);
  return r ? (0.299 * r[0] + 0.587 * r[1] + 0.114 * r[2]) * r[3] / 255 + (1 - r[3]) * t : 0;
}
function bge() {
  return ha([
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255),
    Math.round(Math.random() * 255)
  ], "rgb");
}
var IL = new Rv(100);
function $0(e) {
  if (Fe(e)) {
    var t = IL.get(e);
    return t || (t = z0(e, -0.1), IL.put(e, t)), t;
  } else if (bv(e)) {
    var r = se({}, e);
    return r.colorStops = ge(e.colorStops, function(n) {
      return {
        offset: n.offset,
        color: z0(n.color, -0.1)
      };
    }), r;
  }
  return e;
}
const xge = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fastLerp: Zp,
  fastMapToColor: Sge,
  lerp: rM,
  lift: z0,
  liftColor: $0,
  lum: Og,
  mapToColor: wge,
  modifyAlpha: Lg,
  modifyHSL: ph,
  parse: yi,
  random: bge,
  stringify: ha,
  toHex: Cge
}, Symbol.toStringTag, { value: "Module" }));
var W0 = Math.round;
function Ng(e) {
  var t;
  if (!e || e === "transparent")
    e = "none";
  else if (typeof e == "string" && e.indexOf("rgba") > -1) {
    var r = yi(e);
    r && (e = "rgb(" + r[0] + "," + r[1] + "," + r[2] + ")", t = r[3]);
  }
  return {
    color: e,
    opacity: t ?? 1
  };
}
var FL = 1e-4;
function Tl(e) {
  return e < FL && e > -FL;
}
function Mm(e) {
  return W0(e * 1e3) / 1e3;
}
function kR(e) {
  return W0(e * 1e4) / 1e4;
}
function Ege(e) {
  return "matrix(" + Mm(e[0]) + "," + Mm(e[1]) + "," + Mm(e[2]) + "," + Mm(e[3]) + "," + kR(e[4]) + "," + kR(e[5]) + ")";
}
var Rge = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function _ge(e, t, r) {
  return r === "top" ? e += t / 2 : r === "bottom" && (e -= t / 2), e;
}
function Tge(e) {
  return e && (e.shadowBlur || e.shadowOffsetX || e.shadowOffsetY);
}
function Pge(e) {
  var t = e.style, r = e.getGlobalScale();
  return [
    t.shadowColor,
    (t.shadowBlur || 0).toFixed(2),
    (t.shadowOffsetX || 0).toFixed(2),
    (t.shadowOffsetY || 0).toFixed(2),
    r[0],
    r[1]
  ].join(",");
}
function f$(e) {
  return e && !!e.image;
}
function Mge(e) {
  return e && !!e.svgElement;
}
function nM(e) {
  return f$(e) || Mge(e);
}
function p$(e) {
  return e.type === "linear";
}
function g$(e) {
  return e.type === "radial";
}
function v$(e) {
  return e && (e.type === "linear" || e.type === "radial");
}
function _S(e) {
  return "url(#" + e + ")";
}
function m$(e) {
  var t = e.getGlobalScale(), r = Math.max(t[0], t[1]);
  return Math.max(Math.ceil(Math.log(r) / Math.log(10)), 1);
}
function y$(e) {
  var t = e.x || 0, r = e.y || 0, n = (e.rotation || 0) * Up, i = st(e.scaleX, 1), o = st(e.scaleY, 1), a = e.skewX || 0, s = e.skewY || 0, l = [];
  return (t || r) && l.push("translate(" + t + "px," + r + "px)"), n && l.push("rotate(" + n + ")"), (i !== 1 || o !== 1) && l.push("scale(" + i + "," + o + ")"), (a || s) && l.push("skew(" + W0(a * Up) + "deg, " + W0(s * Up) + "deg)"), l.join(" ");
}
var Dge = function() {
  return kt.hasGlobalWindow && Ye(window.btoa) ? function(e) {
    return window.btoa(unescape(encodeURIComponent(e)));
  } : typeof Buffer < "u" ? function(e) {
    return Buffer.from(e).toString("base64");
  } : function(e) {
    return process.env.NODE_ENV !== "production" && Mo("Base64 isn't natively supported in the current environment."), null;
  };
}(), VR = Array.prototype.slice;
function Cs(e, t, r) {
  return (t - e) * r + e;
}
function Rb(e, t, r, n) {
  for (var i = t.length, o = 0; o < i; o++)
    e[o] = Cs(t[o], r[o], n);
  return e;
}
function Age(e, t, r, n) {
  for (var i = t.length, o = i && t[0].length, a = 0; a < i; a++) {
    e[a] || (e[a] = []);
    for (var s = 0; s < o; s++)
      e[a][s] = Cs(t[a][s], r[a][s], n);
  }
  return e;
}
function Dm(e, t, r, n) {
  for (var i = t.length, o = 0; o < i; o++)
    e[o] = t[o] + r[o] * n;
  return e;
}
function LL(e, t, r, n) {
  for (var i = t.length, o = i && t[0].length, a = 0; a < i; a++) {
    e[a] || (e[a] = []);
    for (var s = 0; s < o; s++)
      e[a][s] = t[a][s] + r[a][s] * n;
  }
  return e;
}
function Ige(e, t) {
  for (var r = e.length, n = t.length, i = r > n ? t : e, o = Math.min(r, n), a = i[o - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = o; s < Math.max(r, n); s++)
    i.push({
      offset: a.offset,
      color: a.color.slice()
    });
}
function Fge(e, t, r) {
  var n = e, i = t;
  if (!(!n.push || !i.push)) {
    var o = n.length, a = i.length;
    if (o !== a) {
      var s = o > a;
      if (s)
        n.length = a;
      else
        for (var l = o; l < a; l++)
          n.push(r === 1 ? i[l] : VR.call(i[l]));
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (r === 1)
        isNaN(n[l]) && (n[l] = i[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(n[l][c]) && (n[l][c] = i[l][c]);
  }
}
function Xp(e) {
  if (kn(e)) {
    var t = e.length;
    if (kn(e[0])) {
      for (var r = [], n = 0; n < t; n++)
        r.push(VR.call(e[n]));
      return r;
    }
    return VR.call(e);
  }
  return e;
}
function Xy(e) {
  return e[0] = Math.floor(e[0]) || 0, e[1] = Math.floor(e[1]) || 0, e[2] = Math.floor(e[2]) || 0, e[3] = e[3] == null ? 1 : e[3], "rgba(" + e.join(",") + ")";
}
function Lge(e) {
  return kn(e && e[0]) ? 2 : 1;
}
var Am = 0, Qy = 1, C$ = 2, Ep = 3, BR = 4, GR = 5, OL = 6;
function NL(e) {
  return e === BR || e === GR;
}
function Im(e) {
  return e === Qy || e === C$;
}
var Kf = [0, 0, 0, 0], Oge = function() {
  function e(t) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
  }
  return e.prototype.isFinished = function() {
    return this._finished;
  }, e.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, e.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, e.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, e.prototype.addKeyframe = function(t, r, n) {
    this._needsSort = !0;
    var i = this.keyframes, o = i.length, a = !1, s = OL, l = r;
    if (kn(r)) {
      var u = Lge(r);
      s = u, (u === 1 && !$t(r[0]) || u === 2 && !$t(r[0][0])) && (a = !0);
    } else if ($t(r) && !$l(r))
      s = Am;
    else if (Fe(r))
      if (!isNaN(+r))
        s = Am;
      else {
        var c = yi(r);
        c && (l = c, s = Ep);
      }
    else if (bv(r)) {
      var d = se({}, l);
      d.colorStops = ge(r.colorStops, function(f) {
        return {
          offset: f.offset,
          color: yi(f.color)
        };
      }), p$(r) ? s = BR : g$(r) && (s = GR), l = d;
    }
    o === 0 ? this.valType = s : (s !== this.valType || s === OL) && (a = !0), this.discrete = this.discrete || a;
    var h = {
      time: t,
      value: l,
      rawValue: r,
      percent: 0
    };
    return n && (h.easing = n, h.easingFunc = Ye(n) ? n : qp[n] || tM(n)), i.push(h), h;
  }, e.prototype.prepare = function(t, r) {
    var n = this.keyframes;
    this._needsSort && n.sort(function(g, v) {
      return g.time - v.time;
    });
    for (var i = this.valType, o = n.length, a = n[o - 1], s = this.discrete, l = Im(i), u = NL(i), c = 0; c < o; c++) {
      var d = n[c], h = d.value, f = a.value;
      d.percent = d.time / t, s || (l && c !== o - 1 ? Fge(h, f, i) : u && Ige(h.colorStops, f.colorStops));
    }
    if (!s && i !== GR && r && this.needsAnimate() && r.needsAnimate() && i === r.valType && !r._finished) {
      this._additiveTrack = r;
      for (var p = n[0].value, c = 0; c < o; c++)
        i === Am ? n[c].additiveValue = n[c].value - p : i === Ep ? n[c].additiveValue = Dm([], n[c].value, p, -1) : Im(i) && (n[c].additiveValue = i === Qy ? Dm([], n[c].value, p, -1) : LL([], n[c].value, p, -1));
    }
  }, e.prototype.step = function(t, r) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var n = this._additiveTrack != null, i = n ? "additiveValue" : "value", o = this.valType, a = this.keyframes, s = a.length, l = this.propName, u = o === Ep, c, d = this._lastFr, h = Math.min, f, p;
      if (s === 1)
        f = p = a[0];
      else {
        if (r < 0)
          c = 0;
        else if (r < this._lastFrP) {
          var g = h(d + 1, s - 1);
          for (c = g; c >= 0 && !(a[c].percent <= r); c--)
            ;
          c = h(c, s - 2);
        } else {
          for (c = d; c < s && !(a[c].percent > r); c++)
            ;
          c = h(c - 1, s - 2);
        }
        p = a[c + 1], f = a[c];
      }
      if (f && p) {
        this._lastFr = c, this._lastFrP = r;
        var v = p.percent - f.percent, m = v === 0 ? 1 : h((r - f.percent) / v, 1);
        p.easingFunc && (m = p.easingFunc(m));
        var y = n ? this._additiveValue : u ? Kf : t[l];
        if ((Im(o) || u) && !y && (y = this._additiveValue = []), this.discrete)
          t[l] = m < 1 ? f.rawValue : p.rawValue;
        else if (Im(o))
          o === Qy ? Rb(y, f[i], p[i], m) : Age(y, f[i], p[i], m);
        else if (NL(o)) {
          var C = f[i], S = p[i], b = o === BR;
          t[l] = {
            type: b ? "linear" : "radial",
            x: Cs(C.x, S.x, m),
            y: Cs(C.y, S.y, m),
            colorStops: ge(C.colorStops, function(x, E) {
              var R = S.colorStops[E];
              return {
                offset: Cs(x.offset, R.offset, m),
                color: Xy(Rb([], x.color, R.color, m))
              };
            }),
            global: S.global
          }, b ? (t[l].x2 = Cs(C.x2, S.x2, m), t[l].y2 = Cs(C.y2, S.y2, m)) : t[l].r = Cs(C.r, S.r, m);
        } else if (u)
          Rb(y, f[i], p[i], m), n || (t[l] = Xy(y));
        else {
          var w = Cs(f[i], p[i], m);
          n ? this._additiveValue = w : t[l] = w;
        }
        n && this._addToTarget(t);
      }
    }
  }, e.prototype._addToTarget = function(t) {
    var r = this.valType, n = this.propName, i = this._additiveValue;
    r === Am ? t[n] = t[n] + i : r === Ep ? (yi(t[n], Kf), Dm(Kf, Kf, i, 1), t[n] = Xy(Kf)) : r === Qy ? Dm(t[n], t[n], i, 1) : r === C$ && LL(t[n], t[n], i, 1);
  }, e;
}(), iM = function() {
  function e(t, r, n, i) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = r, r && i) {
      Mo("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = i, this._allowDiscrete = n;
  }
  return e.prototype.getMaxTime = function() {
    return this._maxTime;
  }, e.prototype.getDelay = function() {
    return this._delay;
  }, e.prototype.getLoop = function() {
    return this._loop;
  }, e.prototype.getTarget = function() {
    return this._target;
  }, e.prototype.changeTarget = function(t) {
    this._target = t;
  }, e.prototype.when = function(t, r, n) {
    return this.whenWithKeys(t, r, At(r), n);
  }, e.prototype.whenWithKeys = function(t, r, n, i) {
    for (var o = this._tracks, a = 0; a < n.length; a++) {
      var s = n[a], l = o[s];
      if (!l) {
        l = o[s] = new Oge(s);
        var u = void 0, c = this._getAdditiveTrack(s);
        if (c) {
          var d = c.keyframes, h = d[d.length - 1];
          u = h && h.value, c.valType === Ep && u && (u = Xy(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        t > 0 && l.addKeyframe(0, Xp(u), i), this._trackKeys.push(s);
      }
      l.addKeyframe(t, Xp(r[s]), i);
    }
    return this._maxTime = Math.max(this._maxTime, t), this;
  }, e.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, e.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, e.prototype.isPaused = function() {
    return !!this._paused;
  }, e.prototype.duration = function(t) {
    return this._maxTime = t, this._force = !0, this;
  }, e.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var t = this._doneCbs;
    if (t)
      for (var r = t.length, n = 0; n < r; n++)
        t[n].call(this);
  }, e.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var t = this.animation, r = this._abortedCbs;
    if (t && t.removeClip(this._clip), this._clip = null, r)
      for (var n = 0; n < r.length; n++)
        r[n].call(this);
  }, e.prototype._setTracksFinished = function() {
    for (var t = this._tracks, r = this._trackKeys, n = 0; n < r.length; n++)
      t[r[n]].setFinished();
  }, e.prototype._getAdditiveTrack = function(t) {
    var r, n = this._additiveAnimators;
    if (n)
      for (var i = 0; i < n.length; i++) {
        var o = n[i].getTrack(t);
        o && (r = o);
      }
    return r;
  }, e.prototype.start = function(t) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var r = this, n = [], i = this._maxTime || 0, o = 0; o < this._trackKeys.length; o++) {
        var a = this._trackKeys[o], s = this._tracks[a], l = this._getAdditiveTrack(a), u = s.keyframes, c = u.length;
        if (s.prepare(i, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var d = u[c - 1];
            d && (r._target[s.propName] = d.rawValue), s.setFinished();
          } else
            n.push(s);
      }
      if (n.length || this._force) {
        var h = new gge({
          life: i,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(f) {
            r._started = 2;
            var p = r._additiveAnimators;
            if (p) {
              for (var g = !1, v = 0; v < p.length; v++)
                if (p[v]._clip) {
                  g = !0;
                  break;
                }
              g || (r._additiveAnimators = null);
            }
            for (var v = 0; v < n.length; v++)
              n[v].step(r._target, f);
            var m = r._onframeCbs;
            if (m)
              for (var v = 0; v < m.length; v++)
                m[v](r._target, f);
          },
          ondestroy: function() {
            r._doneCallback();
          }
        });
        this._clip = h, this.animation && this.animation.addClip(h), t && h.setEasing(t);
      } else
        this._doneCallback();
      return this;
    }
  }, e.prototype.stop = function(t) {
    if (this._clip) {
      var r = this._clip;
      t && r.onframe(1), this._abortedCallback();
    }
  }, e.prototype.delay = function(t) {
    return this._delay = t, this;
  }, e.prototype.during = function(t) {
    return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
  }, e.prototype.done = function(t) {
    return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
  }, e.prototype.aborted = function(t) {
    return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
  }, e.prototype.getClip = function() {
    return this._clip;
  }, e.prototype.getTrack = function(t) {
    return this._tracks[t];
  }, e.prototype.getTracks = function() {
    var t = this;
    return ge(this._trackKeys, function(r) {
      return t._tracks[r];
    });
  }, e.prototype.stopTracks = function(t, r) {
    if (!t.length || !this._clip)
      return !0;
    for (var n = this._tracks, i = this._trackKeys, o = 0; o < t.length; o++) {
      var a = n[t[o]];
      a && !a.isFinished() && (r ? a.step(this._target, 1) : this._started === 1 && a.step(this._target, 0), a.setFinished());
    }
    for (var s = !0, o = 0; o < i.length; o++)
      if (!n[i[o]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, e.prototype.saveTo = function(t, r, n) {
    if (t) {
      r = r || this._trackKeys;
      for (var i = 0; i < r.length; i++) {
        var o = r[i], a = this._tracks[o];
        if (!(!a || a.isFinished())) {
          var s = a.keyframes, l = s[n ? 0 : s.length - 1];
          l && (t[o] = Xp(l.rawValue));
        }
      }
    }
  }, e.prototype.__changeFinalValue = function(t, r) {
    r = r || At(t);
    for (var n = 0; n < r.length; n++) {
      var i = r[n], o = this._tracks[i];
      if (o) {
        var a = o.keyframes;
        if (a.length > 1) {
          var s = a.pop();
          o.addKeyframe(s.time, t[i]), o.prepare(this._maxTime, o.getAdditiveTrack());
        }
      }
    }
  }, e;
}();
function th() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var Nge = function(e) {
  Mr(t, e);
  function t(r) {
    var n = e.call(this) || this;
    return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, r = r || {}, n.stage = r.stage || {}, n;
  }
  return t.prototype.addClip = function(r) {
    r.animation && this.removeClip(r), this._head ? (this._tail.next = r, r.prev = this._tail, r.next = null, this._tail = r) : this._head = this._tail = r, r.animation = this;
  }, t.prototype.addAnimator = function(r) {
    r.animation = this;
    var n = r.getClip();
    n && this.addClip(n);
  }, t.prototype.removeClip = function(r) {
    if (r.animation) {
      var n = r.prev, i = r.next;
      n ? n.next = i : this._head = i, i ? i.prev = n : this._tail = n, r.next = r.prev = r.animation = null;
    }
  }, t.prototype.removeAnimator = function(r) {
    var n = r.getClip();
    n && this.removeClip(n), r.animation = null;
  }, t.prototype.update = function(r) {
    for (var n = th() - this._pausedTime, i = n - this._time, o = this._head; o; ) {
      var a = o.next, s = o.step(n, i);
      s && (o.ondestroy(), this.removeClip(o)), o = a;
    }
    this._time = n, r || (this.trigger("frame", i), this.stage.update && this.stage.update());
  }, t.prototype._startLoop = function() {
    var r = this;
    this._running = !0;
    function n() {
      r._running && (B0(n), !r._paused && r.update());
    }
    B0(n);
  }, t.prototype.start = function() {
    this._running || (this._time = th(), this._pausedTime = 0, this._startLoop());
  }, t.prototype.stop = function() {
    this._running = !1;
  }, t.prototype.pause = function() {
    this._paused || (this._pauseStart = th(), this._paused = !0);
  }, t.prototype.resume = function() {
    this._paused && (this._pausedTime += th() - this._pauseStart, this._paused = !1);
  }, t.prototype.clear = function() {
    for (var r = this._head; r; ) {
      var n = r.next;
      r.prev = r.next = r.animation = null, r = n;
    }
    this._head = this._tail = null;
  }, t.prototype.isFinished = function() {
    return this._head == null;
  }, t.prototype.animate = function(r, n) {
    n = n || {}, this.start();
    var i = new iM(r, n.loop);
    return this.addAnimator(i), i;
  }, t;
}(Go), kge = 300, _b = kt.domSupported, Tb = function() {
  var e = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], t = [
    "touchstart",
    "touchend",
    "touchmove"
  ], r = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, n = ge(e, function(i) {
    var o = i.replace("mouse", "pointer");
    return r.hasOwnProperty(o) ? o : i;
  });
  return {
    mouse: e,
    touch: t,
    pointer: n
  };
}(), kL = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, VL = !1;
function HR(e) {
  var t = e.pointerType;
  return t === "pen" || t === "touch";
}
function Vge(e) {
  e.touching = !0, e.touchTimer != null && (clearTimeout(e.touchTimer), e.touchTimer = null), e.touchTimer = setTimeout(function() {
    e.touching = !1, e.touchTimer = null;
  }, 700);
}
function Pb(e) {
  e && (e.zrByTouch = !0);
}
function Bge(e, t) {
  return yo(e.dom, new Gge(e, t), !0);
}
function S$(e, t) {
  for (var r = t, n = !1; r && r.nodeType !== 9 && !(n = r.domBelongToZr || r !== t && r === e.painterRoot); )
    r = r.parentNode;
  return n;
}
var Gge = /* @__PURE__ */ function() {
  function e(t, r) {
    this.stopPropagation = Kr, this.stopImmediatePropagation = Kr, this.preventDefault = Kr, this.type = r.type, this.target = this.currentTarget = t.dom, this.pointerType = r.pointerType, this.clientX = r.clientX, this.clientY = r.clientY;
  }
  return e;
}(), Qo = {
  mousedown: function(e) {
    e = yo(this.dom, e), this.__mayPointerCapture = [e.zrX, e.zrY], this.trigger("mousedown", e);
  },
  mousemove: function(e) {
    e = yo(this.dom, e);
    var t = this.__mayPointerCapture;
    t && (e.zrX !== t[0] || e.zrY !== t[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    e = yo(this.dom, e), this.__togglePointerCapture(!1), this.trigger("mouseup", e);
  },
  mouseout: function(e) {
    e = yo(this.dom, e);
    var t = e.toElement || e.relatedTarget;
    S$(this, t) || (this.__pointerCapturing && (e.zrEventControl = "no_globalout"), this.trigger("mouseout", e));
  },
  wheel: function(e) {
    VL = !0, e = yo(this.dom, e), this.trigger("mousewheel", e);
  },
  mousewheel: function(e) {
    VL || (e = yo(this.dom, e), this.trigger("mousewheel", e));
  },
  touchstart: function(e) {
    e = yo(this.dom, e), Pb(e), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(e, "start"), Qo.mousemove.call(this, e), Qo.mousedown.call(this, e);
  },
  touchmove: function(e) {
    e = yo(this.dom, e), Pb(e), this.handler.processGesture(e, "change"), Qo.mousemove.call(this, e);
  },
  touchend: function(e) {
    e = yo(this.dom, e), Pb(e), this.handler.processGesture(e, "end"), Qo.mouseup.call(this, e), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < kge && Qo.click.call(this, e);
  },
  pointerdown: function(e) {
    Qo.mousedown.call(this, e);
  },
  pointermove: function(e) {
    HR(e) || Qo.mousemove.call(this, e);
  },
  pointerup: function(e) {
    Qo.mouseup.call(this, e);
  },
  pointerout: function(e) {
    HR(e) || Qo.mouseout.call(this, e);
  }
};
B(["click", "dblclick", "contextmenu"], function(e) {
  Qo[e] = function(t) {
    t = yo(this.dom, t), this.trigger(e, t);
  };
});
var zR = {
  pointermove: function(e) {
    HR(e) || zR.mousemove.call(this, e);
  },
  pointerup: function(e) {
    zR.mouseup.call(this, e);
  },
  mousemove: function(e) {
    this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    var t = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", e), t && (e.zrEventControl = "only_globalout", this.trigger("mouseout", e));
  }
};
function Hge(e, t) {
  var r = t.domHandlers;
  kt.pointerEventsSupported ? B(Tb.pointer, function(n) {
    Jy(t, n, function(i) {
      r[n].call(e, i);
    });
  }) : (kt.touchEventsSupported && B(Tb.touch, function(n) {
    Jy(t, n, function(i) {
      r[n].call(e, i), Vge(t);
    });
  }), B(Tb.mouse, function(n) {
    Jy(t, n, function(i) {
      i = eM(i), t.touching || r[n].call(e, i);
    });
  }));
}
function zge(e, t) {
  kt.pointerEventsSupported ? B(kL.pointer, r) : kt.touchEventsSupported || B(kL.mouse, r);
  function r(n) {
    function i(o) {
      o = eM(o), S$(e, o.target) || (o = Bge(e, o), t.domHandlers[n].call(e, o));
    }
    Jy(t, n, i, { capture: !0 });
  }
}
function Jy(e, t, r, n) {
  e.mounted[t] = r, e.listenerOpts[t] = n, FR(e.domTarget, t, r, n);
}
function Mb(e) {
  var t = e.mounted;
  for (var r in t)
    t.hasOwnProperty(r) && Xpe(e.domTarget, r, t[r], e.listenerOpts[r]);
  e.mounted = {};
}
var BL = /* @__PURE__ */ function() {
  function e(t, r) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = r;
  }
  return e;
}(), $ge = function(e) {
  Mr(t, e);
  function t(r, n) {
    var i = e.call(this) || this;
    return i.__pointerCapturing = !1, i.dom = r, i.painterRoot = n, i._localHandlerScope = new BL(r, Qo), _b && (i._globalHandlerScope = new BL(document, zR)), Hge(i, i._localHandlerScope), i;
  }
  return t.prototype.dispose = function() {
    Mb(this._localHandlerScope), _b && Mb(this._globalHandlerScope);
  }, t.prototype.setCursor = function(r) {
    this.dom.style && (this.dom.style.cursor = r || "default");
  }, t.prototype.__togglePointerCapture = function(r) {
    if (this.__mayPointerCapture = null, _b && +this.__pointerCapturing ^ +r) {
      this.__pointerCapturing = r;
      var n = this._globalHandlerScope;
      r ? zge(this, n) : Mb(n);
    }
  }, t;
}(Go), w$ = 1;
kt.hasGlobalWindow && (w$ = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var j0 = w$, $R = 0.4, WR = "#333", jR = "#ccc", Wge = "#eee", GL = Ev, HL = 5e-5;
function gu(e) {
  return e > HL || e < -HL;
}
var vu = [], Cd = [], Db = ki(), Ab = Math.abs, jge = function() {
  function e() {
  }
  return e.prototype.getLocalTransform = function(t) {
    return e.getLocalTransform(this, t);
  }, e.prototype.setPosition = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.prototype.setScale = function(t) {
    this.scaleX = t[0], this.scaleY = t[1];
  }, e.prototype.setSkew = function(t) {
    this.skewX = t[0], this.skewY = t[1];
  }, e.prototype.setOrigin = function(t) {
    this.originX = t[0], this.originY = t[1];
  }, e.prototype.needLocalTransform = function() {
    return gu(this.rotation) || gu(this.x) || gu(this.y) || gu(this.scaleX - 1) || gu(this.scaleY - 1) || gu(this.skewX) || gu(this.skewY);
  }, e.prototype.updateTransform = function() {
    var t = this.parent && this.parent.transform, r = this.needLocalTransform(), n = this.transform;
    if (!(r || t)) {
      n && (GL(n), this.invTransform = null);
      return;
    }
    n = n || ki(), r ? this.getLocalTransform(n) : GL(n), t && (r ? Ka(n, t, n) : ES(n, t)), this.transform = n, this._resolveGlobalScaleRatio(n);
  }, e.prototype._resolveGlobalScaleRatio = function(t) {
    var r = this.globalScaleRatio;
    if (r != null && r !== 1) {
      this.getGlobalScale(vu);
      var n = vu[0] < 0 ? -1 : 1, i = vu[1] < 0 ? -1 : 1, o = ((vu[0] - n) * r + n) / vu[0] || 0, a = ((vu[1] - i) * r + i) / vu[1] || 0;
      t[0] *= o, t[1] *= o, t[2] *= a, t[3] *= a;
    }
    this.invTransform = this.invTransform || ki(), Wc(this.invTransform, t);
  }, e.prototype.getComputedTransform = function() {
    for (var t = this, r = []; t; )
      r.push(t), t = t.parent;
    for (; t = r.pop(); )
      t.updateTransform();
    return this.transform;
  }, e.prototype.setLocalTransform = function(t) {
    if (t) {
      var r = t[0] * t[0] + t[1] * t[1], n = t[2] * t[2] + t[3] * t[3], i = Math.atan2(t[1], t[0]), o = Math.PI / 2 + i - Math.atan2(t[3], t[2]);
      n = Math.sqrt(n) * Math.cos(o), r = Math.sqrt(r), this.skewX = o, this.skewY = 0, this.rotation = -i, this.x = +t[4], this.y = +t[5], this.scaleX = r, this.scaleY = n, this.originX = 0, this.originY = 0;
    }
  }, e.prototype.decomposeTransform = function() {
    if (this.transform) {
      var t = this.parent, r = this.transform;
      t && t.transform && (t.invTransform = t.invTransform || ki(), Ka(Cd, t.invTransform, r), r = Cd);
      var n = this.originX, i = this.originY;
      (n || i) && (Db[4] = n, Db[5] = i, Ka(Cd, r, Db), Cd[4] -= n, Cd[5] -= i, r = Cd), this.setLocalTransform(r);
    }
  }, e.prototype.getGlobalScale = function(t) {
    var r = this.transform;
    return t = t || [], r ? (t[0] = Math.sqrt(r[0] * r[0] + r[1] * r[1]), t[1] = Math.sqrt(r[2] * r[2] + r[3] * r[3]), r[0] < 0 && (t[0] = -t[0]), r[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
  }, e.prototype.transformCoordToLocal = function(t, r) {
    var n = [t, r], i = this.invTransform;
    return i && An(n, n, i), n;
  }, e.prototype.transformCoordToGlobal = function(t, r) {
    var n = [t, r], i = this.transform;
    return i && An(n, n, i), n;
  }, e.prototype.getLineScale = function() {
    var t = this.transform;
    return t && Ab(t[0] - 1) > 1e-10 && Ab(t[3] - 1) > 1e-10 ? Math.sqrt(Ab(t[0] * t[3] - t[2] * t[1])) : 1;
  }, e.prototype.copyTransform = function(t) {
    b$(this, t);
  }, e.getLocalTransform = function(t, r) {
    r = r || [];
    var n = t.originX || 0, i = t.originY || 0, o = t.scaleX, a = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, d = t.y, h = t.skewX ? Math.tan(t.skewX) : 0, f = t.skewY ? Math.tan(-t.skewY) : 0;
    if (n || i || s || l) {
      var p = n + s, g = i + l;
      r[4] = -p * o - h * g * a, r[5] = -g * a - f * p * o;
    } else
      r[4] = r[5] = 0;
    return r[0] = o, r[3] = a, r[1] = f * o, r[2] = h * a, u && nu(r, r, u), r[4] += n + c, r[5] += i + d, r;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
  }(), e;
}(), Qa = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function b$(e, t) {
  for (var r = 0; r < Qa.length; r++) {
    var n = Qa[r];
    e[n] = t[n];
  }
}
const Ts = jge;
var zL = {};
function no(e, t) {
  t = t || Hl;
  var r = zL[t];
  r || (r = zL[t] = new Rv(500));
  var n = r.get(e);
  return n == null && (n = va.measureText(e, t).width, r.put(e, n)), n;
}
function $L(e, t, r, n) {
  var i = no(e, t), o = TS(t), a = Rp(0, i, r), s = jd(0, o, n), l = new St(a, s, i, o);
  return l;
}
function _v(e, t, r, n) {
  var i = ((e || "") + "").split(`
`), o = i.length;
  if (o === 1)
    return $L(i[0], t, r, n);
  for (var a = new St(0, 0, 0, 0), s = 0; s < i.length; s++) {
    var l = $L(i[s], t, r, n);
    s === 0 ? a.copy(l) : a.union(l);
  }
  return a;
}
function Rp(e, t, r) {
  return r === "right" ? e -= t : r === "center" && (e -= t / 2), e;
}
function jd(e, t, r) {
  return r === "middle" ? e -= t / 2 : r === "bottom" && (e -= t), e;
}
function TS(e) {
  return no("国", e);
}
function ya(e, t) {
  return typeof e == "string" ? e.lastIndexOf("%") >= 0 ? parseFloat(e) / 100 * t : parseFloat(e) : e;
}
function U0(e, t, r) {
  var n = t.position || "inside", i = t.distance != null ? t.distance : 5, o = r.height, a = r.width, s = o / 2, l = r.x, u = r.y, c = "left", d = "top";
  if (n instanceof Array)
    l += ya(n[0], r.width), u += ya(n[1], r.height), c = null, d = null;
  else
    switch (n) {
      case "left":
        l -= i, u += s, c = "right", d = "middle";
        break;
      case "right":
        l += i + a, u += s, d = "middle";
        break;
      case "top":
        l += a / 2, u -= i, c = "center", d = "bottom";
        break;
      case "bottom":
        l += a / 2, u += o + i, c = "center";
        break;
      case "inside":
        l += a / 2, u += s, c = "center", d = "middle";
        break;
      case "insideLeft":
        l += i, u += s, d = "middle";
        break;
      case "insideRight":
        l += a - i, u += s, c = "right", d = "middle";
        break;
      case "insideTop":
        l += a / 2, u += i, c = "center";
        break;
      case "insideBottom":
        l += a / 2, u += o - i, c = "center", d = "bottom";
        break;
      case "insideTopLeft":
        l += i, u += i;
        break;
      case "insideTopRight":
        l += a - i, u += i, c = "right";
        break;
      case "insideBottomLeft":
        l += i, u += o - i, d = "bottom";
        break;
      case "insideBottomRight":
        l += a - i, u += o - i, c = "right", d = "bottom";
        break;
    }
  return e = e || {}, e.x = l, e.y = u, e.align = c, e.verticalAlign = d, e;
}
var Ib = "__zr_normal__", Fb = Qa.concat(["ignore"]), Uge = Oo(Qa, function(e, t) {
  return e[t] = !0, e;
}, { ignore: !1 }), Sd = {}, Kge = new St(0, 0, 0, 0), PS = function() {
  function e(t) {
    this.id = qP(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
  }
  return e.prototype._init = function(t) {
    this.attr(t);
  }, e.prototype.drift = function(t, r, n) {
    switch (this.draggable) {
      case "horizontal":
        r = 0;
        break;
      case "vertical":
        t = 0;
        break;
    }
    var i = this.transform;
    i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += t, i[5] += r, this.decomposeTransform(), this.markRedraw();
  }, e.prototype.beforeUpdate = function() {
  }, e.prototype.afterUpdate = function() {
  }, e.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, e.prototype.updateInnerText = function(t) {
    var r = this._textContent;
    if (r && (!r.ignore || t)) {
      this.textConfig || (this.textConfig = {});
      var n = this.textConfig, i = n.local, o = r.innerTransformable, a = void 0, s = void 0, l = !1;
      o.parent = i ? this : null;
      var u = !1;
      if (o.copyTransform(r), n.position != null) {
        var c = Kge;
        n.layoutRect ? c.copy(n.layoutRect) : c.copy(this.getBoundingRect()), i || c.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(Sd, n, c) : U0(Sd, n, c), o.x = Sd.x, o.y = Sd.y, a = Sd.align, s = Sd.verticalAlign;
        var d = n.origin;
        if (d && n.rotation != null) {
          var h = void 0, f = void 0;
          d === "center" ? (h = c.width * 0.5, f = c.height * 0.5) : (h = ya(d[0], c.width), f = ya(d[1], c.height)), u = !0, o.originX = -o.x + h + (i ? 0 : c.x), o.originY = -o.y + f + (i ? 0 : c.y);
        }
      }
      n.rotation != null && (o.rotation = n.rotation);
      var p = n.offset;
      p && (o.x += p[0], o.y += p[1], u || (o.originX = -p[0], o.originY = -p[1]));
      var g = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, v = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), m = void 0, y = void 0, C = void 0;
      g && this.canBeInsideText() ? (m = n.insideFill, y = n.insideStroke, (m == null || m === "auto") && (m = this.getInsideTextFill()), (y == null || y === "auto") && (y = this.getInsideTextStroke(m), C = !0)) : (m = n.outsideFill, y = n.outsideStroke, (m == null || m === "auto") && (m = this.getOutsideFill()), (y == null || y === "auto") && (y = this.getOutsideStroke(m), C = !0)), m = m || "#000", (m !== v.fill || y !== v.stroke || C !== v.autoStroke || a !== v.align || s !== v.verticalAlign) && (l = !0, v.fill = m, v.stroke = y, v.autoStroke = C, v.align = a, v.verticalAlign = s, r.setDefaultTextStyle(v)), r.__dirty |= qi, l && r.dirtyStyle(!0);
    }
  }, e.prototype.canBeInsideText = function() {
    return !0;
  }, e.prototype.getInsideTextFill = function() {
    return "#fff";
  }, e.prototype.getInsideTextStroke = function(t) {
    return "#000";
  }, e.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? jR : WR;
  }, e.prototype.getOutsideStroke = function(t) {
    var r = this.__zr && this.__zr.getBackgroundColor(), n = typeof r == "string" && yi(r);
    n || (n = [255, 255, 255, 1]);
    for (var i = n[3], o = this.__zr.isDarkMode(), a = 0; a < 3; a++)
      n[a] = n[a] * i + (o ? 0 : 255) * (1 - i);
    return n[3] = 1, ha(n, "rgba");
  }, e.prototype.traverse = function(t, r) {
  }, e.prototype.attrKV = function(t, r) {
    t === "textConfig" ? this.setTextConfig(r) : t === "textContent" ? this.setTextContent(r) : t === "clipPath" ? this.setClipPath(r) : t === "extra" ? (this.extra = this.extra || {}, se(this.extra, r)) : this[t] = r;
  }, e.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, e.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, e.prototype.attr = function(t, r) {
    if (typeof t == "string")
      this.attrKV(t, r);
    else if (Ze(t))
      for (var n = t, i = At(n), o = 0; o < i.length; o++) {
        var a = i[o];
        this.attrKV(a, t[a]);
      }
    return this.markRedraw(), this;
  }, e.prototype.saveCurrentToNormalState = function(t) {
    this._innerSaveToNormal(t);
    for (var r = this._normalState, n = 0; n < this.animators.length; n++) {
      var i = this.animators[n], o = i.__fromStateTransition;
      if (!(i.getLoop() || o && o !== Ib)) {
        var a = i.targetName, s = a ? r[a] : r;
        i.saveTo(s);
      }
    }
  }, e.prototype._innerSaveToNormal = function(t) {
    var r = this._normalState;
    r || (r = this._normalState = {}), t.textConfig && !r.textConfig && (r.textConfig = this.textConfig), this._savePrimaryToNormal(t, r, Fb);
  }, e.prototype._savePrimaryToNormal = function(t, r, n) {
    for (var i = 0; i < n.length; i++) {
      var o = n[i];
      t[o] != null && !(o in r) && (r[o] = this[o]);
    }
  }, e.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, e.prototype.getState = function(t) {
    return this.states[t];
  }, e.prototype.ensureState = function(t) {
    var r = this.states;
    return r[t] || (r[t] = {}), r[t];
  }, e.prototype.clearStates = function(t) {
    this.useState(Ib, !1, t);
  }, e.prototype.useState = function(t, r, n, i) {
    var o = t === Ib, a = this.hasState();
    if (!(!a && o)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(bt(s, t) >= 0 && (r || s.length === 1))) {
        var u;
        if (this.stateProxy && !o && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !o) {
          Mo("State " + t + " not exists.");
          return;
        }
        o || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || i);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, r, !n && !this.__inHover && l && l.duration > 0, l);
        var d = this._textContent, h = this._textGuide;
        return d && d.useState(t, r, n, c), h && h.useState(t, r, n, c), o ? (this.currentStates = [], this._normalState = {}) : r ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~qi), u;
      }
    }
  }, e.prototype.useStates = function(t, r, n) {
    if (!t.length)
      this.clearStates();
    else {
      var i = [], o = this.currentStates, a = t.length, s = a === o.length;
      if (s) {
        for (var l = 0; l < a; l++)
          if (t[l] !== o[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < a; l++) {
        var u = t[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && i.push(c);
      }
      var d = i[a - 1], h = !!(d && d.hoverLayer || n);
      h && this._toggleHoverLayerFlag(!0);
      var f = this._mergeStates(i), p = this.stateTransition;
      this.saveCurrentToNormalState(f), this._applyStateObj(t.join(","), f, this._normalState, !1, !r && !this.__inHover && p && p.duration > 0, p);
      var g = this._textContent, v = this._textGuide;
      g && g.useStates(t, r, h), v && v.useStates(t, r, h), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !h && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~qi);
    }
  }, e.prototype.isSilent = function() {
    for (var t = this.silent, r = this.parent; !t && r; ) {
      if (r.silent) {
        t = !0;
        break;
      }
      r = r.parent;
    }
    return t;
  }, e.prototype._updateAnimationTargets = function() {
    for (var t = 0; t < this.animators.length; t++) {
      var r = this.animators[t];
      r.targetName && r.changeTarget(this[r.targetName]);
    }
  }, e.prototype.removeState = function(t) {
    var r = bt(this.currentStates, t);
    if (r >= 0) {
      var n = this.currentStates.slice();
      n.splice(r, 1), this.useStates(n);
    }
  }, e.prototype.replaceState = function(t, r, n) {
    var i = this.currentStates.slice(), o = bt(i, t), a = bt(i, r) >= 0;
    o >= 0 ? a ? i.splice(o, 1) : i[o] = r : n && !a && i.push(r), this.useStates(i);
  }, e.prototype.toggleState = function(t, r) {
    r ? this.useState(t, !0) : this.removeState(t);
  }, e.prototype._mergeStates = function(t) {
    for (var r = {}, n, i = 0; i < t.length; i++) {
      var o = t[i];
      se(r, o), o.textConfig && (n = n || {}, se(n, o.textConfig));
    }
    return n && (r.textConfig = n), r;
  }, e.prototype._applyStateObj = function(t, r, n, i, o, a) {
    var s = !(r && i);
    r && r.textConfig ? (this.textConfig = se({}, i ? this.textConfig : n.textConfig), se(this.textConfig, r.textConfig)) : s && n.textConfig && (this.textConfig = n.textConfig);
    for (var l = {}, u = !1, c = 0; c < Fb.length; c++) {
      var d = Fb[c], h = o && Uge[d];
      r && r[d] != null ? h ? (u = !0, l[d] = r[d]) : this[d] = r[d] : s && n[d] != null && (h ? (u = !0, l[d] = n[d]) : this[d] = n[d]);
    }
    if (!o)
      for (var c = 0; c < this.animators.length; c++) {
        var f = this.animators[c], p = f.targetName;
        f.getLoop() || f.__changeFinalValue(p ? (r || n)[p] : r || n);
      }
    u && this._transitionState(t, l, a);
  }, e.prototype._attachComponent = function(t) {
    if (t.__zr && !t.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (t === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var r = this.__zr;
    r && t.addSelfToZr(r), t.__zr = r, t.__hostTarget = this;
  }, e.prototype._detachComponent = function(t) {
    t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
  }, e.prototype.getClipPath = function() {
    return this._clipPath;
  }, e.prototype.setClipPath = function(t) {
    this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
  }, e.prototype.removeClipPath = function() {
    var t = this._clipPath;
    t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
  }, e.prototype.getTextContent = function() {
    return this._textContent;
  }, e.prototype.setTextContent = function(t) {
    var r = this._textContent;
    if (r !== t) {
      if (r && r !== t && this.removeTextContent(), process.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      t.innerTransformable = new Ts(), this._attachComponent(t), this._textContent = t, this.markRedraw();
    }
  }, e.prototype.setTextConfig = function(t) {
    this.textConfig || (this.textConfig = {}), se(this.textConfig, t), this.markRedraw();
  }, e.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, e.prototype.removeTextContent = function() {
    var t = this._textContent;
    t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, e.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, e.prototype.setTextGuideLine = function(t) {
    this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
  }, e.prototype.removeTextGuideLine = function() {
    var t = this._textGuide;
    t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
  }, e.prototype.markRedraw = function() {
    this.__dirty |= qi;
    var t = this.__zr;
    t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, e.prototype.dirty = function() {
    this.markRedraw();
  }, e.prototype._toggleHoverLayerFlag = function(t) {
    this.__inHover = t;
    var r = this._textContent, n = this._textGuide;
    r && (r.__inHover = t), n && (n.__inHover = t);
  }, e.prototype.addSelfToZr = function(t) {
    if (this.__zr !== t) {
      this.__zr = t;
      var r = this.animators;
      if (r)
        for (var n = 0; n < r.length; n++)
          t.animation.addAnimator(r[n]);
      this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    if (this.__zr) {
      this.__zr = null;
      var r = this.animators;
      if (r)
        for (var n = 0; n < r.length; n++)
          t.animation.removeAnimator(r[n]);
      this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
    }
  }, e.prototype.animate = function(t, r, n) {
    var i = t ? this[t] : this;
    if (process.env.NODE_ENV !== "production" && !i) {
      Mo('Property "' + t + '" is not existed in element ' + this.id);
      return;
    }
    var o = new iM(i, r, n);
    return t && (o.targetName = t), this.addAnimator(o, t), o;
  }, e.prototype.addAnimator = function(t, r) {
    var n = this.__zr, i = this;
    t.during(function() {
      i.updateDuringAnimation(r);
    }).done(function() {
      var o = i.animators, a = bt(o, t);
      a >= 0 && o.splice(a, 1);
    }), this.animators.push(t), n && n.animation.addAnimator(t), n && n.wakeUp();
  }, e.prototype.updateDuringAnimation = function(t) {
    this.markRedraw();
  }, e.prototype.stopAnimation = function(t, r) {
    for (var n = this.animators, i = n.length, o = [], a = 0; a < i; a++) {
      var s = n[a];
      !t || t === s.scope ? s.stop(r) : o.push(s);
    }
    return this.animators = o, this;
  }, e.prototype.animateTo = function(t, r, n) {
    Lb(this, t, r, n);
  }, e.prototype.animateFrom = function(t, r, n) {
    Lb(this, t, r, n, !0);
  }, e.prototype._transitionState = function(t, r, n, i) {
    for (var o = Lb(this, r, n, i), a = 0; a < o.length; a++)
      o[a].__fromStateTransition = t;
  }, e.prototype.getBoundingRect = function() {
    return null;
  }, e.prototype.getPaintRect = function() {
    return null;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "element", t.name = "", t.ignore = t.silent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = !1, t.__dirty = qi;
    var r = {};
    function n(o, a, s) {
      r[o + a + s] || (console.warn("DEPRECATED: '" + o + "' has been deprecated. use '" + a + "', '" + s + "' instead"), r[o + a + s] = !0);
    }
    function i(o, a, s, l) {
      Object.defineProperty(t, o, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && n(o, s, l), !this[a]) {
            var c = this[a] = [];
            u(this, c);
          }
          return this[a];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && n(o, s, l), this[s] = c[0], this[l] = c[1], this[a] = c, u(this, c);
        }
      });
      function u(c, d) {
        Object.defineProperty(d, 0, {
          get: function() {
            return c[s];
          },
          set: function(h) {
            c[s] = h;
          }
        }), Object.defineProperty(d, 1, {
          get: function() {
            return c[l];
          },
          set: function(h) {
            c[l] = h;
          }
        });
      }
    }
    Object.defineProperty && (i("position", "_legacyPos", "x", "y"), i("scale", "_legacyScale", "scaleX", "scaleY"), i("origin", "_legacyOrigin", "originX", "originY"));
  }(), e;
}();
qr(PS, Go);
qr(PS, Ts);
function Lb(e, t, r, n, i) {
  r = r || {};
  var o = [];
  x$(e, "", e, t, r, n, o, i);
  var a = o.length, s = !1, l = r.done, u = r.aborted, c = function() {
    s = !0, a--, a <= 0 && (s ? l && l() : u && u());
  }, d = function() {
    a--, a <= 0 && (s ? l && l() : u && u());
  };
  a || l && l(), o.length > 0 && r.during && o[0].during(function(p, g) {
    r.during(g);
  });
  for (var h = 0; h < o.length; h++) {
    var f = o[h];
    c && f.done(c), d && f.aborted(d), r.force && f.duration(r.duration), f.start(r.easing);
  }
  return o;
}
function Ob(e, t, r) {
  for (var n = 0; n < r; n++)
    e[n] = t[n];
}
function Yge(e) {
  return kn(e[0]);
}
function qge(e, t, r) {
  if (kn(t[r]))
    if (kn(e[r]) || (e[r] = []), ei(t[r])) {
      var n = t[r].length;
      e[r].length !== n && (e[r] = new t[r].constructor(n), Ob(e[r], t[r], n));
    } else {
      var i = t[r], o = e[r], a = i.length;
      if (Yge(i))
        for (var s = i[0].length, l = 0; l < a; l++)
          o[l] ? Ob(o[l], i[l], s) : o[l] = Array.prototype.slice.call(i[l]);
      else
        Ob(o, i, a);
      o.length = i.length;
    }
  else
    e[r] = t[r];
}
function Zge(e, t) {
  return e === t || kn(e) && kn(t) && Xge(e, t);
}
function Xge(e, t) {
  var r = e.length;
  if (r !== t.length)
    return !1;
  for (var n = 0; n < r; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function x$(e, t, r, n, i, o, a, s) {
  for (var l = At(n), u = i.duration, c = i.delay, d = i.additive, h = i.setToFinal, f = !Ze(o), p = e.animators, g = [], v = 0; v < l.length; v++) {
    var m = l[v], y = n[m];
    if (y != null && r[m] != null && (f || o[m]))
      if (Ze(y) && !kn(y) && !bv(y)) {
        if (t) {
          s || (r[m] = y, e.updateDuringAnimation(t));
          continue;
        }
        x$(e, m, r[m], y, i, o && o[m], a, s);
      } else
        g.push(m);
    else s || (r[m] = y, e.updateDuringAnimation(t), g.push(m));
  }
  var C = g.length;
  if (!d && C)
    for (var S = 0; S < p.length; S++) {
      var b = p[S];
      if (b.targetName === t) {
        var w = b.stopTracks(g);
        if (w) {
          var x = bt(p, b);
          p.splice(x, 1);
        }
      }
    }
  if (i.force || (g = ir(g, function(P) {
    return !Zge(n[P], r[P]);
  }), C = g.length), C > 0 || i.force && !a.length) {
    var E = void 0, R = void 0, _ = void 0;
    if (s) {
      R = {}, h && (E = {});
      for (var S = 0; S < C; S++) {
        var m = g[S];
        R[m] = r[m], h ? E[m] = n[m] : r[m] = n[m];
      }
    } else if (h) {
      _ = {};
      for (var S = 0; S < C; S++) {
        var m = g[S];
        _[m] = Xp(r[m]), qge(r, n, m);
      }
    }
    var b = new iM(r, !1, !1, d ? ir(p, function(D) {
      return D.targetName === t;
    }) : null);
    b.targetName = t, i.scope && (b.scope = i.scope), h && E && b.whenWithKeys(0, E, g), _ && b.whenWithKeys(0, _, g), b.whenWithKeys(u ?? 500, s ? R : n, g).delay(c || 0), e.addAnimator(b, t), a.push(b);
  }
}
var E$ = function(e) {
  Mr(t, e);
  function t(r) {
    var n = e.call(this) || this;
    return n.isGroup = !0, n._children = [], n.attr(r), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.children = function() {
    return this._children.slice();
  }, t.prototype.childAt = function(r) {
    return this._children[r];
  }, t.prototype.childOfName = function(r) {
    for (var n = this._children, i = 0; i < n.length; i++)
      if (n[i].name === r)
        return n[i];
  }, t.prototype.childCount = function() {
    return this._children.length;
  }, t.prototype.add = function(r) {
    if (r && (r !== this && r.parent !== this && (this._children.push(r), this._doAdd(r)), process.env.NODE_ENV !== "production" && r.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, t.prototype.addBefore = function(r, n) {
    if (r && r !== this && r.parent !== this && n && n.parent === this) {
      var i = this._children, o = i.indexOf(n);
      o >= 0 && (i.splice(o, 0, r), this._doAdd(r));
    }
    return this;
  }, t.prototype.replace = function(r, n) {
    var i = bt(this._children, r);
    return i >= 0 && this.replaceAt(n, i), this;
  }, t.prototype.replaceAt = function(r, n) {
    var i = this._children, o = i[n];
    if (r && r !== this && r.parent !== this && r !== o) {
      i[n] = r, o.parent = null;
      var a = this.__zr;
      a && o.removeSelfFromZr(a), this._doAdd(r);
    }
    return this;
  }, t.prototype._doAdd = function(r) {
    r.parent && r.parent.remove(r), r.parent = this;
    var n = this.__zr;
    n && n !== r.__zr && r.addSelfToZr(n), n && n.refresh();
  }, t.prototype.remove = function(r) {
    var n = this.__zr, i = this._children, o = bt(i, r);
    return o < 0 ? this : (i.splice(o, 1), r.parent = null, n && r.removeSelfFromZr(n), n && n.refresh(), this);
  }, t.prototype.removeAll = function() {
    for (var r = this._children, n = this.__zr, i = 0; i < r.length; i++) {
      var o = r[i];
      n && o.removeSelfFromZr(n), o.parent = null;
    }
    return r.length = 0, this;
  }, t.prototype.eachChild = function(r, n) {
    for (var i = this._children, o = 0; o < i.length; o++) {
      var a = i[o];
      r.call(n, a, o);
    }
    return this;
  }, t.prototype.traverse = function(r, n) {
    for (var i = 0; i < this._children.length; i++) {
      var o = this._children[i], a = r.call(n, o);
      o.isGroup && !a && o.traverse(r, n);
    }
    return this;
  }, t.prototype.addSelfToZr = function(r) {
    e.prototype.addSelfToZr.call(this, r);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.addSelfToZr(r);
    }
  }, t.prototype.removeSelfFromZr = function(r) {
    e.prototype.removeSelfFromZr.call(this, r);
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.removeSelfFromZr(r);
    }
  }, t.prototype.getBoundingRect = function(r) {
    for (var n = new St(0, 0, 0, 0), i = r || this._children, o = [], a = null, s = 0; s < i.length; s++) {
      var l = i[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(o);
        c ? (St.applyTransform(n, u, c), a = a || n.clone(), a.union(n)) : (a = a || u.clone(), a.union(u));
      }
    }
    return a || n;
  }, t;
}(PS);
E$.prototype.type = "group";
const it = E$;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var _p = {}, ec = {};
function Qge(e) {
  delete ec[e];
}
function Jge(e) {
  if (!e)
    return !1;
  if (typeof e == "string")
    return Og(e, 1) < $R;
  if (e.colorStops) {
    for (var t = e.colorStops, r = 0, n = t.length, i = 0; i < n; i++)
      r += Og(t[i].color, 1);
    return r /= n, r < $R;
  }
  return !1;
}
var eve = function() {
  function e(t, r, n) {
    var i = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = r, this.id = t;
    var o = new cge(), a = n.renderer || "canvas";
    if (_p[a] || (a = At(_p)[0]), process.env.NODE_ENV !== "production" && !_p[a])
      throw new Error("Renderer '" + a + "' is not imported. Please import it first.");
    n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect;
    var s = new _p[a](r, o, n, t), l = n.ssr || s.ssrOnly;
    this.storage = o, this.painter = s;
    var u = !kt.node && !kt.worker && !l ? new $ge(s.getViewportRoot(), s.root) : null, c = n.useCoarsePointer, d = c == null || c === "auto" ? kt.touchEventsSupported : !!c, h = 44, f;
    d && (f = st(n.pointerSize, h)), this.handler = new r$(o, s, u, s.root, f), this.animation = new Nge({
      stage: {
        update: l ? null : function() {
          return i._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return e.prototype.add = function(t) {
    this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
  }, e.prototype.remove = function(t) {
    this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
  }, e.prototype.configLayer = function(t, r) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(t, r), this.refresh());
  }, e.prototype.setBackgroundColor = function(t) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = Jge(t));
  }, e.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, e.prototype.setDarkMode = function(t) {
    this._darkMode = t;
  }, e.prototype.isDarkMode = function() {
    return this._darkMode;
  }, e.prototype.refreshImmediately = function(t) {
    this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, e.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, e.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, e.prototype._flush = function(t) {
    var r, n = th();
    this._needsRefresh && (r = !0, this.refreshImmediately(t)), this._needsRefreshHover && (r = !0, this.refreshHoverImmediately());
    var i = th();
    r ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: i - n
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, e.prototype.setSleepAfterStill = function(t) {
    this._sleepAfterStill = t;
  }, e.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, e.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, e.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, e.prototype.resize = function(t) {
    this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
  }, e.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, e.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, e.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, e.prototype.setCursorStyle = function(t) {
    this._disposed || this.handler.setCursorStyle(t);
  }, e.prototype.findHover = function(t, r) {
    if (!this._disposed)
      return this.handler.findHover(t, r);
  }, e.prototype.on = function(t, r, n) {
    return this._disposed || this.handler.on(t, r, n), this;
  }, e.prototype.off = function(t, r) {
    this._disposed || this.handler.off(t, r);
  }, e.prototype.trigger = function(t, r) {
    this._disposed || this.handler.trigger(t, r);
  }, e.prototype.clear = function() {
    if (!this._disposed) {
      for (var t = this.storage.getRoots(), r = 0; r < t.length; r++)
        t[r] instanceof it && t[r].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, e.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, Qge(this.id));
  }, e;
}();
function UR(e, t) {
  var r = new eve(qP(), e, t);
  return ec[r.id] = r, r;
}
function tve(e) {
  e.dispose();
}
function rve() {
  for (var e in ec)
    ec.hasOwnProperty(e) && ec[e].dispose();
  ec = {};
}
function nve(e) {
  return ec[e];
}
function R$(e, t) {
  _p[e] = t;
}
var KR;
function _$(e) {
  if (typeof KR == "function")
    return KR(e);
}
function T$(e) {
  KR = e;
}
var ive = "5.6.0";
const ove = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dispose: tve,
  disposeAll: rve,
  getElementSSRData: _$,
  getInstance: nve,
  init: UR,
  registerPainter: R$,
  registerSSRDataGetter: T$,
  version: ive
}, Symbol.toStringTag, { value: "Module" }));
var WL = 1e-4, P$ = 20;
function ave(e) {
  return e.replace(/^\s+|\s+$/g, "");
}
function nr(e, t, r, n) {
  var i = t[0], o = t[1], a = r[0], s = r[1], l = o - i, u = s - a;
  if (l === 0)
    return u === 0 ? a : (a + s) / 2;
  if (n)
    if (l > 0) {
      if (e <= i)
        return a;
      if (e >= o)
        return s;
    } else {
      if (e >= i)
        return a;
      if (e <= o)
        return s;
    }
  else {
    if (e === i)
      return a;
    if (e === o)
      return s;
  }
  return (e - i) / l * u + a;
}
function Ae(e, t) {
  switch (e) {
    case "center":
    case "middle":
      e = "50%";
      break;
    case "left":
    case "top":
      e = "0%";
      break;
    case "right":
    case "bottom":
      e = "100%";
      break;
  }
  return Fe(e) ? ave(e).match(/%$/) ? parseFloat(e) / 100 * t : parseFloat(e) : e == null ? NaN : +e;
}
function Gr(e, t, r) {
  return t == null && (t = 10), t = Math.min(Math.max(0, t), P$), e = (+e).toFixed(t), r ? e : +e;
}
function Ji(e) {
  return e.sort(function(t, r) {
    return t - r;
  }), e;
}
function oa(e) {
  if (e = +e, isNaN(e))
    return 0;
  if (e > 1e-14) {
    for (var t = 1, r = 0; r < 15; r++, t *= 10)
      if (Math.round(e * t) / t === e)
        return r;
  }
  return K0(e);
}
function K0(e) {
  var t = e.toString().toLowerCase(), r = t.indexOf("e"), n = r > 0 ? +t.slice(r + 1) : 0, i = r > 0 ? r : t.length, o = t.indexOf("."), a = o < 0 ? 0 : i - 1 - o;
  return Math.max(0, a - n);
}
function oM(e, t) {
  var r = Math.log, n = Math.LN10, i = Math.floor(r(e[1] - e[0]) / n), o = Math.round(r(Math.abs(t[1] - t[0])) / n), a = Math.min(Math.max(-i + o, 0), 20);
  return isFinite(a) ? a : 20;
}
function sve(e, t, r) {
  if (!e[t])
    return 0;
  var n = M$(e, r);
  return n[t] || 0;
}
function M$(e, t) {
  var r = Oo(e, function(f, p) {
    return f + (isNaN(p) ? 0 : p);
  }, 0);
  if (r === 0)
    return [];
  for (var n = Math.pow(10, t), i = ge(e, function(f) {
    return (isNaN(f) ? 0 : f) / r * n * 100;
  }), o = n * 100, a = ge(i, function(f) {
    return Math.floor(f);
  }), s = Oo(a, function(f, p) {
    return f + p;
  }, 0), l = ge(i, function(f, p) {
    return f - a[p];
  }); s < o; ) {
    for (var u = Number.NEGATIVE_INFINITY, c = null, d = 0, h = l.length; d < h; ++d)
      l[d] > u && (u = l[d], c = d);
    ++a[c], l[c] = 0, ++s;
  }
  return ge(a, function(f) {
    return f / n;
  });
}
function lve(e, t) {
  var r = Math.max(oa(e), oa(t)), n = e + t;
  return r > P$ ? n : Gr(n, r);
}
var YR = 9007199254740991;
function aM(e) {
  var t = Math.PI * 2;
  return (e % t + t) % t;
}
function Ah(e) {
  return e > -WL && e < WL;
}
var uve = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function io(e) {
  if (e instanceof Date)
    return e;
  if (Fe(e)) {
    var t = uve.exec(e);
    if (!t)
      return /* @__PURE__ */ new Date(NaN);
    if (t[8]) {
      var r = +t[4] || 0;
      return t[8].toUpperCase() !== "Z" && (r -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, r, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
    } else
      return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
  } else if (e == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(e));
}
function D$(e) {
  return Math.pow(10, Tv(e));
}
function Tv(e) {
  if (e === 0)
    return 0;
  var t = Math.floor(Math.log(e) / Math.LN10);
  return e / Math.pow(10, t) >= 10 && t++, t;
}
function sM(e, t) {
  var r = Tv(e), n = Math.pow(10, r), i = e / n, o;
  return t ? i < 1.5 ? o = 1 : i < 2.5 ? o = 2 : i < 4 ? o = 3 : i < 7 ? o = 5 : o = 10 : i < 1 ? o = 1 : i < 2 ? o = 2 : i < 3 ? o = 3 : i < 5 ? o = 5 : o = 10, e = o * n, r >= -20 ? +e.toFixed(r < 0 ? -r : 0) : e;
}
function e0(e, t) {
  var r = (e.length - 1) * t + 1, n = Math.floor(r), i = +e[n - 1], o = r - n;
  return o ? i + o * (e[n] - i) : i;
}
function qR(e) {
  e.sort(function(l, u) {
    return s(l, u, 0) ? -1 : 1;
  });
  for (var t = -1 / 0, r = 1, n = 0; n < e.length; ) {
    for (var i = e[n].interval, o = e[n].close, a = 0; a < 2; a++)
      i[a] <= t && (i[a] = t, o[a] = a ? 1 : 1 - r), t = i[a], r = o[a];
    i[0] === i[1] && o[0] * o[1] !== 1 ? e.splice(n, 1) : n++;
  }
  return e;
  function s(l, u, c) {
    return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && s(l, u, 1));
  }
}
function Ja(e) {
  var t = parseFloat(e);
  return t == e && (t !== 0 || !Fe(e) || e.indexOf("x") <= 0) ? t : NaN;
}
function MS(e) {
  return !isNaN(Ja(e));
}
function A$() {
  return Math.round(Math.random() * 9);
}
function I$(e, t) {
  return t === 0 ? e : I$(t, e % t);
}
function jL(e, t) {
  return e == null ? t : t == null ? e : e * t / I$(e, t);
}
var cve = "[ECharts] ", UL = {}, dve = typeof console < "u" && console.warn && console.log;
function DS(e, t, r) {
  if (dve) {
    if (r) {
      if (UL[t])
        return;
      UL[t] = !0;
    }
    console[e](cve + t);
  }
}
function hve(e, t) {
  DS("log", e, t);
}
function Vr(e, t) {
  DS("warn", e, t);
}
function Vn(e, t) {
  DS("error", e, t);
}
function No(e) {
  process.env.NODE_ENV !== "production" && DS("warn", "DEPRECATED: " + e, !0);
}
function Jr(e, t, r) {
  process.env.NODE_ENV !== "production" && No((r ? "[" + r + "]" : "") + (e + " is deprecated, use " + t + " instead."));
}
function wi() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var r = "";
  if (process.env.NODE_ENV !== "production") {
    var n = function(i) {
      return i === void 0 ? "undefined" : i === 1 / 0 ? "Infinity" : i === -1 / 0 ? "-Infinity" : $l(i) ? "NaN" : i instanceof Date ? "Date(" + i.toISOString() + ")" : Ye(i) ? "function () { ... }" : XP(i) ? i + "" : null;
    };
    r = ge(e, function(i) {
      if (Fe(i))
        return i;
      var o = n(i);
      if (o != null)
        return o;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(i, function(a, s) {
            var l = n(s);
            return l ?? s;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return r;
}
function er(e) {
  throw new Error(e);
}
function KL(e, t, r) {
  return (t - e) * r + e;
}
var F$ = "series\0", L$ = "\0_ec_\0";
function dr(e) {
  return e instanceof Array ? e : e == null ? [] : [e];
}
function Tc(e, t, r) {
  if (e) {
    e[t] = e[t] || {}, e.emphasis = e.emphasis || {}, e.emphasis[t] = e.emphasis[t] || {};
    for (var n = 0, i = r.length; n < i; n++) {
      var o = r[n];
      !e.emphasis[t].hasOwnProperty(o) && e[t].hasOwnProperty(o) && (e.emphasis[t][o] = e[t][o]);
    }
  }
}
var YL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function nf(e) {
  return Ze(e) && !fe(e) && !(e instanceof Date) ? e.value : e;
}
function fve(e) {
  return Ze(e) && !(e instanceof Array);
}
function O$(e, t, r) {
  var n = r === "normalMerge", i = r === "replaceMerge", o = r === "replaceAll";
  e = e || [], t = (t || []).slice();
  var a = We();
  B(t, function(l, u) {
    if (!Ze(l)) {
      t[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !ZL(l.id) && qL(l.id), l.name != null && !ZL(l.name) && qL(l.name));
  });
  var s = pve(e, a, r);
  return (n || i) && gve(s, e, a, t), n && vve(s, t), n || i ? mve(s, t, i) : o && yve(s, t), Cve(s), s;
}
function pve(e, t, r) {
  var n = [];
  if (r === "replaceAll")
    return n;
  for (var i = 0; i < e.length; i++) {
    var o = e[i];
    o && o.id != null && t.set(o.id, i), n.push({
      existing: r === "replaceMerge" || Ih(o) ? null : o,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return n;
}
function gve(e, t, r, n) {
  B(n, function(i, o) {
    if (!(!i || i.id == null)) {
      var a = Qp(i.id), s = r.get(a);
      if (s != null) {
        var l = e[s];
        Qe(!l.newOption, 'Duplicated option on id "' + a + '".'), l.newOption = i, l.existing = t[s], n[o] = null;
      }
    }
  });
}
function vve(e, t) {
  B(t, function(r, n) {
    if (!(!r || r.name == null))
      for (var i = 0; i < e.length; i++) {
        var o = e[i].existing;
        if (!e[i].newOption && o && (o.id == null || r.id == null) && !Ih(r) && !Ih(o) && N$("name", o, r)) {
          e[i].newOption = r, t[n] = null;
          return;
        }
      }
  });
}
function mve(e, t, r) {
  B(t, function(n) {
    if (n) {
      for (
        var i, o = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (i = e[o]) && (i.newOption || Ih(i.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        i.existing && n.id != null && !N$("id", n, i.existing));
      )
        o++;
      i ? (i.newOption = n, i.brandNew = r) : e.push({
        newOption: n,
        brandNew: r,
        existing: null,
        keyInfo: null
      }), o++;
    }
  });
}
function yve(e, t) {
  B(t, function(r) {
    e.push({
      newOption: r,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function Cve(e) {
  var t = We();
  B(e, function(r) {
    var n = r.existing;
    n && t.set(n.id, r);
  }), B(e, function(r) {
    var n = r.newOption;
    Qe(!n || n.id == null || !t.get(n.id) || t.get(n.id) === r, "id duplicates: " + (n && n.id)), n && n.id != null && t.set(n.id, r), !r.keyInfo && (r.keyInfo = {});
  }), B(e, function(r, n) {
    var i = r.existing, o = r.newOption, a = r.keyInfo;
    if (Ze(o)) {
      if (a.name = o.name != null ? Qp(o.name) : i ? i.name : F$ + n, i)
        a.id = Qp(i.id);
      else if (o.id != null)
        a.id = Qp(o.id);
      else {
        var s = 0;
        do
          a.id = "\0" + a.name + "\0" + s++;
        while (t.get(a.id));
      }
      t.set(a.id, r);
    }
  });
}
function N$(e, t, r) {
  var n = vn(t[e], null), i = vn(r[e], null);
  return n != null && i != null && n === i;
}
function Qp(e) {
  if (process.env.NODE_ENV !== "production" && e == null)
    throw new Error();
  return vn(e, "");
}
function vn(e, t) {
  return e == null ? t : Fe(e) ? e : $t(e) || Pg(e) ? e + "" : t;
}
function qL(e) {
  process.env.NODE_ENV !== "production" && Vr("`" + e + "` is invalid id or name. Must be a string or number.");
}
function ZL(e) {
  return Pg(e) || MS(e);
}
function lM(e) {
  var t = e.name;
  return !!(t && t.indexOf(F$));
}
function Ih(e) {
  return e && e.id != null && Qp(e.id).indexOf(L$) === 0;
}
function Sve(e) {
  return L$ + e;
}
function wve(e, t, r) {
  B(e, function(n) {
    var i = n.newOption;
    Ze(i) && (n.keyInfo.mainType = t, n.keyInfo.subType = bve(t, i, n.existing, r));
  });
}
function bve(e, t, r, n) {
  var i = t.type ? t.type : r ? r.subType : n.determineSubType(e, t);
  return i;
}
function xve(e, t) {
  var r = {}, n = {};
  return i(e || [], r), i(t || [], n, r), [o(r), o(n)];
  function i(a, s, l) {
    for (var u = 0, c = a.length; u < c; u++) {
      var d = vn(a[u].seriesId, null);
      if (d == null)
        return;
      for (var h = dr(a[u].dataIndex), f = l && l[d], p = 0, g = h.length; p < g; p++) {
        var v = h[p];
        f && f[v] ? f[v] = null : (s[d] || (s[d] = {}))[v] = 1;
      }
    }
  }
  function o(a, s) {
    var l = [];
    for (var u in a)
      if (a.hasOwnProperty(u) && a[u] != null)
        if (s)
          l.push(+u);
        else {
          var c = o(a[u], !0);
          c.length && l.push({
            seriesId: u,
            dataIndex: c
          });
        }
    return l;
  }
}
function Pc(e, t) {
  if (t.dataIndexInside != null)
    return t.dataIndexInside;
  if (t.dataIndex != null)
    return fe(t.dataIndex) ? ge(t.dataIndex, function(r) {
      return e.indexOfRawIndex(r);
    }) : e.indexOfRawIndex(t.dataIndex);
  if (t.name != null)
    return fe(t.name) ? ge(t.name, function(r) {
      return e.indexOfName(r);
    }) : e.indexOfName(t.name);
}
function Gt() {
  var e = "__ec_inner_" + Eve++;
  return function(t) {
    return t[e] || (t[e] = {});
  };
}
var Eve = A$();
function Jp(e, t, r) {
  var n = uM(t, r), i = n.mainTypeSpecified, o = n.queryOptionMap, a = n.others, s = a, l = r ? r.defaultMainType : null;
  return !i && l && o.set(l, {}), o.each(function(u, c) {
    var d = Pv(e, c, u, {
      useDefault: l === c,
      enableAll: r && r.enableAll != null ? r.enableAll : !0,
      enableNone: r && r.enableNone != null ? r.enableNone : !0
    });
    s[c + "Models"] = d.models, s[c + "Model"] = d.models[0];
  }), s;
}
function uM(e, t) {
  var r;
  if (Fe(e)) {
    var n = {};
    n[e + "Index"] = 0, r = n;
  } else
    r = e;
  var i = We(), o = {}, a = !1;
  return B(r, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      o[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], d = (u[2] || "").toLowerCase();
    if (!(!c || !d || t && t.includeMainTypes && bt(t.includeMainTypes, c) < 0)) {
      a = a || !!c;
      var h = i.get(c) || i.set(c, {});
      h[d] = s;
    }
  }), {
    mainTypeSpecified: a,
    queryOptionMap: i,
    others: o
  };
}
var un = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, Rve = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function Pv(e, t, r, n) {
  n = n || un;
  var i = r.index, o = r.id, a = r.name, s = {
    models: null,
    specified: i != null || o != null || a != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = n.useDefault && (l = e.getComponent(t)) ? [l] : [], s;
  }
  return i === "none" || i === !1 ? (Qe(n.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (i === "all" && (Qe(n.enableAll, '`"all"` is not a valid value on index option.'), i = o = a = null), s.models = e.queryComponents({
    mainType: t,
    index: i,
    id: o,
    name: a
  }), s);
}
function k$(e, t, r) {
  e.setAttribute ? e.setAttribute(t, r) : e[t] = r;
}
function _ve(e, t) {
  return e.getAttribute ? e.getAttribute(t) : e[t];
}
function Tve(e) {
  return e === "auto" ? kt.domSupported ? "html" : "richText" : e || "html";
}
function ZR(e, t) {
  var r = We(), n = [];
  return B(e, function(i) {
    var o = t(i);
    (r.get(o) || (n.push(o), r.set(o, []))).push(i);
  }), {
    keys: n,
    buckets: r
  };
}
function V$(e, t, r, n, i) {
  var o = t == null || t === "auto";
  if (n == null)
    return n;
  if ($t(n)) {
    var a = KL(r || 0, n, i);
    return Gr(a, o ? Math.max(oa(r || 0), oa(n)) : t);
  } else {
    if (Fe(n))
      return i < 1 ? r : n;
    for (var s = [], l = r, u = n, c = Math.max(l ? l.length : 0, u.length), d = 0; d < c; ++d) {
      var h = e.getDimensionInfo(d);
      if (h && h.type === "ordinal")
        s[d] = (i < 1 && l ? l : u)[d];
      else {
        var f = l && l[d] ? l[d] : 0, p = u[d], a = KL(f, p, i);
        s[d] = Gr(a, o ? Math.max(oa(f), oa(p)) : t);
      }
    }
    return s;
  }
}
var Pve = ".", mu = "___EC__COMPONENT__CONTAINER___", B$ = "___EC__EXTENDED_CLASS___";
function za(e) {
  var t = {
    main: "",
    sub: ""
  };
  if (e) {
    var r = e.split(Pve);
    t.main = r[0] || "", t.sub = r[1] || "";
  }
  return t;
}
function Mve(e) {
  Qe(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e), 'componentType "' + e + '" illegal');
}
function Dve(e) {
  return !!(e && e[B$]);
}
function cM(e, t) {
  e.$constructor = e, e.extend = function(r) {
    process.env.NODE_ENV !== "production" && B(t, function(o) {
      r[o] || console.warn("Method `" + o + "` should be implemented" + (r.type ? " in " + r.type : "") + ".");
    });
    var n = this, i;
    return Ave(n) ? i = /** @class */
    function(o) {
      ne(a, o);
      function a() {
        return o.apply(this, arguments) || this;
      }
      return a;
    }(n) : (i = function() {
      (r.$constructor || n).apply(this, arguments);
    }, ZP(i, this)), se(i.prototype, r), i[B$] = !0, i.extend = this.extend, i.superCall = Lve, i.superApply = Ove, i.superClass = n, i;
  };
}
function Ave(e) {
  return Ye(e) && /^class\s/.test(Function.prototype.toString.call(e));
}
function G$(e, t) {
  e.extend = t.extend;
}
var Ive = Math.round(Math.random() * 10);
function Fve(e) {
  var t = ["__\0is_clz", Ive++].join("_");
  e.prototype[t] = !0, process.env.NODE_ENV !== "production" && Qe(!e.isInstance, 'The method "is" can not be defined.'), e.isInstance = function(r) {
    return !!(r && r[t]);
  };
}
function Lve(e, t) {
  for (var r = [], n = 2; n < arguments.length; n++)
    r[n - 2] = arguments[n];
  return this.superClass.prototype[t].apply(e, r);
}
function Ove(e, t, r) {
  return this.superClass.prototype[t].apply(e, r);
}
function AS(e) {
  var t = {};
  e.registerClass = function(n) {
    var i = n.type || n.prototype.type;
    if (i) {
      Mve(i), n.prototype.type = i;
      var o = za(i);
      if (!o.sub)
        process.env.NODE_ENV !== "production" && t[o.main] && console.warn(o.main + " exists."), t[o.main] = n;
      else if (o.sub !== mu) {
        var a = r(o);
        a[o.sub] = n;
      }
    }
    return n;
  }, e.getClass = function(n, i, o) {
    var a = t[n];
    if (a && a[mu] && (a = i ? a[i] : null), o && !a)
      throw new Error(i ? "Component " + n + "." + (i || "") + " is used but not imported." : n + ".type should be specified.");
    return a;
  }, e.getClassesByMainType = function(n) {
    var i = za(n), o = [], a = t[i.main];
    return a && a[mu] ? B(a, function(s, l) {
      l !== mu && o.push(s);
    }) : o.push(a), o;
  }, e.hasClass = function(n) {
    var i = za(n);
    return !!t[i.main];
  }, e.getAllClassMainTypes = function() {
    var n = [];
    return B(t, function(i, o) {
      n.push(o);
    }), n;
  }, e.hasSubTypes = function(n) {
    var i = za(n), o = t[i.main];
    return o && o[mu];
  };
  function r(n) {
    var i = t[n.main];
    return (!i || !i[mu]) && (i = t[n.main] = {}, i[mu] = !0), i;
  }
}
function Mc(e, t) {
  for (var r = 0; r < e.length; r++)
    e[r][1] || (e[r][1] = e[r][0]);
  return t = t || !1, function(n, i, o) {
    for (var a = {}, s = 0; s < e.length; s++) {
      var l = e[s][1];
      if (!(i && bt(i, l) >= 0 || o && bt(o, l) < 0)) {
        var u = n.getShallow(l, t);
        u != null && (a[e[s][0]] = u);
      }
    }
    return a;
  };
}
var Nve = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], kve = Mc(Nve), Vve = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getAreaStyle = function(t, r) {
      return kve(this, t, r);
    }, e;
  }()
), XR = new Rv(50);
function Bve(e) {
  if (typeof e == "string") {
    var t = XR.get(e);
    return t && t.image;
  } else
    return e;
}
function dM(e, t, r, n, i) {
  if (e)
    if (typeof e == "string") {
      if (t && t.__zrImageSrc === e || !r)
        return t;
      var o = XR.get(e), a = { hostEl: r, cb: n, cbPayload: i };
      return o ? (t = o.image, !IS(t) && o.pending.push(a)) : (t = va.loadImage(e, XL, XL), t.__zrImageSrc = e, XR.put(e, t.__cachedImgObj = {
        image: t,
        pending: [a]
      })), t;
    } else
      return e;
  else return t;
}
function XL() {
  var e = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var t = 0; t < e.pending.length; t++) {
    var r = e.pending[t], n = r.cb;
    n && n(this, r.cbPayload), r.hostEl.dirty();
  }
  e.pending.length = 0;
}
function IS(e) {
  return e && e.width && e.height;
}
var Nb = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function H$(e, t, r, n, i) {
  if (!t)
    return "";
  var o = (e + "").split(`
`);
  i = z$(t, r, n, i);
  for (var a = 0, s = o.length; a < s; a++)
    o[a] = $$(o[a], i);
  return o.join(`
`);
}
function z$(e, t, r, n) {
  n = n || {};
  var i = se({}, n);
  i.font = t, r = st(r, "..."), i.maxIterations = st(n.maxIterations, 2);
  var o = i.minChar = st(n.minChar, 0);
  i.cnCharWidth = no("国", t);
  var a = i.ascCharWidth = no("a", t);
  i.placeholder = st(n.placeholder, "");
  for (var s = e = Math.max(0, e - 1), l = 0; l < o && s >= a; l++)
    s -= a;
  var u = no(r, t);
  return u > s && (r = "", u = 0), s = e - u, i.ellipsis = r, i.ellipsisWidth = u, i.contentWidth = s, i.containerWidth = e, i;
}
function $$(e, t) {
  var r = t.containerWidth, n = t.font, i = t.contentWidth;
  if (!r)
    return "";
  var o = no(e, n);
  if (o <= r)
    return e;
  for (var a = 0; ; a++) {
    if (o <= i || a >= t.maxIterations) {
      e += t.ellipsis;
      break;
    }
    var s = a === 0 ? Gve(e, i, t.ascCharWidth, t.cnCharWidth) : o > 0 ? Math.floor(e.length * i / o) : 0;
    e = e.substr(0, s), o = no(e, n);
  }
  return e === "" && (e = t.placeholder), e;
}
function Gve(e, t, r, n) {
  for (var i = 0, o = 0, a = e.length; o < a && i < t; o++) {
    var s = e.charCodeAt(o);
    i += 0 <= s && s <= 127 ? r : n;
  }
  return o;
}
function Hve(e, t) {
  e != null && (e += "");
  var r = t.overflow, n = t.padding, i = t.font, o = r === "truncate", a = TS(i), s = st(t.lineHeight, a), l = !!t.backgroundColor, u = t.lineOverflow === "truncate", c = t.width, d;
  c != null && (r === "break" || r === "breakAll") ? d = e ? W$(e, t.font, c, r === "breakAll", 0).lines : [] : d = e ? e.split(`
`) : [];
  var h = d.length * s, f = st(t.height, h);
  if (h > f && u) {
    var p = Math.floor(f / s);
    d = d.slice(0, p);
  }
  if (e && o && c != null)
    for (var g = z$(c, i, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), v = 0; v < d.length; v++)
      d[v] = $$(d[v], g);
  for (var m = f, y = 0, v = 0; v < d.length; v++)
    y = Math.max(no(d[v], i), y);
  c == null && (c = y);
  var C = y;
  return n && (m += n[0] + n[2], C += n[1] + n[3], c += n[1] + n[3]), l && (C = c), {
    lines: d,
    height: f,
    outerWidth: C,
    outerHeight: m,
    lineHeight: s,
    calculatedLineHeight: a,
    contentWidth: y,
    contentHeight: h,
    width: c
  };
}
var zve = /* @__PURE__ */ function() {
  function e() {
  }
  return e;
}(), QL = /* @__PURE__ */ function() {
  function e(t) {
    this.tokens = [], t && (this.tokens = t);
  }
  return e;
}(), $ve = /* @__PURE__ */ function() {
  function e() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [];
  }
  return e;
}();
function Wve(e, t) {
  var r = new $ve();
  if (e != null && (e += ""), !e)
    return r;
  for (var n = t.width, i = t.height, o = t.overflow, a = (o === "break" || o === "breakAll") && n != null ? { width: n, accumWidth: 0, breakAll: o === "breakAll" } : null, s = Nb.lastIndex = 0, l; (l = Nb.exec(e)) != null; ) {
    var u = l.index;
    u > s && kb(r, e.substring(s, u), t, a), kb(r, l[2], t, a, l[1]), s = Nb.lastIndex;
  }
  s < e.length && kb(r, e.substring(s, e.length), t, a);
  var c = [], d = 0, h = 0, f = t.padding, p = o === "truncate", g = t.lineOverflow === "truncate";
  function v(F, G, M) {
    F.width = G, F.lineHeight = M, d += M, h = Math.max(h, G);
  }
  e: for (var m = 0; m < r.lines.length; m++) {
    for (var y = r.lines[m], C = 0, S = 0, b = 0; b < y.tokens.length; b++) {
      var w = y.tokens[b], x = w.styleName && t.rich[w.styleName] || {}, E = w.textPadding = x.padding, R = E ? E[1] + E[3] : 0, _ = w.font = x.font || t.font;
      w.contentHeight = TS(_);
      var P = st(x.height, w.contentHeight);
      if (w.innerHeight = P, E && (P += E[0] + E[2]), w.height = P, w.lineHeight = ro(x.lineHeight, t.lineHeight, P), w.align = x && x.align || t.align, w.verticalAlign = x && x.verticalAlign || "middle", g && i != null && d + w.lineHeight > i) {
        b > 0 ? (y.tokens = y.tokens.slice(0, b), v(y, S, C), r.lines = r.lines.slice(0, m + 1)) : r.lines = r.lines.slice(0, m);
        break e;
      }
      var D = x.width, I = D == null || D === "auto";
      if (typeof D == "string" && D.charAt(D.length - 1) === "%")
        w.percentWidth = D, c.push(w), w.contentWidth = no(w.text, _);
      else {
        if (I) {
          var A = x.backgroundColor, O = A && A.image;
          O && (O = Bve(O), IS(O) && (w.width = Math.max(w.width, O.width * P / O.height)));
        }
        var L = p && n != null ? n - S : null;
        L != null && L < w.width ? !I || L < R ? (w.text = "", w.width = w.contentWidth = 0) : (w.text = H$(w.text, L - R, _, t.ellipsis, { minChar: t.truncateMinChar }), w.width = w.contentWidth = no(w.text, _)) : w.contentWidth = no(w.text, _);
      }
      w.width += R, S += w.width, x && (C = Math.max(C, w.lineHeight));
    }
    v(y, S, C);
  }
  r.outerWidth = r.width = st(n, h), r.outerHeight = r.height = st(i, d), r.contentHeight = d, r.contentWidth = h, f && (r.outerWidth += f[1] + f[3], r.outerHeight += f[0] + f[2]);
  for (var m = 0; m < c.length; m++) {
    var w = c[m], N = w.percentWidth;
    w.width = parseInt(N, 10) / 100 * r.width;
  }
  return r;
}
function kb(e, t, r, n, i) {
  var o = t === "", a = i && r.rich[i] || {}, s = e.lines, l = a.font || r.font, u = !1, c, d;
  if (n) {
    var h = a.padding, f = h ? h[1] + h[3] : 0;
    if (a.width != null && a.width !== "auto") {
      var p = ya(a.width, n.width) + f;
      s.length > 0 && p + n.accumWidth > n.width && (c = t.split(`
`), u = !0), n.accumWidth = p;
    } else {
      var g = W$(t, l, n.width, n.breakAll, n.accumWidth);
      n.accumWidth = g.accumWidth + f, d = g.linesWidths, c = g.lines;
    }
  } else
    c = t.split(`
`);
  for (var v = 0; v < c.length; v++) {
    var m = c[v], y = new zve();
    if (y.styleName = i, y.text = m, y.isLineHolder = !m && !o, typeof a.width == "number" ? y.width = a.width : y.width = d ? d[v] : no(m, l), !v && !u) {
      var C = (s[s.length - 1] || (s[0] = new QL())).tokens, S = C.length;
      S === 1 && C[0].isLineHolder ? C[0] = y : (m || !S || o) && C.push(y);
    } else
      s.push(new QL([y]));
  }
}
function jve(e) {
  var t = e.charCodeAt(0);
  return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
}
var Uve = Oo(",&?/;] ".split(""), function(e, t) {
  return e[t] = !0, e;
}, {});
function Kve(e) {
  return jve(e) ? !!Uve[e] : !0;
}
function W$(e, t, r, n, i) {
  for (var o = [], a = [], s = "", l = "", u = 0, c = 0, d = 0; d < e.length; d++) {
    var h = e.charAt(d);
    if (h === `
`) {
      l && (s += l, c += u), o.push(s), a.push(c), s = "", l = "", u = 0, c = 0;
      continue;
    }
    var f = no(h, t), p = n ? !1 : !Kve(h);
    if (o.length ? c + f > r : i + c + f > r) {
      c ? (s || l) && (p ? (s || (s = l, l = "", u = 0, c = u), o.push(s), a.push(c - u), l += h, u += f, s = "", c = u) : (l && (s += l, l = "", u = 0), o.push(s), a.push(c), s = h, c = f)) : p ? (o.push(l), a.push(u), l = h, u = f) : (o.push(h), a.push(f));
      continue;
    }
    c += f, p ? (l += h, u += f) : (l && (s += l, l = "", u = 0), s += h);
  }
  return !o.length && !s && (s = e, l = "", u = 0), l && (s += l), s && (o.push(s), a.push(c)), o.length === 1 && (c += i), {
    accumWidth: c,
    lines: o,
    linesWidths: a
  };
}
var QR = "__zr_style_" + Math.round(Math.random() * 10), hc = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, FS = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
hc[QR] = !0;
var JL = ["z", "z2", "invisible"], Yve = ["invisible"], qve = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype._init = function(r) {
    for (var n = At(r), i = 0; i < n.length; i++) {
      var o = n[i];
      o === "style" ? this.useStyle(r[o]) : e.prototype.attrKV.call(this, o, r[o]);
    }
    this.style || this.useStyle({});
  }, t.prototype.beforeBrush = function() {
  }, t.prototype.afterBrush = function() {
  }, t.prototype.innerBeforeBrush = function() {
  }, t.prototype.innerAfterBrush = function() {
  }, t.prototype.shouldBePainted = function(r, n, i, o) {
    var a = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && Zve(this, r, n) || a && !a[0] && !a[3])
      return !1;
    if (i && this.__clipPaths) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (o && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, t.prototype.contain = function(r, n) {
    return this.rectContain(r, n);
  }, t.prototype.traverse = function(r, n) {
    r.call(n, this);
  }, t.prototype.rectContain = function(r, n) {
    var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect();
    return o.contain(i[0], i[1]);
  }, t.prototype.getPaintRect = function() {
    var r = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var n = this.transform, i = this.getBoundingRect(), o = this.style, a = o.shadowBlur || 0, s = o.shadowOffsetX || 0, l = o.shadowOffsetY || 0;
      r = this._paintRect || (this._paintRect = new St(0, 0, 0, 0)), n ? St.applyTransform(r, i, n) : r.copy(i), (a || s || l) && (r.width += a * 2 + Math.abs(s), r.height += a * 2 + Math.abs(l), r.x = Math.min(r.x, r.x + s - a), r.y = Math.min(r.y, r.y + l - a));
      var u = this.dirtyRectTolerance;
      r.isZero() || (r.x = Math.floor(r.x - u), r.y = Math.floor(r.y - u), r.width = Math.ceil(r.width + 1 + u * 2), r.height = Math.ceil(r.height + 1 + u * 2));
    }
    return r;
  }, t.prototype.setPrevPaintRect = function(r) {
    r ? (this._prevPaintRect = this._prevPaintRect || new St(0, 0, 0, 0), this._prevPaintRect.copy(r)) : this._prevPaintRect = null;
  }, t.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, t.prototype.animateStyle = function(r) {
    return this.animate("style", r);
  }, t.prototype.updateDuringAnimation = function(r) {
    r === "style" ? this.dirtyStyle() : this.markRedraw();
  }, t.prototype.attrKV = function(r, n) {
    r !== "style" ? e.prototype.attrKV.call(this, r, n) : this.style ? this.setStyle(n) : this.useStyle(n);
  }, t.prototype.setStyle = function(r, n) {
    return typeof r == "string" ? this.style[r] = n : se(this.style, r), this.dirtyStyle(), this;
  }, t.prototype.dirtyStyle = function(r) {
    r || this.markRedraw(), this.__dirty |= xp, this._rect && (this._rect = null);
  }, t.prototype.dirty = function() {
    this.dirtyStyle();
  }, t.prototype.styleChanged = function() {
    return !!(this.__dirty & xp);
  }, t.prototype.styleUpdated = function() {
    this.__dirty &= ~xp;
  }, t.prototype.createStyle = function(r) {
    return xv(hc, r);
  }, t.prototype.useStyle = function(r) {
    r[QR] || (r = this.createStyle(r)), this.__inHover ? this.__hoverStyle = r : this.style = r, this.dirtyStyle();
  }, t.prototype.isStyleObject = function(r) {
    return r[QR];
  }, t.prototype._innerSaveToNormal = function(r) {
    e.prototype._innerSaveToNormal.call(this, r);
    var n = this._normalState;
    r.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(r, n, JL);
  }, t.prototype._applyStateObj = function(r, n, i, o, a, s) {
    e.prototype._applyStateObj.call(this, r, n, i, o, a, s);
    var l = !(n && o), u;
    if (n && n.style ? a ? o ? u = n.style : (u = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), o ? this.style : i.style), this._mergeStyle(u, n.style)) : l && (u = i.style), u)
      if (a) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var d = At(c), h = 0; h < d.length; h++) {
            var f = d[h];
            f in u && (u[f] = u[f], this.style[f] = c[f]);
          }
        for (var p = At(u), h = 0; h < p.length; h++) {
          var f = p[h];
          this.style[f] = this.style[f];
        }
        this._transitionState(r, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? Yve : JL, h = 0; h < g.length; h++) {
      var f = g[h];
      n && n[f] != null ? this[f] = n[f] : l && i[f] != null && (this[f] = i[f]);
    }
  }, t.prototype._mergeStates = function(r) {
    for (var n = e.prototype._mergeStates.call(this, r), i, o = 0; o < r.length; o++) {
      var a = r[o];
      a.style && (i = i || {}, this._mergeStyle(i, a.style));
    }
    return i && (n.style = i), n;
  }, t.prototype._mergeStyle = function(r, n) {
    return se(r, n), r;
  }, t.prototype.getAnimationStyleProps = function() {
    return FS;
  }, t.initDefaultProps = function() {
    var r = t.prototype;
    r.type = "displayable", r.invisible = !1, r.z = 0, r.z2 = 0, r.zlevel = 0, r.culling = !1, r.cursor = "pointer", r.rectHover = !1, r.incremental = !1, r._rect = null, r.dirtyRectTolerance = 0, r.__dirty = qi | xp;
  }(), t;
}(PS), Vb = new St(0, 0, 0, 0), Bb = new St(0, 0, 0, 0);
function Zve(e, t, r) {
  return Vb.copy(e.getBoundingRect()), e.transform && Vb.applyTransform(e.transform), Bb.width = t, Bb.height = r, !Vb.intersect(Bb);
}
const ko = qve;
var Ai = Math.min, Ii = Math.max, Gb = Math.sin, Hb = Math.cos, yu = Math.PI * 2, Fm = ru(), Lm = ru(), Om = ru();
function LS(e, t, r) {
  if (e.length !== 0) {
    for (var n = e[0], i = n[0], o = n[0], a = n[1], s = n[1], l = 1; l < e.length; l++)
      n = e[l], i = Ai(i, n[0]), o = Ii(o, n[0]), a = Ai(a, n[1]), s = Ii(s, n[1]);
    t[0] = i, t[1] = a, r[0] = o, r[1] = s;
  }
}
function eO(e, t, r, n, i, o) {
  i[0] = Ai(e, r), i[1] = Ai(t, n), o[0] = Ii(e, r), o[1] = Ii(t, n);
}
var tO = [], rO = [];
function Xve(e, t, r, n, i, o, a, s, l, u) {
  var c = s$, d = Sn, h = c(e, r, i, a, tO);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var f = 0; f < h; f++) {
    var p = d(e, r, i, a, tO[f]);
    l[0] = Ai(p, l[0]), u[0] = Ii(p, u[0]);
  }
  h = c(t, n, o, s, rO);
  for (var f = 0; f < h; f++) {
    var g = d(t, n, o, s, rO[f]);
    l[1] = Ai(g, l[1]), u[1] = Ii(g, u[1]);
  }
  l[0] = Ai(e, l[0]), u[0] = Ii(e, u[0]), l[0] = Ai(a, l[0]), u[0] = Ii(a, u[0]), l[1] = Ai(t, l[1]), u[1] = Ii(t, u[1]), l[1] = Ai(s, l[1]), u[1] = Ii(s, u[1]);
}
function Qve(e, t, r, n, i, o, a, s) {
  var l = u$, u = Pn, c = Ii(Ai(l(e, r, i), 1), 0), d = Ii(Ai(l(t, n, o), 1), 0), h = u(e, r, i, c), f = u(t, n, o, d);
  a[0] = Ai(e, i, h), a[1] = Ai(t, o, f), s[0] = Ii(e, i, h), s[1] = Ii(t, o, f);
}
function Jve(e, t, r, n, i, o, a, s, l) {
  var u = Rs, c = _s, d = Math.abs(i - o);
  if (d % yu < 1e-4 && d > 1e-4) {
    s[0] = e - r, s[1] = t - n, l[0] = e + r, l[1] = t + n;
    return;
  }
  if (Fm[0] = Hb(i) * r + e, Fm[1] = Gb(i) * n + t, Lm[0] = Hb(o) * r + e, Lm[1] = Gb(o) * n + t, u(s, Fm, Lm), c(l, Fm, Lm), i = i % yu, i < 0 && (i = i + yu), o = o % yu, o < 0 && (o = o + yu), i > o && !a ? o += yu : i < o && a && (i += yu), a) {
    var h = o;
    o = i, i = h;
  }
  for (var f = 0; f < o; f += Math.PI / 2)
    f > i && (Om[0] = Hb(f) * r + e, Om[1] = Gb(f) * n + t, u(s, Om, s), c(l, Om, l));
}
var Cr = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, Cu = [], Su = [], _a = [], ll = [], Ta = [], Pa = [], zb = Math.min, $b = Math.max, wu = Math.cos, bu = Math.sin, fs = Math.abs, JR = Math.PI, yl = JR * 2, Wb = typeof Float32Array < "u", Yf = [];
function jb(e) {
  var t = Math.round(e / JR * 1e8) / 1e8;
  return t % 2 * JR;
}
function hM(e, t) {
  var r = jb(e[0]);
  r < 0 && (r += yl);
  var n = r - e[0], i = e[1];
  i += n, !t && i - r >= yl ? i = r + yl : t && r - i >= yl ? i = r - yl : !t && r > i ? i = r + (yl - jb(r - i)) : t && r < i && (i = r - (yl - jb(i - r))), e[0] = r, e[1] = i;
}
var es = function() {
  function e(t) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return e.prototype.increaseVersion = function() {
    this._version++;
  }, e.prototype.getVersion = function() {
    return this._version;
  }, e.prototype.setScale = function(t, r, n) {
    n = n || 0, n > 0 && (this._ux = fs(n / j0 / t) || 0, this._uy = fs(n / j0 / r) || 0);
  }, e.prototype.setDPR = function(t) {
    this.dpr = t;
  }, e.prototype.setContext = function(t) {
    this._ctx = t;
  }, e.prototype.getContext = function() {
    return this._ctx;
  }, e.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, e.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, e.prototype.moveTo = function(t, r) {
    return this._drawPendingPt(), this.addData(Cr.M, t, r), this._ctx && this._ctx.moveTo(t, r), this._x0 = t, this._y0 = r, this._xi = t, this._yi = r, this;
  }, e.prototype.lineTo = function(t, r) {
    var n = fs(t - this._xi), i = fs(r - this._yi), o = n > this._ux || i > this._uy;
    if (this.addData(Cr.L, t, r), this._ctx && o && this._ctx.lineTo(t, r), o)
      this._xi = t, this._yi = r, this._pendingPtDist = 0;
    else {
      var a = n * n + i * i;
      a > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = r, this._pendingPtDist = a);
    }
    return this;
  }, e.prototype.bezierCurveTo = function(t, r, n, i, o, a) {
    return this._drawPendingPt(), this.addData(Cr.C, t, r, n, i, o, a), this._ctx && this._ctx.bezierCurveTo(t, r, n, i, o, a), this._xi = o, this._yi = a, this;
  }, e.prototype.quadraticCurveTo = function(t, r, n, i) {
    return this._drawPendingPt(), this.addData(Cr.Q, t, r, n, i), this._ctx && this._ctx.quadraticCurveTo(t, r, n, i), this._xi = n, this._yi = i, this;
  }, e.prototype.arc = function(t, r, n, i, o, a) {
    this._drawPendingPt(), Yf[0] = i, Yf[1] = o, hM(Yf, a), i = Yf[0], o = Yf[1];
    var s = o - i;
    return this.addData(Cr.A, t, r, n, n, i, s, 0, a ? 0 : 1), this._ctx && this._ctx.arc(t, r, n, i, o, a), this._xi = wu(o) * n + t, this._yi = bu(o) * n + r, this;
  }, e.prototype.arcTo = function(t, r, n, i, o) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, r, n, i, o), this;
  }, e.prototype.rect = function(t, r, n, i) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(t, r, n, i), this.addData(Cr.R, t, r, n, i), this;
  }, e.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(Cr.Z);
    var t = this._ctx, r = this._x0, n = this._y0;
    return t && t.closePath(), this._xi = r, this._yi = n, this;
  }, e.prototype.fill = function(t) {
    t && t.fill(), this.toStatic();
  }, e.prototype.stroke = function(t) {
    t && t.stroke(), this.toStatic();
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.setData = function(t) {
    var r = t.length;
    !(this.data && this.data.length === r) && Wb && (this.data = new Float32Array(r));
    for (var n = 0; n < r; n++)
      this.data[n] = t[n];
    this._len = r;
  }, e.prototype.appendPath = function(t) {
    t instanceof Array || (t = [t]);
    for (var r = t.length, n = 0, i = this._len, o = 0; o < r; o++)
      n += t[o].len();
    Wb && this.data instanceof Float32Array && (this.data = new Float32Array(i + n));
    for (var o = 0; o < r; o++)
      for (var a = t[o].data, s = 0; s < a.length; s++)
        this.data[i++] = a[s];
    this._len = i;
  }, e.prototype.addData = function(t, r, n, i, o, a, s, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var d = 0; d < arguments.length; d++)
        c[this._len++] = arguments[d];
    }
  }, e.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, e.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var t = [], r = 0; r < this._len; r++)
        t[r] = this.data[r];
      this.data = t;
    }
  }, e.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var t = this.data;
      t instanceof Array && (t.length = this._len, Wb && this._len > 11 && (this.data = new Float32Array(t)));
    }
  }, e.prototype.getBoundingRect = function() {
    _a[0] = _a[1] = Ta[0] = Ta[1] = Number.MAX_VALUE, ll[0] = ll[1] = Pa[0] = Pa[1] = -Number.MAX_VALUE;
    var t = this.data, r = 0, n = 0, i = 0, o = 0, a;
    for (a = 0; a < this._len; ) {
      var s = t[a++], l = a === 1;
      switch (l && (r = t[a], n = t[a + 1], i = r, o = n), s) {
        case Cr.M:
          r = i = t[a++], n = o = t[a++], Ta[0] = i, Ta[1] = o, Pa[0] = i, Pa[1] = o;
          break;
        case Cr.L:
          eO(r, n, t[a], t[a + 1], Ta, Pa), r = t[a++], n = t[a++];
          break;
        case Cr.C:
          Xve(r, n, t[a++], t[a++], t[a++], t[a++], t[a], t[a + 1], Ta, Pa), r = t[a++], n = t[a++];
          break;
        case Cr.Q:
          Qve(r, n, t[a++], t[a++], t[a], t[a + 1], Ta, Pa), r = t[a++], n = t[a++];
          break;
        case Cr.A:
          var u = t[a++], c = t[a++], d = t[a++], h = t[a++], f = t[a++], p = t[a++] + f;
          a += 1;
          var g = !t[a++];
          l && (i = wu(f) * d + u, o = bu(f) * h + c), Jve(u, c, d, h, f, p, g, Ta, Pa), r = wu(p) * d + u, n = bu(p) * h + c;
          break;
        case Cr.R:
          i = r = t[a++], o = n = t[a++];
          var v = t[a++], m = t[a++];
          eO(i, o, i + v, o + m, Ta, Pa);
          break;
        case Cr.Z:
          r = i, n = o;
          break;
      }
      Rs(_a, _a, Ta), _s(ll, ll, Pa);
    }
    return a === 0 && (_a[0] = _a[1] = ll[0] = ll[1] = 0), new St(_a[0], _a[1], ll[0] - _a[0], ll[1] - _a[1]);
  }, e.prototype._calculateLength = function() {
    var t = this.data, r = this._len, n = this._ux, i = this._uy, o = 0, a = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, d = 0, h = 0; h < r; ) {
      var f = t[h++], p = h === 1;
      p && (o = t[h], a = t[h + 1], s = o, l = a);
      var g = -1;
      switch (f) {
        case Cr.M:
          o = s = t[h++], a = l = t[h++];
          break;
        case Cr.L: {
          var v = t[h++], m = t[h++], y = v - o, C = m - a;
          (fs(y) > n || fs(C) > i || h === r - 1) && (g = Math.sqrt(y * y + C * C), o = v, a = m);
          break;
        }
        case Cr.C: {
          var S = t[h++], b = t[h++], v = t[h++], m = t[h++], w = t[h++], x = t[h++];
          g = dge(o, a, S, b, v, m, w, x, 10), o = w, a = x;
          break;
        }
        case Cr.Q: {
          var S = t[h++], b = t[h++], v = t[h++], m = t[h++];
          g = fge(o, a, S, b, v, m, 10), o = v, a = m;
          break;
        }
        case Cr.A:
          var E = t[h++], R = t[h++], _ = t[h++], P = t[h++], D = t[h++], I = t[h++], A = I + D;
          h += 1, p && (s = wu(D) * _ + E, l = bu(D) * P + R), g = $b(_, P) * zb(yl, Math.abs(I)), o = wu(A) * _ + E, a = bu(A) * P + R;
          break;
        case Cr.R: {
          s = o = t[h++], l = a = t[h++];
          var O = t[h++], L = t[h++];
          g = O * 2 + L * 2;
          break;
        }
        case Cr.Z: {
          var y = s - o, C = l - a;
          g = Math.sqrt(y * y + C * C), o = s, a = l;
          break;
        }
      }
      g >= 0 && (u[d++] = g, c += g);
    }
    return this._pathLen = c, c;
  }, e.prototype.rebuildPath = function(t, r) {
    var n = this.data, i = this._ux, o = this._uy, a = this._len, s, l, u, c, d, h, f = r < 1, p, g, v = 0, m = 0, y, C = 0, S, b;
    if (!(f && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, g = this._pathLen, y = r * g, !y)))
      e: for (var w = 0; w < a; ) {
        var x = n[w++], E = w === 1;
        switch (E && (u = n[w], c = n[w + 1], s = u, l = c), x !== Cr.L && C > 0 && (t.lineTo(S, b), C = 0), x) {
          case Cr.M:
            s = u = n[w++], l = c = n[w++], t.moveTo(u, c);
            break;
          case Cr.L: {
            d = n[w++], h = n[w++];
            var R = fs(d - u), _ = fs(h - c);
            if (R > i || _ > o) {
              if (f) {
                var P = p[m++];
                if (v + P > y) {
                  var D = (y - v) / P;
                  t.lineTo(u * (1 - D) + d * D, c * (1 - D) + h * D);
                  break e;
                }
                v += P;
              }
              t.lineTo(d, h), u = d, c = h, C = 0;
            } else {
              var I = R * R + _ * _;
              I > C && (S = d, b = h, C = I);
            }
            break;
          }
          case Cr.C: {
            var A = n[w++], O = n[w++], L = n[w++], N = n[w++], F = n[w++], G = n[w++];
            if (f) {
              var P = p[m++];
              if (v + P > y) {
                var D = (y - v) / P;
                Wl(u, A, L, F, D, Cu), Wl(c, O, N, G, D, Su), t.bezierCurveTo(Cu[1], Su[1], Cu[2], Su[2], Cu[3], Su[3]);
                break e;
              }
              v += P;
            }
            t.bezierCurveTo(A, O, L, N, F, G), u = F, c = G;
            break;
          }
          case Cr.Q: {
            var A = n[w++], O = n[w++], L = n[w++], N = n[w++];
            if (f) {
              var P = p[m++];
              if (v + P > y) {
                var D = (y - v) / P;
                Ig(u, A, L, D, Cu), Ig(c, O, N, D, Su), t.quadraticCurveTo(Cu[1], Su[1], Cu[2], Su[2]);
                break e;
              }
              v += P;
            }
            t.quadraticCurveTo(A, O, L, N), u = L, c = N;
            break;
          }
          case Cr.A:
            var M = n[w++], V = n[w++], z = n[w++], k = n[w++], $ = n[w++], W = n[w++], j = n[w++], U = !n[w++], Z = z > k ? z : k, ee = fs(z - k) > 1e-3, J = $ + W, X = !1;
            if (f) {
              var P = p[m++];
              v + P > y && (J = $ + W * (y - v) / P, X = !0), v += P;
            }
            if (ee && t.ellipse ? t.ellipse(M, V, z, k, j, $, J, U) : t.arc(M, V, Z, $, J, U), X)
              break e;
            E && (s = wu($) * z + M, l = bu($) * k + V), u = wu(J) * z + M, c = bu(J) * k + V;
            break;
          case Cr.R:
            s = u = n[w], l = c = n[w + 1], d = n[w++], h = n[w++];
            var Y = n[w++], de = n[w++];
            if (f) {
              var P = p[m++];
              if (v + P > y) {
                var K = y - v;
                t.moveTo(d, h), t.lineTo(d + zb(K, Y), h), K -= Y, K > 0 && t.lineTo(d + Y, h + zb(K, de)), K -= de, K > 0 && t.lineTo(d + $b(Y - K, 0), h + de), K -= Y, K > 0 && t.lineTo(d, h + $b(de - K, 0));
                break e;
              }
              v += P;
            }
            t.rect(d, h, Y, de);
            break;
          case Cr.Z:
            if (f) {
              var P = p[m++];
              if (v + P > y) {
                var D = (y - v) / P;
                t.lineTo(u * (1 - D) + s * D, c * (1 - D) + l * D);
                break e;
              }
              v += P;
            }
            t.closePath(), u = s, c = l;
        }
      }
  }, e.prototype.clone = function() {
    var t = new e(), r = this.data;
    return t.data = r.slice ? r.slice() : Array.prototype.slice.call(r), t._len = this._len, t;
  }, e.CMD = Cr, e.initDefaultProps = function() {
    var t = e.prototype;
    t._saveData = !0, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
  }(), e;
}();
function Sl(e, t, r, n, i, o, a) {
  if (i === 0)
    return !1;
  var s = i, l = 0, u = e;
  if (a > t + s && a > n + s || a < t - s && a < n - s || o > e + s && o > r + s || o < e - s && o < r - s)
    return !1;
  if (e !== r)
    l = (t - n) / (e - r), u = (e * n - r * t) / (e - r);
  else
    return Math.abs(o - e) <= s / 2;
  var c = l * o - a + u, d = c * c / (l * l + 1);
  return d <= s / 2 * s / 2;
}
function eme(e, t, r, n, i, o, a, s, l, u, c) {
  if (l === 0)
    return !1;
  var d = l;
  if (c > t + d && c > n + d && c > o + d && c > s + d || c < t - d && c < n - d && c < o - d && c < s - d || u > e + d && u > r + d && u > i + d && u > a + d || u < e - d && u < r - d && u < i - d && u < a - d)
    return !1;
  var h = l$(e, t, r, n, i, o, a, s, u, c, null);
  return h <= d / 2;
}
function j$(e, t, r, n, i, o, a, s, l) {
  if (a === 0)
    return !1;
  var u = a;
  if (l > t + u && l > n + u && l > o + u || l < t - u && l < n - u && l < o - u || s > e + u && s > r + u && s > i + u || s < e - u && s < r - u && s < i - u)
    return !1;
  var c = c$(e, t, r, n, i, o, s, l, null);
  return c <= u / 2;
}
var nO = Math.PI * 2;
function eo(e) {
  return e %= nO, e < 0 && (e += nO), e;
}
var qf = Math.PI * 2;
function tme(e, t, r, n, i, o, a, s, l) {
  if (a === 0)
    return !1;
  var u = a;
  s -= e, l -= t;
  var c = Math.sqrt(s * s + l * l);
  if (c - u > r || c + u < r)
    return !1;
  if (Math.abs(n - i) % qf < 1e-4)
    return !0;
  if (o) {
    var d = n;
    n = eo(i), i = eo(d);
  } else
    n = eo(n), i = eo(i);
  n > i && (i += qf);
  var h = Math.atan2(l, s);
  return h < 0 && (h += qf), h >= n && h <= i || h + qf >= n && h + qf <= i;
}
function Ss(e, t, r, n, i, o) {
  if (o > t && o > n || o < t && o < n || n === t)
    return 0;
  var a = (o - t) / (n - t), s = n < t ? 1 : -1;
  (a === 1 || a === 0) && (s = n < t ? 0.5 : -0.5);
  var l = a * (r - e) + e;
  return l === i ? 1 / 0 : l > i ? s : 0;
}
var ul = es.CMD, xu = Math.PI * 2, rme = 1e-4;
function nme(e, t) {
  return Math.abs(e - t) < rme;
}
var ci = [-1, -1, -1], So = [-1, -1];
function ime() {
  var e = So[0];
  So[0] = So[1], So[1] = e;
}
function ome(e, t, r, n, i, o, a, s, l, u) {
  if (u > t && u > n && u > o && u > s || u < t && u < n && u < o && u < s)
    return 0;
  var c = H0(t, n, o, s, u, ci);
  if (c === 0)
    return 0;
  for (var d = 0, h = -1, f = void 0, p = void 0, g = 0; g < c; g++) {
    var v = ci[g], m = v === 0 || v === 1 ? 0.5 : 1, y = Sn(e, r, i, a, v);
    y < l || (h < 0 && (h = s$(t, n, o, s, So), So[1] < So[0] && h > 1 && ime(), f = Sn(t, n, o, s, So[0]), h > 1 && (p = Sn(t, n, o, s, So[1]))), h === 2 ? v < So[0] ? d += f < t ? m : -m : v < So[1] ? d += p < f ? m : -m : d += s < p ? m : -m : v < So[0] ? d += f < t ? m : -m : d += s < f ? m : -m);
  }
  return d;
}
function ame(e, t, r, n, i, o, a, s) {
  if (s > t && s > n && s > o || s < t && s < n && s < o)
    return 0;
  var l = hge(t, n, o, s, ci);
  if (l === 0)
    return 0;
  var u = u$(t, n, o);
  if (u >= 0 && u <= 1) {
    for (var c = 0, d = Pn(t, n, o, u), h = 0; h < l; h++) {
      var f = ci[h] === 0 || ci[h] === 1 ? 0.5 : 1, p = Pn(e, r, i, ci[h]);
      p < a || (ci[h] < u ? c += d < t ? f : -f : c += o < d ? f : -f);
    }
    return c;
  } else {
    var f = ci[0] === 0 || ci[0] === 1 ? 0.5 : 1, p = Pn(e, r, i, ci[0]);
    return p < a ? 0 : o < t ? f : -f;
  }
}
function sme(e, t, r, n, i, o, a, s) {
  if (s -= t, s > r || s < -r)
    return 0;
  var l = Math.sqrt(r * r - s * s);
  ci[0] = -l, ci[1] = l;
  var u = Math.abs(n - i);
  if (u < 1e-4)
    return 0;
  if (u >= xu - 1e-4) {
    n = 0, i = xu;
    var c = o ? 1 : -1;
    return a >= ci[0] + e && a <= ci[1] + e ? c : 0;
  }
  if (n > i) {
    var d = n;
    n = i, i = d;
  }
  n < 0 && (n += xu, i += xu);
  for (var h = 0, f = 0; f < 2; f++) {
    var p = ci[f];
    if (p + e > a) {
      var g = Math.atan2(s, p), c = o ? 1 : -1;
      g < 0 && (g = xu + g), (g >= n && g <= i || g + xu >= n && g + xu <= i) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), h += c);
    }
  }
  return h;
}
function U$(e, t, r, n, i) {
  for (var o = e.data, a = e.len(), s = 0, l = 0, u = 0, c = 0, d = 0, h, f, p = 0; p < a; ) {
    var g = o[p++], v = p === 1;
    switch (g === ul.M && p > 1 && (r || (s += Ss(l, u, c, d, n, i))), v && (l = o[p], u = o[p + 1], c = l, d = u), g) {
      case ul.M:
        c = o[p++], d = o[p++], l = c, u = d;
        break;
      case ul.L:
        if (r) {
          if (Sl(l, u, o[p], o[p + 1], t, n, i))
            return !0;
        } else
          s += Ss(l, u, o[p], o[p + 1], n, i) || 0;
        l = o[p++], u = o[p++];
        break;
      case ul.C:
        if (r) {
          if (eme(l, u, o[p++], o[p++], o[p++], o[p++], o[p], o[p + 1], t, n, i))
            return !0;
        } else
          s += ome(l, u, o[p++], o[p++], o[p++], o[p++], o[p], o[p + 1], n, i) || 0;
        l = o[p++], u = o[p++];
        break;
      case ul.Q:
        if (r) {
          if (j$(l, u, o[p++], o[p++], o[p], o[p + 1], t, n, i))
            return !0;
        } else
          s += ame(l, u, o[p++], o[p++], o[p], o[p + 1], n, i) || 0;
        l = o[p++], u = o[p++];
        break;
      case ul.A:
        var m = o[p++], y = o[p++], C = o[p++], S = o[p++], b = o[p++], w = o[p++];
        p += 1;
        var x = !!(1 - o[p++]);
        h = Math.cos(b) * C + m, f = Math.sin(b) * S + y, v ? (c = h, d = f) : s += Ss(l, u, h, f, n, i);
        var E = (n - m) * S / C + m;
        if (r) {
          if (tme(m, y, S, b, b + w, x, t, E, i))
            return !0;
        } else
          s += sme(m, y, S, b, b + w, x, E, i);
        l = Math.cos(b + w) * C + m, u = Math.sin(b + w) * S + y;
        break;
      case ul.R:
        c = l = o[p++], d = u = o[p++];
        var R = o[p++], _ = o[p++];
        if (h = c + R, f = d + _, r) {
          if (Sl(c, d, h, d, t, n, i) || Sl(h, d, h, f, t, n, i) || Sl(h, f, c, f, t, n, i) || Sl(c, f, c, d, t, n, i))
            return !0;
        } else
          s += Ss(h, d, h, f, n, i), s += Ss(c, f, c, d, n, i);
        break;
      case ul.Z:
        if (r) {
          if (Sl(l, u, c, d, t, n, i))
            return !0;
        } else
          s += Ss(l, u, c, d, n, i);
        l = c, u = d;
        break;
    }
  }
  return !r && !nme(u, d) && (s += Ss(l, u, c, d, n, i) || 0), s !== 0;
}
function lme(e, t, r) {
  return U$(e, 0, !1, t, r);
}
function ume(e, t, r, n) {
  return U$(e, t, !0, r, n);
}
var Y0 = Xe({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, hc), cme = {
  style: Xe({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, FS.style)
}, Ub = Qa.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), Mt = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.update = function() {
    var r = this;
    e.prototype.update.call(this);
    var n = this.style;
    if (n.decal) {
      var i = this._decalEl = this._decalEl || new t();
      i.buildPath === t.prototype.buildPath && (i.buildPath = function(l) {
        r.buildPath(l, r.shape);
      }), i.silent = !0;
      var o = i.style;
      for (var a in n)
        o[a] !== n[a] && (o[a] = n[a]);
      o.fill = n.fill ? n.decal : null, o.decal = null, o.shadowColor = null, n.strokeFirst && (o.stroke = null);
      for (var s = 0; s < Ub.length; ++s)
        i[Ub[s]] = this[Ub[s]];
      i.__dirty |= qi;
    } else this._decalEl && (this._decalEl = null);
  }, t.prototype.getDecalElement = function() {
    return this._decalEl;
  }, t.prototype._init = function(r) {
    var n = At(r);
    this.shape = this.getDefaultShape();
    var i = this.getDefaultStyle();
    i && this.useStyle(i);
    for (var o = 0; o < n.length; o++) {
      var a = n[o], s = r[a];
      a === "style" ? this.style ? se(this.style, s) : this.useStyle(s) : a === "shape" ? se(this.shape, s) : e.prototype.attrKV.call(this, a, s);
    }
    this.style || this.useStyle({});
  }, t.prototype.getDefaultStyle = function() {
    return null;
  }, t.prototype.getDefaultShape = function() {
    return {};
  }, t.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, t.prototype.getInsideTextFill = function() {
    var r = this.style.fill;
    if (r !== "none") {
      if (Fe(r)) {
        var n = Og(r, 0);
        return n > 0.5 ? WR : n > 0.2 ? Wge : jR;
      } else if (r)
        return jR;
    }
    return WR;
  }, t.prototype.getInsideTextStroke = function(r) {
    var n = this.style.fill;
    if (Fe(n)) {
      var i = this.__zr, o = !!(i && i.isDarkMode()), a = Og(r, 0) < $R;
      if (o === a)
        return n;
    }
  }, t.prototype.buildPath = function(r, n, i) {
  }, t.prototype.pathUpdated = function() {
    this.__dirty &= ~Wd;
  }, t.prototype.getUpdatedPathProxy = function(r) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, r), this.path;
  }, t.prototype.createPathProxy = function() {
    this.path = new es(!1);
  }, t.prototype.hasStroke = function() {
    var r = this.style, n = r.stroke;
    return !(n == null || n === "none" || !(r.lineWidth > 0));
  }, t.prototype.hasFill = function() {
    var r = this.style, n = r.fill;
    return n != null && n !== "none";
  }, t.prototype.getBoundingRect = function() {
    var r = this._rect, n = this.style, i = !r;
    if (i) {
      var o = !1;
      this.path || (o = !0, this.createPathProxy());
      var a = this.path;
      (o || this.__dirty & Wd) && (a.beginPath(), this.buildPath(a, this.shape, !1), this.pathUpdated()), r = a.getBoundingRect();
    }
    if (this._rect = r, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = r.clone());
      if (this.__dirty || i) {
        s.copy(r);
        var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return r;
  }, t.prototype.contain = function(r, n) {
    var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect(), a = this.style;
    if (r = i[0], n = i[1], o.contain(r, n)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = a.lineWidth, u = a.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), ume(s, l / u, r, n)))
          return !0;
      }
      if (this.hasFill())
        return lme(s, r, n);
    }
    return !1;
  }, t.prototype.dirtyShape = function() {
    this.__dirty |= Wd, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, t.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, t.prototype.animateShape = function(r) {
    return this.animate("shape", r);
  }, t.prototype.updateDuringAnimation = function(r) {
    r === "style" ? this.dirtyStyle() : r === "shape" ? this.dirtyShape() : this.markRedraw();
  }, t.prototype.attrKV = function(r, n) {
    r === "shape" ? this.setShape(n) : e.prototype.attrKV.call(this, r, n);
  }, t.prototype.setShape = function(r, n) {
    var i = this.shape;
    return i || (i = this.shape = {}), typeof r == "string" ? i[r] = n : se(i, r), this.dirtyShape(), this;
  }, t.prototype.shapeChanged = function() {
    return !!(this.__dirty & Wd);
  }, t.prototype.createStyle = function(r) {
    return xv(Y0, r);
  }, t.prototype._innerSaveToNormal = function(r) {
    e.prototype._innerSaveToNormal.call(this, r);
    var n = this._normalState;
    r.shape && !n.shape && (n.shape = se({}, this.shape));
  }, t.prototype._applyStateObj = function(r, n, i, o, a, s) {
    e.prototype._applyStateObj.call(this, r, n, i, o, a, s);
    var l = !(n && o), u;
    if (n && n.shape ? a ? o ? u = n.shape : (u = se({}, i.shape), se(u, n.shape)) : (u = se({}, o ? this.shape : i.shape), se(u, n.shape)) : l && (u = i.shape), u)
      if (a) {
        this.shape = se({}, this.shape);
        for (var c = {}, d = At(u), h = 0; h < d.length; h++) {
          var f = d[h];
          typeof u[f] == "object" ? this.shape[f] = u[f] : c[f] = u[f];
        }
        this._transitionState(r, {
          shape: c
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, t.prototype._mergeStates = function(r) {
    for (var n = e.prototype._mergeStates.call(this, r), i, o = 0; o < r.length; o++) {
      var a = r[o];
      a.shape && (i = i || {}, this._mergeStyle(i, a.shape));
    }
    return i && (n.shape = i), n;
  }, t.prototype.getAnimationStyleProps = function() {
    return cme;
  }, t.prototype.isZeroArea = function() {
    return !1;
  }, t.extend = function(r) {
    var n = function(o) {
      Mr(a, o);
      function a(s) {
        var l = o.call(this, s) || this;
        return r.init && r.init.call(l, s), l;
      }
      return a.prototype.getDefaultStyle = function() {
        return et(r.style);
      }, a.prototype.getDefaultShape = function() {
        return et(r.shape);
      }, a;
    }(t);
    for (var i in r)
      typeof r[i] == "function" && (n.prototype[i] = r[i]);
    return n;
  }, t.initDefaultProps = function() {
    var r = t.prototype;
    r.type = "path", r.strokeContainThreshold = 5, r.segmentIgnoreThreshold = 0, r.subPixelOptimize = !1, r.autoBatch = !1, r.__dirty = qi | xp | Wd;
  }(), t;
}(ko), dme = Xe({
  strokeFirst: !0,
  font: Hl,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, Y0), Fh = function(e) {
  Mr(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.hasStroke = function() {
    var r = this.style, n = r.stroke;
    return n != null && n !== "none" && r.lineWidth > 0;
  }, t.prototype.hasFill = function() {
    var r = this.style, n = r.fill;
    return n != null && n !== "none";
  }, t.prototype.createStyle = function(r) {
    return xv(dme, r);
  }, t.prototype.setBoundingRect = function(r) {
    this._rect = r;
  }, t.prototype.getBoundingRect = function() {
    var r = this.style;
    if (!this._rect) {
      var n = r.text;
      n != null ? n += "" : n = "";
      var i = _v(n, r.font, r.textAlign, r.textBaseline);
      if (i.x += r.x || 0, i.y += r.y || 0, this.hasStroke()) {
        var o = r.lineWidth;
        i.x -= o / 2, i.y -= o / 2, i.width += o, i.height += o;
      }
      this._rect = i;
    }
    return this._rect;
  }, t.initDefaultProps = function() {
    var r = t.prototype;
    r.dirtyRectTolerance = 10;
  }(), t;
}(ko);
Fh.prototype.type = "tspan";
var hme = Xe({
  x: 0,
  y: 0
}, hc), fme = {
  style: Xe({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, FS.style)
};
function pme(e) {
  return !!(e && typeof e != "string" && e.width && e.height);
}
var K$ = function(e) {
  Mr(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.createStyle = function(r) {
    return xv(hme, r);
  }, t.prototype._getSize = function(r) {
    var n = this.style, i = n[r];
    if (i != null)
      return i;
    var o = pme(n.image) ? n.image : this.__image;
    if (!o)
      return 0;
    var a = r === "width" ? "height" : "width", s = n[a];
    return s == null ? o[r] : o[r] / o[a] * s;
  }, t.prototype.getWidth = function() {
    return this._getSize("width");
  }, t.prototype.getHeight = function() {
    return this._getSize("height");
  }, t.prototype.getAnimationStyleProps = function() {
    return fme;
  }, t.prototype.getBoundingRect = function() {
    var r = this.style;
    return this._rect || (this._rect = new St(r.x || 0, r.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, t;
}(ko);
K$.prototype.type = "image";
const In = K$;
function gme(e, t) {
  var r = t.x, n = t.y, i = t.width, o = t.height, a = t.r, s, l, u, c;
  i < 0 && (r = r + i, i = -i), o < 0 && (n = n + o, o = -o), typeof a == "number" ? s = l = u = c = a : a instanceof Array ? a.length === 1 ? s = l = u = c = a[0] : a.length === 2 ? (s = u = a[0], l = c = a[1]) : a.length === 3 ? (s = a[0], l = c = a[1], u = a[2]) : (s = a[0], l = a[1], u = a[2], c = a[3]) : s = l = u = c = 0;
  var d;
  s + l > i && (d = s + l, s *= i / d, l *= i / d), u + c > i && (d = u + c, u *= i / d, c *= i / d), l + u > o && (d = l + u, l *= o / d, u *= o / d), s + c > o && (d = s + c, s *= o / d, c *= o / d), e.moveTo(r + s, n), e.lineTo(r + i - l, n), l !== 0 && e.arc(r + i - l, n + l, l, -Math.PI / 2, 0), e.lineTo(r + i, n + o - u), u !== 0 && e.arc(r + i - u, n + o - u, u, 0, Math.PI / 2), e.lineTo(r + c, n + o), c !== 0 && e.arc(r + c, n + o - c, c, Math.PI / 2, Math.PI), e.lineTo(r, n + s), s !== 0 && e.arc(r + s, n + s, s, Math.PI, Math.PI * 1.5);
}
var rh = Math.round;
function Y$(e, t, r) {
  if (t) {
    var n = t.x1, i = t.x2, o = t.y1, a = t.y2;
    e.x1 = n, e.x2 = i, e.y1 = o, e.y2 = a;
    var s = r && r.lineWidth;
    return s && (rh(n * 2) === rh(i * 2) && (e.x1 = e.x2 = tc(n, s, !0)), rh(o * 2) === rh(a * 2) && (e.y1 = e.y2 = tc(o, s, !0))), e;
  }
}
function q$(e, t, r) {
  if (t) {
    var n = t.x, i = t.y, o = t.width, a = t.height;
    e.x = n, e.y = i, e.width = o, e.height = a;
    var s = r && r.lineWidth;
    return s && (e.x = tc(n, s, !0), e.y = tc(i, s, !0), e.width = Math.max(tc(n + o, s, !1) - e.x, o === 0 ? 0 : 1), e.height = Math.max(tc(i + a, s, !1) - e.y, a === 0 ? 0 : 1)), e;
  }
}
function tc(e, t, r) {
  if (!t)
    return e;
  var n = rh(e * 2);
  return (n + rh(t)) % 2 === 0 ? n / 2 : (n + (r ? 1 : -1)) / 2;
}
var vme = /* @__PURE__ */ function() {
  function e() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return e;
}(), mme = {}, Z$ = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new vme();
  }, t.prototype.buildPath = function(r, n) {
    var i, o, a, s;
    if (this.subPixelOptimize) {
      var l = q$(mme, n, this.style);
      i = l.x, o = l.y, a = l.width, s = l.height, l.r = n.r, n = l;
    } else
      i = n.x, o = n.y, a = n.width, s = n.height;
    n.r ? gme(r, n) : r.rect(i, o, a, s);
  }, t.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, t;
}(Mt);
Z$.prototype.type = "rect";
const Bt = Z$;
var iO = {
  fill: "#000"
}, oO = 2, yme = {
  style: Xe({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, FS.style)
}, X$ = function(e) {
  Mr(t, e);
  function t(r) {
    var n = e.call(this) || this;
    return n.type = "text", n._children = [], n._defaultStyle = iO, n.attr(r), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.update = function() {
    e.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var r = 0; r < this._children.length; r++) {
      var n = this._children[r];
      n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
    }
  }, t.prototype.updateTransform = function() {
    var r = this.innerTransformable;
    r ? (r.updateTransform(), r.transform && (this.transform = r.transform)) : e.prototype.updateTransform.call(this);
  }, t.prototype.getLocalTransform = function(r) {
    var n = this.innerTransformable;
    return n ? n.getLocalTransform(r) : e.prototype.getLocalTransform.call(this, r);
  }, t.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), e.prototype.getComputedTransform.call(this);
  }, t.prototype._updateSubTexts = function() {
    this._childCursor = 0, wme(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, t.prototype.addSelfToZr = function(r) {
    e.prototype.addSelfToZr.call(this, r);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = r;
  }, t.prototype.removeSelfFromZr = function(r) {
    e.prototype.removeSelfFromZr.call(this, r);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = null;
  }, t.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var r = new St(0, 0, 0, 0), n = this._children, i = [], o = null, a = 0; a < n.length; a++) {
        var s = n[a], l = s.getBoundingRect(), u = s.getLocalTransform(i);
        u ? (r.copy(l), r.applyTransform(u), o = o || r.clone(), o.union(r)) : (o = o || l.clone(), o.union(l));
      }
      this._rect = o || r;
    }
    return this._rect;
  }, t.prototype.setDefaultTextStyle = function(r) {
    this._defaultStyle = r || iO;
  }, t.prototype.setTextContent = function(r) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, t.prototype._mergeStyle = function(r, n) {
    if (!n)
      return r;
    var i = n.rich, o = r.rich || i && {};
    return se(r, n), i && o ? (this._mergeRich(o, i), r.rich = o) : o && (r.rich = o), r;
  }, t.prototype._mergeRich = function(r, n) {
    for (var i = At(n), o = 0; o < i.length; o++) {
      var a = i[o];
      r[a] = r[a] || {}, se(r[a], n[a]);
    }
  }, t.prototype.getAnimationStyleProps = function() {
    return yme;
  }, t.prototype._getOrCreateChild = function(r) {
    var n = this._children[this._childCursor];
    return (!n || !(n instanceof r)) && (n = new r()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
  }, t.prototype._updatePlainTexts = function() {
    var r = this.style, n = r.font || Hl, i = r.padding, o = hO(r), a = Hve(o, r), s = Kb(r), l = !!r.backgroundColor, u = a.outerHeight, c = a.outerWidth, d = a.contentWidth, h = a.lines, f = a.lineHeight, p = this._defaultStyle, g = r.x || 0, v = r.y || 0, m = r.align || p.align || "left", y = r.verticalAlign || p.verticalAlign || "top", C = g, S = jd(v, a.contentHeight, y);
    if (s || i) {
      var b = Rp(g, c, m), w = jd(v, u, y);
      s && this._renderBackground(r, r, b, w, c, u);
    }
    S += f / 2, i && (C = dO(g, m, i), y === "top" ? S += i[0] : y === "bottom" && (S -= i[2]));
    for (var x = 0, E = !1, R = cO("fill" in r ? r.fill : (E = !0, p.fill)), _ = uO("stroke" in r ? r.stroke : !l && (!p.autoStroke || E) ? (x = oO, p.stroke) : null), P = r.textShadowBlur > 0, D = r.width != null && (r.overflow === "truncate" || r.overflow === "break" || r.overflow === "breakAll"), I = a.calculatedLineHeight, A = 0; A < h.length; A++) {
      var O = this._getOrCreateChild(Fh), L = O.createStyle();
      O.useStyle(L), L.text = h[A], L.x = C, L.y = S, m && (L.textAlign = m), L.textBaseline = "middle", L.opacity = r.opacity, L.strokeFirst = !0, P && (L.shadowBlur = r.textShadowBlur || 0, L.shadowColor = r.textShadowColor || "transparent", L.shadowOffsetX = r.textShadowOffsetX || 0, L.shadowOffsetY = r.textShadowOffsetY || 0), L.stroke = _, L.fill = R, _ && (L.lineWidth = r.lineWidth || x, L.lineDash = r.lineDash, L.lineDashOffset = r.lineDashOffset || 0), L.font = n, sO(L, r), S += f, D && O.setBoundingRect(new St(Rp(L.x, r.width, L.textAlign), jd(L.y, I, L.textBaseline), d, I));
    }
  }, t.prototype._updateRichTexts = function() {
    var r = this.style, n = hO(r), i = Wve(n, r), o = i.width, a = i.outerWidth, s = i.outerHeight, l = r.padding, u = r.x || 0, c = r.y || 0, d = this._defaultStyle, h = r.align || d.align, f = r.verticalAlign || d.verticalAlign, p = Rp(u, a, h), g = jd(c, s, f), v = p, m = g;
    l && (v += l[3], m += l[0]);
    var y = v + o;
    Kb(r) && this._renderBackground(r, r, p, g, a, s);
    for (var C = !!r.backgroundColor, S = 0; S < i.lines.length; S++) {
      for (var b = i.lines[S], w = b.tokens, x = w.length, E = b.lineHeight, R = b.width, _ = 0, P = v, D = y, I = x - 1, A = void 0; _ < x && (A = w[_], !A.align || A.align === "left"); )
        this._placeToken(A, r, E, m, P, "left", C), R -= A.width, P += A.width, _++;
      for (; I >= 0 && (A = w[I], A.align === "right"); )
        this._placeToken(A, r, E, m, D, "right", C), R -= A.width, D -= A.width, I--;
      for (P += (o - (P - v) - (y - D) - R) / 2; _ <= I; )
        A = w[_], this._placeToken(A, r, E, m, P + A.width / 2, "center", C), P += A.width, _++;
      m += E;
    }
  }, t.prototype._placeToken = function(r, n, i, o, a, s, l) {
    var u = n.rich[r.styleName] || {};
    u.text = r.text;
    var c = r.verticalAlign, d = o + i / 2;
    c === "top" ? d = o + r.height / 2 : c === "bottom" && (d = o + i - r.height / 2);
    var h = !r.isLineHolder && Kb(u);
    h && this._renderBackground(u, n, s === "right" ? a - r.width : s === "center" ? a - r.width / 2 : a, d - r.height / 2, r.width, r.height);
    var f = !!u.backgroundColor, p = r.textPadding;
    p && (a = dO(a, s, p), d -= r.height / 2 - p[0] - r.innerHeight / 2);
    var g = this._getOrCreateChild(Fh), v = g.createStyle();
    g.useStyle(v);
    var m = this._defaultStyle, y = !1, C = 0, S = cO("fill" in u ? u.fill : "fill" in n ? n.fill : (y = !0, m.fill)), b = uO("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !f && !l && (!m.autoStroke || y) ? (C = oO, m.stroke) : null), w = u.textShadowBlur > 0 || n.textShadowBlur > 0;
    v.text = r.text, v.x = a, v.y = d, w && (v.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, v.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", v.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, v.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), v.textAlign = s, v.textBaseline = "middle", v.font = r.font || Hl, v.opacity = ro(u.opacity, n.opacity, 1), sO(v, u), b && (v.lineWidth = ro(u.lineWidth, n.lineWidth, C), v.lineDash = st(u.lineDash, n.lineDash), v.lineDashOffset = n.lineDashOffset || 0, v.stroke = b), S && (v.fill = S);
    var x = r.contentWidth, E = r.contentHeight;
    g.setBoundingRect(new St(Rp(v.x, x, v.textAlign), jd(v.y, E, v.textBaseline), x, E));
  }, t.prototype._renderBackground = function(r, n, i, o, a, s) {
    var l = r.backgroundColor, u = r.borderWidth, c = r.borderColor, d = l && l.image, h = l && !d, f = r.borderRadius, p = this, g, v;
    if (h || r.lineHeight || u && c) {
      g = this._getOrCreateChild(Bt), g.useStyle(g.createStyle()), g.style.fill = null;
      var m = g.shape;
      m.x = i, m.y = o, m.width = a, m.height = s, m.r = f, g.dirtyShape();
    }
    if (h) {
      var y = g.style;
      y.fill = l || null, y.fillOpacity = st(r.fillOpacity, 1);
    } else if (d) {
      v = this._getOrCreateChild(In), v.onload = function() {
        p.dirtyStyle();
      };
      var C = v.style;
      C.image = l.image, C.x = i, C.y = o, C.width = a, C.height = s;
    }
    if (u && c) {
      var y = g.style;
      y.lineWidth = u, y.stroke = c, y.strokeOpacity = st(r.strokeOpacity, 1), y.lineDash = r.borderDash, y.lineDashOffset = r.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var S = (g || v).style;
    S.shadowBlur = r.shadowBlur || 0, S.shadowColor = r.shadowColor || "transparent", S.shadowOffsetX = r.shadowOffsetX || 0, S.shadowOffsetY = r.shadowOffsetY || 0, S.opacity = ro(r.opacity, n.opacity, 1);
  }, t.makeFont = function(r) {
    var n = "";
    return J$(r) && (n = [
      r.fontStyle,
      r.fontWeight,
      Q$(r.fontSize),
      r.fontFamily || "sans-serif"
    ].join(" ")), n && _o(n) || r.textFont || r.font;
  }, t;
}(ko), Cme = { left: !0, right: 1, center: 1 }, Sme = { top: 1, bottom: 1, middle: 1 }, aO = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function Q$(e) {
  return typeof e == "string" && (e.indexOf("px") !== -1 || e.indexOf("rem") !== -1 || e.indexOf("em") !== -1) ? e : isNaN(+e) ? UP + "px" : e + "px";
}
function sO(e, t) {
  for (var r = 0; r < aO.length; r++) {
    var n = aO[r], i = t[n];
    i != null && (e[n] = i);
  }
}
function J$(e) {
  return e.fontSize != null || e.fontFamily || e.fontWeight;
}
function wme(e) {
  return lO(e), B(e.rich, lO), e;
}
function lO(e) {
  if (e) {
    e.font = X$.makeFont(e);
    var t = e.align;
    t === "middle" && (t = "center"), e.align = t == null || Cme[t] ? t : "left";
    var r = e.verticalAlign;
    r === "center" && (r = "middle"), e.verticalAlign = r == null || Sme[r] ? r : "top";
    var n = e.padding;
    n && (e.padding = xS(e.padding));
  }
}
function uO(e, t) {
  return e == null || t <= 0 || e === "transparent" || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function cO(e) {
  return e == null || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function dO(e, t, r) {
  return t === "right" ? e - r[1] : t === "center" ? e + r[3] / 2 - r[1] / 2 : e + r[3];
}
function hO(e) {
  var t = e.text;
  return t != null && (t += ""), t;
}
function Kb(e) {
  return !!(e.backgroundColor || e.lineHeight || e.borderWidth && e.borderColor);
}
const Vt = X$;
var ot = Gt(), e_ = function(e, t, r, n) {
  if (n) {
    var i = ot(n);
    i.dataIndex = r, i.dataType = t, i.seriesIndex = e, i.ssrType = "chart", n.type === "group" && n.traverse(function(o) {
      var a = ot(o);
      a.seriesIndex = e, a.dataIndex = r, a.dataType = t, a.ssrType = "chart";
    });
  }
}, fO = 1, pO = {}, e6 = Gt(), fM = Gt(), pM = 0, Mv = 1, OS = 2, bi = ["emphasis", "blur", "select"], kg = ["normal", "emphasis", "blur", "select"], of = 10, bme = 9, fc = "highlight", t0 = "downplay", eg = "select", r0 = "unselect", tg = "toggleSelect";
function wd(e) {
  return e != null && e !== "none";
}
function NS(e, t, r) {
  e.onHoverStateChange && (e.hoverState || 0) !== r && e.onHoverStateChange(t), e.hoverState = r;
}
function t6(e) {
  NS(e, "emphasis", OS);
}
function r6(e) {
  e.hoverState === OS && NS(e, "normal", pM);
}
function gM(e) {
  NS(e, "blur", Mv);
}
function n6(e) {
  e.hoverState === Mv && NS(e, "normal", pM);
}
function xme(e) {
  e.selected = !0;
}
function Eme(e) {
  e.selected = !1;
}
function gO(e, t, r) {
  t(e, r);
}
function Qs(e, t, r) {
  gO(e, t, r), e.isGroup && e.traverse(function(n) {
    gO(n, t, r);
  });
}
function q0(e, t) {
  switch (t) {
    case "emphasis":
      e.hoverState = OS;
      break;
    case "normal":
      e.hoverState = pM;
      break;
    case "blur":
      e.hoverState = Mv;
      break;
    case "select":
      e.selected = !0;
  }
}
function Rme(e, t, r, n) {
  for (var i = e.style, o = {}, a = 0; a < t.length; a++) {
    var s = t[a], l = i[s];
    o[s] = l ?? (n && n[s]);
  }
  for (var a = 0; a < e.animators.length; a++) {
    var u = e.animators[a];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(r) < 0 && u.targetName === "style" && u.saveTo(o, t);
  }
  return o;
}
function _me(e, t, r, n) {
  var i = r && bt(r, "select") >= 0, o = !1;
  if (e instanceof Mt) {
    var a = e6(e), s = i && a.selectFill || a.normalFill, l = i && a.selectStroke || a.normalStroke;
    if (wd(s) || wd(l)) {
      n = n || {};
      var u = n.style || {};
      u.fill === "inherit" ? (o = !0, n = se({}, n), u = se({}, u), u.fill = s) : !wd(u.fill) && wd(s) ? (o = !0, n = se({}, n), u = se({}, u), u.fill = $0(s)) : !wd(u.stroke) && wd(l) && (o || (n = se({}, n), u = se({}, u)), u.stroke = $0(l)), n.style = u;
    }
  }
  if (n && n.z2 == null) {
    o || (n = se({}, n));
    var c = e.z2EmphasisLift;
    n.z2 = e.z2 + (c ?? of);
  }
  return n;
}
function Tme(e, t, r) {
  if (r && r.z2 == null) {
    r = se({}, r);
    var n = e.z2SelectLift;
    r.z2 = e.z2 + (n ?? bme);
  }
  return r;
}
function Pme(e, t, r) {
  var n = bt(e.currentStates, t) >= 0, i = e.style.opacity, o = n ? null : Rme(e, ["opacity"], t, {
    opacity: 1
  });
  r = r || {};
  var a = r.style || {};
  return a.opacity == null && (r = se({}, r), a = se({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: n ? i : o.opacity * 0.1
  }, a), r.style = a), r;
}
function Yb(e, t) {
  var r = this.states[e];
  if (this.style) {
    if (e === "emphasis")
      return _me(this, e, t, r);
    if (e === "blur")
      return Pme(this, e, r);
    if (e === "select")
      return Tme(this, e, r);
  }
  return r;
}
function Dc(e) {
  e.stateProxy = Yb;
  var t = e.getTextContent(), r = e.getTextGuideLine();
  t && (t.stateProxy = Yb), r && (r.stateProxy = Yb);
}
function vO(e, t) {
  !s6(e, t) && !e.__highByOuter && Qs(e, t6);
}
function mO(e, t) {
  !s6(e, t) && !e.__highByOuter && Qs(e, r6);
}
function zs(e, t) {
  e.__highByOuter |= 1 << (t || 0), Qs(e, t6);
}
function $s(e, t) {
  !(e.__highByOuter &= ~(1 << (t || 0))) && Qs(e, r6);
}
function i6(e) {
  Qs(e, gM);
}
function vM(e) {
  Qs(e, n6);
}
function o6(e) {
  Qs(e, xme);
}
function a6(e) {
  Qs(e, Eme);
}
function s6(e, t) {
  return e.__highDownSilentOnTouch && t.zrByTouch;
}
function l6(e) {
  var t = e.getModel(), r = [], n = [];
  t.eachComponent(function(i, o) {
    var a = fM(o), s = i === "series", l = s ? e.getViewOfSeriesModel(o) : e.getViewOfComponentModel(o);
    !s && n.push(l), a.isBlured && (l.group.traverse(function(u) {
      n6(u);
    }), s && r.push(o)), a.isBlured = !1;
  }), B(n, function(i) {
    i && i.toggleBlurSeries && i.toggleBlurSeries(r, !1, t);
  });
}
function t_(e, t, r, n) {
  var i = n.getModel();
  r = r || "coordinateSystem";
  function o(u, c) {
    for (var d = 0; d < c.length; d++) {
      var h = u.getItemGraphicEl(c[d]);
      h && vM(h);
    }
  }
  if (e != null && !(!t || t === "none")) {
    var a = i.getSeriesByIndex(e), s = a.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    i.eachSeries(function(u) {
      var c = a === u, d = u.coordinateSystem;
      d && d.master && (d = d.master);
      var h = d && s ? d === s : c;
      if (!// Not blur other series if blurScope series
      (r === "series" && !c || r === "coordinateSystem" && !h || t === "series" && c)) {
        var f = n.getViewOfSeriesModel(u);
        if (f.group.traverse(function(v) {
          v.__highByOuter && c && t === "self" || gM(v);
        }), kn(t))
          o(u.getData(), t);
        else if (Ze(t))
          for (var p = At(t), g = 0; g < p.length; g++)
            o(u.getData(p[g]), t[p[g]]);
        l.push(u), fM(u).isBlured = !0;
      }
    }), i.eachComponent(function(u, c) {
      if (u !== "series") {
        var d = n.getViewOfComponentModel(c);
        d && d.toggleBlurSeries && d.toggleBlurSeries(l, !0, i);
      }
    });
  }
}
function r_(e, t, r) {
  if (!(e == null || t == null)) {
    var n = r.getModel().getComponent(e, t);
    if (n) {
      fM(n).isBlured = !0;
      var i = r.getViewOfComponentModel(n);
      !i || !i.focusBlurEnabled || i.group.traverse(function(o) {
        gM(o);
      });
    }
  }
}
function Mme(e, t, r) {
  var n = e.seriesIndex, i = e.getData(t.dataType);
  if (!i) {
    process.env.NODE_ENV !== "production" && Vn("Unknown dataType " + t.dataType);
    return;
  }
  var o = Pc(i, t);
  o = (fe(o) ? o[0] : o) || 0;
  var a = i.getItemGraphicEl(o);
  if (!a)
    for (var s = i.count(), l = 0; !a && l < s; )
      a = i.getItemGraphicEl(l++);
  if (a) {
    var u = ot(a);
    t_(n, u.focus, u.blurScope, r);
  } else {
    var c = e.get(["emphasis", "focus"]), d = e.get(["emphasis", "blurScope"]);
    c != null && t_(n, c, d, r);
  }
}
function mM(e, t, r, n) {
  var i = {
    focusSelf: !1,
    dispatchers: null
  };
  if (e == null || e === "series" || t == null || r == null)
    return i;
  var o = n.getModel().getComponent(e, t);
  if (!o)
    return i;
  var a = n.getViewOfComponentModel(o);
  if (!a || !a.findHighDownDispatchers)
    return i;
  for (var s = a.findHighDownDispatchers(r), l, u = 0; u < s.length; u++)
    if (process.env.NODE_ENV !== "production" && !jl(s[u]) && Vn("param should be highDownDispatcher"), ot(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function Dme(e, t, r) {
  process.env.NODE_ENV !== "production" && !jl(e) && Vn("param should be highDownDispatcher");
  var n = ot(e), i = mM(n.componentMainType, n.componentIndex, n.componentHighDownName, r), o = i.dispatchers, a = i.focusSelf;
  o ? (a && r_(n.componentMainType, n.componentIndex, r), B(o, function(s) {
    return vO(s, t);
  })) : (t_(n.seriesIndex, n.focus, n.blurScope, r), n.focus === "self" && r_(n.componentMainType, n.componentIndex, r), vO(e, t));
}
function Ame(e, t, r) {
  process.env.NODE_ENV !== "production" && !jl(e) && Vn("param should be highDownDispatcher"), l6(r);
  var n = ot(e), i = mM(n.componentMainType, n.componentIndex, n.componentHighDownName, r).dispatchers;
  i ? B(i, function(o) {
    return mO(o, t);
  }) : mO(e, t);
}
function Ime(e, t, r) {
  if (i_(t)) {
    var n = t.dataType, i = e.getData(n), o = Pc(i, t);
    fe(o) || (o = [o]), e[t.type === tg ? "toggleSelect" : t.type === eg ? "select" : "unselect"](o, n);
  }
}
function yO(e) {
  var t = e.getAllData();
  B(t, function(r) {
    var n = r.data, i = r.type;
    n.eachItemGraphicEl(function(o, a) {
      e.isSelected(a, i) ? o6(o) : a6(o);
    });
  });
}
function Fme(e) {
  var t = [];
  return e.eachSeries(function(r) {
    var n = r.getAllData();
    B(n, function(i) {
      i.data;
      var o = i.type, a = r.getSelectedDataIndices();
      if (a.length > 0) {
        var s = {
          dataIndex: a,
          seriesIndex: r.seriesIndex
        };
        o != null && (s.dataType = o), t.push(s);
      }
    });
  }), t;
}
function Fl(e, t, r) {
  rc(e, !0), Qs(e, Dc), n_(e, t, r);
}
function Lme(e) {
  rc(e, !1);
}
function Hr(e, t, r, n) {
  n ? Lme(e) : Fl(e, t, r);
}
function n_(e, t, r) {
  var n = ot(e);
  t != null ? (n.focus = t, n.blurScope = r) : n.focus && (n.focus = null);
}
var CO = ["emphasis", "blur", "select"], Ome = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function Bn(e, t, r, n) {
  r = r || "itemStyle";
  for (var i = 0; i < CO.length; i++) {
    var o = CO[i], a = t.getModel([o, r]), s = e.ensureState(o);
    s.style = n ? n(a) : a[Ome[r]]();
  }
}
function rc(e, t) {
  var r = t === !1, n = e;
  e.highDownSilentOnTouch && (n.__highDownSilentOnTouch = e.highDownSilentOnTouch), (!r || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !r);
}
function jl(e) {
  return !!(e && e.__highDownDispatcher);
}
function Nme(e, t, r) {
  var n = ot(e);
  n.componentMainType = t.mainType, n.componentIndex = t.componentIndex, n.componentHighDownName = r;
}
function kme(e) {
  var t = pO[e];
  return t == null && fO <= 32 && (t = pO[e] = fO++), t;
}
function i_(e) {
  var t = e.type;
  return t === eg || t === r0 || t === tg;
}
function SO(e) {
  var t = e.type;
  return t === fc || t === t0;
}
function Vme(e) {
  var t = e6(e);
  t.normalFill = e.style.fill, t.normalStroke = e.style.stroke;
  var r = e.states.select || {};
  t.selectFill = r.style && r.style.fill || null, t.selectStroke = r.style && r.style.stroke || null;
}
var bd = es.CMD, Bme = [[], [], []], wO = Math.sqrt, Gme = Math.atan2;
function u6(e, t) {
  if (t) {
    var r = e.data, n = e.len(), i, o, a, s, l, u, c = bd.M, d = bd.C, h = bd.L, f = bd.R, p = bd.A, g = bd.Q;
    for (a = 0, s = 0; a < n; ) {
      switch (i = r[a++], s = a, o = 0, i) {
        case c:
          o = 1;
          break;
        case h:
          o = 1;
          break;
        case d:
          o = 3;
          break;
        case g:
          o = 2;
          break;
        case p:
          var v = t[4], m = t[5], y = wO(t[0] * t[0] + t[1] * t[1]), C = wO(t[2] * t[2] + t[3] * t[3]), S = Gme(-t[1] / C, t[0] / y);
          r[a] *= y, r[a++] += v, r[a] *= C, r[a++] += m, r[a++] *= y, r[a++] *= C, r[a++] += S, r[a++] += S, a += 2, s = a;
          break;
        case f:
          u[0] = r[a++], u[1] = r[a++], An(u, u, t), r[s++] = u[0], r[s++] = u[1], u[0] += r[a++], u[1] += r[a++], An(u, u, t), r[s++] = u[0], r[s++] = u[1];
      }
      for (l = 0; l < o; l++) {
        var b = Bme[l];
        b[0] = r[a++], b[1] = r[a++], An(b, b, t), r[s++] = b[0], r[s++] = b[1];
      }
    }
    e.increaseVersion();
  }
}
var qb = Math.sqrt, Nm = Math.sin, km = Math.cos, Zf = Math.PI;
function bO(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function o_(e, t) {
  return (e[0] * t[0] + e[1] * t[1]) / (bO(e) * bO(t));
}
function xO(e, t) {
  return (e[0] * t[1] < e[1] * t[0] ? -1 : 1) * Math.acos(o_(e, t));
}
function EO(e, t, r, n, i, o, a, s, l, u, c) {
  var d = l * (Zf / 180), h = km(d) * (e - r) / 2 + Nm(d) * (t - n) / 2, f = -1 * Nm(d) * (e - r) / 2 + km(d) * (t - n) / 2, p = h * h / (a * a) + f * f / (s * s);
  p > 1 && (a *= qb(p), s *= qb(p));
  var g = (i === o ? -1 : 1) * qb((a * a * (s * s) - a * a * (f * f) - s * s * (h * h)) / (a * a * (f * f) + s * s * (h * h))) || 0, v = g * a * f / s, m = g * -s * h / a, y = (e + r) / 2 + km(d) * v - Nm(d) * m, C = (t + n) / 2 + Nm(d) * v + km(d) * m, S = xO([1, 0], [(h - v) / a, (f - m) / s]), b = [(h - v) / a, (f - m) / s], w = [(-1 * h - v) / a, (-1 * f - m) / s], x = xO(b, w);
  if (o_(b, w) <= -1 && (x = Zf), o_(b, w) >= 1 && (x = 0), x < 0) {
    var E = Math.round(x / Zf * 1e6) / 1e6;
    x = Zf * 2 + E % 2 * Zf;
  }
  c.addData(u, y, C, a, s, S, x, d, o);
}
var Hme = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, zme = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function $me(e) {
  var t = new es();
  if (!e)
    return t;
  var r = 0, n = 0, i = r, o = n, a, s = es.CMD, l = e.match(Hme);
  if (!l)
    return t;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], d = c.charAt(0), h = void 0, f = c.match(zme) || [], p = f.length, g = 0; g < p; g++)
      f[g] = parseFloat(f[g]);
    for (var v = 0; v < p; ) {
      var m = void 0, y = void 0, C = void 0, S = void 0, b = void 0, w = void 0, x = void 0, E = r, R = n, _ = void 0, P = void 0;
      switch (d) {
        case "l":
          r += f[v++], n += f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "L":
          r = f[v++], n = f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "m":
          r += f[v++], n += f[v++], h = s.M, t.addData(h, r, n), i = r, o = n, d = "l";
          break;
        case "M":
          r = f[v++], n = f[v++], h = s.M, t.addData(h, r, n), i = r, o = n, d = "L";
          break;
        case "h":
          r += f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "H":
          r = f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "v":
          n += f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "V":
          n = f[v++], h = s.L, t.addData(h, r, n);
          break;
        case "C":
          h = s.C, t.addData(h, f[v++], f[v++], f[v++], f[v++], f[v++], f[v++]), r = f[v - 2], n = f[v - 1];
          break;
        case "c":
          h = s.C, t.addData(h, f[v++] + r, f[v++] + n, f[v++] + r, f[v++] + n, f[v++] + r, f[v++] + n), r += f[v - 2], n += f[v - 1];
          break;
        case "S":
          m = r, y = n, _ = t.len(), P = t.data, a === s.C && (m += r - P[_ - 4], y += n - P[_ - 3]), h = s.C, E = f[v++], R = f[v++], r = f[v++], n = f[v++], t.addData(h, m, y, E, R, r, n);
          break;
        case "s":
          m = r, y = n, _ = t.len(), P = t.data, a === s.C && (m += r - P[_ - 4], y += n - P[_ - 3]), h = s.C, E = r + f[v++], R = n + f[v++], r += f[v++], n += f[v++], t.addData(h, m, y, E, R, r, n);
          break;
        case "Q":
          E = f[v++], R = f[v++], r = f[v++], n = f[v++], h = s.Q, t.addData(h, E, R, r, n);
          break;
        case "q":
          E = f[v++] + r, R = f[v++] + n, r += f[v++], n += f[v++], h = s.Q, t.addData(h, E, R, r, n);
          break;
        case "T":
          m = r, y = n, _ = t.len(), P = t.data, a === s.Q && (m += r - P[_ - 4], y += n - P[_ - 3]), r = f[v++], n = f[v++], h = s.Q, t.addData(h, m, y, r, n);
          break;
        case "t":
          m = r, y = n, _ = t.len(), P = t.data, a === s.Q && (m += r - P[_ - 4], y += n - P[_ - 3]), r += f[v++], n += f[v++], h = s.Q, t.addData(h, m, y, r, n);
          break;
        case "A":
          C = f[v++], S = f[v++], b = f[v++], w = f[v++], x = f[v++], E = r, R = n, r = f[v++], n = f[v++], h = s.A, EO(E, R, r, n, w, x, C, S, b, h, t);
          break;
        case "a":
          C = f[v++], S = f[v++], b = f[v++], w = f[v++], x = f[v++], E = r, R = n, r += f[v++], n += f[v++], h = s.A, EO(E, R, r, n, w, x, C, S, b, h, t);
          break;
      }
    }
    (d === "z" || d === "Z") && (h = s.Z, t.addData(h), r = i, n = o), a = h;
  }
  return t.toStatic(), t;
}
var c6 = function(e) {
  Mr(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.applyTransform = function(r) {
  }, t;
}(Mt);
function d6(e) {
  return e.setData != null;
}
function h6(e, t) {
  var r = $me(e), n = se({}, t);
  return n.buildPath = function(i) {
    if (d6(i)) {
      i.setData(r.data);
      var o = i.getContext();
      o && i.rebuildPath(o, 1);
    } else {
      var o = i;
      r.rebuildPath(o, 1);
    }
  }, n.applyTransform = function(i) {
    u6(r, i), this.dirtyShape();
  }, n;
}
function f6(e, t) {
  return new c6(h6(e, t));
}
function Wme(e, t) {
  var r = h6(e, t), n = function(i) {
    Mr(o, i);
    function o(a) {
      var s = i.call(this, a) || this;
      return s.applyTransform = r.applyTransform, s.buildPath = r.buildPath, s;
    }
    return o;
  }(c6);
  return n;
}
function jme(e, t) {
  for (var r = [], n = e.length, i = 0; i < n; i++) {
    var o = e[i];
    r.push(o.getUpdatedPathProxy(!0));
  }
  var a = new Mt(t);
  return a.createPathProxy(), a.buildPath = function(s) {
    if (d6(s)) {
      s.appendPath(r);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, a;
}
function yM(e, t) {
  t = t || {};
  var r = new Mt();
  return e.shape && r.setShape(e.shape), r.setStyle(e.style), t.bakeTransform ? u6(r.path, e.getComputedTransform()) : t.toLocal ? r.setLocalTransform(e.getComputedTransform()) : r.copyTransform(e), r.buildPath = e.buildPath, r.applyTransform = r.applyTransform, r.z = e.z, r.z2 = e.z2, r.zlevel = e.zlevel, r;
}
var Ume = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return e;
}(), p6 = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new Ume();
  }, t.prototype.buildPath = function(r, n) {
    r.moveTo(n.cx + n.r, n.cy), r.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
  }, t;
}(Mt);
p6.prototype.type = "circle";
const Js = p6;
var Kme = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return e;
}(), g6 = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new Kme();
  }, t.prototype.buildPath = function(r, n) {
    var i = 0.5522848, o = n.cx, a = n.cy, s = n.rx, l = n.ry, u = s * i, c = l * i;
    r.moveTo(o - s, a), r.bezierCurveTo(o - s, a - c, o - u, a - l, o, a - l), r.bezierCurveTo(o + u, a - l, o + s, a - c, o + s, a), r.bezierCurveTo(o + s, a + c, o + u, a + l, o, a + l), r.bezierCurveTo(o - u, a + l, o - s, a + c, o - s, a), r.closePath();
  }, t;
}(Mt);
g6.prototype.type = "ellipse";
const kS = g6;
var v6 = Math.PI, Zb = v6 * 2, Eu = Math.sin, xd = Math.cos, Yme = Math.acos, jn = Math.atan2, RO = Math.abs, rg = Math.sqrt, Tp = Math.max, Ma = Math.min, Xo = 1e-4;
function qme(e, t, r, n, i, o, a, s) {
  var l = r - e, u = n - t, c = a - i, d = s - o, h = d * l - c * u;
  if (!(h * h < Xo))
    return h = (c * (t - o) - d * (e - i)) / h, [e + h * l, t + h * u];
}
function Vm(e, t, r, n, i, o, a) {
  var s = e - r, l = t - n, u = (a ? o : -o) / rg(s * s + l * l), c = u * l, d = -u * s, h = e + c, f = t + d, p = r + c, g = n + d, v = (h + p) / 2, m = (f + g) / 2, y = p - h, C = g - f, S = y * y + C * C, b = i - o, w = h * g - p * f, x = (C < 0 ? -1 : 1) * rg(Tp(0, b * b * S - w * w)), E = (w * C - y * x) / S, R = (-w * y - C * x) / S, _ = (w * C + y * x) / S, P = (-w * y + C * x) / S, D = E - v, I = R - m, A = _ - v, O = P - m;
  return D * D + I * I > A * A + O * O && (E = _, R = P), {
    cx: E,
    cy: R,
    x0: -c,
    y0: -d,
    x1: E * (i / b - 1),
    y1: R * (i / b - 1)
  };
}
function Zme(e) {
  var t;
  if (fe(e)) {
    var r = e.length;
    if (!r)
      return e;
    r === 1 ? t = [e[0], e[0], 0, 0] : r === 2 ? t = [e[0], e[0], e[1], e[1]] : r === 3 ? t = e.concat(e[2]) : t = e;
  } else
    t = [e, e, e, e];
  return t;
}
function Xme(e, t) {
  var r, n = Tp(t.r, 0), i = Tp(t.r0 || 0, 0), o = n > 0, a = i > 0;
  if (!(!o && !a)) {
    if (o || (n = i, i = 0), i > n) {
      var s = n;
      n = i, i = s;
    }
    var l = t.startAngle, u = t.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx, d = t.cy, h = !!t.clockwise, f = RO(u - l), p = f > Zb && f % Zb;
      if (p > Xo && (f = p), !(n > Xo))
        e.moveTo(c, d);
      else if (f > Zb - Xo)
        e.moveTo(c + n * xd(l), d + n * Eu(l)), e.arc(c, d, n, l, u, !h), i > Xo && (e.moveTo(c + i * xd(u), d + i * Eu(u)), e.arc(c, d, i, u, l, h));
      else {
        var g = void 0, v = void 0, m = void 0, y = void 0, C = void 0, S = void 0, b = void 0, w = void 0, x = void 0, E = void 0, R = void 0, _ = void 0, P = void 0, D = void 0, I = void 0, A = void 0, O = n * xd(l), L = n * Eu(l), N = i * xd(u), F = i * Eu(u), G = f > Xo;
        if (G) {
          var M = t.cornerRadius;
          M && (r = Zme(M), g = r[0], v = r[1], m = r[2], y = r[3]);
          var V = RO(n - i) / 2;
          if (C = Ma(V, m), S = Ma(V, y), b = Ma(V, g), w = Ma(V, v), R = x = Tp(C, S), _ = E = Tp(b, w), (x > Xo || E > Xo) && (P = n * xd(u), D = n * Eu(u), I = i * xd(l), A = i * Eu(l), f < v6)) {
            var z = qme(O, L, I, A, P, D, N, F);
            if (z) {
              var k = O - z[0], $ = L - z[1], W = P - z[0], j = D - z[1], U = 1 / Eu(Yme((k * W + $ * j) / (rg(k * k + $ * $) * rg(W * W + j * j))) / 2), Z = rg(z[0] * z[0] + z[1] * z[1]);
              R = Ma(x, (n - Z) / (U + 1)), _ = Ma(E, (i - Z) / (U - 1));
            }
          }
        }
        if (!G)
          e.moveTo(c + O, d + L);
        else if (R > Xo) {
          var ee = Ma(m, R), J = Ma(y, R), X = Vm(I, A, O, L, n, ee, h), Y = Vm(P, D, N, F, n, J, h);
          e.moveTo(c + X.cx + X.x0, d + X.cy + X.y0), R < x && ee === J ? e.arc(c + X.cx, d + X.cy, R, jn(X.y0, X.x0), jn(Y.y0, Y.x0), !h) : (ee > 0 && e.arc(c + X.cx, d + X.cy, ee, jn(X.y0, X.x0), jn(X.y1, X.x1), !h), e.arc(c, d, n, jn(X.cy + X.y1, X.cx + X.x1), jn(Y.cy + Y.y1, Y.cx + Y.x1), !h), J > 0 && e.arc(c + Y.cx, d + Y.cy, J, jn(Y.y1, Y.x1), jn(Y.y0, Y.x0), !h));
        } else
          e.moveTo(c + O, d + L), e.arc(c, d, n, l, u, !h);
        if (!(i > Xo) || !G)
          e.lineTo(c + N, d + F);
        else if (_ > Xo) {
          var ee = Ma(g, _), J = Ma(v, _), X = Vm(N, F, P, D, i, -J, h), Y = Vm(O, L, I, A, i, -ee, h);
          e.lineTo(c + X.cx + X.x0, d + X.cy + X.y0), _ < E && ee === J ? e.arc(c + X.cx, d + X.cy, _, jn(X.y0, X.x0), jn(Y.y0, Y.x0), !h) : (J > 0 && e.arc(c + X.cx, d + X.cy, J, jn(X.y0, X.x0), jn(X.y1, X.x1), !h), e.arc(c, d, i, jn(X.cy + X.y1, X.cx + X.x1), jn(Y.cy + Y.y1, Y.cx + Y.x1), h), ee > 0 && e.arc(c + Y.cx, d + Y.cy, ee, jn(Y.y1, Y.x1), jn(Y.y0, Y.x0), !h));
        } else
          e.lineTo(c + N, d + F), e.arc(c, d, i, u, l, h);
      }
      e.closePath();
    }
  }
}
var Qme = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return e;
}(), m6 = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new Qme();
  }, t.prototype.buildPath = function(r, n) {
    Xme(r, n);
  }, t.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, t;
}(Mt);
m6.prototype.type = "sector";
const xi = m6;
var Jme = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return e;
}(), y6 = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new Jme();
  }, t.prototype.buildPath = function(r, n) {
    var i = n.cx, o = n.cy, a = Math.PI * 2;
    r.moveTo(i + n.r, o), r.arc(i, o, n.r, 0, a, !1), r.moveTo(i + n.r0, o), r.arc(i, o, n.r0, 0, a, !0);
  }, t;
}(Mt);
y6.prototype.type = "ring";
const Dv = y6;
function eye(e, t, r, n) {
  var i = [], o = [], a = [], s = [], l, u, c, d;
  if (n) {
    c = [1 / 0, 1 / 0], d = [-1 / 0, -1 / 0];
    for (var h = 0, f = e.length; h < f; h++)
      Rs(c, c, e[h]), _s(d, d, e[h]);
    Rs(c, c, n[0]), _s(d, d, n[1]);
  }
  for (var h = 0, f = e.length; h < f; h++) {
    var p = e[h];
    if (r)
      l = e[h ? h - 1 : f - 1], u = e[(h + 1) % f];
    else if (h === 0 || h === f - 1) {
      i.push(Ua(e[h]));
      continue;
    } else
      l = e[h - 1], u = e[h + 1];
    El(o, u, l), Kp(o, o, t);
    var g = V0(p, l), v = V0(p, u), m = g + v;
    m !== 0 && (g /= m, v /= m), Kp(a, o, -g), Kp(s, o, v);
    var y = MR([], p, a), C = MR([], p, s);
    n && (_s(y, y, c), Rs(y, y, d), _s(C, C, c), Rs(C, C, d)), i.push(y), i.push(C);
  }
  return r && i.push(i.shift()), i;
}
function C6(e, t, r) {
  var n = t.smooth, i = t.points;
  if (i && i.length >= 2) {
    if (n) {
      var o = eye(i, n, r, t.smoothConstraint);
      e.moveTo(i[0][0], i[0][1]);
      for (var a = i.length, s = 0; s < (r ? a : a - 1); s++) {
        var l = o[s * 2], u = o[s * 2 + 1], c = i[(s + 1) % a];
        e.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      e.moveTo(i[0][0], i[0][1]);
      for (var s = 1, d = i.length; s < d; s++)
        e.lineTo(i[s][0], i[s][1]);
    }
    r && e.closePath();
  }
}
var tye = /* @__PURE__ */ function() {
  function e() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
}(), S6 = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new tye();
  }, t.prototype.buildPath = function(r, n) {
    C6(r, n, !0);
  }, t;
}(Mt);
S6.prototype.type = "polygon";
const Ei = S6;
var rye = /* @__PURE__ */ function() {
  function e() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
}(), w6 = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new rye();
  }, t.prototype.buildPath = function(r, n) {
    C6(r, n, !1);
  }, t;
}(Mt);
w6.prototype.type = "polyline";
const Ri = w6;
var nye = {}, iye = /* @__PURE__ */ function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return e;
}(), b6 = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new iye();
  }, t.prototype.buildPath = function(r, n) {
    var i, o, a, s;
    if (this.subPixelOptimize) {
      var l = Y$(nye, n, this.style);
      i = l.x1, o = l.y1, a = l.x2, s = l.y2;
    } else
      i = n.x1, o = n.y1, a = n.x2, s = n.y2;
    var u = n.percent;
    u !== 0 && (r.moveTo(i, o), u < 1 && (a = i * (1 - u) + a * u, s = o * (1 - u) + s * u), r.lineTo(a, s));
  }, t.prototype.pointAt = function(r) {
    var n = this.shape;
    return [
      n.x1 * (1 - r) + n.x2 * r,
      n.y1 * (1 - r) + n.y2 * r
    ];
  }, t;
}(Mt);
b6.prototype.type = "line";
const wn = b6;
var Ti = [], oye = /* @__PURE__ */ function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return e;
}();
function _O(e, t, r) {
  var n = e.cpx2, i = e.cpy2;
  return n != null || i != null ? [
    (r ? DL : Sn)(e.x1, e.cpx1, e.cpx2, e.x2, t),
    (r ? DL : Sn)(e.y1, e.cpy1, e.cpy2, e.y2, t)
  ] : [
    (r ? LR : Pn)(e.x1, e.cpx1, e.x2, t),
    (r ? LR : Pn)(e.y1, e.cpy1, e.y2, t)
  ];
}
var x6 = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new oye();
  }, t.prototype.buildPath = function(r, n) {
    var i = n.x1, o = n.y1, a = n.x2, s = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, d = n.cpy2, h = n.percent;
    h !== 0 && (r.moveTo(i, o), c == null || d == null ? (h < 1 && (Ig(i, l, a, h, Ti), l = Ti[1], a = Ti[2], Ig(o, u, s, h, Ti), u = Ti[1], s = Ti[2]), r.quadraticCurveTo(l, u, a, s)) : (h < 1 && (Wl(i, l, c, a, h, Ti), l = Ti[1], c = Ti[2], a = Ti[3], Wl(o, u, d, s, h, Ti), u = Ti[1], d = Ti[2], s = Ti[3]), r.bezierCurveTo(l, u, c, d, a, s)));
  }, t.prototype.pointAt = function(r) {
    return _O(this.shape, r, !1);
  }, t.prototype.tangentAt = function(r) {
    var n = _O(this.shape, r, !0);
    return $c(n, n);
  }, t;
}(Mt);
x6.prototype.type = "bezier-curve";
const Av = x6;
var aye = /* @__PURE__ */ function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return e;
}(), E6 = function(e) {
  Mr(t, e);
  function t(r) {
    return e.call(this, r) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new aye();
  }, t.prototype.buildPath = function(r, n) {
    var i = n.cx, o = n.cy, a = Math.max(n.r, 0), s = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(s), d = Math.sin(s);
    r.moveTo(c * a + i, d * a + o), r.arc(i, o, a, s, l, !u);
  }, t;
}(Mt);
E6.prototype.type = "arc";
const VS = E6;
var sye = function(e) {
  Mr(t, e);
  function t() {
    var r = e !== null && e.apply(this, arguments) || this;
    return r.type = "compound", r;
  }
  return t.prototype._updatePathDirty = function() {
    for (var r = this.shape.paths, n = this.shapeChanged(), i = 0; i < r.length; i++)
      n = n || r[i].shapeChanged();
    n && this.dirtyShape();
  }, t.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var r = this.shape.paths || [], n = this.getGlobalScale(), i = 0; i < r.length; i++)
      r[i].path || r[i].createPathProxy(), r[i].path.setScale(n[0], n[1], r[i].segmentIgnoreThreshold);
  }, t.prototype.buildPath = function(r, n) {
    for (var i = n.paths || [], o = 0; o < i.length; o++)
      i[o].buildPath(r, i[o].shape, !0);
  }, t.prototype.afterBrush = function() {
    for (var r = this.shape.paths || [], n = 0; n < r.length; n++)
      r[n].pathUpdated();
  }, t.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), Mt.prototype.getBoundingRect.call(this);
  }, t;
}(Mt);
const BS = sye;
var R6 = function() {
  function e(t) {
    this.colorStops = t || [];
  }
  return e.prototype.addColorStop = function(t, r) {
    this.colorStops.push({
      offset: t,
      color: r
    });
  }, e;
}(), lye = function(e) {
  Mr(t, e);
  function t(r, n, i, o, a, s) {
    var l = e.call(this, a) || this;
    return l.x = r ?? 0, l.y = n ?? 0, l.x2 = i ?? 1, l.y2 = o ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return t;
}(R6);
const af = lye;
var uye = function(e) {
  Mr(t, e);
  function t(r, n, i, o, a) {
    var s = e.call(this, o) || this;
    return s.x = r ?? 0.5, s.y = n ?? 0.5, s.r = i ?? 0.5, s.type = "radial", s.global = a || !1, s;
  }
  return t;
}(R6);
const CM = uye;
var Ru = [0, 0], _u = [0, 0], Bm = new Ct(), Gm = new Ct(), cye = function() {
  function e(t, r) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var n = 0; n < 4; n++)
      this._corners[n] = new Ct();
    for (var n = 0; n < 2; n++)
      this._axes[n] = new Ct();
    t && this.fromBoundingRect(t, r);
  }
  return e.prototype.fromBoundingRect = function(t, r) {
    var n = this._corners, i = this._axes, o = t.x, a = t.y, s = o + t.width, l = a + t.height;
    if (n[0].set(o, a), n[1].set(s, a), n[2].set(s, l), n[3].set(o, l), r)
      for (var u = 0; u < 4; u++)
        n[u].transform(r);
    Ct.sub(i[0], n[1], n[0]), Ct.sub(i[1], n[3], n[0]), i[0].normalize(), i[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = i[u].dot(n[0]);
  }, e.prototype.intersect = function(t, r) {
    var n = !0, i = !r;
    return Bm.set(1 / 0, 1 / 0), Gm.set(0, 0), !this._intersectCheckOneSide(this, t, Bm, Gm, i, 1) && (n = !1, i) || !this._intersectCheckOneSide(t, this, Bm, Gm, i, -1) && (n = !1, i) || i || Ct.copy(r, n ? Bm : Gm), n;
  }, e.prototype._intersectCheckOneSide = function(t, r, n, i, o, a) {
    for (var s = !0, l = 0; l < 2; l++) {
      var u = this._axes[l];
      if (this._getProjMinMaxOnAxis(l, t._corners, Ru), this._getProjMinMaxOnAxis(l, r._corners, _u), Ru[1] < _u[0] || Ru[0] > _u[1]) {
        if (s = !1, o)
          return s;
        var c = Math.abs(_u[0] - Ru[1]), d = Math.abs(Ru[0] - _u[1]);
        Math.min(c, d) > i.len() && (c < d ? Ct.scale(i, u, -c * a) : Ct.scale(i, u, d * a));
      } else if (n) {
        var c = Math.abs(_u[0] - Ru[1]), d = Math.abs(Ru[0] - _u[1]);
        Math.min(c, d) < n.len() && (c < d ? Ct.scale(n, u, c * a) : Ct.scale(n, u, -d * a));
      }
    }
    return s;
  }, e.prototype._getProjMinMaxOnAxis = function(t, r, n) {
    for (var i = this._axes[t], o = this._origin, a = r[0].dot(i) + o[t], s = a, l = a, u = 1; u < r.length; u++) {
      var c = r[u].dot(i) + o[t];
      s = Math.min(c, s), l = Math.max(c, l);
    }
    n[0] = s, n[1] = l;
  }, e;
}();
const Z0 = cye;
var dye = [], hye = function(e) {
  Mr(t, e);
  function t() {
    var r = e !== null && e.apply(this, arguments) || this;
    return r.notClear = !0, r.incremental = !0, r._displayables = [], r._temporaryDisplayables = [], r._cursor = 0, r;
  }
  return t.prototype.traverse = function(r, n) {
    r.call(n, this);
  }, t.prototype.useStyle = function() {
    this.style = {};
  }, t.prototype.getCursor = function() {
    return this._cursor;
  }, t.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, t.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, t.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, t.prototype.addDisplayable = function(r, n) {
    n ? this._temporaryDisplayables.push(r) : this._displayables.push(r), this.markRedraw();
  }, t.prototype.addDisplayables = function(r, n) {
    n = n || !1;
    for (var i = 0; i < r.length; i++)
      this.addDisplayable(r[i], n);
  }, t.prototype.getDisplayables = function() {
    return this._displayables;
  }, t.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, t.prototype.eachPendingDisplayable = function(r) {
    for (var n = this._cursor; n < this._displayables.length; n++)
      r && r(this._displayables[n]);
    for (var n = 0; n < this._temporaryDisplayables.length; n++)
      r && r(this._temporaryDisplayables[n]);
  }, t.prototype.update = function() {
    this.updateTransform();
    for (var r = this._cursor; r < this._displayables.length; r++) {
      var n = this._displayables[r];
      n.parent = this, n.update(), n.parent = null;
    }
    for (var r = 0; r < this._temporaryDisplayables.length; r++) {
      var n = this._temporaryDisplayables[r];
      n.parent = this, n.update(), n.parent = null;
    }
  }, t.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var r = new St(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
        var i = this._displayables[n], o = i.getBoundingRect().clone();
        i.needLocalTransform() && o.applyTransform(i.getLocalTransform(dye)), r.union(o);
      }
      this._rect = r;
    }
    return this._rect;
  }, t.prototype.contain = function(r, n) {
    var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect();
    if (o.contain(i[0], i[1]))
      for (var a = 0; a < this._displayables.length; a++) {
        var s = this._displayables[a];
        if (s.contain(r, n))
          return !0;
      }
    return !1;
  }, t;
}(ko);
const _6 = hye;
var T6 = Gt();
function sf(e, t, r, n, i) {
  var o;
  if (t && t.ecModel) {
    var a = t.ecModel.getUpdatePayload();
    o = a && a.animation;
  }
  var s = t && t.isAnimationEnabled(), l = e === "update";
  if (s) {
    var u = void 0, c = void 0, d = void 0;
    n ? (u = st(n.duration, 200), c = st(n.easing, "cubicOut"), d = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), d = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), o && (o.duration != null && (u = o.duration), o.easing != null && (c = o.easing), o.delay != null && (d = o.delay)), Ye(d) && (d = d(r, i)), Ye(u) && (u = u(r));
    var h = {
      duration: u || 0,
      delay: d,
      easing: c
    };
    return h;
  } else
    return null;
}
function SM(e, t, r, n, i, o, a) {
  var s = !1, l;
  Ye(i) ? (a = o, o = i, i = null) : Ze(i) && (o = i.cb, a = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex);
  var u = e === "leave";
  u || t.stopAnimation("leave");
  var c = sf(e, n, i, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(t, i) : null);
  if (c && c.duration > 0) {
    var d = c.duration, h = c.delay, f = c.easing, p = {
      duration: d,
      delay: h || 0,
      easing: f,
      done: o,
      force: !!o || !!a,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: e,
      during: a
    };
    s ? t.animateFrom(r, p) : t.animateTo(r, p);
  } else
    t.stopAnimation(), !s && t.attr(r), a && a(1), o && o();
}
function jt(e, t, r, n, i, o) {
  SM("update", e, t, r, n, i, o);
}
function Pr(e, t, r, n, i, o) {
  SM("enter", e, t, r, n, i, o);
}
function gh(e) {
  if (!e.__zr)
    return !0;
  for (var t = 0; t < e.animators.length; t++) {
    var r = e.animators[t];
    if (r.scope === "leave")
      return !0;
  }
  return !1;
}
function Ul(e, t, r, n, i, o) {
  gh(e) || SM("leave", e, t, r, n, i, o);
}
function TO(e, t, r, n) {
  e.removeTextContent(), e.removeTextGuideLine(), Ul(e, {
    style: {
      opacity: 0
    }
  }, t, r, n);
}
function Vg(e, t, r) {
  function n() {
    e.parent && e.parent.remove(e);
  }
  e.isGroup ? e.traverse(function(i) {
    i.isGroup || TO(i, t, r, n);
  }) : TO(e, t, r, n);
}
function Ca(e) {
  T6(e).oldStyle = e.style;
}
function fye(e) {
  return T6(e).oldStyle;
}
var X0 = Math.max, Q0 = Math.min, a_ = {};
function P6(e) {
  return Mt.extend(e);
}
var pye = Wme;
function M6(e, t) {
  return pye(e, t);
}
function Ho(e, t) {
  a_[e] = t;
}
function GS(e) {
  if (a_.hasOwnProperty(e))
    return a_[e];
}
function Iv(e, t, r, n) {
  var i = f6(e, t);
  return r && (n === "center" && (r = D6(r, i.getBoundingRect())), bM(i, r)), i;
}
function wM(e, t, r) {
  var n = new In({
    style: {
      image: e,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    onload: function(i) {
      if (r === "center") {
        var o = {
          width: i.width,
          height: i.height
        };
        n.setStyle(D6(t, o));
      }
    }
  });
  return n;
}
function D6(e, t) {
  var r = t.width / t.height, n = e.height * r, i;
  n <= e.width ? i = e.height : (n = e.width, i = n / r);
  var o = e.x + e.width / 2, a = e.y + e.height / 2;
  return {
    x: o - n / 2,
    y: a - i / 2,
    width: n,
    height: i
  };
}
var Zi = jme;
function bM(e, t) {
  if (e.applyTransform) {
    var r = e.getBoundingRect(), n = r.calculateTransform(t);
    e.applyTransform(n);
  }
}
function Lh(e, t) {
  return Y$(e, e, {
    lineWidth: t
  }), e;
}
function gye(e) {
  return q$(e.shape, e.shape, e.style), e;
}
var n0 = tc;
function Ll(e, t) {
  for (var r = Ev([]); e && e !== t; )
    Ka(r, e.getLocalTransform(), r), e = e.parent;
  return r;
}
function fa(e, t, r) {
  return t && !kn(t) && (t = Ts.getLocalTransform(t)), r && (t = Wc([], t)), An([], e, t);
}
function HS(e, t, r) {
  var n = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : Math.abs(2 * t[4] / t[0]), i = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : Math.abs(2 * t[4] / t[2]), o = [e === "left" ? -n : e === "right" ? n : 0, e === "top" ? -i : e === "bottom" ? i : 0];
  return o = fa(o, t, r), Math.abs(o[0]) > Math.abs(o[1]) ? o[0] > 0 ? "right" : "left" : o[1] > 0 ? "bottom" : "top";
}
function PO(e) {
  return !e.isGroup;
}
function vye(e) {
  return e.shape != null;
}
function Fv(e, t, r) {
  if (!e || !t)
    return;
  function n(a) {
    var s = {};
    return a.traverse(function(l) {
      PO(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function i(a) {
    var s = {
      x: a.x,
      y: a.y,
      rotation: a.rotation
    };
    return vye(a) && (s.shape = se({}, a.shape)), s;
  }
  var o = n(e);
  t.traverse(function(a) {
    if (PO(a) && a.anid) {
      var s = o[a.anid];
      if (s) {
        var l = i(a);
        a.attr(i(s)), jt(a, l, r, ot(a).dataIndex);
      }
    }
  });
}
function xM(e, t) {
  return ge(e, function(r) {
    var n = r[0];
    n = X0(n, t.x), n = Q0(n, t.x + t.width);
    var i = r[1];
    return i = X0(i, t.y), i = Q0(i, t.y + t.height), [n, i];
  });
}
function A6(e, t) {
  var r = X0(e.x, t.x), n = Q0(e.x + e.width, t.x + t.width), i = X0(e.y, t.y), o = Q0(e.y + e.height, t.y + t.height);
  if (n >= r && o >= i)
    return {
      x: r,
      y: i,
      width: n - r,
      height: o - i
    };
}
function lf(e, t, r) {
  var n = se({
    rectHover: !0
  }, t), i = n.style = {
    strokeNoScale: !0
  };
  if (r = r || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, e)
    return e.indexOf("image://") === 0 ? (i.image = e.slice(8), Xe(i, r), new In(n)) : Iv(e.replace("path://", ""), n, r, "center");
}
function Pp(e, t, r, n, i) {
  for (var o = 0, a = i[i.length - 1]; o < i.length; o++) {
    var s = i[o];
    if (I6(e, t, r, n, s[0], s[1], a[0], a[1]))
      return !0;
    a = s;
  }
}
function I6(e, t, r, n, i, o, a, s) {
  var l = r - e, u = n - t, c = a - i, d = s - o, h = Xb(c, d, l, u);
  if (mye(h))
    return !1;
  var f = e - i, p = t - o, g = Xb(f, p, l, u) / h;
  if (g < 0 || g > 1)
    return !1;
  var v = Xb(f, p, c, d) / h;
  return !(v < 0 || v > 1);
}
function Xb(e, t, r, n) {
  return e * n - r * t;
}
function mye(e) {
  return e <= 1e-6 && e >= -1e-6;
}
function uf(e) {
  var t = e.itemTooltipOption, r = e.componentModel, n = e.itemName, i = Fe(t) ? {
    formatter: t
  } : t, o = r.mainType, a = r.componentIndex, s = {
    componentType: o,
    name: n,
    $vars: ["name"]
  };
  s[o + "Index"] = a;
  var l = e.formatterParamsExtra;
  l && B(At(l), function(c) {
    Be(s, c) || (s[c] = l[c], s.$vars.push(c));
  });
  var u = ot(e.el);
  u.componentMainType = o, u.componentIndex = a, u.tooltipConfig = {
    name: n,
    option: Xe({
      content: n,
      encodeHTMLContent: !0,
      formatterParams: s
    }, i)
  };
}
function MO(e, t) {
  var r;
  e.isGroup && (r = t(e)), r || e.traverse(t);
}
function iu(e, t) {
  if (e)
    if (fe(e))
      for (var r = 0; r < e.length; r++)
        MO(e[r], t);
    else
      MO(e, t);
}
Ho("circle", Js);
Ho("ellipse", kS);
Ho("sector", xi);
Ho("ring", Dv);
Ho("polygon", Ei);
Ho("polyline", Ri);
Ho("rect", Bt);
Ho("line", wn);
Ho("bezierCurve", Av);
Ho("arc", VS);
const jc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: VS,
  BezierCurve: Av,
  BoundingRect: St,
  Circle: Js,
  CompoundPath: BS,
  Ellipse: kS,
  Group: it,
  Image: In,
  IncrementalDisplayable: _6,
  Line: wn,
  LinearGradient: af,
  OrientedBoundingRect: Z0,
  Path: Mt,
  Point: Ct,
  Polygon: Ei,
  Polyline: Ri,
  RadialGradient: CM,
  Rect: Bt,
  Ring: Dv,
  Sector: xi,
  Text: Vt,
  applyTransform: fa,
  clipPointsByRect: xM,
  clipRectByRect: A6,
  createIcon: lf,
  extendPath: M6,
  extendShape: P6,
  getShapeClass: GS,
  getTransform: Ll,
  groupTransition: Fv,
  initProps: Pr,
  isElementRemoved: gh,
  lineLineIntersect: I6,
  linePolygonIntersect: Pp,
  makeImage: wM,
  makePath: Iv,
  mergePath: Zi,
  registerShape: Ho,
  removeElement: Ul,
  removeElementWithFadeOut: Vg,
  resizePath: bM,
  setTooltipConfig: uf,
  subPixelOptimize: n0,
  subPixelOptimizeLine: Lh,
  subPixelOptimizeRect: gye,
  transformDirection: HS,
  traverseElements: iu,
  updateProps: jt
}, Symbol.toStringTag, { value: "Module" }));
var zS = {};
function F6(e, t) {
  for (var r = 0; r < bi.length; r++) {
    var n = bi[r], i = t[n], o = e.ensureState(n);
    o.style = o.style || {}, o.style.text = i;
  }
  var a = e.currentStates.slice();
  e.clearStates(!0), e.setStyle({
    text: t.normal
  }), e.useStates(a, !0);
}
function s_(e, t, r) {
  var n = e.labelFetcher, i = e.labelDataIndex, o = e.labelDimIndex, a = t.normal, s;
  n && (s = n.getFormattedLabel(i, "normal", null, o, a && a.get("formatter"), r != null ? {
    interpolatedValue: r
  } : null)), s == null && (s = Ye(e.defaultText) ? e.defaultText(i, e, r) : e.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < bi.length; u++) {
    var c = bi[u], d = t[c];
    l[c] = st(n ? n.getFormattedLabel(i, c, null, o, d && d.get("formatter")) : null, s);
  }
  return l;
}
function Gn(e, t, r, n) {
  r = r || zS;
  for (var i = e instanceof Vt, o = !1, a = 0; a < kg.length; a++) {
    var s = t[kg[a]];
    if (s && s.getShallow("show")) {
      o = !0;
      break;
    }
  }
  var l = i ? e : e.getTextContent();
  if (o) {
    i || (l || (l = new Vt(), e.setTextContent(l)), e.stateProxy && (l.stateProxy = e.stateProxy));
    var u = s_(r, t), c = t.normal, d = !!c.getShallow("show"), h = br(c, n && n.normal, r, !1, !i);
    h.text = u.normal, i || e.setTextConfig(J0(c, r, !1));
    for (var a = 0; a < bi.length; a++) {
      var f = bi[a], s = t[f];
      if (s) {
        var p = l.ensureState(f), g = !!st(s.getShallow("show"), d);
        if (g !== d && (p.ignore = !g), p.style = br(s, n && n[f], r, !0, !i), p.style.text = u[f], !i) {
          var v = e.ensureState(f);
          v.textConfig = J0(s, r, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (h.x = l.style.x), l.style.y != null && (h.y = l.style.y), l.ignore = !d, l.useStyle(h), l.dirty(), r.enableTextSetter && (cf(l).setLabelText = function(m) {
      var y = s_(r, t, m);
      F6(l, y);
    });
  } else l && (l.ignore = !0);
  e.dirty();
}
function Rn(e, t) {
  t = t || "label";
  for (var r = {
    normal: e.getModel(t)
  }, n = 0; n < bi.length; n++) {
    var i = bi[n];
    r[i] = e.getModel([i, t]);
  }
  return r;
}
function br(e, t, r, n, i) {
  var o = {};
  return yye(o, e, r, n, i), t && se(o, t), o;
}
function J0(e, t, r) {
  t = t || {};
  var n = {}, i, o = e.getShallow("rotate"), a = st(e.getShallow("distance"), r ? null : 5), s = e.getShallow("offset");
  return i = e.getShallow("position") || (r ? null : "inside"), i === "outside" && (i = t.defaultOutsidePosition || "top"), i != null && (n.position = i), s != null && (n.offset = s), o != null && (o *= Math.PI / 180, n.rotation = o), a != null && (n.distance = a), n.outsideFill = e.get("color") === "inherit" ? t.inheritColor || null : "auto", n;
}
function yye(e, t, r, n, i) {
  r = r || zS;
  var o = t.ecModel, a = o && o.option.textStyle, s = Cye(t), l;
  if (s) {
    l = {};
    for (var u in s)
      if (s.hasOwnProperty(u)) {
        var c = t.getModel(["rich", u]);
        FO(l[u] = {}, c, a, r, n, i, !1, !0);
      }
  }
  l && (e.rich = l);
  var d = t.get("overflow");
  d && (e.overflow = d);
  var h = t.get("minMargin");
  h != null && (e.margin = h), FO(e, t, a, r, n, i, !0, !1);
}
function Cye(e) {
  for (var t; e && e !== e.ecModel; ) {
    var r = (e.option || zS).rich;
    if (r) {
      t = t || {};
      for (var n = At(r), i = 0; i < n.length; i++) {
        var o = n[i];
        t[o] = 1;
      }
    }
    e = e.parentModel;
  }
  return t;
}
var DO = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], AO = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], IO = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function FO(e, t, r, n, i, o, a, s) {
  r = !i && r || zS;
  var l = n && n.inheritColor, u = t.getShallow("color"), c = t.getShallow("textBorderColor"), d = st(t.getShallow("opacity"), r.opacity);
  (u === "inherit" || u === "auto") && (process.env.NODE_ENV !== "production" && u === "auto" && Jr("color: 'auto'", "color: 'inherit'"), l ? u = l : u = null), (c === "inherit" || c === "auto") && (process.env.NODE_ENV !== "production" && c === "auto" && Jr("color: 'auto'", "color: 'inherit'"), l ? c = l : c = null), o || (u = u || r.color, c = c || r.textBorderColor), u != null && (e.fill = u), c != null && (e.stroke = c);
  var h = st(t.getShallow("textBorderWidth"), r.textBorderWidth);
  h != null && (e.lineWidth = h);
  var f = st(t.getShallow("textBorderType"), r.textBorderType);
  f != null && (e.lineDash = f);
  var p = st(t.getShallow("textBorderDashOffset"), r.textBorderDashOffset);
  p != null && (e.lineDashOffset = p), !i && d == null && !s && (d = n && n.defaultOpacity), d != null && (e.opacity = d), !i && !o && e.fill == null && n.inheritColor && (e.fill = n.inheritColor);
  for (var g = 0; g < DO.length; g++) {
    var v = DO[g], m = st(t.getShallow(v), r[v]);
    m != null && (e[v] = m);
  }
  for (var g = 0; g < AO.length; g++) {
    var v = AO[g], m = t.getShallow(v);
    m != null && (e[v] = m);
  }
  if (e.verticalAlign == null) {
    var y = t.getShallow("baseline");
    y != null && (e.verticalAlign = y);
  }
  if (!a || !n.disableBox) {
    for (var g = 0; g < IO.length; g++) {
      var v = IO[g], m = t.getShallow(v);
      m != null && (e[v] = m);
    }
    var C = t.getShallow("borderType");
    C != null && (e.borderDash = C), (e.backgroundColor === "auto" || e.backgroundColor === "inherit") && l && (process.env.NODE_ENV !== "production" && e.backgroundColor === "auto" && Jr("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), e.backgroundColor = l), (e.borderColor === "auto" || e.borderColor === "inherit") && l && (process.env.NODE_ENV !== "production" && e.borderColor === "auto" && Jr("borderColor: 'auto'", "borderColor: 'inherit'"), e.borderColor = l);
  }
}
function EM(e, t) {
  var r = t && t.getModel("textStyle");
  return _o([
    // FIXME in node-canvas fontWeight is before fontStyle
    e.fontStyle || r && r.getShallow("fontStyle") || "",
    e.fontWeight || r && r.getShallow("fontWeight") || "",
    (e.fontSize || r && r.getShallow("fontSize") || 12) + "px",
    e.fontFamily || r && r.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var cf = Gt();
function L6(e, t, r, n) {
  if (e) {
    var i = cf(e);
    i.prevValue = i.value, i.value = r;
    var o = t.normal;
    i.valueAnimation = o.get("valueAnimation"), i.valueAnimation && (i.precision = o.get("precision"), i.defaultInterpolatedText = n, i.statesModels = t);
  }
}
function O6(e, t, r, n, i) {
  var o = cf(e);
  if (!o.valueAnimation || o.prevValue === o.value)
    return;
  var a = o.defaultInterpolatedText, s = st(o.interpolatedValue, o.prevValue), l = o.value;
  function u(c) {
    var d = V$(r, o.precision, s, l, c);
    o.interpolatedValue = c === 1 ? null : d;
    var h = s_({
      labelDataIndex: t,
      labelFetcher: i,
      defaultText: a ? a(d) : d + ""
    }, o.statesModels, d);
    F6(e, h);
  }
  e.percent = 0, (o.prevValue == null ? Pr : jt)(e, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, n, t, null, u);
}
var Sye = ["textStyle", "color"], Qb = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], Jb = new Vt(), wye = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getTextColor = function(t) {
      var r = this.ecModel;
      return this.getShallow("color") || (!t && r ? r.get(Sye) : null);
    }, e.prototype.getFont = function() {
      return EM({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, e.prototype.getTextRect = function(t) {
      for (var r = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < Qb.length; n++)
        r[Qb[n]] = this.getShallow(Qb[n]);
      return Jb.useStyle(r), Jb.update(), Jb.getBoundingRect();
    }, e;
  }()
), N6 = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], bye = Mc(N6), xye = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getLineStyle = function(t) {
      return bye(this, t);
    }, e;
  }()
), k6 = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], Eye = Mc(k6), Rye = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getItemStyle = function(t, r) {
      return Eye(this, t, r);
    }, e;
  }()
), Uc = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.parentModel = r, this.ecModel = n, this.option = t;
    }
    return e.prototype.init = function(t, r, n) {
    }, e.prototype.mergeOption = function(t, r) {
      yt(this.option, t, !0);
    }, e.prototype.get = function(t, r) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !r && this.parentModel);
    }, e.prototype.getShallow = function(t, r) {
      var n = this.option, i = n == null ? n : n[t];
      if (i == null && !r) {
        var o = this.parentModel;
        o && (i = o.getShallow(t));
      }
      return i;
    }, e.prototype.getModel = function(t, r) {
      var n = t != null, i = n ? this.parsePath(t) : null, o = n ? this._doGet(i) : this.option;
      return r = r || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new e(o, r, this.ecModel);
    }, e.prototype.isEmpty = function() {
      return this.option == null;
    }, e.prototype.restoreData = function() {
    }, e.prototype.clone = function() {
      var t = this.constructor;
      return new t(et(this.option));
    }, e.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, e.prototype.resolveParentPath = function(t) {
      return t;
    }, e.prototype.isAnimationEnabled = function() {
      if (!kt.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, e.prototype._doGet = function(t, r) {
      var n = this.option;
      if (!t)
        return n;
      for (var i = 0; i < t.length && !(t[i] && (n = n && typeof n == "object" ? n[t[i]] : null, n == null)); i++)
        ;
      return n == null && r && (n = r._doGet(this.resolveParentPath(t), r.parentModel)), n;
    }, e;
  }()
);
cM(Uc);
Fve(Uc);
qr(Uc, xye);
qr(Uc, Rye);
qr(Uc, Vve);
qr(Uc, wye);
const cr = Uc;
var _ye = Math.round(Math.random() * 10);
function df(e) {
  return [e || "", _ye++].join("_");
}
function Tye(e) {
  var t = {};
  e.registerSubTypeDefaulter = function(r, n) {
    var i = za(r);
    t[i.main] = n;
  }, e.determineSubType = function(r, n) {
    var i = n.type;
    if (!i) {
      var o = za(r).main;
      e.hasSubTypes(r) && t[o] && (i = t[o](n));
    }
    return i;
  };
}
function Pye(e, t) {
  e.topologicalTravel = function(o, a, s, l) {
    if (!o.length)
      return;
    var u = r(a), c = u.graph, d = u.noEntryList, h = {};
    for (B(o, function(y) {
      h[y] = !0;
    }); d.length; ) {
      var f = d.pop(), p = c[f], g = !!h[f];
      g && (s.call(l, f, p.originalDeps.slice()), delete h[f]), B(p.successor, g ? m : v);
    }
    B(h, function() {
      var y = "";
      throw process.env.NODE_ENV !== "production" && (y = wi("Circular dependency may exists: ", h, o, a)), new Error(y);
    });
    function v(y) {
      c[y].entryCount--, c[y].entryCount === 0 && d.push(y);
    }
    function m(y) {
      h[y] = !0, v(y);
    }
  };
  function r(o) {
    var a = {}, s = [];
    return B(o, function(l) {
      var u = n(a, l), c = u.originalDeps = t(l), d = i(c, o);
      u.entryCount = d.length, u.entryCount === 0 && s.push(l), B(d, function(h) {
        bt(u.predecessor, h) < 0 && u.predecessor.push(h);
        var f = n(a, h);
        bt(f.successor, h) < 0 && f.successor.push(l);
      });
    }), {
      graph: a,
      noEntryList: s
    };
  }
  function n(o, a) {
    return o[a] || (o[a] = {
      predecessor: [],
      successor: []
    }), o[a];
  }
  function i(o, a) {
    var s = [];
    return B(o, function(l) {
      bt(a, l) >= 0 && s.push(l);
    }), s;
  }
}
function ou(e, t) {
  return yt(yt({}, e, !0), t, !0);
}
const Mye = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, Dye = {
  time: {
    month: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"],
    monthAbbr: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
    dayOfWeek: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"],
    dayOfWeekAbbr: ["日", "一", "二", "三", "四", "五", "六"]
  },
  legend: {
    selector: {
      all: "全选",
      inverse: "反选"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "矩形选择",
        polygon: "圈选",
        lineX: "横向选择",
        lineY: "纵向选择",
        keep: "保持选择",
        clear: "清除选择"
      }
    },
    dataView: {
      title: "数据视图",
      lang: ["数据视图", "关闭", "刷新"]
    },
    dataZoom: {
      title: {
        zoom: "区域缩放",
        back: "区域缩放还原"
      }
    },
    magicType: {
      title: {
        line: "切换为折线图",
        bar: "切换为柱状图",
        stack: "切换为堆叠",
        tiled: "切换为平铺"
      }
    },
    restore: {
      title: "还原"
    },
    saveAsImage: {
      title: "保存为图片",
      lang: ["右键另存为图片"]
    }
  },
  series: {
    typeNames: {
      pie: "饼图",
      bar: "柱状图",
      line: "折线图",
      scatter: "散点图",
      effectScatter: "涟漪散点图",
      radar: "雷达图",
      tree: "树图",
      treemap: "矩形树图",
      boxplot: "箱型图",
      candlestick: "K线图",
      k: "K线图",
      heatmap: "热力图",
      map: "地图",
      parallel: "平行坐标图",
      lines: "线图",
      graph: "关系图",
      sankey: "桑基图",
      funnel: "漏斗图",
      gauge: "仪表盘图",
      pictorialBar: "象形柱图",
      themeRiver: "主题河流图",
      sunburst: "旭日图",
      custom: "自定义图表",
      chart: "图表"
    }
  },
  aria: {
    general: {
      withTitle: "这是一个关于“{title}”的图表。",
      withoutTitle: "这是一个图表，"
    },
    series: {
      single: {
        prefix: "",
        withName: "图表类型是{seriesType}，表示{seriesName}。",
        withoutName: "图表类型是{seriesType}。"
      },
      multiple: {
        prefix: "它由{seriesCount}个图表系列组成。",
        withName: "第{seriesId}个系列是一个表示{seriesName}的{seriesType}，",
        withoutName: "第{seriesId}个系列是一个{seriesType}，",
        separator: {
          middle: "；",
          end: "。"
        }
      }
    },
    data: {
      allData: "其数据是——",
      partialData: "其中，前{displayCnt}项是——",
      withName: "{name}的数据是{value}",
      withoutName: "{value}",
      separator: {
        middle: "，",
        end: ""
      }
    }
  }
};
var eC = "ZH", RM = "EN", vh = RM, i0 = {}, _M = {}, V6 = kt.domSupported ? function() {
  var e = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || vh).toUpperCase()
  );
  return e.indexOf(eC) > -1 ? eC : vh;
}() : vh;
function TM(e, t) {
  e = e.toUpperCase(), _M[e] = new cr(t), i0[e] = t;
}
function Aye(e) {
  if (Fe(e)) {
    var t = i0[e.toUpperCase()] || {};
    return e === eC || e === RM ? et(t) : yt(et(t), et(i0[vh]), !1);
  } else
    return yt(et(e), et(i0[vh]), !1);
}
function l_(e) {
  return _M[e];
}
function Iye() {
  return _M[vh];
}
TM(RM, Mye);
TM(eC, Dye);
var PM = 1e3, MM = PM * 60, ng = MM * 60, Ro = ng * 24, LO = Ro * 365, Mp = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, Hm = "{yyyy}-{MM}-{dd}", OO = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: Hm,
  hour: Hm + " " + Mp.hour,
  minute: Hm + " " + Mp.minute,
  second: Hm + " " + Mp.second,
  millisecond: Mp.none
}, e1 = ["year", "month", "day", "hour", "minute", "second", "millisecond"], B6 = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function di(e, t) {
  return e += "", "0000".substr(0, t - e.length) + e;
}
function mh(e) {
  switch (e) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return e;
  }
}
function Fye(e) {
  return e === mh(e);
}
function Lye(e) {
  switch (e) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function Lv(e, t, r, n) {
  var i = io(e), o = i[DM(r)](), a = i[yh(r)]() + 1, s = Math.floor((a - 1) / 3) + 1, l = i[$S(r)](), u = i["get" + (r ? "UTC" : "") + "Day"](), c = i[Bg(r)](), d = (c - 1) % 12 + 1, h = i[WS(r)](), f = i[jS(r)](), p = i[US(r)](), g = c >= 12 ? "pm" : "am", v = g.toUpperCase(), m = n instanceof cr ? n : l_(n || V6) || Iye(), y = m.getModel("time"), C = y.get("month"), S = y.get("monthAbbr"), b = y.get("dayOfWeek"), w = y.get("dayOfWeekAbbr");
  return (t || "").replace(/{a}/g, g + "").replace(/{A}/g, v + "").replace(/{yyyy}/g, o + "").replace(/{yy}/g, di(o % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, C[a - 1]).replace(/{MMM}/g, S[a - 1]).replace(/{MM}/g, di(a, 2)).replace(/{M}/g, a + "").replace(/{dd}/g, di(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, b[u]).replace(/{ee}/g, w[u]).replace(/{e}/g, u + "").replace(/{HH}/g, di(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, di(d + "", 2)).replace(/{h}/g, d + "").replace(/{mm}/g, di(h, 2)).replace(/{m}/g, h + "").replace(/{ss}/g, di(f, 2)).replace(/{s}/g, f + "").replace(/{SSS}/g, di(p, 3)).replace(/{S}/g, p + "");
}
function Oye(e, t, r, n, i) {
  var o = null;
  if (Fe(r))
    o = r;
  else if (Ye(r))
    o = r(e.value, t, {
      level: e.level
    });
  else {
    var a = se({}, Mp);
    if (e.level > 0)
      for (var s = 0; s < e1.length; ++s)
        a[e1[s]] = "{primary|" + a[e1[s]] + "}";
    var l = r ? r.inherit === !1 ? r : Xe(r, a) : a, u = G6(e.value, i);
    if (l[u])
      o = l[u];
    else if (l.inherit) {
      for (var c = B6.indexOf(u), s = c - 1; s >= 0; --s)
        if (l[u]) {
          o = l[u];
          break;
        }
      o = o || a.none;
    }
    if (fe(o)) {
      var d = e.level == null ? 0 : e.level >= 0 ? e.level : o.length + e.level;
      d = Math.min(d, o.length - 1), o = o[d];
    }
  }
  return Lv(new Date(e.value), o, i, n);
}
function G6(e, t) {
  var r = io(e), n = r[yh(t)]() + 1, i = r[$S(t)](), o = r[Bg(t)](), a = r[WS(t)](), s = r[jS(t)](), l = r[US(t)](), u = l === 0, c = u && s === 0, d = c && a === 0, h = d && o === 0, f = h && i === 1, p = f && n === 1;
  return p ? "year" : f ? "month" : h ? "day" : d ? "hour" : c ? "minute" : u ? "second" : "millisecond";
}
function NO(e, t, r) {
  var n = $t(e) ? io(e) : e;
  switch (t = t || G6(e, r), t) {
    case "year":
      return n[DM(r)]();
    case "half-year":
      return n[yh(r)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((n[yh(r)]() + 1) / 4);
    case "month":
      return n[yh(r)]();
    case "day":
      return n[$S(r)]();
    case "half-day":
      return n[Bg(r)]() / 24;
    case "hour":
      return n[Bg(r)]();
    case "minute":
      return n[WS(r)]();
    case "second":
      return n[jS(r)]();
    case "millisecond":
      return n[US(r)]();
  }
}
function DM(e) {
  return e ? "getUTCFullYear" : "getFullYear";
}
function yh(e) {
  return e ? "getUTCMonth" : "getMonth";
}
function $S(e) {
  return e ? "getUTCDate" : "getDate";
}
function Bg(e) {
  return e ? "getUTCHours" : "getHours";
}
function WS(e) {
  return e ? "getUTCMinutes" : "getMinutes";
}
function jS(e) {
  return e ? "getUTCSeconds" : "getSeconds";
}
function US(e) {
  return e ? "getUTCMilliseconds" : "getMilliseconds";
}
function Nye(e) {
  return e ? "setUTCFullYear" : "setFullYear";
}
function H6(e) {
  return e ? "setUTCMonth" : "setMonth";
}
function z6(e) {
  return e ? "setUTCDate" : "setDate";
}
function $6(e) {
  return e ? "setUTCHours" : "setHours";
}
function W6(e) {
  return e ? "setUTCMinutes" : "setMinutes";
}
function j6(e) {
  return e ? "setUTCSeconds" : "setSeconds";
}
function U6(e) {
  return e ? "setUTCMilliseconds" : "setMilliseconds";
}
function kye(e, t, r, n, i, o, a, s) {
  var l = new Vt({
    style: {
      text: e,
      font: t,
      align: r,
      verticalAlign: n,
      padding: i,
      rich: o,
      overflow: a ? "truncate" : null,
      lineHeight: s
    }
  });
  return l.getBoundingRect();
}
function AM(e) {
  if (!MS(e))
    return Fe(e) ? e : "-";
  var t = (e + "").split(".");
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
}
function IM(e, t) {
  return e = (e || "").toLowerCase().replace(/-(.)/g, function(r, n) {
    return n.toUpperCase();
  }), t && e && (e = e.charAt(0).toUpperCase() + e.slice(1)), e;
}
var Kc = xS;
function u_(e, t, r) {
  var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function i(c) {
    return c && _o(c) ? c : "-";
  }
  function o(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var a = t === "time", s = e instanceof Date;
  if (a || s) {
    var l = a ? io(e) : e;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else return Lv(l, n, r);
  }
  if (t === "ordinal")
    return Pg(e) ? i(e) : $t(e) && o(e) ? e + "" : "-";
  var u = Ja(e);
  return o(u) ? AM(u) : Pg(e) ? i(e) : typeof e == "boolean" ? e + "" : "-";
}
var kO = ["a", "b", "c", "d", "e", "f", "g"], t1 = function(e, t) {
  return "{" + e + (t ?? "") + "}";
};
function FM(e, t, r) {
  fe(t) || (t = [t]);
  var n = t.length;
  if (!n)
    return "";
  for (var i = t[0].$vars || [], o = 0; o < i.length; o++) {
    var a = kO[o];
    e = e.replace(t1(a), t1(a, 0));
  }
  for (var s = 0; s < n; s++)
    for (var l = 0; l < i.length; l++) {
      var u = t[s][i[l]];
      e = e.replace(t1(kO[l], s), r ? fi(u) : u);
    }
  return e;
}
function Vye(e, t, r) {
  return B(t, function(n, i) {
    e = e.replace("{" + i + "}", n);
  }), e;
}
function K6(e, t) {
  var r = Fe(e) ? {
    color: e,
    extraCssText: t
  } : e || {}, n = r.color, i = r.type;
  t = r.extraCssText;
  var o = r.renderMode || "html";
  if (!n)
    return "";
  if (o === "html")
    return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + fi(n) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + fi(n) + ";" + (t || "") + '"></span>';
  var a = r.markerId || "markerX";
  return {
    renderMode: o,
    content: "{" + a + "|}  ",
    style: i === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: n
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: n
    }
  };
}
function Bye(e, t, r) {
  process.env.NODE_ENV !== "production" && Jr("echarts.format.formatTime", "echarts.time.format"), (e === "week" || e === "month" || e === "quarter" || e === "half-year" || e === "year") && (e = `MM-dd
yyyy`);
  var n = io(t), i = r ? "getUTC" : "get", o = n[i + "FullYear"](), a = n[i + "Month"]() + 1, s = n[i + "Date"](), l = n[i + "Hours"](), u = n[i + "Minutes"](), c = n[i + "Seconds"](), d = n[i + "Milliseconds"]();
  return e = e.replace("MM", di(a, 2)).replace("M", a).replace("yyyy", o).replace("yy", di(o % 100 + "", 2)).replace("dd", di(s, 2)).replace("d", s).replace("hh", di(l, 2)).replace("h", l).replace("mm", di(u, 2)).replace("m", u).replace("ss", di(c, 2)).replace("s", c).replace("SSS", di(d, 3)), e;
}
function Gye(e) {
  return e && e.charAt(0).toUpperCase() + e.substr(1);
}
function Ac(e, t) {
  return t = t || "transparent", Fe(e) ? e : Ze(e) && e.colorStops && (e.colorStops[0] || {}).color || t;
}
function tC(e, t) {
  if (t === "_blank" || t === "blank") {
    var r = window.open();
    r.opener = null, r.location.href = e;
  } else
    window.open(e, t);
}
var o0 = B, Y6 = ["left", "right", "top", "bottom", "width", "height"], nc = [["width", "left", "right"], ["height", "top", "bottom"]];
function LM(e, t, r, n, i) {
  var o = 0, a = 0;
  n == null && (n = 1 / 0), i == null && (i = 1 / 0);
  var s = 0;
  t.eachChild(function(l, u) {
    var c = l.getBoundingRect(), d = t.childAt(u + 1), h = d && d.getBoundingRect(), f, p;
    if (e === "horizontal") {
      var g = c.width + (h ? -h.x + c.x : 0);
      f = o + g, f > n || l.newline ? (o = 0, f = g, a += s + r, s = c.height) : s = Math.max(s, c.height);
    } else {
      var v = c.height + (h ? -h.y + c.y : 0);
      p = a + v, p > i || l.newline ? (o += s + r, a = 0, p = v, s = c.width) : s = Math.max(s, c.width);
    }
    l.newline || (l.x = o, l.y = a, l.markRedraw(), e === "horizontal" ? o = f + r : a = p + r);
  });
}
var pc = LM;
dt(LM, "vertical");
dt(LM, "horizontal");
function Hye(e, t, r) {
  var n = t.width, i = t.height, o = Ae(e.left, n), a = Ae(e.top, i), s = Ae(e.right, n), l = Ae(e.bottom, i);
  return (isNaN(o) || isNaN(parseFloat(e.left))) && (o = 0), (isNaN(s) || isNaN(parseFloat(e.right))) && (s = n), (isNaN(a) || isNaN(parseFloat(e.top))) && (a = 0), (isNaN(l) || isNaN(parseFloat(e.bottom))) && (l = i), r = Kc(r || 0), {
    width: Math.max(s - o - r[1] - r[3], 0),
    height: Math.max(l - a - r[0] - r[2], 0)
  };
}
function hn(e, t, r) {
  r = Kc(r || 0);
  var n = t.width, i = t.height, o = Ae(e.left, n), a = Ae(e.top, i), s = Ae(e.right, n), l = Ae(e.bottom, i), u = Ae(e.width, n), c = Ae(e.height, i), d = r[2] + r[0], h = r[1] + r[3], f = e.aspect;
  switch (isNaN(u) && (u = n - s - h - o), isNaN(c) && (c = i - l - d - a), f != null && (isNaN(u) && isNaN(c) && (f > n / i ? u = n * 0.8 : c = i * 0.8), isNaN(u) && (u = f * c), isNaN(c) && (c = u / f)), isNaN(o) && (o = n - s - u - h), isNaN(a) && (a = i - l - c - d), e.left || e.right) {
    case "center":
      o = n / 2 - u / 2 - r[3];
      break;
    case "right":
      o = n - u - h;
      break;
  }
  switch (e.top || e.bottom) {
    case "middle":
    case "center":
      a = i / 2 - c / 2 - r[0];
      break;
    case "bottom":
      a = i - c - d;
      break;
  }
  o = o || 0, a = a || 0, isNaN(u) && (u = n - h - o - (s || 0)), isNaN(c) && (c = i - d - a - (l || 0));
  var p = new St(o + r[3], a + r[0], u, c);
  return p.margin = r, p;
}
function KS(e, t, r, n, i, o) {
  var a = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all";
  if (o = o || e, o.x = e.x, o.y = e.y, !a && !s)
    return !1;
  var u;
  if (l === "raw")
    u = e.type === "group" ? new St(0, 0, +t.width || 0, +t.height || 0) : e.getBoundingRect();
  else if (u = e.getBoundingRect(), e.needLocalTransform()) {
    var c = e.getLocalTransform();
    u = u.clone(), u.applyTransform(c);
  }
  var d = hn(Xe({
    width: u.width,
    height: u.height
  }, t), r, n), h = a ? d.x - u.x : 0, f = s ? d.y - u.y : 0;
  return l === "raw" ? (o.x = h, o.y = f) : (o.x += h, o.y += f), o === e && e.markRedraw(), !0;
}
function zye(e, t) {
  return e[nc[t][0]] != null || e[nc[t][1]] != null && e[nc[t][2]] != null;
}
function Gg(e) {
  var t = e.layoutMode || e.constructor.layoutMode;
  return Ze(t) ? t : t ? {
    type: t
  } : null;
}
function Kl(e, t, r) {
  var n = r && r.ignoreSize;
  !fe(n) && (n = [n, n]);
  var i = a(nc[0], 0), o = a(nc[1], 1);
  u(nc[0], e, i), u(nc[1], e, o);
  function a(c, d) {
    var h = {}, f = 0, p = {}, g = 0, v = 2;
    if (o0(c, function(C) {
      p[C] = e[C];
    }), o0(c, function(C) {
      s(t, C) && (h[C] = p[C] = t[C]), l(h, C) && f++, l(p, C) && g++;
    }), n[d])
      return l(t, c[1]) ? p[c[2]] = null : l(t, c[2]) && (p[c[1]] = null), p;
    if (g === v || !f)
      return p;
    if (f >= v)
      return h;
    for (var m = 0; m < c.length; m++) {
      var y = c[m];
      if (!s(h, y) && s(e, y)) {
        h[y] = e[y];
        break;
      }
    }
    return h;
  }
  function s(c, d) {
    return c.hasOwnProperty(d);
  }
  function l(c, d) {
    return c[d] != null && c[d] !== "auto";
  }
  function u(c, d, h) {
    o0(c, function(f) {
      d[f] = h[f];
    });
  }
}
function hf(e) {
  return q6({}, e);
}
function q6(e, t) {
  return t && e && o0(Y6, function(r) {
    t.hasOwnProperty(r) && (e[r] = t[r]);
  }), e;
}
var $ye = Gt(), Rt = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i) {
      var o = e.call(this, r, n, i) || this;
      return o.uid = df("ec_cpt_model"), o;
    }
    return t.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i);
    }, t.prototype.mergeDefaultAndTheme = function(r, n) {
      var i = Gg(this), o = i ? hf(r) : {}, a = n.getTheme();
      yt(r, a.get(this.mainType)), yt(r, this.getDefaultOption()), i && Kl(r, o, i);
    }, t.prototype.mergeOption = function(r, n) {
      yt(this.option, r, !0);
      var i = Gg(this);
      i && Kl(this.option, r, i);
    }, t.prototype.optionUpdated = function(r, n) {
    }, t.prototype.getDefaultOption = function() {
      var r = this.constructor;
      if (!Dve(r))
        return r.defaultOption;
      var n = $ye(this);
      if (!n.defaultOption) {
        for (var i = [], o = r; o; ) {
          var a = o.prototype.defaultOption;
          a && i.push(a), o = o.superClass;
        }
        for (var s = {}, l = i.length - 1; l >= 0; l--)
          s = yt(s, i[l], !0);
        n.defaultOption = s;
      }
      return n.defaultOption;
    }, t.prototype.getReferringComponents = function(r, n) {
      var i = r + "Index", o = r + "Id";
      return Pv(this.ecModel, r, {
        index: this.get(i, !0),
        id: this.get(o, !0)
      }, n);
    }, t.prototype.getBoxLayoutParams = function() {
      var r = this;
      return {
        left: r.get("left"),
        top: r.get("top"),
        right: r.get("right"),
        bottom: r.get("bottom"),
        width: r.get("width"),
        height: r.get("height")
      };
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(r) {
      this.option.zlevel = r;
    }, t.protoInitialize = function() {
      var r = t.prototype;
      r.type = "component", r.id = "", r.name = "", r.mainType = "", r.subType = "", r.componentIndex = 0;
    }(), t;
  }(cr)
);
G$(Rt, cr);
AS(Rt);
Tye(Rt);
Pye(Rt, Wye);
function Wye(e) {
  var t = [];
  return B(Rt.getClassesByMainType(e), function(r) {
    t = t.concat(r.dependencies || r.prototype.dependencies || []);
  }), t = ge(t, function(r) {
    return za(r).main;
  }), e !== "dataset" && bt(t, "dataset") <= 0 && t.unshift("dataset"), t;
}
var Z6 = "";
typeof navigator < "u" && (Z6 = navigator.platform || "");
var Ed = "rgba(0, 0, 0, 0.2)";
const jye = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: Ed,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: Ed,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: Ed,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: Ed,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: Ed,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: Ed,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: Z6.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var c_ = We(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), zo = "original", ti = "arrayRows", $o = "objectRows", is = "keyedColumns", As = "typedArray", X6 = "unknown", Ya = "column", ff = "row", Ln = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, Q6 = Gt();
function Uye(e) {
  Q6(e).datasetMap = We();
}
function J6(e, t, r) {
  var n = {}, i = NM(t);
  if (!i || !e)
    return n;
  var o = [], a = [], s = t.ecModel, l = Q6(s).datasetMap, u = i.uid + "_" + r.seriesLayoutBy, c, d;
  e = e.slice(), B(e, function(g, v) {
    var m = Ze(g) ? g : e[v] = {
      name: g
    };
    m.type === "ordinal" && c == null && (c = v, d = p(m)), n[m.name] = [];
  });
  var h = l.get(u) || l.set(u, {
    categoryWayDim: d,
    valueWayDim: 0
  });
  B(e, function(g, v) {
    var m = g.name, y = p(g);
    if (c == null) {
      var C = h.valueWayDim;
      f(n[m], C, y), f(a, C, y), h.valueWayDim += y;
    } else if (c === v)
      f(n[m], 0, y), f(o, 0, y);
    else {
      var C = h.categoryWayDim;
      f(n[m], C, y), f(a, C, y), h.categoryWayDim += y;
    }
  });
  function f(g, v, m) {
    for (var y = 0; y < m; y++)
      g.push(v + y);
  }
  function p(g) {
    var v = g.dimsDef;
    return v ? v.length : 1;
  }
  return o.length && (n.itemName = o), a.length && (n.seriesName = a), n;
}
function OM(e, t, r) {
  var n = {}, i = NM(e);
  if (!i)
    return n;
  var o = t.sourceFormat, a = t.dimensionsDefine, s;
  (o === $o || o === is) && B(a, function(c, d) {
    (Ze(c) ? c.name : c) === "name" && (s = d);
  });
  var l = function() {
    for (var c = {}, d = {}, h = [], f = 0, p = Math.min(5, r); f < p; f++) {
      var g = tW(t.data, o, t.seriesLayoutBy, a, t.startIndex, f);
      h.push(g);
      var v = g === Ln.Not;
      if (v && c.v == null && f !== s && (c.v = f), (c.n == null || c.n === c.v || !v && h[c.n] === Ln.Not) && (c.n = f), m(c) && h[c.n] !== Ln.Not)
        return c;
      v || (g === Ln.Might && d.v == null && f !== s && (d.v = f), (d.n == null || d.n === d.v) && (d.n = f));
    }
    function m(y) {
      return y.v != null && y.n != null;
    }
    return m(c) ? c : m(d) ? d : null;
  }();
  if (l) {
    n.value = [l.v];
    var u = s ?? l.n;
    n.itemName = [u], n.seriesName = [u];
  }
  return n;
}
function NM(e) {
  var t = e.get("data", !0);
  if (!t)
    return Pv(e.ecModel, "dataset", {
      index: e.get("datasetIndex", !0),
      id: e.get("datasetId", !0)
    }, un).models[0];
}
function Kye(e) {
  return !e.get("transform", !0) && !e.get("fromTransformResult", !0) ? [] : Pv(e.ecModel, "dataset", {
    index: e.get("fromDatasetIndex", !0),
    id: e.get("fromDatasetId", !0)
  }, un).models;
}
function eW(e, t) {
  return tW(e.data, e.sourceFormat, e.seriesLayoutBy, e.dimensionsDefine, e.startIndex, t);
}
function tW(e, t, r, n, i, o) {
  var a, s = 5;
  if (ei(e))
    return Ln.Not;
  var l, u;
  if (n) {
    var c = n[o];
    Ze(c) ? (l = c.name, u = c.type) : Fe(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? Ln.Must : Ln.Not;
  if (t === ti) {
    var d = e;
    if (r === ff) {
      for (var h = d[o], f = 0; f < (h || []).length && f < s; f++)
        if ((a = S(h[i + f])) != null)
          return a;
    } else
      for (var f = 0; f < d.length && f < s; f++) {
        var p = d[i + f];
        if (p && (a = S(p[o])) != null)
          return a;
      }
  } else if (t === $o) {
    var g = e;
    if (!l)
      return Ln.Not;
    for (var f = 0; f < g.length && f < s; f++) {
      var v = g[f];
      if (v && (a = S(v[l])) != null)
        return a;
    }
  } else if (t === is) {
    var m = e;
    if (!l)
      return Ln.Not;
    var h = m[l];
    if (!h || ei(h))
      return Ln.Not;
    for (var f = 0; f < h.length && f < s; f++)
      if ((a = S(h[f])) != null)
        return a;
  } else if (t === zo)
    for (var y = e, f = 0; f < y.length && f < s; f++) {
      var v = y[f], C = nf(v);
      if (!fe(C))
        return Ln.Not;
      if ((a = S(C[o])) != null)
        return a;
    }
  function S(b) {
    var w = Fe(b);
    if (b != null && Number.isFinite(Number(b)) && b !== "")
      return w ? Ln.Might : Ln.Not;
    if (w && b !== "-")
      return Ln.Must;
  }
  return Ln.Not;
}
var d_ = We();
function Yye(e, t) {
  Qe(d_.get(e) == null && t), d_.set(e, t);
}
function qye(e, t, r) {
  var n = d_.get(t);
  if (!n)
    return r;
  var i = n(e);
  if (!i)
    return r;
  if (process.env.NODE_ENV !== "production")
    for (var o = 0; o < i.length; o++)
      Qe(Ih(i[o]));
  return r.concat(i);
}
var VO = Gt(), Zye = Gt(), kM = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getColorFromPalette = function(t, r, n) {
      var i = dr(this.get("color", !0)), o = this.get("colorLayer", !0);
      return rW(this, VO, i, o, t, r, n);
    }, e.prototype.clearColorPalette = function() {
      Qye(this, VO);
    }, e;
  }()
);
function h_(e, t, r, n) {
  var i = dr(e.get(["aria", "decal", "decals"]));
  return rW(e, Zye, i, null, t, r, n);
}
function Xye(e, t) {
  for (var r = e.length, n = 0; n < r; n++)
    if (e[n].length > t)
      return e[n];
  return e[r - 1];
}
function rW(e, t, r, n, i, o, a) {
  o = o || e;
  var s = t(o), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(i))
    return u[i];
  var c = a == null || !n ? r : Xye(n, a);
  if (c = c || r, !(!c || !c.length)) {
    var d = c[l];
    return i && (u[i] = d), s.paletteIdx = (l + 1) % c.length, d;
  }
}
function Qye(e, t) {
  t(e).paletteIdx = 0, t(e).paletteNameMap = {};
}
var zm, Xf, BO, r1 = "\0_ec_inner", GO = 1, Jye = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, e0e = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, rC = {};
function t0e(e) {
  B(e, function(t, r) {
    if (!Rt.hasClass(r)) {
      var n = Jye[r];
      n && !rC[n] && (Vn("Component " + r + ` is used but not imported.
import { ` + n + ` } from 'echarts/components';
echarts.use([` + n + "]);"), rC[n] = !0);
    }
  });
}
var VM = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function(r, n, i, o, a, s) {
      o = o || {}, this.option = null, this._theme = new cr(o), this._locale = new cr(a), this._optionManager = s;
    }, t.prototype.setOption = function(r, n, i) {
      process.env.NODE_ENV !== "production" && (Qe(r != null, "option is null/undefined"), Qe(r[r1] !== GO, "please use chart.getOption()"));
      var o = $O(n);
      this._optionManager.setOption(r, i, o), this._resetOption(null, o);
    }, t.prototype.resetOption = function(r, n) {
      return this._resetOption(r, $O(n));
    }, t.prototype._resetOption = function(r, n) {
      var i = !1, o = this._optionManager;
      if (!r || r === "recreate") {
        var a = o.mountOption(r === "recreate");
        process.env.NODE_ENV !== "production" && t0e(a), !this.option || r === "recreate" ? BO(this, a) : (this.restoreData(), this._mergeOption(a, n)), i = !0;
      }
      if ((r === "timeline" || r === "media") && this.restoreData(), !r || r === "recreate" || r === "timeline") {
        var s = o.getTimelineOption(this);
        s && (i = !0, this._mergeOption(s, n));
      }
      if (!r || r === "recreate" || r === "media") {
        var l = o.getMediaOption(this);
        l.length && B(l, function(u) {
          i = !0, this._mergeOption(u, n);
        }, this);
      }
      return i;
    }, t.prototype.mergeOption = function(r) {
      this._mergeOption(r, null);
    }, t.prototype._mergeOption = function(r, n) {
      var i = this.option, o = this._componentsMap, a = this._componentsCount, s = [], l = We(), u = n && n.replaceMergeMainTypeMap;
      Uye(this), B(r, function(d, h) {
        d != null && (Rt.hasClass(h) ? h && (s.push(h), l.set(h, !0)) : i[h] = i[h] == null ? et(d) : yt(i[h], d, !0));
      }), u && u.each(function(d, h) {
        Rt.hasClass(h) && !l.get(h) && (s.push(h), l.set(h, !0));
      }), Rt.topologicalTravel(s, Rt.getAllClassMainTypes(), c, this);
      function c(d) {
        var h = qye(this, d, dr(r[d])), f = o.get(d), p = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          f ? u && u.get(d) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = O$(f, h, p);
        wve(g, d, Rt), i[d] = null, o.set(d, null), a.set(d, 0);
        var v = [], m = [], y = 0, C, S;
        B(g, function(b, w) {
          var x = b.existing, E = b.newOption;
          if (!E)
            x && (x.mergeOption({}, this), x.optionUpdated({}, !1));
          else {
            var R = d === "series", _ = Rt.getClass(
              d,
              b.keyInfo.subType,
              !R
              // Give a more detailed warn later if series don't exists
            );
            if (!_) {
              if (process.env.NODE_ENV !== "production") {
                var P = b.keyInfo.subType, D = e0e[P];
                rC[P] || (rC[P] = !0, Vn(D ? "Series " + P + ` is used but not imported.
import { ` + D + ` } from 'echarts/charts';
echarts.use([` + D + "]);" : "Unknown series " + P));
              }
              return;
            }
            if (d === "tooltip") {
              if (C) {
                process.env.NODE_ENV !== "production" && (S || (Vr("Currently only one tooltip component is allowed."), S = !0));
                return;
              }
              C = !0;
            }
            if (x && x.constructor === _)
              x.name = b.keyInfo.name, x.mergeOption(E, this), x.optionUpdated(E, !1);
            else {
              var I = se({
                componentIndex: w
              }, b.keyInfo);
              x = new _(E, this, this, I), se(x, I), b.brandNew && (x.__requireNewView = !0), x.init(E, this, this), x.optionUpdated(null, !0);
            }
          }
          x ? (v.push(x.option), m.push(x), y++) : (v.push(void 0), m.push(void 0));
        }, this), i[d] = v, o.set(d, m), a.set(d, y), d === "series" && zm(this);
      }
      this._seriesIndices || zm(this);
    }, t.prototype.getOption = function() {
      var r = et(this.option);
      return B(r, function(n, i) {
        if (Rt.hasClass(i)) {
          for (var o = dr(n), a = o.length, s = !1, l = a - 1; l >= 0; l--)
            o[l] && !Ih(o[l]) ? s = !0 : (o[l] = null, !s && a--);
          o.length = a, r[i] = o;
        }
      }), delete r[r1], r;
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(r) {
      this._payload = r;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(r, n) {
      var i = this._componentsMap.get(r);
      if (i) {
        var o = i[n || 0];
        if (o)
          return o;
        if (n == null) {
          for (var a = 0; a < i.length; a++)
            if (i[a])
              return i[a];
        }
      }
    }, t.prototype.queryComponents = function(r) {
      var n = r.mainType;
      if (!n)
        return [];
      var i = r.index, o = r.id, a = r.name, s = this._componentsMap.get(n);
      if (!s || !s.length)
        return [];
      var l;
      return i != null ? (l = [], B(dr(i), function(u) {
        s[u] && l.push(s[u]);
      })) : o != null ? l = HO("id", o, s) : a != null ? l = HO("name", a, s) : l = ir(s, function(u) {
        return !!u;
      }), zO(l, r);
    }, t.prototype.findComponents = function(r) {
      var n = r.query, i = r.mainType, o = s(n), a = o ? this.queryComponents(o) : ir(this._componentsMap.get(i), function(u) {
        return !!u;
      });
      return l(zO(a, r));
      function s(u) {
        var c = i + "Index", d = i + "Id", h = i + "Name";
        return u && (u[c] != null || u[d] != null || u[h] != null) ? {
          mainType: i,
          // subType will be filtered finally.
          index: u[c],
          id: u[d],
          name: u[h]
        } : null;
      }
      function l(u) {
        return r.filter ? ir(u, r.filter) : u;
      }
    }, t.prototype.eachComponent = function(r, n, i) {
      var o = this._componentsMap;
      if (Ye(r)) {
        var a = n, s = r;
        o.each(function(d, h) {
          for (var f = 0; d && f < d.length; f++) {
            var p = d[f];
            p && s.call(a, h, p, p.componentIndex);
          }
        });
      } else
        for (var l = Fe(r) ? o.get(r) : Ze(r) ? this.findComponents(r) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && n.call(i, c, c.componentIndex);
        }
    }, t.prototype.getSeriesByName = function(r) {
      var n = vn(r, null);
      return ir(this._componentsMap.get("series"), function(i) {
        return !!i && n != null && i.name === n;
      });
    }, t.prototype.getSeriesByIndex = function(r) {
      return this._componentsMap.get("series")[r];
    }, t.prototype.getSeriesByType = function(r) {
      return ir(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === r;
      });
    }, t.prototype.getSeries = function() {
      return ir(this._componentsMap.get("series"), function(r) {
        return !!r;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(r, n) {
      Xf(this), B(this._seriesIndices, function(i) {
        var o = this._componentsMap.get("series")[i];
        r.call(n, o, i);
      }, this);
    }, t.prototype.eachRawSeries = function(r, n) {
      B(this._componentsMap.get("series"), function(i) {
        i && r.call(n, i, i.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(r, n, i) {
      Xf(this), B(this._seriesIndices, function(o) {
        var a = this._componentsMap.get("series")[o];
        a.subType === r && n.call(i, a, o);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(r, n, i) {
      return B(this.getSeriesByType(r), n, i);
    }, t.prototype.isSeriesFiltered = function(r) {
      return Xf(this), this._seriesIndicesMap.get(r.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(r, n) {
      Xf(this);
      var i = [];
      B(this._seriesIndices, function(o) {
        var a = this._componentsMap.get("series")[o];
        r.call(n, a, o) && i.push(o);
      }, this), this._seriesIndices = i, this._seriesIndicesMap = We(i);
    }, t.prototype.restoreData = function(r) {
      zm(this);
      var n = this._componentsMap, i = [];
      n.each(function(o, a) {
        Rt.hasClass(a) && i.push(a);
      }), Rt.topologicalTravel(i, Rt.getAllClassMainTypes(), function(o) {
        B(n.get(o), function(a) {
          a && (o !== "series" || !r0e(a, r)) && a.restoreData();
        });
      });
    }, t.internalField = function() {
      zm = function(r) {
        var n = r._seriesIndices = [];
        B(r._componentsMap.get("series"), function(i) {
          i && n.push(i.componentIndex);
        }), r._seriesIndicesMap = We(n);
      }, Xf = function(r) {
        if (process.env.NODE_ENV !== "production" && !r._seriesIndices)
          throw new Error("Option should contains series.");
      }, BO = function(r, n) {
        r.option = {}, r.option[r1] = GO, r._componentsMap = We({
          series: []
        }), r._componentsCount = We();
        var i = n.aria;
        Ze(i) && i.enabled == null && (i.enabled = !0), n0e(n, r._theme.option), yt(n, jye, !1), r._mergeOption(n, null);
      };
    }(), t;
  }(cr)
);
function r0e(e, t) {
  if (t) {
    var r = t.seriesIndex, n = t.seriesId, i = t.seriesName;
    return r != null && e.componentIndex !== r || n != null && e.id !== n || i != null && e.name !== i;
  }
}
function n0e(e, t) {
  var r = e.color && !e.colorLayer;
  B(t, function(n, i) {
    i === "colorLayer" && r || Rt.hasClass(i) || (typeof n == "object" ? e[i] = e[i] ? yt(e[i], n, !1) : et(n) : e[i] == null && (e[i] = n));
  });
}
function HO(e, t, r) {
  if (fe(t)) {
    var n = We();
    return B(t, function(o) {
      if (o != null) {
        var a = vn(o, null);
        a != null && n.set(o, !0);
      }
    }), ir(r, function(o) {
      return o && n.get(o[e]);
    });
  } else {
    var i = vn(t, null);
    return ir(r, function(o) {
      return o && i != null && o[e] === i;
    });
  }
}
function zO(e, t) {
  return t.hasOwnProperty("subType") ? ir(e, function(r) {
    return r && r.subType === t.subType;
  }) : e;
}
function $O(e) {
  var t = We();
  return e && B(dr(e.replaceMerge), function(r) {
    process.env.NODE_ENV !== "production" && Qe(Rt.hasClass(r), '"' + r + '" is not valid component main type in "replaceMerge"'), t.set(r, !0);
  }), {
    replaceMergeMainTypeMap: t
  };
}
qr(VM, kM);
var i0e = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], nW = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      B(i0e, function(r) {
        this[r] = ke(t[r], t);
      }, this);
    }
    return e;
  }()
), n1 = {}, Yc = (
  /** @class */
  function() {
    function e() {
      this._coordinateSystems = [];
    }
    return e.prototype.create = function(t, r) {
      var n = [];
      B(n1, function(i, o) {
        var a = i.create(t, r);
        n = n.concat(a || []);
      }), this._coordinateSystems = n;
    }, e.prototype.update = function(t, r) {
      B(this._coordinateSystems, function(n) {
        n.update && n.update(t, r);
      });
    }, e.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, e.register = function(t, r) {
      n1[t] = r;
    }, e.get = function(t) {
      return n1[t];
    }, e;
  }()
), o0e = /^(min|max)?(.+)$/, a0e = (
  /** @class */
  function() {
    function e(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return e.prototype.setOption = function(t, r, n) {
      t && (B(dr(t.series), function(a) {
        a && a.data && ei(a.data) && Mg(a.data);
      }), B(dr(t.dataset), function(a) {
        a && a.source && ei(a.source) && Mg(a.source);
      })), t = et(t);
      var i = this._optionBackup, o = s0e(t, r, !i);
      this._newBaseOption = o.baseOption, i ? (o.timelineOptions.length && (i.timelineOptions = o.timelineOptions), o.mediaList.length && (i.mediaList = o.mediaList), o.mediaDefault && (i.mediaDefault = o.mediaDefault)) : this._optionBackup = o;
    }, e.prototype.mountOption = function(t) {
      var r = this._optionBackup;
      return this._timelineOptions = r.timelineOptions, this._mediaList = r.mediaList, this._mediaDefault = r.mediaDefault, this._currentMediaIndices = [], et(t ? r.baseOption : this._newBaseOption);
    }, e.prototype.getTimelineOption = function(t) {
      var r, n = this._timelineOptions;
      if (n.length) {
        var i = t.getComponent("timeline");
        i && (r = et(
          // FIXME:TS as TimelineModel or quivlant interface
          n[i.getCurrentIndex()]
        ));
      }
      return r;
    }, e.prototype.getMediaOption = function(t) {
      var r = this._api.getWidth(), n = this._api.getHeight(), i = this._mediaList, o = this._mediaDefault, a = [], s = [];
      if (!i.length && !o)
        return s;
      for (var l = 0, u = i.length; l < u; l++)
        l0e(i[l].query, r, n) && a.push(l);
      return !a.length && o && (a = [-1]), a.length && !c0e(a, this._currentMediaIndices) && (s = ge(a, function(c) {
        return et(c === -1 ? o.option : i[c].option);
      })), this._currentMediaIndices = a, s;
    }, e;
  }()
);
function s0e(e, t, r) {
  var n = [], i, o, a = e.baseOption, s = e.timeline, l = e.options, u = e.media, c = !!e.media, d = !!(l || s || a && a.timeline);
  a ? (o = a, o.timeline || (o.timeline = s)) : ((d || c) && (e.options = e.media = null), o = e), c && (fe(u) ? B(u, function(f) {
    process.env.NODE_ENV !== "production" && f && !f.option && Ze(f.query) && Ze(f.query.option) && Vn("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), f && f.option && (f.query ? n.push(f) : i || (i = f));
  }) : process.env.NODE_ENV !== "production" && Vn("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), h(o), B(l, function(f) {
    return h(f);
  }), B(n, function(f) {
    return h(f.option);
  });
  function h(f) {
    B(t, function(p) {
      p(f, r);
    });
  }
  return {
    baseOption: o,
    timelineOptions: l || [],
    mediaDefault: i,
    mediaList: n
  };
}
function l0e(e, t, r) {
  var n = {
    width: t,
    height: r,
    aspectratio: t / r
    // lower case for convenience.
  }, i = !0;
  return B(e, function(o, a) {
    var s = a.match(o0e);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      u0e(n[u], o, l) || (i = !1);
    }
  }), i;
}
function u0e(e, t, r) {
  return r === "min" ? e >= t : r === "max" ? e <= t : e === t;
}
function c0e(e, t) {
  return e.join(",") === t.join(",");
}
var co = B, Hg = Ze, WO = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function i1(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var r = 0, n = WO.length; r < n; r++) {
      var i = WO[r], o = t.normal, a = t.emphasis;
      o && o[i] && (process.env.NODE_ENV !== "production" && Jr("itemStyle.normal." + i, i), e[i] = e[i] || {}, e[i].normal ? yt(e[i].normal, o[i]) : e[i].normal = o[i], o[i] = null), a && a[i] && (process.env.NODE_ENV !== "production" && Jr("itemStyle.emphasis." + i, "emphasis." + i), e[i] = e[i] || {}, e[i].emphasis ? yt(e[i].emphasis, a[i]) : e[i].emphasis = a[i], a[i] = null);
    }
}
function qn(e, t, r) {
  if (e && e[t] && (e[t].normal || e[t].emphasis)) {
    var n = e[t].normal, i = e[t].emphasis;
    n && (process.env.NODE_ENV !== "production" && No("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), r ? (e[t].normal = e[t].emphasis = null, Xe(e[t], n)) : e[t] = n), i && (process.env.NODE_ENV !== "production" && No(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), e.emphasis = e.emphasis || {}, e.emphasis[t] = i, i.focus && (e.emphasis.focus = i.focus), i.blurScope && (e.emphasis.blurScope = i.blurScope));
  }
}
function Dp(e) {
  qn(e, "itemStyle"), qn(e, "lineStyle"), qn(e, "areaStyle"), qn(e, "label"), qn(e, "labelLine"), qn(e, "upperLabel"), qn(e, "edgeLabel");
}
function sn(e, t) {
  var r = Hg(e) && e[t], n = Hg(r) && r.textStyle;
  if (n) {
    process.env.NODE_ENV !== "production" && No("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
    for (var i = 0, o = YL.length; i < o; i++) {
      var a = YL[i];
      n.hasOwnProperty(a) && (r[a] = n[a]);
    }
  }
}
function Co(e) {
  e && (Dp(e), sn(e, "label"), e.emphasis && sn(e.emphasis, "label"));
}
function d0e(e) {
  if (Hg(e)) {
    i1(e), Dp(e), sn(e, "label"), sn(e, "upperLabel"), sn(e, "edgeLabel"), e.emphasis && (sn(e.emphasis, "label"), sn(e.emphasis, "upperLabel"), sn(e.emphasis, "edgeLabel"));
    var t = e.markPoint;
    t && (i1(t), Co(t));
    var r = e.markLine;
    r && (i1(r), Co(r));
    var n = e.markArea;
    n && Co(n);
    var i = e.data;
    if (e.type === "graph") {
      i = i || e.nodes;
      var o = e.links || e.edges;
      if (o && !ei(o))
        for (var a = 0; a < o.length; a++)
          Co(o[a]);
      B(e.categories, function(u) {
        Dp(u);
      });
    }
    if (i && !ei(i))
      for (var a = 0; a < i.length; a++)
        Co(i[a]);
    if (t = e.markPoint, t && t.data)
      for (var s = t.data, a = 0; a < s.length; a++)
        Co(s[a]);
    if (r = e.markLine, r && r.data)
      for (var l = r.data, a = 0; a < l.length; a++)
        fe(l[a]) ? (Co(l[a][0]), Co(l[a][1])) : Co(l[a]);
    e.type === "gauge" ? (sn(e, "axisLabel"), sn(e, "title"), sn(e, "detail")) : e.type === "treemap" ? (qn(e.breadcrumb, "itemStyle"), B(e.levels, function(u) {
      Dp(u);
    })) : e.type === "tree" && Dp(e.leaves);
  }
}
function ps(e) {
  return fe(e) ? e : e ? [e] : [];
}
function jO(e) {
  return (fe(e) ? e[0] : e) || {};
}
function h0e(e, t) {
  co(ps(e.series), function(n) {
    Hg(n) && d0e(n);
  });
  var r = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  t && r.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), co(r, function(n) {
    co(ps(e[n]), function(i) {
      i && (sn(i, "axisLabel"), sn(i.axisPointer, "label"));
    });
  }), co(ps(e.parallel), function(n) {
    var i = n && n.parallelAxisDefault;
    sn(i, "axisLabel"), sn(i && i.axisPointer, "label");
  }), co(ps(e.calendar), function(n) {
    qn(n, "itemStyle"), sn(n, "dayLabel"), sn(n, "monthLabel"), sn(n, "yearLabel");
  }), co(ps(e.radar), function(n) {
    sn(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name, process.env.NODE_ENV !== "production" && No("name property in radar component has been changed to axisName")), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap, process.env.NODE_ENV !== "production" && No("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && co(n.indicator, function(i) {
      i.text && Jr("text", "name", "radar.indicator");
    });
  }), co(ps(e.geo), function(n) {
    Hg(n) && (Co(n), co(ps(n.regions), function(i) {
      Co(i);
    }));
  }), co(ps(e.timeline), function(n) {
    Co(n), qn(n, "label"), qn(n, "itemStyle"), qn(n, "controlStyle", !0);
    var i = n.data;
    fe(i) && B(i, function(o) {
      Ze(o) && (qn(o, "label"), qn(o, "itemStyle"));
    });
  }), co(ps(e.toolbox), function(n) {
    qn(n, "iconStyle"), co(n.feature, function(i) {
      qn(i, "iconStyle");
    });
  }), sn(jO(e.axisPointer), "label"), sn(jO(e.tooltip).axisPointer, "label");
}
function f0e(e, t) {
  for (var r = t.split(","), n = e, i = 0; i < r.length && (n = n && n[r[i]], n != null); i++)
    ;
  return n;
}
function p0e(e, t, r, n) {
  for (var i = t.split(","), o = e, a, s = 0; s < i.length - 1; s++)
    a = i[s], o[a] == null && (o[a] = {}), o = o[a];
  o[i[s]] == null && (o[i[s]] = r);
}
function UO(e) {
  e && B(g0e, function(t) {
    t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]]);
  });
}
var g0e = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], v0e = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], o1 = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function Qf(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var r = 0; r < o1.length; r++) {
      var n = o1[r][1], i = o1[r][0];
      t[n] != null && (t[i] = t[n], process.env.NODE_ENV !== "production" && Jr(n, i));
    }
}
function KO(e) {
  e && e.alignTo === "edge" && e.margin != null && e.edgeDistance == null && (process.env.NODE_ENV !== "production" && Jr("label.margin", "label.edgeDistance", "pie"), e.edgeDistance = e.margin);
}
function YO(e) {
  e && e.downplay && !e.blur && (e.blur = e.downplay, process.env.NODE_ENV !== "production" && Jr("downplay", "blur", "sunburst"));
}
function m0e(e) {
  e && e.focusNodeAdjacency != null && (e.emphasis = e.emphasis || {}, e.emphasis.focus == null && (process.env.NODE_ENV !== "production" && Jr("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), e.emphasis.focus = "adjacency"));
}
function iW(e, t) {
  if (e)
    for (var r = 0; r < e.length; r++)
      t(e[r]), e[r] && iW(e[r].children, t);
}
function oW(e, t) {
  h0e(e, t), e.series = dr(e.series), B(e.series, function(r) {
    if (Ze(r)) {
      var n = r.type;
      if (n === "line")
        r.clipOverflow != null && (r.clip = r.clipOverflow, process.env.NODE_ENV !== "production" && Jr("clipOverflow", "clip", "line"));
      else if (n === "pie" || n === "gauge") {
        r.clockWise != null && (r.clockwise = r.clockWise, process.env.NODE_ENV !== "production" && Jr("clockWise", "clockwise")), KO(r.label);
        var i = r.data;
        if (i && !ei(i))
          for (var o = 0; o < i.length; o++)
            KO(i[o]);
        r.hoverOffset != null && (r.emphasis = r.emphasis || {}, (r.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && Jr("hoverOffset", "emphasis.scaleSize"), r.emphasis.scaleSize = r.hoverOffset));
      } else if (n === "gauge") {
        var a = f0e(r, "pointer.color");
        a != null && p0e(r, "itemStyle.color", a);
      } else if (n === "bar") {
        Qf(r), Qf(r.backgroundStyle), Qf(r.emphasis);
        var i = r.data;
        if (i && !ei(i))
          for (var o = 0; o < i.length; o++)
            typeof i[o] == "object" && (Qf(i[o]), Qf(i[o] && i[o].emphasis));
      } else if (n === "sunburst") {
        var s = r.highlightPolicy;
        s && (r.emphasis = r.emphasis || {}, r.emphasis.focus || (r.emphasis.focus = s, process.env.NODE_ENV !== "production" && Jr("highlightPolicy", "emphasis.focus", "sunburst"))), YO(r), iW(r.data, YO);
      } else n === "graph" || n === "sankey" ? m0e(r) : n === "map" && (r.mapType && !r.map && (process.env.NODE_ENV !== "production" && Jr("mapType", "map", "map"), r.map = r.mapType), r.mapLocation && (process.env.NODE_ENV !== "production" && No("`mapLocation` is not used anymore."), Xe(r, r.mapLocation)));
      r.hoverAnimation != null && (r.emphasis = r.emphasis || {}, r.emphasis && r.emphasis.scale == null && (process.env.NODE_ENV !== "production" && Jr("hoverAnimation", "emphasis.scale"), r.emphasis.scale = r.hoverAnimation)), UO(r);
    }
  }), e.dataRange && (e.visualMap = e.dataRange), B(v0e, function(r) {
    var n = e[r];
    n && (fe(n) || (n = [n]), B(n, function(i) {
      UO(i);
    }));
  });
}
function y0e(e) {
  var t = We();
  e.eachSeries(function(r) {
    var n = r.get("stack");
    if (n) {
      var i = t.get(n) || t.set(n, []), o = r.getData(), a = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: o.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: o.getCalculationInfo("stackedOverDimension"),
        stackedDimension: o.getCalculationInfo("stackedDimension"),
        stackedByDimension: o.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: o.getCalculationInfo("isStackedByIndex"),
        data: o,
        seriesModel: r
      };
      if (!a.stackedDimension || !(a.isStackedByIndex || a.stackedByDimension))
        return;
      i.length && o.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(a);
    }
  }), t.each(C0e);
}
function C0e(e) {
  B(e, function(t, r) {
    var n = [], i = [NaN, NaN], o = [t.stackResultDimension, t.stackedOverDimension], a = t.data, s = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
    a.modify(o, function(u, c, d) {
      var h = a.get(t.stackedDimension, d);
      if (isNaN(h))
        return i;
      var f, p;
      s ? p = a.getRawIndex(d) : f = a.get(t.stackedByDimension, d);
      for (var g = NaN, v = r - 1; v >= 0; v--) {
        var m = e[v];
        if (s || (p = m.data.rawIndexOf(m.stackedByDimension, f)), p >= 0) {
          var y = m.data.getByRawIndex(m.stackResultDimension, p);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && h >= 0 && y > 0 || l === "samesign" && h <= 0 && y < 0) {
            h = lve(h, y), g = y;
            break;
          }
        }
      }
      return n[0] = h, n[1] = g, n;
    });
  });
}
var YS = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.data = t.data || (t.sourceFormat === is ? {} : []), this.sourceFormat = t.sourceFormat || X6, this.seriesLayoutBy = t.seriesLayoutBy || Ya, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var r = this.dimensionsDefine = t.dimensionsDefine;
      if (r)
        for (var n = 0; n < r.length; n++) {
          var i = r[n];
          i.type == null && eW(this, n) === Ln.Must && (i.type = "ordinal");
        }
    }
    return e;
  }()
);
function BM(e) {
  return e instanceof YS;
}
function f_(e, t, r) {
  r = r || aW(e);
  var n = t.seriesLayoutBy, i = w0e(e, r, n, t.sourceHeader, t.dimensions), o = new YS({
    data: e,
    sourceFormat: r,
    seriesLayoutBy: n,
    dimensionsDefine: i.dimensionsDefine,
    startIndex: i.startIndex,
    dimensionsDetectedCount: i.dimensionsDetectedCount,
    metaRawOption: et(t)
  });
  return o;
}
function GM(e) {
  return new YS({
    data: e,
    sourceFormat: ei(e) ? As : zo
  });
}
function S0e(e) {
  return new YS({
    data: e.data,
    sourceFormat: e.sourceFormat,
    seriesLayoutBy: e.seriesLayoutBy,
    dimensionsDefine: et(e.dimensionsDefine),
    startIndex: e.startIndex,
    dimensionsDetectedCount: e.dimensionsDetectedCount
  });
}
function aW(e) {
  var t = X6;
  if (ei(e))
    t = As;
  else if (fe(e)) {
    e.length === 0 && (t = ti);
    for (var r = 0, n = e.length; r < n; r++) {
      var i = e[r];
      if (i != null) {
        if (fe(i) || ei(i)) {
          t = ti;
          break;
        } else if (Ze(i)) {
          t = $o;
          break;
        }
      }
    }
  } else if (Ze(e)) {
    for (var o in e)
      if (Be(e, o) && kn(e[o])) {
        t = is;
        break;
      }
  }
  return t;
}
function w0e(e, t, r, n, i) {
  var o, a;
  if (!e)
    return {
      dimensionsDefine: qO(i),
      startIndex: a,
      dimensionsDetectedCount: o
    };
  if (t === ti) {
    var s = e;
    n === "auto" || n == null ? ZO(function(u) {
      u != null && u !== "-" && (Fe(u) ? a == null && (a = 1) : a = 0);
    }, r, s, 10) : a = $t(n) ? n : n ? 1 : 0, !i && a === 1 && (i = [], ZO(function(u, c) {
      i[c] = u != null ? u + "" : "";
    }, r, s, 1 / 0)), o = i ? i.length : r === ff ? s.length : s[0] ? s[0].length : null;
  } else if (t === $o)
    i || (i = b0e(e));
  else if (t === is)
    i || (i = [], B(e, function(u, c) {
      i.push(c);
    }));
  else if (t === zo) {
    var l = nf(e[0]);
    o = fe(l) && l.length || 1;
  } else t === As && process.env.NODE_ENV !== "production" && Qe(!!i, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: a,
    dimensionsDefine: qO(i),
    dimensionsDetectedCount: o
  };
}
function b0e(e) {
  for (var t = 0, r; t < e.length && !(r = e[t++]); )
    ;
  if (r)
    return At(r);
}
function qO(e) {
  if (e) {
    var t = We();
    return ge(e, function(r, n) {
      r = Ze(r) ? r : {
        name: r
      };
      var i = {
        name: r.name,
        displayName: r.displayName,
        type: r.type
      };
      if (i.name == null)
        return i;
      i.name += "", i.displayName == null && (i.displayName = i.name);
      var o = t.get(i.name);
      return o ? i.name += "-" + o.count++ : t.set(i.name, {
        count: 1
      }), i;
    });
  }
}
function ZO(e, t, r, n) {
  if (t === ff)
    for (var i = 0; i < r.length && i < n; i++)
      e(r[i] ? r[i][0] : null, i);
  else
    for (var o = r[0] || [], i = 0; i < o.length && i < n; i++)
      e(o[i], i);
}
function sW(e) {
  var t = e.sourceFormat;
  return t === $o || t === is;
}
var Tu, Pu, Mu, XO, QO, lW = (
  /** @class */
  function() {
    function e(t, r) {
      var n = BM(t) ? t : GM(t);
      this._source = n;
      var i = this._data = n.data;
      if (n.sourceFormat === As) {
        if (process.env.NODE_ENV !== "production" && r == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = r, this._data = i;
      }
      QO(this, i, n);
    }
    return e.prototype.getSource = function() {
      return this._source;
    }, e.prototype.count = function() {
      return 0;
    }, e.prototype.getItem = function(t, r) {
    }, e.prototype.appendData = function(t) {
    }, e.prototype.clean = function() {
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.pure = !1, t.persistent = !0;
    }(), e.internalField = function() {
      var t;
      QO = function(a, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, d = l.startIndex, h = l.dimensionsDefine, f = XO[HM(u, c)];
        if (process.env.NODE_ENV !== "production" && Qe(f, "Invalide sourceFormat: " + u), se(a, f), u === As)
          a.getItem = r, a.count = i, a.fillStorage = n;
        else {
          var p = uW(u, c);
          a.getItem = ke(p, null, s, d, h);
          var g = cW(u, c);
          a.count = ke(g, null, s, d, h);
        }
      };
      var r = function(a, s) {
        a = a - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * a, d = 0; d < u; d++)
          s[d] = l[c + d];
        return s;
      }, n = function(a, s, l, u) {
        for (var c = this._data, d = this._dimSize, h = 0; h < d; h++) {
          for (var f = u[h], p = f[0] == null ? 1 / 0 : f[0], g = f[1] == null ? -1 / 0 : f[1], v = s - a, m = l[h], y = 0; y < v; y++) {
            var C = c[y * d + h];
            m[a + y] = C, C < p && (p = C), C > g && (g = C);
          }
          f[0] = p, f[1] = g;
        }
      }, i = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      XO = (t = {}, t[ti + "_" + Ya] = {
        pure: !0,
        appendData: o
      }, t[ti + "_" + ff] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[$o] = {
        pure: !0,
        appendData: o
      }, t[is] = {
        pure: !0,
        appendData: function(a) {
          var s = this._data;
          B(a, function(l, u) {
            for (var c = s[u] || (s[u] = []), d = 0; d < (l || []).length; d++)
              c.push(l[d]);
          });
        }
      }, t[zo] = {
        appendData: o
      }, t[As] = {
        persistent: !1,
        pure: !0,
        appendData: function(a) {
          process.env.NODE_ENV !== "production" && Qe(ei(a), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = a;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function o(a) {
        for (var s = 0; s < a.length; s++)
          this._data.push(a[s]);
      }
    }(), e;
  }()
), JO = function(e, t, r, n) {
  return e[n];
}, x0e = (Tu = {}, Tu[ti + "_" + Ya] = function(e, t, r, n) {
  return e[n + t];
}, Tu[ti + "_" + ff] = function(e, t, r, n, i) {
  n += t;
  for (var o = i || [], a = e, s = 0; s < a.length; s++) {
    var l = a[s];
    o[s] = l ? l[n] : null;
  }
  return o;
}, Tu[$o] = JO, Tu[is] = function(e, t, r, n, i) {
  for (var o = i || [], a = 0; a < r.length; a++) {
    var s = r[a].name;
    if (process.env.NODE_ENV !== "production" && s == null)
      throw new Error();
    var l = e[s];
    o[a] = l ? l[n] : null;
  }
  return o;
}, Tu[zo] = JO, Tu);
function uW(e, t) {
  var r = x0e[HM(e, t)];
  return process.env.NODE_ENV !== "production" && Qe(r, 'Do not support get item on "' + e + '", "' + t + '".'), r;
}
var eN = function(e, t, r) {
  return e.length;
}, E0e = (Pu = {}, Pu[ti + "_" + Ya] = function(e, t, r) {
  return Math.max(0, e.length - t);
}, Pu[ti + "_" + ff] = function(e, t, r) {
  var n = e[0];
  return n ? Math.max(0, n.length - t) : 0;
}, Pu[$o] = eN, Pu[is] = function(e, t, r) {
  var n = r[0].name;
  if (process.env.NODE_ENV !== "production" && n == null)
    throw new Error();
  var i = e[n];
  return i ? i.length : 0;
}, Pu[zo] = eN, Pu);
function cW(e, t) {
  var r = E0e[HM(e, t)];
  return process.env.NODE_ENV !== "production" && Qe(r, 'Do not support count on "' + e + '", "' + t + '".'), r;
}
var a1 = function(e, t, r) {
  return e[t];
}, R0e = (Mu = {}, Mu[ti] = a1, Mu[$o] = function(e, t, r) {
  return e[r];
}, Mu[is] = a1, Mu[zo] = function(e, t, r) {
  var n = nf(e);
  return n instanceof Array ? n[t] : n;
}, Mu[As] = a1, Mu);
function dW(e) {
  var t = R0e[e];
  return process.env.NODE_ENV !== "production" && Qe(t, 'Do not support get value on "' + e + '".'), t;
}
function HM(e, t) {
  return e === ti ? e + "_" + t : e;
}
function Oh(e, t, r) {
  if (e) {
    var n = e.getRawDataItem(t);
    if (n != null) {
      var i = e.getStore(), o = i.getSource().sourceFormat;
      if (r != null) {
        var a = e.getDimensionIndex(r), s = i.getDimensionProperty(a);
        return dW(o)(n, a, s);
      } else {
        var l = n;
        return o === zo && (l = nf(n)), l;
      }
    }
  }
}
var _0e = /\{@(.+?)\}/g, qS = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getDataParams = function(t, r) {
      var n = this.getData(r), i = this.getRawValue(t, r), o = n.getRawIndex(t), a = n.getName(t), s = n.getRawDataItem(t), l = n.getItemVisual(t, "style"), u = l && l[n.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, d = this.mainType, h = d === "series", f = n.userOutput && n.userOutput.get();
      return {
        componentType: d,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: h ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: h ? this.id : null,
        seriesName: h ? this.name : null,
        name: a,
        dataIndex: o,
        data: s,
        dataType: r,
        value: i,
        color: u,
        borderColor: c,
        dimensionNames: f ? f.fullDimensions : null,
        encode: f ? f.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, e.prototype.getFormattedLabel = function(t, r, n, i, o, a) {
      r = r || "normal";
      var s = this.getData(n), l = this.getDataParams(t, n);
      if (a && (l.value = a.interpolatedValue), i != null && fe(l.value) && (l.value = l.value[i]), !o) {
        var u = s.getItemModel(t);
        o = u.get(r === "normal" ? ["label", "formatter"] : [r, "label", "formatter"]);
      }
      if (Ye(o))
        return l.status = r, l.dimensionIndex = i, o(l);
      if (Fe(o)) {
        var c = FM(o, l);
        return c.replace(_0e, function(d, h) {
          var f = h.length, p = h;
          p.charAt(0) === "[" && p.charAt(f - 1) === "]" && (p = +p.slice(1, f - 1), process.env.NODE_ENV !== "production" && isNaN(p) && Vn("Invalide label formatter: @" + h + ", only support @[0], @[1], @[2], ..."));
          var g = Oh(s, t, p);
          if (a && fe(a.interpolatedValue)) {
            var v = s.getDimensionIndex(p);
            v >= 0 && (g = a.interpolatedValue[v]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, e.prototype.getRawValue = function(t, r) {
      return Oh(this.getData(r), t);
    }, e.prototype.formatTooltip = function(t, r, n) {
    }, e;
  }()
);
function tN(e) {
  var t, r;
  return Ze(e) ? e.type ? r = e : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + wi(e)) : t = e, {
    text: t,
    // markers: markers || markersExisting,
    frag: r
  };
}
function ig(e) {
  return new T0e(e);
}
var T0e = (
  /** @class */
  function() {
    function e(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
    }
    return e.prototype.perform = function(t) {
      var r = this._upstream, n = t && t.skip;
      if (this._dirty && r) {
        var i = this.context;
        i.data = i.outputData = r.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var o;
      this._plan && !n && (o = this._plan(this.context));
      var a = c(this._modBy), s = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (a !== l || s !== u) && (o = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var d;
      (this._dirty || o === "reset") && (this._dirty = !1, d = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var h = t && t.step;
      if (r ? (process.env.NODE_ENV !== "production" && Qe(r._outputDueEnd != null), this._dueEnd = r._outputDueEnd) : (process.env.NODE_ENV !== "production" && Qe(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var f = this._dueIndex, p = Math.min(h != null ? this._dueIndex + h : 1 / 0, this._dueEnd);
        if (!n && (d || f < p)) {
          var g = this._progress;
          if (fe(g))
            for (var v = 0; v < g.length; v++)
              this._doProgress(g[v], f, p, l, u);
          else
            this._doProgress(g, f, p, l, u);
        }
        this._dueIndex = p;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        process.env.NODE_ENV !== "production" && Qe(m >= this._outputDueEnd), this._outputDueEnd = m;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, e.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, e.prototype._doProgress = function(t, r, n, i, o) {
      rN.reset(r, n, i, o), this._callingProgress = t, this._callingProgress({
        start: r,
        end: n,
        count: n - r,
        next: rN.next
      }, this.context);
    }, e.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var r, n;
      !t && this._reset && (r = this._reset(this.context), r && r.progress && (n = r.forceFirstProgress, r = r.progress), fe(r) && !r.length && (r = null)), this._progress = r, this._modBy = this._modDataCount = null;
      var i = this._downstream;
      return i && i.dirty(), n;
    }, e.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, e.prototype.pipe = function(t) {
      process.env.NODE_ENV !== "production" && Qe(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, e.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, e.prototype.getUpstream = function() {
      return this._upstream;
    }, e.prototype.getDownstream = function() {
      return this._downstream;
    }, e.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, e;
  }()
), rN = /* @__PURE__ */ function() {
  var e, t, r, n, i, o = {
    reset: function(l, u, c, d) {
      t = l, e = u, r = c, n = d, i = Math.ceil(n / r), o.next = r > 1 && n > 0 ? s : a;
    }
  };
  return o;
  function a() {
    return t < e ? t++ : null;
  }
  function s() {
    var l = t % i * r + Math.ceil(t / i), u = t >= e ? null : l < n ? l : t;
    return t++, u;
  }
}();
function Ol(e, t) {
  var r = t && t.type;
  return r === "ordinal" ? e : (r === "time" && !$t(e) && e != null && e !== "-" && (e = +io(e)), e == null || e === "" ? NaN : Number(e));
}
var P0e = We({
  number: function(e) {
    return parseFloat(e);
  },
  time: function(e) {
    return +io(e);
  },
  trim: function(e) {
    return Fe(e) ? _o(e) : e;
  }
});
function hW(e) {
  return P0e.get(e);
}
var fW = {
  lt: function(e, t) {
    return e < t;
  },
  lte: function(e, t) {
    return e <= t;
  },
  gt: function(e, t) {
    return e > t;
  },
  gte: function(e, t) {
    return e >= t;
  }
}, M0e = (
  /** @class */
  function() {
    function e(t, r) {
      if (!$t(r)) {
        var n = "";
        process.env.NODE_ENV !== "production" && (n = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'), er(n);
      }
      this._opFn = fW[t], this._rvalFloat = Ja(r);
    }
    return e.prototype.evaluate = function(t) {
      return $t(t) ? this._opFn(t, this._rvalFloat) : this._opFn(Ja(t), this._rvalFloat);
    }, e;
  }()
), pW = (
  /** @class */
  function() {
    function e(t, r) {
      var n = t === "desc";
      this._resultLT = n ? 1 : -1, r == null && (r = n ? "min" : "max"), this._incomparable = r === "min" ? -1 / 0 : 1 / 0;
    }
    return e.prototype.evaluate = function(t, r) {
      var n = $t(t) ? t : Ja(t), i = $t(r) ? r : Ja(r), o = isNaN(n), a = isNaN(i);
      if (o && (n = this._incomparable), a && (i = this._incomparable), o && a) {
        var s = Fe(t), l = Fe(r);
        s && (n = l ? t : 0), l && (i = s ? r : 0);
      }
      return n < i ? this._resultLT : n > i ? -this._resultLT : 0;
    }, e;
  }()
), D0e = (
  /** @class */
  function() {
    function e(t, r) {
      this._rval = r, this._isEQ = t, this._rvalTypeof = typeof r, this._rvalFloat = Ja(r);
    }
    return e.prototype.evaluate = function(t) {
      var r = t === this._rval;
      if (!r) {
        var n = typeof t;
        n !== this._rvalTypeof && (n === "number" || this._rvalTypeof === "number") && (r = Ja(t) === this._rvalFloat);
      }
      return this._isEQ ? r : !r;
    }, e;
  }()
);
function A0e(e, t) {
  return e === "eq" || e === "ne" ? new D0e(e === "eq", t) : Be(fW, e) ? new M0e(e, t) : null;
}
var I0e = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getRawData = function() {
      throw new Error("not supported");
    }, e.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, e.prototype.cloneRawData = function() {
    }, e.prototype.getDimensionInfo = function(t) {
    }, e.prototype.cloneAllDimensionInfo = function() {
    }, e.prototype.count = function() {
    }, e.prototype.retrieveValue = function(t, r) {
    }, e.prototype.retrieveValueFromItem = function(t, r) {
    }, e.prototype.convertValue = function(t, r) {
      return Ol(t, r);
    }, e;
  }()
);
function F0e(e, t) {
  var r = new I0e(), n = e.data, i = r.sourceFormat = e.sourceFormat, o = e.startIndex, a = "";
  e.seriesLayoutBy !== Ya && (process.env.NODE_ENV !== "production" && (a = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), er(a));
  var s = [], l = {}, u = e.dimensionsDefine;
  if (u)
    B(u, function(g, v) {
      var m = g.name, y = {
        index: v,
        name: m,
        displayName: g.displayName
      };
      if (s.push(y), m != null) {
        var C = "";
        Be(l, m) && (process.env.NODE_ENV !== "production" && (C = 'dimension name "' + m + '" duplicated.'), er(C)), l[m] = y;
      }
    });
  else
    for (var c = 0; c < e.dimensionsDetectedCount; c++)
      s.push({
        index: c
      });
  var d = uW(i, Ya);
  t.__isBuiltIn && (r.getRawDataItem = function(g) {
    return d(n, o, s, g);
  }, r.getRawData = ke(L0e, null, e)), r.cloneRawData = ke(O0e, null, e);
  var h = cW(i, Ya);
  r.count = ke(h, null, n, o, s);
  var f = dW(i);
  r.retrieveValue = function(g, v) {
    var m = d(n, o, s, g);
    return p(m, v);
  };
  var p = r.retrieveValueFromItem = function(g, v) {
    if (g != null) {
      var m = s[v];
      if (m)
        return f(g, v, m.name);
    }
  };
  return r.getDimensionInfo = ke(N0e, null, s, l), r.cloneAllDimensionInfo = ke(k0e, null, s), r;
}
function L0e(e) {
  var t = e.sourceFormat;
  if (!zM(t)) {
    var r = "";
    process.env.NODE_ENV !== "production" && (r = "`getRawData` is not supported in source format " + t), er(r);
  }
  return e.data;
}
function O0e(e) {
  var t = e.sourceFormat, r = e.data;
  if (!zM(t)) {
    var n = "";
    process.env.NODE_ENV !== "production" && (n = "`cloneRawData` is not supported in source format " + t), er(n);
  }
  if (t === ti) {
    for (var i = [], o = 0, a = r.length; o < a; o++)
      i.push(r[o].slice());
    return i;
  } else if (t === $o) {
    for (var i = [], o = 0, a = r.length; o < a; o++)
      i.push(se({}, r[o]));
    return i;
  }
}
function N0e(e, t, r) {
  if (r != null) {
    if ($t(r) || !isNaN(r) && !Be(t, r))
      return e[r];
    if (Be(t, r))
      return t[r];
  }
}
function k0e(e) {
  return et(e);
}
var gW = We();
function V0e(e) {
  e = et(e);
  var t = e.type, r = "";
  t || (process.env.NODE_ENV !== "production" && (r = "Must have a `type` when `registerTransform`."), er(r));
  var n = t.split(":");
  n.length !== 2 && (process.env.NODE_ENV !== "production" && (r = 'Name must include namespace like "ns:regression".'), er(r));
  var i = !1;
  n[0] === "echarts" && (t = n[1], i = !0), e.__isBuiltIn = i, gW.set(t, e);
}
function B0e(e, t, r) {
  var n = dr(e), i = n.length, o = "";
  i || (process.env.NODE_ENV !== "production" && (o = "If `transform` declared, it should at least contain one transform."), er(o));
  for (var a = 0, s = i; a < s; a++) {
    var l = n[a];
    t = G0e(l, t, r, i === 1 ? null : a), a !== s - 1 && (t.length = Math.max(t.length, 1));
  }
  return t;
}
function G0e(e, t, r, n) {
  var i = "";
  t.length || (process.env.NODE_ENV !== "production" && (i = "Must have at least one upstream dataset."), er(i)), Ze(e) || (process.env.NODE_ENV !== "production" && (i = "transform declaration must be an object rather than " + typeof e + "."), er(i));
  var o = e.type, a = gW.get(o);
  a || (process.env.NODE_ENV !== "production" && (i = 'Can not find transform on type "' + o + '".'), er(i));
  var s = ge(t, function(c) {
    return F0e(c, a);
  }), l = dr(a.transform({
    upstream: s[0],
    upstreamList: s,
    config: et(e.config)
  }));
  if (process.env.NODE_ENV !== "production" && e.print) {
    var u = ge(l, function(c) {
      var d = n != null ? " === pipe index: " + n : "";
      return ["=== dataset index: " + r.datasetIndex + d + " ===", "- transform result data:", wi(c.data), "- transform result dimensions:", wi(c.dimensions)].join(`
`);
    }).join(`
`);
    hve(u);
  }
  return ge(l, function(c, d) {
    var h = "";
    Ze(c) || (process.env.NODE_ENV !== "production" && (h = "A transform should not return some empty results."), er(h)), c.data || (process.env.NODE_ENV !== "production" && (h = "Transform result data should be not be null or undefined"), er(h));
    var f = aW(c.data);
    zM(f) || (process.env.NODE_ENV !== "production" && (h = "Transform result data should be array rows or object rows."), er(h));
    var p, g = t[0];
    if (g && d === 0 && !c.dimensions) {
      var v = g.startIndex;
      v && (c.data = g.data.slice(0, v).concat(c.data)), p = {
        seriesLayoutBy: Ya,
        sourceHeader: v,
        dimensions: g.metaRawOption.dimensions
      };
    } else
      p = {
        seriesLayoutBy: Ya,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return f_(c.data, p, null);
  });
}
function zM(e) {
  return e === ti || e === $o;
}
var ZS = "undefined", H0e = typeof Uint32Array === ZS ? Array : Uint32Array, z0e = typeof Uint16Array === ZS ? Array : Uint16Array, vW = typeof Int32Array === ZS ? Array : Int32Array, nN = typeof Float64Array === ZS ? Array : Float64Array, mW = {
  float: nN,
  int: vW,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: nN
}, s1;
function Jf(e) {
  return e > 65535 ? H0e : z0e;
}
function Rd() {
  return [1 / 0, -1 / 0];
}
function $0e(e) {
  var t = e.constructor;
  return t === Array ? e.slice() : new t(e);
}
function iN(e, t, r, n, i) {
  var o = mW[r || "float"];
  if (i) {
    var a = e[t], s = a && a.length;
    if (s !== n) {
      for (var l = new o(n), u = 0; u < s; u++)
        l[u] = a[u];
      e[t] = l;
    }
  } else
    e[t] = new o(n);
}
var p_ = (
  /** @class */
  function() {
    function e() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = We();
    }
    return e.prototype.initData = function(t, r, n) {
      process.env.NODE_ENV !== "production" && Qe(Ye(t.getItem) && Ye(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var i = t.getSource(), o = this.defaultDimValueGetter = s1[i.sourceFormat];
      this._dimValueGetter = n || o, this._rawExtent = [];
      var a = sW(i);
      this._dimensions = ge(r, function(s) {
        return process.env.NODE_ENV !== "production" && a && Qe(s.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, e.prototype.getProvider = function() {
      return this._provider;
    }, e.prototype.getSource = function() {
      return this._provider.getSource();
    }, e.prototype.ensureCalculationDimension = function(t, r) {
      var n = this._calcDimNameToIdx, i = this._dimensions, o = n.get(t);
      if (o != null) {
        if (i[o].type === r)
          return o;
      } else
        o = i.length;
      return i[o] = {
        type: r
      }, n.set(t, o), this._chunks[o] = new mW[r || "float"](this._rawCount), this._rawExtent[o] = Rd(), o;
    }, e.prototype.collectOrdinalMeta = function(t, r) {
      var n = this._chunks[t], i = this._dimensions[t], o = this._rawExtent, a = i.ordinalOffset || 0, s = n.length;
      a === 0 && (o[t] = Rd());
      for (var l = o[t], u = a; u < s; u++) {
        var c = n[u] = r.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      i.ordinalMeta = r, i.ordinalOffset = s, i.type = "ordinal";
    }, e.prototype.getOrdinalMeta = function(t) {
      var r = this._dimensions[t], n = r.ordinalMeta;
      return n;
    }, e.prototype.getDimensionProperty = function(t) {
      var r = this._dimensions[t];
      return r && r.property;
    }, e.prototype.appendData = function(t) {
      process.env.NODE_ENV !== "production" && Qe(!this._indices, "appendData can only be called on raw data.");
      var r = this._provider, n = this.count();
      r.appendData(t);
      var i = r.count();
      return r.persistent || (i += n), n < i && this._initDataFromProvider(n, i, !0), [n, i];
    }, e.prototype.appendValues = function(t, r) {
      for (var n = this._chunks, i = this._dimensions, o = i.length, a = this._rawExtent, s = this.count(), l = s + Math.max(t.length, r || 0), u = 0; u < o; u++) {
        var c = i[u];
        iN(n, u, c.type, l, !0);
      }
      for (var d = [], h = s; h < l; h++)
        for (var f = h - s, p = 0; p < o; p++) {
          var c = i[p], g = s1.arrayRows.call(this, t[f] || d, c.property, f, p);
          n[p][h] = g;
          var v = a[p];
          g < v[0] && (v[0] = g), g > v[1] && (v[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, e.prototype._initDataFromProvider = function(t, r, n) {
      for (var i = this._provider, o = this._chunks, a = this._dimensions, s = a.length, l = this._rawExtent, u = ge(a, function(y) {
        return y.property;
      }), c = 0; c < s; c++) {
        var d = a[c];
        l[c] || (l[c] = Rd()), iN(o, c, d.type, r, n);
      }
      if (i.fillStorage)
        i.fillStorage(t, r, o, l);
      else
        for (var h = [], f = t; f < r; f++) {
          h = i.getItem(f, h);
          for (var p = 0; p < s; p++) {
            var g = o[p], v = this._dimValueGetter(h, u[p], f, p);
            g[f] = v;
            var m = l[p];
            v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      !i.persistent && i.clean && i.clean(), this._rawCount = this._count = r, this._extent = [];
    }, e.prototype.count = function() {
      return this._count;
    }, e.prototype.get = function(t, r) {
      if (!(r >= 0 && r < this._count))
        return NaN;
      var n = this._chunks[t];
      return n ? n[this.getRawIndex(r)] : NaN;
    }, e.prototype.getValues = function(t, r) {
      var n = [], i = [];
      if (r == null) {
        r = t, t = [];
        for (var o = 0; o < this._dimensions.length; o++)
          i.push(o);
      } else
        i = t;
      for (var o = 0, a = i.length; o < a; o++)
        n.push(this.get(i[o], r));
      return n;
    }, e.prototype.getByRawIndex = function(t, r) {
      if (!(r >= 0 && r < this._rawCount))
        return NaN;
      var n = this._chunks[t];
      return n ? n[r] : NaN;
    }, e.prototype.getSum = function(t) {
      var r = this._chunks[t], n = 0;
      if (r)
        for (var i = 0, o = this.count(); i < o; i++) {
          var a = this.get(t, i);
          isNaN(a) || (n += a);
        }
      return n;
    }, e.prototype.getMedian = function(t) {
      var r = [];
      this.each([t], function(o) {
        isNaN(o) || r.push(o);
      });
      var n = r.sort(function(o, a) {
        return o - a;
      }), i = this.count();
      return i === 0 ? 0 : i % 2 === 1 ? n[(i - 1) / 2] : (n[i / 2] + n[i / 2 - 1]) / 2;
    }, e.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0)
        return -1;
      if (!this._indices)
        return t;
      var r = this._indices, n = r[t];
      if (n != null && n < this._count && n === t)
        return t;
      for (var i = 0, o = this._count - 1; i <= o; ) {
        var a = (i + o) / 2 | 0;
        if (r[a] < t)
          i = a + 1;
        else if (r[a] > t)
          o = a - 1;
        else
          return a;
      }
      return -1;
    }, e.prototype.indicesOfNearest = function(t, r, n) {
      var i = this._chunks, o = i[t], a = [];
      if (!o)
        return a;
      n == null && (n = 1 / 0);
      for (var s = 1 / 0, l = -1, u = 0, c = 0, d = this.count(); c < d; c++) {
        var h = this.getRawIndex(c), f = r - o[h], p = Math.abs(f);
        p <= n && ((p < s || p === s && f >= 0 && l < 0) && (s = p, l = f, u = 0), f === l && (a[u++] = c));
      }
      return a.length = u, a;
    }, e.prototype.getIndices = function() {
      var t, r = this._indices;
      if (r) {
        var n = r.constructor, i = this._count;
        if (n === Array) {
          t = new n(i);
          for (var o = 0; o < i; o++)
            t[o] = r[o];
        } else
          t = new n(r.buffer, 0, i);
      } else {
        var n = Jf(this._rawCount);
        t = new n(this.count());
        for (var o = 0; o < t.length; o++)
          t[o] = o;
      }
      return t;
    }, e.prototype.filter = function(t, r) {
      if (!this._count)
        return this;
      for (var n = this.clone(), i = n.count(), o = Jf(n._rawCount), a = new o(i), s = [], l = t.length, u = 0, c = t[0], d = n._chunks, h = 0; h < i; h++) {
        var f = void 0, p = n.getRawIndex(h);
        if (l === 0)
          f = r(h);
        else if (l === 1) {
          var g = d[c][p];
          f = r(g, h);
        } else {
          for (var v = 0; v < l; v++)
            s[v] = d[t[v]][p];
          s[v] = h, f = r.apply(null, s);
        }
        f && (a[u++] = p);
      }
      return u < i && (n._indices = a), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, e.prototype.selectRange = function(t) {
      var r = this.clone(), n = r._count;
      if (!n)
        return this;
      var i = At(t), o = i.length;
      if (!o)
        return this;
      var a = r.count(), s = Jf(r._rawCount), l = new s(a), u = 0, c = i[0], d = t[c][0], h = t[c][1], f = r._chunks, p = !1;
      if (!r._indices) {
        var g = 0;
        if (o === 1) {
          for (var v = f[i[0]], m = 0; m < n; m++) {
            var y = v[m];
            (y >= d && y <= h || isNaN(y)) && (l[u++] = g), g++;
          }
          p = !0;
        } else if (o === 2) {
          for (var v = f[i[0]], C = f[i[1]], S = t[i[1]][0], b = t[i[1]][1], m = 0; m < n; m++) {
            var y = v[m], w = C[m];
            (y >= d && y <= h || isNaN(y)) && (w >= S && w <= b || isNaN(w)) && (l[u++] = g), g++;
          }
          p = !0;
        }
      }
      if (!p)
        if (o === 1)
          for (var m = 0; m < a; m++) {
            var x = r.getRawIndex(m), y = f[i[0]][x];
            (y >= d && y <= h || isNaN(y)) && (l[u++] = x);
          }
        else
          for (var m = 0; m < a; m++) {
            for (var E = !0, x = r.getRawIndex(m), R = 0; R < o; R++) {
              var _ = i[R], y = f[_][x];
              (y < t[_][0] || y > t[_][1]) && (E = !1);
            }
            E && (l[u++] = r.getRawIndex(m));
          }
      return u < a && (r._indices = l), r._count = u, r._extent = [], r._updateGetRawIdx(), r;
    }, e.prototype.map = function(t, r) {
      var n = this.clone(t);
      return this._updateDims(n, t, r), n;
    }, e.prototype.modify = function(t, r) {
      this._updateDims(this, t, r);
    }, e.prototype._updateDims = function(t, r, n) {
      for (var i = t._chunks, o = [], a = r.length, s = t.count(), l = [], u = t._rawExtent, c = 0; c < r.length; c++)
        u[r[c]] = Rd();
      for (var d = 0; d < s; d++) {
        for (var h = t.getRawIndex(d), f = 0; f < a; f++)
          l[f] = i[r[f]][h];
        l[a] = d;
        var p = n && n.apply(null, l);
        if (p != null) {
          typeof p != "object" && (o[0] = p, p = o);
          for (var c = 0; c < p.length; c++) {
            var g = r[c], v = p[c], m = u[g], y = i[g];
            y && (y[h] = v), v < m[0] && (m[0] = v), v > m[1] && (m[1] = v);
          }
        }
      }
    }, e.prototype.lttbDownSample = function(t, r) {
      var n = this.clone([t], !0), i = n._chunks, o = i[t], a = this.count(), s = 0, l = Math.floor(1 / r), u = this.getRawIndex(0), c, d, h, f = new (Jf(this._rawCount))(Math.min((Math.ceil(a / l) + 2) * 2, a));
      f[s++] = u;
      for (var p = 1; p < a - 1; p += l) {
        for (var g = Math.min(p + l, a - 1), v = Math.min(p + l * 2, a), m = (v + g) / 2, y = 0, C = g; C < v; C++) {
          var S = this.getRawIndex(C), b = o[S];
          isNaN(b) || (y += b);
        }
        y /= v - g;
        var w = p, x = Math.min(p + l, a), E = p - 1, R = o[u];
        c = -1, h = w;
        for (var _ = -1, P = 0, C = w; C < x; C++) {
          var S = this.getRawIndex(C), b = o[S];
          if (isNaN(b)) {
            P++, _ < 0 && (_ = S);
            continue;
          }
          d = Math.abs((E - m) * (b - R) - (E - C) * (y - R)), d > c && (c = d, h = S);
        }
        P > 0 && P < x - w && (f[s++] = Math.min(_, h), h = Math.max(_, h)), f[s++] = h, u = h;
      }
      return f[s++] = this.getRawIndex(a - 1), n._count = s, n._indices = f, n.getRawIndex = this._getRawIdx, n;
    }, e.prototype.downSample = function(t, r, n, i) {
      for (var o = this.clone([t], !0), a = o._chunks, s = [], l = Math.floor(1 / r), u = a[t], c = this.count(), d = o._rawExtent[t] = Rd(), h = new (Jf(this._rawCount))(Math.ceil(c / l)), f = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, s.length = l);
        for (var g = 0; g < l; g++) {
          var v = this.getRawIndex(p + g);
          s[g] = u[v];
        }
        var m = n(s), y = this.getRawIndex(Math.min(p + i(s, m) || 0, c - 1));
        u[y] = m, m < d[0] && (d[0] = m), m > d[1] && (d[1] = m), h[f++] = y;
      }
      return o._count = f, o._indices = h, o._updateGetRawIdx(), o;
    }, e.prototype.each = function(t, r) {
      if (this._count)
        for (var n = t.length, i = this._chunks, o = 0, a = this.count(); o < a; o++) {
          var s = this.getRawIndex(o);
          switch (n) {
            case 0:
              r(o);
              break;
            case 1:
              r(i[t[0]][s], o);
              break;
            case 2:
              r(i[t[0]][s], i[t[1]][s], o);
              break;
            default:
              for (var l = 0, u = []; l < n; l++)
                u[l] = i[t[l]][s];
              u[l] = o, r.apply(null, u);
          }
        }
    }, e.prototype.getDataExtent = function(t) {
      var r = this._chunks[t], n = Rd();
      if (!r)
        return n;
      var i = this.count(), o = !this._indices, a;
      if (o)
        return this._rawExtent[t].slice();
      if (a = this._extent[t], a)
        return a.slice();
      a = n;
      for (var s = a[0], l = a[1], u = 0; u < i; u++) {
        var c = this.getRawIndex(u), d = r[c];
        d < s && (s = d), d > l && (l = d);
      }
      return a = [s, l], this._extent[t] = a, a;
    }, e.prototype.getRawDataItem = function(t) {
      var r = this.getRawIndex(t);
      if (this._provider.persistent)
        return this._provider.getItem(r);
      for (var n = [], i = this._chunks, o = 0; o < i.length; o++)
        n.push(i[o][r]);
      return n;
    }, e.prototype.clone = function(t, r) {
      var n = new e(), i = this._chunks, o = t && Oo(t, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (o)
        for (var a = 0; a < i.length; a++)
          n._chunks[a] = o[a] ? $0e(i[a]) : i[a];
      else
        n._chunks = i;
      return this._copyCommonProps(n), r || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, e.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = et(this._extent), t._rawExtent = et(this._rawExtent);
    }, e.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, r = void 0;
        if (t === Array) {
          var n = this._indices.length;
          r = new t(n);
          for (var i = 0; i < n; i++)
            r[i] = this._indices[i];
        } else
          r = new t(this._indices);
        return r;
      }
      return null;
    }, e.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, e.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, e.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, e.internalField = function() {
      function t(r, n, i, o) {
        return Ol(r[o], this._dimensions[o]);
      }
      s1 = {
        arrayRows: t,
        objectRows: function(r, n, i, o) {
          return Ol(r[n], this._dimensions[o]);
        },
        keyedColumns: t,
        original: function(r, n, i, o) {
          var a = r && (r.value == null ? r : r.value);
          return Ol(a instanceof Array ? a[o] : a, this._dimensions[o]);
        },
        typedArray: function(r, n, i, o) {
          return r[o];
        }
      };
    }(), e;
  }()
), yW = (
  /** @class */
  function() {
    function e(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
    }
    return e.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, e.prototype._setLocalSource = function(t, r) {
      this._sourceList = t, this._upstreamSignList = r, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, e.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, e.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, e.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, r = this._getUpstreamSourceManagers(), n = !!r.length, i, o;
      if (ep(t)) {
        var a = t, s = void 0, l = void 0, u = void 0;
        if (n) {
          var c = r[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, o = [c._getVersionSign()];
        } else
          s = a.get("data", !0), l = ei(s) ? As : zo, o = [];
        var d = this._getSourceMetaRawOption() || {}, h = u && u.metaRawOption || {}, f = st(d.seriesLayoutBy, h.seriesLayoutBy) || null, p = st(d.sourceHeader, h.sourceHeader), g = st(d.dimensions, h.dimensions), v = f !== h.seriesLayoutBy || !!p != !!h.sourceHeader || g;
        i = v ? [f_(s, {
          seriesLayoutBy: f,
          sourceHeader: p,
          dimensions: g
        }, l)] : [];
      } else {
        var m = t;
        if (n) {
          var y = this._applyTransform(r);
          i = y.sourceList, o = y.upstreamSignList;
        } else {
          var C = m.get("source", !0);
          i = [f_(C, this._getSourceMetaRawOption(), null)], o = [];
        }
      }
      process.env.NODE_ENV !== "production" && Qe(i && o), this._setLocalSource(i, o);
    }, e.prototype._applyTransform = function(t) {
      var r = this._sourceHost, n = r.get("transform", !0), i = r.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && Qe(i != null || n != null), i != null) {
        var o = "";
        t.length !== 1 && (process.env.NODE_ENV !== "production" && (o = "When using `fromTransformResult`, there should be only one upstream dataset"), aN(o));
      }
      var a, s = [], l = [];
      return B(t, function(u) {
        u.prepareSource();
        var c = u.getSource(i || 0), d = "";
        i != null && !c && (process.env.NODE_ENV !== "production" && (d = "Can not retrieve result by `fromTransformResult`: " + i), aN(d)), s.push(c), l.push(u._getVersionSign());
      }), n ? a = B0e(n, s, {
        datasetIndex: r.componentIndex
      }) : i != null && (a = [S0e(s[0])]), {
        sourceList: a,
        upstreamSignList: l
      };
    }, e.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var t = this._getUpstreamSourceManagers(), r = 0; r < t.length; r++) {
        var n = t[r];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          n._isDirty() || this._upstreamSignList[r] !== n._getVersionSign()
        )
          return !0;
      }
    }, e.prototype.getSource = function(t) {
      t = t || 0;
      var r = this._sourceList[t];
      if (!r) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(t);
      }
      return r;
    }, e.prototype.getSharedDataStore = function(t) {
      process.env.NODE_ENV !== "production" && Qe(ep(this._sourceHost), "Can only call getDataStore on series source manager.");
      var r = t.makeStoreSchema();
      return this._innerGetDataStore(r.dimensions, t.source, r.hash);
    }, e.prototype._innerGetDataStore = function(t, r, n) {
      var i = 0, o = this._storeList, a = o[i];
      a || (a = o[i] = {});
      var s = a[n];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        ep(this._sourceHost) && l ? s = l._innerGetDataStore(t, r, n) : (s = new p_(), s.initData(new lW(r, t.length), t)), a[n] = s;
      }
      return s;
    }, e.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (ep(t)) {
        var r = NM(t);
        return r ? [r.getSourceManager()] : [];
      } else
        return ge(Kye(t), function(n) {
          return n.getSourceManager();
        });
    }, e.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, r, n, i;
      if (ep(t))
        r = t.get("seriesLayoutBy", !0), n = t.get("sourceHeader", !0), i = t.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var o = t;
        r = o.get("seriesLayoutBy", !0), n = o.get("sourceHeader", !0), i = o.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: r,
        sourceHeader: n,
        dimensions: i
      };
    }, e;
  }()
);
function oN(e) {
  var t = e.option.transform;
  t && Mg(e.option.transform);
}
function ep(e) {
  return e.mainType === "series";
}
function aN(e) {
  throw new Error(e);
}
var CW = "line-height:1";
function SW(e, t) {
  var r = e.color || "#6e7079", n = e.fontSize || 12, i = e.fontWeight || "400", o = e.color || "#464646", a = e.fontSize || 14, s = e.fontWeight || "900";
  return t === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + fi(n + "") + "px;color:" + fi(r) + ";font-weight:" + fi(i + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + fi(a + "") + "px;color:" + fi(o) + ";font-weight:" + fi(s + "")
  } : {
    nameStyle: {
      fontSize: n,
      fill: r,
      fontWeight: i
    },
    valueStyle: {
      fontSize: a,
      fill: o,
      fontWeight: s
    }
  };
}
var W0e = [0, 10, 20, 30], j0e = ["", `
`, `

`, `


`];
function _n(e, t) {
  return t.type = e, t;
}
function g_(e) {
  return e.type === "section";
}
function wW(e) {
  return g_(e) ? U0e : K0e;
}
function bW(e) {
  if (g_(e)) {
    var t = 0, r = e.blocks.length, n = r > 1 || r > 0 && !e.noHeader;
    return B(e.blocks, function(i) {
      var o = bW(i);
      o >= t && (t = o + +(n && // 0 always can not be readable gap level.
      (!o || g_(i) && !i.noHeader)));
    }), t;
  }
  return 0;
}
function U0e(e, t, r, n) {
  var i = t.noHeader, o = Y0e(bW(t)), a = [], s = t.blocks || [];
  Qe(!s || fe(s)), s = s || [];
  var l = e.orderMode;
  if (t.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (Be(u, l)) {
      var c = new pW(u[l], null);
      s.sort(function(p, g) {
        return c.evaluate(p.sortParam, g.sortParam);
      });
    } else l === "seriesDesc" && s.reverse();
  }
  B(s, function(p, g) {
    var v = t.valueFormatter, m = wW(p)(
      // Inherit valueFormatter
      v ? se(se({}, e), {
        valueFormatter: v
      }) : e,
      p,
      g > 0 ? o.html : 0,
      n
    );
    m != null && a.push(m);
  });
  var d = e.renderMode === "richText" ? a.join(o.richText) : v_(a.join(""), i ? r : o.html);
  if (i)
    return d;
  var h = u_(t.header, "ordinal", e.useUTC), f = SW(n, e.renderMode).nameStyle;
  return e.renderMode === "richText" ? xW(e, h, f) + o.richText + d : v_('<div style="' + f + ";" + CW + ';">' + fi(h) + "</div>" + d, r);
}
function K0e(e, t, r, n) {
  var i = e.renderMode, o = t.noName, a = t.noValue, s = !t.markerType, l = t.name, u = e.useUTC, c = t.valueFormatter || e.valueFormatter || function(S) {
    return S = fe(S) ? S : [S], ge(S, function(b, w) {
      return u_(b, fe(f) ? f[w] : f, u);
    });
  };
  if (!(o && a)) {
    var d = s ? "" : e.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || "#333", i), h = o ? "" : u_(l, "ordinal", u), f = t.valueType, p = a ? [] : c(t.value, t.dataIndex), g = !s || !o, v = !s && o, m = SW(n, i), y = m.nameStyle, C = m.valueStyle;
    return i === "richText" ? (s ? "" : d) + (o ? "" : xW(e, h, y)) + (a ? "" : X0e(e, p, g, v, C)) : v_((s ? "" : d) + (o ? "" : q0e(h, !s, y)) + (a ? "" : Z0e(p, g, v, C)), r);
  }
}
function sN(e, t, r, n, i, o) {
  if (e) {
    var a = wW(e), s = {
      useUTC: i,
      renderMode: r,
      orderMode: n,
      markupStyleCreator: t,
      valueFormatter: e.valueFormatter
    };
    return a(s, e, 0, o);
  }
}
function Y0e(e) {
  return {
    html: W0e[e],
    richText: j0e[e]
  };
}
function v_(e, t) {
  var r = '<div style="clear:both"></div>', n = "margin: " + t + "px 0 0";
  return '<div style="' + n + ";" + CW + ';">' + e + r + "</div>";
}
function q0e(e, t, r) {
  var n = t ? "margin-left:2px" : "";
  return '<span style="' + r + ";" + n + '">' + fi(e) + "</span>";
}
function Z0e(e, t, r, n) {
  var i = r ? "10px" : "20px", o = t ? "float:right;margin-left:" + i : "";
  return e = fe(e) ? e : [e], '<span style="' + o + ";" + n + '">' + ge(e, function(a) {
    return fi(a);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function xW(e, t, r) {
  return e.markupStyleCreator.wrapRichTextStyle(t, r);
}
function X0e(e, t, r, n, i) {
  var o = [i], a = n ? 10 : 20;
  return r && o.push({
    padding: [0, 0, 0, a],
    align: "right"
  }), e.markupStyleCreator.wrapRichTextStyle(fe(t) ? t.join("  ") : t, o);
}
function EW(e, t) {
  var r = e.getData().getItemVisual(t, "style"), n = r[e.visualDrawType];
  return Ac(n);
}
function RW(e, t) {
  var r = e.get("padding");
  return r ?? (t === "richText" ? [8, 10] : 10);
}
var l1 = (
  /** @class */
  function() {
    function e() {
      this.richTextStyles = {}, this._nextStyleNameId = A$();
    }
    return e.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, e.prototype.makeTooltipMarker = function(t, r, n) {
      var i = n === "richText" ? this._generateStyleName() : null, o = K6({
        color: r,
        type: t,
        renderMode: n,
        markerId: i
      });
      return Fe(o) ? o : (process.env.NODE_ENV !== "production" && Qe(i), this.richTextStyles[i] = o.style, o.content);
    }, e.prototype.wrapRichTextStyle = function(t, r) {
      var n = {};
      fe(r) ? B(r, function(o) {
        return se(n, o);
      }) : se(n, r);
      var i = this._generateStyleName();
      return this.richTextStyles[i] = n, "{" + i + "|" + t + "}";
    }, e;
  }()
);
function _W(e) {
  var t = e.series, r = e.dataIndex, n = e.multipleSeries, i = t.getData(), o = i.mapDimensionsAll("defaultedTooltip"), a = o.length, s = t.getRawValue(r), l = fe(s), u = EW(t, r), c, d, h, f;
  if (a > 1 || l && !a) {
    var p = Q0e(s, t, r, o, u);
    c = p.inlineValues, d = p.inlineValueTypes, h = p.blocks, f = p.inlineValues[0];
  } else if (a) {
    var g = i.getDimensionInfo(o[0]);
    f = c = Oh(i, r, o[0]), d = g.type;
  } else
    f = c = l ? s[0] : s;
  var v = lM(t), m = v && t.name || "", y = i.getName(r), C = n ? m : y;
  return _n("section", {
    header: m,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: n || !v,
    sortParam: f,
    blocks: [_n("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: C,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !_o(C),
      value: c,
      valueType: d,
      dataIndex: r
    })].concat(h || [])
  });
}
function Q0e(e, t, r, n, i) {
  var o = t.getData(), a = Oo(e, function(d, h, f) {
    var p = o.getDimensionInfo(f);
    return d = d || p && p.tooltip !== !1 && p.displayName != null;
  }, !1), s = [], l = [], u = [];
  n.length ? B(n, function(d) {
    c(Oh(o, r, d), d);
  }) : B(e, c);
  function c(d, h) {
    var f = o.getDimensionInfo(h);
    !f || f.otherDims.tooltip === !1 || (a ? u.push(_n("nameValue", {
      markerType: "subItem",
      markerColor: i,
      name: f.displayName,
      value: d,
      valueType: f.type
    })) : (s.push(d), l.push(f.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var cl = Gt();
function $m(e, t) {
  return e.getName(t) || e.getId(t);
}
var a0 = "__universalTransitionEnabled", hr = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r._selectedDataIndicesMap = {}, r;
    }
    return t.prototype.init = function(r, n, i) {
      this.seriesIndex = this.componentIndex, this.dataTask = ig({
        count: eCe,
        reset: tCe
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(r, i);
      var o = cl(this).sourceManager = new yW(this);
      o.prepareSource();
      var a = this.getInitialData(r, i);
      uN(a, this), this.dataTask.context.data = a, process.env.NODE_ENV !== "production" && Qe(a, "getInitialData returned invalid data."), cl(this).dataBeforeProcessed = a, lN(this), this._initSelectedMapFromData(a);
    }, t.prototype.mergeDefaultAndTheme = function(r, n) {
      var i = Gg(this), o = i ? hf(r) : {}, a = this.subType;
      Rt.hasClass(a) && (a += "Series"), yt(r, n.getTheme().get(this.subType)), yt(r, this.getDefaultOption()), Tc(r, "label", ["show"]), this.fillDataTextStyle(r.data), i && Kl(r, o, i);
    }, t.prototype.mergeOption = function(r, n) {
      r = yt(this.option, r, !0), this.fillDataTextStyle(r.data);
      var i = Gg(this);
      i && Kl(this.option, r, i);
      var o = cl(this).sourceManager;
      o.dirty(), o.prepareSource();
      var a = this.getInitialData(r, n);
      uN(a, this), this.dataTask.dirty(), this.dataTask.context.data = a, cl(this).dataBeforeProcessed = a, lN(this), this._initSelectedMapFromData(a);
    }, t.prototype.fillDataTextStyle = function(r) {
      if (r && !ei(r))
        for (var n = ["show"], i = 0; i < r.length; i++)
          r[i] && r[i].label && Tc(r[i], "label", n);
    }, t.prototype.getInitialData = function(r, n) {
    }, t.prototype.appendData = function(r) {
      var n = this.getRawData();
      n.appendData(r.data);
    }, t.prototype.getData = function(r) {
      var n = m_(this);
      if (n) {
        var i = n.context.data;
        return r == null || !i.getLinkedData ? i : i.getLinkedData(r);
      } else
        return cl(this).data;
    }, t.prototype.getAllData = function() {
      var r = this.getData();
      return r && r.getLinkedDataAll ? r.getLinkedDataAll() : [{
        data: r
      }];
    }, t.prototype.setData = function(r) {
      var n = m_(this);
      if (n) {
        var i = n.context;
        i.outputData = r, n !== this.dataTask && (i.data = r);
      }
      cl(this).data = r;
    }, t.prototype.getEncode = function() {
      var r = this.get("encode", !0);
      if (r)
        return We(r);
    }, t.prototype.getSourceManager = function() {
      return cl(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return cl(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var r = this.get("colorBy");
      return r || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var r = this.coordinateSystem;
      return r && r.getBaseAxis && r.getBaseAxis();
    }, t.prototype.formatTooltip = function(r, n, i) {
      return _W({
        series: this,
        dataIndex: r,
        multipleSeries: n
      });
    }, t.prototype.isAnimationEnabled = function() {
      var r = this.ecModel;
      if (kt.node && !(r && r.ssr))
        return !1;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(r, n, i) {
      var o = this.ecModel, a = kM.prototype.getColorFromPalette.call(this, r, n, i);
      return a || (a = o.getColorFromPalette(r, n, i)), a;
    }, t.prototype.coordDimToDataDim = function(r) {
      return this.getRawData().mapDimensionsAll(r);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(r, n) {
      this._innerSelect(this.getData(n), r);
    }, t.prototype.unselect = function(r, n) {
      var i = this.option.selectedMap;
      if (i) {
        var o = this.option.selectedMode, a = this.getData(n);
        if (o === "series" || i === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < r.length; s++) {
          var l = r[s], u = $m(a, l);
          i[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(r, n) {
      for (var i = [], o = 0; o < r.length; o++)
        i[0] = r[o], this.isSelected(r[o], n) ? this.unselect(i, n) : this.select(i, n);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var r = this._selectedDataIndicesMap, n = At(r), i = [], o = 0; o < n.length; o++) {
        var a = r[n[o]];
        a >= 0 && i.push(a);
      }
      return i;
    }, t.prototype.isSelected = function(r, n) {
      var i = this.option.selectedMap;
      if (!i)
        return !1;
      var o = this.getData(n);
      return (i === "all" || i[$m(o, r)]) && !o.getItemModel(r).get(["select", "disabled"]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[a0])
        return !0;
      var r = this.option.universalTransition;
      return r ? r === !0 ? !0 : r && r.enabled : !1;
    }, t.prototype._innerSelect = function(r, n) {
      var i, o, a = this.option, s = a.selectedMode, l = n.length;
      if (!(!s || !l)) {
        if (s === "series")
          a.selectedMap = "all";
        else if (s === "multiple") {
          Ze(a.selectedMap) || (a.selectedMap = {});
          for (var u = a.selectedMap, c = 0; c < l; c++) {
            var d = n[c], h = $m(r, d);
            u[h] = !0, this._selectedDataIndicesMap[h] = r.getRawIndex(d);
          }
        } else if (s === "single" || s === !0) {
          var f = n[l - 1], h = $m(r, f);
          a.selectedMap = (i = {}, i[h] = !0, i), this._selectedDataIndicesMap = (o = {}, o[h] = r.getRawIndex(f), o);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(r) {
      if (!this.option.selectedMap) {
        var n = [];
        r.hasItemOption && r.each(function(i) {
          var o = r.getRawDataItem(i);
          o && o.selected && n.push(i);
        }), n.length > 0 && this._innerSelect(r, n);
      }
    }, t.registerClass = function(r) {
      return Rt.registerClass(r);
    }, t.protoInitialize = function() {
      var r = t.prototype;
      r.type = "series.__base__", r.seriesIndex = 0, r.ignoreStyleOnData = !1, r.hasSymbolVisual = !1, r.defaultSymbol = "circle", r.visualStyleAccessPath = "itemStyle", r.visualDrawType = "fill";
    }(), t;
  }(Rt)
);
qr(hr, qS);
qr(hr, kM);
G$(hr, Rt);
function lN(e) {
  var t = e.name;
  lM(e) || (e.name = J0e(e) || t);
}
function J0e(e) {
  var t = e.getRawData(), r = t.mapDimensionsAll("seriesName"), n = [];
  return B(r, function(i) {
    var o = t.getDimensionInfo(i);
    o.displayName && n.push(o.displayName);
  }), n.join(" ");
}
function eCe(e) {
  return e.model.getRawData().count();
}
function tCe(e) {
  var t = e.model;
  return t.setData(t.getRawData().cloneShallow()), rCe;
}
function rCe(e, t) {
  t.outputData && e.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
}
function uN(e, t) {
  B(Dg(e.CHANGABLE_METHODS, e.DOWNSAMPLE_METHODS), function(r) {
    e.wrapMethod(r, dt(nCe, t));
  });
}
function nCe(e, t) {
  var r = m_(e);
  return r && r.setOutputEnd((t || this).count()), t;
}
function m_(e) {
  var t = (e.ecModel || {}).scheduler, r = t && t.getPipeline(e.uid);
  if (r) {
    var n = r.currentTask;
    if (n) {
      var i = n.agentStubMap;
      i && (n = i.get(e.uid));
    }
    return n;
  }
}
var Rr = (
  /** @class */
  function() {
    function e() {
      this.group = new it(), this.uid = df("viewComponent");
    }
    return e.prototype.init = function(t, r) {
    }, e.prototype.render = function(t, r, n, i) {
    }, e.prototype.dispose = function(t, r) {
    }, e.prototype.updateView = function(t, r, n, i) {
    }, e.prototype.updateLayout = function(t, r, n, i) {
    }, e.prototype.updateVisual = function(t, r, n, i) {
    }, e.prototype.toggleBlurSeries = function(t, r, n) {
    }, e.prototype.eachRendered = function(t) {
      var r = this.group;
      r && r.traverse(t);
    }, e;
  }()
);
cM(Rr);
AS(Rr);
function pf() {
  var e = Gt();
  return function(t) {
    var r = e(t), n = t.pipelineContext, i = !!r.large, o = !!r.progressiveRender, a = r.large = !!(n && n.large), s = r.progressiveRender = !!(n && n.progressiveRender);
    return (i !== a || o !== s) && "reset";
  };
}
var TW = Gt(), iCe = pf(), ar = (
  /** @class */
  function() {
    function e() {
      this.group = new it(), this.uid = df("viewChart"), this.renderTask = ig({
        plan: oCe,
        reset: aCe
      }), this.renderTask.context = {
        view: this
      };
    }
    return e.prototype.init = function(t, r) {
    }, e.prototype.render = function(t, r, n, i) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, e.prototype.highlight = function(t, r, n, i) {
      var o = t.getData(i && i.dataType);
      if (!o) {
        process.env.NODE_ENV !== "production" && Vn("Unknown dataType " + i.dataType);
        return;
      }
      dN(o, i, "emphasis");
    }, e.prototype.downplay = function(t, r, n, i) {
      var o = t.getData(i && i.dataType);
      if (!o) {
        process.env.NODE_ENV !== "production" && Vn("Unknown dataType " + i.dataType);
        return;
      }
      dN(o, i, "normal");
    }, e.prototype.remove = function(t, r) {
      this.group.removeAll();
    }, e.prototype.dispose = function(t, r) {
    }, e.prototype.updateView = function(t, r, n, i) {
      this.render(t, r, n, i);
    }, e.prototype.updateLayout = function(t, r, n, i) {
      this.render(t, r, n, i);
    }, e.prototype.updateVisual = function(t, r, n, i) {
      this.render(t, r, n, i);
    }, e.prototype.eachRendered = function(t) {
      iu(this.group, t);
    }, e.markUpdateMethod = function(t, r) {
      TW(t).updateMethod = r;
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "chart";
    }(), e;
  }()
);
function cN(e, t, r) {
  e && jl(e) && (t === "emphasis" ? zs : $s)(e, r);
}
function dN(e, t, r) {
  var n = Pc(e, t), i = t && t.highlightKey != null ? kme(t.highlightKey) : null;
  n != null ? B(dr(n), function(o) {
    cN(e.getItemGraphicEl(o), r, i);
  }) : e.eachItemGraphicEl(function(o) {
    cN(o, r, i);
  });
}
cM(ar, ["dispose"]);
AS(ar);
function oCe(e) {
  return iCe(e.model);
}
function aCe(e) {
  var t = e.model, r = e.ecModel, n = e.api, i = e.payload, o = t.pipelineContext.progressiveRender, a = e.view, s = i && TW(i).updateMethod, l = o ? "incrementalPrepareRender" : s && a[s] ? s : "render";
  return l !== "render" && a[l](t, r, n, i), sCe[l];
}
var sCe = {
  incrementalPrepareRender: {
    progress: function(e, t) {
      t.view.incrementalRender(e, t.model, t.ecModel, t.api, t.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(e, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload);
    }
  }
}, nC = "\0__throttleOriginMethod", hN = "\0__throttleRate", fN = "\0__throttleType";
function XS(e, t, r) {
  var n, i = 0, o = 0, a = null, s, l, u, c;
  t = t || 0;
  function d() {
    o = (/* @__PURE__ */ new Date()).getTime(), a = null, e.apply(l, u || []);
  }
  var h = function() {
    for (var f = [], p = 0; p < arguments.length; p++)
      f[p] = arguments[p];
    n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = f;
    var g = c || t, v = c || r;
    c = null, s = n - (v ? i : o) - g, clearTimeout(a), v ? a = setTimeout(d, g) : s >= 0 ? d() : a = setTimeout(d, -s), i = n;
  };
  return h.clear = function() {
    a && (clearTimeout(a), a = null);
  }, h.debounceNextCall = function(f) {
    c = f;
  }, h;
}
function gf(e, t, r, n) {
  var i = e[t];
  if (i) {
    var o = i[nC] || i, a = i[fN], s = i[hN];
    if (s !== r || a !== n) {
      if (r == null || !n)
        return e[t] = o;
      i = e[t] = XS(o, r, n === "debounce"), i[nC] = o, i[fN] = n, i[hN] = r;
    }
    return i;
  }
}
function zg(e, t) {
  var r = e[t];
  r && r[nC] && (r.clear && r.clear(), e[t] = r[nC]);
}
var pN = Gt(), gN = {
  itemStyle: Mc(k6, !0),
  lineStyle: Mc(N6, !0)
}, lCe = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function PW(e, t) {
  var r = e.visualStyleMapper || gN[t];
  return r || (console.warn("Unknown style type '" + t + "'."), gN.itemStyle);
}
function MW(e, t) {
  var r = e.visualDrawType || lCe[t];
  return r || (console.warn("Unknown style type '" + t + "'."), "fill");
}
var uCe = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    var r = e.getData(), n = e.visualStyleAccessPath || "itemStyle", i = e.getModel(n), o = PW(e, n), a = o(i), s = i.getShallow("decal");
    s && (r.setVisual("decal", s), s.dirty = !0);
    var l = MW(e, n), u = a[l], c = Ye(u) ? u : null, d = a.fill === "auto" || a.stroke === "auto";
    if (!a[l] || c || d) {
      var h = e.getColorFromPalette(
        // TODO series count changed.
        e.name,
        null,
        t.getSeriesCount()
      );
      a[l] || (a[l] = h, r.setVisual("colorFromPalette", !0)), a.fill = a.fill === "auto" || Ye(a.fill) ? h : a.fill, a.stroke = a.stroke === "auto" || Ye(a.stroke) ? h : a.stroke;
    }
    if (r.setVisual("style", a), r.setVisual("drawType", l), !t.isSeriesFiltered(e) && c)
      return r.setVisual("colorFromPalette", !1), {
        dataEach: function(f, p) {
          var g = e.getDataParams(p), v = se({}, a);
          v[l] = c(g), f.setItemVisual(p, "style", v);
        }
      };
  }
}, tp = new cr(), cCe = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    if (!(e.ignoreStyleOnData || t.isSeriesFiltered(e))) {
      var r = e.getData(), n = e.visualStyleAccessPath || "itemStyle", i = PW(e, n), o = r.getVisual("drawType");
      return {
        dataEach: r.hasItemOption ? function(a, s) {
          var l = a.getRawDataItem(s);
          if (l && l[n]) {
            tp.option = l[n];
            var u = i(tp), c = a.ensureUniqueItemVisual(s, "style");
            se(c, u), tp.option.decal && (a.setItemVisual(s, "decal", tp.option.decal), tp.option.decal.dirty = !0), o in u && a.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, dCe = {
  performRawSeries: !0,
  overallReset: function(e) {
    var t = We();
    e.eachSeries(function(r) {
      var n = r.getColorBy();
      if (!r.isColorBySeries()) {
        var i = r.type + "-" + n, o = t.get(i);
        o || (o = {}, t.set(i, o)), pN(r).scope = o;
      }
    }), e.eachSeries(function(r) {
      if (!(r.isColorBySeries() || e.isSeriesFiltered(r))) {
        var n = r.getRawData(), i = {}, o = r.getData(), a = pN(r).scope, s = r.visualStyleAccessPath || "itemStyle", l = MW(r, s);
        o.each(function(u) {
          var c = o.getRawIndex(u);
          i[c] = u;
        }), n.each(function(u) {
          var c = i[u], d = o.getItemVisual(c, "colorFromPalette");
          if (d) {
            var h = o.ensureUniqueItemVisual(c, "style"), f = n.getName(u) || u + "", p = n.count();
            h[l] = r.getColorFromPalette(f, a, p);
          }
        });
      }
    });
  }
}, Wm = Math.PI;
function hCe(e, t) {
  t = t || {}, Xe(t, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: !0,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var r = new it(), n = new Bt({
    style: {
      fill: t.maskColor
    },
    zlevel: t.zlevel,
    z: 1e4
  });
  r.add(n);
  var i = new Vt({
    style: {
      text: t.text,
      fill: t.textColor,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      fontStyle: t.fontStyle,
      fontFamily: t.fontFamily
    },
    zlevel: t.zlevel,
    z: 10001
  }), o = new Bt({
    style: {
      fill: "none"
    },
    textContent: i,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: t.zlevel,
    z: 10001
  });
  r.add(o);
  var a;
  return t.showSpinner && (a = new VS({
    shape: {
      startAngle: -Wm / 2,
      endAngle: -Wm / 2 + 0.1,
      r: t.spinnerRadius
    },
    style: {
      stroke: t.color,
      lineCap: "round",
      lineWidth: t.lineWidth
    },
    zlevel: t.zlevel,
    z: 10001
  }), a.animateShape(!0).when(1e3, {
    endAngle: Wm * 3 / 2
  }).start("circularInOut"), a.animateShape(!0).when(1e3, {
    startAngle: Wm * 3 / 2
  }).delay(300).start("circularInOut"), r.add(a)), r.resize = function() {
    var s = i.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (e.getWidth() - l * 2 - (t.showSpinner && s ? 10 : 0) - s) / 2 - (t.showSpinner && s ? 0 : 5 + s / 2) + (t.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = e.getHeight() / 2;
    t.showSpinner && a.setShape({
      cx: u,
      cy: c
    }), o.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), n.setShape({
      x: 0,
      y: 0,
      width: e.getWidth(),
      height: e.getHeight()
    });
  }, r.resize(), r;
}
var DW = (
  /** @class */
  function() {
    function e(t, r, n, i) {
      this._stageTaskMap = We(), this.ecInstance = t, this.api = r, n = this._dataProcessorHandlers = n.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = n.concat(i);
    }
    return e.prototype.restoreData = function(t, r) {
      t.restoreData(r), this._stageTaskMap.each(function(n) {
        var i = n.overallTask;
        i && i.dirty();
      });
    }, e.prototype.getPerformArgs = function(t, r) {
      if (t.__pipeline) {
        var n = this._pipelineMap.get(t.__pipeline.id), i = n.context, o = !r && n.progressiveEnabled && (!i || i.progressiveRender) && t.__idxInPipeline > n.blockIndex, a = o ? n.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / a) : null;
        return {
          step: a,
          modBy: l,
          modDataCount: s
        };
      }
    }, e.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, e.prototype.updateStreamModes = function(t, r) {
      var n = this._pipelineMap.get(t.uid), i = t.getData(), o = i.count(), a = n.progressiveEnabled && r.incrementalPrepareRender && o >= n.threshold, s = t.get("large") && o >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? o : null;
      t.pipelineContext = n.context = {
        progressiveRender: a,
        modDataCount: l,
        large: s
      };
    }, e.prototype.restorePipelines = function(t) {
      var r = this, n = r._pipelineMap = We();
      t.eachSeries(function(i) {
        var o = i.getProgressive(), a = i.uid;
        n.set(a, {
          id: a,
          head: null,
          tail: null,
          threshold: i.getProgressiveThreshold(),
          progressiveEnabled: o && !(i.preventIncremental && i.preventIncremental()),
          blockIndex: -1,
          step: Math.round(o || 700),
          count: 0
        }), r._pipe(i, i.dataTask);
      });
    }, e.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, r = this.api.getModel(), n = this.api;
      B(this._allHandlers, function(i) {
        var o = t.get(i.uid) || t.set(i.uid, {}), a = "";
        process.env.NODE_ENV !== "production" && (a = '"reset" and "overallReset" must not be both specified.'), Qe(!(i.reset && i.overallReset), a), i.reset && this._createSeriesStageTask(i, o, r, n), i.overallReset && this._createOverallStageTask(i, o, r, n);
      }, this);
    }, e.prototype.prepareView = function(t, r, n, i) {
      var o = t.renderTask, a = o.context;
      a.model = r, a.ecModel = n, a.api = i, o.__block = !t.incrementalPrepareRender, this._pipe(r, o);
    }, e.prototype.performDataProcessorTasks = function(t, r) {
      this._performStageTasks(this._dataProcessorHandlers, t, r, {
        block: !0
      });
    }, e.prototype.performVisualTasks = function(t, r, n) {
      this._performStageTasks(this._visualHandlers, t, r, n);
    }, e.prototype._performStageTasks = function(t, r, n, i) {
      i = i || {};
      var o = !1, a = this;
      B(t, function(l, u) {
        if (!(i.visualType && i.visualType !== l.visualType)) {
          var c = a._stageTaskMap.get(l.uid), d = c.seriesTaskMap, h = c.overallTask;
          if (h) {
            var f, p = h.agentStubMap;
            p.each(function(v) {
              s(i, v) && (v.dirty(), f = !0);
            }), f && h.dirty(), a.updatePayload(h, n);
            var g = a.getPerformArgs(h, i.block);
            p.each(function(v) {
              v.perform(g);
            }), h.perform(g) && (o = !0);
          } else d && d.each(function(v, m) {
            s(i, v) && v.dirty();
            var y = a.getPerformArgs(v, i.block);
            y.skip = !l.performRawSeries && r.isSeriesFiltered(v.context.model), a.updatePayload(v, n), v.perform(y) && (o = !0);
          });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = o || this.unfinished;
    }, e.prototype.performSeriesTasks = function(t) {
      var r;
      t.eachSeries(function(n) {
        r = n.dataTask.perform() || r;
      }), this.unfinished = r || this.unfinished;
    }, e.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var r = t.tail;
        do {
          if (r.__block) {
            t.blockIndex = r.__idxInPipeline;
            break;
          }
          r = r.getUpstream();
        } while (r);
      });
    }, e.prototype.updatePayload = function(t, r) {
      r !== "remain" && (t.context.payload = r);
    }, e.prototype._createSeriesStageTask = function(t, r, n, i) {
      var o = this, a = r.seriesTaskMap, s = r.seriesTaskMap = We(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, i).each(c);
      function c(d) {
        var h = d.uid, f = s.set(h, a && a.get(h) || ig({
          plan: mCe,
          reset: yCe,
          count: SCe
        }));
        f.context = {
          model: d,
          ecModel: n,
          api: i,
          // PENDING: `useClearVisual` not used?
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: o
        }, o._pipe(d, f);
      }
    }, e.prototype._createOverallStageTask = function(t, r, n, i) {
      var o = this, a = r.overallTask = r.overallTask || ig({
        reset: fCe
      });
      a.context = {
        ecModel: n,
        api: i,
        overallReset: t.overallReset,
        scheduler: o
      };
      var s = a.agentStubMap, l = a.agentStubMap = We(), u = t.seriesType, c = t.getTargetSeries, d = !0, h = !1, f = "";
      process.env.NODE_ENV !== "production" && (f = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), Qe(!t.createOnAllSeries, f), u ? n.eachRawSeriesByType(u, p) : c ? c(n, i).each(p) : (d = !1, B(n.getSeries(), p));
      function p(g) {
        var v = g.uid, m = l.set(v, s && s.get(v) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (h = !0, ig({
          reset: pCe,
          onDirty: vCe
        })));
        m.context = {
          model: g,
          overallProgress: d
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, m.agent = a, m.__block = d, o._pipe(g, m);
      }
      h && a.dirty();
    }, e.prototype._pipe = function(t, r) {
      var n = t.uid, i = this._pipelineMap.get(n);
      !i.head && (i.head = r), i.tail && i.tail.pipe(r), i.tail = r, r.__idxInPipeline = i.count++, r.__pipeline = i;
    }, e.wrapStageHandler = function(t, r) {
      return Ye(t) && (t = {
        overallReset: t,
        seriesType: wCe(t)
      }), t.uid = df("stageHandler"), r && (t.visualType = r), t;
    }, e;
  }()
);
function fCe(e) {
  e.overallReset(e.ecModel, e.api, e.payload);
}
function pCe(e) {
  return e.overallProgress && gCe;
}
function gCe() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function vCe() {
  this.agent && this.agent.dirty();
}
function mCe(e) {
  return e.plan ? e.plan(e.model, e.ecModel, e.api, e.payload) : null;
}
function yCe(e) {
  e.useClearVisual && e.data.clearAllVisual();
  var t = e.resetDefines = dr(e.reset(e.model, e.ecModel, e.api, e.payload));
  return t.length > 1 ? ge(t, function(r, n) {
    return AW(n);
  }) : CCe;
}
var CCe = AW(0);
function AW(e) {
  return function(t, r) {
    var n = r.data, i = r.resetDefines[e];
    if (i && i.dataEach)
      for (var o = t.start; o < t.end; o++)
        i.dataEach(n, o);
    else i && i.progress && i.progress(t, n);
  };
}
function SCe(e) {
  return e.data.count();
}
function wCe(e) {
  iC = null;
  try {
    e($g, IW);
  } catch {
  }
  return iC;
}
var $g = {}, IW = {}, iC;
FW($g, VM);
FW(IW, nW);
$g.eachSeriesByType = $g.eachRawSeriesByType = function(e) {
  iC = e;
};
$g.eachComponent = function(e) {
  e.mainType === "series" && e.subType && (iC = e.subType);
};
function FW(e, t) {
  for (var r in t.prototype)
    e[r] = Kr;
}
var vN = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
const bCe = {
  color: vN,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], vN]
};
var ui = "#B9B8CE", mN = "#100C2A", jm = function() {
  return {
    axisLine: {
      lineStyle: {
        color: ui
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
}, yN = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], LW = {
  darkMode: !0,
  color: yN,
  backgroundColor: mN,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: ui
    }
  },
  textStyle: {
    color: ui
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: ui
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: ui
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: ui
    }
  },
  timeline: {
    lineStyle: {
      color: ui
    },
    label: {
      color: ui
    },
    controlStyle: {
      color: ui,
      borderColor: ui
    }
  },
  calendar: {
    itemStyle: {
      color: mN
    },
    dayLabel: {
      color: ui
    },
    monthLabel: {
      color: ui
    },
    yearLabel: {
      color: ui
    }
  },
  timeAxis: jm(),
  logAxis: jm(),
  valueAxis: jm(),
  categoryAxis: jm(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: yN
  },
  gauge: {
    title: {
      color: ui
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: ui
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  }
};
LW.categoryAxis.splitLine.show = !1;
var xCe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.normalizeQuery = function(t) {
      var r = {}, n = {}, i = {};
      if (Fe(t)) {
        var o = za(t);
        r.mainType = o.main || null, r.subType = o.sub || null;
      } else {
        var a = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        B(t, function(l, u) {
          for (var c = !1, d = 0; d < a.length; d++) {
            var h = a[d], f = u.lastIndexOf(h);
            if (f > 0 && f === u.length - h.length) {
              var p = u.slice(0, f);
              p !== "data" && (r.mainType = p, r[h.toLowerCase()] = l, c = !0);
            }
          }
          s.hasOwnProperty(u) && (n[u] = l, c = !0), c || (i[u] = l);
        });
      }
      return {
        cptQuery: r,
        dataQuery: n,
        otherQuery: i
      };
    }, e.prototype.filter = function(t, r) {
      var n = this.eventInfo;
      if (!n)
        return !0;
      var i = n.targetEl, o = n.packedEvent, a = n.model, s = n.view;
      if (!a || !s)
        return !0;
      var l = r.cptQuery, u = r.dataQuery;
      return c(l, a, "mainType") && c(l, a, "subType") && c(l, a, "index", "componentIndex") && c(l, a, "name") && c(l, a, "id") && c(u, o, "name") && c(u, o, "dataIndex") && c(u, o, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, r.otherQuery, i, o));
      function c(d, h, f, p) {
        return d[f] == null || h[p || f] === d[f];
      }
    }, e.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, e;
  }()
), y_ = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], CN = y_.concat(["symbolKeepAspect"]), ECe = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    var r = e.getData();
    if (e.legendIcon && r.setVisual("legendIcon", e.legendIcon), !e.hasSymbolVisual)
      return;
    for (var n = {}, i = {}, o = !1, a = 0; a < y_.length; a++) {
      var s = y_[a], l = e.get(s);
      Ye(l) ? (o = !0, i[s] = l) : n[s] = l;
    }
    if (n.symbol = n.symbol || e.defaultSymbol, r.setVisual(se({
      legendIcon: e.legendIcon || n.symbol,
      symbolKeepAspect: e.get("symbolKeepAspect")
    }, n)), t.isSeriesFiltered(e))
      return;
    var u = At(i);
    function c(d, h) {
      for (var f = e.getRawValue(h), p = e.getDataParams(h), g = 0; g < u.length; g++) {
        var v = u[g];
        d.setItemVisual(h, v, i[v](f, p));
      }
    }
    return {
      dataEach: o ? c : null
    };
  }
}, RCe = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    if (!e.hasSymbolVisual || t.isSeriesFiltered(e))
      return;
    var r = e.getData();
    function n(i, o) {
      for (var a = i.getItemModel(o), s = 0; s < CN.length; s++) {
        var l = CN[s], u = a.getShallow(l, !0);
        u != null && i.setItemVisual(o, l, u);
      }
    }
    return {
      dataEach: r.hasItemOption ? n : null
    };
  }
};
function $M(e, t, r) {
  switch (r) {
    case "color":
      var n = e.getItemVisual(t, "style");
      return n[e.getVisual("drawType")];
    case "opacity":
      return e.getItemVisual(t, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getItemVisual(t, r);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + r);
  }
}
function Ov(e, t) {
  switch (t) {
    case "color":
      var r = e.getVisual("style");
      return r[e.getVisual("drawType")];
    case "opacity":
      return e.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getVisual(t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function OW(e, t, r, n) {
  switch (r) {
    case "color":
      var i = e.ensureUniqueItemVisual(t, "style");
      i[e.getVisual("drawType")] = n, e.setItemVisual(t, "colorFromPalette", !1);
      break;
    case "opacity":
      e.ensureUniqueItemVisual(t, "style").opacity = n;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      e.setItemVisual(t, r, n);
      break;
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + r);
  }
}
function NW(e, t) {
  function r(n, i) {
    var o = [];
    return n.eachComponent({
      mainType: "series",
      subType: e,
      query: i
    }, function(a) {
      o.push(a.seriesIndex);
    }), o;
  }
  B([[e + "ToggleSelect", "toggleSelect"], [e + "Select", "select"], [e + "UnSelect", "unselect"]], function(n) {
    t(n[0], function(i, o, a) {
      i = se({}, i), process.env.NODE_ENV !== "production" && Jr(i.type, n[1]), a.dispatchAction(se(i, {
        type: n[1],
        seriesIndex: r(o, i)
      }));
    });
  });
}
function _d(e, t, r, n, i) {
  var o = e + t;
  r.isSilent(o) || (process.env.NODE_ENV !== "production" && No("event " + o + " is deprecated."), n.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(a) {
    for (var s = a.seriesIndex, l = a.option.selectedMap, u = i.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === s) {
        var d = a.getData(), h = Pc(d, i.fromActionPayload);
        r.trigger(o, {
          type: o,
          seriesId: a.id,
          name: fe(h) ? d.getName(h[0]) : d.getName(h),
          selected: Fe(l) ? l : se({}, l)
        });
      }
  }));
}
function _Ce(e, t, r) {
  e.on("selectchanged", function(n) {
    var i = r.getModel();
    n.isFromClick ? (_d("map", "selectchanged", t, i, n), _d("pie", "selectchanged", t, i, n)) : n.fromAction === "select" ? (_d("map", "selected", t, i, n), _d("pie", "selected", t, i, n)) : n.fromAction === "unselect" && (_d("map", "unselected", t, i, n), _d("pie", "unselected", t, i, n));
  });
}
function ic(e, t, r) {
  for (var n; e && !(t(e) && (n = e, r)); )
    e = e.__hostTarget || e.parent;
  return n;
}
var TCe = Math.round(Math.random() * 9), PCe = typeof Object.defineProperty == "function", MCe = function() {
  function e() {
    this._id = "__ec_inner_" + TCe++;
  }
  return e.prototype.get = function(t) {
    return this._guard(t)[this._id];
  }, e.prototype.set = function(t, r) {
    var n = this._guard(t);
    return PCe ? Object.defineProperty(n, this._id, {
      value: r,
      enumerable: !1,
      configurable: !0
    }) : n[this._id] = r, this;
  }, e.prototype.delete = function(t) {
    return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
  }, e.prototype.has = function(t) {
    return !!this._guard(t)[this._id];
  }, e.prototype._guard = function(t) {
    if (t !== Object(t))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return t;
  }, e;
}(), DCe = Mt.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var r = t.cx, n = t.cy, i = t.width / 2, o = t.height / 2;
    e.moveTo(r, n - o), e.lineTo(r + i, n + o), e.lineTo(r - i, n + o), e.closePath();
  }
}), ACe = Mt.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var r = t.cx, n = t.cy, i = t.width / 2, o = t.height / 2;
    e.moveTo(r, n - o), e.lineTo(r + i, n), e.lineTo(r, n + o), e.lineTo(r - i, n), e.closePath();
  }
}), ICe = Mt.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var r = t.x, n = t.y, i = t.width / 5 * 3, o = Math.max(i, t.height), a = i / 2, s = a * a / (o - a), l = n - o + a + s, u = Math.asin(s / a), c = Math.cos(u) * a, d = Math.sin(u), h = Math.cos(u), f = a * 0.6, p = a * 0.7;
    e.moveTo(r - c, l + s), e.arc(r, l, a, Math.PI - u, Math.PI * 2 + u), e.bezierCurveTo(r + c - d * f, l + s + h * f, r, n - p, r, n), e.bezierCurveTo(r, n - p, r - c + d * f, l + s + h * f, r - c, l + s), e.closePath();
  }
}), FCe = Mt.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var r = t.height, n = t.width, i = t.x, o = t.y, a = n / 3 * 2;
    e.moveTo(i, o), e.lineTo(i + a, o + r), e.lineTo(i, o + r / 4 * 3), e.lineTo(i - a, o + r), e.lineTo(i, o), e.closePath();
  }
}), LCe = {
  line: wn,
  rect: Bt,
  roundRect: Bt,
  square: Bt,
  circle: Js,
  diamond: ACe,
  pin: ICe,
  arrow: FCe,
  triangle: DCe
}, OCe = {
  line: function(e, t, r, n, i) {
    i.x1 = e, i.y1 = t + n / 2, i.x2 = e + r, i.y2 = t + n / 2;
  },
  rect: function(e, t, r, n, i) {
    i.x = e, i.y = t, i.width = r, i.height = n;
  },
  roundRect: function(e, t, r, n, i) {
    i.x = e, i.y = t, i.width = r, i.height = n, i.r = Math.min(r, n) / 4;
  },
  square: function(e, t, r, n, i) {
    var o = Math.min(r, n);
    i.x = e, i.y = t, i.width = o, i.height = o;
  },
  circle: function(e, t, r, n, i) {
    i.cx = e + r / 2, i.cy = t + n / 2, i.r = Math.min(r, n) / 2;
  },
  diamond: function(e, t, r, n, i) {
    i.cx = e + r / 2, i.cy = t + n / 2, i.width = r, i.height = n;
  },
  pin: function(e, t, r, n, i) {
    i.x = e + r / 2, i.y = t + n / 2, i.width = r, i.height = n;
  },
  arrow: function(e, t, r, n, i) {
    i.x = e + r / 2, i.y = t + n / 2, i.width = r, i.height = n;
  },
  triangle: function(e, t, r, n, i) {
    i.cx = e + r / 2, i.cy = t + n / 2, i.width = r, i.height = n;
  }
}, oC = {};
B(LCe, function(e, t) {
  oC[t] = new e();
});
var NCe = Mt.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(e, t, r) {
    var n = U0(e, t, r), i = this.shape;
    return i && i.symbolType === "pin" && t.position === "inside" && (n.y = r.y + r.height * 0.4), n;
  },
  buildPath: function(e, t, r) {
    var n = t.symbolType;
    if (n !== "none") {
      var i = oC[n];
      i || (n = "rect", i = oC[n]), OCe[n](t.x, t.y, t.width, t.height, i.shape), i.buildPath(e, i.shape, r);
    }
  }
});
function kCe(e, t) {
  if (this.type !== "image") {
    var r = this.style;
    this.__isEmptyBrush ? (r.stroke = e, r.fill = t || "#fff", r.lineWidth = 2) : this.shape.symbolType === "line" ? r.stroke = e : r.fill = e, this.markRedraw();
  }
}
function rn(e, t, r, n, i, o, a) {
  var s = e.indexOf("empty") === 0;
  s && (e = e.substr(5, 1).toLowerCase() + e.substr(6));
  var l;
  return e.indexOf("image://") === 0 ? l = wM(e.slice(8), new St(t, r, n, i), a ? "center" : "cover") : e.indexOf("path://") === 0 ? l = Iv(e.slice(7), {}, new St(t, r, n, i), a ? "center" : "cover") : l = new NCe({
    shape: {
      symbolType: e,
      x: t,
      y: r,
      width: n,
      height: i
    }
  }), l.__isEmptyBrush = s, l.setColor = kCe, o && l.setColor(o), l;
}
function vf(e) {
  return fe(e) || (e = [+e, +e]), [e[0] || 0, e[1] || 0];
}
function qc(e, t) {
  if (e != null)
    return fe(e) || (e = [e, e]), [Ae(e[0], t[0]) || 0, Ae(st(e[1], e[0]), t[1]) || 0];
}
function oc(e) {
  return isFinite(e);
}
function VCe(e, t, r) {
  var n = t.x == null ? 0 : t.x, i = t.x2 == null ? 1 : t.x2, o = t.y == null ? 0 : t.y, a = t.y2 == null ? 0 : t.y2;
  t.global || (n = n * r.width + r.x, i = i * r.width + r.x, o = o * r.height + r.y, a = a * r.height + r.y), n = oc(n) ? n : 0, i = oc(i) ? i : 1, o = oc(o) ? o : 0, a = oc(a) ? a : 0;
  var s = e.createLinearGradient(n, o, i, a);
  return s;
}
function BCe(e, t, r) {
  var n = r.width, i = r.height, o = Math.min(n, i), a = t.x == null ? 0.5 : t.x, s = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
  t.global || (a = a * n + r.x, s = s * i + r.y, l = l * o), a = oc(a) ? a : 0.5, s = oc(s) ? s : 0.5, l = l >= 0 && oc(l) ? l : 0.5;
  var u = e.createRadialGradient(a, s, 0, a, s, l);
  return u;
}
function C_(e, t, r) {
  for (var n = t.type === "radial" ? BCe(e, t, r) : VCe(e, t, r), i = t.colorStops, o = 0; o < i.length; o++)
    n.addColorStop(i[o].offset, i[o].color);
  return n;
}
function GCe(e, t) {
  if (e === t || !e && !t)
    return !1;
  if (!e || !t || e.length !== t.length)
    return !0;
  for (var r = 0; r < e.length; r++)
    if (e[r] !== t[r])
      return !0;
  return !1;
}
function Um(e) {
  return parseInt(e, 10);
}
function nh(e, t, r) {
  var n = ["width", "height"][t], i = ["clientWidth", "clientHeight"][t], o = ["paddingLeft", "paddingTop"][t], a = ["paddingRight", "paddingBottom"][t];
  if (r[n] != null && r[n] !== "auto")
    return parseFloat(r[n]);
  var s = document.defaultView.getComputedStyle(e);
  return (e[i] || Um(s[n]) || Um(e.style[n])) - (Um(s[o]) || 0) - (Um(s[a]) || 0) | 0;
}
function HCe(e, t) {
  return !e || e === "solid" || !(t > 0) ? null : e === "dashed" ? [4 * t, 2 * t] : e === "dotted" ? [t] : $t(e) ? [e] : fe(e) ? e : null;
}
function WM(e) {
  var t = e.style, r = t.lineDash && t.lineWidth > 0 && HCe(t.lineDash, t.lineWidth), n = t.lineDashOffset;
  if (r) {
    var i = t.strokeNoScale && e.getLineScale ? e.getLineScale() : 1;
    i && i !== 1 && (r = ge(r, function(o) {
      return o / i;
    }), n /= i);
  }
  return [r, n];
}
var zCe = new es(!0);
function aC(e) {
  var t = e.stroke;
  return !(t == null || t === "none" || !(e.lineWidth > 0));
}
function SN(e) {
  return typeof e == "string" && e !== "none";
}
function sC(e) {
  var t = e.fill;
  return t != null && t !== "none";
}
function wN(e, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var r = e.globalAlpha;
    e.globalAlpha = t.fillOpacity * t.opacity, e.fill(), e.globalAlpha = r;
  } else
    e.fill();
}
function bN(e, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var r = e.globalAlpha;
    e.globalAlpha = t.strokeOpacity * t.opacity, e.stroke(), e.globalAlpha = r;
  } else
    e.stroke();
}
function S_(e, t, r) {
  var n = dM(t.image, t.__image, r);
  if (IS(n)) {
    var i = e.createPattern(n, t.repeat || "repeat");
    if (typeof DOMMatrix == "function" && i && i.setTransform) {
      var o = new DOMMatrix();
      o.translateSelf(t.x || 0, t.y || 0), o.rotateSelf(0, 0, (t.rotation || 0) * Up), o.scaleSelf(t.scaleX || 1, t.scaleY || 1), i.setTransform(o);
    }
    return i;
  }
}
function $Ce(e, t, r, n) {
  var i, o = aC(r), a = sC(r), s = r.strokePercent, l = s < 1, u = !t.path;
  (!t.silent || l) && u && t.createPathProxy();
  var c = t.path || zCe, d = t.__dirty;
  if (!n) {
    var h = r.fill, f = r.stroke, p = a && !!h.colorStops, g = o && !!f.colorStops, v = a && !!h.image, m = o && !!f.image, y = void 0, C = void 0, S = void 0, b = void 0, w = void 0;
    (p || g) && (w = t.getBoundingRect()), p && (y = d ? C_(e, h, w) : t.__canvasFillGradient, t.__canvasFillGradient = y), g && (C = d ? C_(e, f, w) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = C), v && (S = d || !t.__canvasFillPattern ? S_(e, h, t) : t.__canvasFillPattern, t.__canvasFillPattern = S), m && (b = d || !t.__canvasStrokePattern ? S_(e, f, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = S), p ? e.fillStyle = y : v && (S ? e.fillStyle = S : a = !1), g ? e.strokeStyle = C : m && (b ? e.strokeStyle = b : o = !1);
  }
  var x = t.getGlobalScale();
  c.setScale(x[0], x[1], t.segmentIgnoreThreshold);
  var E, R;
  e.setLineDash && r.lineDash && (i = WM(t), E = i[0], R = i[1]);
  var _ = !0;
  (u || d & Wd) && (c.setDPR(e.dpr), l ? c.setContext(null) : (c.setContext(e), _ = !1), c.reset(), t.buildPath(c, t.shape, n), c.toStatic(), t.pathUpdated()), _ && c.rebuildPath(e, l ? s : 1), E && (e.setLineDash(E), e.lineDashOffset = R), n || (r.strokeFirst ? (o && bN(e, r), a && wN(e, r)) : (a && wN(e, r), o && bN(e, r))), E && e.setLineDash([]);
}
function WCe(e, t, r) {
  var n = t.__image = dM(r.image, t.__image, t, t.onload);
  if (!(!n || !IS(n))) {
    var i = r.x || 0, o = r.y || 0, a = t.getWidth(), s = t.getHeight(), l = n.width / n.height;
    if (a == null && s != null ? a = s * l : s == null && a != null ? s = a / l : a == null && s == null && (a = n.width, s = n.height), r.sWidth && r.sHeight) {
      var u = r.sx || 0, c = r.sy || 0;
      e.drawImage(n, u, c, r.sWidth, r.sHeight, i, o, a, s);
    } else if (r.sx && r.sy) {
      var u = r.sx, c = r.sy, d = a - u, h = s - c;
      e.drawImage(n, u, c, d, h, i, o, a, s);
    } else
      e.drawImage(n, i, o, a, s);
  }
}
function jCe(e, t, r) {
  var n, i = r.text;
  if (i != null && (i += ""), i) {
    e.font = r.font || Hl, e.textAlign = r.textAlign, e.textBaseline = r.textBaseline;
    var o = void 0, a = void 0;
    e.setLineDash && r.lineDash && (n = WM(t), o = n[0], a = n[1]), o && (e.setLineDash(o), e.lineDashOffset = a), r.strokeFirst ? (aC(r) && e.strokeText(i, r.x, r.y), sC(r) && e.fillText(i, r.x, r.y)) : (sC(r) && e.fillText(i, r.x, r.y), aC(r) && e.strokeText(i, r.x, r.y)), o && e.setLineDash([]);
  }
}
var xN = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], EN = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function kW(e, t, r, n, i) {
  var o = !1;
  if (!n && (r = r || {}, t === r))
    return !1;
  if (n || t.opacity !== r.opacity) {
    Fi(e, i), o = !0;
    var a = Math.max(Math.min(t.opacity, 1), 0);
    e.globalAlpha = isNaN(a) ? hc.opacity : a;
  }
  (n || t.blend !== r.blend) && (o || (Fi(e, i), o = !0), e.globalCompositeOperation = t.blend || hc.blend);
  for (var s = 0; s < xN.length; s++) {
    var l = xN[s];
    (n || t[l] !== r[l]) && (o || (Fi(e, i), o = !0), e[l] = e.dpr * (t[l] || 0));
  }
  return (n || t.shadowColor !== r.shadowColor) && (o || (Fi(e, i), o = !0), e.shadowColor = t.shadowColor || hc.shadowColor), o;
}
function RN(e, t, r, n, i) {
  var o = Wg(t, i.inHover), a = n ? null : r && Wg(r, i.inHover) || {};
  if (o === a)
    return !1;
  var s = kW(e, o, a, n, i);
  if ((n || o.fill !== a.fill) && (s || (Fi(e, i), s = !0), SN(o.fill) && (e.fillStyle = o.fill)), (n || o.stroke !== a.stroke) && (s || (Fi(e, i), s = !0), SN(o.stroke) && (e.strokeStyle = o.stroke)), (n || o.opacity !== a.opacity) && (s || (Fi(e, i), s = !0), e.globalAlpha = o.opacity == null ? 1 : o.opacity), t.hasStroke()) {
    var l = o.lineWidth, u = l / (o.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
    e.lineWidth !== u && (s || (Fi(e, i), s = !0), e.lineWidth = u);
  }
  for (var c = 0; c < EN.length; c++) {
    var d = EN[c], h = d[0];
    (n || o[h] !== a[h]) && (s || (Fi(e, i), s = !0), e[h] = o[h] || d[1]);
  }
  return s;
}
function UCe(e, t, r, n, i) {
  return kW(e, Wg(t, i.inHover), r && Wg(r, i.inHover), n, i);
}
function VW(e, t) {
  var r = t.transform, n = e.dpr || 1;
  r ? e.setTransform(n * r[0], n * r[1], n * r[2], n * r[3], n * r[4], n * r[5]) : e.setTransform(n, 0, 0, n, 0, 0);
}
function KCe(e, t, r) {
  for (var n = !1, i = 0; i < e.length; i++) {
    var o = e[i];
    n = n || o.isZeroArea(), VW(t, o), t.beginPath(), o.buildPath(t, o.shape), t.clip();
  }
  r.allClipped = n;
}
function YCe(e, t) {
  return e && t ? e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || e[4] !== t[4] || e[5] !== t[5] : !(!e && !t);
}
var _N = 1, TN = 2, PN = 3, MN = 4;
function qCe(e) {
  var t = sC(e), r = aC(e);
  return !(e.lineDash || !(+t ^ +r) || t && typeof e.fill != "string" || r && typeof e.stroke != "string" || e.strokePercent < 1 || e.strokeOpacity < 1 || e.fillOpacity < 1);
}
function Fi(e, t) {
  t.batchFill && e.fill(), t.batchStroke && e.stroke(), t.batchFill = "", t.batchStroke = "";
}
function Wg(e, t) {
  return t && e.__hoverStyle || e.style;
}
function jM(e, t) {
  ac(e, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function ac(e, t, r, n) {
  var i = t.transform;
  if (!t.shouldBePainted(r.viewWidth, r.viewHeight, !1, !1)) {
    t.__dirty &= ~qi, t.__isRendered = !1;
    return;
  }
  var o = t.__clipPaths, a = r.prevElClipPaths, s = !1, l = !1;
  if ((!a || GCe(o, a)) && (a && a.length && (Fi(e, r), e.restore(), l = s = !0, r.prevElClipPaths = null, r.allClipped = !1, r.prevEl = null), o && o.length && (Fi(e, r), e.save(), KCe(o, e, r), s = !0), r.prevElClipPaths = o), r.allClipped) {
    t.__isRendered = !1;
    return;
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
  var u = r.prevEl;
  u || (l = s = !0);
  var c = t instanceof Mt && t.autoBatch && qCe(t.style);
  s || YCe(i, u.transform) ? (Fi(e, r), VW(e, t)) : c || Fi(e, r);
  var d = Wg(t, r.inHover);
  t instanceof Mt ? (r.lastDrawType !== _N && (l = !0, r.lastDrawType = _N), RN(e, t, u, l, r), (!c || !r.batchFill && !r.batchStroke) && e.beginPath(), $Ce(e, t, d, c), c && (r.batchFill = d.fill || "", r.batchStroke = d.stroke || "")) : t instanceof Fh ? (r.lastDrawType !== PN && (l = !0, r.lastDrawType = PN), RN(e, t, u, l, r), jCe(e, t, d)) : t instanceof In ? (r.lastDrawType !== TN && (l = !0, r.lastDrawType = TN), UCe(e, t, u, l, r), WCe(e, t, d)) : t.getTemporalDisplayables && (r.lastDrawType !== MN && (l = !0, r.lastDrawType = MN), ZCe(e, t, r)), c && n && Fi(e, r), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), r.prevEl = t, t.__dirty = 0, t.__isRendered = !0;
}
function ZCe(e, t, r) {
  var n = t.getDisplayables(), i = t.getTemporalDisplayables();
  e.save();
  var o = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: r.viewWidth,
    viewHeight: r.viewHeight,
    inHover: r.inHover
  }, a, s;
  for (a = t.getCursor(), s = n.length; a < s; a++) {
    var l = n[a];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), ac(e, l, o, a === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), o.prevEl = l;
  }
  for (var u = 0, c = i.length; u < c; u++) {
    var l = i[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), ac(e, l, o, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), o.prevEl = l;
  }
  t.clearTemporalDisplayables(), t.notClear = !0, e.restore();
}
var u1 = new MCe(), DN = new Rv(100), AN = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function Nh(e, t) {
  if (e === "none")
    return null;
  var r = t.getDevicePixelRatio(), n = t.getZr(), i = n.painter.type === "svg";
  e.dirty && u1.delete(e);
  var o = u1.get(e);
  if (o)
    return o;
  var a = Xe(e, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  a.backgroundColor === "none" && (a.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = a.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / r, u1.set(e, s), e.dirty = !1, s;
  function l(u) {
    for (var c = [r], d = !0, h = 0; h < AN.length; ++h) {
      var f = a[AN[h]];
      if (f != null && !fe(f) && !Fe(f) && !$t(f) && typeof f != "boolean") {
        d = !1;
        break;
      }
      c.push(f);
    }
    var p;
    if (d) {
      p = c.join(",") + (i ? "-svg" : "");
      var g = DN.get(p);
      g && (i ? u.svgElement = g : u.image = g);
    }
    var v = GW(a.dashArrayX), m = XCe(a.dashArrayY), y = BW(a.symbol), C = QCe(v), S = HW(m), b = !i && va.createCanvas(), w = i && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, x = R(), E;
    b && (b.width = x.width * r, b.height = x.height * r, E = b.getContext("2d")), _(), d && DN.put(p, b || w), u.image = b, u.svgElement = w, u.svgWidth = x.width, u.svgHeight = x.height;
    function R() {
      for (var P = 1, D = 0, I = C.length; D < I; ++D)
        P = jL(P, C[D]);
      for (var A = 1, D = 0, I = y.length; D < I; ++D)
        A = jL(A, y[D].length);
      P *= A;
      var O = S * C.length * y.length;
      if (process.env.NODE_ENV !== "production") {
        var L = function(N) {
          console.warn("Calculated decal size is greater than " + N + " due to decal option settings so " + N + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + N + " to be larger to avoid incontinuity.");
        };
        P > a.maxTileWidth && L("maxTileWidth"), O > a.maxTileHeight && L("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(P, a.maxTileWidth)),
        height: Math.max(1, Math.min(O, a.maxTileHeight))
      };
    }
    function _() {
      E && (E.clearRect(0, 0, b.width, b.height), a.backgroundColor && (E.fillStyle = a.backgroundColor, E.fillRect(0, 0, b.width, b.height)));
      for (var P = 0, D = 0; D < m.length; ++D)
        P += m[D];
      if (P <= 0)
        return;
      for (var I = -S, A = 0, O = 0, L = 0; I < x.height; ) {
        if (A % 2 === 0) {
          for (var N = O / 2 % y.length, F = 0, G = 0, M = 0; F < x.width * 2; ) {
            for (var V = 0, D = 0; D < v[L].length; ++D)
              V += v[L][D];
            if (V <= 0)
              break;
            if (G % 2 === 0) {
              var z = (1 - a.symbolSize) * 0.5, k = F + v[L][G] * z, $ = I + m[A] * z, W = v[L][G] * a.symbolSize, j = m[A] * a.symbolSize, U = M / 2 % y[N].length;
              Z(k, $, W, j, y[N][U]);
            }
            F += v[L][G], ++M, ++G, G === v[L].length && (G = 0);
          }
          ++L, L === v.length && (L = 0);
        }
        I += m[A], ++O, ++A, A === m.length && (A = 0);
      }
      function Z(ee, J, X, Y, de) {
        var K = i ? 1 : r, ie = rn(de, ee * K, J * K, X * K, Y * K, a.color, a.symbolKeepAspect);
        if (i) {
          var Ce = n.painter.renderOneToVNode(ie);
          Ce && w.children.push(Ce);
        } else
          jM(E, ie);
      }
    }
  }
}
function BW(e) {
  if (!e || e.length === 0)
    return [["rect"]];
  if (Fe(e))
    return [[e]];
  for (var t = !0, r = 0; r < e.length; ++r)
    if (!Fe(e[r])) {
      t = !1;
      break;
    }
  if (t)
    return BW([e]);
  for (var n = [], r = 0; r < e.length; ++r)
    Fe(e[r]) ? n.push([e[r]]) : n.push(e[r]);
  return n;
}
function GW(e) {
  if (!e || e.length === 0)
    return [[0, 0]];
  if ($t(e)) {
    var t = Math.ceil(e);
    return [[t, t]];
  }
  for (var r = !0, n = 0; n < e.length; ++n)
    if (!$t(e[n])) {
      r = !1;
      break;
    }
  if (r)
    return GW([e]);
  for (var i = [], n = 0; n < e.length; ++n)
    if ($t(e[n])) {
      var t = Math.ceil(e[n]);
      i.push([t, t]);
    } else {
      var t = ge(e[n], function(s) {
        return Math.ceil(s);
      });
      t.length % 2 === 1 ? i.push(t.concat(t)) : i.push(t);
    }
  return i;
}
function XCe(e) {
  if (!e || typeof e == "object" && e.length === 0)
    return [0, 0];
  if ($t(e)) {
    var t = Math.ceil(e);
    return [t, t];
  }
  var r = ge(e, function(n) {
    return Math.ceil(n);
  });
  return e.length % 2 ? r.concat(r) : r;
}
function QCe(e) {
  return ge(e, function(t) {
    return HW(t);
  });
}
function HW(e) {
  for (var t = 0, r = 0; r < e.length; ++r)
    t += e[r];
  return e.length % 2 === 1 ? t * 2 : t;
}
function JCe(e, t) {
  e.eachRawSeries(function(r) {
    if (!e.isSeriesFiltered(r)) {
      var n = r.getData();
      n.hasItemVisual() && n.each(function(a) {
        var s = n.getItemVisual(a, "decal");
        if (s) {
          var l = n.ensureUniqueItemVisual(a, "style");
          l.decal = Nh(s, t);
        }
      });
      var i = n.getVisual("decal");
      if (i) {
        var o = n.getVisual("style");
        o.decal = Nh(i, t);
      }
    }
  });
}
var Jo = new Go(), lC = {};
function eSe(e, t) {
  process.env.NODE_ENV !== "production" && lC[e] && Vn("Already has an implementation of " + e + "."), lC[e] = t;
}
function zW(e) {
  return process.env.NODE_ENV !== "production" && (lC[e] || Vn("Implementation of " + e + " doesn't exists.")), lC[e];
}
var tSe = "5.5.1", rSe = {
  zrender: "5.6.0"
}, nSe = 1, iSe = 800, oSe = 900, aSe = 1e3, sSe = 2e3, lSe = 5e3, $W = 1e3, uSe = 1100, UM = 2e3, WW = 3e3, cSe = 4e3, QS = 4500, dSe = 4600, hSe = 5e3, fSe = 6e3, jW = 7e3, UW = {
  PROCESSOR: {
    FILTER: aSe,
    SERIES_FILTER: iSe,
    STATISTIC: lSe
  },
  VISUAL: {
    LAYOUT: $W,
    PROGRESSIVE_LAYOUT: uSe,
    GLOBAL: UM,
    CHART: WW,
    POST_CHART_LAYOUT: dSe,
    COMPONENT: cSe,
    BRUSH: hSe,
    CHART_ITEM: QS,
    ARIA: fSe,
    DECAL: jW
  }
}, Un = "__flagInMainProcess", Pi = "__pendingUpdate", c1 = "__needsUpdateStatus", IN = /^[a-zA-Z0-9_]+$/, d1 = "__connectUpdateStatus", FN = 0, pSe = 1, gSe = 2;
function KW(e) {
  return function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    if (this.isDisposed()) {
      Ki(this.id);
      return;
    }
    return qW(this, e, t);
  };
}
function YW(e) {
  return function() {
    for (var t = [], r = 0; r < arguments.length; r++)
      t[r] = arguments[r];
    return qW(this, e, t);
  };
}
function qW(e, t, r) {
  return r[0] = r[0] && r[0].toLowerCase(), Go.prototype[t].apply(e, r);
}
var ZW = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  }(Go)
), XW = ZW.prototype;
XW.on = YW("on");
XW.off = YW("off");
var Td, h1, Km, dl, f1, p1, g1, rp, np, LN, ON, v1, NN, Ym, kN, QW, ho, VN, uC = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i) {
      var o = e.call(this, new xCe()) || this;
      o._chartsViews = [], o._chartsMap = {}, o._componentsViews = [], o._componentsMap = {}, o._pendingActions = [], i = i || {}, Fe(n) && (n = JW[n]), o._dom = r;
      var a = "canvas", s = "auto", l = !1;
      if (process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          kt.hasGlobalWindow ? window : global
        );
        u && (a = st(u.__ECHARTS__DEFAULT__RENDERER__, a), s = st(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = st(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      i.ssr && T$(function(f) {
        var p = ot(f), g = p.dataIndex;
        if (g != null) {
          var v = We();
          return v.set("series_index", p.seriesIndex), v.set("data_index", g), p.ssrType && v.set("ssr_type", p.ssrType), v;
        }
      });
      var c = o._zr = UR(r, {
        renderer: i.renderer || a,
        devicePixelRatio: i.devicePixelRatio,
        width: i.width,
        height: i.height,
        ssr: i.ssr,
        useDirtyRect: st(i.useDirtyRect, l),
        useCoarsePointer: st(i.useCoarsePointer, s),
        pointerSize: i.pointerSize
      });
      o._ssr = i.ssr, o._throttledZrFlush = XS(ke(c.flush, c), 17), n = et(n), n && oW(n, !0), o._theme = n, o._locale = Aye(i.locale || V6), o._coordSysMgr = new Yc();
      var d = o._api = kN(o);
      function h(f, p) {
        return f.__prio - p.__prio;
      }
      return Zy(dC, h), Zy(w_, h), o._scheduler = new DW(o, d, w_, dC), o._messageCenter = new ZW(), o._initEvents(), o.resize = ke(o.resize, o), c.animation.on("frame", o._onframe, o), LN(c, o), ON(c, o), Mg(o), o;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        VN(this);
        var r = this._scheduler;
        if (this[Pi]) {
          var n = this[Pi].silent;
          this[Un] = !0;
          try {
            Td(this), dl.update.call(this, null, this[Pi].updateParams);
          } catch (l) {
            throw this[Un] = !1, this[Pi] = null, l;
          }
          this._zr.flush(), this[Un] = !1, this[Pi] = null, rp.call(this, n), np.call(this, n);
        } else if (r.unfinished) {
          var i = nSe, o = this._model, a = this._api;
          r.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            r.performSeriesTasks(o), r.performDataProcessorTasks(o), p1(this, o), r.performVisualTasks(o), Ym(this, this._model, a, "remain", {}), i -= +/* @__PURE__ */ new Date() - s;
          } while (i > 0 && r.unfinished);
          r.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(r, n, i) {
      if (this[Un]) {
        process.env.NODE_ENV !== "production" && Vn("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      var o, a, s;
      if (Ze(n) && (i = n.lazyUpdate, o = n.silent, a = n.replaceMerge, s = n.transition, n = n.notMerge), this[Un] = !0, !this._model || n) {
        var l = new a0e(this._api), u = this._theme, c = this._model = new VM();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(r, {
        replaceMerge: a
      }, b_);
      var d = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (i)
        this[Pi] = {
          silent: o,
          updateParams: d
        }, this[Un] = !1, this.getZr().wakeUp();
      else {
        try {
          Td(this), dl.update.call(this, null, d);
        } catch (h) {
          throw this[Pi] = null, this[Un] = !1, h;
        }
        this._ssr || this._zr.flush(), this[Pi] = null, this[Un] = !1, rp.call(this, o), np.call(this, o);
      }
    }, t.prototype.setTheme = function() {
      No("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || kt.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(r) {
      return process.env.NODE_ENV !== "production" && Jr("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(r);
    }, t.prototype.renderToCanvas = function(r) {
      r = r || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return n.getRenderedCanvas({
        backgroundColor: r.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: r.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(r) {
      r = r || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return n.renderToString({
        useViewBox: r.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      if (kt.svgSupported) {
        var r = this._zr, n = r.storage.getDisplayList();
        return B(n, function(i) {
          i.stopAnimation(null, !0);
        }), r.painter.toDataURL();
      }
    }, t.prototype.getDataURL = function(r) {
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      r = r || {};
      var n = r.excludeComponents, i = this._model, o = [], a = this;
      B(n, function(l) {
        i.eachComponent({
          mainType: l
        }, function(u) {
          var c = a._componentsMap[u.__viewId];
          c.group.ignore || (o.push(c), c.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(r).toDataURL("image/" + (r && r.type || "png"));
      return B(o, function(l) {
        l.group.ignore = !1;
      }), s;
    }, t.prototype.getConnectedDataURL = function(r) {
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      var n = r.type === "svg", i = this.group, o = Math.min, a = Math.max, s = 1 / 0;
      if (hC[i]) {
        var l = s, u = s, c = -s, d = -s, h = [], f = r && r.pixelRatio || this.getDevicePixelRatio();
        B(gc, function(C, S) {
          if (C.group === i) {
            var b = n ? C.getZr().painter.getSvgDom().innerHTML : C.renderToCanvas(et(r)), w = C.getDom().getBoundingClientRect();
            l = o(w.left, l), u = o(w.top, u), c = a(w.right, c), d = a(w.bottom, d), h.push({
              dom: b,
              left: w.left,
              top: w.top
            });
          }
        }), l *= f, u *= f, c *= f, d *= f;
        var p = c - l, g = d - u, v = va.createCanvas(), m = UR(v, {
          renderer: n ? "svg" : "canvas"
        });
        if (m.resize({
          width: p,
          height: g
        }), n) {
          var y = "";
          return B(h, function(C) {
            var S = C.left - l, b = C.top - u;
            y += '<g transform="translate(' + S + "," + b + ')">' + C.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, r.connectedBackgroundColor && m.painter.setBackgroundColor(r.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else
          return r.connectedBackgroundColor && m.add(new Bt({
            shape: {
              x: 0,
              y: 0,
              width: p,
              height: g
            },
            style: {
              fill: r.connectedBackgroundColor
            }
          })), B(h, function(C) {
            var S = new In({
              style: {
                x: C.left * f - l,
                y: C.top * f - u,
                image: C.dom
              }
            });
            m.add(S);
          }), m.refreshImmediately(), v.toDataURL("image/" + (r && r.type || "png"));
      } else
        return this.getDataURL(r);
    }, t.prototype.convertToPixel = function(r, n) {
      return f1(this, "convertToPixel", r, n);
    }, t.prototype.convertFromPixel = function(r, n) {
      return f1(this, "convertFromPixel", r, n);
    }, t.prototype.containPixel = function(r, n) {
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      var i = this._model, o, a = Jp(i, r);
      return B(a, function(s, l) {
        l.indexOf("Models") >= 0 && B(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            o = o || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var d = this._chartsMap[u.__viewId];
            d && d.containPoint ? o = o || d.containPoint(n, u) : process.env.NODE_ENV !== "production" && Vr(l + ": " + (d ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && Vr(l + ": containPoint is not supported");
        }, this);
      }, this), !!o;
    }, t.prototype.getVisual = function(r, n) {
      var i = this._model, o = Jp(i, r, {
        defaultMainType: "series"
      }), a = o.seriesModel;
      process.env.NODE_ENV !== "production" && (a || Vr("There is no specified series model"));
      var s = a.getData(), l = o.hasOwnProperty("dataIndexInside") ? o.dataIndexInside : o.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(o.dataIndex) : null;
      return l != null ? $M(s, l, n) : Ov(s, n);
    }, t.prototype.getViewOfComponentModel = function(r) {
      return this._componentsMap[r.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(r) {
      return this._chartsMap[r.__viewId];
    }, t.prototype._initEvents = function() {
      var r = this;
      B(vSe, function(n) {
        var i = function(o) {
          var a = r.getModel(), s = o.target, l, u = n === "globalout";
          if (u ? l = {} : s && ic(s, function(p) {
            var g = ot(p);
            if (g && g.dataIndex != null) {
              var v = g.dataModel || a.getSeriesByIndex(g.seriesIndex);
              return l = v && v.getDataParams(g.dataIndex, g.dataType, s) || {}, !0;
            } else if (g.eventData)
              return l = se({}, g.eventData), !0;
          }, !0), l) {
            var c = l.componentType, d = l.componentIndex;
            (c === "markLine" || c === "markPoint" || c === "markArea") && (c = "series", d = l.seriesIndex);
            var h = c && d != null && a.getComponent(c, d), f = h && r[h.mainType === "series" ? "_chartsMap" : "_componentsMap"][h.__viewId];
            process.env.NODE_ENV !== "production" && !u && !(h && f) && Vr("model or view can not be found by params"), l.event = o, l.type = n, r._$eventProcessor.eventInfo = {
              targetEl: s,
              packedEvent: l,
              model: h,
              view: f
            }, r.trigger(n, l);
          }
        };
        i.zrEventfulCallAtLast = !0, r._zr.on(n, i, r);
      }), B(og, function(n, i) {
        r._messageCenter.on(i, function(o) {
          this.trigger(i, o);
        }, r);
      }), B(["selectchanged"], function(n) {
        r._messageCenter.on(n, function(i) {
          this.trigger(n, i);
        }, r);
      }), _Ce(this._messageCenter, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      this._disposed = !0;
      var r = this.getDom();
      r && k$(this.getDom(), YM, "");
      var n = this, i = n._api, o = n._model;
      B(n._componentsViews, function(a) {
        a.dispose(o, i);
      }), B(n._chartsViews, function(a) {
        a.dispose(o, i);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete gc[n.id];
    }, t.prototype.resize = function(r) {
      if (this[Un]) {
        process.env.NODE_ENV !== "production" && Vn("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      this._zr.resize(r);
      var n = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!n) {
        var i = n.resetOption("media"), o = r && r.silent;
        this[Pi] && (o == null && (o = this[Pi].silent), i = !0, this[Pi] = null), this[Un] = !0;
        try {
          i && Td(this), dl.update.call(this, {
            type: "resize",
            animation: se({
              // Disable animation
              duration: 0
            }, r && r.animation)
          });
        } catch (a) {
          throw this[Un] = !1, a;
        }
        this[Un] = !1, rp.call(this, o), np.call(this, o);
      }
    }, t.prototype.showLoading = function(r, n) {
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      if (Ze(r) && (n = r, r = ""), r = r || "default", this.hideLoading(), !x_[r]) {
        process.env.NODE_ENV !== "production" && Vr("Loading effects " + r + " not exists.");
        return;
      }
      var i = x_[r](this._api, n), o = this._zr;
      this._loadingFX = i, o.add(i);
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(r) {
      var n = se({}, r);
      return n.type = og[r.type], n;
    }, t.prototype.dispatchAction = function(r, n) {
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      if (Ze(n) || (n = {
        silent: !!n
      }), !!cC[r.type] && this._model) {
        if (this[Un]) {
          this._pendingActions.push(r);
          return;
        }
        var i = n.silent;
        g1.call(this, r, i);
        var o = n.flush;
        o ? this._zr.flush() : o !== !1 && kt.browser.weChat && this._throttledZrFlush(), rp.call(this, i), np.call(this, i);
      }
    }, t.prototype.updateLabelLayout = function() {
      Jo.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, t.prototype.appendData = function(r) {
      if (this._disposed) {
        Ki(this.id);
        return;
      }
      var n = r.seriesIndex, i = this.getModel(), o = i.getSeriesByIndex(n);
      process.env.NODE_ENV !== "production" && Qe(r.data && o), o.appendData(r), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, t.internalField = function() {
      Td = function(d) {
        var h = d._scheduler;
        h.restorePipelines(d._model), h.prepareStageTasks(), h1(d, !0), h1(d, !1), h.plan();
      }, h1 = function(d, h) {
        for (var f = d._model, p = d._scheduler, g = h ? d._componentsViews : d._chartsViews, v = h ? d._componentsMap : d._chartsMap, m = d._zr, y = d._api, C = 0; C < g.length; C++)
          g[C].__alive = !1;
        h ? f.eachComponent(function(w, x) {
          w !== "series" && S(x);
        }) : f.eachSeries(S);
        function S(w) {
          var x = w.__requireNewView;
          w.__requireNewView = !1;
          var E = "_ec_" + w.id + "_" + w.type, R = !x && v[E];
          if (!R) {
            var _ = za(w.type), P = h ? Rr.getClass(_.main, _.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              ar.getClass(_.sub)
            );
            process.env.NODE_ENV !== "production" && Qe(P, _.sub + " does not exist."), R = new P(), R.init(f, y), v[E] = R, g.push(R), m.add(R.group);
          }
          w.__viewId = R.__id = E, R.__alive = !0, R.__model = w, R.group.__ecComponentInfo = {
            mainType: w.mainType,
            index: w.componentIndex
          }, !h && p.prepareView(R, w, f, y);
        }
        for (var C = 0; C < g.length; ) {
          var b = g[C];
          b.__alive ? C++ : (!h && b.renderTask.dispose(), m.remove(b.group), b.dispose(f, y), g.splice(C, 1), v[b.__id] === b && delete v[b.__id], b.__id = b.group.__ecComponentInfo = null);
        }
      }, Km = function(d, h, f, p, g) {
        var v = d._model;
        if (v.setUpdatePayload(f), !p) {
          B([].concat(d._componentsViews).concat(d._chartsViews), b);
          return;
        }
        var m = {};
        m[p + "Id"] = f[p + "Id"], m[p + "Index"] = f[p + "Index"], m[p + "Name"] = f[p + "Name"];
        var y = {
          mainType: p,
          query: m
        };
        g && (y.subType = g);
        var C = f.excludeSeriesId, S;
        C != null && (S = We(), B(dr(C), function(w) {
          var x = vn(w, null);
          x != null && S.set(x, !0);
        })), v && v.eachComponent(y, function(w) {
          var x = S && S.get(w.id) != null;
          if (!x)
            if (SO(f))
              if (w instanceof hr)
                f.type === fc && !f.notBlur && !w.get(["emphasis", "disabled"]) && Mme(w, f, d._api);
              else {
                var E = mM(w.mainType, w.componentIndex, f.name, d._api), R = E.focusSelf, _ = E.dispatchers;
                f.type === fc && R && !f.notBlur && r_(w.mainType, w.componentIndex, d._api), _ && B(_, function(P) {
                  f.type === fc ? zs(P) : $s(P);
                });
              }
            else i_(f) && w instanceof hr && (Ime(w, f, d._api), yO(w), ho(d));
        }, d), v && v.eachComponent(y, function(w) {
          var x = S && S.get(w.id) != null;
          x || b(d[p === "series" ? "_chartsMap" : "_componentsMap"][w.__viewId]);
        }, d);
        function b(w) {
          w && w.__alive && w[h] && w[h](w.__model, v, d._api, f);
        }
      }, dl = {
        prepareAndUpdate: function(d) {
          Td(this), dl.update.call(this, d, {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: d.newOption != null
          });
        },
        update: function(d, h) {
          var f = this._model, p = this._api, g = this._zr, v = this._coordSysMgr, m = this._scheduler;
          if (f) {
            f.setUpdatePayload(d), m.restoreData(f, d), m.performSeriesTasks(f), v.create(f, p), m.performDataProcessorTasks(f, d), p1(this, f), v.update(f, p), r(f), m.performVisualTasks(f, d), v1(this, f, p, d, h);
            var y = f.get("backgroundColor") || "transparent", C = f.get("darkMode");
            g.setBackgroundColor(y), C != null && C !== "auto" && g.setDarkMode(C), Jo.trigger("afterupdate", f, p);
          }
        },
        updateTransform: function(d) {
          var h = this, f = this._model, p = this._api;
          if (f) {
            f.setUpdatePayload(d);
            var g = [];
            f.eachComponent(function(m, y) {
              if (m !== "series") {
                var C = h.getViewOfComponentModel(y);
                if (C && C.__alive)
                  if (C.updateTransform) {
                    var S = C.updateTransform(y, f, p, d);
                    S && S.update && g.push(C);
                  } else
                    g.push(C);
              }
            });
            var v = We();
            f.eachSeries(function(m) {
              var y = h._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var C = y.updateTransform(m, f, p, d);
                C && C.update && v.set(m.uid, 1);
              } else
                v.set(m.uid, 1);
            }), r(f), this._scheduler.performVisualTasks(f, d, {
              setDirty: !0,
              dirtyMap: v
            }), Ym(this, f, p, d, {}, v), Jo.trigger("afterupdate", f, p);
          }
        },
        updateView: function(d) {
          var h = this._model;
          h && (h.setUpdatePayload(d), ar.markUpdateMethod(d, "updateView"), r(h), this._scheduler.performVisualTasks(h, d, {
            setDirty: !0
          }), v1(this, h, this._api, d, {}), Jo.trigger("afterupdate", h, this._api));
        },
        updateVisual: function(d) {
          var h = this, f = this._model;
          f && (f.setUpdatePayload(d), f.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), ar.markUpdateMethod(d, "updateVisual"), r(f), this._scheduler.performVisualTasks(f, d, {
            visualType: "visual",
            setDirty: !0
          }), f.eachComponent(function(p, g) {
            if (p !== "series") {
              var v = h.getViewOfComponentModel(g);
              v && v.__alive && v.updateVisual(g, f, h._api, d);
            }
          }), f.eachSeries(function(p) {
            var g = h._chartsMap[p.__viewId];
            g.updateVisual(p, f, h._api, d);
          }), Jo.trigger("afterupdate", f, this._api));
        },
        updateLayout: function(d) {
          dl.update.call(this, d);
        }
      }, f1 = function(d, h, f, p) {
        if (d._disposed) {
          Ki(d.id);
          return;
        }
        for (var g = d._model, v = d._coordSysMgr.getCoordinateSystems(), m, y = Jp(g, f), C = 0; C < v.length; C++) {
          var S = v[C];
          if (S[h] && (m = S[h](g, y, p)) != null)
            return m;
        }
        process.env.NODE_ENV !== "production" && Vr("No coordinate system that supports " + h + " found by the given finder.");
      }, p1 = function(d, h) {
        var f = d._chartsMap, p = d._scheduler;
        h.eachSeries(function(g) {
          p.updateStreamModes(g, f[g.__viewId]);
        });
      }, g1 = function(d, h) {
        var f = this, p = this.getModel(), g = d.type, v = d.escapeConnect, m = cC[g], y = m.actionInfo, C = (y.update || "update").split(":"), S = C.pop(), b = C[0] != null && za(C[0]);
        this[Un] = !0;
        var w = [d], x = !1;
        d.batch && (x = !0, w = ge(d.batch, function(A) {
          return A = Xe(se({}, A), d), A.batch = null, A;
        }));
        var E = [], R, _ = i_(d), P = SO(d);
        if (P && l6(this._api), B(w, function(A) {
          if (R = m.action(A, f._model, f._api), R = R || se({}, A), R.type = y.event || R.type, E.push(R), P) {
            var O = uM(d), L = O.queryOptionMap, N = O.mainTypeSpecified, F = N ? L.keys()[0] : "series";
            Km(f, S, A, F), ho(f);
          } else _ ? (Km(f, S, A, "series"), ho(f)) : b && Km(f, S, A, b.main, b.sub);
        }), S !== "none" && !P && !_ && !b)
          try {
            this[Pi] ? (Td(this), dl.update.call(this, d), this[Pi] = null) : dl[S].call(this, d);
          } catch (A) {
            throw this[Un] = !1, A;
          }
        if (x ? R = {
          type: y.event || g,
          escapeConnect: v,
          batch: E
        } : R = E[0], this[Un] = !1, !h) {
          var D = this._messageCenter;
          if (D.trigger(R.type, R), _) {
            var I = {
              type: "selectchanged",
              escapeConnect: v,
              selected: Fme(p),
              isFromClick: d.isFromClick || !1,
              fromAction: d.type,
              fromActionPayload: d
            };
            D.trigger(I.type, I);
          }
        }
      }, rp = function(d) {
        for (var h = this._pendingActions; h.length; ) {
          var f = h.shift();
          g1.call(this, f, d);
        }
      }, np = function(d) {
        !d && this.trigger("updated");
      }, LN = function(d, h) {
        d.on("rendered", function(f) {
          h.trigger("rendered", f), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          d.animation.isFinished() && !h[Pi] && !h._scheduler.unfinished && !h._pendingActions.length && h.trigger("finished");
        });
      }, ON = function(d, h) {
        d.on("mouseover", function(f) {
          var p = f.target, g = ic(p, jl);
          g && (Dme(g, f, h._api), ho(h));
        }).on("mouseout", function(f) {
          var p = f.target, g = ic(p, jl);
          g && (Ame(g, f, h._api), ho(h));
        }).on("click", function(f) {
          var p = f.target, g = ic(p, function(y) {
            return ot(y).dataIndex != null;
          }, !0);
          if (g) {
            var v = g.selected ? "unselect" : "select", m = ot(g);
            h._api.dispatchAction({
              type: v,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function r(d) {
        d.clearColorPalette(), d.eachSeries(function(h) {
          h.clearColorPalette();
        });
      }
      function n(d) {
        var h = [], f = [], p = !1;
        if (d.eachComponent(function(y, C) {
          var S = C.get("zlevel") || 0, b = C.get("z") || 0, w = C.getZLevelKey();
          p = p || !!w, (y === "series" ? f : h).push({
            zlevel: S,
            z: b,
            idx: C.componentIndex,
            type: y,
            key: w
          });
        }), p) {
          var g = h.concat(f), v, m;
          Zy(g, function(y, C) {
            return y.zlevel === C.zlevel ? y.z - C.z : y.zlevel - C.zlevel;
          }), B(g, function(y) {
            var C = d.getComponent(y.type, y.idx), S = y.zlevel, b = y.key;
            v != null && (S = Math.max(v, S)), b ? (S === v && b !== m && S++, m = b) : m && (S === v && S++, m = ""), v = S, C.setZLevel(S);
          });
        }
      }
      v1 = function(d, h, f, p, g) {
        n(h), NN(d, h, f, p, g), B(d._chartsViews, function(v) {
          v.__alive = !1;
        }), Ym(d, h, f, p, g), B(d._chartsViews, function(v) {
          v.__alive || v.remove(h, f);
        });
      }, NN = function(d, h, f, p, g, v) {
        B(v || d._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, h, f, p), s(y, m), c(y, m);
        });
      }, Ym = function(d, h, f, p, g, v) {
        var m = d._scheduler;
        g = se(g || {}, {
          updatedSeries: h.getSeries()
        }), Jo.trigger("series:beforeupdate", h, f, g);
        var y = !1;
        h.eachSeries(function(C) {
          var S = d._chartsMap[C.__viewId];
          S.__alive = !0;
          var b = S.renderTask;
          m.updatePayload(b, p), u(C, S), v && v.get(C.uid) && b.dirty(), b.perform(m.getPerformArgs(b)) && (y = !0), S.group.silent = !!C.get("silent"), a(C, S), yO(C);
        }), m.unfinished = y || m.unfinished, Jo.trigger("series:layoutlabels", h, f, g), Jo.trigger("series:transition", h, f, g), h.eachSeries(function(C) {
          var S = d._chartsMap[C.__viewId];
          s(C, S), c(C, S);
        }), o(d, h), Jo.trigger("series:afterupdate", h, f, g);
      }, ho = function(d) {
        d[c1] = !0, d.getZr().wakeUp();
      }, VN = function(d) {
        d[c1] && (d.getZr().storage.traverse(function(h) {
          gh(h) || i(h);
        }), d[c1] = !1);
      };
      function i(d) {
        for (var h = [], f = d.currentStates, p = 0; p < f.length; p++) {
          var g = f[p];
          g === "emphasis" || g === "blur" || g === "select" || h.push(g);
        }
        d.selected && d.states.select && h.push("select"), d.hoverState === OS && d.states.emphasis ? h.push("emphasis") : d.hoverState === Mv && d.states.blur && h.push("blur"), d.useStates(h);
      }
      function o(d, h) {
        var f = d._zr, p = f.storage, g = 0;
        p.traverse(function(v) {
          v.isGroup || g++;
        }), g > h.get("hoverLayerThreshold") && !kt.node && !kt.worker && h.eachSeries(function(v) {
          if (!v.preventUsingHoverLayer) {
            var m = d._chartsMap[v.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function a(d, h) {
        var f = d.get("blendMode") || null;
        h.eachRendered(function(p) {
          p.isGroup || (p.style.blend = f);
        });
      }
      function s(d, h) {
        if (!d.preventAutoZ) {
          var f = d.get("z") || 0, p = d.get("zlevel") || 0;
          h.eachRendered(function(g) {
            return l(g, f, p, -1 / 0), !0;
          });
        }
      }
      function l(d, h, f, p) {
        var g = d.getTextContent(), v = d.getTextGuideLine(), m = d.isGroup;
        if (m)
          for (var y = d.childrenRef(), C = 0; C < y.length; C++)
            p = Math.max(l(y[C], h, f, p), p);
        else
          d.z = h, d.zlevel = f, p = Math.max(d.z2, p);
        if (g && (g.z = h, g.zlevel = f, isFinite(p) && (g.z2 = p + 2)), v) {
          var S = d.textGuideLineConfig;
          v.z = h, v.zlevel = f, isFinite(p) && (v.z2 = p + (S && S.showAbove ? 1 : -1));
        }
        return p;
      }
      function u(d, h) {
        h.eachRendered(function(f) {
          if (!gh(f)) {
            var p = f.getTextContent(), g = f.getTextGuideLine();
            f.stateTransition && (f.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), f.hasState() ? (f.prevStates = f.currentStates, f.clearStates()) : f.prevStates && (f.prevStates = null);
          }
        });
      }
      function c(d, h) {
        var f = d.getModel("stateAnimation"), p = d.isAnimationEnabled(), g = f.get("duration"), v = g > 0 ? {
          duration: g,
          delay: f.get("delay"),
          easing: f.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        h.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (gh(m))
              return;
            if (m instanceof Mt && Vme(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (p) {
              m.stateTransition = v;
              var C = m.getTextContent(), S = m.getTextGuideLine();
              C && (C.stateTransition = v), S && (S.stateTransition = v);
            }
            m.__dirty && i(m);
          }
        });
      }
      kN = function(d) {
        return new /** @class */
        (function(h) {
          ne(f, h);
          function f() {
            return h !== null && h.apply(this, arguments) || this;
          }
          return f.prototype.getCoordinateSystems = function() {
            return d._coordSysMgr.getCoordinateSystems();
          }, f.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var g = p.__ecComponentInfo;
              if (g != null)
                return d._model.getComponent(g.mainType, g.index);
              p = p.parent;
            }
          }, f.prototype.enterEmphasis = function(p, g) {
            zs(p, g), ho(d);
          }, f.prototype.leaveEmphasis = function(p, g) {
            $s(p, g), ho(d);
          }, f.prototype.enterBlur = function(p) {
            i6(p), ho(d);
          }, f.prototype.leaveBlur = function(p) {
            vM(p), ho(d);
          }, f.prototype.enterSelect = function(p) {
            o6(p), ho(d);
          }, f.prototype.leaveSelect = function(p) {
            a6(p), ho(d);
          }, f.prototype.getModel = function() {
            return d.getModel();
          }, f.prototype.getViewOfComponentModel = function(p) {
            return d.getViewOfComponentModel(p);
          }, f.prototype.getViewOfSeriesModel = function(p) {
            return d.getViewOfSeriesModel(p);
          }, f;
        }(nW))(d);
      }, QW = function(d) {
        function h(f, p) {
          for (var g = 0; g < f.length; g++) {
            var v = f[g];
            v[d1] = p;
          }
        }
        B(og, function(f, p) {
          d._messageCenter.on(p, function(g) {
            if (hC[d.group] && d[d1] !== FN) {
              if (g && g.escapeConnect)
                return;
              var v = d.makeActionFromEvent(g), m = [];
              B(gc, function(y) {
                y !== d && y.group === d.group && m.push(y);
              }), h(m, FN), B(m, function(y) {
                y[d1] !== pSe && y.dispatchAction(v);
              }), h(m, gSe);
            }
          });
        });
      };
    }(), t;
  }(Go)
), KM = uC.prototype;
KM.on = KW("on");
KM.off = KW("off");
KM.one = function(e, t, r) {
  var n = this;
  No("ECharts#one is deprecated.");
  function i() {
    for (var o = [], a = 0; a < arguments.length; a++)
      o[a] = arguments[a];
    t && t.apply && t.apply(this, o), n.off(e, i);
  }
  this.on.call(this, e, i, r);
};
var vSe = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function Ki(e) {
  process.env.NODE_ENV !== "production" && Vr("Instance " + e + " has been disposed");
}
var cC = {}, og = {}, w_ = [], b_ = [], dC = [], JW = {}, x_ = {}, gc = {}, hC = {}, mSe = +/* @__PURE__ */ new Date() - 0, ySe = +/* @__PURE__ */ new Date() - 0, YM = "_echarts_instance_";
function CSe(e, t, r) {
  var n = !(r && r.ssr);
  if (n) {
    if (process.env.NODE_ENV !== "production" && !e)
      throw new Error("Initialize failed: invalid dom.");
    var i = qM(e);
    if (i)
      return process.env.NODE_ENV !== "production" && Vr("There is a chart instance already initialized on the dom."), i;
    process.env.NODE_ENV !== "production" && zl(e) && e.nodeName.toUpperCase() !== "CANVAS" && (!e.clientWidth && (!r || r.width == null) || !e.clientHeight && (!r || r.height == null)) && Vr("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var o = new uC(e, t, r);
  return o.id = "ec_" + mSe++, gc[o.id] = o, n && k$(e, YM, o.id), QW(o), Jo.trigger("afterinit", o), o;
}
function SSe(e) {
  if (fe(e)) {
    var t = e;
    e = null, B(t, function(r) {
      r.group != null && (e = r.group);
    }), e = e || "g_" + ySe++, B(t, function(r) {
      r.group = e;
    });
  }
  return hC[e] = !0, e;
}
function e7(e) {
  hC[e] = !1;
}
var wSe = e7;
function bSe(e) {
  Fe(e) ? e = gc[e] : e instanceof uC || (e = qM(e)), e instanceof uC && !e.isDisposed() && e.dispose();
}
function qM(e) {
  return gc[_ve(e, YM)];
}
function xSe(e) {
  return gc[e];
}
function ZM(e, t) {
  JW[e] = t;
}
function XM(e) {
  bt(b_, e) < 0 && b_.push(e);
}
function QM(e, t) {
  JM(w_, e, t, sSe);
}
function t7(e) {
  JS("afterinit", e);
}
function r7(e) {
  JS("afterupdate", e);
}
function JS(e, t) {
  Jo.on(e, t);
}
function wa(e, t, r) {
  Ye(t) && (r = t, t = "");
  var n = Ze(e) ? e.type : [e, e = {
    event: t
  }][0];
  e.event = (e.event || n).toLowerCase(), t = e.event, !og[t] && (Qe(IN.test(n) && IN.test(t)), cC[n] || (cC[n] = {
    action: r,
    actionInfo: e
  }), og[t] = n);
}
function n7(e, t) {
  Yc.register(e, t);
}
function ESe(e) {
  var t = Yc.get(e);
  if (t)
    return t.getDimensionsInfo ? t.getDimensionsInfo() : t.dimensions.slice();
}
function i7(e, t) {
  JM(dC, e, t, $W, "layout");
}
function au(e, t) {
  JM(dC, e, t, WW, "visual");
}
var BN = [];
function JM(e, t, r, n, i) {
  if ((Ye(t) || Ze(t)) && (r = t, t = n), process.env.NODE_ENV !== "production") {
    if (isNaN(t) || t == null)
      throw new Error("Illegal priority");
    B(e, function(a) {
      Qe(a.__raw !== r);
    });
  }
  if (!(bt(BN, r) >= 0)) {
    BN.push(r);
    var o = DW.wrapStageHandler(r, i);
    o.__prio = t, o.__raw = r, e.push(o);
  }
}
function eD(e, t) {
  x_[e] = t;
}
function RSe(e) {
  process.env.NODE_ENV !== "production" && No("setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead."), $3({
    createCanvas: e
  });
}
function o7(e, t, r) {
  var n = zW("registerMap");
  n && n(e, t, r);
}
function _Se(e) {
  var t = zW("getMap");
  return t && t(e);
}
var a7 = V0e;
au(UM, uCe);
au(QS, cCe);
au(QS, dCe);
au(UM, ECe);
au(QS, RCe);
au(jW, JCe);
XM(oW);
QM(oSe, y0e);
eD("default", hCe);
wa({
  type: fc,
  event: fc,
  update: fc
}, Kr);
wa({
  type: t0,
  event: t0,
  update: t0
}, Kr);
wa({
  type: eg,
  event: eg,
  update: eg
}, Kr);
wa({
  type: r0,
  event: r0,
  update: r0
}, Kr);
wa({
  type: tg,
  event: tg,
  update: tg
}, Kr);
ZM("light", bCe);
ZM("dark", LW);
var TSe = {}, GN = [], PSe = {
  registerPreprocessor: XM,
  registerProcessor: QM,
  registerPostInit: t7,
  registerPostUpdate: r7,
  registerUpdateLifecycle: JS,
  registerAction: wa,
  registerCoordinateSystem: n7,
  registerLayout: i7,
  registerVisual: au,
  registerTransform: a7,
  registerLoading: eD,
  registerMap: o7,
  registerImpl: eSe,
  PRIORITY: UW,
  ComponentModel: Rt,
  ComponentView: Rr,
  SeriesModel: hr,
  ChartView: ar,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(e) {
    Rt.registerClass(e);
  },
  registerComponentView: function(e) {
    Rr.registerClass(e);
  },
  registerSeriesModel: function(e) {
    hr.registerClass(e);
  },
  registerChartView: function(e) {
    ar.registerClass(e);
  },
  registerSubTypeDefaulter: function(e, t) {
    Rt.registerSubTypeDefaulter(e, t);
  },
  registerPainter: function(e, t) {
    R$(e, t);
  }
};
function _t(e) {
  if (fe(e)) {
    B(e, function(t) {
      _t(t);
    });
    return;
  }
  bt(GN, e) >= 0 || (GN.push(e), Ye(e) && (e = {
    install: e
  }), e.install(PSe));
}
function ip(e) {
  return e == null ? 0 : e.length || 1;
}
function HN(e) {
  return e;
}
var Ws = (
  /** @class */
  function() {
    function e(t, r, n, i, o, a) {
      this._old = t, this._new = r, this._oldKeyGetter = n || HN, this._newKeyGetter = i || HN, this.context = o, this._diffModeMultiple = a === "multiple";
    }
    return e.prototype.add = function(t) {
      return this._add = t, this;
    }, e.prototype.update = function(t) {
      return this._update = t, this;
    }, e.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, e.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, e.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, e.prototype.remove = function(t) {
      return this._remove = t, this;
    }, e.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, e.prototype._executeOneToOne = function() {
      var t = this._old, r = this._new, n = {}, i = new Array(t.length), o = new Array(r.length);
      this._initIndexMap(t, null, i, "_oldKeyGetter"), this._initIndexMap(r, n, o, "_newKeyGetter");
      for (var a = 0; a < t.length; a++) {
        var s = i[a], l = n[s], u = ip(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[s] = l[0]), this._update && this._update(c, a);
        } else u === 1 ? (n[s] = null, this._update && this._update(l, a)) : this._remove && this._remove(a);
      }
      this._performRestAdd(o, n);
    }, e.prototype._executeMultiple = function() {
      var t = this._old, r = this._new, n = {}, i = {}, o = [], a = [];
      this._initIndexMap(t, n, o, "_oldKeyGetter"), this._initIndexMap(r, i, a, "_newKeyGetter");
      for (var s = 0; s < o.length; s++) {
        var l = o[s], u = n[l], c = i[l], d = ip(u), h = ip(c);
        if (d > 1 && h === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), i[l] = null;
        else if (d === 1 && h > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), i[l] = null;
        else if (d === 1 && h === 1)
          this._update && this._update(c, u), i[l] = null;
        else if (d > 1 && h > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), i[l] = null;
        else if (d > 1)
          for (var f = 0; f < d; f++)
            this._remove && this._remove(u[f]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(a, i);
    }, e.prototype._performRestAdd = function(t, r) {
      for (var n = 0; n < t.length; n++) {
        var i = t[n], o = r[i], a = ip(o);
        if (a > 1)
          for (var s = 0; s < a; s++)
            this._add && this._add(o[s]);
        else a === 1 && this._add && this._add(o);
        r[i] = null;
      }
    }, e.prototype._initIndexMap = function(t, r, n, i) {
      for (var o = this._diffModeMultiple, a = 0; a < t.length; a++) {
        var s = "_ec_" + this[i](t[a], a);
        if (o || (n[a] = s), !!r) {
          var l = r[s], u = ip(l);
          u === 0 ? (r[s] = a, o && n.push(s)) : u === 1 ? r[s] = [l, a] : l.push(a);
        }
      }
    }, e;
  }()
), MSe = (
  /** @class */
  function() {
    function e(t, r) {
      this._encode = t, this._schema = r;
    }
    return e.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, e.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, e;
  }()
);
function DSe(e, t) {
  var r = {}, n = r.encode = {}, i = We(), o = [], a = [], s = {};
  B(e.dimensions, function(h) {
    var f = e.getDimensionInfo(h), p = f.coordDim;
    if (p) {
      process.env.NODE_ENV !== "production" && Qe(c_.get(p) == null);
      var g = f.coordDimIndex;
      m1(n, p)[g] = h, f.isExtraCoord || (i.set(p, 1), ASe(f.type) && (o[0] = h), m1(s, p)[g] = e.getDimensionIndex(f.name)), f.defaultTooltip && a.push(h);
    }
    c_.each(function(v, m) {
      var y = m1(n, m), C = f.otherDims[m];
      C != null && C !== !1 && (y[C] = f.name);
    });
  });
  var l = [], u = {};
  i.each(function(h, f) {
    var p = n[f];
    u[f] = p[0], l = l.concat(p);
  }), r.dataDimsOnCoord = l, r.dataDimIndicesOnCoord = ge(l, function(h) {
    return e.getDimensionInfo(h).storeDimIndex;
  }), r.encodeFirstDimNotExtra = u;
  var c = n.label;
  c && c.length && (o = c.slice());
  var d = n.tooltip;
  return d && d.length ? a = d.slice() : a.length || (a = o.slice()), n.defaultedLabel = o, n.defaultedTooltip = a, r.userOutput = new MSe(s, t), r;
}
function m1(e, t) {
  return e.hasOwnProperty(t) || (e[t] = []), e[t];
}
function fC(e) {
  return e === "category" ? "ordinal" : e === "time" ? "time" : "float";
}
function ASe(e) {
  return !(e === "ordinal" || e === "time");
}
var s0 = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.otherDims = {}, t != null && se(this, t);
    }
    return e;
  }()
), ISe = Gt(), FSe = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, s7 = (
  /** @class */
  function() {
    function e(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return e.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, e.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = c7(this.source)));
    }, e.prototype.getSourceDimensionIndex = function(t) {
      return st(this._dimNameMap.get(t), -1);
    }, e.prototype.getSourceDimension = function(t) {
      var r = this.source.dimensionsDefine;
      if (r)
        return r[t];
    }, e.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, r = sW(this.source), n = !d7(t), i = "", o = [], a = 0, s = 0; a < t; a++) {
        var l = void 0, u = void 0, c = void 0, d = this.dimensions[s];
        if (d && d.storeDimIndex === a)
          l = r ? d.name : null, u = d.type, c = d.ordinalMeta, s++;
        else {
          var h = this.getSourceDimension(a);
          h && (l = r ? h.name : null, u = h.type);
        }
        o.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), r && l != null && (!d || !d.isCalculationCoord) && (i += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += FSe[u] || "f", c && (i += c.uid), i += "$";
      }
      var f = this.source, p = [f.seriesLayoutBy, f.startIndex, i].join("$$");
      return {
        dimensions: o,
        hash: p
      };
    }, e.prototype.makeOutputDimensionNames = function() {
      for (var t = [], r = 0, n = 0; r < this._fullDimCount; r++) {
        var i = void 0, o = this.dimensions[n];
        if (o && o.storeDimIndex === r)
          o.isCalculationCoord || (i = o.name), n++;
        else {
          var a = this.getSourceDimension(r);
          a && (i = a.name);
        }
        t.push(i);
      }
      return t;
    }, e.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, e;
  }()
);
function l7(e) {
  return e instanceof s7;
}
function u7(e) {
  for (var t = We(), r = 0; r < (e || []).length; r++) {
    var n = e[r], i = Ze(n) ? n.name : n;
    i != null && t.get(i) == null && t.set(i, r);
  }
  return t;
}
function c7(e) {
  var t = ISe(e);
  return t.dimNameMap || (t.dimNameMap = u7(e.dimensionsDefine));
}
function d7(e) {
  return e > 30;
}
var op = Ze, hl = ge, LSe = typeof Int32Array > "u" ? Array : Int32Array, OSe = "e\0\0", zN = -1, NSe = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], kSe = ["_approximateExtent"], $N, qm, ap, Pd, y1, Zm, C1, VSe = (
  /** @class */
  function() {
    function e(t, r) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
      var n, i = !1;
      l7(t) ? (n = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (i = !0, n = t), n = n || ["x", "y"];
      for (var o = {}, a = [], s = {}, l = !1, u = {}, c = 0; c < n.length; c++) {
        var d = n[c], h = Fe(d) ? new s0({
          name: d
        }) : d instanceof s0 ? d : new s0(d), f = h.name;
        h.type = h.type || "float", h.coordDim || (h.coordDim = f, h.coordDimIndex = 0);
        var p = h.otherDims = h.otherDims || {};
        a.push(f), o[f] = h, u[f] != null && (l = !0), h.createInvertedIndices && (s[f] = []), p.itemName === 0 && (this._nameDimIdx = c), p.itemId === 0 && (this._idDimIdx = c), process.env.NODE_ENV !== "production" && Qe(i || h.storeDimIndex >= 0), i && (h.storeDimIndex = c);
      }
      if (this.dimensions = a, this._dimInfos = o, this._initGetDimensionInfo(l), this.hostModel = r, this._invertedIndicesMap = s, this._dimOmitted) {
        var g = this._dimIdxToName = We();
        B(a, function(v) {
          g.set(o[v].storeDimIndex, v);
        });
      }
    }
    return e.prototype.getDimension = function(t) {
      var r = this._recognizeDimIndex(t);
      if (r == null)
        return t;
      if (r = t, !this._dimOmitted)
        return this.dimensions[r];
      var n = this._dimIdxToName.get(r);
      if (n != null)
        return n;
      var i = this._schema.getSourceDimension(r);
      if (i)
        return i.name;
    }, e.prototype.getDimensionIndex = function(t) {
      var r = this._recognizeDimIndex(t);
      if (r != null)
        return r;
      if (t == null)
        return -1;
      var n = this._getDimInfo(t);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, e.prototype._recognizeDimIndex = function(t) {
      if ($t(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        return +t;
    }, e.prototype._getStoreDimIndex = function(t) {
      var r = this.getDimensionIndex(t);
      if (process.env.NODE_ENV !== "production" && r == null)
        throw new Error("Unknown dimension " + t);
      return r;
    }, e.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, e.prototype._initGetDimensionInfo = function(t) {
      var r = this._dimInfos;
      this._getDimInfo = t ? function(n) {
        return r.hasOwnProperty(n) ? r[n] : void 0;
      } : function(n) {
        return r[n];
      };
    }, e.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, e.prototype.mapDimension = function(t, r) {
      var n = this._dimSummary;
      if (r == null)
        return n.encodeFirstDimNotExtra[t];
      var i = n.encode[t];
      return i ? i[r] : null;
    }, e.prototype.mapDimensionsAll = function(t) {
      var r = this._dimSummary, n = r.encode[t];
      return (n || []).slice();
    }, e.prototype.getStore = function() {
      return this._store;
    }, e.prototype.initData = function(t, r, n) {
      var i = this, o;
      if (t instanceof p_ && (o = t), !o) {
        var a = this.dimensions, s = BM(t) || kn(t) ? new lW(t, a.length) : t;
        o = new p_();
        var l = hl(a, function(u) {
          return {
            type: i._dimInfos[u].type,
            property: u
          };
        });
        o.initData(s, l, n);
      }
      this._store = o, this._nameList = (r || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, o.count()), this._dimSummary = DSe(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, e.prototype.appendData = function(t) {
      var r = this._store.appendData(t);
      this._doInit(r[0], r[1]);
    }, e.prototype.appendValues = function(t, r) {
      var n = this._store.appendValues(t, r.length), i = n.start, o = n.end, a = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), r)
        for (var s = i; s < o; s++) {
          var l = s - i;
          this._nameList[s] = r[l], a && C1(this, s);
        }
    }, e.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, r = this.dimensions, n = 0; n < r.length; n++) {
        var i = this._dimInfos[r[n]];
        i.ordinalMeta && t.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta);
      }
    }, e.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== As && !t.fillStorage;
    }, e.prototype._doInit = function(t, r) {
      if (!(t >= r)) {
        var n = this._store, i = n.getProvider();
        this._updateOrdinalMeta();
        var o = this._nameList, a = this._idList, s = i.getSource().sourceFormat, l = s === zo;
        if (l && !i.pure)
          for (var u = [], c = t; c < r; c++) {
            var d = i.getItem(c, u);
            if (!this.hasItemOption && fve(d) && (this.hasItemOption = !0), d) {
              var h = d.name;
              o[c] == null && h != null && (o[c] = vn(h, null));
              var f = d.id;
              a[c] == null && f != null && (a[c] = vn(f, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = t; c < r; c++)
            C1(this, c);
        $N(this);
      }
    }, e.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.setApproximateExtent = function(t, r) {
      r = this.getDimension(r), this._approximateExtent[r] = t.slice();
    }, e.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, e.prototype.setCalculationInfo = function(t, r) {
      op(t) ? se(this._calculationInfo, t) : this._calculationInfo[t] = r;
    }, e.prototype.getName = function(t) {
      var r = this.getRawIndex(t), n = this._nameList[r];
      return n == null && this._nameDimIdx != null && (n = ap(this, this._nameDimIdx, r)), n == null && (n = ""), n;
    }, e.prototype._getCategory = function(t, r) {
      var n = this._store.get(t, r), i = this._store.getOrdinalMeta(t);
      return i ? i.categories[n] : n;
    }, e.prototype.getId = function(t) {
      return qm(this, this.getRawIndex(t));
    }, e.prototype.count = function() {
      return this._store.count();
    }, e.prototype.get = function(t, r) {
      var n = this._store, i = this._dimInfos[t];
      if (i)
        return n.get(i.storeDimIndex, r);
    }, e.prototype.getByRawIndex = function(t, r) {
      var n = this._store, i = this._dimInfos[t];
      if (i)
        return n.getByRawIndex(i.storeDimIndex, r);
    }, e.prototype.getIndices = function() {
      return this._store.getIndices();
    }, e.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, e.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, e.prototype.getValues = function(t, r) {
      var n = this, i = this._store;
      return fe(t) ? i.getValues(hl(t, function(o) {
        return n._getStoreDimIndex(o);
      }), r) : i.getValues(t);
    }, e.prototype.hasValue = function(t) {
      for (var r = this._dimSummary.dataDimIndicesOnCoord, n = 0, i = r.length; n < i; n++)
        if (isNaN(this._store.get(r[n], t)))
          return !1;
      return !0;
    }, e.prototype.indexOfName = function(t) {
      for (var r = 0, n = this._store.count(); r < n; r++)
        if (this.getName(r) === t)
          return r;
      return -1;
    }, e.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, e.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, e.prototype.rawIndexOf = function(t, r) {
      var n = t && this._invertedIndicesMap[t];
      if (process.env.NODE_ENV !== "production" && !n)
        throw new Error("Do not supported yet");
      var i = n[r];
      return i == null || isNaN(i) ? zN : i;
    }, e.prototype.indicesOfNearest = function(t, r, n) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(t), r, n);
    }, e.prototype.each = function(t, r, n) {
      Ye(t) && (n = r, r = t, t = []);
      var i = n || this, o = hl(Pd(t), this._getStoreDimIndex, this);
      this._store.each(o, i ? ke(r, i) : r);
    }, e.prototype.filterSelf = function(t, r, n) {
      Ye(t) && (n = r, r = t, t = []);
      var i = n || this, o = hl(Pd(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(o, i ? ke(r, i) : r), this;
    }, e.prototype.selectRange = function(t) {
      var r = this, n = {}, i = At(t);
      return B(i, function(o) {
        var a = r._getStoreDimIndex(o);
        n[a] = t[o];
      }), this._store = this._store.selectRange(n), this;
    }, e.prototype.mapArray = function(t, r, n) {
      Ye(t) && (n = r, r = t, t = []), n = n || this;
      var i = [];
      return this.each(t, function() {
        i.push(r && r.apply(this, arguments));
      }, n), i;
    }, e.prototype.map = function(t, r, n, i) {
      var o = n || i || this, a = hl(Pd(t), this._getStoreDimIndex, this), s = Zm(this);
      return s._store = this._store.map(a, o ? ke(r, o) : r), s;
    }, e.prototype.modify = function(t, r, n, i) {
      var o = this, a = n || i || this;
      process.env.NODE_ENV !== "production" && B(Pd(t), function(l) {
        var u = o.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var s = hl(Pd(t), this._getStoreDimIndex, this);
      this._store.modify(s, a ? ke(r, a) : r);
    }, e.prototype.downSample = function(t, r, n, i) {
      var o = Zm(this);
      return o._store = this._store.downSample(this._getStoreDimIndex(t), r, n, i), o;
    }, e.prototype.lttbDownSample = function(t, r) {
      var n = Zm(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), r), n;
    }, e.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, e.prototype.getItemModel = function(t) {
      var r = this.hostModel, n = this.getRawDataItem(t);
      return new cr(n, r, r && r.ecModel);
    }, e.prototype.diff = function(t) {
      var r = this;
      return new Ws(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return qm(t, n);
      }, function(n) {
        return qm(r, n);
      });
    }, e.prototype.getVisual = function(t) {
      var r = this._visual;
      return r && r[t];
    }, e.prototype.setVisual = function(t, r) {
      this._visual = this._visual || {}, op(t) ? se(this._visual, t) : this._visual[t] = r;
    }, e.prototype.getItemVisual = function(t, r) {
      var n = this._itemVisuals[t], i = n && n[r];
      return i ?? this.getVisual(r);
    }, e.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, e.prototype.ensureUniqueItemVisual = function(t, r) {
      var n = this._itemVisuals, i = n[t];
      i || (i = n[t] = {});
      var o = i[r];
      return o == null && (o = this.getVisual(r), fe(o) ? o = o.slice() : op(o) && (o = se({}, o)), i[r] = o), o;
    }, e.prototype.setItemVisual = function(t, r, n) {
      var i = this._itemVisuals[t] || {};
      this._itemVisuals[t] = i, op(r) ? se(i, r) : i[r] = n;
    }, e.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, e.prototype.setLayout = function(t, r) {
      op(t) ? se(this._layout, t) : this._layout[t] = r;
    }, e.prototype.getLayout = function(t) {
      return this._layout[t];
    }, e.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, e.prototype.setItemLayout = function(t, r, n) {
      this._itemLayouts[t] = n ? se(this._itemLayouts[t] || {}, r) : r;
    }, e.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, e.prototype.setItemGraphicEl = function(t, r) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      e_(n, this.dataType, t, r), this._graphicEls[t] = r;
    }, e.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, e.prototype.eachItemGraphicEl = function(t, r) {
      B(this._graphicEls, function(n, i) {
        n && t && t.call(r, n, i);
      });
    }, e.prototype.cloneShallow = function(t) {
      return t || (t = new e(this._schema ? this._schema : hl(this.dimensions, this._getDimInfo, this), this.hostModel)), y1(t, this), t._store = this._store, t;
    }, e.prototype.wrapMethod = function(t, r) {
      var n = this[t];
      Ye(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var i = n.apply(this, arguments);
        return r.apply(this, [i].concat(bS(arguments)));
      });
    }, e.internalField = function() {
      $N = function(t) {
        var r = t._invertedIndicesMap;
        B(r, function(n, i) {
          var o = t._dimInfos[i], a = o.ordinalMeta, s = t._store;
          if (a) {
            n = r[i] = new LSe(a.categories.length);
            for (var l = 0; l < n.length; l++)
              n[l] = zN;
            for (var l = 0; l < s.count(); l++)
              n[s.get(o.storeDimIndex, l)] = l;
          }
        });
      }, ap = function(t, r, n) {
        return vn(t._getCategory(r, n), null);
      }, qm = function(t, r) {
        var n = t._idList[r];
        return n == null && t._idDimIdx != null && (n = ap(t, t._idDimIdx, r)), n == null && (n = OSe + r), n;
      }, Pd = function(t) {
        return fe(t) || (t = t != null ? [t] : []), t;
      }, Zm = function(t) {
        var r = new e(t._schema ? t._schema : hl(t.dimensions, t._getDimInfo, t), t.hostModel);
        return y1(r, t), r;
      }, y1 = function(t, r) {
        B(NSe.concat(r.__wrappedMethods || []), function(n) {
          r.hasOwnProperty(n) && (t[n] = r[n]);
        }), t.__wrappedMethods = r.__wrappedMethods, B(kSe, function(n) {
          t[n] = et(r[n]);
        }), t._calculationInfo = se({}, r._calculationInfo);
      }, C1 = function(t, r) {
        var n = t._nameList, i = t._idList, o = t._nameDimIdx, a = t._idDimIdx, s = n[r], l = i[r];
        if (s == null && o != null && (n[r] = s = ap(t, o, r)), l == null && a != null && (i[r] = l = ap(t, a, r)), l == null && s != null) {
          var u = t._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), i[r] = l;
        }
      };
    }(), e;
  }()
);
const Jn = VSe;
function BSe(e, t) {
  return mf(e, t).dimensions;
}
function mf(e, t) {
  BM(e) || (e = GM(e)), t = t || {};
  var r = t.coordDimensions || [], n = t.dimensionsDefine || e.dimensionsDefine || [], i = We(), o = [], a = HSe(e, r, n, t.dimensionsCount), s = t.canOmitUnusedDimensions && d7(a), l = n === e.dimensionsDefine, u = l ? c7(e) : u7(n), c = t.encodeDefine;
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(e, a));
  for (var d = We(c), h = new vW(a), f = 0; f < h.length; f++)
    h[f] = -1;
  function p(R) {
    var _ = h[R];
    if (_ < 0) {
      var P = n[R], D = Ze(P) ? P : {
        name: P
      }, I = new s0(), A = D.name;
      A != null && u.get(A) != null && (I.name = I.displayName = A), D.type != null && (I.type = D.type), D.displayName != null && (I.displayName = D.displayName);
      var O = o.length;
      return h[R] = O, I.storeDimIndex = R, o.push(I), I;
    }
    return o[_];
  }
  if (!s)
    for (var f = 0; f < a; f++)
      p(f);
  d.each(function(R, _) {
    var P = dr(R).slice();
    if (P.length === 1 && !Fe(P[0]) && P[0] < 0) {
      d.set(_, !1);
      return;
    }
    var D = d.set(_, []);
    B(P, function(I, A) {
      var O = Fe(I) ? u.get(I) : I;
      O != null && O < a && (D[A] = O, v(p(O), _, A));
    });
  });
  var g = 0;
  B(r, function(R) {
    var _, P, D, I;
    if (Fe(R))
      _ = R, I = {};
    else {
      I = R, _ = I.name;
      var A = I.ordinalMeta;
      I.ordinalMeta = null, I = se({}, I), I.ordinalMeta = A, P = I.dimsDef, D = I.otherDims, I.name = I.coordDim = I.coordDimIndex = I.dimsDef = I.otherDims = null;
    }
    var O = d.get(_);
    if (O !== !1) {
      if (O = dr(O), !O.length)
        for (var L = 0; L < (P && P.length || 1); L++) {
          for (; g < a && p(g).coordDim != null; )
            g++;
          g < a && O.push(g++);
        }
      B(O, function(N, F) {
        var G = p(N);
        if (l && I.type != null && (G.type = I.type), v(Xe(G, I), _, F), G.name == null && P) {
          var M = P[F];
          !Ze(M) && (M = {
            name: M
          }), G.name = G.displayName = M.name, G.defaultTooltip = M.defaultTooltip;
        }
        D && Xe(G.otherDims, D);
      });
    }
  });
  function v(R, _, P) {
    c_.get(_) != null ? R.otherDims[_] = P : (R.coordDim = _, R.coordDimIndex = P, i.set(_, !0));
  }
  var m = t.generateCoord, y = t.generateCoordCount, C = y != null;
  y = m ? y || 1 : 0;
  var S = m || "value";
  function b(R) {
    R.name == null && (R.name = R.coordDim);
  }
  if (s)
    B(o, function(R) {
      b(R);
    }), o.sort(function(R, _) {
      return R.storeDimIndex - _.storeDimIndex;
    });
  else
    for (var w = 0; w < a; w++) {
      var x = p(w), E = x.coordDim;
      E == null && (x.coordDim = zSe(S, i, C), x.coordDimIndex = 0, (!m || y <= 0) && (x.isExtraCoord = !0), y--), b(x), x.type == null && (eW(e, w) === Ln.Must || x.isExtraCoord && (x.otherDims.itemName != null || x.otherDims.seriesName != null)) && (x.type = "ordinal");
    }
  return GSe(o), new s7({
    source: e,
    dimensions: o,
    fullDimensionCount: a,
    dimensionOmitted: s
  });
}
function GSe(e) {
  for (var t = We(), r = 0; r < e.length; r++) {
    var n = e[r], i = n.name, o = t.get(i) || 0;
    o > 0 && (n.name = i + (o - 1)), o++, t.set(i, o);
  }
}
function HSe(e, t, r, n) {
  var i = Math.max(e.dimensionsDetectedCount || 1, t.length, r.length, n || 0);
  return B(t, function(o) {
    var a;
    Ze(o) && (a = o.dimsDef) && (i = Math.max(i, a.length));
  }), i;
}
function zSe(e, t, r) {
  if (r || t.hasKey(e)) {
    for (var n = 0; t.hasKey(e + n); )
      n++;
    e += n;
  }
  return t.set(e, !0), e;
}
var $Se = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.coordSysDims = [], this.axisMap = We(), this.categoryAxisMap = We(), this.coordSysName = t;
    }
    return e;
  }()
);
function WSe(e) {
  var t = e.get("coordinateSystem"), r = new $Se(t), n = jSe[t];
  if (n)
    return n(e, r, r.axisMap, r.categoryAxisMap), r;
}
var jSe = {
  cartesian2d: function(e, t, r, n) {
    var i = e.getReferringComponents("xAxis", un).models[0], o = e.getReferringComponents("yAxis", un).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!i)
        throw new Error('xAxis "' + tn(e.get("xAxisIndex"), e.get("xAxisId"), 0) + '" not found');
      if (!o)
        throw new Error('yAxis "' + tn(e.get("xAxisIndex"), e.get("yAxisId"), 0) + '" not found');
    }
    t.coordSysDims = ["x", "y"], r.set("x", i), r.set("y", o), Md(i) && (n.set("x", i), t.firstCategoryDimIndex = 0), Md(o) && (n.set("y", o), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  singleAxis: function(e, t, r, n) {
    var i = e.getReferringComponents("singleAxis", un).models[0];
    if (process.env.NODE_ENV !== "production" && !i)
      throw new Error("singleAxis should be specified.");
    t.coordSysDims = ["single"], r.set("single", i), Md(i) && (n.set("single", i), t.firstCategoryDimIndex = 0);
  },
  polar: function(e, t, r, n) {
    var i = e.getReferringComponents("polar", un).models[0], o = i.findAxisModel("radiusAxis"), a = i.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!a)
        throw new Error("angleAxis option not found");
      if (!o)
        throw new Error("radiusAxis option not found");
    }
    t.coordSysDims = ["radius", "angle"], r.set("radius", o), r.set("angle", a), Md(o) && (n.set("radius", o), t.firstCategoryDimIndex = 0), Md(a) && (n.set("angle", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  geo: function(e, t, r, n) {
    t.coordSysDims = ["lng", "lat"];
  },
  parallel: function(e, t, r, n) {
    var i = e.ecModel, o = i.getComponent("parallel", e.get("parallelIndex")), a = t.coordSysDims = o.dimensions.slice();
    B(o.parallelAxisIndex, function(s, l) {
      var u = i.getComponent("parallelAxis", s), c = a[l];
      r.set(c, u), Md(u) && (n.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
    });
  }
};
function Md(e) {
  return e.get("type") === "category";
}
function h7(e, t, r) {
  r = r || {};
  var n = r.byIndex, i = r.stackedCoordDimension, o, a, s;
  USe(t) ? o = t : (a = t.schema, o = a.dimensions, s = t.store);
  var l = !!(e && e.get("stack")), u, c, d, h;
  if (B(o, function(y, C) {
    Fe(y) && (o[C] = y = {
      name: y
    }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!i || i === y.coordDim) && (c = y));
  }), c && !n && !u && (n = !0), c) {
    d = "__\0ecstackresult_" + e.id, h = "__\0ecstackedover_" + e.id, u && (u.createInvertedIndices = !0);
    var f = c.coordDim, p = c.type, g = 0;
    B(o, function(y) {
      y.coordDim === f && g++;
    });
    var v = {
      name: d,
      coordDim: f,
      coordDimIndex: g,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: o.length
    }, m = {
      name: h,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: h,
      coordDimIndex: g + 1,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: o.length + 1
    };
    a ? (s && (v.storeDimIndex = s.ensureCalculationDimension(h, p), m.storeDimIndex = s.ensureCalculationDimension(d, p)), a.appendCalculationDimension(v), a.appendCalculationDimension(m)) : (o.push(v), o.push(m));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: h,
    stackResultDimension: d
  };
}
function USe(e) {
  return !l7(e.schema);
}
function js(e, t) {
  return !!t && t === e.getCalculationInfo("stackedDimension");
}
function tD(e, t) {
  return js(e, t) ? e.getCalculationInfo("stackResultDimension") : t;
}
function KSe(e, t) {
  var r = e.get("coordinateSystem"), n = Yc.get(r), i;
  return t && t.coordSysDims && (i = ge(t.coordSysDims, function(o) {
    var a = {
      name: o
    }, s = t.axisMap.get(o);
    if (s) {
      var l = s.get("type");
      a.type = fC(l);
    }
    return a;
  })), i || (i = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || ["x", "y"]), i;
}
function YSe(e, t, r) {
  var n, i;
  return r && B(e, function(o, a) {
    var s = o.coordDim, l = r.categoryAxisMap.get(s);
    l && (n == null && (n = a), o.ordinalMeta = l.getOrdinalMeta(), t && (o.createInvertedIndices = !0)), o.otherDims.itemName != null && (i = !0);
  }), !i && n != null && (e[n].otherDims.itemName = 0), n;
}
function os(e, t, r) {
  r = r || {};
  var n = t.getSourceManager(), i, o = !1;
  e ? (o = !0, i = GM(e)) : (i = n.getSource(), o = i.sourceFormat === zo);
  var a = WSe(t), s = KSe(t, a), l = r.useEncodeDefaulter, u = Ye(l) ? l : l ? dt(J6, s, t) : null, c = {
    coordDimensions: s,
    generateCoord: r.generateCoord,
    encodeDefine: t.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !o
  }, d = mf(i, c), h = YSe(d.dimensions, r.createInvertedIndices, a), f = o ? null : n.getSharedDataStore(d), p = h7(t, {
    schema: d,
    store: f
  }), g = new Jn(d, t);
  g.setCalculationInfo(p);
  var v = h != null && qSe(i) ? function(m, y, C, S) {
    return S === h ? C : this.defaultDimValueGetter(m, y, C, S);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    o ? i : f,
    null,
    v
  ), g;
}
function qSe(e) {
  if (e.sourceFormat === zo) {
    var t = ZSe(e.data || []);
    return !fe(nf(t));
  }
}
function ZSe(e) {
  for (var t = 0; t < e.length && e[t] == null; )
    t++;
  return e[t];
}
var as = (
  /** @class */
  function() {
    function e(t) {
      this._setting = t || {}, this._extent = [1 / 0, -1 / 0];
    }
    return e.prototype.getSetting = function(t) {
      return this._setting[t];
    }, e.prototype.unionExtent = function(t) {
      var r = this._extent;
      t[0] < r[0] && (r[0] = t[0]), t[1] > r[1] && (r[1] = t[1]);
    }, e.prototype.unionExtentFromData = function(t, r) {
      this.unionExtent(t.getApproximateExtent(r));
    }, e.prototype.getExtent = function() {
      return this._extent.slice();
    }, e.prototype.setExtent = function(t, r) {
      var n = this._extent;
      isNaN(t) || (n[0] = t), isNaN(r) || (n[1] = r);
    }, e.prototype.isInExtentRange = function(t) {
      return this._extent[0] <= t && this._extent[1] >= t;
    }, e.prototype.isBlank = function() {
      return this._isBlank;
    }, e.prototype.setBlank = function(t) {
      this._isBlank = t;
    }, e;
  }()
);
AS(as);
var XSe = 0, E_ = (
  /** @class */
  function() {
    function e(t) {
      this.categories = t.categories || [], this._needCollect = t.needCollect, this._deduplication = t.deduplication, this.uid = ++XSe;
    }
    return e.createByAxisModel = function(t) {
      var r = t.option, n = r.data, i = n && ge(n, QSe);
      return new e({
        categories: i,
        needCollect: !i,
        // deduplication is default in axis.
        deduplication: r.dedplication !== !1
      });
    }, e.prototype.getOrdinal = function(t) {
      return this._getOrCreateMap().get(t);
    }, e.prototype.parseAndCollect = function(t) {
      var r, n = this._needCollect;
      if (!Fe(t) && !n)
        return t;
      if (n && !this._deduplication)
        return r = this.categories.length, this.categories[r] = t, r;
      var i = this._getOrCreateMap();
      return r = i.get(t), r == null && (n ? (r = this.categories.length, this.categories[r] = t, i.set(t, r)) : r = NaN), r;
    }, e.prototype._getOrCreateMap = function() {
      return this._map || (this._map = We(this.categories));
    }, e;
  }()
);
function QSe(e) {
  return Ze(e) && e.value != null ? e.value : e + "";
}
function JSe(e) {
  var t = Math.pow(10, Tv(Math.abs(e))), r = Math.abs(e / t);
  return r === 0 || r === 1 || r === 2 || r === 3 || r === 5;
}
function R_(e) {
  return e.type === "interval" || e.type === "log";
}
function ewe(e, t, r, n) {
  var i = {}, o = e[1] - e[0], a = i.interval = sM(o / t, !0);
  r != null && a < r && (a = i.interval = r), n != null && a > n && (a = i.interval = n);
  var s = i.intervalPrecision = f7(a), l = i.niceTickExtent = [Gr(Math.ceil(e[0] / a) * a, s), Gr(Math.floor(e[1] / a) * a, s)];
  return twe(l, e), i;
}
function S1(e) {
  var t = Math.pow(10, Tv(e)), r = e / t;
  return r ? r === 2 ? r = 3 : r === 3 ? r = 5 : r *= 2 : r = 1, Gr(r * t);
}
function f7(e) {
  return oa(e) + 2;
}
function WN(e, t, r) {
  e[t] = Math.max(Math.min(e[t], r[1]), r[0]);
}
function twe(e, t) {
  !isFinite(e[0]) && (e[0] = t[0]), !isFinite(e[1]) && (e[1] = t[1]), WN(e, 0, t), WN(e, 1, t), e[0] > e[1] && (e[0] = e[1]);
}
function ew(e, t) {
  return e >= t[0] && e <= t[1];
}
function tw(e, t) {
  return t[1] === t[0] ? 0.5 : (e - t[0]) / (t[1] - t[0]);
}
function rw(e, t) {
  return e * (t[1] - t[0]) + t[0];
}
var nw = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      n.type = "ordinal";
      var i = n.getSetting("ordinalMeta");
      return i || (i = new E_({})), fe(i) && (i = new E_({
        categories: ge(i, function(o) {
          return Ze(o) ? o.value : o;
        })
      })), n._ordinalMeta = i, n._extent = n.getSetting("extent") || [0, i.categories.length - 1], n;
    }
    return t.prototype.parse = function(r) {
      return r == null ? NaN : Fe(r) ? this._ordinalMeta.getOrdinal(r) : Math.round(r);
    }, t.prototype.contain = function(r) {
      return r = this.parse(r), ew(r, this._extent) && this._ordinalMeta.categories[r] != null;
    }, t.prototype.normalize = function(r) {
      return r = this._getTickNumber(this.parse(r)), tw(r, this._extent);
    }, t.prototype.scale = function(r) {
      return r = Math.round(rw(r, this._extent)), this.getRawOrdinalNumber(r);
    }, t.prototype.getTicks = function() {
      for (var r = [], n = this._extent, i = n[0]; i <= n[1]; )
        r.push({
          value: i
        }), i++;
      return r;
    }, t.prototype.getMinorTicks = function(r) {
    }, t.prototype.setSortInfo = function(r) {
      if (r == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var n = r.ordinalNumbers, i = this._ordinalNumbersByTick = [], o = this._ticksByOrdinalNumber = [], a = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, n.length); a < l; ++a) {
        var u = n[a];
        i[a] = u, o[u] = a;
      }
      for (var c = 0; a < s; ++a) {
        for (; o[c] != null; )
          c++;
        i.push(c), o[c] = a;
      }
    }, t.prototype._getTickNumber = function(r) {
      var n = this._ticksByOrdinalNumber;
      return n && r >= 0 && r < n.length ? n[r] : r;
    }, t.prototype.getRawOrdinalNumber = function(r) {
      var n = this._ordinalNumbersByTick;
      return n && r >= 0 && r < n.length ? n[r] : r;
    }, t.prototype.getLabel = function(r) {
      if (!this.isBlank()) {
        var n = this.getRawOrdinalNumber(r.value), i = this._ordinalMeta.categories[n];
        return i == null ? "" : i + "";
      }
    }, t.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, t.prototype.unionExtentFromData = function(r, n) {
      this.unionExtent(r.getApproximateExtent(n));
    }, t.prototype.isInExtentRange = function(r) {
      return r = this._getTickNumber(r), this._extent[0] <= r && this._extent[1] >= r;
    }, t.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, t.prototype.calcNiceTicks = function() {
    }, t.prototype.calcNiceExtent = function() {
    }, t.type = "ordinal", t;
  }(as)
);
as.registerClass(nw);
var Du = Gr, Us = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "interval", r._interval = 0, r._intervalPrecision = 2, r;
    }
    return t.prototype.parse = function(r) {
      return r;
    }, t.prototype.contain = function(r) {
      return ew(r, this._extent);
    }, t.prototype.normalize = function(r) {
      return tw(r, this._extent);
    }, t.prototype.scale = function(r) {
      return rw(r, this._extent);
    }, t.prototype.setExtent = function(r, n) {
      var i = this._extent;
      isNaN(r) || (i[0] = parseFloat(r)), isNaN(n) || (i[1] = parseFloat(n));
    }, t.prototype.unionExtent = function(r) {
      var n = this._extent;
      r[0] < n[0] && (n[0] = r[0]), r[1] > n[1] && (n[1] = r[1]), this.setExtent(n[0], n[1]);
    }, t.prototype.getInterval = function() {
      return this._interval;
    }, t.prototype.setInterval = function(r) {
      this._interval = r, this._niceExtent = this._extent.slice(), this._intervalPrecision = f7(r);
    }, t.prototype.getTicks = function(r) {
      var n = this._interval, i = this._extent, o = this._niceExtent, a = this._intervalPrecision, s = [];
      if (!n)
        return s;
      var l = 1e4;
      i[0] < o[0] && (r ? s.push({
        value: Du(o[0] - n, a)
      }) : s.push({
        value: i[0]
      }));
      for (var u = o[0]; u <= o[1] && (s.push({
        value: u
      }), u = Du(u + n, a), u !== s[s.length - 1].value); )
        if (s.length > l)
          return [];
      var c = s.length ? s[s.length - 1].value : o[1];
      return i[1] > c && (r ? s.push({
        value: Du(c + n, a)
      }) : s.push({
        value: i[1]
      })), s;
    }, t.prototype.getMinorTicks = function(r) {
      for (var n = this.getTicks(!0), i = [], o = this.getExtent(), a = 1; a < n.length; a++) {
        for (var s = n[a], l = n[a - 1], u = 0, c = [], d = s.value - l.value, h = d / r; u < r - 1; ) {
          var f = Du(l.value + (u + 1) * h);
          f > o[0] && f < o[1] && c.push(f), u++;
        }
        i.push(c);
      }
      return i;
    }, t.prototype.getLabel = function(r, n) {
      if (r == null)
        return "";
      var i = n && n.precision;
      i == null ? i = oa(r.value) || 0 : i === "auto" && (i = this._intervalPrecision);
      var o = Du(r.value, i, !0);
      return AM(o);
    }, t.prototype.calcNiceTicks = function(r, n, i) {
      r = r || 5;
      var o = this._extent, a = o[1] - o[0];
      if (isFinite(a)) {
        a < 0 && (a = -a, o.reverse());
        var s = ewe(o, r, n, i);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, t.prototype.calcNiceExtent = function(r) {
      var n = this._extent;
      if (n[0] === n[1])
        if (n[0] !== 0) {
          var i = Math.abs(n[0]);
          r.fixMax || (n[1] += i / 2), n[0] -= i / 2;
        } else
          n[1] = 1;
      var o = n[1] - n[0];
      isFinite(o) || (n[0] = 0, n[1] = 1), this.calcNiceTicks(r.splitNumber, r.minInterval, r.maxInterval);
      var a = this._interval;
      r.fixMin || (n[0] = Du(Math.floor(n[0] / a) * a)), r.fixMax || (n[1] = Du(Math.ceil(n[1] / a) * a));
    }, t.prototype.setNiceExtent = function(r, n) {
      this._niceExtent = [r, n];
    }, t.type = "interval", t;
  }(as)
);
as.registerClass(Us);
var p7 = typeof Float32Array < "u", rwe = p7 ? Float32Array : Array;
function $a(e) {
  return fe(e) ? p7 ? new Float32Array(e) : e : new rwe(e);
}
var __ = "__ec_stack_";
function rD(e) {
  return e.get("stack") || __ + e.seriesIndex;
}
function nD(e) {
  return e.dim + e.index;
}
function nwe(e) {
  var t = [], r = e.axis, n = "axis0";
  if (r.type === "category") {
    for (var i = r.getBandWidth(), o = 0; o < e.count; o++)
      t.push(Xe({
        bandWidth: i,
        axisKey: n,
        stackId: __ + o
      }, e));
    for (var a = m7(t), s = [], o = 0; o < e.count; o++) {
      var l = a[n][__ + o];
      l.offsetCenter = l.offset + l.width / 2, s.push(l);
    }
    return s;
  }
}
function g7(e, t) {
  var r = [];
  return t.eachSeriesByType(e, function(n) {
    S7(n) && r.push(n);
  }), r;
}
function iwe(e) {
  var t = {};
  B(e, function(l) {
    var u = l.coordinateSystem, c = u.getBaseAxis();
    if (!(c.type !== "time" && c.type !== "value"))
      for (var d = l.getData(), h = c.dim + "_" + c.index, f = d.getDimensionIndex(d.mapDimension(c.dim)), p = d.getStore(), g = 0, v = p.count(); g < v; ++g) {
        var m = p.get(f, g);
        t[h] ? t[h].push(m) : t[h] = [m];
      }
  });
  var r = {};
  for (var n in t)
    if (t.hasOwnProperty(n)) {
      var i = t[n];
      if (i) {
        i.sort(function(l, u) {
          return l - u;
        });
        for (var o = null, a = 1; a < i.length; ++a) {
          var s = i[a] - i[a - 1];
          s > 0 && (o = o === null ? s : Math.min(o, s));
        }
        r[n] = o;
      }
    }
  return r;
}
function v7(e) {
  var t = iwe(e), r = [];
  return B(e, function(n) {
    var i = n.coordinateSystem, o = i.getBaseAxis(), a = o.getExtent(), s;
    if (o.type === "category")
      s = o.getBandWidth();
    else if (o.type === "value" || o.type === "time") {
      var l = o.dim + "_" + o.index, u = t[l], c = Math.abs(a[1] - a[0]), d = o.scale.getExtent(), h = Math.abs(d[1] - d[0]);
      s = u ? c / h * u : c;
    } else {
      var f = n.getData();
      s = Math.abs(a[1] - a[0]) / f.count();
    }
    var p = Ae(n.get("barWidth"), s), g = Ae(n.get("barMaxWidth"), s), v = Ae(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      n.get("barMinWidth") || (w7(n) ? 0.5 : 1),
      s
    ), m = n.get("barGap"), y = n.get("barCategoryGap");
    r.push({
      bandWidth: s,
      barWidth: p,
      barMaxWidth: g,
      barMinWidth: v,
      barGap: m,
      barCategoryGap: y,
      axisKey: nD(o),
      stackId: rD(n)
    });
  }), m7(r);
}
function m7(e) {
  var t = {};
  B(e, function(n, i) {
    var o = n.axisKey, a = n.bandWidth, s = t[o] || {
      bandWidth: a,
      remainedWidth: a,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    }, l = s.stacks;
    t[o] = s;
    var u = n.stackId;
    l[u] || s.autoWidthCount++, l[u] = l[u] || {
      width: 0,
      maxWidth: 0
    };
    var c = n.barWidth;
    c && !l[u].width && (l[u].width = c, c = Math.min(s.remainedWidth, c), s.remainedWidth -= c);
    var d = n.barMaxWidth;
    d && (l[u].maxWidth = d);
    var h = n.barMinWidth;
    h && (l[u].minWidth = h);
    var f = n.barGap;
    f != null && (s.gap = f);
    var p = n.barCategoryGap;
    p != null && (s.categoryGap = p);
  });
  var r = {};
  return B(t, function(n, i) {
    r[i] = {};
    var o = n.stacks, a = n.bandWidth, s = n.categoryGap;
    if (s == null) {
      var l = At(o).length;
      s = Math.max(35 - l * 4, 15) + "%";
    }
    var u = Ae(s, a), c = Ae(n.gap, 1), d = n.remainedWidth, h = n.autoWidthCount, f = (d - u) / (h + (h - 1) * c);
    f = Math.max(f, 0), B(o, function(m) {
      var y = m.maxWidth, C = m.minWidth;
      if (m.width) {
        var S = m.width;
        y && (S = Math.min(S, y)), C && (S = Math.max(S, C)), m.width = S, d -= S + c * S, h--;
      } else {
        var S = f;
        y && y < S && (S = Math.min(y, d)), C && C > S && (S = C), S !== f && (m.width = S, d -= S + c * S, h--);
      }
    }), f = (d - u) / (h + (h - 1) * c), f = Math.max(f, 0);
    var p = 0, g;
    B(o, function(m, y) {
      m.width || (m.width = f), g = m, p += m.width * (1 + c);
    }), g && (p -= g.width * c);
    var v = -p / 2;
    B(o, function(m, y) {
      r[i][y] = r[i][y] || {
        bandWidth: a,
        offset: v,
        width: m.width
      }, v += m.width * (1 + c);
    });
  }), r;
}
function owe(e, t, r) {
  if (e && t) {
    var n = e[nD(t)];
    return n != null && r != null ? n[rD(r)] : n;
  }
}
function y7(e, t) {
  var r = g7(e, t), n = v7(r);
  B(r, function(i) {
    var o = i.getData(), a = i.coordinateSystem, s = a.getBaseAxis(), l = rD(i), u = n[nD(s)][l], c = u.offset, d = u.width;
    o.setLayout({
      bandWidth: u.bandWidth,
      offset: c,
      size: d
    });
  });
}
function C7(e) {
  return {
    seriesType: e,
    plan: pf(),
    reset: function(t) {
      if (S7(t)) {
        var r = t.getData(), n = t.coordinateSystem, i = n.getBaseAxis(), o = n.getOtherAxis(i), a = r.getDimensionIndex(r.mapDimension(o.dim)), s = r.getDimensionIndex(r.mapDimension(i.dim)), l = t.get("showBackground", !0), u = r.mapDimension(o.dim), c = r.getCalculationInfo("stackResultDimension"), d = js(r, u) && !!r.getCalculationInfo("stackedOnSeries"), h = o.isHorizontal(), f = awe(i, o), p = w7(t), g = t.get("barMinHeight") || 0, v = c && r.getDimensionIndex(c), m = r.getLayout("size"), y = r.getLayout("offset");
        return {
          progress: function(C, S) {
            for (var b = C.count, w = p && $a(b * 3), x = p && l && $a(b * 3), E = p && $a(b), R = n.master.getRect(), _ = h ? R.width : R.height, P, D = S.getStore(), I = 0; (P = C.next()) != null; ) {
              var A = D.get(d ? v : a, P), O = D.get(s, P), L = f, N = void 0;
              d && (N = +A - D.get(a, P));
              var F = void 0, G = void 0, M = void 0, V = void 0;
              if (h) {
                var z = n.dataToPoint([A, O]);
                if (d) {
                  var k = n.dataToPoint([N, O]);
                  L = k[0];
                }
                F = L, G = z[1] + y, M = z[0] - L, V = m, Math.abs(M) < g && (M = (M < 0 ? -1 : 1) * g);
              } else {
                var z = n.dataToPoint([O, A]);
                if (d) {
                  var k = n.dataToPoint([O, N]);
                  L = k[1];
                }
                F = z[0] + y, G = L, M = m, V = z[1] - L, Math.abs(V) < g && (V = (V <= 0 ? -1 : 1) * g);
              }
              p ? (w[I] = F, w[I + 1] = G, w[I + 2] = h ? M : V, x && (x[I] = h ? R.x : F, x[I + 1] = h ? G : R.y, x[I + 2] = _), E[P] = P) : S.setItemLayout(P, {
                x: F,
                y: G,
                width: M,
                height: V
              }), I += 3;
            }
            p && S.setLayout({
              largePoints: w,
              largeDataIndices: E,
              largeBackgroundPoints: x,
              valueAxisHorizontal: h
            });
          }
        };
      }
    }
  };
}
function S7(e) {
  return e.coordinateSystem && e.coordinateSystem.type === "cartesian2d";
}
function w7(e) {
  return e.pipelineContext && e.pipelineContext.large;
}
function awe(e, t) {
  var r = t.model.get("startValue");
  return r || (r = 0), t.toGlobalCoord(t.dataToCoord(t.type === "log" ? r > 0 ? r : 1 : r));
}
var swe = function(e, t, r, n) {
  for (; r < n; ) {
    var i = r + n >>> 1;
    e[i][1] < t ? r = i + 1 : n = i;
  }
  return r;
}, iD = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "time", n;
    }
    return t.prototype.getLabel = function(r) {
      var n = this.getSetting("useUTC");
      return Lv(r.value, OO[Lye(mh(this._minLevelUnit))] || OO.second, n, this.getSetting("locale"));
    }, t.prototype.getFormattedLabel = function(r, n, i) {
      var o = this.getSetting("useUTC"), a = this.getSetting("locale");
      return Oye(r, n, i, a, o);
    }, t.prototype.getTicks = function() {
      var r = this._interval, n = this._extent, i = [];
      if (!r)
        return i;
      i.push({
        value: n[0],
        level: 0
      });
      var o = this.getSetting("useUTC"), a = pwe(this._minLevelUnit, this._approxInterval, o, n);
      return i = i.concat(a), i.push({
        value: n[1],
        level: 0
      }), i;
    }, t.prototype.calcNiceExtent = function(r) {
      var n = this._extent;
      if (n[0] === n[1] && (n[0] -= Ro, n[1] += Ro), n[1] === -1 / 0 && n[0] === 1 / 0) {
        var i = /* @__PURE__ */ new Date();
        n[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), n[0] = n[1] - Ro;
      }
      this.calcNiceTicks(r.splitNumber, r.minInterval, r.maxInterval);
    }, t.prototype.calcNiceTicks = function(r, n, i) {
      r = r || 10;
      var o = this._extent, a = o[1] - o[0];
      this._approxInterval = a / r, n != null && this._approxInterval < n && (this._approxInterval = n), i != null && this._approxInterval > i && (this._approxInterval = i);
      var s = Xm.length, l = Math.min(swe(Xm, this._approxInterval, 0, s), s - 1);
      this._interval = Xm[l][1], this._minLevelUnit = Xm[Math.max(l - 1, 0)][0];
    }, t.prototype.parse = function(r) {
      return $t(r) ? r : +io(r);
    }, t.prototype.contain = function(r) {
      return ew(this.parse(r), this._extent);
    }, t.prototype.normalize = function(r) {
      return tw(this.parse(r), this._extent);
    }, t.prototype.scale = function(r) {
      return rw(r, this._extent);
    }, t.type = "time", t;
  }(Us)
), Xm = [
  // Format                           interval
  ["second", PM],
  ["minute", MM],
  ["hour", ng],
  ["quarter-day", ng * 6],
  ["half-day", ng * 12],
  ["day", Ro * 1.2],
  ["half-week", Ro * 3.5],
  ["week", Ro * 7],
  ["month", Ro * 31],
  ["quarter", Ro * 95],
  ["half-year", LO / 2],
  ["year", LO]
  // 1Y
];
function lwe(e, t, r, n) {
  var i = io(t), o = io(r), a = function(p) {
    return NO(i, p, n) === NO(o, p, n);
  }, s = function() {
    return a("year");
  }, l = function() {
    return s() && a("month");
  }, u = function() {
    return l() && a("day");
  }, c = function() {
    return u() && a("hour");
  }, d = function() {
    return c() && a("minute");
  }, h = function() {
    return d() && a("second");
  }, f = function() {
    return h() && a("millisecond");
  };
  switch (e) {
    case "year":
      return s();
    case "month":
      return l();
    case "day":
      return u();
    case "hour":
      return c();
    case "minute":
      return d();
    case "second":
      return h();
    case "millisecond":
      return f();
  }
}
function uwe(e, t) {
  return e /= Ro, e > 16 ? 16 : e > 7.5 ? 7 : e > 3.5 ? 4 : e > 1.5 ? 2 : 1;
}
function cwe(e) {
  var t = 30 * Ro;
  return e /= t, e > 6 ? 6 : e > 3 ? 3 : e > 2 ? 2 : 1;
}
function dwe(e) {
  return e /= ng, e > 12 ? 12 : e > 6 ? 6 : e > 3.5 ? 4 : e > 2 ? 2 : 1;
}
function jN(e, t) {
  return e /= t ? MM : PM, e > 30 ? 30 : e > 20 ? 20 : e > 15 ? 15 : e > 10 ? 10 : e > 5 ? 5 : e > 2 ? 2 : 1;
}
function hwe(e) {
  return sM(e, !0);
}
function fwe(e, t, r) {
  var n = new Date(e);
  switch (mh(t)) {
    case "year":
    case "month":
      n[H6(r)](0);
    case "day":
      n[z6(r)](1);
    case "hour":
      n[$6(r)](0);
    case "minute":
      n[W6(r)](0);
    case "second":
      n[j6(r)](0), n[U6(r)](0);
  }
  return n.getTime();
}
function pwe(e, t, r, n) {
  var i = 1e4, o = B6, a = 0;
  function s(_, P, D, I, A, O, L) {
    for (var N = new Date(P), F = P, G = N[I](); F < D && F <= n[1]; )
      L.push({
        value: F
      }), G += _, N[A](G), F = N.getTime();
    L.push({
      value: F,
      notAdd: !0
    });
  }
  function l(_, P, D) {
    var I = [], A = !P.length;
    if (!lwe(mh(_), n[0], n[1], r)) {
      A && (P = [{
        // TODO Optimize. Not include so may ticks.
        value: fwe(new Date(n[0]), _, r)
      }, {
        value: n[1]
      }]);
      for (var O = 0; O < P.length - 1; O++) {
        var L = P[O].value, N = P[O + 1].value;
        if (L !== N) {
          var F = void 0, G = void 0, M = void 0, V = !1;
          switch (_) {
            case "year":
              F = Math.max(1, Math.round(t / Ro / 365)), G = DM(r), M = Nye(r);
              break;
            case "half-year":
            case "quarter":
            case "month":
              F = cwe(t), G = yh(r), M = H6(r);
              break;
            case "week":
            case "half-week":
            case "day":
              F = uwe(t), G = $S(r), M = z6(r), V = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              F = dwe(t), G = Bg(r), M = $6(r);
              break;
            case "minute":
              F = jN(t, !0), G = WS(r), M = W6(r);
              break;
            case "second":
              F = jN(t, !1), G = jS(r), M = j6(r);
              break;
            case "millisecond":
              F = hwe(t), G = US(r), M = U6(r);
              break;
          }
          s(F, L, N, G, M, V, I), _ === "year" && D.length > 1 && O === 0 && D.unshift({
            value: D[0].value - F
          });
        }
      }
      for (var O = 0; O < I.length; O++)
        D.push(I[O]);
      return I;
    }
  }
  for (var u = [], c = [], d = 0, h = 0, f = 0; f < o.length && a++ < i; ++f) {
    var p = mh(o[f]);
    if (Fye(o[f])) {
      l(o[f], u[u.length - 1] || [], c);
      var g = o[f + 1] ? mh(o[f + 1]) : null;
      if (p !== g) {
        if (c.length) {
          h = d, c.sort(function(_, P) {
            return _.value - P.value;
          });
          for (var v = [], m = 0; m < c.length; ++m) {
            var y = c[m].value;
            (m === 0 || c[m - 1].value !== y) && (v.push(c[m]), y >= n[0] && y <= n[1] && d++);
          }
          var C = (n[1] - n[0]) / t;
          if (d > C * 1.5 && h > C / 1.5 || (u.push(v), d > C || e === o[f]))
            break;
        }
        c = [];
      }
    }
  }
  process.env.NODE_ENV !== "production" && a >= i && Vr("Exceed safe limit.");
  for (var S = ir(ge(u, function(_) {
    return ir(_, function(P) {
      return P.value >= n[0] && P.value <= n[1] && !P.notAdd;
    });
  }), function(_) {
    return _.length > 0;
  }), b = [], w = S.length - 1, f = 0; f < S.length; ++f)
    for (var x = S[f], E = 0; E < x.length; ++E)
      b.push({
        value: x[E].value,
        level: w - f
      });
  b.sort(function(_, P) {
    return _.value - P.value;
  });
  for (var R = [], f = 0; f < b.length; ++f)
    (f === 0 || b[f].value !== b[f - 1].value) && R.push(b[f]);
  return R;
}
as.registerClass(iD);
var UN = as.prototype, ag = Us.prototype, gwe = Gr, vwe = Math.floor, mwe = Math.ceil, Qm = Math.pow, Yo = Math.log, oD = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "log", r.base = 10, r._originalScale = new Us(), r._interval = 0, r;
    }
    return t.prototype.getTicks = function(r) {
      var n = this._originalScale, i = this._extent, o = n.getExtent(), a = ag.getTicks.call(this, r);
      return ge(a, function(s) {
        var l = s.value, u = Gr(Qm(this.base, l));
        return u = l === i[0] && this._fixMin ? Jm(u, o[0]) : u, u = l === i[1] && this._fixMax ? Jm(u, o[1]) : u, {
          value: u
        };
      }, this);
    }, t.prototype.setExtent = function(r, n) {
      var i = Yo(this.base);
      r = Yo(Math.max(0, r)) / i, n = Yo(Math.max(0, n)) / i, ag.setExtent.call(this, r, n);
    }, t.prototype.getExtent = function() {
      var r = this.base, n = UN.getExtent.call(this);
      n[0] = Qm(r, n[0]), n[1] = Qm(r, n[1]);
      var i = this._originalScale, o = i.getExtent();
      return this._fixMin && (n[0] = Jm(n[0], o[0])), this._fixMax && (n[1] = Jm(n[1], o[1])), n;
    }, t.prototype.unionExtent = function(r) {
      this._originalScale.unionExtent(r);
      var n = this.base;
      r[0] = Yo(r[0]) / Yo(n), r[1] = Yo(r[1]) / Yo(n), UN.unionExtent.call(this, r);
    }, t.prototype.unionExtentFromData = function(r, n) {
      this.unionExtent(r.getApproximateExtent(n));
    }, t.prototype.calcNiceTicks = function(r) {
      r = r || 10;
      var n = this._extent, i = n[1] - n[0];
      if (!(i === 1 / 0 || i <= 0)) {
        var o = D$(i), a = r / i * o;
        for (a <= 0.5 && (o *= 10); !isNaN(o) && Math.abs(o) < 1 && Math.abs(o) > 0; )
          o *= 10;
        var s = [Gr(mwe(n[0] / o) * o), Gr(vwe(n[1] / o) * o)];
        this._interval = o, this._niceExtent = s;
      }
    }, t.prototype.calcNiceExtent = function(r) {
      ag.calcNiceExtent.call(this, r), this._fixMin = r.fixMin, this._fixMax = r.fixMax;
    }, t.prototype.parse = function(r) {
      return r;
    }, t.prototype.contain = function(r) {
      return r = Yo(r) / Yo(this.base), ew(r, this._extent);
    }, t.prototype.normalize = function(r) {
      return r = Yo(r) / Yo(this.base), tw(r, this._extent);
    }, t.prototype.scale = function(r) {
      return r = rw(r, this._extent), Qm(this.base, r);
    }, t.type = "log", t;
  }(as)
), b7 = oD.prototype;
b7.getMinorTicks = ag.getMinorTicks;
b7.getLabel = ag.getLabel;
function Jm(e, t) {
  return gwe(e, oa(t));
}
as.registerClass(oD);
var ywe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this._prepareParams(t, r, n);
    }
    return e.prototype._prepareParams = function(t, r, n) {
      n[1] < n[0] && (n = [NaN, NaN]), this._dataMin = n[0], this._dataMax = n[1];
      var i = this._isOrdinal = t.type === "ordinal";
      this._needCrossZero = t.type === "interval" && r.getNeedCrossZero && r.getNeedCrossZero();
      var o = r.get("min", !0);
      o == null && (o = r.get("startValue", !0));
      var a = this._modelMinRaw = o;
      Ye(a) ? this._modelMinNum = ey(t, a({
        min: n[0],
        max: n[1]
      })) : a !== "dataMin" && (this._modelMinNum = ey(t, a));
      var s = this._modelMaxRaw = r.get("max", !0);
      if (Ye(s) ? this._modelMaxNum = ey(t, s({
        min: n[0],
        max: n[1]
      })) : s !== "dataMax" && (this._modelMaxNum = ey(t, s)), i)
        this._axisDataLen = r.getCategories().length;
      else {
        var l = r.get("boundaryGap"), u = fe(l) ? l : [l || 0, l || 0];
        typeof u[0] == "boolean" || typeof u[1] == "boolean" ? (process.env.NODE_ENV !== "production" && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [ya(u[0], 1), ya(u[1], 1)];
      }
    }, e.prototype.calculate = function() {
      var t = this._isOrdinal, r = this._dataMin, n = this._dataMax, i = this._axisDataLen, o = this._boundaryGapInner, a = t ? null : n - r || Math.abs(r), s = this._modelMinRaw === "dataMin" ? r : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? n : this._modelMaxNum, u = s != null, c = l != null;
      s == null && (s = t ? i ? 0 : NaN : r - o[0] * a), l == null && (l = t ? i ? i - 1 : NaN : n + o[1] * a), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var d = $l(s) || $l(l) || t && !i;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0));
      var h = this._determinedMin, f = this._determinedMax;
      return h != null && (s = h, u = !0), f != null && (l = f, c = !0), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: d
      };
    }, e.prototype.modifyDataMinMax = function(t, r) {
      process.env.NODE_ENV !== "production" && Qe(!this.frozen), this[Swe[t]] = r;
    }, e.prototype.setDeterminedMinMax = function(t, r) {
      var n = Cwe[t];
      process.env.NODE_ENV !== "production" && Qe(!this.frozen && this[n] == null), this[n] = r;
    }, e.prototype.freeze = function() {
      this.frozen = !0;
    }, e;
  }()
), Cwe = {
  min: "_determinedMin",
  max: "_determinedMax"
}, Swe = {
  min: "_dataMin",
  max: "_dataMax"
};
function x7(e, t, r) {
  var n = e.rawExtentInfo;
  return n || (n = new ywe(e, t, r), e.rawExtentInfo = n, n);
}
function ey(e, t) {
  return t == null ? null : $l(t) ? NaN : e.parse(t);
}
function E7(e, t) {
  var r = e.type, n = x7(e, t, e.getExtent()).calculate();
  e.setBlank(n.isBlank);
  var i = n.min, o = n.max, a = t.ecModel;
  if (a && r === "time") {
    var s = g7("bar", a), l = !1;
    if (B(s, function(d) {
      l = l || d.getBaseAxis() === t.axis;
    }), l) {
      var u = v7(s), c = wwe(i, o, t, u);
      i = c.min, o = c.max;
    }
  }
  return {
    extent: [i, o],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: n.minFixed,
    fixMax: n.maxFixed
  };
}
function wwe(e, t, r, n) {
  var i = r.axis.getExtent(), o = i[1] - i[0], a = owe(n, r.axis);
  if (a === void 0)
    return {
      min: e,
      max: t
    };
  var s = 1 / 0;
  B(a, function(f) {
    s = Math.min(f.offset, s);
  });
  var l = -1 / 0;
  B(a, function(f) {
    l = Math.max(f.offset + f.width, l);
  }), s = Math.abs(s), l = Math.abs(l);
  var u = s + l, c = t - e, d = 1 - (s + l) / o, h = c / d - c;
  return t += h * (l / u), e -= h * (s / u), {
    min: e,
    max: t
  };
}
function Ic(e, t) {
  var r = t, n = E7(e, r), i = n.extent, o = r.get("splitNumber");
  e instanceof oD && (e.base = r.get("logBase"));
  var a = e.type, s = r.get("interval"), l = a === "interval" || a === "time";
  e.setExtent(i[0], i[1]), e.calcNiceExtent({
    splitNumber: o,
    fixMin: n.fixMin,
    fixMax: n.fixMax,
    minInterval: l ? r.get("minInterval") : null,
    maxInterval: l ? r.get("maxInterval") : null
  }), s != null && e.setInterval && e.setInterval(s);
}
function Nv(e, t) {
  if (t = t || e.get("type"), t)
    switch (t) {
      case "category":
        return new nw({
          ordinalMeta: e.getOrdinalMeta ? e.getOrdinalMeta() : e.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new iD({
          locale: e.ecModel.getLocaleModel(),
          useUTC: e.ecModel.get("useUTC")
        });
      default:
        return new (as.getClass(t) || Us)();
    }
}
function bwe(e) {
  var t = e.scale.getExtent(), r = t[0], n = t[1];
  return !(r > 0 && n > 0 || r < 0 && n < 0);
}
function yf(e) {
  var t = e.getLabelModel().get("formatter"), r = e.type === "category" ? e.scale.getExtent()[0] : null;
  return e.scale.type === "time" ? /* @__PURE__ */ function(n) {
    return function(i, o) {
      return e.scale.getFormattedLabel(i, o, n);
    };
  }(t) : Fe(t) ? /* @__PURE__ */ function(n) {
    return function(i) {
      var o = e.scale.getLabel(i), a = n.replace("{value}", o ?? "");
      return a;
    };
  }(t) : Ye(t) ? /* @__PURE__ */ function(n) {
    return function(i, o) {
      return r != null && (o = i.value - r), n(aD(e, i), o, i.level != null ? {
        level: i.level
      } : null);
    };
  }(t) : function(n) {
    return e.scale.getLabel(n);
  };
}
function aD(e, t) {
  return e.type === "category" ? e.scale.getLabel(t) : t.value;
}
function xwe(e) {
  var t = e.model, r = e.scale;
  if (!(!t.get(["axisLabel", "show"]) || r.isBlank())) {
    var n, i, o = r.getExtent();
    r instanceof nw ? i = r.count() : (n = r.getTicks(), i = n.length);
    var a = e.getLabelModel(), s = yf(e), l, u = 1;
    i > 40 && (u = Math.ceil(i / 40));
    for (var c = 0; c < i; c += u) {
      var d = n ? n[c] : {
        value: o[0] + c
      }, h = s(d, c), f = a.getTextRect(h), p = Ewe(f, a.get("rotate") || 0);
      l ? l.union(p) : l = p;
    }
    return l;
  }
}
function Ewe(e, t) {
  var r = t * Math.PI / 180, n = e.width, i = e.height, o = n * Math.abs(Math.cos(r)) + Math.abs(i * Math.sin(r)), a = n * Math.abs(Math.sin(r)) + Math.abs(i * Math.cos(r)), s = new St(e.x, e.y, o, a);
  return s;
}
function sD(e) {
  var t = e.get("interval");
  return t ?? "auto";
}
function R7(e) {
  return e.type === "category" && sD(e.getLabelModel()) === 0;
}
function pC(e, t) {
  var r = {};
  return B(e.mapDimensionsAll(t), function(n) {
    r[tD(e, n)] = !0;
  }), At(r);
}
function Rwe(e, t, r) {
  t && B(pC(t, r), function(n) {
    var i = t.getApproximateExtent(n);
    i[0] < e[0] && (e[0] = i[0]), i[1] > e[1] && (e[1] = i[1]);
  });
}
var Cf = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getNeedCrossZero = function() {
      var t = this.option;
      return !t.scale;
    }, e.prototype.getCoordSysModel = function() {
    }, e;
  }()
);
function _we(e) {
  return os(null, e);
}
var Twe = {
  isDimensionStacked: js,
  enableDataStack: h7,
  getStackedDimension: tD
};
function Pwe(e, t) {
  var r = t;
  t instanceof cr || (r = new cr(t));
  var n = Nv(r);
  return n.setExtent(e[0], e[1]), Ic(n, r), n;
}
function Mwe(e) {
  qr(e, Cf);
}
function Dwe(e, t) {
  return t = t || {}, br(e, null, null, t.state !== "normal");
}
const Awe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createDimensions: BSe,
  createList: _we,
  createScale: Pwe,
  createSymbol: rn,
  createTextStyle: Dwe,
  dataStack: Twe,
  enableHoverEmphasis: Fl,
  getECData: ot,
  getLayoutRect: hn,
  mixinAxisModelCommonMethods: Mwe
}, Symbol.toStringTag, { value: "Module" }));
var Iwe = 1e-8;
function KN(e, t) {
  return Math.abs(e - t) < Iwe;
}
function Uu(e, t, r) {
  var n = 0, i = e[0];
  if (!i)
    return !1;
  for (var o = 1; o < e.length; o++) {
    var a = e[o];
    n += Ss(i[0], i[1], a[0], a[1], t, r), i = a;
  }
  var s = e[0];
  return (!KN(i[0], s[0]) || !KN(i[1], s[1])) && (n += Ss(i[0], i[1], s[0], s[1], t, r)), n !== 0;
}
var Fwe = [];
function w1(e, t) {
  for (var r = 0; r < e.length; r++)
    An(e[r], e[r], t);
}
function YN(e, t, r, n) {
  for (var i = 0; i < e.length; i++) {
    var o = e[i];
    n && (o = n.project(o)), o && isFinite(o[0]) && isFinite(o[1]) && (Rs(t, t, o), _s(r, r, o));
  }
}
function Lwe(e) {
  for (var t = 0, r = 0, n = 0, i = e.length, o = e[i - 1][0], a = e[i - 1][1], s = 0; s < i; s++) {
    var l = e[s][0], u = e[s][1], c = o * u - l * a;
    t += c, r += (o + l) * c, n += (a + u) * c, o = l, a = u;
  }
  return t ? [r / t / 3, n / t / 3, t] : [e[0][0] || 0, e[0][1] || 0];
}
var _7 = (
  /** @class */
  function() {
    function e(t) {
      this.name = t;
    }
    return e.prototype.setCenter = function(t) {
      this._center = t;
    }, e.prototype.getCenter = function() {
      var t = this._center;
      return t || (t = this._center = this.calcCenter()), t;
    }, e;
  }()
), qN = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, r) {
      this.type = "polygon", this.exterior = t, this.interiors = r;
    }
    return e;
  }()
), ZN = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.type = "linestring", this.points = t;
    }
    return e;
  }()
), T7 = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i) {
      var o = e.call(this, r) || this;
      return o.type = "geoJSON", o.geometries = n, o._center = i && [i[0], i[1]], o;
    }
    return t.prototype.calcCenter = function() {
      for (var r = this.geometries, n, i = 0, o = 0; o < r.length; o++) {
        var a = r[o], s = a.exterior, l = s && s.length;
        l > i && (n = a, i = l);
      }
      if (n)
        return Lwe(n.exterior);
      var u = this.getBoundingRect();
      return [u.x + u.width / 2, u.y + u.height / 2];
    }, t.prototype.getBoundingRect = function(r) {
      var n = this._rect;
      if (n && !r)
        return n;
      var i = [1 / 0, 1 / 0], o = [-1 / 0, -1 / 0], a = this.geometries;
      return B(a, function(s) {
        s.type === "polygon" ? YN(s.exterior, i, o, r) : B(s.points, function(l) {
          YN(l, i, o, r);
        });
      }), isFinite(i[0]) && isFinite(i[1]) && isFinite(o[0]) && isFinite(o[1]) || (i[0] = i[1] = o[0] = o[1] = 0), n = new St(i[0], i[1], o[0] - i[0], o[1] - i[1]), r || (this._rect = n), n;
    }, t.prototype.contain = function(r) {
      var n = this.getBoundingRect(), i = this.geometries;
      if (!n.contain(r[0], r[1]))
        return !1;
      e: for (var o = 0, a = i.length; o < a; o++) {
        var s = i[o];
        if (s.type === "polygon") {
          var l = s.exterior, u = s.interiors;
          if (Uu(l, r[0], r[1])) {
            for (var c = 0; c < (u ? u.length : 0); c++)
              if (Uu(u[c], r[0], r[1]))
                continue e;
            return !0;
          }
        }
      }
      return !1;
    }, t.prototype.transformTo = function(r, n, i, o) {
      var a = this.getBoundingRect(), s = a.width / a.height;
      i ? o || (o = i / s) : i = s * o;
      for (var l = new St(r, n, i, o), u = a.calculateTransform(l), c = this.geometries, d = 0; d < c.length; d++) {
        var h = c[d];
        h.type === "polygon" ? (w1(h.exterior, u), B(h.interiors, function(f) {
          w1(f, u);
        })) : B(h.points, function(f) {
          w1(f, u);
        });
      }
      a = this._rect, a.copy(l), this._center = [a.x + a.width / 2, a.y + a.height / 2];
    }, t.prototype.cloneShallow = function(r) {
      r == null && (r = this.name);
      var n = new t(r, this.geometries, this._center);
      return n._rect = this._rect, n.transformTo = null, n;
    }, t;
  }(_7)
), Owe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n) {
      var i = e.call(this, r) || this;
      return i.type = "geoSVG", i._elOnlyForCalculate = n, i;
    }
    return t.prototype.calcCenter = function() {
      for (var r = this._elOnlyForCalculate, n = r.getBoundingRect(), i = [n.x + n.width / 2, n.y + n.height / 2], o = Ev(Fwe), a = r; a && !a.isGeoSVGGraphicRoot; )
        Ka(o, a.getLocalTransform(), o), a = a.parent;
      return Wc(o, o), An(i, i, o), i;
    }, t;
  }(_7)
);
function Nwe(e) {
  if (!e.UTF8Encoding)
    return e;
  var t = e, r = t.UTF8Scale;
  r == null && (r = 1024);
  var n = t.features;
  return B(n, function(i) {
    var o = i.geometry, a = o.encodeOffsets, s = o.coordinates;
    if (a)
      switch (o.type) {
        case "LineString":
          o.coordinates = P7(s, a, r);
          break;
        case "Polygon":
          b1(s, a, r);
          break;
        case "MultiLineString":
          b1(s, a, r);
          break;
        case "MultiPolygon":
          B(s, function(l, u) {
            return b1(l, a[u], r);
          });
      }
  }), t.UTF8Encoding = !1, t;
}
function b1(e, t, r) {
  for (var n = 0; n < e.length; n++)
    e[n] = P7(e[n], t[n], r);
}
function P7(e, t, r) {
  for (var n = [], i = t[0], o = t[1], a = 0; a < e.length; a += 2) {
    var s = e.charCodeAt(a) - 64, l = e.charCodeAt(a + 1) - 64;
    s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += o, i = s, o = l, n.push([s / r, l / r]);
  }
  return n;
}
function T_(e, t) {
  return e = Nwe(e), ge(ir(e.features, function(r) {
    return r.geometry && r.properties && r.geometry.coordinates.length > 0;
  }), function(r) {
    var n = r.properties, i = r.geometry, o = [];
    switch (i.type) {
      case "Polygon":
        var a = i.coordinates;
        o.push(new qN(a[0], a.slice(1)));
        break;
      case "MultiPolygon":
        B(i.coordinates, function(l) {
          l[0] && o.push(new qN(l[0], l.slice(1)));
        });
        break;
      case "LineString":
        o.push(new ZN([i.coordinates]));
        break;
      case "MultiLineString":
        o.push(new ZN(i.coordinates));
    }
    var s = new T7(n[t || "name"], o, n.cp);
    return s.properties = n, s;
  });
}
const kwe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MAX_SAFE_INTEGER: YR,
  asc: Ji,
  getPercentWithPrecision: sve,
  getPixelPrecision: oM,
  getPrecision: oa,
  getPrecisionSafe: K0,
  isNumeric: MS,
  isRadianAroundZero: Ah,
  linearMap: nr,
  nice: sM,
  numericToNumber: Ja,
  parseDate: io,
  quantile: e0,
  quantity: D$,
  quantityExponent: Tv,
  reformIntervals: qR,
  remRadian: aM,
  round: Gr
}, Symbol.toStringTag, { value: "Module" })), Vwe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  format: Lv,
  parse: io
}, Symbol.toStringTag, { value: "Module" })), Bwe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: VS,
  BezierCurve: Av,
  BoundingRect: St,
  Circle: Js,
  CompoundPath: BS,
  Ellipse: kS,
  Group: it,
  Image: In,
  IncrementalDisplayable: _6,
  Line: wn,
  LinearGradient: af,
  Polygon: Ei,
  Polyline: Ri,
  RadialGradient: CM,
  Rect: Bt,
  Ring: Dv,
  Sector: xi,
  Text: Vt,
  clipPointsByRect: xM,
  clipRectByRect: A6,
  createIcon: lf,
  extendPath: M6,
  extendShape: P6,
  getShapeClass: GS,
  getTransform: Ll,
  initProps: Pr,
  makeImage: wM,
  makePath: Iv,
  mergePath: Zi,
  registerShape: Ho,
  resizePath: bM,
  updateProps: jt
}, Symbol.toStringTag, { value: "Module" })), Gwe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addCommas: AM,
  capitalFirst: Gye,
  encodeHTML: fi,
  formatTime: Bye,
  formatTpl: FM,
  getTextRect: kye,
  getTooltipMarker: K6,
  normalizeCssArray: Kc,
  toCamelCase: IM,
  truncateText: H$
}, Symbol.toStringTag, { value: "Module" })), Hwe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bind: ke,
  clone: et,
  curry: dt,
  defaults: Xe,
  each: B,
  extend: se,
  filter: ir,
  indexOf: bt,
  inherits: ZP,
  isArray: fe,
  isFunction: Ye,
  isObject: Ze,
  isString: Fe,
  map: ge,
  merge: yt,
  reduce: Oo
}, Symbol.toStringTag, { value: "Module" }));
var jg = Gt();
function M7(e, t) {
  var r = ge(t, function(n) {
    return e.scale.parse(n);
  });
  return e.type === "time" && r.length > 0 && (r.sort(), r.unshift(r[0]), r.push(r[r.length - 1])), r;
}
function zwe(e) {
  var t = e.getLabelModel().get("customValues");
  if (t) {
    var r = yf(e);
    return {
      labels: M7(e, t).map(function(n) {
        var i = {
          value: n
        };
        return {
          formattedLabel: r(i),
          rawLabel: e.scale.getLabel(i),
          tickValue: n
        };
      })
    };
  }
  return e.type === "category" ? Wwe(e) : Uwe(e);
}
function $we(e, t) {
  var r = e.getTickModel().get("customValues");
  return r ? {
    ticks: M7(e, r)
  } : e.type === "category" ? jwe(e, t) : {
    ticks: ge(e.scale.getTicks(), function(n) {
      return n.value;
    })
  };
}
function Wwe(e) {
  var t = e.getLabelModel(), r = D7(e, t);
  return !t.get("show") || e.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: r.labelCategoryInterval
  } : r;
}
function D7(e, t) {
  var r = A7(e, "labels"), n = sD(t), i = I7(r, n);
  if (i)
    return i;
  var o, a;
  return Ye(n) ? o = O7(e, n) : (a = n === "auto" ? Kwe(e) : n, o = L7(e, a)), F7(r, n, {
    labels: o,
    labelCategoryInterval: a
  });
}
function jwe(e, t) {
  var r = A7(e, "ticks"), n = sD(t), i = I7(r, n);
  if (i)
    return i;
  var o, a;
  if ((!t.get("show") || e.scale.isBlank()) && (o = []), Ye(n))
    o = O7(e, n, !0);
  else if (n === "auto") {
    var s = D7(e, e.getLabelModel());
    a = s.labelCategoryInterval, o = ge(s.labels, function(l) {
      return l.tickValue;
    });
  } else
    a = n, o = L7(e, a, !0);
  return F7(r, n, {
    ticks: o,
    tickCategoryInterval: a
  });
}
function Uwe(e) {
  var t = e.scale.getTicks(), r = yf(e);
  return {
    labels: ge(t, function(n, i) {
      return {
        level: n.level,
        formattedLabel: r(n, i),
        rawLabel: e.scale.getLabel(n),
        tickValue: n.value
      };
    })
  };
}
function A7(e, t) {
  return jg(e)[t] || (jg(e)[t] = []);
}
function I7(e, t) {
  for (var r = 0; r < e.length; r++)
    if (e[r].key === t)
      return e[r].value;
}
function F7(e, t, r) {
  return e.push({
    key: t,
    value: r
  }), r;
}
function Kwe(e) {
  var t = jg(e).autoInterval;
  return t ?? (jg(e).autoInterval = e.calculateCategoryInterval());
}
function Ywe(e) {
  var t = qwe(e), r = yf(e), n = (t.axisRotate - t.labelRotate) / 180 * Math.PI, i = e.scale, o = i.getExtent(), a = i.count();
  if (o[1] - o[0] < 1)
    return 0;
  var s = 1;
  a > 40 && (s = Math.max(1, Math.floor(a / 40)));
  for (var l = o[0], u = e.dataToCoord(l + 1) - e.dataToCoord(l), c = Math.abs(u * Math.cos(n)), d = Math.abs(u * Math.sin(n)), h = 0, f = 0; l <= o[1]; l += s) {
    var p = 0, g = 0, v = _v(r({
      value: l
    }), t.font, "center", "top");
    p = v.width * 1.3, g = v.height * 1.3, h = Math.max(h, p, 7), f = Math.max(f, g, 7);
  }
  var m = h / c, y = f / d;
  isNaN(m) && (m = 1 / 0), isNaN(y) && (y = 1 / 0);
  var C = Math.max(0, Math.floor(Math.min(m, y))), S = jg(e.model), b = e.getExtent(), w = S.lastAutoInterval, x = S.lastTickCount;
  return w != null && x != null && Math.abs(w - C) <= 1 && Math.abs(x - a) <= 1 && w > C && S.axisExtent0 === b[0] && S.axisExtent1 === b[1] ? C = w : (S.lastTickCount = a, S.lastAutoInterval = C, S.axisExtent0 = b[0], S.axisExtent1 = b[1]), C;
}
function qwe(e) {
  var t = e.getLabelModel();
  return {
    axisRotate: e.getRotate ? e.getRotate() : e.isHorizontal && !e.isHorizontal() ? 90 : 0,
    labelRotate: t.get("rotate") || 0,
    font: t.getFont()
  };
}
function L7(e, t, r) {
  var n = yf(e), i = e.scale, o = i.getExtent(), a = e.getLabelModel(), s = [], l = Math.max((t || 0) + 1, 1), u = o[0], c = i.count();
  u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
  var d = R7(e), h = a.get("showMinLabel") || d, f = a.get("showMaxLabel") || d;
  h && u !== o[0] && g(o[0]);
  for (var p = u; p <= o[1]; p += l)
    g(p);
  f && p - l !== o[1] && g(o[1]);
  function g(v) {
    var m = {
      value: v
    };
    s.push(r ? v : {
      formattedLabel: n(m),
      rawLabel: i.getLabel(m),
      tickValue: v
    });
  }
  return s;
}
function O7(e, t, r) {
  var n = e.scale, i = yf(e), o = [];
  return B(n.getTicks(), function(a) {
    var s = n.getLabel(a), l = a.value;
    t(a.value, s) && o.push(r ? l : {
      formattedLabel: i(a),
      rawLabel: s,
      tickValue: l
    });
  }), o;
}
var XN = [0, 1], Zwe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.onBand = !1, this.inverse = !1, this.dim = t, this.scale = r, this._extent = n || [0, 0];
    }
    return e.prototype.contain = function(t) {
      var r = this._extent, n = Math.min(r[0], r[1]), i = Math.max(r[0], r[1]);
      return t >= n && t <= i;
    }, e.prototype.containData = function(t) {
      return this.scale.contain(t);
    }, e.prototype.getExtent = function() {
      return this._extent.slice();
    }, e.prototype.getPixelPrecision = function(t) {
      return oM(t || this.scale.getExtent(), this._extent);
    }, e.prototype.setExtent = function(t, r) {
      var n = this._extent;
      n[0] = t, n[1] = r;
    }, e.prototype.dataToCoord = function(t, r) {
      var n = this._extent, i = this.scale;
      return t = i.normalize(t), this.onBand && i.type === "ordinal" && (n = n.slice(), QN(n, i.count())), nr(t, XN, n, r);
    }, e.prototype.coordToData = function(t, r) {
      var n = this._extent, i = this.scale;
      this.onBand && i.type === "ordinal" && (n = n.slice(), QN(n, i.count()));
      var o = nr(t, n, XN, r);
      return this.scale.scale(o);
    }, e.prototype.pointToData = function(t, r) {
    }, e.prototype.getTicksCoords = function(t) {
      t = t || {};
      var r = t.tickModel || this.getTickModel(), n = $we(this, r), i = n.ticks, o = ge(i, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), a = r.get("alignWithLabel");
      return Xwe(this, o, a, t.clamp), o;
    }, e.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var t = this.model.getModel("minorTick"), r = t.get("splitNumber");
      r > 0 && r < 100 || (r = 5);
      var n = this.scale.getMinorTicks(r), i = ge(n, function(o) {
        return ge(o, function(a) {
          return {
            coord: this.dataToCoord(a),
            tickValue: a
          };
        }, this);
      }, this);
      return i;
    }, e.prototype.getViewLabels = function() {
      return zwe(this).labels;
    }, e.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, e.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, e.prototype.getBandWidth = function() {
      var t = this._extent, r = this.scale.getExtent(), n = r[1] - r[0] + (this.onBand ? 1 : 0);
      n === 0 && (n = 1);
      var i = Math.abs(t[1] - t[0]);
      return Math.abs(i) / n;
    }, e.prototype.calculateCategoryInterval = function() {
      return Ywe(this);
    }, e;
  }()
);
function QN(e, t) {
  var r = e[1] - e[0], n = t, i = r / n / 2;
  e[0] += i, e[1] -= i;
}
function Xwe(e, t, r, n) {
  var i = t.length;
  if (!e.onBand || r || !i)
    return;
  var o = e.getExtent(), a, s;
  if (i === 1)
    t[0].coord = o[0], a = t[1] = {
      coord: o[1]
    };
  else {
    var l = t[i - 1].tickValue - t[0].tickValue, u = (t[i - 1].coord - t[0].coord) / l;
    B(t, function(f) {
      f.coord -= u / 2;
    });
    var c = e.scale.getExtent();
    s = 1 + c[1] - t[i - 1].tickValue, a = {
      coord: t[i - 1].coord + u * s
    }, t.push(a);
  }
  var d = o[0] > o[1];
  h(t[0].coord, o[0]) && (n ? t[0].coord = o[0] : t.shift()), n && h(o[0], t[0].coord) && t.unshift({
    coord: o[0]
  }), h(o[1], a.coord) && (n ? a.coord = o[1] : t.pop()), n && h(a.coord, o[1]) && t.push({
    coord: o[1]
  });
  function h(f, p) {
    return f = Gr(f), p = Gr(p), d ? f > p : f < p;
  }
}
const Wo = Zwe;
function Qwe(e) {
  var t = Rt.extend(e);
  return Rt.registerClass(t), t;
}
function Jwe(e) {
  var t = Rr.extend(e);
  return Rr.registerClass(t), t;
}
function ebe(e) {
  var t = hr.extend(e);
  return hr.registerClass(t), t;
}
function tbe(e) {
  var t = ar.extend(e);
  return ar.registerClass(t), t;
}
var sp = Math.PI * 2, Au = es.CMD, rbe = ["top", "right", "bottom", "left"];
function nbe(e, t, r, n, i) {
  var o = r.width, a = r.height;
  switch (e) {
    case "top":
      n.set(r.x + o / 2, r.y - t), i.set(0, -1);
      break;
    case "bottom":
      n.set(r.x + o / 2, r.y + a + t), i.set(0, 1);
      break;
    case "left":
      n.set(r.x - t, r.y + a / 2), i.set(-1, 0);
      break;
    case "right":
      n.set(r.x + o + t, r.y + a / 2), i.set(1, 0);
      break;
  }
}
function ibe(e, t, r, n, i, o, a, s, l) {
  a -= e, s -= t;
  var u = Math.sqrt(a * a + s * s);
  a /= u, s /= u;
  var c = a * r + e, d = s * r + t;
  if (Math.abs(n - i) % sp < 1e-4)
    return l[0] = c, l[1] = d, u - r;
  if (o) {
    var h = n;
    n = eo(i), i = eo(h);
  } else
    n = eo(n), i = eo(i);
  n > i && (i += sp);
  var f = Math.atan2(s, a);
  if (f < 0 && (f += sp), f >= n && f <= i || f + sp >= n && f + sp <= i)
    return l[0] = c, l[1] = d, u - r;
  var p = r * Math.cos(n) + e, g = r * Math.sin(n) + t, v = r * Math.cos(i) + e, m = r * Math.sin(i) + t, y = (p - a) * (p - a) + (g - s) * (g - s), C = (v - a) * (v - a) + (m - s) * (m - s);
  return y < C ? (l[0] = p, l[1] = g, Math.sqrt(y)) : (l[0] = v, l[1] = m, Math.sqrt(C));
}
function gC(e, t, r, n, i, o, a, s) {
  var l = i - e, u = o - t, c = r - e, d = n - t, h = Math.sqrt(c * c + d * d);
  c /= h, d /= h;
  var f = l * c + u * d, p = f / h;
  s && (p = Math.min(Math.max(p, 0), 1)), p *= h;
  var g = a[0] = e + p * c, v = a[1] = t + p * d;
  return Math.sqrt((g - i) * (g - i) + (v - o) * (v - o));
}
function N7(e, t, r, n, i, o, a) {
  r < 0 && (e = e + r, r = -r), n < 0 && (t = t + n, n = -n);
  var s = e + r, l = t + n, u = a[0] = Math.min(Math.max(i, e), s), c = a[1] = Math.min(Math.max(o, t), l);
  return Math.sqrt((u - i) * (u - i) + (c - o) * (c - o));
}
var ea = [];
function obe(e, t, r) {
  var n = N7(t.x, t.y, t.width, t.height, e.x, e.y, ea);
  return r.set(ea[0], ea[1]), n;
}
function abe(e, t, r) {
  for (var n = 0, i = 0, o = 0, a = 0, s, l, u = 1 / 0, c = t.data, d = e.x, h = e.y, f = 0; f < c.length; ) {
    var p = c[f++];
    f === 1 && (n = c[f], i = c[f + 1], o = n, a = i);
    var g = u;
    switch (p) {
      case Au.M:
        o = c[f++], a = c[f++], n = o, i = a;
        break;
      case Au.L:
        g = gC(n, i, c[f], c[f + 1], d, h, ea, !0), n = c[f++], i = c[f++];
        break;
      case Au.C:
        g = l$(n, i, c[f++], c[f++], c[f++], c[f++], c[f], c[f + 1], d, h, ea), n = c[f++], i = c[f++];
        break;
      case Au.Q:
        g = c$(n, i, c[f++], c[f++], c[f], c[f + 1], d, h, ea), n = c[f++], i = c[f++];
        break;
      case Au.A:
        var v = c[f++], m = c[f++], y = c[f++], C = c[f++], S = c[f++], b = c[f++];
        f += 1;
        var w = !!(1 - c[f++]);
        s = Math.cos(S) * y + v, l = Math.sin(S) * C + m, f <= 1 && (o = s, a = l);
        var x = (d - v) * C / y + v;
        g = ibe(v, m, C, S, S + b, w, x, h, ea), n = Math.cos(S + b) * y + v, i = Math.sin(S + b) * C + m;
        break;
      case Au.R:
        o = n = c[f++], a = i = c[f++];
        var E = c[f++], R = c[f++];
        g = N7(o, a, E, R, d, h, ea);
        break;
      case Au.Z:
        g = gC(n, i, o, a, d, h, ea, !0), n = o, i = a;
        break;
    }
    g < u && (u = g, r.set(ea[0], ea[1]));
  }
  return u;
}
var aa = new Ct(), Er = new Ct(), Qr = new Ct(), Wa = new Ct(), Ga = new Ct();
function JN(e, t) {
  if (e) {
    var r = e.getTextGuideLine(), n = e.getTextContent();
    if (n && r) {
      var i = e.textGuideLineConfig || {}, o = [[0, 0], [0, 0], [0, 0]], a = i.candidates || rbe, s = n.getBoundingRect().clone();
      s.applyTransform(n.getComputedTransform());
      var l = 1 / 0, u = i.anchor, c = e.getComputedTransform(), d = c && Wc([], c), h = t.get("length2") || 0;
      u && Qr.copy(u);
      for (var f = 0; f < a.length; f++) {
        var p = a[f];
        nbe(p, 0, s, aa, Wa), Ct.scaleAndAdd(Er, aa, Wa, h), Er.transform(d);
        var g = e.getBoundingRect(), v = u ? u.distance(Er) : e instanceof Mt ? abe(Er, e.path, Qr) : obe(Er, g, Qr);
        v < l && (l = v, Er.transform(c), Qr.transform(c), Qr.toArray(o[0]), Er.toArray(o[1]), aa.toArray(o[2]));
      }
      k7(o, t.get("minTurnAngle")), r.setShape({
        points: o
      });
    }
  }
}
var vC = [], hi = new Ct();
function k7(e, t) {
  if (t <= 180 && t > 0) {
    t = t / 180 * Math.PI, aa.fromArray(e[0]), Er.fromArray(e[1]), Qr.fromArray(e[2]), Ct.sub(Wa, aa, Er), Ct.sub(Ga, Qr, Er);
    var r = Wa.len(), n = Ga.len();
    if (!(r < 1e-3 || n < 1e-3)) {
      Wa.scale(1 / r), Ga.scale(1 / n);
      var i = Wa.dot(Ga), o = Math.cos(t);
      if (o < i) {
        var a = gC(Er.x, Er.y, Qr.x, Qr.y, aa.x, aa.y, vC, !1);
        hi.fromArray(vC), hi.scaleAndAdd(Ga, a / Math.tan(Math.PI - t));
        var s = Qr.x !== Er.x ? (hi.x - Er.x) / (Qr.x - Er.x) : (hi.y - Er.y) / (Qr.y - Er.y);
        if (isNaN(s))
          return;
        s < 0 ? Ct.copy(hi, Er) : s > 1 && Ct.copy(hi, Qr), hi.toArray(e[1]);
      }
    }
  }
}
function sbe(e, t, r) {
  if (r <= 180 && r > 0) {
    r = r / 180 * Math.PI, aa.fromArray(e[0]), Er.fromArray(e[1]), Qr.fromArray(e[2]), Ct.sub(Wa, Er, aa), Ct.sub(Ga, Qr, Er);
    var n = Wa.len(), i = Ga.len();
    if (!(n < 1e-3 || i < 1e-3)) {
      Wa.scale(1 / n), Ga.scale(1 / i);
      var o = Wa.dot(t), a = Math.cos(r);
      if (o < a) {
        var s = gC(Er.x, Er.y, Qr.x, Qr.y, aa.x, aa.y, vC, !1);
        hi.fromArray(vC);
        var l = Math.PI / 2, u = Math.acos(Ga.dot(t)), c = l + u - r;
        if (c >= l)
          Ct.copy(hi, Qr);
        else {
          hi.scaleAndAdd(Ga, s / Math.tan(Math.PI / 2 - c));
          var d = Qr.x !== Er.x ? (hi.x - Er.x) / (Qr.x - Er.x) : (hi.y - Er.y) / (Qr.y - Er.y);
          if (isNaN(d))
            return;
          d < 0 ? Ct.copy(hi, Er) : d > 1 && Ct.copy(hi, Qr);
        }
        hi.toArray(e[1]);
      }
    }
  }
}
function x1(e, t, r, n) {
  var i = r === "normal", o = i ? e : e.ensureState(r);
  o.ignore = t;
  var a = n.get("smooth");
  a && a === !0 && (a = 0.3), o.shape = o.shape || {}, a > 0 && (o.shape.smooth = a);
  var s = n.getModel("lineStyle").getLineStyle();
  i ? e.useStyle(s) : o.style = s;
}
function lbe(e, t) {
  var r = t.smooth, n = t.points;
  if (n)
    if (e.moveTo(n[0][0], n[0][1]), r > 0 && n.length >= 3) {
      var i = Es(n[0], n[1]), o = Es(n[1], n[2]);
      if (!i || !o) {
        e.lineTo(n[1][0], n[1][1]), e.lineTo(n[2][0], n[2][1]);
        return;
      }
      var a = Math.min(i, o) * r, s = Yp([], n[1], n[0], a / i), l = Yp([], n[1], n[2], a / o), u = Yp([], s, l, 0.5);
      e.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), e.bezierCurveTo(l[0], l[1], l[0], l[1], n[2][0], n[2][1]);
    } else
      for (var c = 1; c < n.length; c++)
        e.lineTo(n[c][0], n[c][1]);
}
function lD(e, t, r) {
  var n = e.getTextGuideLine(), i = e.getTextContent();
  if (!i) {
    n && e.removeTextGuideLine();
    return;
  }
  for (var o = t.normal, a = o.get("show"), s = i.ignore, l = 0; l < kg.length; l++) {
    var u = kg[l], c = t[u], d = u === "normal";
    if (c) {
      var h = c.get("show"), f = d ? s : st(i.states[u] && i.states[u].ignore, s);
      if (f || !st(h, a)) {
        var p = d ? n : n && n.states[u];
        p && (p.ignore = !0), n && x1(n, !0, u, c);
        continue;
      }
      n || (n = new Ri(), e.setTextGuideLine(n), !d && (s || !a) && x1(n, !0, "normal", t.normal), e.stateProxy && (n.stateProxy = e.stateProxy)), x1(n, !1, u, c);
    }
  }
  if (n) {
    Xe(n.style, r), n.style.fill = null;
    var g = o.get("showAbove"), v = e.textGuideLineConfig = e.textGuideLineConfig || {};
    v.showAbove = g || !1, n.buildPath = lbe;
  }
}
function uD(e, t) {
  t = t || "labelLine";
  for (var r = {
    normal: e.getModel(t)
  }, n = 0; n < bi.length; n++) {
    var i = bi[n];
    r[i] = e.getModel([i, t]);
  }
  return r;
}
function V7(e) {
  for (var t = [], r = 0; r < e.length; r++) {
    var n = e[r];
    if (!n.defaultAttr.ignore) {
      var i = n.label, o = i.getComputedTransform(), a = i.getBoundingRect(), s = !o || o[1] < 1e-5 && o[2] < 1e-5, l = i.style.margin || 0, u = a.clone();
      u.applyTransform(o), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
      var c = s ? new Z0(a, o) : null;
      t.push({
        label: i,
        labelLine: n.labelLine,
        rect: u,
        localRect: a,
        obb: c,
        priority: n.priority,
        defaultAttr: n.defaultAttr,
        layoutOption: n.computedLayoutOption,
        axisAligned: s,
        transform: o
      });
    }
  }
  return t;
}
function B7(e, t, r, n, i, o) {
  var a = e.length;
  if (a < 2)
    return;
  e.sort(function(E, R) {
    return E.rect[t] - R.rect[t];
  });
  for (var s = 0, l, u = !1, c = 0, d = 0; d < a; d++) {
    var h = e[d], f = h.rect;
    l = f[t] - s, l < 0 && (f[t] -= l, h.label[t] -= l, u = !0);
    var p = Math.max(-l, 0);
    c += p, s = f[t] + f[r];
  }
  c > 0 && o && b(-c / a, 0, a);
  var g = e[0], v = e[a - 1], m, y;
  C(), m < 0 && w(-m, 0.8), y < 0 && w(y, 0.8), C(), S(m, y, 1), S(y, m, -1), C(), m < 0 && x(-m), y < 0 && x(y);
  function C() {
    m = g.rect[t] - n, y = i - v.rect[t] - v.rect[r];
  }
  function S(E, R, _) {
    if (E < 0) {
      var P = Math.min(R, -E);
      if (P > 0) {
        b(P * _, 0, a);
        var D = P + E;
        D < 0 && w(-D * _, 1);
      } else
        w(-E * _, 1);
    }
  }
  function b(E, R, _) {
    E !== 0 && (u = !0);
    for (var P = R; P < _; P++) {
      var D = e[P], I = D.rect;
      I[t] += E, D.label[t] += E;
    }
  }
  function w(E, R) {
    for (var _ = [], P = 0, D = 1; D < a; D++) {
      var I = e[D - 1].rect, A = Math.max(e[D].rect[t] - I[t] - I[r], 0);
      _.push(A), P += A;
    }
    if (P) {
      var O = Math.min(Math.abs(E) / P, R);
      if (E > 0)
        for (var D = 0; D < a - 1; D++) {
          var L = _[D] * O;
          b(L, 0, D + 1);
        }
      else
        for (var D = a - 1; D > 0; D--) {
          var L = _[D - 1] * O;
          b(-L, D, a);
        }
    }
  }
  function x(E) {
    var R = E < 0 ? -1 : 1;
    E = Math.abs(E);
    for (var _ = Math.ceil(E / (a - 1)), P = 0; P < a - 1; P++)
      if (R > 0 ? b(_, 0, P + 1) : b(-_, a - P - 1, a), E -= _, E <= 0)
        return;
  }
  return u;
}
function ube(e, t, r, n) {
  return B7(e, "x", "width", t, r, n);
}
function G7(e, t, r, n) {
  return B7(e, "y", "height", t, r, n);
}
function H7(e) {
  var t = [];
  e.sort(function(g, v) {
    return v.priority - g.priority;
  });
  var r = new St(0, 0, 0, 0);
  function n(g) {
    if (!g.ignore) {
      var v = g.ensureState("emphasis");
      v.ignore == null && (v.ignore = !1);
    }
    g.ignore = !0;
  }
  for (var i = 0; i < e.length; i++) {
    var o = e[i], a = o.axisAligned, s = o.localRect, l = o.transform, u = o.label, c = o.labelLine;
    r.copy(o.rect), r.width -= 0.1, r.height -= 0.1, r.x += 0.05, r.y += 0.05;
    for (var d = o.obb, h = !1, f = 0; f < t.length; f++) {
      var p = t[f];
      if (r.intersect(p.rect)) {
        if (a && p.axisAligned) {
          h = !0;
          break;
        }
        if (p.obb || (p.obb = new Z0(p.localRect, p.transform)), d || (d = new Z0(s, l)), d.intersect(p.obb)) {
          h = !0;
          break;
        }
      }
    }
    h ? (n(u), c && n(c)) : (u.attr("ignore", o.defaultAttr.ignore), c && c.attr("ignore", o.defaultAttr.labelGuideIgnore), t.push(o));
  }
}
function cbe(e) {
  if (e) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push(e[r].slice());
    return t;
  }
}
function dbe(e, t) {
  var r = e.label, n = t && t.getTextGuideLine();
  return {
    dataIndex: e.dataIndex,
    dataType: e.dataType,
    seriesIndex: e.seriesModel.seriesIndex,
    text: e.label.style.text,
    rect: e.hostRect,
    labelRect: e.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: r.style.align,
    verticalAlign: r.style.verticalAlign,
    labelLinePoints: cbe(n && n.shape.points)
  };
}
var ek = ["align", "verticalAlign", "width", "height", "fontSize"], li = new Ts(), E1 = Gt(), hbe = Gt();
function ty(e, t, r) {
  for (var n = 0; n < r.length; n++) {
    var i = r[n];
    t[i] != null && (e[i] = t[i]);
  }
}
var ry = ["x", "y", "rotation"], fbe = (
  /** @class */
  function() {
    function e() {
      this._labelList = [], this._chartViewList = [];
    }
    return e.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, e.prototype._addLabel = function(t, r, n, i, o) {
      var a = i.style, s = i.__hostTarget, l = s.textConfig || {}, u = i.getComputedTransform(), c = i.getBoundingRect().plain();
      St.applyTransform(c, c, u), u ? li.setLocalTransform(u) : (li.x = li.y = li.rotation = li.originX = li.originY = 0, li.scaleX = li.scaleY = 1), li.rotation = eo(li.rotation);
      var d = i.__hostTarget, h;
      if (d) {
        h = d.getBoundingRect().plain();
        var f = d.getComputedTransform();
        St.applyTransform(h, h, f);
      }
      var p = h && d.getTextGuideLine();
      this._labelList.push({
        label: i,
        labelLine: p,
        seriesModel: n,
        dataIndex: t,
        dataType: r,
        layoutOption: o,
        computedLayoutOption: null,
        rect: c,
        hostRect: h,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: h ? h.width * h.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: i.ignore,
          labelGuideIgnore: p && p.ignore,
          x: li.x,
          y: li.y,
          scaleX: li.scaleX,
          scaleY: li.scaleY,
          rotation: li.rotation,
          style: {
            x: a.x,
            y: a.y,
            align: a.align,
            verticalAlign: a.verticalAlign,
            width: a.width,
            height: a.height,
            fontSize: a.fontSize
          },
          cursor: i.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, e.prototype.addLabelsOfSeries = function(t) {
      var r = this;
      this._chartViewList.push(t);
      var n = t.__model, i = n.get("labelLayout");
      (Ye(i) || At(i).length) && t.group.traverse(function(o) {
        if (o.ignore)
          return !0;
        var a = o.getTextContent(), s = ot(o);
        a && !a.disableLabelLayout && r._addLabel(s.dataIndex, s.dataType, n, a, i);
      });
    }, e.prototype.updateLayoutConfig = function(t) {
      var r = t.getWidth(), n = t.getHeight();
      function i(C, S) {
        return function() {
          JN(C, S);
        };
      }
      for (var o = 0; o < this._labelList.length; o++) {
        var a = this._labelList[o], s = a.label, l = s.__hostTarget, u = a.defaultAttr, c = void 0;
        Ye(a.layoutOption) ? c = a.layoutOption(dbe(a, l)) : c = a.layoutOption, c = c || {}, a.computedLayoutOption = c;
        var d = Math.PI / 180;
        l && l.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: c.x != null || c.y != null ? null : u.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: c.rotate != null ? c.rotate * d : u.attachedRot,
          offset: [c.dx || 0, c.dy || 0]
        });
        var h = !1;
        if (c.x != null ? (s.x = Ae(c.x, r), s.setStyle("x", 0), h = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), c.y != null ? (s.y = Ae(c.y, n), s.setStyle("y", 0), h = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), c.labelLinePoints) {
          var f = l.getTextGuideLine();
          f && (f.setShape({
            points: c.labelLinePoints
          }), h = !1);
        }
        var p = E1(s);
        p.needsUpdateLabelLine = h, s.rotation = c.rotate != null ? c.rotate * d : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var g = 0; g < ek.length; g++) {
          var v = ek[g];
          s.setStyle(v, c[v] != null ? c[v] : u.style[v]);
        }
        if (c.draggable) {
          if (s.draggable = !0, s.cursor = "move", l) {
            var m = a.seriesModel;
            if (a.dataIndex != null) {
              var y = a.seriesModel.getData(a.dataType);
              m = y.getItemModel(a.dataIndex);
            }
            s.on("drag", i(l, m.getModel("labelLine")));
          }
        } else
          s.off("drag"), s.cursor = u.cursor;
      }
    }, e.prototype.layout = function(t) {
      var r = t.getWidth(), n = t.getHeight(), i = V7(this._labelList), o = ir(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), a = ir(i, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      ube(o, 0, r), G7(a, 0, n);
      var s = ir(i, function(l) {
        return l.layoutOption.hideOverlap;
      });
      H7(s);
    }, e.prototype.processLabelsOverall = function() {
      var t = this;
      B(this._chartViewList, function(r) {
        var n = r.__model, i = r.ignoreLabelLineUpdate, o = n.isAnimationEnabled();
        r.group.traverse(function(a) {
          if (a.ignore && !a.forceLabelAnimation)
            return !0;
          var s = !i, l = a.getTextContent();
          !s && l && (s = E1(l).needsUpdateLabelLine), s && t._updateLabelLine(a, n), o && t._animateLabels(a, n);
        });
      });
    }, e.prototype._updateLabelLine = function(t, r) {
      var n = t.getTextContent(), i = ot(t), o = i.dataIndex;
      if (n && o != null) {
        var a = r.getData(i.dataType), s = a.getItemModel(o), l = {}, u = a.getItemVisual(o, "style");
        if (u) {
          var c = a.getVisual("drawType");
          l.stroke = u[c];
        }
        var d = s.getModel("labelLine");
        lD(t, uD(s), l), JN(t, d);
      }
    }, e.prototype._animateLabels = function(t, r) {
      var n = t.getTextContent(), i = t.getTextGuideLine();
      if (n && (t.forceLabelAnimation || !n.ignore && !n.invisible && !t.disableLabelAnimation && !gh(t))) {
        var o = E1(n), a = o.oldLayout, s = ot(t), l = s.dataIndex, u = {
          x: n.x,
          y: n.y,
          rotation: n.rotation
        }, c = r.getData(s.dataType);
        if (a) {
          n.attr(a);
          var h = t.prevStates;
          h && (bt(h, "select") >= 0 && n.attr(o.oldLayoutSelect), bt(h, "emphasis") >= 0 && n.attr(o.oldLayoutEmphasis)), jt(n, u, r, l);
        } else if (n.attr(u), !cf(n).valueAnimation) {
          var d = st(n.style.opacity, 1);
          n.style.opacity = 0, Pr(n, {
            style: {
              opacity: d
            }
          }, r, l);
        }
        if (o.oldLayout = u, n.states.select) {
          var f = o.oldLayoutSelect = {};
          ty(f, u, ry), ty(f, n.states.select, ry);
        }
        if (n.states.emphasis) {
          var p = o.oldLayoutEmphasis = {};
          ty(p, u, ry), ty(p, n.states.emphasis, ry);
        }
        O6(n, l, c, r, r);
      }
      if (i && !i.ignore && !i.invisible) {
        var o = hbe(i), a = o.oldLayout, g = {
          points: i.shape.points
        };
        a ? (i.attr({
          shape: a
        }), jt(i, {
          shape: g
        }, r)) : (i.setShape(g), i.style.strokePercent = 0, Pr(i, {
          style: {
            strokePercent: 1
          }
        }, r)), o.oldLayout = g;
      }
    }, e;
  }()
), R1 = Gt();
function pbe(e) {
  e.registerUpdateLifecycle("series:beforeupdate", function(t, r, n) {
    var i = R1(r).labelManager;
    i || (i = R1(r).labelManager = new fbe()), i.clearLabels();
  }), e.registerUpdateLifecycle("series:layoutlabels", function(t, r, n) {
    var i = R1(r).labelManager;
    n.updatedSeries.forEach(function(o) {
      i.addLabelsOfSeries(r.getViewOfSeriesModel(o));
    }), i.updateLayoutConfig(r), i.layout(r), i.processLabelsOverall();
  });
}
var _1 = Math.sin, T1 = Math.cos, z7 = Math.PI, Iu = Math.PI * 2, gbe = 180 / z7, $7 = function() {
  function e() {
  }
  return e.prototype.reset = function(t) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, t || 4);
  }, e.prototype.moveTo = function(t, r) {
    this._add("M", t, r);
  }, e.prototype.lineTo = function(t, r) {
    this._add("L", t, r);
  }, e.prototype.bezierCurveTo = function(t, r, n, i, o, a) {
    this._add("C", t, r, n, i, o, a);
  }, e.prototype.quadraticCurveTo = function(t, r, n, i) {
    this._add("Q", t, r, n, i);
  }, e.prototype.arc = function(t, r, n, i, o, a) {
    this.ellipse(t, r, n, n, 0, i, o, a);
  }, e.prototype.ellipse = function(t, r, n, i, o, a, s, l) {
    var u = s - a, c = !l, d = Math.abs(u), h = Tl(d - Iu) || (c ? u >= Iu : -u >= Iu), f = u > 0 ? u % Iu : u % Iu + Iu, p = !1;
    h ? p = !0 : Tl(d) ? p = !1 : p = f >= z7 == !!c;
    var g = t + n * T1(a), v = r + i * _1(a);
    this._start && this._add("M", g, v);
    var m = Math.round(o * gbe);
    if (h) {
      var y = 1 / this._p, C = (c ? 1 : -1) * (Iu - y);
      this._add("A", n, i, m, 1, +c, t + n * T1(a + C), r + i * _1(a + C)), y > 0.01 && this._add("A", n, i, m, 0, +c, g, v);
    } else {
      var S = t + n * T1(s), b = r + i * _1(s);
      this._add("A", n, i, m, +p, +c, S, b);
    }
  }, e.prototype.rect = function(t, r, n, i) {
    this._add("M", t, r), this._add("l", n, 0), this._add("l", 0, i), this._add("l", -n, 0), this._add("Z");
  }, e.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, e.prototype._add = function(t, r, n, i, o, a, s, l, u) {
    for (var c = [], d = this._p, h = 1; h < arguments.length; h++) {
      var f = arguments[h];
      if (isNaN(f)) {
        this._invalid = !0;
        return;
      }
      c.push(Math.round(f * d) / d);
    }
    this._d.push(t + c.join(" ")), this._start = t === "Z";
  }, e.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, e.prototype.getStr = function() {
    return this._str;
  }, e;
}(), cD = "none", vbe = Math.round;
function mbe(e) {
  var t = e.fill;
  return t != null && t !== cD;
}
function ybe(e) {
  var t = e.stroke;
  return t != null && t !== cD;
}
var P_ = ["lineCap", "miterLimit", "lineJoin"], Cbe = ge(P_, function(e) {
  return "stroke-" + e.toLowerCase();
});
function Sbe(e, t, r, n) {
  var i = t.opacity == null ? 1 : t.opacity;
  if (r instanceof In) {
    e("opacity", i);
    return;
  }
  if (mbe(t)) {
    var o = Ng(t.fill);
    e("fill", o.color);
    var a = t.fillOpacity != null ? t.fillOpacity * o.opacity * i : o.opacity * i;
    a < 1 && e("fill-opacity", a);
  } else
    e("fill", cD);
  if (ybe(t)) {
    var s = Ng(t.stroke);
    e("stroke", s.color);
    var l = t.strokeNoScale ? r.getLineScale() : 1, u = l ? (t.lineWidth || 0) / l : 0, c = t.strokeOpacity != null ? t.strokeOpacity * s.opacity * i : s.opacity * i, d = t.strokeFirst;
    if (u !== 1 && e("stroke-width", u), d && e("paint-order", d ? "stroke" : "fill"), c < 1 && e("stroke-opacity", c), t.lineDash) {
      var h = WM(r), f = h[0], p = h[1];
      f && (p = vbe(p || 0), e("stroke-dasharray", f.join(",")), (p || n) && e("stroke-dashoffset", p));
    }
    for (var g = 0; g < P_.length; g++) {
      var v = P_[g];
      if (t[v] !== Y0[v]) {
        var m = t[v] || Y0[v];
        m && e(Cbe[g], m);
      }
    }
  }
}
var W7 = "http://www.w3.org/2000/svg", j7 = "http://www.w3.org/1999/xlink", wbe = "http://www.w3.org/2000/xmlns/", bbe = "http://www.w3.org/XML/1998/namespace", tk = "ecmeta_";
function U7(e) {
  return document.createElementNS(W7, e);
}
function bn(e, t, r, n, i) {
  return {
    tag: e,
    attrs: r || {},
    children: n,
    text: i,
    key: t
  };
}
function xbe(e, t) {
  var r = [];
  if (t)
    for (var n in t) {
      var i = t[n], o = n;
      i !== !1 && (i !== !0 && i != null && (o += '="' + i + '"'), r.push(o));
    }
  return "<" + e + " " + r.join(" ") + ">";
}
function Ebe(e) {
  return "</" + e + ">";
}
function dD(e, t) {
  t = t || {};
  var r = t.newline ? `
` : "";
  function n(i) {
    var o = i.children, a = i.tag, s = i.attrs, l = i.text;
    return xbe(a, s) + (a !== "style" ? fi(l) : l || "") + (o ? "" + r + ge(o, function(u) {
      return n(u);
    }).join(r) + r : "") + Ebe(a);
  }
  return n(e);
}
function Rbe(e, t, r) {
  r = r || {};
  var n = r.newline ? `
` : "", i = " {" + n, o = n + "}", a = ge(At(e), function(l) {
    return l + i + ge(At(e[l]), function(u) {
      return u + ":" + e[l][u] + ";";
    }).join(n) + o;
  }).join(n), s = ge(At(t), function(l) {
    return "@keyframes " + l + i + ge(At(t[l]), function(u) {
      return u + i + ge(At(t[l][u]), function(c) {
        var d = t[l][u][c];
        return c === "d" && (d = 'path("' + d + '")'), c + ":" + d + ";";
      }).join(n) + o;
    }).join(n) + o;
  }).join(n);
  return !a && !s ? "" : ["<![CDATA[", a, s, "]]>"].join(n);
}
function M_(e) {
  return {
    zrId: e,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssStyleCache: {},
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function rk(e, t, r, n) {
  return bn("svg", "root", {
    width: e,
    height: t,
    xmlns: W7,
    "xmlns:xlink": j7,
    version: "1.1",
    baseProfile: "full",
    viewBox: n ? "0 0 " + e + " " + t : !1
  }, r);
}
var _be = 0;
function K7() {
  return _be++;
}
var nk = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, ku = "transform-origin";
function Tbe(e, t, r) {
  var n = se({}, e.shape);
  se(n, t), e.buildPath(r, n);
  var i = new $7();
  return i.reset(m$(e)), r.rebuildPath(i, 1), i.generateStr(), i.getStr();
}
function Pbe(e, t) {
  var r = t.originX, n = t.originY;
  (r || n) && (e[ku] = r + "px " + n + "px");
}
var Mbe = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function Y7(e, t) {
  var r = t.zrId + "-ani-" + t.cssAnimIdx++;
  return t.cssAnims[r] = e, r;
}
function Dbe(e, t, r) {
  var n = e.shape.paths, i = {}, o, a;
  if (B(n, function(l) {
    var u = M_(r.zrId);
    u.animation = !0, iw(l, {}, u, !0);
    var c = u.cssAnims, d = u.cssNodes, h = At(c), f = h.length;
    if (f) {
      a = h[f - 1];
      var p = c[a];
      for (var g in p) {
        var v = p[g];
        i[g] = i[g] || { d: "" }, i[g].d += v.d || "";
      }
      for (var m in d) {
        var y = d[m].animation;
        y.indexOf(a) >= 0 && (o = y);
      }
    }
  }), !!o) {
    t.d = !1;
    var s = Y7(i, r);
    return o.replace(a, s);
  }
}
function ik(e) {
  return Fe(e) ? nk[e] ? "cubic-bezier(" + nk[e] + ")" : tM(e) ? e : "" : "";
}
function iw(e, t, r, n) {
  var i = e.animators, o = i.length, a = [];
  if (e instanceof BS) {
    var s = Dbe(e, t, r);
    if (s)
      a.push(s);
    else if (!o)
      return;
  } else if (!o)
    return;
  for (var l = {}, u = 0; u < o; u++) {
    var c = i[u], d = [c.getMaxTime() / 1e3 + "s"], h = ik(c.getClip().easing), f = c.getDelay();
    h ? d.push(h) : d.push("linear"), f && d.push(f / 1e3 + "s"), c.getLoop() && d.push("infinite");
    var p = d.join(" ");
    l[p] = l[p] || [p, []], l[p][1].push(c);
  }
  function g(y) {
    var C = y[1], S = C.length, b = {}, w = {}, x = {}, E = "animation-timing-function";
    function R(Z, ee, J) {
      for (var X = Z.getTracks(), Y = Z.getMaxTime(), de = 0; de < X.length; de++) {
        var K = X[de];
        if (K.needsAnimate()) {
          var ie = K.keyframes, Ce = K.propName;
          if (J && (Ce = J(Ce)), Ce)
            for (var Te = 0; Te < ie.length; Te++) {
              var Ie = ie[Te], we = Math.round(Ie.time / Y * 100) + "%", Re = ik(Ie.easing), _e = Ie.rawValue;
              (Fe(_e) || $t(_e)) && (ee[we] = ee[we] || {}, ee[we][Ce] = Ie.rawValue, Re && (ee[we][E] = Re));
            }
        }
      }
    }
    for (var _ = 0; _ < S; _++) {
      var P = C[_], D = P.targetName;
      D ? D === "shape" && R(P, w) : !n && R(P, b);
    }
    for (var I in b) {
      var A = {};
      b$(A, e), se(A, b[I]);
      var O = y$(A), L = b[I][E];
      x[I] = O ? {
        transform: O
      } : {}, Pbe(x[I], A), L && (x[I][E] = L);
    }
    var N, F = !0;
    for (var I in w) {
      x[I] = x[I] || {};
      var G = !N, L = w[I][E];
      G && (N = new es());
      var M = N.len();
      N.reset(), x[I].d = Tbe(e, w[I], N);
      var V = N.len();
      if (!G && M !== V) {
        F = !1;
        break;
      }
      L && (x[I][E] = L);
    }
    if (!F)
      for (var I in x)
        delete x[I].d;
    if (!n)
      for (var _ = 0; _ < S; _++) {
        var P = C[_], D = P.targetName;
        D === "style" && R(P, x, function(X) {
          return Mbe[X];
        });
      }
    for (var z = At(x), k = !0, $, _ = 1; _ < z.length; _++) {
      var W = z[_ - 1], j = z[_];
      if (x[W][ku] !== x[j][ku]) {
        k = !1;
        break;
      }
      $ = x[W][ku];
    }
    if (k && $) {
      for (var I in x)
        x[I][ku] && delete x[I][ku];
      t[ku] = $;
    }
    if (ir(z, function(Z) {
      return At(x[Z]).length > 0;
    }).length) {
      var U = Y7(x, r);
      return U + " " + y[0] + " both";
    }
  }
  for (var v in l) {
    var s = g(l[v]);
    s && a.push(s);
  }
  if (a.length) {
    var m = r.zrId + "-cls-" + K7();
    r.cssNodes["." + m] = {
      animation: a.join(",")
    }, t.class = m;
  }
}
function Abe(e, t, r) {
  if (!e.ignore)
    if (e.isSilent()) {
      var n = {
        "pointer-events": "none"
      };
      ok(n, t, r);
    } else {
      var i = e.states.emphasis && e.states.emphasis.style ? e.states.emphasis.style : {}, o = i.fill;
      if (!o) {
        var a = e.style && e.style.fill, s = e.states.select && e.states.select.style && e.states.select.style.fill, l = e.currentStates.indexOf("select") >= 0 && s || a;
        l && (o = $0(l));
      }
      var u = i.lineWidth;
      if (u) {
        var c = !i.strokeNoScale && e.transform ? e.transform[0] : 1;
        u = u / c;
      }
      var n = {
        cursor: "pointer"
      };
      o && (n.fill = o), i.stroke && (n.stroke = i.stroke), u && (n["stroke-width"] = u), ok(n, t, r);
    }
}
function ok(e, t, r, n) {
  var i = JSON.stringify(e), o = r.cssStyleCache[i];
  o || (o = r.zrId + "-cls-" + K7(), r.cssStyleCache[i] = o, r.cssNodes["." + o + ":hover"] = e), t.class = t.class ? t.class + " " + o : o;
}
var Ug = Math.round;
function q7(e) {
  return e && Fe(e.src);
}
function Z7(e) {
  return e && Ye(e.toDataURL);
}
function hD(e, t, r, n) {
  Sbe(function(i, o) {
    var a = i === "fill" || i === "stroke";
    a && v$(o) ? Q7(t, e, i, n) : a && nM(o) ? J7(r, e, i, n) : a && o === "none" ? e[i] = "transparent" : e[i] = o;
  }, t, r, !1), Vbe(r, e, n);
}
function fD(e, t) {
  var r = _$(t);
  r && (r.each(function(n, i) {
    n != null && (e[(tk + i).toLowerCase()] = n + "");
  }), t.isSilent() && (e[tk + "silent"] = "true"));
}
function ak(e) {
  return Tl(e[0] - 1) && Tl(e[1]) && Tl(e[2]) && Tl(e[3] - 1);
}
function Ibe(e) {
  return Tl(e[4]) && Tl(e[5]);
}
function pD(e, t, r) {
  if (t && !(Ibe(t) && ak(t))) {
    var n = 1e4;
    e.transform = ak(t) ? "translate(" + Ug(t[4] * n) / n + " " + Ug(t[5] * n) / n + ")" : Ege(t);
  }
}
function sk(e, t, r) {
  for (var n = e.points, i = [], o = 0; o < n.length; o++)
    i.push(Ug(n[o][0] * r) / r), i.push(Ug(n[o][1] * r) / r);
  t.points = i.join(" ");
}
function lk(e) {
  return !e.smooth;
}
function Fbe(e) {
  var t = ge(e, function(r) {
    return typeof r == "string" ? [r, r] : r;
  });
  return function(r, n, i) {
    for (var o = 0; o < t.length; o++) {
      var a = t[o], s = r[a[0]];
      s != null && (n[a[1]] = Ug(s * i) / i);
    }
  };
}
var Lbe = {
  circle: [Fbe(["cx", "cy", "r"])],
  polyline: [sk, lk],
  polygon: [sk, lk]
};
function Obe(e) {
  for (var t = e.animators, r = 0; r < t.length; r++)
    if (t[r].targetName === "shape")
      return !0;
  return !1;
}
function X7(e, t) {
  var r = e.style, n = e.shape, i = Lbe[e.type], o = {}, a = t.animation, s = "path", l = e.style.strokePercent, u = t.compress && m$(e) || 4;
  if (i && !t.willUpdate && !(i[1] && !i[1](n)) && !(a && Obe(e)) && !(l < 1)) {
    s = e.type;
    var c = Math.pow(10, u);
    i[0](n, o, c);
  } else {
    var d = !e.path || e.shapeChanged();
    e.path || e.createPathProxy();
    var h = e.path;
    d && (h.beginPath(), e.buildPath(h, e.shape), e.pathUpdated());
    var f = h.getVersion(), p = e, g = p.__svgPathBuilder;
    (p.__svgPathVersion !== f || !g || l !== p.__svgPathStrokePercent) && (g || (g = p.__svgPathBuilder = new $7()), g.reset(u), h.rebuildPath(g, l), g.generateStr(), p.__svgPathVersion = f, p.__svgPathStrokePercent = l), o.d = g.getStr();
  }
  return pD(o, e.transform), hD(o, r, e, t), fD(o, e), t.animation && iw(e, o, t), t.emphasis && Abe(e, o, t), bn(s, e.id + "", o);
}
function Nbe(e, t) {
  var r = e.style, n = r.image;
  if (n && !Fe(n) && (q7(n) ? n = n.src : Z7(n) && (n = n.toDataURL())), !!n) {
    var i = r.x || 0, o = r.y || 0, a = r.width, s = r.height, l = {
      href: n,
      width: a,
      height: s
    };
    return i && (l.x = i), o && (l.y = o), pD(l, e.transform), hD(l, r, e, t), fD(l, e), t.animation && iw(e, l, t), bn("image", e.id + "", l);
  }
}
function kbe(e, t) {
  var r = e.style, n = r.text;
  if (n != null && (n += ""), !(!n || isNaN(r.x) || isNaN(r.y))) {
    var i = r.font || Hl, o = r.x || 0, a = _ge(r.y || 0, TS(i), r.textBaseline), s = Rge[r.textAlign] || r.textAlign, l = {
      "dominant-baseline": "central",
      "text-anchor": s
    };
    if (J$(r)) {
      var u = "", c = r.fontStyle, d = Q$(r.fontSize);
      if (!parseFloat(d))
        return;
      var h = r.fontFamily || z3, f = r.fontWeight;
      u += "font-size:" + d + ";font-family:" + h + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), f && f !== "normal" && (u += "font-weight:" + f + ";"), l.style = u;
    } else
      l.style = "font: " + i;
    return n.match(/\s/) && (l["xml:space"] = "preserve"), o && (l.x = o), a && (l.y = a), pD(l, e.transform), hD(l, r, e, t), fD(l, e), t.animation && iw(e, l, t), bn("text", e.id + "", l, void 0, n);
  }
}
function uk(e, t) {
  if (e instanceof Mt)
    return X7(e, t);
  if (e instanceof In)
    return Nbe(e, t);
  if (e instanceof Fh)
    return kbe(e, t);
}
function Vbe(e, t, r) {
  var n = e.style;
  if (Tge(n)) {
    var i = Pge(e), o = r.shadowCache, a = o[i];
    if (!a) {
      var s = e.getGlobalScale(), l = s[0], u = s[1];
      if (!l || !u)
        return;
      var c = n.shadowOffsetX || 0, d = n.shadowOffsetY || 0, h = n.shadowBlur, f = Ng(n.shadowColor), p = f.opacity, g = f.color, v = h / 2 / l, m = h / 2 / u, y = v + " " + m;
      a = r.zrId + "-s" + r.shadowIdx++, r.defs[a] = bn("filter", a, {
        id: a,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        bn("feDropShadow", "", {
          dx: c / l,
          dy: d / u,
          stdDeviation: y,
          "flood-color": g,
          "flood-opacity": p
        })
      ]), o[i] = a;
    }
    t.filter = _S(a);
  }
}
function Q7(e, t, r, n) {
  var i = e[r], o, a = {
    gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (p$(i))
    o = "linearGradient", a.x1 = i.x, a.y1 = i.y, a.x2 = i.x2, a.y2 = i.y2;
  else if (g$(i))
    o = "radialGradient", a.cx = st(i.x, 0.5), a.cy = st(i.y, 0.5), a.r = st(i.r, 0.5);
  else {
    process.env.NODE_ENV !== "production" && Mo("Illegal gradient type.");
    return;
  }
  for (var s = i.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
    var d = kR(s[u].offset) * 100 + "%", h = s[u].color, f = Ng(h), p = f.color, g = f.opacity, v = {
      offset: d
    };
    v["stop-color"] = p, g < 1 && (v["stop-opacity"] = g), l.push(bn("stop", u + "", v));
  }
  var m = bn(o, "", a, l), y = dD(m), C = n.gradientCache, S = C[y];
  S || (S = n.zrId + "-g" + n.gradientIdx++, C[y] = S, a.id = S, n.defs[S] = bn(o, S, a, l)), t[r] = _S(S);
}
function J7(e, t, r, n) {
  var i = e.style[r], o = e.getBoundingRect(), a = {}, s = i.repeat, l = s === "no-repeat", u = s === "repeat-x", c = s === "repeat-y", d;
  if (f$(i)) {
    var h = i.imageWidth, f = i.imageHeight, p = void 0, g = i.image;
    if (Fe(g) ? p = g : q7(g) ? p = g.src : Z7(g) && (p = g.toDataURL()), typeof Image > "u") {
      var v = "Image width/height must been given explictly in svg-ssr renderer.";
      Qe(h, v), Qe(f, v);
    } else if (h == null || f == null) {
      var m = function(_, P) {
        if (_) {
          var D = _.elm, I = h || P.width, A = f || P.height;
          _.tag === "pattern" && (u ? (A = 1, I /= o.width) : c && (I = 1, A /= o.height)), _.attrs.width = I, _.attrs.height = A, D && (D.setAttribute("width", I), D.setAttribute("height", A));
        }
      }, y = dM(p, null, e, function(_) {
        l || m(w, _), m(d, _);
      });
      y && y.width && y.height && (h = h || y.width, f = f || y.height);
    }
    d = bn("image", "img", {
      href: p,
      width: h,
      height: f
    }), a.width = h, a.height = f;
  } else i.svgElement && (d = et(i.svgElement), a.width = i.svgWidth, a.height = i.svgHeight);
  if (d) {
    var C, S;
    l ? C = S = 1 : u ? (S = 1, C = a.width / o.width) : c ? (C = 1, S = a.height / o.height) : a.patternUnits = "userSpaceOnUse", C != null && !isNaN(C) && (a.width = C), S != null && !isNaN(S) && (a.height = S);
    var b = y$(i);
    b && (a.patternTransform = b);
    var w = bn("pattern", "", a, [d]), x = dD(w), E = n.patternCache, R = E[x];
    R || (R = n.zrId + "-p" + n.patternIdx++, E[x] = R, a.id = R, w = n.defs[R] = bn("pattern", R, a, [d])), t[r] = _S(R);
  }
}
function Bbe(e, t, r) {
  var n = r.clipPathCache, i = r.defs, o = n[e.id];
  if (!o) {
    o = r.zrId + "-c" + r.clipPathIdx++;
    var a = {
      id: o
    };
    n[e.id] = o, i[o] = bn("clipPath", o, a, [X7(e, r)]);
  }
  t["clip-path"] = _S(o);
}
function ck(e) {
  return document.createTextNode(e);
}
function Ku(e, t, r) {
  e.insertBefore(t, r);
}
function dk(e, t) {
  e.removeChild(t);
}
function hk(e, t) {
  e.appendChild(t);
}
function e9(e) {
  return e.parentNode;
}
function t9(e) {
  return e.nextSibling;
}
function P1(e, t) {
  e.textContent = t;
}
var fk = 58, Gbe = 120, Hbe = bn("", "");
function D_(e) {
  return e === void 0;
}
function ka(e) {
  return e !== void 0;
}
function zbe(e, t, r) {
  for (var n = {}, i = t; i <= r; ++i) {
    var o = e[i].key;
    o !== void 0 && (process.env.NODE_ENV !== "production" && n[o] != null && console.error("Duplicate key " + o), n[o] = i);
  }
  return n;
}
function Ap(e, t) {
  var r = e.key === t.key, n = e.tag === t.tag;
  return n && r;
}
function Kg(e) {
  var t, r = e.children, n = e.tag;
  if (ka(n)) {
    var i = e.elm = U7(n);
    if (gD(Hbe, e), fe(r))
      for (t = 0; t < r.length; ++t) {
        var o = r[t];
        o != null && hk(i, Kg(o));
      }
    else ka(e.text) && !Ze(e.text) && hk(i, ck(e.text));
  } else
    e.elm = ck(e.text);
  return e.elm;
}
function r9(e, t, r, n, i) {
  for (; n <= i; ++n) {
    var o = r[n];
    o != null && Ku(e, Kg(o), t);
  }
}
function mC(e, t, r, n) {
  for (; r <= n; ++r) {
    var i = t[r];
    if (i != null)
      if (ka(i.tag)) {
        var o = e9(i.elm);
        dk(o, i.elm);
      } else
        dk(e, i.elm);
  }
}
function gD(e, t) {
  var r, n = t.elm, i = e && e.attrs || {}, o = t.attrs || {};
  if (i !== o) {
    for (r in o) {
      var a = o[r], s = i[r];
      s !== a && (a === !0 ? n.setAttribute(r, "") : a === !1 ? n.removeAttribute(r) : r === "style" ? n.style.cssText = a : r.charCodeAt(0) !== Gbe ? n.setAttribute(r, a) : r === "xmlns:xlink" || r === "xmlns" ? n.setAttributeNS(wbe, r, a) : r.charCodeAt(3) === fk ? n.setAttributeNS(bbe, r, a) : r.charCodeAt(5) === fk ? n.setAttributeNS(j7, r, a) : n.setAttribute(r, a));
    }
    for (r in i)
      r in o || n.removeAttribute(r);
  }
}
function $be(e, t, r) {
  for (var n = 0, i = 0, o = t.length - 1, a = t[0], s = t[o], l = r.length - 1, u = r[0], c = r[l], d, h, f, p; n <= o && i <= l; )
    a == null ? a = t[++n] : s == null ? s = t[--o] : u == null ? u = r[++i] : c == null ? c = r[--l] : Ap(a, u) ? (Ud(a, u), a = t[++n], u = r[++i]) : Ap(s, c) ? (Ud(s, c), s = t[--o], c = r[--l]) : Ap(a, c) ? (Ud(a, c), Ku(e, a.elm, t9(s.elm)), a = t[++n], c = r[--l]) : Ap(s, u) ? (Ud(s, u), Ku(e, s.elm, a.elm), s = t[--o], u = r[++i]) : (D_(d) && (d = zbe(t, n, o)), h = d[u.key], D_(h) ? Ku(e, Kg(u), a.elm) : (f = t[h], f.tag !== u.tag ? Ku(e, Kg(u), a.elm) : (Ud(f, u), t[h] = void 0, Ku(e, f.elm, a.elm))), u = r[++i]);
  (n <= o || i <= l) && (n > o ? (p = r[l + 1] == null ? null : r[l + 1].elm, r9(e, p, r, i, l)) : mC(e, t, n, o));
}
function Ud(e, t) {
  var r = t.elm = e.elm, n = e.children, i = t.children;
  e !== t && (gD(e, t), D_(t.text) ? ka(n) && ka(i) ? n !== i && $be(r, n, i) : ka(i) ? (ka(e.text) && P1(r, ""), r9(r, null, i, 0, i.length - 1)) : ka(n) ? mC(r, n, 0, n.length - 1) : ka(e.text) && P1(r, "") : e.text !== t.text && (ka(n) && mC(r, n, 0, n.length - 1), P1(r, t.text)));
}
function Wbe(e, t) {
  if (Ap(e, t))
    Ud(e, t);
  else {
    var r = e.elm, n = e9(r);
    Kg(t), n !== null && (Ku(n, t.elm, t9(r)), mC(n, [e], 0, 0));
  }
  return t;
}
var jbe = 0, Ube = function() {
  function e(t, r, n) {
    if (this.type = "svg", this.refreshHover = pk("refreshHover"), this.configLayer = pk("configLayer"), this.storage = r, this._opts = n = se({}, n), this.root = t, this._id = "zr" + jbe++, this._oldVNode = rk(n.width, n.height), t && !n.ssr) {
      var i = this._viewport = document.createElement("div");
      i.style.cssText = "position:relative;overflow:hidden";
      var o = this._svgDom = this._oldVNode.elm = U7("svg");
      gD(null, this._oldVNode), i.appendChild(o), t.appendChild(i);
    }
    this.resize(n.width, n.height);
  }
  return e.prototype.getType = function() {
    return this.type;
  }, e.prototype.getViewportRoot = function() {
    return this._viewport;
  }, e.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, e.prototype.getSvgDom = function() {
    return this._svgDom;
  }, e.prototype.refresh = function() {
    if (this.root) {
      var t = this.renderToVNode({
        willUpdate: !0
      });
      t.attrs.style = "position:absolute;left:0;top:0;user-select:none", Wbe(this._oldVNode, t), this._oldVNode = t;
    }
  }, e.prototype.renderOneToVNode = function(t) {
    return uk(t, M_(this._id));
  }, e.prototype.renderToVNode = function(t) {
    t = t || {};
    var r = this.storage.getDisplayList(!0), n = this._width, i = this._height, o = M_(this._id);
    o.animation = t.animation, o.willUpdate = t.willUpdate, o.compress = t.compress, o.emphasis = t.emphasis;
    var a = [], s = this._bgVNode = Kbe(n, i, this._backgroundColor, o);
    s && a.push(s);
    var l = t.compress ? null : this._mainVNode = bn("g", "main", {}, []);
    this._paintList(r, o, l ? l.children : a), l && a.push(l);
    var u = ge(At(o.defs), function(h) {
      return o.defs[h];
    });
    if (u.length && a.push(bn("defs", "defs", {}, u)), t.animation) {
      var c = Rbe(o.cssNodes, o.cssAnims, { newline: !0 });
      if (c) {
        var d = bn("style", "stl", {}, [], c);
        a.push(d);
      }
    }
    return rk(n, i, a, t.useViewBox);
  }, e.prototype.renderToString = function(t) {
    return t = t || {}, dD(this.renderToVNode({
      animation: st(t.cssAnimation, !0),
      emphasis: st(t.cssEmphasis, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: st(t.useViewBox, !0)
    }), { newline: !0 });
  }, e.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t;
  }, e.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, e.prototype._paintList = function(t, r, n) {
    for (var i = t.length, o = [], a = 0, s, l, u = 0, c = 0; c < i; c++) {
      var d = t[c];
      if (!d.invisible) {
        var h = d.__clipPaths, f = h && h.length || 0, p = l && l.length || 0, g = void 0;
        for (g = Math.max(f - 1, p - 1); g >= 0 && !(h && l && h[g] === l[g]); g--)
          ;
        for (var v = p - 1; v > g; v--)
          a--, s = o[a - 1];
        for (var m = g + 1; m < f; m++) {
          var y = {};
          Bbe(h[m], y, r);
          var C = bn("g", "clip-g-" + u++, y, []);
          (s ? s.children : n).push(C), o[a++] = C, s = C;
        }
        l = h;
        var S = uk(d, r);
        S && (s ? s.children : n).push(S);
      }
    }
  }, e.prototype.resize = function(t, r) {
    var n = this._opts, i = this.root, o = this._viewport;
    if (t != null && (n.width = t), r != null && (n.height = r), i && o && (o.style.display = "none", t = nh(i, 0, n), r = nh(i, 1, n), o.style.display = ""), this._width !== t || this._height !== r) {
      if (this._width = t, this._height = r, o) {
        var a = o.style;
        a.width = t + "px", a.height = r + "px";
      }
      if (nM(this._backgroundColor))
        this.refresh();
      else {
        var s = this._svgDom;
        s && (s.setAttribute("width", t), s.setAttribute("height", r));
        var l = this._bgVNode && this._bgVNode.elm;
        l && (l.setAttribute("width", t), l.setAttribute("height", r));
      }
    }
  }, e.prototype.getWidth = function() {
    return this._width;
  }, e.prototype.getHeight = function() {
    return this._height;
  }, e.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, e.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, e.prototype.toDataURL = function(t) {
    var r = this.renderToString(), n = "data:image/svg+xml;";
    return t ? (r = Dge(r), r && n + "base64," + r) : n + "charset=UTF-8," + encodeURIComponent(r);
  }, e;
}();
function pk(e) {
  return function() {
    process.env.NODE_ENV !== "production" && Mo('In SVG mode painter not support method "' + e + '"');
  };
}
function Kbe(e, t, r, n) {
  var i;
  if (r && r !== "none")
    if (i = bn("rect", "bg", {
      width: e,
      height: t,
      x: "0",
      y: "0"
    }), v$(r))
      Q7({ fill: r }, i.attrs, "fill", n);
    else if (nM(r))
      J7({
        style: {
          fill: r
        },
        dirty: Kr,
        getBoundingRect: function() {
          return { width: e, height: t };
        }
      }, i.attrs, "fill", n);
    else {
      var o = Ng(r), a = o.color, s = o.opacity;
      i.attrs.fill = a, s < 1 && (i.attrs["fill-opacity"] = s);
    }
  return i;
}
function Ybe(e) {
  e.registerPainter("svg", Ube);
}
function gk(e, t, r) {
  var n = va.createCanvas(), i = t.getWidth(), o = t.getHeight(), a = n.style;
  return a && (a.position = "absolute", a.left = "0", a.top = "0", a.width = i + "px", a.height = o + "px", n.setAttribute("data-zr-dom-id", e)), n.width = i * r, n.height = o * r, n;
}
var M1 = function(e) {
  Mr(t, e);
  function t(r, n, i) {
    var o = e.call(this) || this;
    o.motionBlur = !1, o.lastFrameAlpha = 0.7, o.dpr = 1, o.virtual = !1, o.config = {}, o.incremental = !1, o.zlevel = 0, o.maxRepaintRectCount = 5, o.__dirty = !0, o.__firstTimePaint = !0, o.__used = !1, o.__drawIndex = 0, o.__startIndex = 0, o.__endIndex = 0, o.__prevStartIndex = null, o.__prevEndIndex = null;
    var a;
    i = i || j0, typeof r == "string" ? a = gk(r, n, i) : Ze(r) && (a = r, r = a.id), o.id = r, o.dom = a;
    var s = a.style;
    return s && (QP(a), a.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), o.painter = n, o.dpr = i, o;
  }
  return t.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, t.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, t.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, t.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, t.prototype.createBackBuffer = function() {
    var r = this.dpr;
    this.domBack = gk("back-" + this.id, this.painter, r), this.ctxBack = this.domBack.getContext("2d"), r !== 1 && this.ctxBack.scale(r, r);
  }, t.prototype.createRepaintRects = function(r, n, i, o) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var a = [], s = this.maxRepaintRectCount, l = !1, u = new St(0, 0, 0, 0);
    function c(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (a.length === 0) {
          var C = new St(0, 0, 0, 0);
          C.copy(y), a.push(C);
        } else {
          for (var S = !1, b = 1 / 0, w = 0, x = 0; x < a.length; ++x) {
            var E = a[x];
            if (E.intersect(y)) {
              var R = new St(0, 0, 0, 0);
              R.copy(E), R.union(y), a[x] = R, S = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(E);
              var _ = y.width * y.height, P = E.width * E.height, D = u.width * u.height, I = D - _ - P;
              I < b && (b = I, w = x);
            }
          }
          if (l && (a[w].union(y), S = !0), !S) {
            var C = new St(0, 0, 0, 0);
            C.copy(y), a.push(C);
          }
          l || (l = a.length >= s);
        }
    }
    for (var d = this.__startIndex; d < this.__endIndex; ++d) {
      var h = r[d];
      if (h) {
        var f = h.shouldBePainted(i, o, !0, !0), p = h.__isRendered && (h.__dirty & qi || !f) ? h.getPrevPaintRect() : null;
        p && c(p);
        var g = f && (h.__dirty & qi || !h.__isRendered) ? h.getPaintRect() : null;
        g && c(g);
      }
    }
    for (var d = this.__prevStartIndex; d < this.__prevEndIndex; ++d) {
      var h = n[d], f = h && h.shouldBePainted(i, o, !0, !0);
      if (h && (!f || !h.__zr) && h.__isRendered) {
        var p = h.getPrevPaintRect();
        p && c(p);
      }
    }
    var v;
    do {
      v = !1;
      for (var d = 0; d < a.length; ) {
        if (a[d].isZero()) {
          a.splice(d, 1);
          continue;
        }
        for (var m = d + 1; m < a.length; )
          a[d].intersect(a[m]) ? (v = !0, a[d].union(a[m]), a.splice(m, 1)) : m++;
        d++;
      }
    } while (v);
    return this._paintRects = a, a;
  }, t.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, t.prototype.resize = function(r, n) {
    var i = this.dpr, o = this.dom, a = o.style, s = this.domBack;
    a && (a.width = r + "px", a.height = n + "px"), o.width = r * i, o.height = n * i, s && (s.width = r * i, s.height = n * i, i !== 1 && this.ctxBack.scale(i, i));
  }, t.prototype.clear = function(r, n, i) {
    var o = this.dom, a = this.ctx, s = o.width, l = o.height;
    n = n || this.clearColor;
    var u = this.motionBlur && !r, c = this.lastFrameAlpha, d = this.dpr, h = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(o, 0, 0, s / d, l / d));
    var f = this.domBack;
    function p(g, v, m, y) {
      if (a.clearRect(g, v, m, y), n && n !== "transparent") {
        var C = void 0;
        if (bv(n)) {
          var S = n.global || n.__width === m && n.__height === y;
          C = S && n.__canvasGradient || C_(a, n, {
            x: 0,
            y: 0,
            width: m,
            height: y
          }), n.__canvasGradient = C, n.__width = m, n.__height = y;
        } else K3(n) && (n.scaleX = n.scaleX || d, n.scaleY = n.scaleY || d, C = S_(a, n, {
          dirty: function() {
            h.setUnpainted(), h.painter.refresh();
          }
        }));
        a.save(), a.fillStyle = C || n, a.fillRect(g, v, m, y), a.restore();
      }
      u && (a.save(), a.globalAlpha = c, a.drawImage(f, g, v, m, y), a.restore());
    }
    !i || u ? p(0, 0, s, l) : i.length && B(i, function(g) {
      p(g.x * d, g.y * d, g.width * d, g.height * d);
    });
  }, t;
}(Go), vk = 1e5, Fu = 314159, ny = 0.01, qbe = 1e-3;
function Zbe(e) {
  return e ? e.__builtin__ ? !0 : !(typeof e.resize != "function" || typeof e.refresh != "function") : !1;
}
function Xbe(e, t) {
  var r = document.createElement("div");
  return r.style.cssText = [
    "position:relative",
    "width:" + e + "px",
    "height:" + t + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", r;
}
var Qbe = function() {
  function e(t, r, n, i) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var o = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    this._opts = n = se({}, n || {}), this.dpr = n.devicePixelRatio || j0, this._singleCanvas = o, this.root = t;
    var a = t.style;
    a && (QP(t), t.innerHTML = ""), this.storage = r;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (o) {
      var c = t, d = c.width, h = c.height;
      n.width != null && (d = n.width), n.height != null && (h = n.height), this.dpr = n.devicePixelRatio || 1, c.width = d * this.dpr, c.height = h * this.dpr, this._width = d, this._height = h;
      var f = new M1(c, this, this.dpr);
      f.__builtin__ = !0, f.initContext(), l[Fu] = f, f.zlevel = Fu, s.push(Fu), this._domRoot = t;
    } else {
      this._width = nh(t, 0, n), this._height = nh(t, 1, n);
      var u = this._domRoot = Xbe(this._width, this._height);
      t.appendChild(u);
    }
  }
  return e.prototype.getType = function() {
    return "canvas";
  }, e.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, e.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, e.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, e.prototype.refresh = function(t) {
    var r = this.storage.getDisplayList(!0), n = this._prevDisplayList, i = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(r, n, t, this._redrawId);
    for (var o = 0; o < i.length; o++) {
      var a = i[o], s = this._layers[a];
      if (!s.__builtin__ && s.refresh) {
        var l = o === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = r.slice()), this;
  }, e.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, e.prototype._paintHoverList = function(t) {
    var r = t.length, n = this._hoverlayer;
    if (n && n.clear(), !!r) {
      for (var i = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, o, a = 0; a < r; a++) {
        var s = t[a];
        s.__inHover && (n || (n = this._hoverlayer = this.getLayer(vk)), o || (o = n.ctx, o.save()), ac(o, s, i, a === r - 1));
      }
      o && o.restore();
    }
  }, e.prototype.getHoverLayer = function() {
    return this.getLayer(vk);
  }, e.prototype.paintOne = function(t, r) {
    jM(t, r);
  }, e.prototype._paintList = function(t, r, n, i) {
    if (this._redrawId === i) {
      n = n || !1, this._updateLayerStatus(t);
      var o = this._doPaintList(t, r, n), a = o.finished, s = o.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(t), a)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        B0(function() {
          l._paintList(t, r, n, i);
        });
      }
    }
  }, e.prototype._compositeManually = function() {
    var t = this.getLayer(Fu).ctx, r = this._domRoot.width, n = this._domRoot.height;
    t.clearRect(0, 0, r, n), this.eachBuiltinLayer(function(i) {
      i.virtual && t.drawImage(i.dom, 0, 0, r, n);
    });
  }, e.prototype._doPaintList = function(t, r, n) {
    for (var i = this, o = [], a = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && o.push(u);
    }
    for (var c = !0, d = !1, h = function(g) {
      var v = o[g], m = v.ctx, y = a && v.createRepaintRects(t, r, f._width, f._height), C = n ? v.__startIndex : v.__drawIndex, S = !n && v.incremental && Date.now, b = S && Date.now(), w = v.zlevel === f._zlevelList[0] ? f._backgroundColor : null;
      if (v.__startIndex === v.__endIndex)
        v.clear(!1, w, y);
      else if (C === v.__startIndex) {
        var x = t[C];
        (!x.incremental || !x.notClear || n) && v.clear(!1, w, y);
      }
      C === -1 && (console.error("For some unknown reason. drawIndex is -1"), C = v.__startIndex);
      var E, R = function(I) {
        var A = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: i._width,
          viewHeight: i._height
        };
        for (E = C; E < v.__endIndex; E++) {
          var O = t[E];
          if (O.__inHover && (d = !0), i._doPaintEl(O, v, a, I, A, E === v.__endIndex - 1), S) {
            var L = Date.now() - b;
            if (L > 15)
              break;
          }
        }
        A.prevElClipPaths && m.restore();
      };
      if (y)
        if (y.length === 0)
          E = v.__endIndex;
        else
          for (var _ = f.dpr, P = 0; P < y.length; ++P) {
            var D = y[P];
            m.save(), m.beginPath(), m.rect(D.x * _, D.y * _, D.width * _, D.height * _), m.clip(), R(D), m.restore();
          }
      else
        m.save(), R(), m.restore();
      v.__drawIndex = E, v.__drawIndex < v.__endIndex && (c = !1);
    }, f = this, p = 0; p < o.length; p++)
      h(p);
    return kt.wxa && B(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: d
    };
  }, e.prototype._doPaintEl = function(t, r, n, i, o, a) {
    var s = r.ctx;
    if (n) {
      var l = t.getPaintRect();
      (!i || l && l.intersect(i)) && (ac(s, t, o, a), t.setPrevPaintRect(l));
    } else
      ac(s, t, o, a);
  }, e.prototype.getLayer = function(t, r) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = Fu);
    var n = this._layers[t];
    return n || (n = new M1("zr_" + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] ? yt(n, this._layerConfig[t], !0) : this._layerConfig[t - ny] && yt(n, this._layerConfig[t - ny], !0), r && (n.virtual = r), this.insertLayer(t, n), n.initContext()), n;
  }, e.prototype.insertLayer = function(t, r) {
    var n = this._layers, i = this._zlevelList, o = i.length, a = this._domRoot, s = null, l = -1;
    if (n[t]) {
      process.env.NODE_ENV !== "production" && Mo("ZLevel " + t + " has been used already");
      return;
    }
    if (!Zbe(r)) {
      process.env.NODE_ENV !== "production" && Mo("Layer of zlevel " + t + " is not valid");
      return;
    }
    if (o > 0 && t > i[0]) {
      for (l = 0; l < o - 1 && !(i[l] < t && i[l + 1] > t); l++)
        ;
      s = n[i[l]];
    }
    if (i.splice(l + 1, 0, t), n[t] = r, !r.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? a.insertBefore(r.dom, u.nextSibling) : a.appendChild(r.dom);
      } else
        a.firstChild ? a.insertBefore(r.dom, a.firstChild) : a.appendChild(r.dom);
    r.painter || (r.painter = this);
  }, e.prototype.eachLayer = function(t, r) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var o = n[i];
      t.call(r, this._layers[o], o);
    }
  }, e.prototype.eachBuiltinLayer = function(t, r) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var o = n[i], a = this._layers[o];
      a.__builtin__ && t.call(r, a, o);
    }
  }, e.prototype.eachOtherLayer = function(t, r) {
    for (var n = this._zlevelList, i = 0; i < n.length; i++) {
      var o = n[i], a = this._layers[o];
      a.__builtin__ || t.call(r, a, o);
    }
  }, e.prototype.getLayers = function() {
    return this._layers;
  }, e.prototype._updateLayerStatus = function(t) {
    this.eachBuiltinLayer(function(d, h) {
      d.__dirty = d.__used = !1;
    });
    function r(d) {
      o && (o.__endIndex !== d && (o.__dirty = !0), o.__endIndex = d);
    }
    if (this._singleCanvas)
      for (var n = 1; n < t.length; n++) {
        var i = t[n];
        if (i.zlevel !== t[n - 1].zlevel || i.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var o = null, a = 0, s, l;
    for (l = 0; l < t.length; l++) {
      var i = t[l], u = i.zlevel, c = void 0;
      s !== u && (s = u, a = 0), i.incremental ? (c = this.getLayer(u + qbe, this._needsManuallyCompositing), c.incremental = !0, a = 1) : c = this.getLayer(u + (a > 0 ? ny : 0), this._needsManuallyCompositing), c.__builtin__ || Mo("ZLevel " + u + " has been used by unkown layer " + c.id), c !== o && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, r(l), o = c), i.__dirty & qi && !i.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    r(l), this.eachBuiltinLayer(function(d, h) {
      !d.__used && d.getElementCount() > 0 && (d.__dirty = !0, d.__startIndex = d.__endIndex = d.__drawIndex = 0), d.__dirty && d.__drawIndex < 0 && (d.__drawIndex = d.__startIndex);
    });
  }, e.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, e.prototype._clearLayer = function(t) {
    t.clear();
  }, e.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t, B(this._layers, function(r) {
      r.setUnpainted();
    });
  }, e.prototype.configLayer = function(t, r) {
    if (r) {
      var n = this._layerConfig;
      n[t] ? yt(n[t], r, !0) : n[t] = r;
      for (var i = 0; i < this._zlevelList.length; i++) {
        var o = this._zlevelList[i];
        if (o === t || o === t + ny) {
          var a = this._layers[o];
          yt(a, n[t], !0);
        }
      }
    }
  }, e.prototype.delLayer = function(t) {
    var r = this._layers, n = this._zlevelList, i = r[t];
    i && (i.dom.parentNode.removeChild(i.dom), delete r[t], n.splice(bt(n, t), 1));
  }, e.prototype.resize = function(t, r) {
    if (this._domRoot.style) {
      var n = this._domRoot;
      n.style.display = "none";
      var i = this._opts, o = this.root;
      if (t != null && (i.width = t), r != null && (i.height = r), t = nh(o, 0, i), r = nh(o, 1, i), n.style.display = "", this._width !== t || r !== this._height) {
        n.style.width = t + "px", n.style.height = r + "px";
        for (var a in this._layers)
          this._layers.hasOwnProperty(a) && this._layers[a].resize(t, r);
        this.refresh(!0);
      }
      this._width = t, this._height = r;
    } else {
      if (t == null || r == null)
        return;
      this._width = t, this._height = r, this.getLayer(Fu).resize(t, r);
    }
    return this;
  }, e.prototype.clearLayer = function(t) {
    var r = this._layers[t];
    r && r.clear();
  }, e.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, e.prototype.getRenderedCanvas = function(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Fu].dom;
    var r = new M1("image", this, t.pixelRatio || this.dpr);
    r.initContext(), r.clear(!1, t.backgroundColor || this._backgroundColor);
    var n = r.ctx;
    if (t.pixelRatio <= this.dpr) {
      this.refresh();
      var i = r.dom.width, o = r.dom.height;
      this.eachLayer(function(d) {
        d.__builtin__ ? n.drawImage(d.dom, 0, 0, i, o) : d.renderToCanvas && (n.save(), d.renderToCanvas(n), n.restore());
      });
    } else
      for (var a = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        ac(n, c, a, l === u - 1);
      }
    return r.dom;
  }, e.prototype.getWidth = function() {
    return this._width;
  }, e.prototype.getHeight = function() {
    return this._height;
  }, e;
}();
function Jbe(e) {
  e.registerPainter("canvas", Qbe);
}
var e1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.getInitialData = function(r) {
      if (process.env.NODE_ENV !== "production") {
        var n = r.coordinateSystem;
        if (n !== "polar" && n !== "cartesian2d")
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
      return os(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getLegendIcon = function(r) {
      var n = new it(), i = rn("line", 0, r.itemHeight / 2, r.itemWidth, 0, r.lineStyle.stroke, !1);
      n.add(i), i.setStyle(r.lineStyle);
      var o = this.getData().getVisual("symbol"), a = this.getData().getVisual("symbolRotate"), s = o === "none" ? "circle" : o, l = r.itemHeight * 0.8, u = rn(s, (r.itemWidth - l) / 2, (r.itemHeight - l) / 2, l, l, r.itemStyle.fill);
      n.add(u), u.setStyle(r.itemStyle);
      var c = r.iconRotate === "inherit" ? a : r.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([r.itemWidth / 2, r.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), n;
    }, t.type = "series.line", t.dependencies = ["grid", "polar"], t.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, t;
  }(hr)
);
function kh(e, t) {
  var r = e.mapDimensionsAll("defaultedLabel"), n = r.length;
  if (n === 1) {
    var i = Oh(e, t, r[0]);
    return i != null ? i + "" : null;
  } else if (n) {
    for (var o = [], a = 0; a < r.length; a++)
      o.push(Oh(e, t, r[a]));
    return o.join(" ");
  }
}
function n9(e, t) {
  var r = e.mapDimensionsAll("defaultedLabel");
  if (!fe(t))
    return t + "";
  for (var n = [], i = 0; i < r.length; i++) {
    var o = e.getDimensionIndex(r[i]);
    o >= 0 && n.push(t[o]);
  }
  return n.join(" ");
}
var kv = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i, o) {
      var a = e.call(this) || this;
      return a.updateData(r, n, i, o), a;
    }
    return t.prototype._createSymbol = function(r, n, i, o, a) {
      this.removeAll();
      var s = rn(r, -1, -1, 2, 2, null, a);
      s.attr({
        z2: 100,
        culling: !0,
        scaleX: o[0] / 2,
        scaleY: o[1] / 2
      }), s.drift = t1e, this._symbolType = r, this.add(s);
    }, t.prototype.stopSymbolAnimation = function(r) {
      this.childAt(0).stopAnimation(null, r);
    }, t.prototype.getSymbolType = function() {
      return this._symbolType;
    }, t.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, t.prototype.highlight = function() {
      zs(this.childAt(0));
    }, t.prototype.downplay = function() {
      $s(this.childAt(0));
    }, t.prototype.setZ = function(r, n) {
      var i = this.childAt(0);
      i.zlevel = r, i.z = n;
    }, t.prototype.setDraggable = function(r, n) {
      var i = this.childAt(0);
      i.draggable = r, i.cursor = !n && r ? "move" : i.cursor;
    }, t.prototype.updateData = function(r, n, i, o) {
      this.silent = !1;
      var a = r.getItemVisual(n, "symbol") || "circle", s = r.hostModel, l = t.getSymbolSize(r, n), u = a !== this._symbolType, c = o && o.disableAnimation;
      if (u) {
        var d = r.getItemVisual(n, "symbolKeepAspect");
        this._createSymbol(a, r, n, l, d);
      } else {
        var h = this.childAt(0);
        h.silent = !1;
        var f = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        c ? h.attr(f) : jt(h, f, s, n), Ca(h);
      }
      if (this._updateCommon(r, n, l, i, o), u) {
        var h = this.childAt(0);
        if (!c) {
          var f = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: h.style.opacity
            }
          };
          h.scaleX = h.scaleY = 0, h.style.opacity = 0, Pr(h, f, s, n);
        }
      }
      c && this.childAt(0).stopAnimation("leave");
    }, t.prototype._updateCommon = function(r, n, i, o, a) {
      var s = this.childAt(0), l = r.hostModel, u, c, d, h, f, p, g, v, m;
      if (o && (u = o.emphasisItemStyle, c = o.blurItemStyle, d = o.selectItemStyle, h = o.focus, f = o.blurScope, g = o.labelStatesModels, v = o.hoverScale, m = o.cursorStyle, p = o.emphasisDisabled), !o || r.hasItemOption) {
        var y = o && o.itemModel ? o.itemModel : r.getItemModel(n), C = y.getModel("emphasis");
        u = C.getModel("itemStyle").getItemStyle(), d = y.getModel(["select", "itemStyle"]).getItemStyle(), c = y.getModel(["blur", "itemStyle"]).getItemStyle(), h = C.get("focus"), f = C.get("blurScope"), p = C.get("disabled"), g = Rn(y), v = C.getShallow("scale"), m = y.getShallow("cursor");
      }
      var S = r.getItemVisual(n, "symbolRotate");
      s.attr("rotation", (S || 0) * Math.PI / 180 || 0);
      var b = qc(r.getItemVisual(n, "symbolOffset"), i);
      b && (s.x = b[0], s.y = b[1]), m && s.attr("cursor", m);
      var w = r.getItemVisual(n, "style"), x = w.fill;
      if (s instanceof In) {
        var E = s.style;
        s.useStyle(se({
          // TODO other properties like x, y ?
          image: E.image,
          x: E.x,
          y: E.y,
          width: E.width,
          height: E.height
        }, w));
      } else
        s.__isEmptyBrush ? s.useStyle(se({}, w)) : s.useStyle(w), s.style.decal = null, s.setColor(x, a && a.symbolInnerColor), s.style.strokeNoScale = !0;
      var R = r.getItemVisual(n, "liftZ"), _ = this._z2;
      R != null ? _ == null && (this._z2 = s.z2, s.z2 += R) : _ != null && (s.z2 = _, this._z2 = null);
      var P = a && a.useNameLabel;
      Gn(s, g, {
        labelFetcher: l,
        labelDataIndex: n,
        defaultText: D,
        inheritColor: x,
        defaultOpacity: w.opacity
      });
      function D(O) {
        return P ? r.getName(O) : kh(r, O);
      }
      this._sizeX = i[0] / 2, this._sizeY = i[1] / 2;
      var I = s.ensureState("emphasis");
      I.style = u, s.ensureState("select").style = d, s.ensureState("blur").style = c;
      var A = v == null || v === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(v) && v > 0 ? +v : 1;
      I.scaleX = this._sizeX * A, I.scaleY = this._sizeY * A, this.setSymbolScale(1), Hr(this, h, f, p);
    }, t.prototype.setSymbolScale = function(r) {
      this.scaleX = this.scaleY = r;
    }, t.prototype.fadeOut = function(r, n, i) {
      var o = this.childAt(0), a = ot(this).dataIndex, s = i && i.animation;
      if (this.silent = o.silent = !0, i && i.fadeLabel) {
        var l = o.getTextContent();
        l && Ul(l, {
          style: {
            opacity: 0
          }
        }, n, {
          dataIndex: a,
          removeOpt: s,
          cb: function() {
            o.removeTextContent();
          }
        });
      } else
        o.removeTextContent();
      Ul(o, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, n, {
        dataIndex: a,
        cb: r,
        removeOpt: s
      });
    }, t.getSymbolSize = function(r, n) {
      return vf(r.getItemVisual(n, "symbolSize"));
    }, t;
  }(it)
);
function t1e(e, t) {
  this.parent.drift(e, t);
}
function D1(e, t, r, n) {
  return t && !isNaN(t[0]) && !isNaN(t[1]) && !(n.isIgnore && n.isIgnore(r)) && !(n.clipShape && !n.clipShape.contain(t[0], t[1])) && e.getItemVisual(r, "symbol") !== "none";
}
function mk(e) {
  return e != null && !Ze(e) && (e = {
    isIgnore: e
  }), e || {};
}
function yk(e) {
  var t = e.hostModel, r = t.getModel("emphasis");
  return {
    emphasisItemStyle: r.getModel("itemStyle").getItemStyle(),
    blurItemStyle: t.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: t.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: r.get("focus"),
    blurScope: r.get("blurScope"),
    emphasisDisabled: r.get("disabled"),
    hoverScale: r.get("scale"),
    labelStatesModels: Rn(t),
    cursorStyle: t.get("cursor")
  };
}
var Vv = (
  /** @class */
  function() {
    function e(t) {
      this.group = new it(), this._SymbolCtor = t || kv;
    }
    return e.prototype.updateData = function(t, r) {
      this._progressiveEls = null, r = mk(r);
      var n = this.group, i = t.hostModel, o = this._data, a = this._SymbolCtor, s = r.disableAnimation, l = yk(t), u = {
        disableAnimation: s
      }, c = r.getSymbolPoint || function(d) {
        return t.getItemLayout(d);
      };
      o || n.removeAll(), t.diff(o).add(function(d) {
        var h = c(d);
        if (D1(t, h, d, r)) {
          var f = new a(t, d, l, u);
          f.setPosition(h), t.setItemGraphicEl(d, f), n.add(f);
        }
      }).update(function(d, h) {
        var f = o.getItemGraphicEl(h), p = c(d);
        if (!D1(t, p, d, r)) {
          n.remove(f);
          return;
        }
        var g = t.getItemVisual(d, "symbol") || "circle", v = f && f.getSymbolType && f.getSymbolType();
        if (!f || v && v !== g)
          n.remove(f), f = new a(t, d, l, u), f.setPosition(p);
        else {
          f.updateData(t, d, l, u);
          var m = {
            x: p[0],
            y: p[1]
          };
          s ? f.attr(m) : jt(f, m, i);
        }
        n.add(f), t.setItemGraphicEl(d, f);
      }).remove(function(d) {
        var h = o.getItemGraphicEl(d);
        h && h.fadeOut(function() {
          n.remove(h);
        }, i);
      }).execute(), this._getSymbolPoint = c, this._data = t;
    }, e.prototype.updateLayout = function() {
      var t = this, r = this._data;
      r && r.eachItemGraphicEl(function(n, i) {
        var o = t._getSymbolPoint(i);
        n.setPosition(o), n.markRedraw();
      });
    }, e.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = yk(t), this._data = null, this.group.removeAll();
    }, e.prototype.incrementalUpdate = function(t, r, n) {
      this._progressiveEls = [], n = mk(n);
      function i(l) {
        l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0);
      }
      for (var o = t.start; o < t.end; o++) {
        var a = r.getItemLayout(o);
        if (D1(r, a, o, n)) {
          var s = new this._SymbolCtor(r, o, this._seriesScope);
          s.traverse(i), s.setPosition(a), this.group.add(s), r.setItemGraphicEl(o, s), this._progressiveEls.push(s);
        }
      }
    }, e.prototype.eachRendered = function(t) {
      iu(this._progressiveEls || this.group, t);
    }, e.prototype.remove = function(t) {
      var r = this.group, n = this._data;
      n && t ? n.eachItemGraphicEl(function(i) {
        i.fadeOut(function() {
          r.remove(i);
        }, n.hostModel);
      }) : r.removeAll();
    }, e;
  }()
);
function i9(e, t, r) {
  var n = e.getBaseAxis(), i = e.getOtherAxis(n), o = r1e(i, r), a = n.dim, s = i.dim, l = t.mapDimension(s), u = t.mapDimension(a), c = s === "x" || s === "radius" ? 1 : 0, d = ge(e.dimensions, function(p) {
    return t.mapDimension(p);
  }), h = !1, f = t.getCalculationInfo("stackResultDimension");
  return js(
    t,
    d[0]
    /* , dims[1] */
  ) && (h = !0, d[0] = f), js(
    t,
    d[1]
    /* , dims[0] */
  ) && (h = !0, d[1] = f), {
    dataDimsForPoint: d,
    valueStart: o,
    valueAxisDim: s,
    baseAxisDim: a,
    stacked: !!h,
    valueDim: l,
    baseDim: u,
    baseDataOffset: c,
    stackedOverDimension: t.getCalculationInfo("stackedOverDimension")
  };
}
function r1e(e, t) {
  var r = 0, n = e.scale.getExtent();
  return t === "start" ? r = n[0] : t === "end" ? r = n[1] : $t(t) && !isNaN(t) ? r = t : n[0] > 0 ? r = n[0] : n[1] < 0 && (r = n[1]), r;
}
function o9(e, t, r, n) {
  var i = NaN;
  e.stacked && (i = r.get(r.getCalculationInfo("stackedOverDimension"), n)), isNaN(i) && (i = e.valueStart);
  var o = e.baseDataOffset, a = [];
  return a[o] = r.get(e.baseDim, n), a[1 - o] = i, t.dataToPoint(a);
}
function n1e(e, t) {
  var r = [];
  return t.diff(e).add(function(n) {
    r.push({
      cmd: "+",
      idx: n
    });
  }).update(function(n, i) {
    r.push({
      cmd: "=",
      idx: i,
      idx1: n
    });
  }).remove(function(n) {
    r.push({
      cmd: "-",
      idx: n
    });
  }).execute(), r;
}
function i1e(e, t, r, n, i, o, a, s) {
  for (var l = n1e(e, t), u = [], c = [], d = [], h = [], f = [], p = [], g = [], v = i9(i, t, a), m = e.getLayout("points") || [], y = t.getLayout("points") || [], C = 0; C < l.length; C++) {
    var S = l[C], b = !0, w = void 0, x = void 0;
    switch (S.cmd) {
      case "=":
        w = S.idx * 2, x = S.idx1 * 2;
        var E = m[w], R = m[w + 1], _ = y[x], P = y[x + 1];
        (isNaN(E) || isNaN(R)) && (E = _, R = P), u.push(E, R), c.push(_, P), d.push(r[w], r[w + 1]), h.push(n[x], n[x + 1]), g.push(t.getRawIndex(S.idx1));
        break;
      case "+":
        var D = S.idx, I = v.dataDimsForPoint, A = i.dataToPoint([t.get(I[0], D), t.get(I[1], D)]);
        x = D * 2, u.push(A[0], A[1]), c.push(y[x], y[x + 1]);
        var O = o9(v, i, t, D);
        d.push(O[0], O[1]), h.push(n[x], n[x + 1]), g.push(t.getRawIndex(D));
        break;
      case "-":
        b = !1;
    }
    b && (f.push(S), p.push(p.length));
  }
  p.sort(function(W, j) {
    return g[W] - g[j];
  });
  for (var L = u.length, N = $a(L), F = $a(L), G = $a(L), M = $a(L), V = [], C = 0; C < p.length; C++) {
    var z = p[C], k = C * 2, $ = z * 2;
    N[k] = u[$], N[k + 1] = u[$ + 1], F[k] = c[$], F[k + 1] = c[$ + 1], G[k] = d[$], G[k + 1] = d[$ + 1], M[k] = h[$], M[k + 1] = h[$ + 1], V[C] = f[z];
  }
  return {
    current: N,
    next: F,
    stackedOnCurrent: G,
    stackedOnNext: M,
    status: V
  };
}
var fl = Math.min, pl = Math.max;
function vc(e, t) {
  return isNaN(e) || isNaN(t);
}
function A_(e, t, r, n, i, o, a, s, l) {
  for (var u, c, d, h, f, p, g = r, v = 0; v < n; v++) {
    var m = t[g * 2], y = t[g * 2 + 1];
    if (g >= i || g < 0)
      break;
    if (vc(m, y)) {
      if (l) {
        g += o;
        continue;
      }
      break;
    }
    if (g === r)
      e[o > 0 ? "moveTo" : "lineTo"](m, y), d = m, h = y;
    else {
      var C = m - u, S = y - c;
      if (C * C + S * S < 0.5) {
        g += o;
        continue;
      }
      if (a > 0) {
        for (var b = g + o, w = t[b * 2], x = t[b * 2 + 1]; w === m && x === y && v < n; )
          v++, b += o, g += o, w = t[b * 2], x = t[b * 2 + 1], m = t[g * 2], y = t[g * 2 + 1], C = m - u, S = y - c;
        var E = v + 1;
        if (l)
          for (; vc(w, x) && E < n; )
            E++, b += o, w = t[b * 2], x = t[b * 2 + 1];
        var R = 0.5, _ = 0, P = 0, D = void 0, I = void 0;
        if (E >= n || vc(w, x))
          f = m, p = y;
        else {
          _ = w - u, P = x - c;
          var A = m - u, O = w - m, L = y - c, N = x - y, F = void 0, G = void 0;
          if (s === "x") {
            F = Math.abs(A), G = Math.abs(O);
            var M = _ > 0 ? 1 : -1;
            f = m - M * F * a, p = y, D = m + M * G * a, I = y;
          } else if (s === "y") {
            F = Math.abs(L), G = Math.abs(N);
            var V = P > 0 ? 1 : -1;
            f = m, p = y - V * F * a, D = m, I = y + V * G * a;
          } else
            F = Math.sqrt(A * A + L * L), G = Math.sqrt(O * O + N * N), R = G / (G + F), f = m - _ * a * (1 - R), p = y - P * a * (1 - R), D = m + _ * a * R, I = y + P * a * R, D = fl(D, pl(w, m)), I = fl(I, pl(x, y)), D = pl(D, fl(w, m)), I = pl(I, fl(x, y)), _ = D - m, P = I - y, f = m - _ * F / G, p = y - P * F / G, f = fl(f, pl(u, m)), p = fl(p, pl(c, y)), f = pl(f, fl(u, m)), p = pl(p, fl(c, y)), _ = m - f, P = y - p, D = m + _ * G / F, I = y + P * G / F;
        }
        e.bezierCurveTo(d, h, f, p, m, y), d = D, h = I;
      } else
        e.lineTo(m, y);
    }
    u = m, c = y, g += o;
  }
  return v;
}
var a9 = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return e;
  }()
), o1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "ec-polyline", n;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new a9();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points, o = 0, a = i.length / 2;
      if (n.connectNulls) {
        for (; a > 0 && vc(i[a * 2 - 2], i[a * 2 - 1]); a--)
          ;
        for (; o < a && vc(i[o * 2], i[o * 2 + 1]); o++)
          ;
      }
      for (; o < a; )
        o += A_(r, i, o, a, a, 1, n.smooth, n.smoothMonotone, n.connectNulls) + 1;
    }, t.prototype.getPointOn = function(r, n) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var i = this.path, o = i.data, a = es.CMD, s, l, u = n === "x", c = [], d = 0; d < o.length; ) {
        var h = o[d++], f = void 0, p = void 0, g = void 0, v = void 0, m = void 0, y = void 0, C = void 0;
        switch (h) {
          case a.M:
            s = o[d++], l = o[d++];
            break;
          case a.L:
            if (f = o[d++], p = o[d++], C = u ? (r - s) / (f - s) : (r - l) / (p - l), C <= 1 && C >= 0) {
              var S = u ? (p - l) * C + l : (f - s) * C + s;
              return u ? [r, S] : [S, r];
            }
            s = f, l = p;
            break;
          case a.C:
            f = o[d++], p = o[d++], g = o[d++], v = o[d++], m = o[d++], y = o[d++];
            var b = u ? H0(s, f, g, m, r, c) : H0(l, p, v, y, r, c);
            if (b > 0)
              for (var w = 0; w < b; w++) {
                var x = c[w];
                if (x <= 1 && x >= 0) {
                  var S = u ? Sn(l, p, v, y, x) : Sn(s, f, g, m, x);
                  return u ? [r, S] : [S, r];
                }
              }
            s = m, l = y;
            break;
        }
      }
    }, t;
  }(Mt)
), a1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  }(a9)
), s9 = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "ec-polygon", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new a1e();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points, o = n.stackedOnPoints, a = 0, s = i.length / 2, l = n.smoothMonotone;
      if (n.connectNulls) {
        for (; s > 0 && vc(i[s * 2 - 2], i[s * 2 - 1]); s--)
          ;
        for (; a < s && vc(i[a * 2], i[a * 2 + 1]); a++)
          ;
      }
      for (; a < s; ) {
        var u = A_(r, i, a, s, s, 1, n.smooth, l, n.connectNulls);
        A_(r, o, a + u - 1, u, s, -1, n.stackedOnSmooth, l, n.connectNulls), a += u + 1, r.closePath();
      }
    }, t;
  }(Mt)
);
function l9(e, t, r, n, i) {
  var o = e.getArea(), a = o.x, s = o.y, l = o.width, u = o.height, c = r.get(["lineStyle", "width"]) || 2;
  a -= c / 2, s -= c / 2, l += c, u += c, l = Math.ceil(l), a !== Math.floor(a) && (a = Math.floor(a), l++);
  var d = new Bt({
    shape: {
      x: a,
      y: s,
      width: l,
      height: u
    }
  });
  if (t) {
    var h = e.getBaseAxis(), f = h.isHorizontal(), p = h.inverse;
    f ? (p && (d.shape.x += l), d.shape.width = 0) : (p || (d.shape.y += u), d.shape.height = 0);
    var g = Ye(i) ? function(v) {
      i(v, d);
    } : null;
    Pr(d, {
      shape: {
        width: l,
        height: u,
        x: a,
        y: s
      }
    }, r, null, n, g);
  }
  return d;
}
function u9(e, t, r) {
  var n = e.getArea(), i = Gr(n.r0, 1), o = Gr(n.r, 1), a = new xi({
    shape: {
      cx: Gr(e.cx, 1),
      cy: Gr(e.cy, 1),
      r0: i,
      r: o,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    }
  });
  if (t) {
    var s = e.getBaseAxis().dim === "angle";
    s ? a.shape.endAngle = n.startAngle : a.shape.r = i, Pr(a, {
      shape: {
        endAngle: n.endAngle,
        r: o
      }
    }, r);
  }
  return a;
}
function Bv(e, t, r, n, i) {
  if (e) {
    if (e.type === "polar")
      return u9(e, t, r);
    if (e.type === "cartesian2d")
      return l9(e, t, r, n, i);
  } else return null;
  return null;
}
function Zc(e, t) {
  return e.type === t;
}
function Ck(e, t) {
  if (e.length === t.length) {
    for (var r = 0; r < e.length; r++)
      if (e[r] !== t[r])
        return;
    return !0;
  }
}
function Sk(e) {
  for (var t = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, o = 0; o < e.length; ) {
    var a = e[o++], s = e[o++];
    isNaN(a) || (t = Math.min(a, t), n = Math.max(a, n)), isNaN(s) || (r = Math.min(s, r), i = Math.max(s, i));
  }
  return [[t, r], [n, i]];
}
function wk(e, t) {
  var r = Sk(e), n = r[0], i = r[1], o = Sk(t), a = o[0], s = o[1];
  return Math.max(Math.abs(n[0] - a[0]), Math.abs(n[1] - a[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1]));
}
function bk(e) {
  return $t(e) ? e : e ? 0.5 : 0;
}
function s1e(e, t, r) {
  if (!r.valueDim)
    return [];
  for (var n = t.count(), i = $a(n * 2), o = 0; o < n; o++) {
    var a = o9(r, e, t, o);
    i[o * 2] = a[0], i[o * 2 + 1] = a[1];
  }
  return i;
}
function gl(e, t, r, n) {
  var i = t.getBaseAxis(), o = i.dim === "x" || i.dim === "radius" ? 0 : 1, a = [], s = 0, l = [], u = [], c = [], d = [];
  if (n) {
    for (s = 0; s < e.length; s += 2)
      !isNaN(e[s]) && !isNaN(e[s + 1]) && d.push(e[s], e[s + 1]);
    e = d;
  }
  for (s = 0; s < e.length - 2; s += 2)
    switch (c[0] = e[s + 2], c[1] = e[s + 3], u[0] = e[s], u[1] = e[s + 1], a.push(u[0], u[1]), r) {
      case "end":
        l[o] = c[o], l[1 - o] = u[1 - o], a.push(l[0], l[1]);
        break;
      case "middle":
        var h = (u[o] + c[o]) / 2, f = [];
        l[o] = f[o] = h, l[1 - o] = u[1 - o], f[1 - o] = c[1 - o], a.push(l[0], l[1]), a.push(f[0], f[1]);
        break;
      default:
        l[o] = u[o], l[1 - o] = c[1 - o], a.push(l[0], l[1]);
    }
  return a.push(e[s++], e[s++]), a;
}
function l1e(e, t) {
  var r = [], n = e.length, i, o;
  function a(c, d, h) {
    var f = c.coord, p = (h - f) / (d.coord - f), g = rM(p, [c.color, d.color]);
    return {
      coord: h,
      color: g
    };
  }
  for (var s = 0; s < n; s++) {
    var l = e[s], u = l.coord;
    if (u < 0)
      i = l;
    else if (u > t) {
      o ? r.push(a(o, l, t)) : i && r.push(a(i, l, 0), a(i, l, t));
      break;
    } else
      i && (r.push(a(i, l, 0)), i = null), r.push(l), o = l;
  }
  return r;
}
function u1e(e, t, r) {
  var n = e.getVisual("visualMeta");
  if (!(!n || !n.length || !e.count())) {
    if (t.type !== "cartesian2d") {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
      return;
    }
    for (var i, o, a = n.length - 1; a >= 0; a--) {
      var s = e.getDimensionInfo(n[a].dimension);
      if (i = s && s.coordDim, i === "x" || i === "y") {
        o = n[a];
        break;
      }
    }
    if (!o) {
      process.env.NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
      return;
    }
    var l = t.getAxis(i), u = ge(o.stops, function(C) {
      return {
        coord: l.toGlobalCoord(l.dataToCoord(C.value)),
        color: C.color
      };
    }), c = u.length, d = o.outerColors.slice();
    c && u[0].coord > u[c - 1].coord && (u.reverse(), d.reverse());
    var h = l1e(u, i === "x" ? r.getWidth() : r.getHeight()), f = h.length;
    if (!f && c)
      return u[0].coord < 0 ? d[1] ? d[1] : u[c - 1].color : d[0] ? d[0] : u[0].color;
    var p = 10, g = h[0].coord - p, v = h[f - 1].coord + p, m = v - g;
    if (m < 1e-3)
      return "transparent";
    B(h, function(C) {
      C.offset = (C.coord - g) / m;
    }), h.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: f ? h[f - 1].offset : 0.5,
      color: d[1] || "transparent"
    }), h.unshift({
      offset: f ? h[0].offset : 0.5,
      color: d[0] || "transparent"
    });
    var y = new af(0, 0, 0, 0, h, !0);
    return y[i] = g, y[i + "2"] = v, y;
  }
}
function c1e(e, t, r) {
  var n = e.get("showAllSymbol"), i = n === "auto";
  if (!(n && !i)) {
    var o = r.getAxesByScale("ordinal")[0];
    if (o && !(i && d1e(o, t))) {
      var a = t.mapDimension(o.dim), s = {};
      return B(o.getViewLabels(), function(l) {
        var u = o.scale.getRawOrdinalNumber(l.tickValue);
        s[u] = 1;
      }), function(l) {
        return !s.hasOwnProperty(t.get(a, l));
      };
    }
  }
}
function d1e(e, t) {
  var r = e.getExtent(), n = Math.abs(r[1] - r[0]) / e.scale.count();
  isNaN(n) && (n = 0);
  for (var i = t.count(), o = Math.max(1, Math.round(i / 5)), a = 0; a < i; a += o)
    if (kv.getSymbolSize(
      t,
      a
      // Only for cartesian, where `isHorizontal` exists.
    )[e.isHorizontal() ? 1 : 0] * 1.5 > n)
      return !1;
  return !0;
}
function h1e(e, t) {
  return isNaN(e) || isNaN(t);
}
function f1e(e) {
  for (var t = e.length / 2; t > 0 && h1e(e[t * 2 - 2], e[t * 2 - 1]); t--)
    ;
  return t - 1;
}
function xk(e, t) {
  return [e[t * 2], e[t * 2 + 1]];
}
function p1e(e, t, r) {
  for (var n = e.length / 2, i = r === "x" ? 0 : 1, o, a, s = 0, l = -1, u = 0; u < n; u++)
    if (a = e[u * 2 + i], !(isNaN(a) || isNaN(e[u * 2 + 1 - i]))) {
      if (u === 0) {
        o = a;
        continue;
      }
      if (o <= t && a >= t || o >= t && a <= t) {
        l = u;
        break;
      }
      s = u, o = a;
    }
  return {
    range: [s, l],
    t: (t - o) / (a - o)
  };
}
function c9(e) {
  if (e.get(["endLabel", "show"]))
    return !0;
  for (var t = 0; t < bi.length; t++)
    if (e.get([bi[t], "endLabel", "show"]))
      return !0;
  return !1;
}
function A1(e, t, r, n) {
  if (Zc(t, "cartesian2d")) {
    var i = n.getModel("endLabel"), o = i.get("valueAnimation"), a = n.getData(), s = {
      lastFrameIndex: 0
    }, l = c9(n) ? function(f, p) {
      e._endLabelOnDuring(f, p, a, s, o, i, t);
    } : null, u = t.getBaseAxis().isHorizontal(), c = l9(t, r, n, function() {
      var f = e._endLabel;
      f && r && s.originalX != null && f.attr({
        x: s.originalX,
        y: s.originalY
      });
    }, l);
    if (!n.get("clip", !0)) {
      var d = c.shape, h = Math.max(d.width, d.height);
      u ? (d.y -= h, d.height += h * 2) : (d.x -= h, d.width += h * 2);
    }
    return l && l(1, c), c;
  } else
    return process.env.NODE_ENV !== "production" && n.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), u9(t, r, n);
}
function g1e(e, t) {
  var r = t.getBaseAxis(), n = r.isHorizontal(), i = r.inverse, o = n ? i ? "right" : "left" : "center", a = n ? "middle" : i ? "top" : "bottom";
  return {
    normal: {
      align: e.get("align") || o,
      verticalAlign: e.get("verticalAlign") || a
    }
  };
}
var v1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function() {
      var r = new it(), n = new Vv();
      this.group.add(n.group), this._symbolDraw = n, this._lineGroup = r;
    }, t.prototype.render = function(r, n, i) {
      var o = this, a = r.coordinateSystem, s = this.group, l = r.getData(), u = r.getModel("lineStyle"), c = r.getModel("areaStyle"), d = l.getLayout("points") || [], h = a.type === "polar", f = this._coordSys, p = this._symbolDraw, g = this._polyline, v = this._polygon, m = this._lineGroup, y = !n.ssr && r.get("animation"), C = !c.isEmpty(), S = c.get("origin"), b = i9(a, l, S), w = C && s1e(a, l, b), x = r.get("showSymbol"), E = r.get("connectNulls"), R = x && !h && c1e(r, l, a), _ = this._data;
      _ && _.eachItemGraphicEl(function(j, U) {
        j.__temp && (s.remove(j), _.setItemGraphicEl(U, null));
      }), x || p.remove(), s.add(m);
      var P = h ? !1 : r.get("step"), D;
      a && a.getArea && r.get("clip", !0) && (D = a.getArea(), D.width != null ? (D.x -= 0.1, D.y -= 0.1, D.width += 0.2, D.height += 0.2) : D.r0 && (D.r0 -= 0.5, D.r += 0.5)), this._clipShapeForSymbol = D;
      var I = u1e(l, a, i) || l.getVisual("style")[l.getVisual("drawType")];
      if (!(g && f.type === a.type && P === this._step))
        x && p.updateData(l, {
          isIgnore: R,
          clipShape: D,
          disableAnimation: !0,
          getSymbolPoint: function(j) {
            return [d[j * 2], d[j * 2 + 1]];
          }
        }), y && this._initSymbolLabelAnimation(l, a, D), P && (d = gl(d, a, P, E), w && (w = gl(w, a, P, E))), g = this._newPolyline(d), C ? v = this._newPolygon(d, w) : v && (m.remove(v), v = this._polygon = null), h || this._initOrUpdateEndLabel(r, a, Ac(I)), m.setClipPath(A1(this, a, !0, r));
      else {
        C && !v ? v = this._newPolygon(d, w) : v && !C && (m.remove(v), v = this._polygon = null), h || this._initOrUpdateEndLabel(r, a, Ac(I));
        var A = m.getClipPath();
        if (A) {
          var O = A1(this, a, !1, r);
          Pr(A, {
            shape: O.shape
          }, r);
        } else
          m.setClipPath(A1(this, a, !0, r));
        x && p.updateData(l, {
          isIgnore: R,
          clipShape: D,
          disableAnimation: !0,
          getSymbolPoint: function(j) {
            return [d[j * 2], d[j * 2 + 1]];
          }
        }), (!Ck(this._stackedOnPoints, w) || !Ck(this._points, d)) && (y ? this._doUpdateAnimation(l, w, a, i, P, S, E) : (P && (d = gl(d, a, P, E), w && (w = gl(w, a, P, E))), g.setShape({
          points: d
        }), v && v.setShape({
          points: d,
          stackedOnPoints: w
        })));
      }
      var L = r.getModel("emphasis"), N = L.get("focus"), F = L.get("blurScope"), G = L.get("disabled");
      if (g.useStyle(Xe(
        // Use color in lineStyle first
        u.getLineStyle(),
        {
          fill: "none",
          stroke: I,
          lineJoin: "bevel"
        }
      )), Bn(g, r, "lineStyle"), g.style.lineWidth > 0 && r.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var M = g.getState("emphasis").style;
        M.lineWidth = +g.style.lineWidth + 1;
      }
      ot(g).seriesIndex = r.seriesIndex, Hr(g, N, F, G);
      var V = bk(r.get("smooth")), z = r.get("smoothMonotone");
      if (g.setShape({
        smooth: V,
        smoothMonotone: z,
        connectNulls: E
      }), v) {
        var k = l.getCalculationInfo("stackedOnSeries"), $ = 0;
        v.useStyle(Xe(c.getAreaStyle(), {
          fill: I,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: l.getVisual("style").decal
        })), k && ($ = bk(k.get("smooth"))), v.setShape({
          smooth: V,
          stackedOnSmooth: $,
          smoothMonotone: z,
          connectNulls: E
        }), Bn(v, r, "areaStyle"), ot(v).seriesIndex = r.seriesIndex, Hr(v, N, F, G);
      }
      var W = function(j) {
        o._changePolyState(j);
      };
      l.eachItemGraphicEl(function(j) {
        j && (j.onHoverStateChange = W);
      }), this._polyline.onHoverStateChange = W, this._data = l, this._coordSys = a, this._stackedOnPoints = w, this._points = d, this._step = P, this._valueOrigin = S, r.get("triggerLineEvent") && (this.packEventData(r, g), v && this.packEventData(r, v));
    }, t.prototype.packEventData = function(r, n) {
      ot(n).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: r.componentIndex,
        seriesIndex: r.seriesIndex,
        seriesName: r.name,
        seriesType: "line"
      };
    }, t.prototype.highlight = function(r, n, i, o) {
      var a = r.getData(), s = Pc(a, o);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = a.getLayout("points"), u = a.getItemGraphicEl(s);
        if (!u) {
          var c = l[s * 2], d = l[s * 2 + 1];
          if (isNaN(c) || isNaN(d) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, d))
            return;
          var h = r.get("zlevel") || 0, f = r.get("z") || 0;
          u = new kv(a, s), u.x = c, u.y = d, u.setZ(h, f);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = h, p.z = f, p.z2 = this._polyline.z2 + 1), u.__temp = !0, a.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u);
        }
        u.highlight();
      } else
        ar.prototype.highlight.call(this, r, n, i, o);
    }, t.prototype.downplay = function(r, n, i, o) {
      var a = r.getData(), s = Pc(a, o);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = a.getItemGraphicEl(s);
        l && (l.__temp ? (a.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else
        ar.prototype.downplay.call(this, r, n, i, o);
    }, t.prototype._changePolyState = function(r) {
      var n = this._polygon;
      q0(this._polyline, r), n && q0(n, r);
    }, t.prototype._newPolyline = function(r) {
      var n = this._polyline;
      return n && this._lineGroup.remove(n), n = new o1e({
        shape: {
          points: r
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(n), this._polyline = n, n;
    }, t.prototype._newPolygon = function(r, n) {
      var i = this._polygon;
      return i && this._lineGroup.remove(i), i = new s9({
        shape: {
          points: r,
          stackedOnPoints: n
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(i), this._polygon = i, i;
    }, t.prototype._initSymbolLabelAnimation = function(r, n, i) {
      var o, a, s = n.getBaseAxis(), l = s.inverse;
      n.type === "cartesian2d" ? (o = s.isHorizontal(), a = !1) : n.type === "polar" && (o = s.dim === "angle", a = !0);
      var u = r.hostModel, c = u.get("animationDuration");
      Ye(c) && (c = c(null));
      var d = u.get("animationDelay") || 0, h = Ye(d) ? d(null) : d;
      r.eachItemGraphicEl(function(f, p) {
        var g = f;
        if (g) {
          var v = [f.x, f.y], m = void 0, y = void 0, C = void 0;
          if (i)
            if (a) {
              var S = i, b = n.pointToCoord(v);
              o ? (m = S.startAngle, y = S.endAngle, C = -b[1] / 180 * Math.PI) : (m = S.r0, y = S.r, C = b[0]);
            } else {
              var w = i;
              o ? (m = w.x, y = w.x + w.width, C = f.x) : (m = w.y + w.height, y = w.y, C = f.y);
            }
          var x = y === m ? 0 : (C - m) / (y - m);
          l && (x = 1 - x);
          var E = Ye(d) ? d(p) : c * x + h, R = g.getSymbolPath(), _ = R.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: E
          }), _ && _.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: E
          }), R.disableLabelAnimation = !0;
        }
      });
    }, t.prototype._initOrUpdateEndLabel = function(r, n, i) {
      var o = r.getModel("endLabel");
      if (c9(r)) {
        var a = r.getData(), s = this._polyline, l = a.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new Vt({
          z2: 200
          // should be higher than item symbol
        }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
        var c = f1e(l);
        c >= 0 && (Gn(s, Rn(r, "endLabel"), {
          inheritColor: i,
          labelFetcher: r,
          labelDataIndex: c,
          defaultText: function(d, h, f) {
            return f != null ? n9(a, f) : kh(a, d);
          },
          enableTextSetter: !0
        }, g1e(o, n)), s.textConfig.position = null);
      } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, t.prototype._endLabelOnDuring = function(r, n, i, o, a, s, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        r < 1 && o.originalX == null && (o.originalX = u.x, o.originalY = u.y);
        var d = i.getLayout("points"), h = i.hostModel, f = h.get("connectNulls"), p = s.get("precision"), g = s.get("distance") || 0, v = l.getBaseAxis(), m = v.isHorizontal(), y = v.inverse, C = n.shape, S = y ? m ? C.x : C.y + C.height : m ? C.x + C.width : C.y, b = (m ? g : 0) * (y ? -1 : 1), w = (m ? 0 : -g) * (y ? -1 : 1), x = m ? "x" : "y", E = p1e(d, S, x), R = E.range, _ = R[1] - R[0], P = void 0;
        if (_ >= 1) {
          if (_ > 1 && !f) {
            var D = xk(d, R[0]);
            u.attr({
              x: D[0] + b,
              y: D[1] + w
            }), a && (P = h.getRawValue(R[0]));
          } else {
            var D = c.getPointOn(S, x);
            D && u.attr({
              x: D[0] + b,
              y: D[1] + w
            });
            var I = h.getRawValue(R[0]), A = h.getRawValue(R[1]);
            a && (P = V$(i, p, I, A, E.t));
          }
          o.lastFrameIndex = R[0];
        } else {
          var O = r === 1 || o.lastFrameIndex > 0 ? R[0] : 0, D = xk(d, O);
          a && (P = h.getRawValue(O)), u.attr({
            x: D[0] + b,
            y: D[1] + w
          });
        }
        if (a) {
          var L = cf(u);
          typeof L.setLabelText == "function" && L.setLabelText(P);
        }
      }
    }, t.prototype._doUpdateAnimation = function(r, n, i, o, a, s, l) {
      var u = this._polyline, c = this._polygon, d = r.hostModel, h = i1e(this._data, r, this._stackedOnPoints, n, this._coordSys, i, this._valueOrigin), f = h.current, p = h.stackedOnCurrent, g = h.next, v = h.stackedOnNext;
      if (a && (f = gl(h.current, i, a, l), p = gl(h.stackedOnCurrent, i, a, l), g = gl(h.next, i, a, l), v = gl(h.stackedOnNext, i, a, l)), wk(f, g) > 3e3 || c && wk(p, v) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), c && (c.stopAnimation(), c.setShape({
          points: g,
          stackedOnPoints: v
        }));
        return;
      }
      u.shape.__points = h.current, u.shape.points = f;
      var m = {
        shape: {
          points: g
        }
      };
      h.current !== f && (m.shape.__points = h.next), u.stopAnimation(), jt(u, m, d), c && (c.setShape({
        // Reuse the points with polyline.
        points: f,
        stackedOnPoints: p
      }), c.stopAnimation(), jt(c, {
        shape: {
          stackedOnPoints: v
        }
      }, d), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var y = [], C = h.status, S = 0; S < C.length; S++) {
        var b = C[S].cmd;
        if (b === "=") {
          var w = r.getItemGraphicEl(C[S].idx1);
          w && y.push({
            el: w,
            ptIdx: S
            // Index of points
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var x = u.shape.__points, E = 0; E < y.length; E++) {
          var R = y[E].el, _ = y[E].ptIdx * 2;
          R.x = x[_], R.y = x[_ + 1], R.markRedraw();
        }
      });
    }, t.prototype.remove = function(r) {
      var n = this.group, i = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function(o, a) {
        o.__temp && (n.remove(o), i.setItemGraphicEl(a, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, t.type = "line", t;
  }(ar)
);
function Gv(e, t) {
  return {
    seriesType: e,
    plan: pf(),
    reset: function(r) {
      var n = r.getData(), i = r.coordinateSystem, o = r.pipelineContext, a = t || o.large;
      if (i) {
        var s = ge(i.dimensions, function(f) {
          return n.mapDimension(f);
        }).slice(0, 2), l = s.length, u = n.getCalculationInfo("stackResultDimension");
        js(n, s[0]) && (s[0] = u), js(n, s[1]) && (s[1] = u);
        var c = n.getStore(), d = n.getDimensionIndex(s[0]), h = n.getDimensionIndex(s[1]);
        return l && {
          progress: function(f, p) {
            for (var g = f.end - f.start, v = a && $a(g * l), m = [], y = [], C = f.start, S = 0; C < f.end; C++) {
              var b = void 0;
              if (l === 1) {
                var w = c.get(d, C);
                b = i.dataToPoint(w, null, y);
              } else
                m[0] = c.get(d, C), m[1] = c.get(h, C), b = i.dataToPoint(m, null, y);
              a ? (v[S++] = b[0], v[S++] = b[1]) : p.setItemLayout(C, b.slice());
            }
            a && p.setLayout("points", v);
          }
        };
      }
    }
  };
}
var m1e = {
  average: function(e) {
    for (var t = 0, r = 0, n = 0; n < e.length; n++)
      isNaN(e[n]) || (t += e[n], r++);
    return r === 0 ? NaN : t / r;
  },
  sum: function(e) {
    for (var t = 0, r = 0; r < e.length; r++)
      t += e[r] || 0;
    return t;
  },
  max: function(e) {
    for (var t = -1 / 0, r = 0; r < e.length; r++)
      e[r] > t && (t = e[r]);
    return isFinite(t) ? t : NaN;
  },
  min: function(e) {
    for (var t = 1 / 0, r = 0; r < e.length; r++)
      e[r] < t && (t = e[r]);
    return isFinite(t) ? t : NaN;
  },
  minmax: function(e) {
    for (var t = -1 / 0, r = -1 / 0, n = 0; n < e.length; n++) {
      var i = e[n], o = Math.abs(i);
      o > t && (t = o, r = i);
    }
    return isFinite(r) ? r : NaN;
  },
  // TODO
  // Median
  nearest: function(e) {
    return e[0];
  }
}, y1e = function(e) {
  return Math.round(e.length / 2);
};
function d9(e) {
  return {
    seriesType: e,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(t, r, n) {
      var i = t.getData(), o = t.get("sampling"), a = t.coordinateSystem, s = i.count();
      if (s > 10 && a.type === "cartesian2d" && o) {
        var l = a.getBaseAxis(), u = a.getOtherAxis(l), c = l.getExtent(), d = n.getDevicePixelRatio(), h = Math.abs(c[1] - c[0]) * (d || 1), f = Math.round(s / h);
        if (isFinite(f) && f > 1) {
          o === "lttb" && t.setData(i.lttbDownSample(i.mapDimension(u.dim), 1 / f));
          var p = void 0;
          Fe(o) ? p = m1e[o] : Ye(o) && (p = o), p && t.setData(i.downSample(i.mapDimension(u.dim), 1 / f, p, y1e));
        }
      }
    }
  };
}
function C1e(e) {
  e.registerChartView(v1e), e.registerSeriesModel(e1e), e.registerLayout(Gv("line", !0)), e.registerVisual({
    seriesType: "line",
    reset: function(t) {
      var r = t.getData(), n = t.getModel("lineStyle").getLineStyle();
      n && !n.stroke && (n.stroke = r.getVisual("style").fill), r.setVisual("legendLineStyle", n);
    }
  }), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, d9("line"));
}
var Yg = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return os(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getMarkerPosition = function(r, n, i) {
      var o = this.coordinateSystem;
      if (o && o.clampData) {
        var a = o.clampData(r), s = o.dataToPoint(a);
        if (i)
          B(o.getAxes(), function(h, f) {
            if (h.type === "category" && n != null) {
              var p = h.getTicksCoords(), g = h.getTickModel().get("alignWithLabel"), v = a[f], m = n[f] === "x1" || n[f] === "y1";
              if (m && !g && (v += 1), p.length < 2)
                return;
              if (p.length === 2) {
                s[f] = h.toGlobalCoord(h.getExtent()[m ? 1 : 0]);
                return;
              }
              for (var y = void 0, C = void 0, S = 1, b = 0; b < p.length; b++) {
                var w = p[b].coord, x = b === p.length - 1 ? p[b - 1].tickValue + S : p[b].tickValue;
                if (x === v) {
                  C = w;
                  break;
                } else if (x < v)
                  y = w;
                else if (y != null && x > v) {
                  C = (w + y) / 2;
                  break;
                }
                b === 1 && (S = x - p[0].tickValue);
              }
              C == null && (y ? y && (C = p[p.length - 1].coord) : C = p[0].coord), s[f] = h.toGlobalCoord(C);
            }
          });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), d = o.getBaseAxis().isHorizontal() ? 0 : 1;
          s[d] += u + c / 2;
        }
        return s;
      }
      return [NaN, NaN];
    }, t.type = "series.__base_bar__", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, t;
  }(hr)
);
hr.registerClass(Yg);
var S1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getInitialData = function() {
      return os(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, t.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, t.prototype.getProgressiveThreshold = function() {
      var r = this.get("progressiveThreshold"), n = this.get("largeThreshold");
      return n > r && (r = n), r;
    }, t.prototype.brushSelector = function(r, n, i) {
      return i.rect(n.getItemLayout(r));
    }, t.type = "series.bar", t.dependencies = ["grid", "polar"], t.defaultOption = ou(Yg.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: !1
    }), t;
  }(Yg)
), w1e = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return e;
  }()
), yC = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "sausage", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new w1e();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.cx, o = n.cy, a = Math.max(n.r0 || 0, 0), s = Math.max(n.r, 0), l = (s - a) * 0.5, u = a + l, c = n.startAngle, d = n.endAngle, h = n.clockwise, f = Math.PI * 2, p = h ? d - c < f : c - d < f;
      p || (c = d - (h ? f : -f));
      var g = Math.cos(c), v = Math.sin(c), m = Math.cos(d), y = Math.sin(d);
      p ? (r.moveTo(g * a + i, v * a + o), r.arc(g * u + i, v * u + o, l, -Math.PI + c, c, !h)) : r.moveTo(g * s + i, v * s + o), r.arc(i, o, s, c, d, !h), r.arc(m * u + i, y * u + o, l, d - Math.PI * 2, d - Math.PI, !h), a !== 0 && r.arc(i, o, a, d, c, h);
    }, t;
  }(Mt)
);
function b1e(e, t) {
  t = t || {};
  var r = t.isRoundCap;
  return function(n, i, o) {
    var a = i.position;
    if (!a || a instanceof Array)
      return U0(n, i, o);
    var s = e(a), l = i.distance != null ? i.distance : 5, u = this.shape, c = u.cx, d = u.cy, h = u.r, f = u.r0, p = (h + f) / 2, g = u.startAngle, v = u.endAngle, m = (g + v) / 2, y = r ? Math.abs(h - f) / 2 : 0, C = Math.cos, S = Math.sin, b = c + h * C(g), w = d + h * S(g), x = "left", E = "top";
    switch (s) {
      case "startArc":
        b = c + (f - l) * C(m), w = d + (f - l) * S(m), x = "center", E = "top";
        break;
      case "insideStartArc":
        b = c + (f + l) * C(m), w = d + (f + l) * S(m), x = "center", E = "bottom";
        break;
      case "startAngle":
        b = c + p * C(g) + iy(g, l + y, !1), w = d + p * S(g) + oy(g, l + y, !1), x = "right", E = "middle";
        break;
      case "insideStartAngle":
        b = c + p * C(g) + iy(g, -l + y, !1), w = d + p * S(g) + oy(g, -l + y, !1), x = "left", E = "middle";
        break;
      case "middle":
        b = c + p * C(m), w = d + p * S(m), x = "center", E = "middle";
        break;
      case "endArc":
        b = c + (h + l) * C(m), w = d + (h + l) * S(m), x = "center", E = "bottom";
        break;
      case "insideEndArc":
        b = c + (h - l) * C(m), w = d + (h - l) * S(m), x = "center", E = "top";
        break;
      case "endAngle":
        b = c + p * C(v) + iy(v, l + y, !0), w = d + p * S(v) + oy(v, l + y, !0), x = "left", E = "middle";
        break;
      case "insideEndAngle":
        b = c + p * C(v) + iy(v, -l + y, !0), w = d + p * S(v) + oy(v, -l + y, !0), x = "right", E = "middle";
        break;
      default:
        return U0(n, i, o);
    }
    return n = n || {}, n.x = b, n.y = w, n.align = x, n.verticalAlign = E, n;
  };
}
function x1e(e, t, r, n) {
  if ($t(n)) {
    e.setTextConfig({
      rotation: n
    });
    return;
  } else if (fe(t)) {
    e.setTextConfig({
      rotation: 0
    });
    return;
  }
  var i = e.shape, o = i.clockwise ? i.startAngle : i.endAngle, a = i.clockwise ? i.endAngle : i.startAngle, s = (o + a) / 2, l, u = r(t);
  switch (u) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      l = s;
      break;
    case "startAngle":
    case "insideStartAngle":
      l = o;
      break;
    case "endAngle":
    case "insideEndAngle":
      l = a;
      break;
    default:
      e.setTextConfig({
        rotation: 0
      });
      return;
  }
  var c = Math.PI * 1.5 - l;
  u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), e.setTextConfig({
    rotation: c
  });
}
function iy(e, t, r) {
  return t * Math.sin(e) * (r ? -1 : 1);
}
function oy(e, t, r) {
  return t * Math.cos(e) * (r ? 1 : -1);
}
function sc(e, t, r) {
  var n = e.get("borderRadius");
  if (n == null)
    return r ? {
      cornerRadius: 0
    } : null;
  fe(n) || (n = [n, n, n, n]);
  var i = Math.abs(t.r || 0 - t.r0 || 0);
  return {
    cornerRadius: ge(n, function(o) {
      return ya(o, i);
    })
  };
}
var I1 = Math.max, F1 = Math.min;
function E1e(e, t) {
  var r = e.getArea && e.getArea();
  if (Zc(e, "cartesian2d")) {
    var n = e.getBaseAxis();
    if (n.type !== "category" || !n.onBand) {
      var i = t.getLayout("bandWidth");
      n.isHorizontal() ? (r.x -= i, r.width += i * 2) : (r.y -= i, r.height += i * 2);
    }
  }
  return r;
}
var R1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e.call(this) || this;
      return r.type = t.type, r._isFirstFrame = !0, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this._model = r, this._removeOnRenderedListener(i), this._updateDrawMode(r);
      var a = r.get("coordinateSystem");
      a === "cartesian2d" || a === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(r, n, i) : this._renderNormal(r, n, i, o)) : process.env.NODE_ENV !== "production" && Vr("Only cartesian2d and polar supported for bar.");
    }, t.prototype.incrementalPrepareRender = function(r) {
      this._clear(), this._updateDrawMode(r), this._updateLargeClip(r);
    }, t.prototype.incrementalRender = function(r, n) {
      this._progressiveEls = [], this._incrementalRenderLarge(r, n);
    }, t.prototype.eachRendered = function(r) {
      iu(this._progressiveEls || this.group, r);
    }, t.prototype._updateDrawMode = function(r) {
      var n = r.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, t.prototype._renderNormal = function(r, n, i, o) {
      var a = this.group, s = r.getData(), l = this._data, u = r.coordinateSystem, c = u.getBaseAxis(), d;
      u.type === "cartesian2d" ? d = c.isHorizontal() : u.type === "polar" && (d = c.dim === "angle");
      var h = r.isAnimationEnabled() ? r : null, f = _1e(r, u);
      f && this._enableRealtimeSort(f, s, i);
      var p = r.get("clip", !0) || f, g = E1e(u, s);
      a.removeClipPath();
      var v = r.get("roundCap", !0), m = r.get("showBackground", !0), y = r.getModel("backgroundStyle"), C = y.get("borderRadius") || 0, S = [], b = this._backgroundEls, w = o && o.isInitSort, x = o && o.type === "changeAxisOrder";
      function E(P) {
        var D = ay[u.type](s, P), I = F1e(u, d, D);
        return I.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? I.setShape("r", C) : I.setShape("cornerRadius", C), S[P] = I, I;
      }
      s.diff(l).add(function(P) {
        var D = s.getItemModel(P), I = ay[u.type](s, P, D);
        if (m && E(P), !(!s.hasValue(P) || !Pk[u.type](I))) {
          var A = !1;
          p && (A = Ek[u.type](g, I));
          var O = Rk[u.type](r, s, P, I, d, h, c.model, !1, v);
          f && (O.forceLabelAnimation = !0), Mk(O, s, P, D, I, r, d, u.type === "polar"), w ? O.attr({
            shape: I
          }) : f ? _k(f, h, O, I, P, d, !1, !1) : Pr(O, {
            shape: I
          }, r, P), s.setItemGraphicEl(P, O), a.add(O), O.ignore = A;
        }
      }).update(function(P, D) {
        var I = s.getItemModel(P), A = ay[u.type](s, P, I);
        if (m) {
          var O = void 0;
          b.length === 0 ? O = E(D) : (O = b[D], O.useStyle(y.getItemStyle()), u.type === "cartesian2d" ? O.setShape("r", C) : O.setShape("cornerRadius", C), S[P] = O);
          var L = ay[u.type](s, P), N = f9(d, L, u);
          jt(O, {
            shape: N
          }, h, P);
        }
        var F = l.getItemGraphicEl(D);
        if (!s.hasValue(P) || !Pk[u.type](A)) {
          a.remove(F);
          return;
        }
        var G = !1;
        if (p && (G = Ek[u.type](g, A), G && a.remove(F)), F ? Ca(F) : F = Rk[u.type](r, s, P, A, d, h, c.model, !!F, v), f && (F.forceLabelAnimation = !0), x) {
          var M = F.getTextContent();
          if (M) {
            var V = cf(M);
            V.prevValue != null && (V.prevValue = V.value);
          }
        } else
          Mk(F, s, P, I, A, r, d, u.type === "polar");
        w ? F.attr({
          shape: A
        }) : f ? _k(f, h, F, A, P, d, !0, x) : jt(F, {
          shape: A
        }, r, P, null), s.setItemGraphicEl(P, F), F.ignore = G, a.add(F);
      }).remove(function(P) {
        var D = l.getItemGraphicEl(P);
        D && Vg(D, r, P);
      }).execute();
      var R = this._backgroundGroup || (this._backgroundGroup = new it());
      R.removeAll();
      for (var _ = 0; _ < S.length; ++_)
        R.add(S[_]);
      a.add(R), this._backgroundEls = S, this._data = s;
    }, t.prototype._renderLarge = function(r, n, i) {
      this._clear(), Ak(r, this.group), this._updateLargeClip(r);
    }, t.prototype._incrementalRenderLarge = function(r, n) {
      this._removeBackground(), Ak(n, this.group, this._progressiveEls, !0);
    }, t.prototype._updateLargeClip = function(r) {
      var n = r.get("clip", !0) && Bv(r.coordinateSystem, !1, r), i = this.group;
      n ? i.setClipPath(n) : i.removeClipPath();
    }, t.prototype._enableRealtimeSort = function(r, n, i) {
      var o = this;
      if (n.count()) {
        var a = r.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(n, r, i), this._isFirstFrame = !1;
        else {
          var s = function(l) {
            var u = n.getItemGraphicEl(l), c = u && u.shape;
            return c && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(a.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            o._updateSortWithinSameData(n, s, a, i);
          }, i.getZr().on("rendered", this._onRendered);
        }
      }
    }, t.prototype._dataSort = function(r, n, i) {
      var o = [];
      return r.each(r.mapDimension(n.dim), function(a, s) {
        var l = i(s);
        l = l ?? NaN, o.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: a
        });
      }), o.sort(function(a, s) {
        return s.mappedValue - a.mappedValue;
      }), {
        ordinalNumbers: ge(o, function(a) {
          return a.ordinalNumber;
        })
      };
    }, t.prototype._isOrderChangedWithinSameData = function(r, n, i) {
      for (var o = i.scale, a = r.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, u = o.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = r.rawIndexOf(a, o.getRawOrdinalNumber(l)), d = c < 0 ? Number.MIN_VALUE : n(r.indexOfRawIndex(c));
        if (d > s)
          return !0;
        s = d;
      }
      return !1;
    }, t.prototype._isOrderDifferentInView = function(r, n) {
      for (var i = n.scale, o = i.getExtent(), a = Math.max(0, o[0]), s = Math.min(o[1], i.getOrdinalMeta().categories.length - 1); a <= s; ++a)
        if (r.ordinalNumbers[a] !== i.getRawOrdinalNumber(a))
          return !0;
    }, t.prototype._updateSortWithinSameData = function(r, n, i, o) {
      if (this._isOrderChangedWithinSameData(r, n, i)) {
        var a = this._dataSort(r, i, n);
        this._isOrderDifferentInView(a, i) && (this._removeOnRenderedListener(o), o.dispatchAction({
          type: "changeAxisOrder",
          componentType: i.dim + "Axis",
          axisId: i.index,
          sortInfo: a
        }));
      }
    }, t.prototype._dispatchInitSort = function(r, n, i) {
      var o = n.baseAxis, a = this._dataSort(r, o, function(s) {
        return r.get(r.mapDimension(n.otherAxis.dim), s);
      });
      i.dispatchAction({
        type: "changeAxisOrder",
        componentType: o.dim + "Axis",
        isInitSort: !0,
        axisId: o.index,
        sortInfo: a
      });
    }, t.prototype.remove = function(r, n) {
      this._clear(this._model), this._removeOnRenderedListener(n);
    }, t.prototype.dispose = function(r, n) {
      this._removeOnRenderedListener(n);
    }, t.prototype._removeOnRenderedListener = function(r) {
      this._onRendered && (r.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, t.prototype._clear = function(r) {
      var n = this.group, i = this._data;
      r && r.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function(o) {
        Vg(o, r, ot(o).dataIndex);
      })) : n.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, t.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, t.type = "bar", t;
  }(ar)
), Ek = {
  cartesian2d: function(e, t) {
    var r = t.width < 0 ? -1 : 1, n = t.height < 0 ? -1 : 1;
    r < 0 && (t.x += t.width, t.width = -t.width), n < 0 && (t.y += t.height, t.height = -t.height);
    var i = e.x + e.width, o = e.y + e.height, a = I1(t.x, e.x), s = F1(t.x + t.width, i), l = I1(t.y, e.y), u = F1(t.y + t.height, o), c = s < a, d = u < l;
    return t.x = c && a > i ? s : a, t.y = d && l > o ? u : l, t.width = c ? 0 : s - a, t.height = d ? 0 : u - l, r < 0 && (t.x += t.width, t.width = -t.width), n < 0 && (t.y += t.height, t.height = -t.height), c || d;
  },
  polar: function(e, t) {
    var r = t.r0 <= t.r ? 1 : -1;
    if (r < 0) {
      var n = t.r;
      t.r = t.r0, t.r0 = n;
    }
    var i = F1(t.r, e.r), o = I1(t.r0, e.r0);
    t.r = i, t.r0 = o;
    var a = i - o < 0;
    if (r < 0) {
      var n = t.r;
      t.r = t.r0, t.r0 = n;
    }
    return a;
  }
}, Rk = {
  cartesian2d: function(e, t, r, n, i, o, a, s, l) {
    var u = new Bt({
      shape: se({}, n),
      z2: 1
    });
    if (u.__dataIndex = r, u.name = "item", o) {
      var c = u.shape, d = i ? "height" : "width";
      c[d] = 0;
    }
    return u;
  },
  polar: function(e, t, r, n, i, o, a, s, l) {
    var u = !i && l ? yC : xi, c = new u({
      shape: n,
      z2: 1
    });
    c.name = "item";
    var d = h9(i);
    if (c.calculateTextPosition = b1e(d, {
      isRoundCap: u === yC
    }), o) {
      var h = c.shape, f = i ? "r" : "endAngle", p = {};
      h[f] = i ? n.r0 : n.startAngle, p[f] = n[f], (s ? jt : Pr)(c, {
        shape: p
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, o);
    }
    return c;
  }
};
function _1e(e, t) {
  var r = e.get("realtimeSort", !0), n = t.getBaseAxis();
  if (process.env.NODE_ENV !== "production" && r && (n.type !== "category" && Vr("`realtimeSort` will not work because this bar series is not based on a category axis."), t.type !== "cartesian2d" && Vr("`realtimeSort` will not work because this bar series is not on cartesian2d.")), r && n.type === "category" && t.type === "cartesian2d")
    return {
      baseAxis: n,
      otherAxis: t.getOtherAxis(n)
    };
}
function _k(e, t, r, n, i, o, a, s) {
  var l, u;
  o ? (u = {
    x: n.x,
    width: n.width
  }, l = {
    y: n.y,
    height: n.height
  }) : (u = {
    y: n.y,
    height: n.height
  }, l = {
    x: n.x,
    width: n.width
  }), s || (a ? jt : Pr)(r, {
    shape: l
  }, t, i, null);
  var c = t ? e.baseAxis.model : null;
  (a ? jt : Pr)(r, {
    shape: u
  }, c, i);
}
function Tk(e, t) {
  for (var r = 0; r < t.length; r++)
    if (!isFinite(e[t[r]]))
      return !0;
  return !1;
}
var T1e = ["x", "y", "width", "height"], P1e = ["cx", "cy", "r", "startAngle", "endAngle"], Pk = {
  cartesian2d: function(e) {
    return !Tk(e, T1e);
  },
  polar: function(e) {
    return !Tk(e, P1e);
  }
}, ay = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(e, t, r) {
    var n = e.getItemLayout(t), i = r ? D1e(r, n) : 0, o = n.width > 0 ? 1 : -1, a = n.height > 0 ? 1 : -1;
    return {
      x: n.x + o * i / 2,
      y: n.y + a * i / 2,
      width: n.width - o * i,
      height: n.height - a * i
    };
  },
  polar: function(e, t, r) {
    var n = e.getItemLayout(t);
    return {
      cx: n.cx,
      cy: n.cy,
      r0: n.r0,
      r: n.r,
      startAngle: n.startAngle,
      endAngle: n.endAngle,
      clockwise: n.clockwise
    };
  }
};
function M1e(e) {
  return e.startAngle != null && e.endAngle != null && e.startAngle === e.endAngle;
}
function h9(e) {
  return /* @__PURE__ */ function(t) {
    var r = t ? "Arc" : "Angle";
    return function(n) {
      switch (n) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return n + r;
        default:
          return n;
      }
    };
  }(e);
}
function Mk(e, t, r, n, i, o, a, s) {
  var l = t.getItemVisual(r, "style");
  if (s) {
    if (!o.get("roundCap")) {
      var c = e.shape, d = sc(n.getModel("itemStyle"), c, !0);
      se(c, d), e.setShape(c);
    }
  } else {
    var u = n.get(["itemStyle", "borderRadius"]) || 0;
    e.setShape("r", u);
  }
  e.useStyle(l);
  var h = n.getShallow("cursor");
  h && e.attr("cursor", h);
  var f = s ? a ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : a ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = Rn(n);
  Gn(e, p, {
    labelFetcher: o,
    labelDataIndex: r,
    defaultText: kh(o.getData(), r),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: f
  });
  var g = e.getTextContent();
  if (s && g) {
    var v = n.get(["label", "position"]);
    e.textConfig.inside = v === "middle" ? !0 : null, x1e(e, v === "outside" ? f : v, h9(a), n.get(["label", "rotate"]));
  }
  L6(g, p, o.getRawValue(r), function(y) {
    return n9(t, y);
  });
  var m = n.getModel(["emphasis"]);
  Hr(e, m.get("focus"), m.get("blurScope"), m.get("disabled")), Bn(e, n), M1e(i) && (e.style.fill = "none", e.style.stroke = "none", B(e.states, function(y) {
    y.style && (y.style.fill = y.style.stroke = "none");
  }));
}
function D1e(e, t) {
  var r = e.get(["itemStyle", "borderColor"]);
  if (!r || r === "none")
    return 0;
  var n = e.get(["itemStyle", "borderWidth"]) || 0, i = isNaN(t.width) ? Number.MAX_VALUE : Math.abs(t.width), o = isNaN(t.height) ? Number.MAX_VALUE : Math.abs(t.height);
  return Math.min(n, i, o);
}
var A1e = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), Dk = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "largeBar", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new A1e();
    }, t.prototype.buildPath = function(r, n) {
      for (var i = n.points, o = this.baseDimIdx, a = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, c = 0; c < i.length; c += 3)
        l[o] = u, l[a] = i[c + 2], s[o] = i[c + o], s[a] = i[c + a], r.rect(s[0], s[1], l[0], l[1]);
    }, t;
  }(Mt)
);
function Ak(e, t, r, n) {
  var i = e.getData(), o = i.getLayout("valueAxisHorizontal") ? 1 : 0, a = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = e.getModel("backgroundStyle"), u = i.getLayout("largeBackgroundPoints");
  if (u) {
    var c = new Dk({
      shape: {
        points: u
      },
      incremental: !!n,
      silent: !0,
      z2: 0
    });
    c.baseDimIdx = o, c.largeDataIndices = a, c.barWidth = s, c.useStyle(l.getItemStyle()), t.add(c), r && r.push(c);
  }
  var d = new Dk({
    shape: {
      points: i.getLayout("largePoints")
    },
    incremental: !!n,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  d.baseDimIdx = o, d.largeDataIndices = a, d.barWidth = s, t.add(d), d.useStyle(i.getVisual("style")), ot(d).seriesIndex = e.seriesIndex, e.get("silent") || (d.on("mousedown", Ik), d.on("mousemove", Ik)), r && r.push(d);
}
var Ik = XS(function(e) {
  var t = this, r = I1e(t, e.offsetX, e.offsetY);
  ot(t).dataIndex = r >= 0 ? r : null;
}, 30, !1);
function I1e(e, t, r) {
  for (var n = e.baseDimIdx, i = 1 - n, o = e.shape.points, a = e.largeDataIndices, s = [], l = [], u = e.barWidth, c = 0, d = o.length / 3; c < d; c++) {
    var h = c * 3;
    if (l[n] = u, l[i] = o[h + 2], s[n] = o[h + n], s[i] = o[h + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), t >= s[0] && t <= s[0] + l[0] && r >= s[1] && r <= s[1] + l[1])
      return a[c];
  }
  return -1;
}
function f9(e, t, r) {
  if (Zc(r, "cartesian2d")) {
    var n = t, i = r.getArea();
    return {
      x: e ? n.x : i.x,
      y: e ? i.y : n.y,
      width: e ? n.width : i.width,
      height: e ? i.height : n.height
    };
  } else {
    var i = r.getArea(), o = t;
    return {
      cx: i.cx,
      cy: i.cy,
      r0: e ? i.r0 : o.r0,
      r: e ? i.r : o.r,
      startAngle: e ? o.startAngle : 0,
      endAngle: e ? o.endAngle : Math.PI * 2
    };
  }
}
function F1e(e, t, r) {
  var n = e.type === "polar" ? xi : Bt;
  return new n({
    shape: f9(t, r, e),
    silent: !0,
    z2: 0
  });
}
function L1e(e) {
  e.registerChartView(R1e), e.registerSeriesModel(S1e), e.registerLayout(e.PRIORITY.VISUAL.LAYOUT, dt(y7, "bar")), e.registerLayout(e.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, C7("bar")), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, d9("bar")), e.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(t, r) {
    var n = t.componentType || "series";
    r.eachComponent({
      mainType: n,
      query: t
    }, function(i) {
      t.sortInfo && i.axis.setCategorySortInfo(t.sortInfo);
    });
  });
}
var Fk = Math.PI * 2, sy = Math.PI / 180;
function p9(e, t) {
  return hn(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function g9(e, t) {
  var r = p9(e, t), n = e.get("center"), i = e.get("radius");
  fe(i) || (i = [0, i]);
  var o = Ae(r.width, t.getWidth()), a = Ae(r.height, t.getHeight()), s = Math.min(o, a), l = Ae(i[0], s / 2), u = Ae(i[1], s / 2), c, d, h = e.coordinateSystem;
  if (h) {
    var f = h.dataToPoint(n);
    c = f[0] || 0, d = f[1] || 0;
  } else
    fe(n) || (n = [n, n]), c = Ae(n[0], o) + r.x, d = Ae(n[1], a) + r.y;
  return {
    cx: c,
    cy: d,
    r0: l,
    r: u
  };
}
function O1e(e, t, r) {
  t.eachSeriesByType(e, function(n) {
    var i = n.getData(), o = i.mapDimension("value"), a = p9(n, r), s = g9(n, r), l = s.cx, u = s.cy, c = s.r, d = s.r0, h = -n.get("startAngle") * sy, f = n.get("endAngle"), p = n.get("padAngle") * sy;
    f = f === "auto" ? h - Fk : -f * sy;
    var g = n.get("minAngle") * sy, v = g + p, m = 0;
    i.each(o, function(N) {
      !isNaN(N) && m++;
    });
    var y = i.getSum(o), C = Math.PI / (y || m) * 2, S = n.get("clockwise"), b = n.get("roseType"), w = n.get("stillShowZeroSum"), x = i.getDataExtent(o);
    x[0] = 0;
    var E = S ? 1 : -1, R = [h, f], _ = E * p / 2;
    hM(R, !S), h = R[0], f = R[1];
    var P = v9(n);
    P.startAngle = h, P.endAngle = f, P.clockwise = S;
    var D = Math.abs(f - h), I = D, A = 0, O = h;
    if (i.setLayout({
      viewRect: a,
      r: c
    }), i.each(o, function(N, F) {
      var G;
      if (isNaN(N)) {
        i.setItemLayout(F, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: S,
          cx: l,
          cy: u,
          r0: d,
          r: b ? NaN : c
        });
        return;
      }
      b !== "area" ? G = y === 0 && w ? C : N * C : G = D / m, G < v ? (G = v, I -= v) : A += N;
      var M = O + E * G, V = 0, z = 0;
      p > G ? (V = O + E * G / 2, z = V) : (V = O + _, z = M - _), i.setItemLayout(F, {
        angle: G,
        startAngle: V,
        endAngle: z,
        clockwise: S,
        cx: l,
        cy: u,
        r0: d,
        r: b ? nr(N, x, [d, c]) : c
      }), O = M;
    }), I < Fk && m)
      if (I <= 1e-3) {
        var L = D / m;
        i.each(o, function(N, F) {
          if (!isNaN(N)) {
            var G = i.getItemLayout(F);
            G.angle = L;
            var M = 0, V = 0;
            L < p ? (M = h + E * (F + 1 / 2) * L, V = M) : (M = h + E * F * L + _, V = h + E * (F + 1) * L - _), G.startAngle = M, G.endAngle = V;
          }
        });
      } else
        C = I / A, O = h, i.each(o, function(N, F) {
          if (!isNaN(N)) {
            var G = i.getItemLayout(F), M = G.angle === v ? v : N * C, V = 0, z = 0;
            M < p ? (V = O + E * M / 2, z = V) : (V = O + _, z = O + E * M - _), G.startAngle = V, G.endAngle = z, O += E * M;
          }
        });
  });
}
var v9 = Gt();
function Hv(e) {
  return {
    seriesType: e,
    reset: function(t, r) {
      var n = r.findComponents({
        mainType: "legend"
      });
      if (!(!n || !n.length)) {
        var i = t.getData();
        i.filterSelf(function(o) {
          for (var a = i.getName(o), s = 0; s < n.length; s++)
            if (!n[s].isSelected(a))
              return !1;
          return !0;
        });
      }
    }
  };
}
var N1e = Math.PI / 180;
function Lk(e, t, r, n, i, o, a, s, l, u) {
  if (e.length < 2)
    return;
  function c(g) {
    for (var v = g.rB, m = v * v, y = 0; y < g.list.length; y++) {
      var C = g.list[y], S = Math.abs(C.label.y - r), b = n + C.len, w = b * b, x = Math.sqrt((1 - Math.abs(S * S / m)) * w), E = t + (x + C.len2) * i, R = E - C.label.x, _ = C.targetTextWidth - R * i;
      m9(C, _, !0), C.label.x = E;
    }
  }
  function d(g) {
    for (var v = {
      list: [],
      maxY: 0
    }, m = {
      list: [],
      maxY: 0
    }, y = 0; y < g.length; y++)
      if (g[y].labelAlignTo === "none") {
        var C = g[y], S = C.label.y > r ? m : v, b = Math.abs(C.label.y - r);
        if (b >= S.maxY) {
          var w = C.label.x - t - C.len2 * i, x = n + C.len, E = Math.abs(w) < x ? Math.sqrt(b * b / (1 - w * w / x / x)) : x;
          S.rB = E, S.maxY = b;
        }
        S.list.push(C);
      }
    c(v), c(m);
  }
  for (var h = e.length, f = 0; f < h; f++)
    if (e[f].position === "outer" && e[f].labelAlignTo === "labelLine") {
      var p = e[f].label.x - u;
      e[f].linePoints[1][0] += p, e[f].label.x = u;
    }
  G7(e, l, l + a) && d(e);
}
function k1e(e, t, r, n, i, o, a, s) {
  for (var l = [], u = [], c = Number.MAX_VALUE, d = -Number.MAX_VALUE, h = 0; h < e.length; h++) {
    var f = e[h].label;
    L1(e[h]) || (f.x < t ? (c = Math.min(c, f.x), l.push(e[h])) : (d = Math.max(d, f.x), u.push(e[h])));
  }
  for (var h = 0; h < e.length; h++) {
    var p = e[h];
    if (!L1(p) && p.linePoints) {
      if (p.labelStyleWidth != null)
        continue;
      var f = p.label, g = p.linePoints, v = void 0;
      p.labelAlignTo === "edge" ? f.x < t ? v = g[2][0] - p.labelDistance - a - p.edgeDistance : v = a + i - p.edgeDistance - g[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? f.x < t ? v = c - a - p.bleedMargin : v = a + i - d - p.bleedMargin : f.x < t ? v = f.x - a - p.bleedMargin : v = a + i - f.x - p.bleedMargin, p.targetTextWidth = v, m9(p, v);
    }
  }
  Lk(u, t, r, n, 1, i, o, a, s, d), Lk(l, t, r, n, -1, i, o, a, s, c);
  for (var h = 0; h < e.length; h++) {
    var p = e[h];
    if (!L1(p) && p.linePoints) {
      var f = p.label, g = p.linePoints, m = p.labelAlignTo === "edge", y = f.style.padding, C = y ? y[1] + y[3] : 0, S = f.style.backgroundColor ? 0 : C, b = p.rect.width + S, w = g[1][0] - g[2][0];
      m ? f.x < t ? g[2][0] = a + p.edgeDistance + b + p.labelDistance : g[2][0] = a + i - p.edgeDistance - b - p.labelDistance : (f.x < t ? g[2][0] = f.x + p.labelDistance : g[2][0] = f.x - p.labelDistance, g[1][0] = g[2][0] + w), g[1][1] = g[2][1] = f.y;
    }
  }
}
function m9(e, t, r) {
  if (r === void 0 && (r = !1), e.labelStyleWidth == null) {
    var n = e.label, i = n.style, o = e.rect, a = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, u = i.overflow, c = o.width + (a ? 0 : l);
    if (t < c || r) {
      var d = o.height;
      if (u && u.match("break")) {
        n.setStyle("backgroundColor", null), n.setStyle("width", t - l);
        var h = n.getBoundingRect();
        n.setStyle("width", Math.ceil(h.width)), n.setStyle("backgroundColor", a);
      } else {
        var f = t - l, p = t < c ? f : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          r ? f > e.unconstrainedWidth ? null : f : null
        );
        n.setStyle("width", p);
      }
      var g = n.getBoundingRect();
      o.width = g.width;
      var v = (n.style.margin || 0) + 2.1;
      o.height = g.height + v, o.y -= (o.height - d) / 2;
    }
  }
}
function L1(e) {
  return e.position === "center";
}
function V1e(e) {
  var t = e.getData(), r = [], n, i, o = !1, a = (e.get("minShowLabelAngle") || 0) * N1e, s = t.getLayout("viewRect"), l = t.getLayout("r"), u = s.width, c = s.x, d = s.y, h = s.height;
  function f(w) {
    w.ignore = !0;
  }
  function p(w) {
    if (!w.ignore)
      return !0;
    for (var x in w.states)
      if (w.states[x].ignore === !1)
        return !0;
    return !1;
  }
  t.each(function(w) {
    var x = t.getItemGraphicEl(w), E = x.shape, R = x.getTextContent(), _ = x.getTextGuideLine(), P = t.getItemModel(w), D = P.getModel("label"), I = D.get("position") || P.get(["emphasis", "label", "position"]), A = D.get("distanceToLabelLine"), O = D.get("alignTo"), L = Ae(D.get("edgeDistance"), u), N = D.get("bleedMargin"), F = P.getModel("labelLine"), G = F.get("length");
    G = Ae(G, u);
    var M = F.get("length2");
    if (M = Ae(M, u), Math.abs(E.endAngle - E.startAngle) < a) {
      B(R.states, f), R.ignore = !0, _ && (B(_.states, f), _.ignore = !0);
      return;
    }
    if (p(R)) {
      var V = (E.startAngle + E.endAngle) / 2, z = Math.cos(V), k = Math.sin(V), $, W, j, U;
      n = E.cx, i = E.cy;
      var Z = I === "inside" || I === "inner";
      if (I === "center")
        $ = E.cx, W = E.cy, U = "center";
      else {
        var ee = (Z ? (E.r + E.r0) / 2 * z : E.r * z) + n, J = (Z ? (E.r + E.r0) / 2 * k : E.r * k) + i;
        if ($ = ee + z * 3, W = J + k * 3, !Z) {
          var X = ee + z * (G + l - E.r), Y = J + k * (G + l - E.r), de = X + (z < 0 ? -1 : 1) * M, K = Y;
          O === "edge" ? $ = z < 0 ? c + L : c + u - L : $ = de + (z < 0 ? -A : A), W = K, j = [[ee, J], [X, Y], [de, K]];
        }
        U = Z ? "center" : O === "edge" ? z > 0 ? "right" : "left" : z > 0 ? "left" : "right";
      }
      var ie = Math.PI, Ce = 0, Te = D.get("rotate");
      if ($t(Te))
        Ce = Te * (ie / 180);
      else if (I === "center")
        Ce = 0;
      else if (Te === "radial" || Te === !0) {
        var Ie = z < 0 ? -V + ie : -V;
        Ce = Ie;
      } else if (Te === "tangential" && I !== "outside" && I !== "outer") {
        var we = Math.atan2(z, k);
        we < 0 && (we = ie * 2 + we);
        var Re = k > 0;
        Re && (we = ie + we), Ce = we - ie;
      }
      if (o = !!Ce, R.x = $, R.y = W, R.rotation = Ce, R.setStyle({
        verticalAlign: "middle"
      }), Z) {
        R.setStyle({
          align: U
        });
        var Ve = R.states.select;
        Ve && (Ve.x += R.x, Ve.y += R.y);
      } else {
        var _e = R.getBoundingRect().clone();
        _e.applyTransform(R.getComputedTransform());
        var He = (R.style.margin || 0) + 2.1;
        _e.y -= He / 2, _e.height += He, r.push({
          label: R,
          labelLine: _,
          position: I,
          len: G,
          len2: M,
          minTurnAngle: F.get("minTurnAngle"),
          maxSurfaceAngle: F.get("maxSurfaceAngle"),
          surfaceNormal: new Ct(z, k),
          linePoints: j,
          textAlign: U,
          labelDistance: A,
          labelAlignTo: O,
          edgeDistance: L,
          bleedMargin: N,
          rect: _e,
          unconstrainedWidth: _e.width,
          labelStyleWidth: R.style.width
        });
      }
      x.setTextConfig({
        inside: Z
      });
    }
  }), !o && e.get("avoidLabelOverlap") && k1e(r, n, i, l, u, h, c, d);
  for (var g = 0; g < r.length; g++) {
    var v = r[g], m = v.label, y = v.labelLine, C = isNaN(m.x) || isNaN(m.y);
    if (m) {
      m.setStyle({
        align: v.textAlign
      }), C && (B(m.states, f), m.ignore = !0);
      var S = m.states.select;
      S && (S.x += m.x, S.y += m.y);
    }
    if (y) {
      var b = v.linePoints;
      C || !b ? (B(y.states, f), y.ignore = !0) : (k7(b, v.minTurnAngle), sbe(b, v.surfaceNormal, v.maxSurfaceAngle), y.setShape({
        points: b
      }), m.__hostTarget.textGuideLineConfig = {
        anchor: new Ct(b[0][0], b[0][1])
      });
    }
  }
}
var B1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i) {
      var o = e.call(this) || this;
      o.z2 = 2;
      var a = new Vt();
      return o.setTextContent(a), o.updateData(r, n, i, !0), o;
    }
    return t.prototype.updateData = function(r, n, i, o) {
      var a = this, s = r.hostModel, l = r.getItemModel(n), u = l.getModel("emphasis"), c = r.getItemLayout(n), d = se(sc(l.getModel("itemStyle"), c, !0), c);
      if (isNaN(d.startAngle)) {
        a.setShape(d);
        return;
      }
      if (o) {
        a.setShape(d);
        var h = s.getShallow("animationType");
        s.ecModel.ssr ? (Pr(a, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: n,
          isFrom: !0
        }), a.originX = d.cx, a.originY = d.cy) : h === "scale" ? (a.shape.r = c.r0, Pr(a, {
          shape: {
            r: c.r
          }
        }, s, n)) : i != null ? (a.setShape({
          startAngle: i,
          endAngle: i
        }), Pr(a, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, s, n)) : (a.shape.endAngle = c.startAngle, jt(a, {
          shape: {
            endAngle: c.endAngle
          }
        }, s, n));
      } else
        Ca(a), jt(a, {
          shape: d
        }, s, n);
      a.useStyle(r.getItemVisual(n, "style")), Bn(a, l);
      var f = (c.startAngle + c.endAngle) / 2, p = s.get("selectedOffset"), g = Math.cos(f) * p, v = Math.sin(f) * p, m = l.getShallow("cursor");
      m && a.attr("cursor", m), this._updateLabel(s, r, n), a.ensureState("emphasis").shape = se({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, sc(u.getModel("itemStyle"), c)), se(a.ensureState("select"), {
        x: g,
        y: v,
        shape: sc(l.getModel(["select", "itemStyle"]), c)
      }), se(a.ensureState("blur"), {
        shape: sc(l.getModel(["blur", "itemStyle"]), c)
      });
      var y = a.getTextGuideLine(), C = a.getTextContent();
      y && se(y.ensureState("select"), {
        x: g,
        y: v
      }), se(C.ensureState("select"), {
        x: g,
        y: v
      }), Hr(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(r, n, i) {
      var o = this, a = n.getItemModel(i), s = a.getModel("labelLine"), l = n.getItemVisual(i, "style"), u = l && l.fill, c = l && l.opacity;
      Gn(o, Rn(a), {
        labelFetcher: n.hostModel,
        labelDataIndex: i,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: r.getFormattedLabel(i, "normal") || n.getName(i)
      });
      var d = o.getTextContent();
      o.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), d.attr({
        z2: 10
      });
      var h = r.get(["label", "position"]);
      if (h !== "outside" && h !== "outer")
        o.removeTextGuideLine();
      else {
        var f = this.getTextGuideLine();
        f || (f = new Ri(), this.setTextGuideLine(f)), lD(this, uD(a), {
          stroke: u,
          opacity: ro(s.get(["lineStyle", "opacity"]), c, 1)
        });
      }
    }, t;
  }(xi)
), G1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.ignoreLabelLineUpdate = !0, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = r.getData(), s = this._data, l = this.group, u;
      if (!s && a.count() > 0) {
        for (var c = a.getItemLayout(0), d = 1; isNaN(c && c.startAngle) && d < a.count(); ++d)
          c = a.getItemLayout(d);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), a.count() === 0 && r.get("showEmptyCircle")) {
        var h = v9(r), f = new xi({
          shape: se(g9(r, i), h)
        });
        f.useStyle(r.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = f, l.add(f);
      }
      a.diff(s).add(function(p) {
        var g = new B1e(a, p, u);
        a.setItemGraphicEl(p, g), l.add(g);
      }).update(function(p, g) {
        var v = s.getItemGraphicEl(g);
        v.updateData(a, p, u), v.off("click"), l.add(v), a.setItemGraphicEl(p, v);
      }).remove(function(p) {
        var g = s.getItemGraphicEl(p);
        Vg(g, r, p);
      }).execute(), V1e(r), r.get("animationTypeUpdate") !== "expansion" && (this._data = a);
    }, t.prototype.dispose = function() {
    }, t.prototype.containPoint = function(r, n) {
      var i = n.getData(), o = i.getItemLayout(0);
      if (o) {
        var a = r[0] - o.cx, s = r[1] - o.cy, l = Math.sqrt(a * a + s * s);
        return l <= o.r && l >= o.r0;
      }
    }, t.type = "pie", t;
  }(ar)
);
function Sf(e, t, r) {
  t = fe(t) && {
    coordDimensions: t
  } || se({
    encodeDefine: e.getEncode()
  }, t);
  var n = e.getSource(), i = mf(n, t).dimensions, o = new Jn(i, e);
  return o.initData(n, r), o;
}
var zv = (
  /** @class */
  function() {
    function e(t, r) {
      this._getDataWithEncodedVisual = t, this._getRawData = r;
    }
    return e.prototype.getAllNames = function() {
      var t = this._getRawData();
      return t.mapArray(t.getName);
    }, e.prototype.containName = function(t) {
      var r = this._getRawData();
      return r.indexOfName(t) >= 0;
    }, e.prototype.indexOfName = function(t) {
      var r = this._getDataWithEncodedVisual();
      return r.indexOfName(t);
    }, e.prototype.getItemVisual = function(t, r) {
      var n = this._getDataWithEncodedVisual();
      return n.getItemVisual(t, r);
    }, e;
  }()
), H1e = Gt(), z1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments), this.legendVisualProvider = new zv(ke(this.getData, this), ke(this.getRawData, this)), this._defaultLabelLine(r);
    }, t.prototype.mergeOption = function() {
      e.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.getInitialData = function() {
      return Sf(this, {
        coordDimensions: ["value"],
        encodeDefaulter: dt(OM, this)
      });
    }, t.prototype.getDataParams = function(r) {
      var n = this.getData(), i = H1e(n), o = i.seats;
      if (!o) {
        var a = [];
        n.each(n.mapDimension("value"), function(l) {
          a.push(l);
        }), o = i.seats = M$(a, n.hostModel.get("percentPrecision"));
      }
      var s = e.prototype.getDataParams.call(this, r);
      return s.percent = o[r] || 0, s.$vars.push("percent"), s;
    }, t.prototype._defaultLabelLine = function(r) {
      Tc(r, "labelLine", ["show"]);
      var n = r.labelLine, i = r.emphasis.labelLine;
      n.show = n.show && r.label.show, i.show = i.show && r.emphasis.label.show;
    }, t.type = "series.pie", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      endAngle: "auto",
      padAngle: 0,
      // 最小角度改为0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 选中时扇区偏移量
      selectedOffset: 10,
      // 选择模式，默认关闭，可选single，multiple
      // selectedMode: false,
      // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter: 标签文本格式器，同 tooltip.formatter，不支持异步回调
        // 默认使用全局文本样式，详见 textStyle
        // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 引导线两段中的第一段长度
        length: 15,
        // 引导线两段中的第二段长度
        length2: 15,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: 各异,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, t;
  }(hr)
);
function $1e(e) {
  return {
    seriesType: e,
    reset: function(t, r) {
      var n = t.getData();
      n.filterSelf(function(i) {
        var o = n.mapDimension("value"), a = n.get(o, i);
        return !($t(a) && !isNaN(a) && a < 0);
      });
    }
  };
}
function W1e(e) {
  e.registerChartView(G1e), e.registerSeriesModel(z1e), NW("pie", e.registerAction), e.registerLayout(dt(O1e, "pie")), e.registerProcessor(Hv("pie")), e.registerProcessor($1e("pie"));
}
var j1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return os(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.getProgressive = function() {
      var r = this.option.progressive;
      return r ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var r = this.option.progressiveThreshold;
      return r ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, t.prototype.brushSelector = function(r, n, i) {
      return i.point(n.getItemLayout(r));
    }, t.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, t.type = "series.scatter", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 图形旋转控制
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 各异
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, t;
  }(hr)
), y9 = 4, U1e = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), K1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return t.prototype.getDefaultShape = function() {
      return new U1e();
    }, t.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points, o = n.size, a = this.symbolProxy, s = a.shape, l = r.getContext ? r.getContext() : r, u = l && o[0] < y9, c = this.softClipShape, d;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, d = this._off; d < i.length; ) {
        var h = i[d++], f = i[d++];
        isNaN(h) || isNaN(f) || c && !c.contain(h, f) || (s.x = h - o[0] / 2, s.y = f - o[1] / 2, s.width = o[0], s.height = o[1], a.buildPath(r, s, !0));
      }
      this.incremental && (this._off = d, this.notClear = !0);
    }, t.prototype.afterBrush = function() {
      var r = this.shape, n = r.points, i = r.size, o = this._ctx, a = this.softClipShape, s;
      if (o) {
        for (s = this._off; s < n.length; ) {
          var l = n[s++], u = n[s++];
          isNaN(l) || isNaN(u) || a && !a.contain(l, u) || o.fillRect(l - i[0] / 2, u - i[1] / 2, i[0], i[1]);
        }
        this.incremental && (this._off = s, this.notClear = !0);
      }
    }, t.prototype.findDataIndex = function(r, n) {
      for (var i = this.shape, o = i.points, a = i.size, s = Math.max(a[0], 4), l = Math.max(a[1], 4), u = o.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, d = o[c] - s / 2, h = o[c + 1] - l / 2;
        if (r >= d && n >= h && r <= d + s && n <= h + l)
          return u;
      }
      return -1;
    }, t.prototype.contain = function(r, n) {
      var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect();
      if (r = i[0], n = i[1], o.contain(r, n)) {
        var a = this.hoverDataIdx = this.findDataIndex(r, n);
        return a >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, t.prototype.getBoundingRect = function() {
      var r = this._rect;
      if (!r) {
        for (var n = this.shape, i = n.points, o = n.size, a = o[0], s = o[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, d = -1 / 0, h = 0; h < i.length; ) {
          var f = i[h++], p = i[h++];
          l = Math.min(f, l), c = Math.max(f, c), u = Math.min(p, u), d = Math.max(p, d);
        }
        r = this._rect = new St(l - a / 2, u - s / 2, c - l + a, d - u + s);
      }
      return r;
    }, t;
  }(Mt)
), Y1e = (
  /** @class */
  function() {
    function e() {
      this.group = new it();
    }
    return e.prototype.updateData = function(t, r) {
      this._clear();
      var n = this._create();
      n.setShape({
        points: t.getLayout("points")
      }), this._setCommon(n, t, r);
    }, e.prototype.updateLayout = function(t) {
      var r = t.getLayout("points");
      this.group.eachChild(function(n) {
        if (n.startIndex != null) {
          var i = (n.endIndex - n.startIndex) * 2, o = n.startIndex * 4 * 2;
          r = new Float32Array(r.buffer, o, i);
        }
        n.setShape("points", r), n.reset();
      });
    }, e.prototype.incrementalPrepareUpdate = function(t) {
      this._clear();
    }, e.prototype.incrementalUpdate = function(t, r, n) {
      var i = this._newAdded[0], o = r.getLayout("points"), a = i && i.shape.points;
      if (a && a.length < 2e4) {
        var s = a.length, l = new Float32Array(s + o.length);
        l.set(a), l.set(o, s), i.endIndex = t.end, i.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = t.start, u.endIndex = t.end, u.incremental = !0, u.setShape({
          points: o
        }), this._setCommon(u, r, n);
      }
    }, e.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, e.prototype._create = function() {
      var t = new K1e({
        cursor: "default"
      });
      return t.ignoreCoarsePointer = !0, this.group.add(t), this._newAdded.push(t), t;
    }, e.prototype._setCommon = function(t, r, n) {
      var i = r.hostModel;
      n = n || {};
      var o = r.getVisual("symbolSize");
      t.setShape("size", o instanceof Array ? o : [o, o]), t.softClipShape = n.clipShape || null, t.symbolProxy = rn(r.getVisual("symbol"), 0, 0, 0, 0), t.setColor = t.symbolProxy.setColor;
      var a = t.shape.size[0] < y9;
      t.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        i.getModel("itemStyle").getItemStyle(a ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var s = r.getVisual("style"), l = s && s.fill;
      l && t.setColor(l);
      var u = ot(t);
      u.seriesIndex = i.seriesIndex, t.on("mousemove", function(c) {
        u.dataIndex = null;
        var d = t.hoverDataIdx;
        d >= 0 && (u.dataIndex = d + (t.startIndex || 0));
      });
    }, e.prototype.remove = function() {
      this._clear();
    }, e.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, e;
  }()
), q1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this._updateSymbolDraw(o, r);
      a.updateData(o, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(r)
      }), this._finished = !0;
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      var o = r.getData(), a = this._updateSymbolDraw(o, r);
      a.incrementalPrepareUpdate(o), this._finished = !1;
    }, t.prototype.incrementalRender = function(r, n, i) {
      this._symbolDraw.incrementalUpdate(r, n.getData(), {
        clipShape: this._getClipShape(n)
      }), this._finished = r.end === n.getData().count();
    }, t.prototype.updateTransform = function(r, n, i) {
      var o = r.getData();
      if (this.group.dirty(), !this._finished || o.count() > 1e4)
        return {
          update: !0
        };
      var a = Gv("").reset(r, n, i);
      a.progress && a.progress({
        start: 0,
        end: o.count(),
        count: o.count()
      }, o), this._symbolDraw.updateLayout(o);
    }, t.prototype.eachRendered = function(r) {
      this._symbolDraw && this._symbolDraw.eachRendered(r);
    }, t.prototype._getClipShape = function(r) {
      if (r.get("clip", !0)) {
        var n = r.coordinateSystem;
        return n && n.getArea && n.getArea(0.1);
      }
    }, t.prototype._updateSymbolDraw = function(r, n) {
      var i = this._symbolDraw, o = n.pipelineContext, a = o.large;
      return (!i || a !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = a ? new Y1e() : new Vv(), this._isLargeDraw = a, this.group.removeAll()), this.group.add(i.group), i;
    }, t.prototype.remove = function(r, n) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, t.prototype.dispose = function() {
    }, t.type = "scatter", t;
  }(ar)
), Z1e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.type = "grid", t.dependencies = ["xAxis", "yAxis"], t.layoutMode = "box", t.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      // If grid size contain label
      containLabel: !1,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, t;
  }(Rt)
), I_ = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", un).models[0];
    }, t.type = "cartesian2dAxis", t;
  }(Rt)
);
qr(I_, Cf);
var C9 = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: !0,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
}, X1e = yt({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, C9), vD = yt({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, C9), Q1e = yt({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, vD), J1e = Xe({
  logBase: 10
}, vD);
const S9 = {
  category: X1e,
  value: vD,
  time: Q1e,
  log: J1e
};
var exe = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function Vh(e, t, r, n) {
  B(exe, function(i, o) {
    var a = yt(yt({}, S9[o], !0), n, !0), s = (
      /** @class */
      function(l) {
        ne(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = t + "Axis." + o, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, d) {
          var h = Gg(this), f = h ? hf(c) : {}, p = d.getTheme();
          yt(c, p.get(o + "Axis")), yt(c, this.getDefaultOption()), c.type = Ok(c), h && Kl(c, f, h);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = E_.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var d = this.option;
          if (d.type === "category")
            return c ? d.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = t + "Axis." + o, u.defaultOption = a, u;
      }(r)
    );
    e.registerComponentModel(s);
  }), e.registerSubTypeDefaulter(t + "Axis", Ok);
}
function Ok(e) {
  return e.type || (e.data ? "category" : "value");
}
var txe = (
  /** @class */
  function() {
    function e(t) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = t || "";
    }
    return e.prototype.getAxis = function(t) {
      return this._axes[t];
    }, e.prototype.getAxes = function() {
      return ge(this._dimList, function(t) {
        return this._axes[t];
      }, this);
    }, e.prototype.getAxesByScale = function(t) {
      return t = t.toLowerCase(), ir(this.getAxes(), function(r) {
        return r.scale.type === t;
      });
    }, e.prototype.addAxis = function(t) {
      var r = t.dim;
      this._axes[r] = t, this._dimList.push(r);
    }, e;
  }()
), F_ = ["x", "y"];
function Nk(e) {
  return e.type === "interval" || e.type === "time";
}
var rxe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "cartesian2d", r.dimensions = F_, r;
    }
    return t.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var r = this.getAxis("x").scale, n = this.getAxis("y").scale;
      if (!(!Nk(r) || !Nk(n))) {
        var i = r.getExtent(), o = n.getExtent(), a = this.dataToPoint([i[0], o[0]]), s = this.dataToPoint([i[1], o[1]]), l = i[1] - i[0], u = o[1] - o[0];
        if (!(!l || !u)) {
          var c = (s[0] - a[0]) / l, d = (s[1] - a[1]) / u, h = a[0] - i[0] * c, f = a[1] - o[0] * d, p = this._transform = [c, 0, 0, d, h, f];
          this._invTransform = Wc([], p);
        }
      }
    }, t.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, t.prototype.containPoint = function(r) {
      var n = this.getAxis("x"), i = this.getAxis("y");
      return n.contain(n.toLocalCoord(r[0])) && i.contain(i.toLocalCoord(r[1]));
    }, t.prototype.containData = function(r) {
      return this.getAxis("x").containData(r[0]) && this.getAxis("y").containData(r[1]);
    }, t.prototype.containZone = function(r, n) {
      var i = this.dataToPoint(r), o = this.dataToPoint(n), a = this.getArea(), s = new St(i[0], i[1], o[0] - i[0], o[1] - i[1]);
      return a.intersect(s);
    }, t.prototype.dataToPoint = function(r, n, i) {
      i = i || [];
      var o = r[0], a = r[1];
      if (this._transform && o != null && isFinite(o) && a != null && isFinite(a))
        return An(i, r, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return i[0] = s.toGlobalCoord(s.dataToCoord(o, n)), i[1] = l.toGlobalCoord(l.dataToCoord(a, n)), i;
    }, t.prototype.clampData = function(r, n) {
      var i = this.getAxis("x").scale, o = this.getAxis("y").scale, a = i.getExtent(), s = o.getExtent(), l = i.parse(r[0]), u = o.parse(r[1]);
      return n = n || [], n[0] = Math.min(Math.max(Math.min(a[0], a[1]), l), Math.max(a[0], a[1])), n[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), n;
    }, t.prototype.pointToData = function(r, n) {
      var i = [];
      if (this._invTransform)
        return An(i, r, this._invTransform);
      var o = this.getAxis("x"), a = this.getAxis("y");
      return i[0] = o.coordToData(o.toLocalCoord(r[0]), n), i[1] = a.coordToData(a.toLocalCoord(r[1]), n), i;
    }, t.prototype.getOtherAxis = function(r) {
      return this.getAxis(r.dim === "x" ? "y" : "x");
    }, t.prototype.getArea = function(r) {
      r = r || 0;
      var n = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), o = Math.min(n[0], n[1]) - r, a = Math.min(i[0], i[1]) - r, s = Math.max(n[0], n[1]) - o + r, l = Math.max(i[0], i[1]) - a + r;
      return new St(o, a, s, l);
    }, t;
  }(txe)
), nxe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i, o, a) {
      var s = e.call(this, r, n, i) || this;
      return s.index = 0, s.type = o || "value", s.position = a || "bottom", s;
    }
    return t.prototype.isHorizontal = function() {
      var r = this.position;
      return r === "top" || r === "bottom";
    }, t.prototype.getGlobalExtent = function(r) {
      var n = this.getExtent();
      return n[0] = this.toGlobalCoord(n[0]), n[1] = this.toGlobalCoord(n[1]), r && n[0] > n[1] && n.reverse(), n;
    }, t.prototype.pointToData = function(r, n) {
      return this.coordToData(this.toLocalCoord(r[this.dim === "x" ? 0 : 1]), n);
    }, t.prototype.setCategorySortInfo = function(r) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = r, this.scale.setSortInfo(r);
    }, t;
  }(Wo)
);
function L_(e, t, r) {
  r = r || {};
  var n = e.coordinateSystem, i = t.axis, o = {}, a = i.getAxesOnZeroOf()[0], s = i.position, l = a ? "onZero" : s, u = i.dim, c = n.getRect(), d = [c.x, c.x + c.width, c.y, c.y + c.height], h = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, f = t.get("offset") || 0, p = u === "x" ? [d[2] - f, d[3] + f] : [d[0] - f, d[1] + f];
  if (a) {
    var g = a.toGlobalCoord(a.dataToCoord(0));
    p[h.onZero] = Math.max(Math.min(g, p[1]), p[0]);
  }
  o.position = [u === "y" ? p[h[l]] : d[0], u === "x" ? p[h[l]] : d[3]], o.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  o.labelDirection = o.tickDirection = o.nameDirection = v[s], o.labelOffset = a ? p[h[s]] - p[h.onZero] : 0, t.get(["axisTick", "inside"]) && (o.tickDirection = -o.tickDirection), tn(r.labelInside, t.get(["axisLabel", "inside"])) && (o.labelDirection = -o.labelDirection);
  var m = t.get(["axisLabel", "rotate"]);
  return o.labelRotate = l === "top" ? -m : m, o.z2 = 1, o;
}
function kk(e) {
  return e.get("coordinateSystem") === "cartesian2d";
}
function Vk(e) {
  var t = {
    xAxisModel: null,
    yAxisModel: null
  };
  return B(t, function(r, n) {
    var i = n.replace(/Model$/, ""), o = e.getReferringComponents(i, un).models[0];
    if (process.env.NODE_ENV !== "production" && !o)
      throw new Error(i + ' "' + ro(e.get(i + "Index"), e.get(i + "Id"), 0) + '" not found');
    t[n] = o;
  }), t;
}
var O1 = Math.log;
function w9(e, t, r) {
  var n = Us.prototype, i = n.getTicks.call(r), o = n.getTicks.call(r, !0), a = i.length - 1, s = n.getInterval.call(r), l = E7(e, t), u = l.extent, c = l.fixMin, d = l.fixMax;
  if (e.type === "log") {
    var h = O1(e.base);
    u = [O1(u[0]) / h, O1(u[1]) / h];
  }
  e.setExtent(u[0], u[1]), e.calcNiceExtent({
    splitNumber: a,
    fixMin: c,
    fixMax: d
  });
  var f = n.getExtent.call(e);
  c && (u[0] = f[0]), d && (u[1] = f[1]);
  var p = n.getInterval.call(e), g = u[0], v = u[1];
  if (c && d)
    p = (v - g) / a;
  else if (c)
    for (v = u[0] + p * a; v < u[1] && isFinite(v) && isFinite(u[1]); )
      p = S1(p), v = u[0] + p * a;
  else if (d)
    for (g = u[1] - p * a; g > u[0] && isFinite(g) && isFinite(u[0]); )
      p = S1(p), g = u[1] - p * a;
  else {
    var m = e.getTicks().length - 1;
    m > a && (p = S1(p));
    var y = p * a;
    v = Math.ceil(u[1] / p) * p, g = Gr(v - y), g < 0 && u[0] >= 0 ? (g = 0, v = Gr(y)) : v > 0 && u[1] <= 0 && (v = 0, g = -Gr(y));
  }
  var C = (i[0].value - o[0].value) / s, S = (i[a].value - o[a].value) / s;
  if (n.setExtent.call(e, g + p * C, v + p * S), n.setInterval.call(e, p), (C || S) && n.setNiceExtent.call(e, g + p, v - p), process.env.NODE_ENV !== "production") {
    var b = n.getTicks.call(e);
    b[1] && (!JSe(p) || K0(b[1].value) > K0(p)) && Vr(
      // eslint-disable-next-line
      "The ticks may be not readable when set min: " + t.get("min") + ", max: " + t.get("max") + " and alignTicks: true"
    );
  }
}
var ixe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = F_, this._initCartesian(t, r, n), this.model = t;
    }
    return e.prototype.getRect = function() {
      return this._rect;
    }, e.prototype.update = function(t, r) {
      var n = this._axesMap;
      this._updateScale(t, this.model);
      function i(a) {
        var s, l = At(a), u = l.length;
        if (u) {
          for (var c = [], d = u - 1; d >= 0; d--) {
            var h = +l[d], f = a[h], p = f.model, g = f.scale;
            // Only value and log axis without interval support alignTicks.
            R_(g) && p.get("alignTicks") && p.get("interval") == null ? c.push(f) : (Ic(g, p), R_(g) && (s = f));
          }
          c.length && (s || (s = c.pop(), Ic(s.scale, s.model)), B(c, function(v) {
            w9(v.scale, v.model, s.scale);
          }));
        }
      }
      i(n.x), i(n.y);
      var o = {};
      B(n.x, function(a) {
        Bk(n, "y", a, o);
      }), B(n.y, function(a) {
        Bk(n, "x", a, o);
      }), this.resize(this.model, r);
    }, e.prototype.resize = function(t, r, n) {
      var i = t.getBoxLayoutParams(), o = !n && t.get("containLabel"), a = hn(i, {
        width: r.getWidth(),
        height: r.getHeight()
      });
      this._rect = a;
      var s = this._axesList;
      l(), o && (B(s, function(u) {
        if (!u.model.get(["axisLabel", "inside"])) {
          var c = xwe(u);
          if (c) {
            var d = u.isHorizontal() ? "height" : "width", h = u.model.get(["axisLabel", "margin"]);
            a[d] -= c[d] + h, u.position === "top" ? a.y += c.height + h : u.position === "left" && (a.x += c.width + h);
          }
        }
      }), l()), B(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        B(s, function(u) {
          var c = u.isHorizontal(), d = c ? [0, a.width] : [0, a.height], h = u.inverse ? 1 : 0;
          u.setExtent(d[h], d[1 - h]), oxe(u, c ? a.x : a.y);
        });
      }
    }, e.prototype.getAxis = function(t, r) {
      var n = this._axesMap[t];
      if (n != null)
        return n[r || 0];
    }, e.prototype.getAxes = function() {
      return this._axesList.slice();
    }, e.prototype.getCartesian = function(t, r) {
      if (t != null && r != null) {
        var n = "x" + t + "y" + r;
        return this._coordsMap[n];
      }
      Ze(t) && (r = t.yAxisIndex, t = t.xAxisIndex);
      for (var i = 0, o = this._coordsList; i < o.length; i++)
        if (o[i].getAxis("x").index === t || o[i].getAxis("y").index === r)
          return o[i];
    }, e.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, e.prototype.convertToPixel = function(t, r, n) {
      var i = this._findConvertTarget(r);
      return i.cartesian ? i.cartesian.dataToPoint(n) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(n)) : null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      var i = this._findConvertTarget(r);
      return i.cartesian ? i.cartesian.pointToData(n) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(n)) : null;
    }, e.prototype._findConvertTarget = function(t) {
      var r = t.seriesModel, n = t.xAxisModel || r && r.getReferringComponents("xAxis", un).models[0], i = t.yAxisModel || r && r.getReferringComponents("yAxis", un).models[0], o = t.gridModel, a = this._coordsList, s, l;
      if (r)
        s = r.coordinateSystem, bt(a, s) < 0 && (s = null);
      else if (n && i)
        s = this.getCartesian(n.componentIndex, i.componentIndex);
      else if (n)
        l = this.getAxis("x", n.componentIndex);
      else if (i)
        l = this.getAxis("y", i.componentIndex);
      else if (o) {
        var u = o.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, e.prototype.containPoint = function(t) {
      var r = this._coordsList[0];
      if (r)
        return r.containPoint(t);
    }, e.prototype._initCartesian = function(t, r, n) {
      var i = this, o = this, a = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (r.eachComponent("xAxis", u("x"), this), r.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, B(s.x, function(c, d) {
        B(s.y, function(h, f) {
          var p = "x" + d + "y" + f, g = new rxe(p);
          g.master = i, g.model = t, i._coordsMap[p] = g, i._coordsList.push(g), g.addAxis(c), g.addAxis(h);
        });
      });
      function u(c) {
        return function(d, h) {
          if (N1(d, t)) {
            var f = d.get("position");
            c === "x" ? f !== "top" && f !== "bottom" && (f = a.bottom ? "top" : "bottom") : f !== "left" && f !== "right" && (f = a.left ? "right" : "left"), a[f] = !0;
            var p = new nxe(c, Nv(d), [0, 0], d.get("type"), f), g = p.type === "category";
            p.onBand = g && d.get("boundaryGap"), p.inverse = d.get("inverse"), d.axis = p, p.model = d, p.grid = o, p.index = h, o._axesList.push(p), s[c][h] = p, l[c]++;
          }
        };
      }
    }, e.prototype._updateScale = function(t, r) {
      B(this._axesList, function(i) {
        if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") {
          var o = i.model.get("categorySortInfo");
          i.scale.setSortInfo(o);
        }
      }), t.eachSeries(function(i) {
        if (kk(i)) {
          var o = Vk(i), a = o.xAxisModel, s = o.yAxisModel;
          if (!N1(a, r) || !N1(s, r))
            return;
          var l = this.getCartesian(a.componentIndex, s.componentIndex), u = i.getData(), c = l.getAxis("x"), d = l.getAxis("y");
          n(u, c), n(u, d);
        }
      }, this);
      function n(i, o) {
        B(pC(i, o.dim), function(a) {
          o.scale.unionExtentFromData(i, a);
        });
      }
    }, e.prototype.getTooltipAxes = function(t) {
      var r = [], n = [];
      return B(this.getCartesians(), function(i) {
        var o = t != null && t !== "auto" ? i.getAxis(t) : i.getBaseAxis(), a = i.getOtherAxis(o);
        bt(r, o) < 0 && r.push(o), bt(n, a) < 0 && n.push(a);
      }), {
        baseAxes: r,
        otherAxes: n
      };
    }, e.create = function(t, r) {
      var n = [];
      return t.eachComponent("grid", function(i, o) {
        var a = new e(i, t, r);
        a.name = "grid_" + o, a.resize(i, r, !0), i.coordinateSystem = a, n.push(a);
      }), t.eachSeries(function(i) {
        if (kk(i)) {
          var o = Vk(i), a = o.xAxisModel, s = o.yAxisModel, l = a.getCoordSysModel();
          if (process.env.NODE_ENV !== "production") {
            if (!l)
              throw new Error('Grid "' + ro(a.get("gridIndex"), a.get("gridId"), 0) + '" not found');
            if (a.getCoordSysModel() !== s.getCoordSysModel())
              throw new Error("xAxis and yAxis must use the same grid");
          }
          var u = l.coordinateSystem;
          i.coordinateSystem = u.getCartesian(a.componentIndex, s.componentIndex);
        }
      }), n;
    }, e.dimensions = F_, e;
  }()
);
function N1(e, t) {
  return e.getCoordSysModel() === t;
}
function Bk(e, t, r, n) {
  r.getAxesOnZeroOf = function() {
    return o ? [o] : [];
  };
  var i = e[t], o, a = r.model, s = a.get(["axisLine", "onZero"]), l = a.get(["axisLine", "onZeroAxisIndex"]);
  if (!s)
    return;
  if (l != null)
    Gk(i[l]) && (o = i[l]);
  else
    for (var u in i)
      if (i.hasOwnProperty(u) && Gk(i[u]) && !n[c(i[u])]) {
        o = i[u];
        break;
      }
  o && (n[c(o)] = !0);
  function c(d) {
    return d.dim + "_" + d.index;
  }
}
function Gk(e) {
  return e && e.type !== "category" && e.type !== "time" && bwe(e);
}
function oxe(e, t) {
  var r = e.getExtent(), n = r[0] + r[1];
  e.toGlobalCoord = e.dim === "x" ? function(i) {
    return i + t;
  } : function(i) {
    return n - i + t;
  }, e.toLocalCoord = e.dim === "x" ? function(i) {
    return i - t;
  } : function(i) {
    return n - i + t;
  };
}
var Pl = Math.PI, Ci = (
  /** @class */
  function() {
    function e(t, r) {
      this.group = new it(), this.opt = r, this.axisModel = t, Xe(r, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0,
        handleAutoShown: function() {
          return !0;
        }
      });
      var n = new it({
        x: r.position[0],
        y: r.position[1],
        rotation: r.rotation
      });
      n.updateTransform(), this._transformGroup = n;
    }
    return e.prototype.hasBuilder = function(t) {
      return !!Hk[t];
    }, e.prototype.add = function(t) {
      Hk[t](this.opt, this.axisModel, this.group, this._transformGroup);
    }, e.prototype.getGroup = function() {
      return this.group;
    }, e.innerTextLayout = function(t, r, n) {
      var i = aM(r - t), o, a;
      return Ah(i) ? (a = n > 0 ? "top" : "bottom", o = "center") : Ah(i - Pl) ? (a = n > 0 ? "bottom" : "top", o = "center") : (a = "middle", i > 0 && i < Pl ? o = n > 0 ? "right" : "left" : o = n > 0 ? "left" : "right"), {
        rotation: i,
        textAlign: o,
        textVerticalAlign: a
      };
    }, e.makeAxisEventDataBase = function(t) {
      var r = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return r[t.mainType + "Index"] = t.componentIndex, r;
    }, e.isLabelSilent = function(t) {
      var r = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || r && r.show);
    }, e;
  }()
), Hk = {
  axisLine: function(e, t, r, n) {
    var i = t.get(["axisLine", "show"]);
    if (i === "auto" && e.handleAutoShown && (i = e.handleAutoShown("axisLine")), !!i) {
      var o = t.axis.getExtent(), a = n.transform, s = [o[0], 0], l = [o[1], 0], u = s[0] > l[0];
      a && (An(s, s, a), An(l, l, a));
      var c = se({
        lineCap: "round"
      }, t.getModel(["axisLine", "lineStyle"]).getLineStyle()), d = new wn({
        shape: {
          x1: s[0],
          y1: s[1],
          x2: l[0],
          y2: l[1]
        },
        style: c,
        strokeContainThreshold: e.strokeContainThreshold || 5,
        silent: !0,
        z2: 1
      });
      Lh(d.shape, d.style.lineWidth), d.anid = "line", r.add(d);
      var h = t.get(["axisLine", "symbol"]);
      if (h != null) {
        var f = t.get(["axisLine", "symbolSize"]);
        Fe(h) && (h = [h, h]), (Fe(f) || $t(f)) && (f = [f, f]);
        var p = qc(t.get(["axisLine", "symbolOffset"]) || 0, f), g = f[0], v = f[1];
        B([{
          rotate: e.rotation + Math.PI / 2,
          offset: p[0],
          r: 0
        }, {
          rotate: e.rotation - Math.PI / 2,
          offset: p[1],
          r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
        }], function(m, y) {
          if (h[y] !== "none" && h[y] != null) {
            var C = rn(h[y], -g / 2, -v / 2, g, v, c.stroke, !0), S = m.r + m.offset, b = u ? l : s;
            C.attr({
              rotation: m.rotate,
              x: b[0] + S * Math.cos(e.rotation),
              y: b[1] - S * Math.sin(e.rotation),
              silent: !0,
              z2: 11
            }), r.add(C);
          }
        });
      }
    }
  },
  axisTickLabel: function(e, t, r, n) {
    var i = lxe(r, n, t, e), o = cxe(r, n, t, e);
    if (sxe(t, o, i), uxe(r, n, t, e.tickDirection), t.get(["axisLabel", "hideOverlap"])) {
      var a = V7(ge(o, function(s) {
        return {
          label: s,
          priority: s.z2,
          defaultAttr: {
            ignore: s.ignore
          }
        };
      }));
      H7(a);
    }
  },
  axisName: function(e, t, r, n) {
    var i = tn(e.axisName, t.get("name"));
    if (i) {
      var o = t.get("nameLocation"), a = e.nameDirection, s = t.getModel("nameTextStyle"), l = t.get("nameGap") || 0, u = t.axis.getExtent(), c = u[0] > u[1] ? -1 : 1, d = [
        o === "start" ? u[0] - c * l : o === "end" ? u[1] + c * l : (u[0] + u[1]) / 2,
        // Reuse labelOffset.
        $k(o) ? e.labelOffset + a * l : 0
      ], h, f = t.get("nameRotate");
      f != null && (f = f * Pl / 180);
      var p;
      $k(o) ? h = Ci.innerTextLayout(
        e.rotation,
        f ?? e.rotation,
        // Adapt to axis.
        a
      ) : (h = axe(e.rotation, o, f || 0, u), p = e.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(h.rotation)), !isFinite(p) && (p = null)));
      var g = s.getFont(), v = t.get("nameTruncate", !0) || {}, m = v.ellipsis, y = tn(e.nameTruncateMaxWidth, v.maxWidth, p), C = new Vt({
        x: d[0],
        y: d[1],
        rotation: h.rotation,
        silent: Ci.isLabelSilent(t),
        style: br(s, {
          text: i,
          font: g,
          overflow: "truncate",
          width: y,
          ellipsis: m,
          fill: s.getTextColor() || t.get(["axisLine", "lineStyle", "color"]),
          align: s.get("align") || h.textAlign,
          verticalAlign: s.get("verticalAlign") || h.textVerticalAlign
        }),
        z2: 1
      });
      if (uf({
        el: C,
        componentModel: t,
        itemName: i
      }), C.__fullText = i, C.anid = "name", t.get("triggerEvent")) {
        var S = Ci.makeAxisEventDataBase(t);
        S.targetType = "axisName", S.name = i, ot(C).eventData = S;
      }
      n.add(C), C.updateTransform(), r.add(C), C.decomposeTransform();
    }
  }
};
function axe(e, t, r, n) {
  var i = aM(r - e), o, a, s = n[0] > n[1], l = t === "start" && !s || t !== "start" && s;
  return Ah(i - Pl / 2) ? (a = l ? "bottom" : "top", o = "center") : Ah(i - Pl * 1.5) ? (a = l ? "top" : "bottom", o = "center") : (a = "middle", i < Pl * 1.5 && i > Pl / 2 ? o = l ? "left" : "right" : o = l ? "right" : "left"), {
    rotation: i,
    textAlign: o,
    textVerticalAlign: a
  };
}
function sxe(e, t, r) {
  if (!R7(e.axis)) {
    var n = e.get(["axisLabel", "showMinLabel"]), i = e.get(["axisLabel", "showMaxLabel"]);
    t = t || [], r = r || [];
    var o = t[0], a = t[1], s = t[t.length - 1], l = t[t.length - 2], u = r[0], c = r[1], d = r[r.length - 1], h = r[r.length - 2];
    n === !1 ? (fo(o), fo(u)) : zk(o, a) && (n ? (fo(a), fo(c)) : (fo(o), fo(u))), i === !1 ? (fo(s), fo(d)) : zk(l, s) && (i ? (fo(l), fo(h)) : (fo(s), fo(d)));
  }
}
function fo(e) {
  e && (e.ignore = !0);
}
function zk(e, t) {
  var r = e && e.getBoundingRect().clone(), n = t && t.getBoundingRect().clone();
  if (!(!r || !n)) {
    var i = Ev([]);
    return nu(i, i, -e.rotation), r.applyTransform(Ka([], i, e.getLocalTransform())), n.applyTransform(Ka([], i, t.getLocalTransform())), r.intersect(n);
  }
}
function $k(e) {
  return e === "middle" || e === "center";
}
function b9(e, t, r, n, i) {
  for (var o = [], a = [], s = [], l = 0; l < e.length; l++) {
    var u = e[l].coord;
    a[0] = u, a[1] = 0, s[0] = u, s[1] = r, t && (An(a, a, t), An(s, s, t));
    var c = new wn({
      shape: {
        x1: a[0],
        y1: a[1],
        x2: s[0],
        y2: s[1]
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    Lh(c.shape, c.style.lineWidth), c.anid = i + "_" + e[l].tickValue, o.push(c);
  }
  return o;
}
function lxe(e, t, r, n) {
  var i = r.axis, o = r.getModel("axisTick"), a = o.get("show");
  if (a === "auto" && n.handleAutoShown && (a = n.handleAutoShown("axisTick")), !(!a || i.scale.isBlank())) {
    for (var s = o.getModel("lineStyle"), l = n.tickDirection * o.get("length"), u = i.getTicksCoords(), c = b9(u, t.transform, l, Xe(s.getLineStyle(), {
      stroke: r.get(["axisLine", "lineStyle", "color"])
    }), "ticks"), d = 0; d < c.length; d++)
      e.add(c[d]);
    return c;
  }
}
function uxe(e, t, r, n) {
  var i = r.axis, o = r.getModel("minorTick");
  if (!(!o.get("show") || i.scale.isBlank())) {
    var a = i.getMinorTicksCoords();
    if (a.length)
      for (var s = o.getModel("lineStyle"), l = n * o.get("length"), u = Xe(s.getLineStyle(), Xe(r.getModel("axisTick").getLineStyle(), {
        stroke: r.get(["axisLine", "lineStyle", "color"])
      })), c = 0; c < a.length; c++)
        for (var d = b9(a[c], t.transform, l, u, "minorticks_" + c), h = 0; h < d.length; h++)
          e.add(d[h]);
  }
}
function cxe(e, t, r, n) {
  var i = r.axis, o = tn(n.axisLabelShow, r.get(["axisLabel", "show"]));
  if (!(!o || i.scale.isBlank())) {
    var a = r.getModel("axisLabel"), s = a.get("margin"), l = i.getViewLabels(), u = (tn(n.labelRotate, a.get("rotate")) || 0) * Pl / 180, c = Ci.innerTextLayout(n.rotation, u, n.labelDirection), d = r.getCategories && r.getCategories(!0), h = [], f = Ci.isLabelSilent(r), p = r.get("triggerEvent");
    return B(l, function(g, v) {
      var m = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(g.tickValue) : g.tickValue, y = g.formattedLabel, C = g.rawLabel, S = a;
      if (d && d[m]) {
        var b = d[m];
        Ze(b) && b.textStyle && (S = new cr(b.textStyle, a, r.ecModel));
      }
      var w = S.getTextColor() || r.get(["axisLine", "lineStyle", "color"]), x = i.dataToCoord(m), E = S.getShallow("align", !0) || c.textAlign, R = st(S.getShallow("alignMinLabel", !0), E), _ = st(S.getShallow("alignMaxLabel", !0), E), P = S.getShallow("verticalAlign", !0) || S.getShallow("baseline", !0) || c.textVerticalAlign, D = st(S.getShallow("verticalAlignMinLabel", !0), P), I = st(S.getShallow("verticalAlignMaxLabel", !0), P), A = new Vt({
        x,
        y: n.labelOffset + n.labelDirection * s,
        rotation: c.rotation,
        silent: f,
        z2: 10 + (g.level || 0),
        style: br(S, {
          text: y,
          align: v === 0 ? R : v === l.length - 1 ? _ : E,
          verticalAlign: v === 0 ? D : v === l.length - 1 ? I : P,
          fill: Ye(w) ? w(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            i.type === "category" ? C : i.type === "value" ? m + "" : m,
            v
          ) : w
        })
      });
      if (A.anid = "label_" + m, p) {
        var O = Ci.makeAxisEventDataBase(r);
        O.targetType = "axisLabel", O.value = C, O.tickIndex = v, i.type === "category" && (O.dataIndex = m), ot(A).eventData = O;
      }
      t.add(A), A.updateTransform(), h.push(A), e.add(A), A.decomposeTransform();
    }), h;
  }
}
function dxe(e, t) {
  var r = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return hxe(r, e, t), r.seriesInvolved && pxe(r, e), r;
}
function hxe(e, t, r) {
  var n = t.getComponent("tooltip"), i = t.getComponent("axisPointer"), o = i.get("link", !0) || [], a = [];
  B(r.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = qg(s.model), u = e.coordSysAxesInfo[l] = {};
    e.coordSysMap[l] = s;
    var c = s.model, d = c.getModel("tooltip", n);
    if (B(s.getAxes(), dt(g, !1, null)), s.getTooltipAxes && n && d.get("show")) {
      var h = d.get("trigger") === "axis", f = d.get(["axisPointer", "type"]) === "cross", p = s.getTooltipAxes(d.get(["axisPointer", "axis"]));
      (h || f) && B(p.baseAxes, dt(g, f ? "cross" : !0, h)), f && B(p.otherAxes, dt(g, "cross", !1));
    }
    function g(v, m, y) {
      var C = y.model.getModel("axisPointer", i), S = C.get("show");
      if (!(!S || S === "auto" && !v && !O_(C))) {
        m == null && (m = C.get("triggerTooltip")), C = v ? fxe(y, d, i, t, v, m) : C;
        var b = C.get("snap"), w = C.get("triggerEmphasis"), x = qg(y.model), E = m || b || y.type === "category", R = e.axesInfo[x] = {
          key: x,
          axis: y,
          coordSys: s,
          axisPointerModel: C,
          triggerTooltip: m,
          triggerEmphasis: w,
          involveSeries: E,
          snap: b,
          useHandle: O_(C),
          seriesModels: [],
          linkGroup: null
        };
        u[x] = R, e.seriesInvolved = e.seriesInvolved || E;
        var _ = gxe(o, y);
        if (_ != null) {
          var P = a[_] || (a[_] = {
            axesInfo: {}
          });
          P.axesInfo[x] = R, P.mapper = o[_].mapper, R.linkGroup = P;
        }
      }
    }
  });
}
function fxe(e, t, r, n, i, o) {
  var a = t.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  B(s, function(h) {
    l[h] = et(a.get(h));
  }), l.snap = e.type !== "category" && !!o, a.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), i === "cross") {
    var c = a.get(["label", "show"]);
    if (u.show = c ?? !0, !o) {
      var d = l.lineStyle = a.get("crossStyle");
      d && Xe(u, d.textStyle);
    }
  }
  return e.model.getModel("axisPointer", new cr(l, r, n));
}
function pxe(e, t) {
  t.eachSeries(function(r) {
    var n = r.coordinateSystem, i = r.get(["tooltip", "trigger"], !0), o = r.get(["tooltip", "show"], !0);
    !n || i === "none" || i === !1 || i === "item" || o === !1 || r.get(["axisPointer", "show"], !0) === !1 || B(e.coordSysAxesInfo[qg(n.model)], function(a) {
      var s = a.axis;
      n.getAxis(s.dim) === s && (a.seriesModels.push(r), a.seriesDataCount == null && (a.seriesDataCount = 0), a.seriesDataCount += r.getData().count());
    });
  });
}
function gxe(e, t) {
  for (var r = t.model, n = t.dim, i = 0; i < e.length; i++) {
    var o = e[i] || {};
    if (k1(o[n + "AxisId"], r.id) || k1(o[n + "AxisIndex"], r.componentIndex) || k1(o[n + "AxisName"], r.name))
      return i;
  }
}
function k1(e, t) {
  return e === "all" || fe(e) && bt(e, t) >= 0 || e === t;
}
function vxe(e) {
  var t = mD(e);
  if (t) {
    var r = t.axisPointerModel, n = t.axis.scale, i = r.option, o = r.get("status"), a = r.get("value");
    a != null && (a = n.parse(a));
    var s = O_(r);
    o == null && (i.status = s ? "show" : "hide");
    var l = n.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (a == null || a > l[1]) && (a = l[1]), a < l[0] && (a = l[0]), i.value = a, s && (i.status = t.axis.scale.isBlank() ? "hide" : "show");
  }
}
function mD(e) {
  var t = (e.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return t && t.axesInfo[qg(e)];
}
function mxe(e) {
  var t = mD(e);
  return t && t.axisPointerModel;
}
function O_(e) {
  return !!e.get(["handle", "show"]);
}
function qg(e) {
  return e.type + "||" + e.id;
}
var V1 = {}, Xc = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this.axisPointerClass && vxe(r), e.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(r, i, !0);
    }, t.prototype.updateAxisPointer = function(r, n, i, o) {
      this._doUpdateAxisPointerClass(r, i, !1);
    }, t.prototype.remove = function(r, n) {
      var i = this._axisPointer;
      i && i.remove(n);
    }, t.prototype.dispose = function(r, n) {
      this._disposeAxisPointer(n), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(r, n, i) {
      var o = t.getAxisPointerClass(this.axisPointerClass);
      if (o) {
        var a = mxe(r);
        a ? (this._axisPointer || (this._axisPointer = new o())).render(r, a, n, i) : this._disposeAxisPointer(n);
      }
    }, t.prototype._disposeAxisPointer = function(r) {
      this._axisPointer && this._axisPointer.dispose(r), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(r, n) {
      if (process.env.NODE_ENV !== "production" && V1[r])
        throw new Error("axisPointer " + r + " exists");
      V1[r] = n;
    }, t.getAxisPointerClass = function(r) {
      return r && V1[r];
    }, t.type = "axis", t;
  }(Rr)
), N_ = Gt();
function x9(e, t, r, n) {
  var i = r.axis;
  if (!i.scale.isBlank()) {
    var o = r.getModel("splitArea"), a = o.getModel("areaStyle"), s = a.get("color"), l = n.coordinateSystem.getRect(), u = i.getTicksCoords({
      tickModel: o,
      clamp: !0
    });
    if (u.length) {
      var c = s.length, d = N_(e).splitAreaColors, h = We(), f = 0;
      if (d)
        for (var p = 0; p < u.length; p++) {
          var g = d.get(u[p].tickValue);
          if (g != null) {
            f = (g + (c - 1) * p) % c;
            break;
          }
        }
      var v = i.toGlobalCoord(u[0].coord), m = a.getAreaStyle();
      s = fe(s) ? s : [s];
      for (var p = 1; p < u.length; p++) {
        var y = i.toGlobalCoord(u[p].coord), C = void 0, S = void 0, b = void 0, w = void 0;
        i.isHorizontal() ? (C = v, S = l.y, b = y - C, w = l.height, v = C + b) : (C = l.x, S = v, b = l.width, w = y - S, v = S + w);
        var x = u[p - 1].tickValue;
        x != null && h.set(x, f), t.add(new Bt({
          anid: x != null ? "area_" + x : null,
          shape: {
            x: C,
            y: S,
            width: b,
            height: w
          },
          style: Xe({
            fill: s[f]
          }, m),
          autoBatch: !0,
          silent: !0
        })), f = (f + 1) % c;
      }
      N_(e).splitAreaColors = h;
    }
  }
}
function E9(e) {
  N_(e).splitAreaColors = null;
}
var yxe = ["axisLine", "axisTickLabel", "axisName"], Cxe = ["splitArea", "splitLine", "minorSplitLine"], R9 = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.axisPointerClass = "CartesianAxisPointer", r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this.group.removeAll();
      var a = this._axisGroup;
      if (this._axisGroup = new it(), this.group.add(this._axisGroup), !!r.get("show")) {
        var s = r.getCoordSysModel(), l = L_(s, r), u = new Ci(r, se({
          handleAutoShown: function(d) {
            for (var h = s.coordinateSystem.getCartesians(), f = 0; f < h.length; f++)
              if (R_(h[f].getOtherAxis(r.axis).scale))
                return !0;
            return !1;
          }
        }, l));
        B(yxe, u.add, u), this._axisGroup.add(u.getGroup()), B(Cxe, function(d) {
          r.get([d, "show"]) && Sxe[d](this, this._axisGroup, r, s);
        }, this);
        var c = o && o.type === "changeAxisOrder" && o.isInitSort;
        c || Fv(a, this._axisGroup, r), e.prototype.render.call(this, r, n, i, o);
      }
    }, t.prototype.remove = function() {
      E9(this);
    }, t.type = "cartesianAxis", t;
  }(Xc)
), Sxe = {
  splitLine: function(e, t, r, n) {
    var i = r.axis;
    if (!i.scale.isBlank()) {
      var o = r.getModel("splitLine"), a = o.getModel("lineStyle"), s = a.get("color");
      s = fe(s) ? s : [s];
      for (var l = n.coordinateSystem.getRect(), u = i.isHorizontal(), c = 0, d = i.getTicksCoords({
        tickModel: o
      }), h = [], f = [], p = a.getLineStyle(), g = 0; g < d.length; g++) {
        var v = i.toGlobalCoord(d[g].coord);
        u ? (h[0] = v, h[1] = l.y, f[0] = v, f[1] = l.y + l.height) : (h[0] = l.x, h[1] = v, f[0] = l.x + l.width, f[1] = v);
        var m = c++ % s.length, y = d[g].tickValue, C = new wn({
          anid: y != null ? "line_" + d[g].tickValue : null,
          autoBatch: !0,
          shape: {
            x1: h[0],
            y1: h[1],
            x2: f[0],
            y2: f[1]
          },
          style: Xe({
            stroke: s[m]
          }, p),
          silent: !0
        });
        Lh(C.shape, p.lineWidth), t.add(C);
      }
    }
  },
  minorSplitLine: function(e, t, r, n) {
    var i = r.axis, o = r.getModel("minorSplitLine"), a = o.getModel("lineStyle"), s = n.coordinateSystem.getRect(), l = i.isHorizontal(), u = i.getMinorTicksCoords();
    if (u.length)
      for (var c = [], d = [], h = a.getLineStyle(), f = 0; f < u.length; f++)
        for (var p = 0; p < u[f].length; p++) {
          var g = i.toGlobalCoord(u[f][p].coord);
          l ? (c[0] = g, c[1] = s.y, d[0] = g, d[1] = s.y + s.height) : (c[0] = s.x, c[1] = g, d[0] = s.x + s.width, d[1] = g);
          var v = new wn({
            anid: "minor_line_" + u[f][p].tickValue,
            autoBatch: !0,
            shape: {
              x1: c[0],
              y1: c[1],
              x2: d[0],
              y2: d[1]
            },
            style: h,
            silent: !0
          });
          Lh(v.shape, h.lineWidth), t.add(v);
        }
  },
  splitArea: function(e, t, r, n) {
    x9(e, t, r, n);
  }
}, _9 = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "xAxis", t;
  }(R9)
), wxe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = _9.type, r;
    }
    return t.type = "yAxis", t;
  }(R9)
), bxe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "grid", r;
    }
    return t.prototype.render = function(r, n) {
      this.group.removeAll(), r.get("show") && this.group.add(new Bt({
        shape: r.coordinateSystem.getRect(),
        style: Xe({
          fill: r.get("backgroundColor")
        }, r.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, t.type = "grid", t;
  }(Rr)
), Wk = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function T9(e) {
  e.registerComponentView(bxe), e.registerComponentModel(Z1e), e.registerCoordinateSystem("cartesian2d", ixe), Vh(e, "x", I_, Wk), Vh(e, "y", I_, Wk), e.registerComponentView(_9), e.registerComponentView(wxe), e.registerPreprocessor(function(t) {
    t.xAxis && t.yAxis && !t.grid && (t.grid = {});
  });
}
function xxe(e) {
  _t(T9), e.registerSeriesModel(j1e), e.registerChartView(q1e), e.registerLayout(Gv("scatter"));
}
function Exe(e) {
  e.eachSeriesByType("radar", function(t) {
    var r = t.getData(), n = [], i = t.coordinateSystem;
    if (i) {
      var o = i.getIndicatorAxes();
      B(o, function(a, s) {
        r.each(r.mapDimension(o[s].dim), function(l, u) {
          n[u] = n[u] || [];
          var c = i.dataToPoint(l, s);
          n[u][s] = jk(c) ? c : Uk(i);
        });
      }), r.each(function(a) {
        var s = U3(n[a], function(l) {
          return jk(l);
        }) || Uk(i);
        n[a].push(s.slice()), r.setItemLayout(a, n[a]);
      });
    }
  });
}
function jk(e) {
  return !isNaN(e[0]) && !isNaN(e[1]);
}
function Uk(e) {
  return [e.cx, e.cy];
}
function Rxe(e) {
  var t = e.polar;
  if (t) {
    fe(t) || (t = [t]);
    var r = [];
    B(t, function(n, i) {
      n.indicator ? (n.type && !n.shape && (n.shape = n.type), e.radar = e.radar || [], fe(e.radar) || (e.radar = [e.radar]), e.radar.push(n)) : r.push(n);
    }), e.polar = r;
  }
  B(e.series, function(n) {
    n && n.type === "radar" && n.polarIndex && (n.radarIndex = n.polarIndex);
  });
}
var _xe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.coordinateSystem, a = this.group, s = r.getData(), l = this._data;
      function u(h, f) {
        var p = h.getItemVisual(f, "symbol") || "circle";
        if (p !== "none") {
          var g = vf(h.getItemVisual(f, "symbolSize")), v = rn(p, -1, -1, 2, 2), m = h.getItemVisual(f, "symbolRotate") || 0;
          return v.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: g[0] / 2,
            scaleY: g[1] / 2,
            rotation: m * Math.PI / 180 || 0
          }), v;
        }
      }
      function c(h, f, p, g, v, m) {
        p.removeAll();
        for (var y = 0; y < f.length - 1; y++) {
          var C = u(g, v);
          C && (C.__dimIdx = y, h[y] ? (C.setPosition(h[y]), jc[m ? "initProps" : "updateProps"](C, {
            x: f[y][0],
            y: f[y][1]
          }, r, v)) : C.setPosition(f[y]), p.add(C));
        }
      }
      function d(h) {
        return ge(h, function(f) {
          return [o.cx, o.cy];
        });
      }
      s.diff(l).add(function(h) {
        var f = s.getItemLayout(h);
        if (f) {
          var p = new Ei(), g = new Ri(), v = {
            shape: {
              points: f
            }
          };
          p.shape.points = d(f), g.shape.points = d(f), Pr(p, v, r, h), Pr(g, v, r, h);
          var m = new it(), y = new it();
          m.add(g), m.add(p), m.add(y), c(g.shape.points, f, y, s, h, !0), s.setItemGraphicEl(h, m);
        }
      }).update(function(h, f) {
        var p = l.getItemGraphicEl(f), g = p.childAt(0), v = p.childAt(1), m = p.childAt(2), y = {
          shape: {
            points: s.getItemLayout(h)
          }
        };
        y.shape.points && (c(g.shape.points, y.shape.points, m, s, h, !1), Ca(v), Ca(g), jt(g, y, r), jt(v, y, r), s.setItemGraphicEl(h, p));
      }).remove(function(h) {
        a.remove(l.getItemGraphicEl(h));
      }).execute(), s.eachItemGraphicEl(function(h, f) {
        var p = s.getItemModel(f), g = h.childAt(0), v = h.childAt(1), m = h.childAt(2), y = s.getItemVisual(f, "style"), C = y.fill;
        a.add(h), g.useStyle(Xe(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: C
        })), Bn(g, p, "lineStyle"), Bn(v, p, "areaStyle");
        var S = p.getModel("areaStyle"), b = S.isEmpty() && S.parentModel.isEmpty();
        v.ignore = b, B(["emphasis", "select", "blur"], function(E) {
          var R = p.getModel([E, "areaStyle"]), _ = R.isEmpty() && R.parentModel.isEmpty();
          v.ensureState(E).ignore = _ && b;
        }), v.useStyle(Xe(S.getAreaStyle(), {
          fill: C,
          opacity: 0.7,
          decal: y.decal
        }));
        var w = p.getModel("emphasis"), x = w.getModel("itemStyle").getItemStyle();
        m.eachChild(function(E) {
          if (E instanceof In) {
            var R = E.style;
            E.useStyle(se({
              // TODO other properties like x, y ?
              image: R.image,
              x: R.x,
              y: R.y,
              width: R.width,
              height: R.height
            }, y));
          } else
            E.useStyle(y), E.setColor(C), E.style.strokeNoScale = !0;
          var _ = E.ensureState("emphasis");
          _.style = et(x);
          var P = s.getStore().get(s.getDimensionIndex(E.__dimIdx), f);
          (P == null || isNaN(P)) && (P = ""), Gn(E, Rn(p), {
            labelFetcher: s.hostModel,
            labelDataIndex: f,
            labelDimIndex: E.__dimIdx,
            defaultText: P,
            inheritColor: C,
            defaultOpacity: y.opacity
          });
        }), Hr(h, w.get("focus"), w.get("blurScope"), w.get("disabled"));
      }), this._data = s;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "radar", t;
  }(ar)
), Txe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments), this.legendVisualProvider = new zv(ke(this.getData, this), ke(this.getRawData, this));
    }, t.prototype.getInitialData = function(r, n) {
      return Sf(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = this.coordinateSystem, s = a.getIndicatorAxes(), l = this.getData().getName(r), u = l === "" ? this.name : l, c = EW(this, r);
      return _n("section", {
        header: u,
        sortBlocks: !0,
        blocks: ge(s, function(d) {
          var h = o.get(o.mapDimension(d.dim), r);
          return _n("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: d.name,
            value: h,
            sortParam: h
          });
        })
      });
    }, t.prototype.getTooltipPosition = function(r) {
      if (r != null) {
        for (var n = this.getData(), i = this.coordinateSystem, o = n.getValues(ge(i.dimensions, function(u) {
          return n.mapDimension(u);
        }), r), a = 0, s = o.length; a < s; a++)
          if (!isNaN(o[a])) {
            var l = i.getIndicatorAxes();
            return i.coordToPoint(l[a].dataToCoord(o[a]), a);
          }
      }
    }, t.type = "series.radar", t.dependencies = ["radar"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, t;
  }(hr)
), lp = S9.value;
function ly(e, t) {
  return Xe({
    show: t
  }, e);
}
var Pxe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.optionUpdated = function() {
      var r = this.get("boundaryGap"), n = this.get("splitNumber"), i = this.get("scale"), o = this.get("axisLine"), a = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), c = this.get(["axisName", "formatter"]), d = this.get("axisNameGap"), h = this.get("triggerEvent"), f = ge(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var g = l;
        p.color != null && (g = Xe({
          color: p.color
        }, l));
        var v = yt(et(p), {
          boundaryGap: r,
          splitNumber: n,
          scale: i,
          axisLine: o,
          axisTick: a,
          // axisType: axisType,
          axisLabel: s,
          // Compatible with 2 and use text
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: d,
          // min: 0,
          nameTextStyle: g,
          triggerEvent: h
        }, !1);
        if (Fe(c)) {
          var m = v.name;
          v.name = c.replace("{value}", m ?? "");
        } else Ye(c) && (v.name = c(v.name, v));
        var y = new cr(v, null, this.ecModel);
        return qr(y, Cf.prototype), y.mainType = "radar", y.componentIndex = this.componentIndex, y;
      }, this);
      this._indicatorModels = f;
    }, t.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, t.type = "radar", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: !0
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: yt({
        lineStyle: {
          color: "#bbb"
        }
      }, lp.axisLine),
      axisLabel: ly(lp.axisLabel, !1),
      axisTick: ly(lp.axisTick, !1),
      // axisType: 'value',
      splitLine: ly(lp.splitLine, !0),
      splitArea: ly(lp.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, t;
  }(Rt)
), Mxe = ["axisLine", "axisTickLabel", "axisName"], Dxe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = this.group;
      o.removeAll(), this._buildAxes(r), this._buildSplitLineAndArea(r);
    }, t.prototype._buildAxes = function(r) {
      var n = r.coordinateSystem, i = n.getIndicatorAxes(), o = ge(i, function(a) {
        var s = a.model.get("showName") ? a.name : "", l = new Ci(a.model, {
          axisName: s,
          position: [n.cx, n.cy],
          rotation: a.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      B(o, function(a) {
        B(Mxe, a.add, a), this.group.add(a.getGroup());
      }, this);
    }, t.prototype._buildSplitLineAndArea = function(r) {
      var n = r.coordinateSystem, i = n.getIndicatorAxes();
      if (!i.length)
        return;
      var o = r.get("shape"), a = r.getModel("splitLine"), s = r.getModel("splitArea"), l = a.getModel("lineStyle"), u = s.getModel("areaStyle"), c = a.get("show"), d = s.get("show"), h = l.get("color"), f = u.get("color"), p = fe(h) ? h : [h], g = fe(f) ? f : [f], v = [], m = [];
      function y(O, L, N) {
        var F = N % L.length;
        return O[F] = O[F] || [], F;
      }
      if (o === "circle")
        for (var C = i[0].getTicksCoords(), S = n.cx, b = n.cy, w = 0; w < C.length; w++) {
          if (c) {
            var x = y(v, p, w);
            v[x].push(new Js({
              shape: {
                cx: S,
                cy: b,
                r: C[w].coord
              }
            }));
          }
          if (d && w < C.length - 1) {
            var x = y(m, g, w);
            m[x].push(new Dv({
              shape: {
                cx: S,
                cy: b,
                r0: C[w].coord,
                r: C[w + 1].coord
              }
            }));
          }
        }
      else
        for (var E, R = ge(i, function(O, L) {
          var N = O.getTicksCoords();
          return E = E == null ? N.length - 1 : Math.min(N.length - 1, E), ge(N, function(F) {
            return n.coordToPoint(F.coord, L);
          });
        }), _ = [], w = 0; w <= E; w++) {
          for (var P = [], D = 0; D < i.length; D++)
            P.push(R[D][w]);
          if (P[0] ? P.push(P[0].slice()) : process.env.NODE_ENV !== "production" && console.error("Can't draw value axis " + w), c) {
            var x = y(v, p, w);
            v[x].push(new Ri({
              shape: {
                points: P
              }
            }));
          }
          if (d && _) {
            var x = y(m, g, w - 1);
            m[x].push(new Ei({
              shape: {
                points: P.concat(_)
              }
            }));
          }
          _ = P.slice().reverse();
        }
      var I = l.getLineStyle(), A = u.getAreaStyle();
      B(m, function(O, L) {
        this.group.add(Zi(O, {
          style: Xe({
            stroke: "none",
            fill: g[L % g.length]
          }, A),
          silent: !0
        }));
      }, this), B(v, function(O, L) {
        this.group.add(Zi(O, {
          style: Xe({
            fill: "none",
            stroke: p[L % p.length]
          }, I),
          silent: !0
        }));
      }, this);
    }, t.type = "radar", t;
  }(Rr)
), Axe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i) {
      var o = e.call(this, r, n, i) || this;
      return o.type = "value", o.angle = 0, o.name = "", o;
    }
    return t;
  }(Wo)
), Ixe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.dimensions = [], this._model = t, this._indicatorAxes = ge(t.getIndicatorModels(), function(i, o) {
        var a = "indicator_" + o, s = new Axe(
          a,
          new Us()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return s.name = i.get("name"), s.model = i, i.axis = s, this.dimensions.push(a), s;
      }, this), this.resize(t, n);
    }
    return e.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, e.prototype.dataToPoint = function(t, r) {
      var n = this._indicatorAxes[r];
      return this.coordToPoint(n.dataToCoord(t), r);
    }, e.prototype.coordToPoint = function(t, r) {
      var n = this._indicatorAxes[r], i = n.angle, o = this.cx + t * Math.cos(i), a = this.cy - t * Math.sin(i);
      return [o, a];
    }, e.prototype.pointToData = function(t) {
      var r = t[0] - this.cx, n = t[1] - this.cy, i = Math.sqrt(r * r + n * n);
      r /= i, n /= i;
      for (var o = Math.atan2(-n, r), a = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], d = Math.abs(o - c.angle);
        d < a && (s = c, l = u, a = d);
      }
      return [l, +(s && s.coordToData(i))];
    }, e.prototype.resize = function(t, r) {
      var n = t.get("center"), i = r.getWidth(), o = r.getHeight(), a = Math.min(i, o) / 2;
      this.cx = Ae(n[0], i), this.cy = Ae(n[1], o), this.startAngle = t.get("startAngle") * Math.PI / 180;
      var s = t.get("radius");
      (Fe(s) || $t(s)) && (s = [0, s]), this.r0 = Ae(s[0], a), this.r = Ae(s[1], a), B(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var c = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        c = Math.atan2(Math.sin(c), Math.cos(c)), l.angle = c;
      }, this);
    }, e.prototype.update = function(t, r) {
      var n = this._indicatorAxes, i = this._model;
      B(n, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), t.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || t.getComponent("radar", s.get("radarIndex")) !== i)) {
          var u = s.getData();
          B(n, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var o = i.get("splitNumber"), a = new Us();
      a.setExtent(0, o), a.setInterval(1), B(n, function(s, l) {
        w9(s.scale, s.model, a);
      });
    }, e.prototype.convertToPixel = function(t, r, n) {
      return console.warn("Not implemented."), null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      return console.warn("Not implemented."), null;
    }, e.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), !1;
    }, e.create = function(t, r) {
      var n = [];
      return t.eachComponent("radar", function(i) {
        var o = new e(i, t, r);
        n.push(o), i.coordinateSystem = o;
      }), t.eachSeriesByType("radar", function(i) {
        i.get("coordinateSystem") === "radar" && (i.coordinateSystem = n[i.get("radarIndex") || 0]);
      }), n;
    }, e.dimensions = [], e;
  }()
);
function Fxe(e) {
  e.registerCoordinateSystem("radar", Ixe), e.registerComponentModel(Pxe), e.registerComponentView(Dxe), e.registerVisual({
    seriesType: "radar",
    reset: function(t) {
      var r = t.getData();
      r.each(function(n) {
        r.setItemVisual(n, "legendIcon", "roundRect");
      }), r.setVisual("legendIcon", "roundRect");
    }
  });
}
function Lxe(e) {
  _t(Fxe), e.registerChartView(_xe), e.registerSeriesModel(Txe), e.registerLayout(Exe), e.registerProcessor(Hv("radar")), e.registerPreprocessor(Rxe);
}
var Kk = "\0_ec_interaction_mutex";
function Oxe(e, t, r) {
  var n = yD(e);
  n[t] = r;
}
function Nxe(e, t, r) {
  var n = yD(e), i = n[t];
  i === r && (n[t] = null);
}
function Yk(e, t) {
  return !!yD(e)[t];
}
function yD(e) {
  return e[Kk] || (e[Kk] = {});
}
wa({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, Kr);
var $v = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this) || this;
      n._zr = r;
      var i = ke(n._mousedownHandler, n), o = ke(n._mousemoveHandler, n), a = ke(n._mouseupHandler, n), s = ke(n._mousewheelHandler, n), l = ke(n._pinchHandler, n);
      return n.enable = function(u, c) {
        this.disable(), this._opt = Xe(et(c) || {}, {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0
        }), u == null && (u = !0), (u === !0 || u === "move" || u === "pan") && (r.on("mousedown", i), r.on("mousemove", o), r.on("mouseup", a)), (u === !0 || u === "scale" || u === "zoom") && (r.on("mousewheel", s), r.on("pinch", l));
      }, n.disable = function() {
        r.off("mousedown", i), r.off("mousemove", o), r.off("mouseup", a), r.off("mousewheel", s), r.off("pinch", l);
      }, n;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype.setPointerChecker = function(r) {
      this.pointerChecker = r;
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(r) {
      if (!bL(r)) {
        for (var n = r.target; n; ) {
          if (n.draggable)
            return;
          n = n.__hostTarget || n.parent;
        }
        var i = r.offsetX, o = r.offsetY;
        this.pointerChecker && this.pointerChecker(r, i, o) && (this._x = i, this._y = o, this._dragging = !0);
      }
    }, t.prototype._mousemoveHandler = function(r) {
      if (!(!this._dragging || !l0("moveOnMouseMove", r, this._opt) || r.gestureEvent === "pinch" || Yk(this._zr, "globalPan"))) {
        var n = r.offsetX, i = r.offsetY, o = this._x, a = this._y, s = n - o, l = i - a;
        this._x = n, this._y = i, this._opt.preventDefaultMouseMove && Hs(r.event), P9(this, "pan", "moveOnMouseMove", r, {
          dx: s,
          dy: l,
          oldX: o,
          oldY: a,
          newX: n,
          newY: i,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(r) {
      bL(r) || (this._dragging = !1);
    }, t.prototype._mousewheelHandler = function(r) {
      var n = l0("zoomOnMouseWheel", r, this._opt), i = l0("moveOnMouseWheel", r, this._opt), o = r.wheelDelta, a = Math.abs(o), s = r.offsetX, l = r.offsetY;
      if (!(o === 0 || !n && !i)) {
        if (n) {
          var u = a > 3 ? 1.4 : a > 1 ? 1.2 : 1.1, c = o > 0 ? u : 1 / u;
          B1(this, "zoom", "zoomOnMouseWheel", r, {
            scale: c,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (i) {
          var d = Math.abs(o), h = (o > 0 ? 1 : -1) * (d > 3 ? 0.4 : d > 1 ? 0.15 : 0.05);
          B1(this, "scrollMove", "moveOnMouseWheel", r, {
            scrollDelta: h,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, t.prototype._pinchHandler = function(r) {
      if (!Yk(this._zr, "globalPan")) {
        var n = r.pinchScale > 1 ? 1.1 : 1 / 1.1;
        B1(this, "zoom", null, r, {
          scale: n,
          originX: r.pinchX,
          originY: r.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t;
  }(Go)
);
function B1(e, t, r, n, i) {
  e.pointerChecker && e.pointerChecker(n, i.originX, i.originY) && (Hs(n.event), P9(e, t, r, n, i));
}
function P9(e, t, r, n, i) {
  i.isAvailableBehavior = ke(l0, null, r, n), e.trigger(t, i);
}
function l0(e, t, r) {
  var n = r[e];
  return !e || n && (!Fe(n) || t.event[n + "Key"]);
}
function CD(e, t, r) {
  var n = e.target;
  n.x += t, n.y += r, n.dirty();
}
function SD(e, t, r, n) {
  var i = e.target, o = e.zoomLimit, a = e.zoom = e.zoom || 1;
  if (a *= t, o) {
    var s = o.min || 0, l = o.max || 1 / 0;
    a = Math.max(Math.min(l, a), s);
  }
  var u = a / e.zoom;
  e.zoom = a, i.x -= (r - i.x) * (u - 1), i.y -= (n - i.y) * (u - 1), i.scaleX *= u, i.scaleY *= u, i.dirty();
}
var kxe = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function ow(e, t, r) {
  var n = t.getComponentByElement(e.topTarget), i = n && n.coordinateSystem;
  return n && n !== r && !kxe.hasOwnProperty(n.mainType) && i && i.model !== r;
}
function M9(e) {
  if (Fe(e)) {
    var t = new DOMParser();
    e = t.parseFromString(e, "text/xml");
  }
  var r = e;
  for (r.nodeType === 9 && (r = r.firstChild); r.nodeName.toLowerCase() !== "svg" || r.nodeType !== 1; )
    r = r.nextSibling;
  return r;
}
var G1, CC = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, qk = At(CC), SC = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, Zk = At(SC), Vxe = function() {
  function e() {
    this._defs = {}, this._root = null;
  }
  return e.prototype.parse = function(t, r) {
    r = r || {};
    var n = M9(t);
    if (process.env.NODE_ENV !== "production" && !n)
      throw new Error("Illegal svg");
    this._defsUsePending = [];
    var i = new it();
    this._root = i;
    var o = [], a = n.getAttribute("viewBox") || "", s = parseFloat(n.getAttribute("width") || r.width), l = parseFloat(n.getAttribute("height") || r.height);
    isNaN(s) && (s = null), isNaN(l) && (l = null), $i(n, i, null, !0, !1);
    for (var u = n.firstChild; u; )
      this._parseNode(u, i, o, null, !1, !1), u = u.nextSibling;
    Hxe(this._defs, this._defsUsePending), this._defsUsePending = [];
    var c, d;
    if (a) {
      var h = aw(a);
      h.length >= 4 && (c = {
        x: parseFloat(h[0] || 0),
        y: parseFloat(h[1] || 0),
        width: parseFloat(h[2]),
        height: parseFloat(h[3])
      });
    }
    if (c && s != null && l != null && (d = A9(c, { x: 0, y: 0, width: s, height: l }), !r.ignoreViewBox)) {
      var f = i;
      i = new it(), i.add(f), f.scaleX = f.scaleY = d.scale, f.x = d.x, f.y = d.y;
    }
    return !r.ignoreRootClip && s != null && l != null && i.setClipPath(new Bt({
      shape: { x: 0, y: 0, width: s, height: l }
    })), {
      root: i,
      width: s,
      height: l,
      viewBoxRect: c,
      viewBoxTransform: d,
      named: o
    };
  }, e.prototype._parseNode = function(t, r, n, i, o, a) {
    var s = t.nodeName.toLowerCase(), l, u = i;
    if (s === "defs" && (o = !0), s === "text" && (a = !0), s === "defs" || s === "switch")
      l = r;
    else {
      if (!o) {
        var c = G1[s];
        if (c && Be(G1, s)) {
          l = c.call(this, t, r);
          var d = t.getAttribute("name");
          if (d) {
            var h = {
              name: d,
              namedFrom: null,
              svgNodeTagLower: s,
              el: l
            };
            n.push(h), s === "g" && (u = h);
          } else i && n.push({
            name: i.name,
            namedFrom: i,
            svgNodeTagLower: s,
            el: l
          });
          r.add(l);
        }
      }
      var f = Xk[s];
      if (f && Be(Xk, s)) {
        var p = f.call(this, t), g = t.getAttribute("id");
        g && (this._defs[g] = p);
      }
    }
    if (l && l.isGroup)
      for (var v = t.firstChild; v; )
        v.nodeType === 1 ? this._parseNode(v, l, n, u, o, a) : v.nodeType === 3 && a && this._parseText(v, l), v = v.nextSibling;
  }, e.prototype._parseText = function(t, r) {
    var n = new Fh({
      style: {
        text: t.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    po(r, n), $i(t, n, this._defsUsePending, !1, !1), Bxe(n, r);
    var i = n.style, o = i.fontSize;
    o && o < 9 && (i.fontSize = 9, n.scaleX *= o / 9, n.scaleY *= o / 9);
    var a = (i.fontSize || i.fontFamily) && [
      i.fontStyle,
      i.fontWeight,
      (i.fontSize || 12) + "px",
      i.fontFamily || "sans-serif"
    ].join(" ");
    i.font = a;
    var s = n.getBoundingRect();
    return this._textX += s.width, r.add(n), n;
  }, e.internalField = function() {
    G1 = {
      g: function(t, r) {
        var n = new it();
        return po(r, n), $i(t, n, this._defsUsePending, !1, !1), n;
      },
      rect: function(t, r) {
        var n = new Bt();
        return po(r, n), $i(t, n, this._defsUsePending, !1, !1), n.setShape({
          x: parseFloat(t.getAttribute("x") || "0"),
          y: parseFloat(t.getAttribute("y") || "0"),
          width: parseFloat(t.getAttribute("width") || "0"),
          height: parseFloat(t.getAttribute("height") || "0")
        }), n.silent = !0, n;
      },
      circle: function(t, r) {
        var n = new Js();
        return po(r, n), $i(t, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(t.getAttribute("cx") || "0"),
          cy: parseFloat(t.getAttribute("cy") || "0"),
          r: parseFloat(t.getAttribute("r") || "0")
        }), n.silent = !0, n;
      },
      line: function(t, r) {
        var n = new wn();
        return po(r, n), $i(t, n, this._defsUsePending, !1, !1), n.setShape({
          x1: parseFloat(t.getAttribute("x1") || "0"),
          y1: parseFloat(t.getAttribute("y1") || "0"),
          x2: parseFloat(t.getAttribute("x2") || "0"),
          y2: parseFloat(t.getAttribute("y2") || "0")
        }), n.silent = !0, n;
      },
      ellipse: function(t, r) {
        var n = new kS();
        return po(r, n), $i(t, n, this._defsUsePending, !1, !1), n.setShape({
          cx: parseFloat(t.getAttribute("cx") || "0"),
          cy: parseFloat(t.getAttribute("cy") || "0"),
          rx: parseFloat(t.getAttribute("rx") || "0"),
          ry: parseFloat(t.getAttribute("ry") || "0")
        }), n.silent = !0, n;
      },
      polygon: function(t, r) {
        var n = t.getAttribute("points"), i;
        n && (i = eV(n));
        var o = new Ei({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return po(r, o), $i(t, o, this._defsUsePending, !1, !1), o;
      },
      polyline: function(t, r) {
        var n = t.getAttribute("points"), i;
        n && (i = eV(n));
        var o = new Ri({
          shape: {
            points: i || []
          },
          silent: !0
        });
        return po(r, o), $i(t, o, this._defsUsePending, !1, !1), o;
      },
      image: function(t, r) {
        var n = new In();
        return po(r, n), $i(t, n, this._defsUsePending, !1, !1), n.setStyle({
          image: t.getAttribute("xlink:href") || t.getAttribute("href"),
          x: +t.getAttribute("x"),
          y: +t.getAttribute("y"),
          width: +t.getAttribute("width"),
          height: +t.getAttribute("height")
        }), n.silent = !0, n;
      },
      text: function(t, r) {
        var n = t.getAttribute("x") || "0", i = t.getAttribute("y") || "0", o = t.getAttribute("dx") || "0", a = t.getAttribute("dy") || "0";
        this._textX = parseFloat(n) + parseFloat(o), this._textY = parseFloat(i) + parseFloat(a);
        var s = new it();
        return po(r, s), $i(t, s, this._defsUsePending, !1, !0), s;
      },
      tspan: function(t, r) {
        var n = t.getAttribute("x"), i = t.getAttribute("y");
        n != null && (this._textX = parseFloat(n)), i != null && (this._textY = parseFloat(i));
        var o = t.getAttribute("dx") || "0", a = t.getAttribute("dy") || "0", s = new it();
        return po(r, s), $i(t, s, this._defsUsePending, !1, !0), this._textX += parseFloat(o), this._textY += parseFloat(a), s;
      },
      path: function(t, r) {
        var n = t.getAttribute("d") || "", i = f6(n);
        return po(r, i), $i(t, i, this._defsUsePending, !1, !1), i.silent = !0, i;
      }
    };
  }(), e;
}(), Xk = {
  lineargradient: function(e) {
    var t = parseInt(e.getAttribute("x1") || "0", 10), r = parseInt(e.getAttribute("y1") || "0", 10), n = parseInt(e.getAttribute("x2") || "10", 10), i = parseInt(e.getAttribute("y2") || "0", 10), o = new af(t, r, n, i);
    return Qk(e, o), Jk(e, o), o;
  },
  radialgradient: function(e) {
    var t = parseInt(e.getAttribute("cx") || "0", 10), r = parseInt(e.getAttribute("cy") || "0", 10), n = parseInt(e.getAttribute("r") || "0", 10), i = new CM(t, r, n);
    return Qk(e, i), Jk(e, i), i;
  }
};
function Qk(e, t) {
  var r = e.getAttribute("gradientUnits");
  r === "userSpaceOnUse" && (t.global = !0);
}
function Jk(e, t) {
  for (var r = e.firstChild; r; ) {
    if (r.nodeType === 1 && r.nodeName.toLocaleLowerCase() === "stop") {
      var n = r.getAttribute("offset"), i = void 0;
      n && n.indexOf("%") > 0 ? i = parseInt(n, 10) / 100 : n ? i = parseFloat(n) : i = 0;
      var o = {};
      D9(r, o, o);
      var a = o.stopColor || r.getAttribute("stop-color") || "#000000";
      t.colorStops.push({
        offset: i,
        color: a
      });
    }
    r = r.nextSibling;
  }
}
function po(e, t) {
  e && e.__inheritedStyle && (t.__inheritedStyle || (t.__inheritedStyle = {}), Xe(t.__inheritedStyle, e.__inheritedStyle));
}
function eV(e) {
  for (var t = aw(e), r = [], n = 0; n < t.length; n += 2) {
    var i = parseFloat(t[n]), o = parseFloat(t[n + 1]);
    r.push([i, o]);
  }
  return r;
}
function $i(e, t, r, n, i) {
  var o = t, a = o.__inheritedStyle = o.__inheritedStyle || {}, s = {};
  e.nodeType === 1 && (Wxe(e, t), D9(e, a, s), n || jxe(e, a, s)), o.style = o.style || {}, a.fill != null && (o.style.fill = tV(o, "fill", a.fill, r)), a.stroke != null && (o.style.stroke = tV(o, "stroke", a.stroke, r)), B([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(l) {
    a[l] != null && (o.style[l] = parseFloat(a[l]));
  }), B([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(l) {
    a[l] != null && (o.style[l] = a[l]);
  }), i && (o.__selfStyle = s), a.lineDash && (o.style.lineDash = ge(aw(a.lineDash), function(l) {
    return parseFloat(l);
  })), (a.visibility === "hidden" || a.visibility === "collapse") && (o.invisible = !0), a.display === "none" && (o.ignore = !0);
}
function Bxe(e, t) {
  var r = t.__selfStyle;
  if (r) {
    var n = r.textBaseline, i = n;
    !n || n === "auto" || n === "baseline" ? i = "alphabetic" : n === "before-edge" || n === "text-before-edge" ? i = "top" : n === "after-edge" || n === "text-after-edge" ? i = "bottom" : (n === "central" || n === "mathematical") && (i = "middle"), e.style.textBaseline = i;
  }
  var o = t.__inheritedStyle;
  if (o) {
    var a = o.textAlign, s = a;
    a && (a === "middle" && (s = "center"), e.style.textAlign = s);
  }
}
var Gxe = /^url\(\s*#(.*?)\)/;
function tV(e, t, r, n) {
  var i = r && r.match(Gxe);
  if (i) {
    var o = _o(i[1]);
    n.push([e, t, o]);
    return;
  }
  return r === "none" && (r = null), r;
}
function Hxe(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    n[0].style[n[1]] = e[n[2]];
  }
}
var zxe = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function aw(e) {
  return e.match(zxe) || [];
}
var $xe = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, H1 = Math.PI / 180;
function Wxe(e, t) {
  var r = e.getAttribute("transform");
  if (r) {
    r = r.replace(/,/g, " ");
    var n = [], i = null;
    r.replace($xe, function(d, h, f) {
      return n.push(h, f), "";
    });
    for (var o = n.length - 1; o > 0; o -= 2) {
      var a = n[o], s = n[o - 1], l = aw(a);
      switch (i = i || ki(), s) {
        case "translate":
          ma(i, i, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
          break;
        case "scale":
          RS(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
          break;
        case "rotate":
          nu(i, i, -parseFloat(l[0]) * H1, [
            parseFloat(l[1] || "0"),
            parseFloat(l[2] || "0")
          ]);
          break;
        case "skewX":
          var u = Math.tan(parseFloat(l[0]) * H1);
          Ka(i, [1, 0, u, 1, 0, 0], i);
          break;
        case "skewY":
          var c = Math.tan(parseFloat(l[0]) * H1);
          Ka(i, [1, c, 0, 1, 0, 0], i);
          break;
        case "matrix":
          i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]);
          break;
      }
    }
    t.setLocalTransform(i);
  }
}
var rV = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function D9(e, t, r) {
  var n = e.getAttribute("style");
  if (n) {
    rV.lastIndex = 0;
    for (var i; (i = rV.exec(n)) != null; ) {
      var o = i[1], a = Be(CC, o) ? CC[o] : null;
      a && (t[a] = i[2]);
      var s = Be(SC, o) ? SC[o] : null;
      s && (r[s] = i[2]);
    }
  }
}
function jxe(e, t, r) {
  for (var n = 0; n < qk.length; n++) {
    var i = qk[n], o = e.getAttribute(i);
    o != null && (t[CC[i]] = o);
  }
  for (var n = 0; n < Zk.length; n++) {
    var i = Zk[n], o = e.getAttribute(i);
    o != null && (r[SC[i]] = o);
  }
}
function A9(e, t) {
  var r = t.width / e.width, n = t.height / e.height, i = Math.min(r, n);
  return {
    scale: i,
    x: -(e.x + e.width / 2) * i + (t.x + t.width / 2),
    y: -(e.y + e.height / 2) * i + (t.y + t.height / 2)
  };
}
function Uxe(e, t) {
  var r = new Vxe();
  return r.parse(e, t);
}
var Kxe = We([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), Yxe = (
  /** @class */
  function() {
    function e(t, r) {
      this.type = "geoSVG", this._usedGraphicMap = We(), this._freedGraphics = [], this._mapName = t, this._parsedXML = M9(r);
    }
    return e.prototype.load = function() {
      var t = this._firstGraphic;
      if (!t) {
        t = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(t), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var r = Zxe(t.named), n = r.regions, i = r.regionsMap;
        this._regions = n, this._regionsMap = i;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, e.prototype._buildGraphic = function(t) {
      var r, n;
      try {
        r = t && Uxe(t, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, n = r.root, Qe(n != null);
      } catch (v) {
        throw new Error(`Invalid svg format
` + v.message);
      }
      var i = new it();
      i.add(n), i.isGeoSVGGraphicRoot = !0;
      var o = r.width, a = r.height, s = r.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, d = void 0, h = void 0;
        if (o != null ? (u = 0, d = o) : s && (u = s.x, d = s.width), a != null ? (c = 0, h = a) : s && (c = s.y, h = s.height), u == null || c == null) {
          var f = n.getBoundingRect();
          u == null && (u = f.x, d = f.width), c == null && (c = f.y, h = f.height);
        }
        l = this._boundingRect = new St(u, c, d, h);
      }
      if (s) {
        var p = A9(s, l);
        n.scaleX = n.scaleY = p.scale, n.x = p.x, n.y = p.y;
      }
      i.setClipPath(new Bt({
        shape: l.plain()
      }));
      var g = [];
      return B(r.named, function(v) {
        Kxe.get(v.svgNodeTagLower) != null && (g.push(v), qxe(v.el));
      }), {
        root: i,
        boundingRect: l,
        named: g
      };
    }, e.prototype.useGraphic = function(t) {
      var r = this._usedGraphicMap, n = r.get(t);
      return n || (n = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), r.set(t, n), n);
    }, e.prototype.freeGraphic = function(t) {
      var r = this._usedGraphicMap, n = r.get(t);
      n && (r.removeKey(t), this._freedGraphics.push(n));
    }, e;
  }()
);
function qxe(e) {
  e.silent = !1, e.isGroup && e.traverse(function(t) {
    t.silent = !1;
  });
}
function Zxe(e) {
  var t = [], r = We();
  return B(e, function(n) {
    if (n.namedFrom == null) {
      var i = new Owe(n.name, n.el);
      t.push(i), r.set(n.name, i);
    }
  }), {
    regions: t,
    regionsMap: r
  };
}
var k_ = [126, 25], nV = "南海诸岛", Vu = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var Lu = 0; Lu < Vu.length; Lu++)
  for (var Dd = 0; Dd < Vu[Lu].length; Dd++)
    Vu[Lu][Dd][0] /= 10.5, Vu[Lu][Dd][1] /= -10.5 / 0.75, Vu[Lu][Dd][0] += k_[0], Vu[Lu][Dd][1] += k_[1];
function Xxe(e, t) {
  if (e === "china") {
    for (var r = 0; r < t.length; r++)
      if (t[r].name === nV)
        return;
    t.push(new T7(nV, ge(Vu, function(n) {
      return {
        type: "polygon",
        exterior: n
      };
    }), k_));
  }
}
var Qxe = {
  南海诸岛: [32, 80],
  // 全国
  广东: [0, -10],
  香港: [10, 5],
  澳门: [-10, 10],
  // '北京': [-10, 0],
  天津: [5, 5]
};
function Jxe(e, t) {
  if (e === "china") {
    var r = Qxe[t.name];
    if (r) {
      var n = t.getCenter();
      n[0] += r[0] / 10.5, n[1] += -r[1] / (10.5 / 0.75), t.setCenter(n);
    }
  }
}
var eEe = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function tEe(e, t) {
  e === "china" && t.name === "台湾" && t.geometries.push({
    type: "polygon",
    exterior: eEe[0]
  });
}
var rEe = "name", nEe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "geoJSON", this._parsedMap = We(), this._mapName = t, this._specialAreas = n, this._geoJSON = oEe(r);
    }
    return e.prototype.load = function(t, r) {
      r = r || rEe;
      var n = this._parsedMap.get(r);
      if (!n) {
        var i = this._parseToRegions(r);
        n = this._parsedMap.set(r, {
          regions: i,
          boundingRect: iEe(i)
        });
      }
      var o = We(), a = [];
      return B(n.regions, function(s) {
        var l = s.name;
        t && Be(t, l) && (s = s.cloneShallow(l = t[l])), a.push(s), o.set(l, s);
      }), {
        regions: a,
        boundingRect: n.boundingRect || new St(0, 0, 0, 0),
        regionsMap: o
      };
    }, e.prototype._parseToRegions = function(t) {
      var r = this._mapName, n = this._geoJSON, i;
      try {
        i = n ? T_(n, t) : [];
      } catch (o) {
        throw new Error(`Invalid geoJson format
` + o.message);
      }
      return Xxe(r, i), B(i, function(o) {
        var a = o.name;
        Jxe(r, o), tEe(r, o);
        var s = this._specialAreas && this._specialAreas[a];
        s && o.transformTo(s.left, s.top, s.width, s.height);
      }, this), i;
    }, e.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, e;
  }()
);
function iEe(e) {
  for (var t, r = 0; r < e.length; r++) {
    var n = e[r].getBoundingRect();
    t = t || n.clone(), t.union(n);
  }
  return t;
}
function oEe(e) {
  return Fe(e) ? typeof JSON < "u" && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")() : e;
}
var up = We();
const Ks = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(e, t, r) {
    if (t.svg) {
      var n = new Yxe(e, t.svg);
      up.set(e, n);
    } else {
      var i = t.geoJson || t.geoJSON;
      i && !t.features ? r = t.specialAreas : i = t;
      var n = new nEe(e, i, r);
      up.set(e, n);
    }
  },
  getGeoResource: function(e) {
    return up.get(e);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(e) {
    var t = up.get(e);
    return t && t.type === "geoJSON" && t.getMapForUser();
  },
  load: function(e, t, r) {
    var n = up.get(e);
    if (!n) {
      process.env.NODE_ENV !== "production" && console.error("Map " + e + " not exists. The GeoJSON of the map must be provided.");
      return;
    }
    return n.load(t, r);
  }
};
var wD = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], aEe = We(wD), sEe = We(wD.concat(["g"])), lEe = We(wD.concat(["g"])), I9 = Gt();
function uy(e) {
  var t = e.getItemStyle(), r = e.get("areaColor");
  return r != null && (t.fill = r), t;
}
function iV(e) {
  var t = e.style;
  t && (t.stroke = t.stroke || t.fill, t.fill = null);
}
var F9 = (
  /** @class */
  function() {
    function e(t) {
      var r = new it();
      this.uid = df("ec_map_draw"), this._controller = new $v(t.getZr()), this._controllerHost = {
        target: r
      }, this.group = r, r.add(this._regionsGroup = new it()), r.add(this._svgGroup = new it());
    }
    return e.prototype.draw = function(t, r, n, i, o) {
      var a = t.mainType === "geo", s = t.getData && t.getData();
      a && r.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(m) {
        !s && m.getHostGeoModel() === t && (s = m.getData());
      });
      var l = t.coordinateSystem, u = this._regionsGroup, c = this.group, d = l.getTransformInfo(), h = d.raw, f = d.roam, p = !u.childAt(0) || o;
      p ? (c.x = f.x, c.y = f.y, c.scaleX = f.scaleX, c.scaleY = f.scaleY, c.dirty()) : jt(c, f, t);
      var g = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, v = {
        api: n,
        geo: l,
        mapOrGeoModel: t,
        data: s,
        isVisualEncodedByVisualMap: g,
        isGeo: a,
        transformInfoRaw: h
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(v) : l.resourceType === "geoSVG" && this._buildSVG(v), this._updateController(t, r, n), this._updateMapSelectHandler(t, u, n, i);
    }, e.prototype._buildGeoJSON = function(t) {
      var r = this._regionsGroupByName = We(), n = We(), i = this._regionsGroup, o = t.transformInfoRaw, a = t.mapOrGeoModel, s = t.data, l = t.geo.projection, u = l && l.stream;
      function c(f, p) {
        return p && (f = p(f)), f && [f[0] * o.scaleX + o.x, f[1] * o.scaleY + o.y];
      }
      function d(f) {
        for (var p = [], g = !u && l && l.project, v = 0; v < f.length; ++v) {
          var m = c(f[v], g);
          m && p.push(m);
        }
        return p;
      }
      function h(f) {
        return {
          shape: {
            points: d(f)
          }
        };
      }
      i.removeAll(), B(t.geo.regions, function(f) {
        var p = f.name, g = r.get(p), v = n.get(p) || {}, m = v.dataIdx, y = v.regionModel;
        g || (g = r.set(p, new it()), i.add(g), m = s ? s.indexOfName(p) : null, y = t.isGeo ? a.getRegionModel(p) : s ? s.getItemModel(m) : null, n.set(p, {
          dataIdx: m,
          regionModel: y
        }));
        var C = [], S = [];
        B(f.geometries, function(x) {
          if (x.type === "polygon") {
            var E = [x.exterior].concat(x.interiors || []);
            u && (E = cV(E, u)), B(E, function(_) {
              C.push(new Ei(h(_)));
            });
          } else {
            var R = x.points;
            u && (R = cV(R, u, !0)), B(R, function(_) {
              S.push(new Ri(h(_)));
            });
          }
        });
        var b = c(f.getCenter(), l && l.project);
        function w(x, E) {
          if (x.length) {
            var R = new BS({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: x
              }
            });
            g.add(R), oV(t, R, m, y), aV(t, R, p, y, a, m, b), E && (iV(R), B(R.states, iV));
          }
        }
        w(C), w(S, !0);
      }), r.each(function(f, p) {
        var g = n.get(p), v = g.dataIdx, m = g.regionModel;
        sV(t, f, p, m, a, v), lV(t, f, p, m, a), uV(t, f, p, m, a);
      }, this);
    }, e.prototype._buildSVG = function(t) {
      var r = t.geo.map, n = t.transformInfoRaw;
      this._svgGroup.x = n.x, this._svgGroup.y = n.y, this._svgGroup.scaleX = n.scaleX, this._svgGroup.scaleY = n.scaleY, this._svgResourceChanged(r) && (this._freeSVG(), this._useSVG(r));
      var i = this._svgDispatcherMap = We(), o = !1;
      B(this._svgGraphicRecord.named, function(a) {
        var s = a.name, l = t.mapOrGeoModel, u = t.data, c = a.svgNodeTagLower, d = a.el, h = u ? u.indexOfName(s) : null, f = l.getRegionModel(s);
        if (aEe.get(c) != null && d instanceof ko && oV(t, d, h, f), d instanceof ko && (d.culling = !0), d.z2EmphasisLift = 0, !a.namedFrom && (lEe.get(c) != null && aV(t, d, s, f, l, h, null), sV(t, d, s, f, l, h), lV(t, d, s, f, l), sEe.get(c) != null)) {
          var p = uV(t, d, s, f, l);
          p === "self" && (o = !0);
          var g = i.get(s) || i.set(s, []);
          g.push(d);
        }
      }, this), this._enableBlurEntireSVG(o, t);
    }, e.prototype._enableBlurEntireSVG = function(t, r) {
      if (t && r.isGeo) {
        var n = r.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), i = n.opacity;
        this._svgGraphicRecord.root.traverse(function(o) {
          if (!o.isGroup) {
            Dc(o);
            var a = o.ensureState("blur").style || {};
            a.opacity == null && i != null && (a.opacity = i), o.ensureState("emphasis");
          }
        });
      }
    }, e.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, e.prototype.findHighDownDispatchers = function(t, r) {
      if (t == null)
        return [];
      var n = r.coordinateSystem;
      if (n.resourceType === "geoJSON") {
        var i = this._regionsGroupByName;
        if (i) {
          var o = i.get(t);
          return o ? [o] : [];
        }
      } else if (n.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(t) || [];
    }, e.prototype._svgResourceChanged = function(t) {
      return this._svgMapName !== t;
    }, e.prototype._useSVG = function(t) {
      var r = Ks.getGeoResource(t);
      if (r && r.type === "geoSVG") {
        var n = r.useGraphic(this.uid);
        this._svgGroup.add(n.root), this._svgGraphicRecord = n, this._svgMapName = t;
      }
    }, e.prototype._freeSVG = function() {
      var t = this._svgMapName;
      if (t != null) {
        var r = Ks.getGeoResource(t);
        r && r.type === "geoSVG" && r.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, e.prototype._updateController = function(t, r, n) {
      var i = t.coordinateSystem, o = this._controller, a = this._controllerHost;
      a.zoomLimit = t.get("scaleLimit"), a.zoom = i.getZoom(), o.enable(t.get("roam") || !1);
      var s = t.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: s
        };
        return u[s + "Id"] = t.id, u;
      }
      o.off("pan").on("pan", function(u) {
        this._mouseDownFlag = !1, CD(a, u.dx, u.dy), n.dispatchAction(se(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), o.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = !1, SD(a, u.scale, u.originX, u.originY), n.dispatchAction(se(l(), {
          totalZoom: a.zoom,
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), o.setPointerChecker(function(u, c, d) {
        return i.containPoint([c, d]) && !ow(u, n, t);
      });
    }, e.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(t) {
        var r = t.getTextContent();
        r && (r.ignore = I9(r).ignore);
      });
    }, e.prototype._updateMapSelectHandler = function(t, r, n, i) {
      var o = this;
      r.off("mousedown"), r.off("click"), t.get("selectedMode") && (r.on("mousedown", function() {
        o._mouseDownFlag = !0;
      }), r.on("click", function(a) {
        o._mouseDownFlag && (o._mouseDownFlag = !1);
      }));
    }, e;
  }()
);
function oV(e, t, r, n) {
  var i = n.getModel("itemStyle"), o = n.getModel(["emphasis", "itemStyle"]), a = n.getModel(["blur", "itemStyle"]), s = n.getModel(["select", "itemStyle"]), l = uy(i), u = uy(o), c = uy(s), d = uy(a), h = e.data;
  if (h) {
    var f = h.getItemVisual(r, "style"), p = h.getItemVisual(r, "decal");
    e.isVisualEncodedByVisualMap && f.fill && (l.fill = f.fill), p && (l.decal = Nh(p, e.api));
  }
  t.setStyle(l), t.style.strokeNoScale = !0, t.ensureState("emphasis").style = u, t.ensureState("select").style = c, t.ensureState("blur").style = d, Dc(t);
}
function aV(e, t, r, n, i, o, a) {
  var s = e.data, l = e.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), o)), c = s && s.getItemLayout(o);
  if (l || u || c && c.showLabel) {
    var d = l ? r : o, h = void 0;
    (!s || o >= 0) && (h = i);
    var f = a ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    Gn(t, Rn(n), {
      labelFetcher: h,
      labelDataIndex: d,
      defaultText: r
    }, f);
    var p = t.getTextContent();
    if (p && (I9(p).ignore = p.ignore, t.textConfig && a)) {
      var g = t.getBoundingRect().clone();
      t.textConfig.layoutRect = g, t.textConfig.position = [(a[0] - g.x) / g.width * 100 + "%", (a[1] - g.y) / g.height * 100 + "%"];
    }
    t.disableLabelAnimation = !0;
  } else
    t.removeTextContent(), t.removeTextConfig(), t.disableLabelAnimation = null;
}
function sV(e, t, r, n, i, o) {
  e.data ? e.data.setItemGraphicEl(o, t) : ot(t).eventData = {
    componentType: "geo",
    componentIndex: i.componentIndex,
    geoIndex: i.componentIndex,
    name: r,
    region: n && n.option || {}
  };
}
function lV(e, t, r, n, i) {
  e.data || uf({
    el: t,
    componentModel: i,
    itemName: r,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: n.get("tooltip")
  });
}
function uV(e, t, r, n, i) {
  t.highDownSilentOnTouch = !!i.get("selectedMode");
  var o = n.getModel("emphasis"), a = o.get("focus");
  return Hr(t, a, o.get("blurScope"), o.get("disabled")), e.isGeo && Nme(t, i, r), a;
}
function cV(e, t, r) {
  var n = [], i;
  function o() {
    i = [];
  }
  function a() {
    i.length && (n.push(i), i = []);
  }
  var s = t({
    polygonStart: o,
    polygonEnd: a,
    lineStart: o,
    lineEnd: a,
    point: function(l, u) {
      isFinite(l) && isFinite(u) && i.push([l, u]);
    },
    sphere: function() {
    }
  });
  return !r && s.polygonStart(), B(e, function(l) {
    s.lineStart();
    for (var u = 0; u < l.length; u++)
      s.point(l[u][0], l[u][1]);
    s.lineEnd();
  }), !r && s.polygonEnd(), n;
}
var uEe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      if (!(o && o.type === "mapToggleSelect" && o.from === this.uid)) {
        var a = this.group;
        if (a.removeAll(), !r.getHostGeoModel()) {
          if (this._mapDraw && o && o.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), o && o.type === "geoRoam" && o.componentType === "series" && o.seriesId === r.id) {
            var s = this._mapDraw;
            s && a.add(s.group);
          } else if (r.needsDrawMap) {
            var s = this._mapDraw || new F9(i);
            a.add(s.group), s.draw(r, n, i, this, o), this._mapDraw = s;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          r.get("showLegendSymbol") && n.getComponent("legend") && this._renderSymbols(r, n, i);
        }
      }
    }, t.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, t.prototype._renderSymbols = function(r, n, i) {
      var o = r.originalData, a = this.group;
      o.each(o.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = o.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, d = u.offset, h = new Js({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: r.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + d * 9,
                cy: c[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (d ? 0 : of + 1)
            });
            if (!d) {
              var f = r.mainSeries.getData(), p = o.getName(l), g = f.indexOfName(p), v = o.getItemModel(l), m = v.getModel("label"), y = f.getItemGraphicEl(g);
              Gn(h, Rn(v), {
                labelFetcher: {
                  getFormattedLabel: function(C, S) {
                    return r.getFormattedLabel(g, S);
                  }
                },
                defaultText: p
              }), h.disableLabelAnimation = !0, m.get("position") || h.setTextConfig({
                position: "bottom"
              }), y.onHoverStateChange = function(C) {
                q0(h, C);
              };
            }
            a.add(h);
          }
        }
      });
    }, t.type = "map", t;
  }(ar)
), cEe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.needsDrawMap = !1, r.seriesGroup = [], r.getTooltipPosition = function(n) {
        if (n != null) {
          var i = this.getData().getName(n), o = this.coordinateSystem, a = o.getRegion(i);
          return a && o.dataToPoint(a.getCenter());
        }
      }, r;
    }
    return t.prototype.getInitialData = function(r) {
      for (var n = Sf(this, {
        coordDimensions: ["value"],
        encodeDefaulter: dt(OM, this)
      }), i = We(), o = [], a = 0, s = n.count(); a < s; a++) {
        var l = n.getName(a);
        i.set(l, !0);
      }
      var u = Ks.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return B(u.regions, function(c) {
        var d = c.name;
        i.get(d) || o.push(d);
      }), n.appendValues([], o), n;
    }, t.prototype.getHostGeoModel = function() {
      var r = this.option.geoIndex;
      return r != null ? this.ecModel.getComponent("geo", r) : null;
    }, t.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, t.prototype.getRawValue = function(r) {
      var n = this.getData();
      return n.get(n.mapDimension("value"), r);
    }, t.prototype.getRegionModel = function(r) {
      var n = this.getData();
      return n.getItemModel(n.indexOfName(r));
    }, t.prototype.formatTooltip = function(r, n, i) {
      for (var o = this.getData(), a = this.getRawValue(r), s = o.getName(r), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var d = l[c].originalData.indexOfName(s), h = o.mapDimension("value");
        isNaN(l[c].originalData.get(h, d)) || u.push(l[c].name);
      }
      return _n("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [_n("nameValue", {
          name: s,
          value: a
        })]
      });
    }, t.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, t.prototype.setCenter = function(r) {
      this.option.center = r;
    }, t.prototype.getLegendIcon = function(r) {
      var n = r.icon || "roundRect", i = rn(n, 0, 0, r.itemWidth, r.itemHeight, r.itemStyle.fill);
      return i.setStyle(r.itemStyle), i.style.stroke = "none", n.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i;
    }, t.type = "series.map", t.dependencies = ["geo"], t.layoutMode = "box", t.defaultOption = {
      // 一级层叠
      // zlevel: 0,
      // 二级层叠
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, t;
  }(hr)
);
function dEe(e, t) {
  var r = {};
  return B(e, function(n) {
    n.each(n.mapDimension("value"), function(i, o) {
      var a = "ec-" + n.getName(o);
      r[a] = r[a] || [], isNaN(i) || r[a].push(i);
    });
  }), e[0].map(e[0].mapDimension("value"), function(n, i) {
    for (var o = "ec-" + e[0].getName(i), a = 0, s = 1 / 0, l = -1 / 0, u = r[o].length, c = 0; c < u; c++)
      s = Math.min(s, r[o][c]), l = Math.max(l, r[o][c]), a += r[o][c];
    var d;
    return t === "min" ? d = s : t === "max" ? d = l : t === "average" ? d = a / u : d = a, u === 0 ? NaN : d;
  });
}
function hEe(e) {
  var t = {};
  e.eachSeriesByType("map", function(r) {
    var n = r.getHostGeoModel(), i = n ? "o" + n.id : "i" + r.getMapType();
    (t[i] = t[i] || []).push(r);
  }), B(t, function(r, n) {
    for (var i = dEe(ge(r, function(a) {
      return a.getData();
    }), r[0].get("mapValueCalculation")), o = 0; o < r.length; o++)
      r[o].originalData = r[o].getData();
    for (var o = 0; o < r.length; o++)
      r[o].seriesGroup = r, r[o].needsDrawMap = o === 0 && !r[o].getHostGeoModel(), r[o].setData(i.cloneShallow()), r[o].mainSeries = r[0];
  });
}
function fEe(e) {
  var t = {};
  e.eachSeriesByType("map", function(r) {
    var n = r.getMapType();
    if (!(r.getHostGeoModel() || t[n])) {
      var i = {};
      B(r.seriesGroup, function(a) {
        var s = a.coordinateSystem, l = a.originalData;
        a.get("showLegendSymbol") && e.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
          var d = l.getName(c), h = s.getRegion(d);
          if (!(!h || isNaN(u))) {
            var f = i[d] || 0, p = s.dataToPoint(h.getCenter());
            i[d] = f + 1, l.setItemLayout(c, {
              point: p,
              offset: f
            });
          }
        });
      });
      var o = r.getData();
      o.each(function(a) {
        var s = o.getName(a), l = o.getItemLayout(a) || {};
        l.showLabel = !i[s], o.setItemLayout(a, l);
      }), t[n] = !0;
    }
  });
}
var dV = An, Wv = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this) || this;
      return n.type = "view", n.dimensions = ["x", "y"], n._roamTransformable = new Ts(), n._rawTransformable = new Ts(), n.name = r, n;
    }
    return t.prototype.setBoundingRect = function(r, n, i, o) {
      return this._rect = new St(r, n, i, o), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(r, n, i, o) {
      this._transformTo(r, n, i, o), this._viewRect = new St(r, n, i, o);
    }, t.prototype._transformTo = function(r, n, i, o) {
      var a = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = a.calculateTransform(new St(r, n, i, o));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(r, n) {
      r && (this._center = [Ae(r[0], n.getWidth()), Ae(r[1], n.getHeight())], this._updateCenterAndZoom());
    }, t.prototype.setZoom = function(r) {
      r = r || 1;
      var n = this.zoomLimit;
      n && (n.max != null && (r = Math.min(n.max, r)), n.min != null && (r = Math.max(n.min, r))), this._zoom = r, this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var r = this.getBoundingRect(), n = r.x + r.width / 2, i = r.y + r.height / 2;
      return [n, i];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var r = this._rawTransformable.getLocalTransform(), n = this._roamTransformable, i = this.getDefaultCenter(), o = this.getCenter(), a = this.getZoom();
      o = An([], o, r), i = An([], i, r), n.originX = o[0], n.originY = o[1], n.x = i[0] - o[0], n.y = i[1] - o[1], n.scaleX = n.scaleY = a, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var r = this._roamTransformable, n = this._rawTransformable;
      n.parent = r, r.updateTransform(), n.updateTransform(), ES(this.transform || (this.transform = []), n.transform || ki()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], Wc(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var r = this._rawTransformable, n = this._roamTransformable, i = new Ts();
      return i.transform = n.transform, i.decomposeTransform(), {
        roam: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        },
        raw: {
          x: r.x,
          y: r.y,
          scaleX: r.scaleX,
          scaleY: r.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var r = this.getBoundingRect().clone();
      return r.applyTransform(this.transform), r;
    }, t.prototype.dataToPoint = function(r, n, i) {
      var o = n ? this._rawTransform : this.transform;
      return i = i || [], o ? dV(i, r, o) : Kn(i, r);
    }, t.prototype.pointToData = function(r) {
      var n = this.invTransform;
      return n ? dV([], r, n) : [r[0], r[1]];
    }, t.prototype.convertToPixel = function(r, n, i) {
      var o = hV(n);
      return o === this ? o.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(r, n, i) {
      var o = hV(n);
      return o === this ? o.pointToData(i) : null;
    }, t.prototype.containPoint = function(r) {
      return this.getViewRectAfterRoam().contain(r[0], r[1]);
    }, t.dimensions = ["x", "y"], t;
  }(Ts)
);
function hV(e) {
  var t = e.seriesModel;
  return t ? t.coordinateSystem : null;
}
var pEe = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, L9 = ["lng", "lat"], O9 = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i) {
      var o = e.call(this, r) || this;
      o.dimensions = L9, o.type = "geo", o._nameCoordMap = We(), o.map = n;
      var a = i.projection, s = Ks.load(n, i.nameMap, i.nameProperty), l = Ks.getGeoResource(n), u = o.resourceType = l ? l.type : null, c = o.regions = s.regions, d = pEe[l.type];
      o._regionsMap = s.regionsMap, o.regions = s.regions, process.env.NODE_ENV !== "production" && a && (u === "geoSVG" && (process.env.NODE_ENV !== "production" && Vr("Map " + n + " with SVG source can't use projection. Only GeoJSON source supports projection."), a = null), a.project && a.unproject || (process.env.NODE_ENV !== "production" && Vr("project and unproject must be both provided in the projeciton."), a = null)), o.projection = a;
      var h;
      if (a)
        for (var f = 0; f < c.length; f++) {
          var p = c[f].getBoundingRect(a);
          h = h || p.clone(), h.union(p);
        }
      else
        h = s.boundingRect;
      return o.setBoundingRect(h.x, h.y, h.width, h.height), o.aspectScale = a ? 1 : st(i.aspectScale, d.aspectScale), o._invertLongitute = a ? !1 : d.invertLongitute, o;
    }
    return t.prototype._transformTo = function(r, n, i, o) {
      var a = this.getBoundingRect(), s = this._invertLongitute;
      a = a.clone(), s && (a.y = -a.y - a.height);
      var l = this._rawTransformable;
      l.transform = a.calculateTransform(new St(r, n, i, o));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, t.prototype.getRegion = function(r) {
      return this._regionsMap.get(r);
    }, t.prototype.getRegionByCoord = function(r) {
      for (var n = this.regions, i = 0; i < n.length; i++) {
        var o = n[i];
        if (o.type === "geoJSON" && o.contain(r))
          return n[i];
      }
    }, t.prototype.addGeoCoord = function(r, n) {
      this._nameCoordMap.set(r, n);
    }, t.prototype.getGeoCoord = function(r) {
      var n = this._regionsMap.get(r);
      return this._nameCoordMap.get(r) || n && n.getCenter();
    }, t.prototype.dataToPoint = function(r, n, i) {
      if (Fe(r) && (r = this.getGeoCoord(r)), r) {
        var o = this.projection;
        return o && (r = o.project(r)), r && this.projectedToPoint(r, n, i);
      }
    }, t.prototype.pointToData = function(r) {
      var n = this.projection;
      return n && (r = n.unproject(r)), r && this.pointToProjected(r);
    }, t.prototype.pointToProjected = function(r) {
      return e.prototype.pointToData.call(this, r);
    }, t.prototype.projectedToPoint = function(r, n, i) {
      return e.prototype.dataToPoint.call(this, r, n, i);
    }, t.prototype.convertToPixel = function(r, n, i) {
      var o = fV(n);
      return o === this ? o.dataToPoint(i) : null;
    }, t.prototype.convertFromPixel = function(r, n, i) {
      var o = fV(n);
      return o === this ? o.pointToData(i) : null;
    }, t;
  }(Wv)
);
qr(O9, Wv);
function fV(e) {
  var t = e.geoModel, r = e.seriesModel;
  return t ? t.coordinateSystem : r ? r.coordinateSystem || (r.getReferringComponents("geo", un).models[0] || {}).coordinateSystem : null;
}
const pV = O9;
function gV(e, t) {
  var r = e.get("boundingCoords");
  if (r != null) {
    var n = r[0], i = r[1];
    if (!(isFinite(n[0]) && isFinite(n[1]) && isFinite(i[0]) && isFinite(i[1])))
      process.env.NODE_ENV !== "production" && console.error("Invalid boundingCoords");
    else {
      var o = this.projection;
      if (o) {
        var a = n[0], s = n[1], l = i[0], u = i[1];
        n = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0];
        var c = function(w, x, E, R) {
          for (var _ = E - w, P = R - x, D = 0; D <= 100; D++) {
            var I = D / 100, A = o.project([w + _ * I, x + P * I]);
            Rs(n, n, A), _s(i, i, A);
          }
        };
        c(a, s, l, s), c(l, s, l, u), c(l, u, a, u), c(a, u, l, s);
      }
      this.setBoundingRect(n[0], n[1], i[0] - n[0], i[1] - n[1]);
    }
  }
  var d = this.getBoundingRect(), h = e.get("layoutCenter"), f = e.get("layoutSize"), p = t.getWidth(), g = t.getHeight(), v = d.width / d.height * this.aspectScale, m = !1, y, C;
  h && f && (y = [Ae(h[0], p), Ae(h[1], g)], C = Ae(f, Math.min(p, g)), !isNaN(y[0]) && !isNaN(y[1]) && !isNaN(C) ? m = !0 : process.env.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
  var S;
  if (m)
    S = {}, v > 1 ? (S.width = C, S.height = C / v) : (S.height = C, S.width = C * v), S.y = y[1] - S.height / 2, S.x = y[0] - S.width / 2;
  else {
    var b = e.getBoxLayoutParams();
    b.aspect = v, S = hn(b, {
      width: p,
      height: g
    });
  }
  this.setViewRect(S.x, S.y, S.width, S.height), this.setCenter(e.get("center"), t), this.setZoom(e.get("zoom"));
}
function gEe(e, t) {
  B(t.get("geoCoord"), function(r, n) {
    e.addGeoCoord(n, r);
  });
}
var vEe = (
  /** @class */
  function() {
    function e() {
      this.dimensions = L9;
    }
    return e.prototype.create = function(t, r) {
      var n = [];
      function i(a) {
        return {
          nameProperty: a.get("nameProperty"),
          aspectScale: a.get("aspectScale"),
          projection: a.get("projection")
        };
      }
      t.eachComponent("geo", function(a, s) {
        var l = a.get("map"), u = new pV(l + s, l, se({
          nameMap: a.get("nameMap")
        }, i(a)));
        u.zoomLimit = a.get("scaleLimit"), n.push(u), a.coordinateSystem = u, u.model = a, u.resize = gV, u.resize(a, r);
      }), t.eachSeries(function(a) {
        var s = a.get("coordinateSystem");
        if (s === "geo") {
          var l = a.get("geoIndex") || 0;
          a.coordinateSystem = n[l];
        }
      });
      var o = {};
      return t.eachSeriesByType("map", function(a) {
        if (!a.getHostGeoModel()) {
          var s = a.getMapType();
          o[s] = o[s] || [], o[s].push(a);
        }
      }), B(o, function(a, s) {
        var l = ge(a, function(c) {
          return c.get("nameMap");
        }), u = new pV(s, s, se({
          nameMap: wS(l)
        }, i(a[0])));
        u.zoomLimit = tn.apply(null, ge(a, function(c) {
          return c.get("scaleLimit");
        })), n.push(u), u.resize = gV, u.resize(a[0], r), B(a, function(c) {
          c.coordinateSystem = u, gEe(u, c);
        });
      }), n;
    }, e.prototype.getFilledRegions = function(t, r, n, i) {
      for (var o = (t || []).slice(), a = We(), s = 0; s < o.length; s++)
        a.set(o[s].name, o[s]);
      var l = Ks.load(r, n, i);
      return B(l.regions, function(u) {
        var c = u.name;
        !a.get(c) && o.push({
          name: c
        });
      }), o;
    }, e;
  }()
), N9 = new vEe(), mEe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n, i) {
      var o = Ks.getGeoResource(r.map);
      if (o && o.type === "geoJSON") {
        var a = r.itemStyle = r.itemStyle || {};
        "color" in a || (a.color = "#eee");
      }
      this.mergeDefaultAndTheme(r, i), Tc(r, "label", ["show"]);
    }, t.prototype.optionUpdated = function() {
      var r = this, n = this.option;
      n.regions = N9.getFilledRegions(n.regions, n.map, n.nameMap, n.nameProperty);
      var i = {};
      this._optionModelMap = Oo(n.regions || [], function(o, a) {
        var s = a.name;
        return s && (o.set(s, new cr(a, r, r.ecModel)), a.selected && (i[s] = !0)), o;
      }, We()), n.selectedMap || (n.selectedMap = i);
    }, t.prototype.getRegionModel = function(r) {
      return this._optionModelMap.get(r) || new cr(null, this, this.ecModel);
    }, t.prototype.getFormattedLabel = function(r, n) {
      var i = this.getRegionModel(r), o = n === "normal" ? i.get(["label", "formatter"]) : i.get(["emphasis", "label", "formatter"]), a = {
        name: r
      };
      if (Ye(o))
        return a.status = n, o(a);
      if (Fe(o))
        return o.replace("{a}", r ?? "");
    }, t.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, t.prototype.setCenter = function(r) {
      this.option.center = r;
    }, t.prototype.select = function(r) {
      var n = this.option, i = n.selectedMode;
      if (i) {
        i !== "multiple" && (n.selectedMap = null);
        var o = n.selectedMap || (n.selectedMap = {});
        o[r] = !0;
      }
    }, t.prototype.unSelect = function(r) {
      var n = this.option.selectedMap;
      n && (n[r] = !1);
    }, t.prototype.toggleSelected = function(r) {
      this[this.isSelected(r) ? "unSelect" : "select"](r);
    }, t.prototype.isSelected = function(r) {
      var n = this.option.selectedMap;
      return !!(n && n[r]);
    }, t.type = "geo", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
        // Default color:
        // + geoJSON: #eee
        // + geoSVG: null (use SVG original `fill`)
        // color: '#eee'
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, t;
  }(Rt)
);
function vV(e, t) {
  return e.pointToProjected ? e.pointToProjected(t) : e.pointToData(t);
}
function bD(e, t, r, n) {
  var i = e.getZoom(), o = e.getCenter(), a = t.zoom, s = e.projectedToPoint ? e.projectedToPoint(o) : e.dataToPoint(o);
  if (t.dx != null && t.dy != null && (s[0] -= t.dx, s[1] -= t.dy, e.setCenter(vV(e, s), n)), a != null) {
    if (r) {
      var l = r.min || 0, u = r.max || 1 / 0;
      a = Math.max(Math.min(i * a, u), l) / i;
    }
    e.scaleX *= a, e.scaleY *= a;
    var c = (t.originX - e.x) * (a - 1), d = (t.originY - e.y) * (a - 1);
    e.x -= c, e.y -= d, e.updateTransform(), e.setCenter(vV(e, s), n), e.setZoom(a * i);
  }
  return {
    center: e.getCenter(),
    zoom: e.getZoom()
  };
}
var yEe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.focusBlurEnabled = !0, r;
    }
    return t.prototype.init = function(r, n) {
      this._api = n;
    }, t.prototype.render = function(r, n, i, o) {
      if (this._model = r, !r.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new F9(i));
      var a = this._mapDraw;
      a.draw(r, n, i, this, o), a.group.on("click", this._handleRegionClick, this), a.group.silent = r.get("silent"), this.group.add(a.group), this.updateSelectStatus(r, n, i);
    }, t.prototype._handleRegionClick = function(r) {
      var n;
      ic(r.target, function(i) {
        return (n = ot(i).eventData) != null;
      }, !0), n && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: n.name
      });
    }, t.prototype.updateSelectStatus = function(r, n, i) {
      var o = this;
      this._mapDraw.group.traverse(function(a) {
        var s = ot(a).eventData;
        if (s)
          return o._model.isSelected(s.name) ? i.enterSelect(a) : i.leaveSelect(a), !0;
      });
    }, t.prototype.findHighDownDispatchers = function(r) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(r, this._model);
    }, t.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, t.type = "geo", t;
  }(Rr)
);
function CEe(e, t, r) {
  Ks.registerMap(e, t, r);
}
function k9(e) {
  e.registerCoordinateSystem("geo", N9), e.registerComponentModel(mEe), e.registerComponentView(yEe), e.registerImpl("registerMap", CEe), e.registerImpl("getMap", function(r) {
    return Ks.getMapForUser(r);
  });
  function t(r, n) {
    n.update = "geo:updateSelectStatus", e.registerAction(n, function(i, o) {
      var a = {}, s = [];
      return o.eachComponent({
        mainType: "geo",
        query: i
      }, function(l) {
        l[r](i.name);
        var u = l.coordinateSystem;
        B(u.regions, function(d) {
          a[d.name] = l.isSelected(d.name) || !1;
        });
        var c = [];
        B(a, function(d, h) {
          a[h] && c.push(h);
        }), s.push({
          geoIndex: l.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: c
        });
      }), {
        selected: a,
        allSelected: s,
        name: i.name
      };
    });
  }
  t("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), t("select", {
    type: "geoSelect",
    event: "geoselected"
  }), t("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), e.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(r, n, i) {
    var o = r.componentType || "series";
    n.eachComponent({
      mainType: o,
      query: r
    }, function(a) {
      var s = a.coordinateSystem;
      if (s.type === "geo") {
        var l = bD(s, r, a.get("scaleLimit"), i);
        a.setCenter && a.setCenter(l.center), a.setZoom && a.setZoom(l.zoom), o === "series" && B(a.seriesGroup, function(u) {
          u.setCenter(l.center), u.setZoom(l.zoom);
        });
      }
    });
  });
}
function SEe(e) {
  _t(k9), e.registerChartView(uEe), e.registerSeriesModel(cEe), e.registerLayout(fEe), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, hEe), NW("map", e.registerAction);
}
function wEe(e) {
  var t = e;
  t.hierNode = {
    defaultAncestor: null,
    ancestor: t,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var r = [t], n, i; n = r.pop(); )
    if (i = n.children, n.isExpand && i.length)
      for (var o = i.length, a = o - 1; a >= 0; a--) {
        var s = i[a];
        s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: a,
          thread: null
        }, r.push(s);
      }
}
function bEe(e, t) {
  var r = e.isExpand ? e.children : [], n = e.parentNode.children, i = e.hierNode.i ? n[e.hierNode.i - 1] : null;
  if (r.length) {
    REe(e);
    var o = (r[0].hierNode.prelim + r[r.length - 1].hierNode.prelim) / 2;
    i ? (e.hierNode.prelim = i.hierNode.prelim + t(e, i), e.hierNode.modifier = e.hierNode.prelim - o) : e.hierNode.prelim = o;
  } else i && (e.hierNode.prelim = i.hierNode.prelim + t(e, i));
  e.parentNode.hierNode.defaultAncestor = _Ee(e, i, e.parentNode.hierNode.defaultAncestor || n[0], t);
}
function xEe(e) {
  var t = e.hierNode.prelim + e.parentNode.hierNode.modifier;
  e.setLayout({
    x: t
  }, !0), e.hierNode.modifier += e.parentNode.hierNode.modifier;
}
function mV(e) {
  return arguments.length ? e : MEe;
}
function Ip(e, t) {
  return e -= Math.PI / 2, {
    x: t * Math.cos(e),
    y: t * Math.sin(e)
  };
}
function EEe(e, t) {
  return hn(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function REe(e) {
  for (var t = e.children, r = t.length, n = 0, i = 0; --r >= 0; ) {
    var o = t[r];
    o.hierNode.prelim += n, o.hierNode.modifier += n, i += o.hierNode.change, n += o.hierNode.shift + i;
  }
}
function _Ee(e, t, r, n) {
  if (t) {
    for (var i = e, o = e, a = o.parentNode.children[0], s = t, l = i.hierNode.modifier, u = o.hierNode.modifier, c = a.hierNode.modifier, d = s.hierNode.modifier; s = z1(s), o = $1(o), s && o; ) {
      i = z1(i), a = $1(a), i.hierNode.ancestor = e;
      var h = s.hierNode.prelim + d - o.hierNode.prelim - u + n(s, o);
      h > 0 && (PEe(TEe(s, e, r), e, h), u += h, l += h), d += s.hierNode.modifier, u += o.hierNode.modifier, l += i.hierNode.modifier, c += a.hierNode.modifier;
    }
    s && !z1(i) && (i.hierNode.thread = s, i.hierNode.modifier += d - l), o && !$1(a) && (a.hierNode.thread = o, a.hierNode.modifier += u - c, r = e);
  }
  return r;
}
function z1(e) {
  var t = e.children;
  return t.length && e.isExpand ? t[t.length - 1] : e.hierNode.thread;
}
function $1(e) {
  var t = e.children;
  return t.length && e.isExpand ? t[0] : e.hierNode.thread;
}
function TEe(e, t, r) {
  return e.hierNode.ancestor.parentNode === t.parentNode ? e.hierNode.ancestor : r;
}
function PEe(e, t, r) {
  var n = r / (t.hierNode.i - e.hierNode.i);
  t.hierNode.change -= n, t.hierNode.shift += r, t.hierNode.modifier += r, t.hierNode.prelim += r, e.hierNode.change += n;
}
function MEe(e, t) {
  return e.parentNode === t.parentNode ? 1 : 2;
}
var DEe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.parentPoint = [], this.childPoints = [];
    }
    return e;
  }()
), AEe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      return e.call(this, r) || this;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new DEe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.childPoints, o = i.length, a = n.parentPoint, s = i[0], l = i[o - 1];
      if (o === 1) {
        r.moveTo(a[0], a[1]), r.lineTo(s[0], s[1]);
        return;
      }
      var u = n.orient, c = u === "TB" || u === "BT" ? 0 : 1, d = 1 - c, h = Ae(n.forkPosition, 1), f = [];
      f[c] = a[c], f[d] = a[d] + (l[d] - a[d]) * h, r.moveTo(a[0], a[1]), r.lineTo(f[0], f[1]), r.moveTo(s[0], s[1]), f[c] = s[c], r.lineTo(f[0], f[1]), f[c] = l[c], r.lineTo(f[0], f[1]), r.lineTo(l[0], l[1]);
      for (var p = 1; p < o - 1; p++) {
        var g = i[p];
        r.moveTo(g[0], g[1]), f[c] = g[c], r.lineTo(f[0], f[1]);
      }
    }, t;
  }(Mt)
), IEe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._mainGroup = new it(), r;
    }
    return t.prototype.init = function(r, n) {
      this._controller = new $v(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = r.layoutInfo, s = this._mainGroup, l = r.get("layout");
      l === "radial" ? (s.x = a.x + a.width / 2, s.y = a.y + a.height / 2) : (s.x = a.x, s.y = a.y), this._updateViewCoordSys(r, i), this._updateController(r, n, i);
      var u = this._data;
      o.diff(u).add(function(c) {
        yV(o, c) && CV(o, c, null, s, r);
      }).update(function(c, d) {
        var h = u.getItemGraphicEl(d);
        if (!yV(o, c)) {
          h && wV(u, d, h, s, r);
          return;
        }
        CV(o, c, h, s, r);
      }).remove(function(c) {
        var d = u.getItemGraphicEl(c);
        d && wV(u, c, d, s, r);
      }).execute(), this._nodeScaleRatio = r.get("nodeScaleRatio"), this._updateNodeAndLinkScale(r), r.get("expandAndCollapse") === !0 && o.eachItemGraphicEl(function(c, d) {
        c.off("click").on("click", function() {
          i.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: r.id,
            dataIndex: d
          });
        });
      }), this._data = o;
    }, t.prototype._updateViewCoordSys = function(r, n) {
      var i = r.getData(), o = [];
      i.each(function(d) {
        var h = i.getItemLayout(d);
        h && !isNaN(h.x) && !isNaN(h.y) && o.push([+h.x, +h.y]);
      });
      var a = [], s = [];
      LS(o, a, s);
      var l = this._min, u = this._max;
      s[0] - a[0] === 0 && (a[0] = l ? l[0] : a[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - a[1] === 0 && (a[1] = l ? l[1] : a[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var c = r.coordinateSystem = new Wv();
      c.zoomLimit = r.get("scaleLimit"), c.setBoundingRect(a[0], a[1], s[0] - a[0], s[1] - a[1]), c.setCenter(r.get("center"), n), c.setZoom(r.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = a, this._max = s;
    }, t.prototype._updateController = function(r, n, i) {
      var o = this, a = this._controller, s = this._controllerHost, l = this.group;
      a.setPointerChecker(function(u, c, d) {
        var h = l.getBoundingRect();
        return h.applyTransform(l.transform), h.contain(c, d) && !ow(u, i, r);
      }), a.enable(r.get("roam")), s.zoomLimit = r.get("scaleLimit"), s.zoom = r.coordinateSystem.getZoom(), a.off("pan").off("zoom").on("pan", function(u) {
        CD(s, u.dx, u.dy), i.dispatchAction({
          seriesId: r.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        SD(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: r.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), o._updateNodeAndLinkScale(r), i.updateLabelLayout();
      });
    }, t.prototype._updateNodeAndLinkScale = function(r) {
      var n = r.getData(), i = this._getNodeGlobalScale(r);
      n.eachItemGraphicEl(function(o, a) {
        o.setSymbolScale(i);
      });
    }, t.prototype._getNodeGlobalScale = function(r) {
      var n = r.coordinateSystem;
      if (n.type !== "view")
        return 1;
      var i = this._nodeScaleRatio, o = n.scaleX || 1, a = n.getZoom(), s = (a - 1) * i + 1;
      return s / o;
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, t.type = "tree", t;
  }(ar)
);
function yV(e, t) {
  var r = e.getItemLayout(t);
  return r && !isNaN(r.x) && !isNaN(r.y);
}
function CV(e, t, r, n, i) {
  var o = !r, a = e.tree.getNodeByDataIndex(t), s = a.getModel(), l = a.getVisual("style").fill, u = a.isExpand === !1 && a.children.length !== 0 ? l : "#fff", c = e.tree.root, d = a.parentNode === c ? a : a.parentNode || a, h = e.getItemGraphicEl(d.dataIndex), f = d.getLayout(), p = h ? {
    x: h.__oldX,
    y: h.__oldY,
    rawX: h.__radialOldRawX,
    rawY: h.__radialOldRawY
  } : f, g = a.getLayout();
  o ? (r = new kv(e, t, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), r.x = p.x, r.y = p.y) : r.updateData(e, t, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), r.__radialOldRawX = r.__radialRawX, r.__radialOldRawY = r.__radialRawY, r.__radialRawX = g.rawX, r.__radialRawY = g.rawY, n.add(r), e.setItemGraphicEl(t, r), r.__oldX = r.x, r.__oldY = r.y, jt(r, {
    x: g.x,
    y: g.y
  }, i);
  var v = r.getSymbolPath();
  if (i.get("layout") === "radial") {
    var m = c.children[0], y = m.getLayout(), C = m.children.length, S = void 0, b = void 0;
    if (g.x === y.x && a.isExpand === !0 && m.children.length) {
      var w = {
        x: (m.children[0].getLayout().x + m.children[C - 1].getLayout().x) / 2,
        y: (m.children[0].getLayout().y + m.children[C - 1].getLayout().y) / 2
      };
      S = Math.atan2(w.y - y.y, w.x - y.x), S < 0 && (S = Math.PI * 2 + S), b = w.x < y.x, b && (S = S - Math.PI);
    } else
      S = Math.atan2(g.y - y.y, g.x - y.x), S < 0 && (S = Math.PI * 2 + S), a.children.length === 0 || a.children.length !== 0 && a.isExpand === !1 ? (b = g.x < y.x, b && (S = S - Math.PI)) : (b = g.x > y.x, b || (S = S - Math.PI));
    var x = b ? "left" : "right", E = s.getModel("label"), R = E.get("rotate"), _ = R * (Math.PI / 180), P = v.getTextContent();
    P && (v.setTextConfig({
      position: E.get("position") || x,
      rotation: R == null ? -S : _,
      origin: "center"
    }), P.setStyle("verticalAlign", "middle"));
  }
  var D = s.get(["emphasis", "focus"]), I = D === "relative" ? Dg(a.getAncestorsIndices(), a.getDescendantIndices()) : D === "ancestor" ? a.getAncestorsIndices() : D === "descendant" ? a.getDescendantIndices() : null;
  I && (ot(r).focus = I), FEe(i, a, c, r, p, f, g, n), r.__edge && (r.onHoverStateChange = function(A) {
    if (A !== "blur") {
      var O = a.parentNode && e.getItemGraphicEl(a.parentNode.dataIndex);
      O && O.hoverState === Mv || q0(r.__edge, A);
    }
  });
}
function FEe(e, t, r, n, i, o, a, s) {
  var l = t.getModel(), u = e.get("edgeShape"), c = e.get("layout"), d = e.getOrient(), h = e.get(["lineStyle", "curveness"]), f = e.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), g = n.__edge;
  if (u === "curve")
    t.parentNode && t.parentNode !== r && (g || (g = n.__edge = new Av({
      shape: V_(c, d, h, i, i)
    })), jt(g, {
      shape: V_(c, d, h, o, a)
    }, e));
  else if (u === "polyline") {
    if (c === "orthogonal") {
      if (t !== r && t.children && t.children.length !== 0 && t.isExpand === !0) {
        for (var v = t.children, m = [], y = 0; y < v.length; y++) {
          var C = v[y].getLayout();
          m.push([C.x, C.y]);
        }
        g || (g = n.__edge = new AEe({
          shape: {
            parentPoint: [a.x, a.y],
            childPoints: [[a.x, a.y]],
            orient: d,
            forkPosition: f
          }
        })), jt(g, {
          shape: {
            parentPoint: [a.x, a.y],
            childPoints: m
          }
        }, e);
      }
    } else if (process.env.NODE_ENV !== "production")
      throw new Error("The polyline edgeShape can only be used in orthogonal layout");
  }
  g && !(u === "polyline" && !t.isExpand) && (g.useStyle(Xe({
    strokeNoScale: !0,
    fill: null
  }, p)), Bn(g, l, "lineStyle"), Dc(g), s.add(g));
}
function SV(e, t, r, n, i) {
  var o = t.tree.root, a = V9(o, e), s = a.source, l = a.sourceLayout, u = t.getItemGraphicEl(e.dataIndex);
  if (u) {
    var c = t.getItemGraphicEl(s.dataIndex), d = c.__edge, h = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? d : void 0), f = n.get("edgeShape"), p = n.get("layout"), g = n.get("orient"), v = n.get(["lineStyle", "curveness"]);
    h && (f === "curve" ? Ul(h, {
      shape: V_(p, g, v, l, l),
      style: {
        opacity: 0
      }
    }, n, {
      cb: function() {
        r.remove(h);
      },
      removeOpt: i
    }) : f === "polyline" && n.get("layout") === "orthogonal" && Ul(h, {
      shape: {
        parentPoint: [l.x, l.y],
        childPoints: [[l.x, l.y]]
      },
      style: {
        opacity: 0
      }
    }, n, {
      cb: function() {
        r.remove(h);
      },
      removeOpt: i
    }));
  }
}
function V9(e, t) {
  for (var r = t.parentNode === e ? t : t.parentNode || t, n; n = r.getLayout(), n == null; )
    r = r.parentNode === e ? r : r.parentNode || r;
  return {
    source: r,
    sourceLayout: n
  };
}
function wV(e, t, r, n, i) {
  var o = e.tree.getNodeByDataIndex(t), a = e.tree.root, s = V9(a, o).sourceLayout, l = {
    duration: i.get("animationDurationUpdate"),
    easing: i.get("animationEasingUpdate")
  };
  Ul(r, {
    x: s.x + 1,
    y: s.y + 1
  }, i, {
    cb: function() {
      n.remove(r), e.setItemGraphicEl(t, null);
    },
    removeOpt: l
  }), r.fadeOut(null, e.hostModel, {
    fadeLabel: !0,
    animation: l
  }), o.children.forEach(function(u) {
    SV(u, e, n, i, l);
  }), SV(o, e, n, i, l);
}
function V_(e, t, r, n, i) {
  var o, a, s, l, u, c, d, h;
  if (e === "radial") {
    u = n.rawX, d = n.rawY, c = i.rawX, h = i.rawY;
    var f = Ip(u, d), p = Ip(u, d + (h - d) * r), g = Ip(c, h + (d - h) * r), v = Ip(c, h);
    return {
      x1: f.x || 0,
      y1: f.y || 0,
      x2: v.x || 0,
      y2: v.y || 0,
      cpx1: p.x || 0,
      cpy1: p.y || 0,
      cpx2: g.x || 0,
      cpy2: g.y || 0
    };
  } else
    u = n.x, d = n.y, c = i.x, h = i.y, (t === "LR" || t === "RL") && (o = u + (c - u) * r, a = d, s = c + (u - c) * r, l = h), (t === "TB" || t === "BT") && (o = u, a = d + (h - d) * r, s = c, l = h + (d - h) * r);
  return {
    x1: u,
    y1: d,
    x2: c,
    y2: h,
    cpx1: o,
    cpy1: a,
    cpx2: s,
    cpy2: l
  };
}
var Do = Gt();
function B9(e) {
  var t = e.mainData, r = e.datas;
  r || (r = {
    main: t
  }, e.datasAttr = {
    main: "data"
  }), e.datas = e.mainData = null, G9(t, r, e), B(r, function(n) {
    B(t.TRANSFERABLE_METHODS, function(i) {
      n.wrapMethod(i, dt(LEe, e));
    });
  }), t.wrapMethod("cloneShallow", dt(NEe, e)), B(t.CHANGABLE_METHODS, function(n) {
    t.wrapMethod(n, dt(OEe, e));
  }), Qe(r[t.dataType] === t);
}
function LEe(e, t) {
  if (BEe(this)) {
    var r = se({}, Do(this).datas);
    r[this.dataType] = t, G9(t, r, e);
  } else
    xD(t, this.dataType, Do(this).mainData, e);
  return t;
}
function OEe(e, t) {
  return e.struct && e.struct.update(), t;
}
function NEe(e, t) {
  return B(Do(t).datas, function(r, n) {
    r !== t && xD(r.cloneShallow(), n, t, e);
  }), t;
}
function kEe(e) {
  var t = Do(this).mainData;
  return e == null || t == null ? t : Do(t).datas[e];
}
function VEe() {
  var e = Do(this).mainData;
  return e == null ? [{
    data: e
  }] : ge(At(Do(e).datas), function(t) {
    return {
      type: t,
      data: Do(e).datas[t]
    };
  });
}
function BEe(e) {
  return Do(e).mainData === e;
}
function G9(e, t, r) {
  Do(e).datas = {}, B(t, function(n, i) {
    xD(n, i, e, r);
  });
}
function xD(e, t, r, n) {
  Do(r).datas[t] = e, Do(e).mainData = r, e.dataType = t, n.struct && (e[n.structAttr] = n.struct, n.struct[n.datasAttr[t]] = e), e.getLinkedData = kEe, e.getLinkedDataAll = VEe;
}
var GEe = (
  /** @class */
  function() {
    function e(t, r) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = t || "", this.hostTree = r;
    }
    return e.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, e.prototype.eachNode = function(t, r, n) {
      Ye(t) && (n = r, r = t, t = null), t = t || {}, Fe(t) && (t = {
        order: t
      });
      var i = t.order || "preorder", o = this[t.attr || "children"], a;
      i === "preorder" && (a = r.call(n, this));
      for (var s = 0; !a && s < o.length; s++)
        o[s].eachNode(t, r, n);
      i === "postorder" && r.call(n, this);
    }, e.prototype.updateDepthAndHeight = function(t) {
      var r = 0;
      this.depth = t;
      for (var n = 0; n < this.children.length; n++) {
        var i = this.children[n];
        i.updateDepthAndHeight(t + 1), i.height > r && (r = i.height);
      }
      this.height = r + 1;
    }, e.prototype.getNodeById = function(t) {
      if (this.getId() === t)
        return this;
      for (var r = 0, n = this.children, i = n.length; r < i; r++) {
        var o = n[r].getNodeById(t);
        if (o)
          return o;
      }
    }, e.prototype.contains = function(t) {
      if (t === this)
        return !0;
      for (var r = 0, n = this.children, i = n.length; r < i; r++) {
        var o = n[r].contains(t);
        if (o)
          return o;
      }
    }, e.prototype.getAncestors = function(t) {
      for (var r = [], n = t ? this : this.parentNode; n; )
        r.push(n), n = n.parentNode;
      return r.reverse(), r;
    }, e.prototype.getAncestorsIndices = function() {
      for (var t = [], r = this; r; )
        t.push(r.dataIndex), r = r.parentNode;
      return t.reverse(), t;
    }, e.prototype.getDescendantIndices = function() {
      var t = [];
      return this.eachNode(function(r) {
        t.push(r.dataIndex);
      }), t;
    }, e.prototype.getValue = function(t) {
      var r = this.hostTree.data;
      return r.getStore().get(r.getDimensionIndex(t || "value"), this.dataIndex);
    }, e.prototype.setLayout = function(t, r) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, t, r);
    }, e.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var r = this.hostTree, n = r.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, e.prototype.setVisual = function(t, r) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, t, r);
    }, e.prototype.getVisual = function(t) {
      return this.hostTree.data.getItemVisual(this.dataIndex, t);
    }, e.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, e.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, e.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var t = this.parentNode.children, r = 0; r < t.length; ++r)
          if (t[r] === this)
            return r;
        return -1;
      }
      return -1;
    }, e.prototype.isAncestorOf = function(t) {
      for (var r = t.parentNode; r; ) {
        if (r === this)
          return !0;
        r = r.parentNode;
      }
      return !1;
    }, e.prototype.isDescendantOf = function(t) {
      return t !== this && t.isAncestorOf(this);
    }, e;
  }()
), ED = (
  /** @class */
  function() {
    function e(t) {
      this.type = "tree", this._nodes = [], this.hostModel = t;
    }
    return e.prototype.eachNode = function(t, r, n) {
      this.root.eachNode(t, r, n);
    }, e.prototype.getNodeByDataIndex = function(t) {
      var r = this.data.getRawIndex(t);
      return this._nodes[r];
    }, e.prototype.getNodeById = function(t) {
      return this.root.getNodeById(t);
    }, e.prototype.update = function() {
      for (var t = this.data, r = this._nodes, n = 0, i = r.length; n < i; n++)
        r[n].dataIndex = -1;
      for (var n = 0, i = t.count(); n < i; n++)
        r[t.getRawIndex(n)].dataIndex = n;
    }, e.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, e.createTree = function(t, r, n) {
      var i = new e(r), o = [], a = 1;
      s(t);
      function s(c, d) {
        var h = c.value;
        a = Math.max(a, fe(h) ? h.length : 1), o.push(c);
        var f = new GEe(vn(c.name, ""), i);
        d ? HEe(f, d) : i.root = f, i._nodes.push(f);
        var p = c.children;
        if (p)
          for (var g = 0; g < p.length; g++)
            s(p[g], f);
      }
      i.root.updateDepthAndHeight(0);
      var l = mf(o, {
        coordDimensions: ["value"],
        dimensionsCount: a
      }).dimensions, u = new Jn(l, r);
      return u.initData(o), n && n(u), B9({
        mainData: u,
        struct: i,
        structAttr: "tree"
      }), i.update(), i;
    }, e;
  }()
);
function HEe(e, t) {
  var r = t.children;
  e.parentNode !== t && (r.push(e), e.parentNode = t);
}
function Zg(e, t, r) {
  if (e && bt(t, e.type) >= 0) {
    var n = r.getData().tree.root, i = e.targetNode;
    if (Fe(i) && (i = n.getNodeById(i)), i && n.contains(i))
      return {
        node: i
      };
    var o = e.targetNodeId;
    if (o != null && (i = n.getNodeById(o)))
      return {
        node: i
      };
  }
}
function H9(e) {
  for (var t = []; e; )
    e = e.parentNode, e && t.push(e);
  return t.reverse();
}
function RD(e, t) {
  var r = H9(e);
  return bt(r, t) >= 0;
}
function sw(e, t) {
  for (var r = []; e; ) {
    var n = e.dataIndex;
    r.push({
      name: e.name,
      dataIndex: n,
      value: t.getRawValue(n)
    }), e = e.parentNode;
  }
  return r.reverse(), r;
}
var zEe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.hasSymbolVisual = !0, r.ignoreStyleOnData = !0, r;
    }
    return t.prototype.getInitialData = function(r) {
      var n = {
        name: r.name,
        children: r.data
      }, i = r.leaves || {}, o = new cr(i, this, this.ecModel), a = ED.createTree(n, this, s);
      function s(d) {
        d.wrapMethod("getItemModel", function(h, f) {
          var p = a.getNodeByDataIndex(f);
          return p && p.children.length && p.isExpand || (h.parentModel = o), h;
        });
      }
      var l = 0;
      a.eachNode("preorder", function(d) {
        d.depth > l && (l = d.depth);
      });
      var u = r.expandAndCollapse, c = u && r.initialTreeDepth >= 0 ? r.initialTreeDepth : l;
      return a.root.eachNode("preorder", function(d) {
        var h = d.hostTree.data.getRawDataItem(d.dataIndex);
        d.isExpand = h && h.collapsed != null ? !h.collapsed : d.depth <= c;
      }), a.data;
    }, t.prototype.getOrient = function() {
      var r = this.get("orient");
      return r === "horizontal" ? r = "LR" : r === "vertical" && (r = "TB"), r;
    }, t.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, t.prototype.setCenter = function(r) {
      this.option.center = r;
    }, t.prototype.formatTooltip = function(r, n, i) {
      for (var o = this.getData().tree, a = o.root.children[0], s = o.getNodeByDataIndex(r), l = s.getValue(), u = s.name; s && s !== a; )
        u = s.parentNode.name + "." + u, s = s.parentNode;
      return _n("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, t.prototype.getDataParams = function(r) {
      var n = e.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(r);
      return n.treeAncestors = sw(i, this), n.collapsed = !i.isExpand, n;
    }, t.type = "series.tree", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, t;
  }(hr)
);
function $Ee(e, t, r) {
  for (var n = [e], i = [], o; o = n.pop(); )
    if (i.push(o), o.isExpand) {
      var a = o.children;
      if (a.length)
        for (var s = 0; s < a.length; s++)
          n.push(a[s]);
    }
  for (; o = i.pop(); )
    t(o, r);
}
function cp(e, t) {
  for (var r = [e], n; n = r.pop(); )
    if (t(n), n.isExpand) {
      var i = n.children;
      if (i.length)
        for (var o = i.length - 1; o >= 0; o--)
          r.push(i[o]);
    }
}
function WEe(e, t) {
  e.eachSeriesByType("tree", function(r) {
    jEe(r, t);
  });
}
function jEe(e, t) {
  var r = EEe(e, t);
  e.layoutInfo = r;
  var n = e.get("layout"), i = 0, o = 0, a = null;
  n === "radial" ? (i = 2 * Math.PI, o = Math.min(r.height, r.width) / 2, a = mV(function(C, S) {
    return (C.parentNode === S.parentNode ? 1 : 2) / C.depth;
  })) : (i = r.width, o = r.height, a = mV());
  var s = e.getData().tree.root, l = s.children[0];
  if (l) {
    wEe(s), $Ee(l, bEe, a), s.hierNode.modifier = -l.hierNode.prelim, cp(l, xEe);
    var u = l, c = l, d = l;
    cp(l, function(C) {
      var S = C.getLayout().x;
      S < u.getLayout().x && (u = C), S > c.getLayout().x && (c = C), C.depth > d.depth && (d = C);
    });
    var h = u === c ? 1 : a(u, c) / 2, f = h - u.getLayout().x, p = 0, g = 0, v = 0, m = 0;
    if (n === "radial")
      p = i / (c.getLayout().x + h + f), g = o / (d.depth - 1 || 1), cp(l, function(C) {
        v = (C.getLayout().x + f) * p, m = (C.depth - 1) * g;
        var S = Ip(v, m);
        C.setLayout({
          x: S.x,
          y: S.y,
          rawX: v,
          rawY: m
        }, !0);
      });
    else {
      var y = e.getOrient();
      y === "RL" || y === "LR" ? (g = o / (c.getLayout().x + h + f), p = i / (d.depth - 1 || 1), cp(l, function(C) {
        m = (C.getLayout().x + f) * g, v = y === "LR" ? (C.depth - 1) * p : i - (C.depth - 1) * p, C.setLayout({
          x: v,
          y: m
        }, !0);
      })) : (y === "TB" || y === "BT") && (p = i / (c.getLayout().x + h + f), g = o / (d.depth - 1 || 1), cp(l, function(C) {
        v = (C.getLayout().x + f) * p, m = y === "TB" ? (C.depth - 1) * g : o - (C.depth - 1) * g, C.setLayout({
          x: v,
          y: m
        }, !0);
      }));
    }
  }
}
function UEe(e) {
  e.eachSeriesByType("tree", function(t) {
    var r = t.getData(), n = r.tree;
    n.eachNode(function(i) {
      var o = i.getModel(), a = o.getModel("itemStyle").getItemStyle(), s = r.ensureUniqueItemVisual(i.dataIndex, "style");
      se(s, a);
    });
  });
}
function KEe(e) {
  e.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(t, r) {
    r.eachComponent({
      mainType: "series",
      subType: "tree",
      query: t
    }, function(n) {
      var i = t.dataIndex, o = n.getData().tree, a = o.getNodeByDataIndex(i);
      a.isExpand = !a.isExpand;
    });
  }), e.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(t, r, n) {
    r.eachComponent({
      mainType: "series",
      subType: "tree",
      query: t
    }, function(i) {
      var o = i.coordinateSystem, a = bD(o, t, void 0, n);
      i.setCenter && i.setCenter(a.center), i.setZoom && i.setZoom(a.zoom);
    });
  });
}
function YEe(e) {
  e.registerChartView(IEe), e.registerSeriesModel(zEe), e.registerLayout(WEe), e.registerVisual(UEe), KEe(e);
}
var bV = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function qEe(e) {
  for (var t = 0; t < bV.length; t++)
    e.registerAction({
      type: bV[t],
      update: "updateView"
    }, Kr);
  e.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(r, n) {
    n.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: r
    }, i);
    function i(o, a) {
      var s = ["treemapZoomToNode", "treemapRootToNode"], l = Zg(r, s, o);
      if (l) {
        var u = o.getViewRoot();
        u && (r.direction = RD(u, l.node) ? "rollUp" : "drillDown"), o.resetViewRoot(l.node);
      }
    }
  });
}
function z9(e) {
  var t = e.getData(), r = t.tree, n = {};
  r.eachNode(function(i) {
    for (var o = i; o && o.depth > 1; )
      o = o.parentNode;
    var a = h_(e.ecModel, o.name || o.dataIndex + "", n);
    i.setVisual("decal", a);
  });
}
var ZEe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.preventUsingHoverLayer = !0, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      var i = {
        name: r.name,
        children: r.data
      };
      $9(i);
      var o = r.levels || [], a = this.designatedVisualItemStyle = {}, s = new cr({
        itemStyle: a
      }, this, n);
      o = r.levels = XEe(o, n);
      var l = ge(o || [], function(d) {
        return new cr(d, s, n);
      }, this), u = ED.createTree(i, this, c);
      function c(d) {
        d.wrapMethod("getItemModel", function(h, f) {
          var p = u.getNodeByDataIndex(f), g = p ? l[p.depth] : null;
          return h.parentModel = g || s, h;
        });
      }
      return u.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = this.getRawValue(r), s = o.getName(r);
      return _n("nameValue", {
        name: s,
        value: a
      });
    }, t.prototype.getDataParams = function(r) {
      var n = e.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(r);
      return n.treeAncestors = sw(i, this), n.treePathInfo = n.treeAncestors, n;
    }, t.prototype.setLayoutInfo = function(r) {
      this.layoutInfo = this.layoutInfo || {}, se(this.layoutInfo, r);
    }, t.prototype.mapIdToIndex = function(r) {
      var n = this._idIndexMap;
      n || (n = this._idIndexMap = We(), this._idIndexMapCount = 0);
      var i = n.get(r);
      return i == null && n.set(r, i = this._idIndexMapCount++), i;
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(r) {
      r ? this._viewRoot = r : r = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!r || r !== n && !n.contains(r)) && (this._viewRoot = n);
    }, t.prototype.enableAriaDecal = function() {
      z9(this);
    }, t.type = "series.treemap", t.layoutMode = "box", t.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "▶",
      // to align specialized icon. ▷▶❒❐▼✚
      zoomToNodeRatio: 0.32 * 0.32,
      scaleLimit: null,
      roam: !0,
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        top: "bottom",
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
            // '#5793f3',
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: "#fff",
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, t;
  }(hr)
);
function $9(e) {
  var t = 0;
  B(e.children, function(n) {
    $9(n);
    var i = n.value;
    fe(i) && (i = i[0]), t += i;
  });
  var r = e.value;
  fe(r) && (r = r[0]), (r == null || isNaN(r)) && (r = t), r < 0 && (r = 0), fe(e.value) ? e.value[0] = r : e.value = r;
}
function XEe(e, t) {
  var r = dr(t.get("color")), n = dr(t.get(["aria", "decal", "decals"]));
  if (r) {
    e = e || [];
    var i, o;
    B(e, function(s) {
      var l = new cr(s), u = l.get("color"), c = l.get("decal");
      (l.get(["itemStyle", "color"]) || u && u !== "none") && (i = !0), (l.get(["itemStyle", "decal"]) || c && c !== "none") && (o = !0);
    });
    var a = e[0] || (e[0] = {});
    return i || (a.color = r.slice()), !o && n && (a.decal = n.slice()), e;
  }
}
var QEe = 8, xV = 8, W1 = 5, JEe = (
  /** @class */
  function() {
    function e(t) {
      this.group = new it(), t.add(this.group);
    }
    return e.prototype.render = function(t, r, n, i) {
      var o = t.getModel("breadcrumb"), a = this.group;
      if (a.removeAll(), !(!o.get("show") || !n)) {
        var s = o.getModel("itemStyle"), l = o.getModel("emphasis"), u = s.getModel("textStyle"), c = l.getModel(["itemStyle", "textStyle"]), d = {
          pos: {
            left: o.get("left"),
            right: o.get("right"),
            top: o.get("top"),
            bottom: o.get("bottom")
          },
          box: {
            width: r.getWidth(),
            height: r.getHeight()
          },
          emptyItemWidth: o.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(n, d, u), this._renderContent(t, d, s, l, u, c, i), KS(a, d.pos, d.box);
      }
    }, e.prototype._prepare = function(t, r, n) {
      for (var i = t; i; i = i.parentNode) {
        var o = vn(i.getModel().get("name"), ""), a = n.getTextRect(o), s = Math.max(a.width + QEe * 2, r.emptyItemWidth);
        r.totalWidth += s + xV, r.renderList.push({
          node: i,
          text: o,
          width: s
        });
      }
    }, e.prototype._renderContent = function(t, r, n, i, o, a, s) {
      for (var l = 0, u = r.emptyItemWidth, c = t.get(["breadcrumb", "height"]), d = Hye(r.pos, r.box), h = r.totalWidth, f = r.renderList, p = i.getModel("itemStyle").getItemStyle(), g = f.length - 1; g >= 0; g--) {
        var v = f[g], m = v.node, y = v.width, C = v.text;
        h > d.width && (h -= y - u, y = u, C = null);
        var S = new Ei({
          shape: {
            points: eRe(l, 0, y, c, g === f.length - 1, g === 0)
          },
          style: Xe(n.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new Vt({
            style: br(o, {
              text: C
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: of * 1e4,
          onclick: dt(s, m)
        });
        S.disableLabelAnimation = !0, S.getTextContent().ensureState("emphasis").style = br(a, {
          text: C
        }), S.ensureState("emphasis").style = p, Hr(S, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(S), tRe(S, t, m), l += y + xV;
      }
    }, e.prototype.remove = function() {
      this.group.removeAll();
    }, e;
  }()
);
function eRe(e, t, r, n, i, o) {
  var a = [[i ? e : e - W1, t], [e + r, t], [e + r, t + n], [i ? e : e - W1, t + n]];
  return !o && a.splice(2, 0, [e + r + W1, t + n / 2]), !i && a.push([e, t + n / 2]), a;
}
function tRe(e, t, r) {
  ot(e).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: t.componentIndex,
    seriesIndex: t.seriesIndex,
    seriesName: t.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: r && r.dataIndex,
      name: r && r.name
    },
    treePathInfo: r && sw(r, t)
  };
}
var rRe = (
  /** @class */
  function() {
    function e() {
      this._storage = [], this._elExistsMap = {};
    }
    return e.prototype.add = function(t, r, n, i, o) {
      return this._elExistsMap[t.id] ? !1 : (this._elExistsMap[t.id] = !0, this._storage.push({
        el: t,
        target: r,
        duration: n,
        delay: i,
        easing: o
      }), !0);
    }, e.prototype.finished = function(t) {
      return this._finishedCallback = t, this;
    }, e.prototype.start = function() {
      for (var t = this, r = this._storage.length, n = function() {
        r--, r <= 0 && (t._storage.length = 0, t._elExistsMap = {}, t._finishedCallback && t._finishedCallback());
      }, i = 0, o = this._storage.length; i < o; i++) {
        var a = this._storage[i];
        a.el.animateTo(a.target, {
          duration: a.duration,
          delay: a.delay,
          easing: a.easing,
          setToFinal: !0,
          done: n,
          aborted: n
        });
      }
      return this;
    }, e;
  }()
);
function nRe() {
  return new rRe();
}
var B_ = it, EV = Bt, RV = 3, _V = "label", TV = "upperLabel", iRe = of * 10, oRe = of * 2, aRe = of * 3, Bu = Mc([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), PV = function(e) {
  var t = Bu(e);
  return t.stroke = t.fill = t.lineWidth = null, t;
}, wC = Gt(), sRe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._state = "ready", r._storage = dp(), r;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = n.findComponents({
        mainType: "series",
        subType: "treemap",
        query: o
      });
      if (!(bt(a, r) < 0)) {
        this.seriesModel = r, this.api = i, this.ecModel = n;
        var s = ["treemapZoomToNode", "treemapRootToNode"], l = Zg(o, s, r), u = o && o.type, c = r.layoutInfo, d = !this._oldTree, h = this._storage, f = u === "treemapRootToNode" && l && h ? {
          rootNodeGroup: h.nodeGroup[l.node.getRawIndex()],
          direction: o.direction
        } : null, p = this._giveContainerGroup(c), g = r.get("animation"), v = this._doRender(p, r, f);
        g && !d && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, v, r, f) : v.renderFinally(), this._resetController(i), this._renderBreadcrumb(r, i, l);
      }
    }, t.prototype._giveContainerGroup = function(r) {
      var n = this._containerGroup;
      return n || (n = this._containerGroup = new B_(), this._initEvents(n), this.group.add(n)), n.x = r.x, n.y = r.y, n;
    }, t.prototype._doRender = function(r, n, i) {
      var o = n.getData().tree, a = this._oldTree, s = dp(), l = dp(), u = this._storage, c = [];
      function d(y, C, S, b) {
        return lRe(n, l, u, i, s, c, y, C, S, b);
      }
      g(o.root ? [o.root] : [], a && a.root ? [a.root] : [], r, o === a || !a, 0);
      var h = v(u);
      if (this._oldTree = o, this._storage = l, this._controllerHost) {
        var f = this.seriesModel.layoutInfo, p = o.root.getLayout();
        p.width === f.width && p.height === f.height && (this._controllerHost.zoom = 1);
      }
      return {
        lastsForAnimation: s,
        willDeleteEls: h,
        renderFinally: m
      };
      function g(y, C, S, b, w) {
        b ? (C = y, B(y, function(R, _) {
          !R.isRemoved() && E(_, _);
        })) : new Ws(C, y, x, x).add(E).update(E).remove(dt(E, null)).execute();
        function x(R) {
          return R.getId();
        }
        function E(R, _) {
          var P = R != null ? y[R] : null, D = _ != null ? C[_] : null, I = d(P, D, S, w);
          I && g(P && P.viewChildren || [], D && D.viewChildren || [], I, b, w + 1);
        }
      }
      function v(y) {
        var C = dp();
        return y && B(y, function(S, b) {
          var w = C[b];
          B(S, function(x) {
            x && (w.push(x), wC(x).willDelete = !0);
          });
        }), C;
      }
      function m() {
        B(h, function(y) {
          B(y, function(C) {
            C.parent && C.parent.remove(C);
          });
        }), B(c, function(y) {
          y.invisible = !0, y.dirty();
        });
      }
    }, t.prototype._doAnimation = function(r, n, i, o) {
      var a = i.get("animationDurationUpdate"), s = i.get("animationEasing"), l = (Ye(a) ? 0 : a) || 0, u = (Ye(s) ? null : s) || "cubicOut", c = nRe();
      B(n.willDeleteEls, function(d, h) {
        B(d, function(f, p) {
          if (!f.invisible) {
            var g = f.parent, v, m = wC(g);
            if (o && o.direction === "drillDown")
              v = g === o.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: m.nodeWidth,
                  height: m.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var y = 0, C = 0;
              m.willDelete || (y = m.nodeWidth / 2, C = m.nodeHeight / 2), v = h === "nodeGroup" ? {
                x: y,
                y: C,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: y,
                  y: C,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            v && c.add(f, v, l, 0, u);
          }
        });
      }), B(this._storage, function(d, h) {
        B(d, function(f, p) {
          var g = n.lastsForAnimation[h][p], v = {};
          g && (f instanceof it ? g.oldX != null && (v.x = f.x, v.y = f.y, f.x = g.oldX, f.y = g.oldY) : (g.oldShape && (v.shape = se({}, f.shape), f.setShape(g.oldShape)), g.fadein ? (f.setStyle("opacity", 0), v.style = {
            opacity: 1
          }) : f.style.opacity !== 1 && (v.style = {
            opacity: 1
          })), c.add(f, v, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(ke(function() {
        this._state = "ready", n.renderFinally();
      }, this)).start();
    }, t.prototype._resetController = function(r) {
      var n = this._controller, i = this._controllerHost;
      i || (this._controllerHost = {
        target: this.group
      }, i = this._controllerHost), n || (n = this._controller = new $v(r.getZr()), n.enable(this.seriesModel.get("roam")), i.zoomLimit = this.seriesModel.get("scaleLimit"), i.zoom = this.seriesModel.get("zoom"), n.on("pan", ke(this._onPan, this)), n.on("zoom", ke(this._onZoom, this)));
      var o = new St(0, 0, r.getWidth(), r.getHeight());
      n.setPointerChecker(function(a, s, l) {
        return o.contain(s, l);
      });
    }, t.prototype._clearController = function() {
      var r = this._controller;
      this._controllerHost = null, r && (r.dispose(), r = null);
    }, t.prototype._onPan = function(r) {
      if (this._state !== "animating" && (Math.abs(r.dx) > RV || Math.abs(r.dy) > RV)) {
        var n = this.seriesModel.getData().tree.root;
        if (!n)
          return;
        var i = n.getLayout();
        if (!i)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: i.x + r.dx,
            y: i.y + r.dy,
            width: i.width,
            height: i.height
          }
        });
      }
    }, t.prototype._onZoom = function(r) {
      var n = r.originX, i = r.originY, o = r.scale;
      if (this._state !== "animating") {
        var a = this.seriesModel.getData().tree.root;
        if (!a)
          return;
        var s = a.getLayout();
        if (!s)
          return;
        var l = new St(s.x, s.y, s.width, s.height), u = null, c = this._controllerHost;
        u = c.zoomLimit;
        var d = c.zoom = c.zoom || 1;
        if (d *= o, u) {
          var h = u.min || 0, f = u.max || 1 / 0;
          d = Math.max(Math.min(f, d), h);
        }
        var p = d / c.zoom;
        c.zoom = d;
        var g = this.seriesModel.layoutInfo;
        n -= g.x, i -= g.y;
        var v = ki();
        ma(v, v, [-n, -i]), RS(v, v, [p, p]), ma(v, v, [n, i]), l.applyTransform(v), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: l.x,
            y: l.y,
            width: l.width,
            height: l.height
          }
        });
      }
    }, t.prototype._initEvents = function(r) {
      var n = this;
      r.on("click", function(i) {
        if (n._state === "ready") {
          var o = n.seriesModel.get("nodeClick", !0);
          if (o) {
            var a = n.findTarget(i.offsetX, i.offsetY);
            if (a) {
              var s = a.node;
              if (s.getLayout().isLeafRoot)
                n._rootToNode(a);
              else if (o === "zoomToNode")
                n._zoomToNode(a);
              else if (o === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", !0), c = l.get("target", !0) || "blank";
                u && tC(u, c);
              }
            }
          }
        }
      }, this);
    }, t.prototype._renderBreadcrumb = function(r, n, i) {
      var o = this;
      i || (i = r.get("leafDepth", !0) != null ? {
        node: r.getViewRoot()
      } : this.findTarget(n.getWidth() / 2, n.getHeight() / 2), i || (i = {
        node: r.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new JEe(this.group))).render(r, n, i.node, function(a) {
        o._state !== "animating" && (RD(r.getViewRoot(), a) ? o._rootToNode({
          node: a
        }) : o._zoomToNode({
          node: a
        }));
      });
    }, t.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = dp(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, t.prototype.dispose = function() {
      this._clearController();
    }, t.prototype._zoomToNode = function(r) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: r.node
      });
    }, t.prototype._rootToNode = function(r) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: r.node
      });
    }, t.prototype.findTarget = function(r, n) {
      var i, o = this.seriesModel.getViewRoot();
      return o.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(a) {
        var s = this._storage.background[a.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(r, n), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height)
            i = {
              node: a,
              offsetX: l[0],
              offsetY: l[1]
            };
          else
            return !1;
        }
      }, this), i;
    }, t.type = "treemap", t;
  }(ar)
);
function dp() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function lRe(e, t, r, n, i, o, a, s, l, u) {
  if (!a)
    return;
  var c = a.getLayout(), d = e.getData(), h = a.getModel();
  if (d.setItemGraphicEl(a.dataIndex, null), !c || !c.isInView)
    return;
  var f = c.width, p = c.height, g = c.borderWidth, v = c.invisible, m = a.getRawIndex(), y = s && s.getRawIndex(), C = a.viewChildren, S = c.upperHeight, b = C && C.length, w = h.getModel("itemStyle"), x = h.getModel(["emphasis", "itemStyle"]), E = h.getModel(["blur", "itemStyle"]), R = h.getModel(["select", "itemStyle"]), _ = w.get("borderRadius") || 0, P = $("nodeGroup", B_);
  if (!P)
    return;
  if (l.add(P), P.x = c.x || 0, P.y = c.y || 0, P.markRedraw(), wC(P).nodeWidth = f, wC(P).nodeHeight = p, c.isAboveViewRoot)
    return P;
  var D = $("background", EV, u, oRe);
  D && G(P, D, b && c.upperLabelHeight);
  var I = h.getModel("emphasis"), A = I.get("focus"), O = I.get("blurScope"), L = I.get("disabled"), N = A === "ancestor" ? a.getAncestorsIndices() : A === "descendant" ? a.getDescendantIndices() : A;
  if (b)
    jl(P) && rc(P, !1), D && (rc(D, !L), d.setItemGraphicEl(a.dataIndex, D), n_(D, N, O));
  else {
    var F = $("content", EV, u, aRe);
    F && M(P, F), D.disableMorphing = !0, D && jl(D) && rc(D, !1), rc(P, !L), d.setItemGraphicEl(a.dataIndex, P), n_(P, N, O);
  }
  return P;
  function G(U, Z, ee) {
    var J = ot(Z);
    if (J.dataIndex = a.dataIndex, J.seriesIndex = e.seriesIndex, Z.setShape({
      x: 0,
      y: 0,
      width: f,
      height: p,
      r: _
    }), v)
      V(Z);
    else {
      Z.invisible = !1;
      var X = a.getVisual("style"), Y = X.stroke, de = PV(w);
      de.fill = Y;
      var K = Bu(x);
      K.fill = x.get("borderColor");
      var ie = Bu(E);
      ie.fill = E.get("borderColor");
      var Ce = Bu(R);
      if (Ce.fill = R.get("borderColor"), ee) {
        var Te = f - 2 * g;
        z(
          // PENDING: convert ZRColor to ColorString for text.
          Z,
          Y,
          X.opacity,
          {
            x: g,
            y: 0,
            width: Te,
            height: S
          }
        );
      } else
        Z.removeTextContent();
      Z.setStyle(de), Z.ensureState("emphasis").style = K, Z.ensureState("blur").style = ie, Z.ensureState("select").style = Ce, Dc(Z);
    }
    U.add(Z);
  }
  function M(U, Z) {
    var ee = ot(Z);
    ee.dataIndex = a.dataIndex, ee.seriesIndex = e.seriesIndex;
    var J = Math.max(f - 2 * g, 0), X = Math.max(p - 2 * g, 0);
    if (Z.culling = !0, Z.setShape({
      x: g,
      y: g,
      width: J,
      height: X,
      r: _
    }), v)
      V(Z);
    else {
      Z.invisible = !1;
      var Y = a.getVisual("style"), de = Y.fill, K = PV(w);
      K.fill = de, K.decal = Y.decal;
      var ie = Bu(x), Ce = Bu(E), Te = Bu(R);
      z(Z, de, Y.opacity, null), Z.setStyle(K), Z.ensureState("emphasis").style = ie, Z.ensureState("blur").style = Ce, Z.ensureState("select").style = Te, Dc(Z);
    }
    U.add(Z);
  }
  function V(U) {
    !U.invisible && o.push(U);
  }
  function z(U, Z, ee, J) {
    var X = h.getModel(J ? TV : _V), Y = vn(h.get("name"), null), de = X.getShallow("show");
    Gn(U, Rn(h, J ? TV : _V), {
      defaultText: de ? Y : null,
      inheritColor: Z,
      defaultOpacity: ee,
      labelFetcher: e,
      labelDataIndex: a.dataIndex
    });
    var K = U.getTextContent();
    if (K) {
      var ie = K.style, Ce = xS(ie.padding || 0);
      J && (U.setTextConfig({
        layoutRect: J
      }), K.disableLabelLayout = !0), K.beforeUpdate = function() {
        var Ie = Math.max((J ? J.width : U.shape.width) - Ce[1] - Ce[3], 0), we = Math.max((J ? J.height : U.shape.height) - Ce[0] - Ce[2], 0);
        (ie.width !== Ie || ie.height !== we) && K.setStyle({
          width: Ie,
          height: we
        });
      }, ie.truncateMinChar = 2, ie.lineOverflow = "truncate", k(ie, J, c);
      var Te = K.getState("emphasis");
      k(Te ? Te.style : null, J, c);
    }
  }
  function k(U, Z, ee) {
    var J = U ? U.text : null;
    if (!Z && ee.isLeafRoot && J != null) {
      var X = e.get("drillDownIcon", !0);
      U.text = X ? X + " " + J : J;
    }
  }
  function $(U, Z, ee, J) {
    var X = y != null && r[U][y], Y = i[U];
    return X ? (r[U][y] = null, W(Y, X)) : v || (X = new Z(), X instanceof ko && (X.z2 = uRe(ee, J)), j(Y, X)), t[U][m] = X;
  }
  function W(U, Z) {
    var ee = U[m] = {};
    Z instanceof B_ ? (ee.oldX = Z.x, ee.oldY = Z.y) : ee.oldShape = se({}, Z.shape);
  }
  function j(U, Z) {
    var ee = U[m] = {}, J = a.parentNode, X = Z instanceof it;
    if (J && (!n || n.direction === "drillDown")) {
      var Y = 0, de = 0, K = i.background[J.getRawIndex()];
      !n && K && K.oldShape && (Y = K.oldShape.width, de = K.oldShape.height), X ? (ee.oldX = 0, ee.oldY = de) : ee.oldShape = {
        x: Y,
        y: de,
        width: 0,
        height: 0
      };
    }
    ee.fadein = !X;
  }
}
function uRe(e, t) {
  return e * iRe + t;
}
var Xg = B, cRe = Ze, bC = -1, xn = (
  /** @class */
  function() {
    function e(t) {
      var r = t.mappingMethod, n = t.type, i = this.option = et(t);
      this.type = n, this.mappingMethod = r, this._normalizeData = fRe[r];
      var o = e.visualHandlers[n];
      this.applyVisual = o.applyVisual, this.getColorMapper = o.getColorMapper, this._normalizedToVisual = o._normalizedToVisual[r], r === "piecewise" ? (j1(i), dRe(i)) : r === "category" ? i.categories ? hRe(i) : j1(i, !0) : (Qe(r !== "linear" || i.dataExtent), j1(i));
    }
    return e.prototype.mapValueToVisual = function(t) {
      var r = this._normalizeData(t);
      return this._normalizedToVisual(r, t);
    }, e.prototype.getNormalizer = function() {
      return ke(this._normalizeData, this);
    }, e.listVisualTypes = function() {
      return At(e.visualHandlers);
    }, e.isValidType = function(t) {
      return e.visualHandlers.hasOwnProperty(t);
    }, e.eachVisual = function(t, r, n) {
      Ze(t) ? B(t, r, n) : r.call(n, t);
    }, e.mapVisual = function(t, r, n) {
      var i, o = fe(t) ? [] : Ze(t) ? {} : (i = !0, null);
      return e.eachVisual(t, function(a, s) {
        var l = r.call(n, a, s);
        i ? o = l : o[s] = l;
      }), o;
    }, e.retrieveVisuals = function(t) {
      var r = {}, n;
      return t && Xg(e.visualHandlers, function(i, o) {
        t.hasOwnProperty(o) && (r[o] = t[o], n = !0);
      }), n ? r : null;
    }, e.prepareVisualTypes = function(t) {
      if (fe(t))
        t = t.slice();
      else if (cRe(t)) {
        var r = [];
        Xg(t, function(n, i) {
          r.push(i);
        }), t = r;
      } else
        return [];
      return t.sort(function(n, i) {
        return i === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, e.dependsOn = function(t, r) {
      return r === "color" ? !!(t && t.indexOf(r) === 0) : t === r;
    }, e.findPieceIndex = function(t, r, n) {
      for (var i, o = 1 / 0, a = 0, s = r.length; a < s; a++) {
        var l = r[a].value;
        if (l != null) {
          if (l === t || Fe(l) && l === t + "")
            return a;
          n && h(l, a);
        }
      }
      for (var a = 0, s = r.length; a < s; a++) {
        var u = r[a], c = u.interval, d = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (dy(d[1], t, c[1]))
              return a;
          } else if (c[1] === 1 / 0) {
            if (dy(d[0], c[0], t))
              return a;
          } else if (dy(d[0], c[0], t) && dy(d[1], t, c[1]))
            return a;
          n && h(c[0], a), n && h(c[1], a);
        }
      }
      if (n)
        return t === 1 / 0 ? r.length - 1 : t === -1 / 0 ? 0 : i;
      function h(f, p) {
        var g = Math.abs(f - t);
        g < o && (o = g, i = p);
      }
    }, e.visualHandlers = {
      color: {
        applyVisual: hp("color"),
        getColorMapper: function() {
          var t = this.option;
          return ke(t.mappingMethod === "category" ? function(r, n) {
            return !n && (r = this._normalizeData(r)), Fp.call(this, r);
          } : function(r, n, i) {
            var o = !!i;
            return !n && (r = this._normalizeData(r)), i = Zp(r, t.parsedVisual, i), o ? i : ha(i, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return ha(Zp(t, this.option.parsedVisual), "rgba");
          },
          category: Fp,
          piecewise: function(t, r) {
            var n = H_.call(this, r);
            return n == null && (n = ha(Zp(t, this.option.parsedVisual), "rgba")), n;
          },
          fixed: Gu
        }
      },
      colorHue: cy(function(t, r) {
        return ph(t, r);
      }),
      colorSaturation: cy(function(t, r) {
        return ph(t, null, r);
      }),
      colorLightness: cy(function(t, r) {
        return ph(t, null, null, r);
      }),
      colorAlpha: cy(function(t, r) {
        return Lg(t, r);
      }),
      decal: {
        applyVisual: hp("decal"),
        _normalizedToVisual: {
          linear: null,
          category: Fp,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: hp("opacity"),
        _normalizedToVisual: G_([0, 1])
      },
      liftZ: {
        applyVisual: hp("liftZ"),
        _normalizedToVisual: {
          linear: Gu,
          category: Gu,
          piecewise: Gu,
          fixed: Gu
        }
      },
      symbol: {
        applyVisual: function(t, r, n) {
          var i = this.mapValueToVisual(t);
          n("symbol", i);
        },
        _normalizedToVisual: {
          linear: MV,
          category: Fp,
          piecewise: function(t, r) {
            var n = H_.call(this, r);
            return n == null && (n = MV.call(this, t)), n;
          },
          fixed: Gu
        }
      },
      symbolSize: {
        applyVisual: hp("symbolSize"),
        _normalizedToVisual: G_([0, 1])
      }
    }, e;
  }()
);
function dRe(e) {
  var t = e.pieceList;
  e.hasSpecialVisual = !1, B(t, function(r, n) {
    r.originIndex = n, r.visual != null && (e.hasSpecialVisual = !0);
  });
}
function hRe(e) {
  var t = e.categories, r = e.categoryMap = {}, n = e.visual;
  if (Xg(t, function(a, s) {
    r[a] = s;
  }), !fe(n)) {
    var i = [];
    Ze(n) ? Xg(n, function(a, s) {
      var l = r[s];
      i[l ?? bC] = a;
    }) : i[bC] = n, n = W9(e, i);
  }
  for (var o = t.length - 1; o >= 0; o--)
    n[o] == null && (delete r[t[o]], t.pop());
}
function j1(e, t) {
  var r = e.visual, n = [];
  Ze(r) ? Xg(r, function(o) {
    n.push(o);
  }) : r != null && n.push(r);
  var i = {
    color: 1,
    symbol: 1
  };
  !t && n.length === 1 && !i.hasOwnProperty(e.type) && (n[1] = n[0]), W9(e, n);
}
function cy(e) {
  return {
    applyVisual: function(t, r, n) {
      var i = this.mapValueToVisual(t);
      n("color", e(r("color"), i));
    },
    _normalizedToVisual: G_([0, 1])
  };
}
function MV(e) {
  var t = this.option.visual;
  return t[Math.round(nr(e, [0, 1], [0, t.length - 1], !0))] || {};
}
function hp(e) {
  return function(t, r, n) {
    n(e, this.mapValueToVisual(t));
  };
}
function Fp(e) {
  var t = this.option.visual;
  return t[this.option.loop && e !== bC ? e % t.length : e];
}
function Gu() {
  return this.option.visual[0];
}
function G_(e) {
  return {
    linear: function(t) {
      return nr(t, e, this.option.visual, !0);
    },
    category: Fp,
    piecewise: function(t, r) {
      var n = H_.call(this, r);
      return n == null && (n = nr(t, e, this.option.visual, !0)), n;
    },
    fixed: Gu
  };
}
function H_(e) {
  var t = this.option, r = t.pieceList;
  if (t.hasSpecialVisual) {
    var n = xn.findPieceIndex(e, r), i = r[n];
    if (i && i.visual)
      return i.visual[this.type];
  }
}
function W9(e, t) {
  return e.visual = t, e.type === "color" && (e.parsedVisual = ge(t, function(r) {
    var n = yi(r);
    return !n && process.env.NODE_ENV !== "production" && Vr("'" + r + "' is an illegal color, fallback to '#000000'", !0), n || [0, 0, 0, 1];
  })), t;
}
var fRe = {
  linear: function(e) {
    return nr(e, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(e) {
    var t = this.option.pieceList, r = xn.findPieceIndex(e, t, !0);
    if (r != null)
      return nr(r, [0, t.length - 1], [0, 1], !0);
  },
  category: function(e) {
    var t = this.option.categories ? this.option.categoryMap[e] : e;
    return t ?? bC;
  },
  fixed: Kr
};
function dy(e, t, r) {
  return e ? t <= r : t < r;
}
var pRe = "itemStyle", j9 = Gt();
const gRe = {
  seriesType: "treemap",
  reset: function(e) {
    var t = e.getData().tree, r = t.root;
    r.isRemoved() || U9(
      r,
      // Visual should calculate from tree root but not view root.
      {},
      e.getViewRoot().getAncestors(),
      e
    );
  }
};
function U9(e, t, r, n) {
  var i = e.getModel(), o = e.getLayout(), a = e.hostTree.data;
  if (!(!o || o.invisible || !o.isInView)) {
    var s = i.getModel(pRe), l = vRe(s, t, n), u = a.ensureUniqueItemVisual(e.dataIndex, "style"), c = s.get("borderColor"), d = s.get("borderColorSaturation"), h;
    d != null && (h = DV(l), c = mRe(d, h)), u.stroke = c;
    var f = e.viewChildren;
    if (!f || !f.length)
      h = DV(l), u.fill = h;
    else {
      var p = yRe(e, i, o, s, l, f);
      B(f, function(g, v) {
        if (g.depth >= r.length || g === r[g.depth]) {
          var m = CRe(i, l, g, v, p, n);
          U9(g, m, r, n);
        }
      });
    }
  }
}
function vRe(e, t, r) {
  var n = se({}, t), i = r.designatedVisualItemStyle;
  return B(["color", "colorAlpha", "colorSaturation"], function(o) {
    i[o] = t[o];
    var a = e.get(o);
    i[o] = null, a != null && (n[o] = a);
  }), n;
}
function DV(e) {
  var t = U1(e, "color");
  if (t) {
    var r = U1(e, "colorAlpha"), n = U1(e, "colorSaturation");
    return n && (t = ph(t, null, null, n)), r && (t = Lg(t, r)), t;
  }
}
function mRe(e, t) {
  return t != null ? ph(t, null, null, e) : null;
}
function U1(e, t) {
  var r = e[t];
  if (r != null && r !== "none")
    return r;
}
function yRe(e, t, r, n, i, o) {
  if (!(!o || !o.length)) {
    var a = K1(t, "color") || i.color != null && i.color !== "none" && (K1(t, "colorAlpha") || K1(t, "colorSaturation"));
    if (a) {
      var s = t.get("visualMin"), l = t.get("visualMax"), u = r.dataExtent.slice();
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
      var c = t.get("colorMappingBy"), d = {
        type: a.name,
        dataExtent: u,
        visual: a.range
      };
      d.type === "color" && (c === "index" || c === "id") ? (d.mappingMethod = "category", d.loop = !0) : d.mappingMethod = "linear";
      var h = new xn(d);
      return j9(h).drColorMappingBy = c, h;
    }
  }
}
function K1(e, t) {
  var r = e.get(t);
  return fe(r) && r.length ? {
    name: t,
    range: r
  } : null;
}
function CRe(e, t, r, n, i, o) {
  var a = se({}, t);
  if (i) {
    var s = i.type, l = s === "color" && j9(i).drColorMappingBy, u = l === "index" ? n : l === "id" ? o.mapIdToIndex(r.getId()) : r.getValue(e.get("visualDimension"));
    a[s] = i.mapValueToVisual(u);
  }
  return a;
}
var Qg = Math.max, xC = Math.min, AV = tn, _D = B, K9 = ["itemStyle", "borderWidth"], SRe = ["itemStyle", "gapWidth"], wRe = ["upperLabel", "show"], bRe = ["upperLabel", "height"];
const xRe = {
  seriesType: "treemap",
  reset: function(e, t, r, n) {
    var i = r.getWidth(), o = r.getHeight(), a = e.option, s = hn(e.getBoxLayoutParams(), {
      width: r.getWidth(),
      height: r.getHeight()
    }), l = a.size || [], u = Ae(AV(s.width, l[0]), i), c = Ae(AV(s.height, l[1]), o), d = n && n.type, h = ["treemapZoomToNode", "treemapRootToNode"], f = Zg(n, h, e), p = d === "treemapRender" || d === "treemapMove" ? n.rootRect : null, g = e.getViewRoot(), v = H9(g);
    if (d !== "treemapMove") {
      var m = d === "treemapZoomToNode" ? MRe(e, f, g, u, c) : p ? [p.width, p.height] : [u, c], y = a.sort;
      y && y !== "asc" && y !== "desc" && (y = "desc");
      var C = {
        squareRatio: a.squareRatio,
        sort: y,
        leafDepth: a.leafDepth
      };
      g.hostTree.clearLayouts();
      var S = {
        x: 0,
        y: 0,
        width: m[0],
        height: m[1],
        area: m[0] * m[1]
      };
      g.setLayout(S), Y9(g, C, !1, 0), S = g.getLayout(), _D(v, function(w, x) {
        var E = (v[x + 1] || g).getValue();
        w.setLayout(se({
          dataExtent: [E, E],
          borderWidth: 0,
          upperHeight: 0
        }, S));
      });
    }
    var b = e.getData().tree.root;
    b.setLayout(DRe(s, p, f), !0), e.setLayoutInfo(s), q9(
      b,
      // Transform to base element coordinate system.
      new St(-s.x, -s.y, i, o),
      v,
      g,
      0
    );
  }
};
function Y9(e, t, r, n) {
  var i, o;
  if (!e.isRemoved()) {
    var a = e.getLayout();
    i = a.width, o = a.height;
    var s = e.getModel(), l = s.get(K9), u = s.get(SRe) / 2, c = Z9(s), d = Math.max(l, c), h = l - u, f = d - u;
    e.setLayout({
      borderWidth: l,
      upperHeight: d,
      upperLabelHeight: c
    }, !0), i = Qg(i - 2 * h, 0), o = Qg(o - h - f, 0);
    var p = i * o, g = ERe(e, s, p, t, r, n);
    if (g.length) {
      var v = {
        x: h,
        y: f,
        width: i,
        height: o
      }, m = xC(i, o), y = 1 / 0, C = [];
      C.area = 0;
      for (var S = 0, b = g.length; S < b; ) {
        var w = g[S];
        C.push(w), C.area += w.getLayout().area;
        var x = PRe(C, m, t.squareRatio);
        x <= y ? (S++, y = x) : (C.area -= C.pop().getLayout().area, IV(C, m, v, u, !1), m = xC(v.width, v.height), C.length = C.area = 0, y = 1 / 0);
      }
      if (C.length && IV(C, m, v, u, !0), !r) {
        var E = s.get("childrenVisibleMin");
        E != null && p < E && (r = !0);
      }
      for (var S = 0, b = g.length; S < b; S++)
        Y9(g[S], t, r, n + 1);
    }
  }
}
function ERe(e, t, r, n, i, o) {
  var a = e.children || [], s = n.sort;
  s !== "asc" && s !== "desc" && (s = null);
  var l = n.leafDepth != null && n.leafDepth <= o;
  if (i && !l)
    return e.viewChildren = [];
  a = ir(a, function(f) {
    return !f.isRemoved();
  }), _Re(a, s);
  var u = TRe(t, a, s);
  if (u.sum === 0)
    return e.viewChildren = [];
  if (u.sum = RRe(t, r, u.sum, s, a), u.sum === 0)
    return e.viewChildren = [];
  for (var c = 0, d = a.length; c < d; c++) {
    var h = a[c].getValue() / u.sum * r;
    a[c].setLayout({
      area: h
    });
  }
  return l && (a.length && e.setLayout({
    isLeafRoot: !0
  }, !0), a.length = 0), e.viewChildren = a, e.setLayout({
    dataExtent: u.dataExtent
  }, !0), a;
}
function RRe(e, t, r, n, i) {
  if (!n)
    return r;
  for (var o = e.get("visibleMin"), a = i.length, s = a, l = a - 1; l >= 0; l--) {
    var u = i[n === "asc" ? a - l - 1 : l].getValue();
    u / r * t < o && (s = l, r -= u);
  }
  return n === "asc" ? i.splice(0, a - s) : i.splice(s, a - s), r;
}
function _Re(e, t) {
  return t && e.sort(function(r, n) {
    var i = t === "asc" ? r.getValue() - n.getValue() : n.getValue() - r.getValue();
    return i === 0 ? t === "asc" ? r.dataIndex - n.dataIndex : n.dataIndex - r.dataIndex : i;
  }), e;
}
function TRe(e, t, r) {
  for (var n = 0, i = 0, o = t.length; i < o; i++)
    n += t[i].getValue();
  var a = e.get("visualDimension"), s;
  return !t || !t.length ? s = [NaN, NaN] : a === "value" && r ? (s = [t[t.length - 1].getValue(), t[0].getValue()], r === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], _D(t, function(l) {
    var u = l.getValue(a);
    u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
  })), {
    sum: n,
    dataExtent: s
  };
}
function PRe(e, t, r) {
  for (var n = 0, i = 1 / 0, o = 0, a = void 0, s = e.length; o < s; o++)
    a = e[o].getLayout().area, a && (a < i && (i = a), a > n && (n = a));
  var l = e.area * e.area, u = t * t * r;
  return l ? Qg(u * n / l, l / (u * i)) : 1 / 0;
}
function IV(e, t, r, n, i) {
  var o = t === r.width ? 0 : 1, a = 1 - o, s = ["x", "y"], l = ["width", "height"], u = r[s[o]], c = t ? e.area / t : 0;
  (i || c > r[l[a]]) && (c = r[l[a]]);
  for (var d = 0, h = e.length; d < h; d++) {
    var f = e[d], p = {}, g = c ? f.getLayout().area / c : 0, v = p[l[a]] = Qg(c - 2 * n, 0), m = r[s[o]] + r[l[o]] - u, y = d === h - 1 || m < g ? m : g, C = p[l[o]] = Qg(y - 2 * n, 0);
    p[s[a]] = r[s[a]] + xC(n, v / 2), p[s[o]] = u + xC(n, C / 2), u += y, f.setLayout(p, !0);
  }
  r[s[a]] += c, r[l[a]] -= c;
}
function MRe(e, t, r, n, i) {
  var o = (t || {}).node, a = [n, i];
  if (!o || o === r)
    return a;
  for (var s, l = n * i, u = l * e.option.zoomToNodeRatio; s = o.parentNode; ) {
    for (var c = 0, d = s.children, h = 0, f = d.length; h < f; h++)
      c += d[h].getValue();
    var p = o.getValue();
    if (p === 0)
      return a;
    u *= c / p;
    var g = s.getModel(), v = g.get(K9), m = Math.max(v, Z9(g));
    u += 4 * v * v + (3 * v + m) * Math.pow(u, 0.5), u > YR && (u = YR), o = s;
  }
  u < l && (u = l);
  var y = Math.pow(u / l, 0.5);
  return [n * y, i * y];
}
function DRe(e, t, r) {
  if (t)
    return {
      x: t.x,
      y: t.y
    };
  var n = {
    x: 0,
    y: 0
  };
  if (!r)
    return n;
  var i = r.node, o = i.getLayout();
  if (!o)
    return n;
  for (var a = [o.width / 2, o.height / 2], s = i; s; ) {
    var l = s.getLayout();
    a[0] += l.x, a[1] += l.y, s = s.parentNode;
  }
  return {
    x: e.width / 2 - a[0],
    y: e.height / 2 - a[1]
  };
}
function q9(e, t, r, n, i) {
  var o = e.getLayout(), a = r[i], s = a && a === e;
  if (!(a && !s || i === r.length && e !== n)) {
    e.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !s && !t.intersect(o),
      isAboveViewRoot: s
    }, !0);
    var l = new St(t.x - o.x, t.y - o.y, t.width, t.height);
    _D(e.viewChildren || [], function(u) {
      q9(u, l, r, n, i + 1);
    });
  }
}
function Z9(e) {
  return e.get(wRe) ? e.get(bRe) : 0;
}
function ARe(e) {
  e.registerSeriesModel(ZEe), e.registerChartView(sRe), e.registerVisual(gRe), e.registerLayout(xRe), qEe(e);
}
function IRe(e) {
  var t = e.findComponents({
    mainType: "legend"
  });
  !t || !t.length || e.eachSeriesByType("graph", function(r) {
    var n = r.getCategoriesData(), i = r.getGraph(), o = i.data, a = n.mapArray(n.getName);
    o.filterSelf(function(s) {
      var l = o.getItemModel(s), u = l.getShallow("category");
      if (u != null) {
        $t(u) && (u = a[u]);
        for (var c = 0; c < t.length; c++)
          if (!t[c].isSelected(u))
            return !1;
      }
      return !0;
    });
  });
}
function FRe(e) {
  var t = {};
  e.eachSeriesByType("graph", function(r) {
    var n = r.getCategoriesData(), i = r.getData(), o = {};
    n.each(function(a) {
      var s = n.getName(a);
      o["ec-" + s] = a;
      var l = n.getItemModel(a), u = l.getModel("itemStyle").getItemStyle();
      u.fill || (u.fill = r.getColorFromPalette(s, t)), n.setItemVisual(a, "style", u);
      for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], d = 0; d < c.length; d++) {
        var h = l.getShallow(c[d], !0);
        h != null && n.setItemVisual(a, c[d], h);
      }
    }), n.count() && i.each(function(a) {
      var s = i.getItemModel(a), l = s.getShallow("category");
      if (l != null) {
        Fe(l) && (l = o["ec-" + l]);
        var u = n.getItemVisual(l, "style"), c = i.ensureUniqueItemVisual(a, "style");
        se(c, u);
        for (var d = ["symbol", "symbolSize", "symbolKeepAspect"], h = 0; h < d.length; h++)
          i.setItemVisual(a, d[h], n.getItemVisual(l, d[h]));
      }
    });
  });
}
function hy(e) {
  return e instanceof Array || (e = [e, e]), e;
}
function LRe(e) {
  e.eachSeriesByType("graph", function(t) {
    var r = t.getGraph(), n = t.getEdgeData(), i = hy(t.get("edgeSymbol")), o = hy(t.get("edgeSymbolSize"));
    n.setVisual("fromSymbol", i && i[0]), n.setVisual("toSymbol", i && i[1]), n.setVisual("fromSymbolSize", o && o[0]), n.setVisual("toSymbolSize", o && o[1]), n.setVisual("style", t.getModel("lineStyle").getLineStyle()), n.each(function(a) {
      var s = n.getItemModel(a), l = r.getEdgeByIndex(a), u = hy(s.getShallow("symbol", !0)), c = hy(s.getShallow("symbolSize", !0)), d = s.getModel("lineStyle").getLineStyle(), h = n.ensureUniqueItemVisual(a, "style");
      switch (se(h, d), h.stroke) {
        case "source": {
          var f = l.node1.getVisual("style");
          h.stroke = f && f.fill;
          break;
        }
        case "target": {
          var f = l.node2.getVisual("style");
          h.stroke = f && f.fill;
          break;
        }
      }
      u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
    });
  });
}
var z_ = "-->", lw = function(e) {
  return e.get("autoCurveness") || null;
}, X9 = function(e, t) {
  var r = lw(e), n = 20, i = [];
  if ($t(r))
    n = r;
  else if (fe(r)) {
    e.__curvenessList = r;
    return;
  }
  t > n && (n = t);
  var o = n % 2 ? n + 2 : n + 3;
  i = [];
  for (var a = 0; a < o; a++)
    i.push((a % 2 ? a + 1 : a) / 10 * (a % 2 ? -1 : 1));
  e.__curvenessList = i;
}, Jg = function(e, t, r) {
  var n = [e.id, e.dataIndex].join("."), i = [t.id, t.dataIndex].join(".");
  return [r.uid, n, i].join(z_);
}, Q9 = function(e) {
  var t = e.split(z_);
  return [t[0], t[2], t[1]].join(z_);
}, ORe = function(e, t) {
  var r = Jg(e.node1, e.node2, t);
  return t.__edgeMap[r];
}, NRe = function(e, t) {
  var r = $_(Jg(e.node1, e.node2, t), t), n = $_(Jg(e.node2, e.node1, t), t);
  return r + n;
}, $_ = function(e, t) {
  var r = t.__edgeMap;
  return r[e] ? r[e].length : 0;
};
function kRe(e) {
  lw(e) && (e.__curvenessList = [], e.__edgeMap = {}, X9(e));
}
function VRe(e, t, r, n) {
  if (lw(r)) {
    var i = Jg(e, t, r), o = r.__edgeMap, a = o[Q9(i)];
    o[i] && !a ? o[i].isForward = !0 : a && o[i] && (a.isForward = !0, o[i].isForward = !1), o[i] = o[i] || [], o[i].push(n);
  }
}
function TD(e, t, r, n) {
  var i = lw(t), o = fe(i);
  if (!i)
    return null;
  var a = ORe(e, t);
  if (!a)
    return null;
  for (var s = -1, l = 0; l < a.length; l++)
    if (a[l] === r) {
      s = l;
      break;
    }
  var u = NRe(e, t);
  X9(t, u), e.lineStyle = e.lineStyle || {};
  var c = Jg(e.node1, e.node2, t), d = t.__curvenessList, h = o || u % 2 ? 0 : 1;
  if (a.isForward)
    return d[h + s];
  var f = Q9(c), p = $_(f, t), g = d[s + p + h];
  return n ? o ? i && i[0] === 0 ? (p + h) % 2 ? g : -g : ((p % 2 ? 0 : 1) + h) % 2 ? g : -g : (p + h) % 2 ? g : -g : d[s + p + h];
}
function J9(e) {
  var t = e.coordinateSystem;
  if (!(t && t.type !== "view")) {
    var r = e.getGraph();
    r.eachNode(function(n) {
      var i = n.getModel();
      n.setLayout([+i.get("x"), +i.get("y")]);
    }), PD(r, e);
  }
}
function PD(e, t) {
  e.eachEdge(function(r, n) {
    var i = ro(r.getModel().get(["lineStyle", "curveness"]), -TD(r, t, n, !0), 0), o = Ua(r.node1.getLayout()), a = Ua(r.node2.getLayout()), s = [o, a];
    +i && s.push([(o[0] + a[0]) / 2 - (o[1] - a[1]) * i, (o[1] + a[1]) / 2 - (a[0] - o[0]) * i]), r.setLayout(s);
  });
}
function BRe(e, t) {
  e.eachSeriesByType("graph", function(r) {
    var n = r.get("layout"), i = r.coordinateSystem;
    if (i && i.type !== "view") {
      var o = r.getData(), a = [];
      B(i.dimensions, function(h) {
        a = a.concat(o.mapDimensionsAll(h));
      });
      for (var s = 0; s < o.count(); s++) {
        for (var l = [], u = !1, c = 0; c < a.length; c++) {
          var d = o.get(a[c], s);
          isNaN(d) || (u = !0), l.push(d);
        }
        u ? o.setItemLayout(s, i.dataToPoint(l)) : o.setItemLayout(s, [NaN, NaN]);
      }
      PD(o.graph, r);
    } else (!n || n === "none") && J9(r);
  });
}
function Lp(e) {
  var t = e.coordinateSystem;
  if (t.type !== "view")
    return 1;
  var r = e.option.nodeScaleRatio, n = t.scaleX, i = t.getZoom(), o = (i - 1) * r + 1;
  return o / n;
}
function Op(e) {
  var t = e.getVisual("symbolSize");
  return t instanceof Array && (t = (t[0] + t[1]) / 2), +t;
}
var FV = Math.PI, Y1 = [];
function MD(e, t, r, n) {
  var i = e.coordinateSystem;
  if (!(i && i.type !== "view")) {
    var o = i.getBoundingRect(), a = e.getData(), s = a.graph, l = o.width / 2 + o.x, u = o.height / 2 + o.y, c = Math.min(o.width, o.height) / 2, d = a.count();
    if (a.setLayout({
      cx: l,
      cy: u
    }), !!d) {
      if (r) {
        var h = i.pointToData(n), f = h[0], p = h[1], g = [f - l, p - u];
        $c(g, g), Kp(g, g, c), r.setLayout([l + g[0], u + g[1]], !0);
        var v = e.get(["circular", "rotateLabel"]);
        ej(r, v, l, u);
      }
      GRe[t](e, s, a, c, l, u, d), s.eachEdge(function(m, y) {
        var C = ro(m.getModel().get(["lineStyle", "curveness"]), TD(m, e, y), 0), S = Ua(m.node1.getLayout()), b = Ua(m.node2.getLayout()), w, x = (S[0] + b[0]) / 2, E = (S[1] + b[1]) / 2;
        +C && (C *= 3, w = [l * C + x * (1 - C), u * C + E * (1 - C)]), m.setLayout([S, b, w]);
      });
    }
  }
}
var GRe = {
  value: function(e, t, r, n, i, o, a) {
    var s = 0, l = r.getSum("value"), u = Math.PI * 2 / (l || a);
    t.eachNode(function(c) {
      var d = c.getValue("value"), h = u * (l ? d : 1) / 2;
      s += h, c.setLayout([n * Math.cos(s) + i, n * Math.sin(s) + o]), s += h;
    });
  },
  symbolSize: function(e, t, r, n, i, o, a) {
    var s = 0;
    Y1.length = a;
    var l = Lp(e);
    t.eachNode(function(d) {
      var h = Op(d);
      isNaN(h) && (h = 2), h < 0 && (h = 0), h *= l;
      var f = Math.asin(h / 2 / n);
      isNaN(f) && (f = FV / 2), Y1[d.dataIndex] = f, s += f * 2;
    });
    var u = (2 * FV - s) / a / 2, c = 0;
    t.eachNode(function(d) {
      var h = u + Y1[d.dataIndex];
      c += h, (!d.getLayout() || !d.getLayout().fixed) && d.setLayout([n * Math.cos(c) + i, n * Math.sin(c) + o]), c += h;
    });
  }
};
function ej(e, t, r, n) {
  var i = e.getGraphicEl();
  if (i) {
    var o = e.getModel(), a = o.get(["label", "rotate"]) || 0, s = i.getSymbolPath();
    if (t) {
      var l = e.getLayout(), u = Math.atan2(l[1] - n, l[0] - r);
      u < 0 && (u = Math.PI * 2 + u);
      var c = l[0] < r;
      c && (u = u - Math.PI);
      var d = c ? "left" : "right";
      s.setTextConfig({
        rotation: -u,
        position: d,
        origin: "center"
      });
      var h = s.ensureState("emphasis");
      se(h.textConfig || (h.textConfig = {}), {
        position: d
      });
    } else
      s.setTextConfig({
        rotation: a *= Math.PI / 180
      });
  }
}
function HRe(e) {
  e.eachSeriesByType("graph", function(t) {
    t.get("layout") === "circular" && MD(t, "symbolSize");
  });
}
var Ad = k0;
function zRe(e, t, r) {
  for (var n = e, i = t, o = r.rect, a = o.width, s = o.height, l = [o.x + a / 2, o.y + s / 2], u = r.gravity == null ? 0.1 : r.gravity, c = 0; c < n.length; c++) {
    var d = n[c];
    d.p || (d.p = ru(a * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), d.pp = Ua(d.p), d.edges = null;
  }
  var h = r.friction == null ? 0.6 : r.friction, f = h, p, g;
  return {
    warmUp: function() {
      f = h * 0.8;
    },
    setFixed: function(v) {
      n[v].fixed = !0;
    },
    setUnfixed: function(v) {
      n[v].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(v) {
      p = v;
    },
    /**
     * After step hook
     */
    afterStep: function(v) {
      g = v;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(v) {
      p && p(n, i);
      for (var m = [], y = n.length, C = 0; C < i.length; C++) {
        var S = i[C];
        if (!S.ignoreForceLayout) {
          var b = S.n1, w = S.n2;
          El(m, w.p, b.p);
          var x = Ag(m) - S.d, E = w.w / (b.w + w.w);
          isNaN(E) && (E = 0), $c(m, m), !b.fixed && Ad(b.p, b.p, m, E * x * f), !w.fixed && Ad(w.p, w.p, m, -(1 - E) * x * f);
        }
      }
      for (var C = 0; C < y; C++) {
        var R = n[C];
        R.fixed || (El(m, l, R.p), Ad(R.p, R.p, m, u * f));
      }
      for (var C = 0; C < y; C++)
        for (var b = n[C], _ = C + 1; _ < y; _++) {
          var w = n[_];
          El(m, w.p, b.p);
          var x = Ag(m);
          x === 0 && (X3(m, Math.random() - 0.5, Math.random() - 0.5), x = 1);
          var P = (b.rep + w.rep) / x / x;
          !b.fixed && Ad(b.pp, b.pp, m, P), !w.fixed && Ad(w.pp, w.pp, m, -P);
        }
      for (var D = [], C = 0; C < y; C++) {
        var R = n[C];
        R.fixed || (El(D, R.p, R.pp), Ad(R.p, R.p, D, f), Kn(R.pp, R.p));
      }
      f = f * 0.992;
      var I = f < 0.01;
      g && g(n, i, I), v && v(I);
    }
  };
}
function $Re(e) {
  e.eachSeriesByType("graph", function(t) {
    var r = t.coordinateSystem;
    if (!(r && r.type !== "view"))
      if (t.get("layout") === "force") {
        var n = t.preservedPoints || {}, i = t.getGraph(), o = i.data, a = i.edgeData, s = t.getModel("force"), l = s.get("initLayout");
        t.preservedPoints ? o.each(function(C) {
          var S = o.getId(C);
          o.setItemLayout(C, n[S] || [NaN, NaN]);
        }) : !l || l === "none" ? J9(t) : l === "circular" && MD(t, "value");
        var u = o.getDataExtent("value"), c = a.getDataExtent("value"), d = s.get("repulsion"), h = s.get("edgeLength"), f = fe(d) ? d : [d, d], p = fe(h) ? h : [h, h];
        p = [p[1], p[0]];
        var g = o.mapArray("value", function(C, S) {
          var b = o.getItemLayout(S), w = nr(C, u, f);
          return isNaN(w) && (w = (f[0] + f[1]) / 2), {
            w,
            rep: w,
            fixed: o.getItemModel(S).get("fixed"),
            p: !b || isNaN(b[0]) || isNaN(b[1]) ? null : b
          };
        }), v = a.mapArray("value", function(C, S) {
          var b = i.getEdgeByIndex(S), w = nr(C, c, p);
          isNaN(w) && (w = (p[0] + p[1]) / 2);
          var x = b.getModel(), E = ro(b.getModel().get(["lineStyle", "curveness"]), -TD(b, t, S, !0), 0);
          return {
            n1: g[b.node1.dataIndex],
            n2: g[b.node2.dataIndex],
            d: w,
            curveness: E,
            ignoreForceLayout: x.get("ignoreForceLayout")
          };
        }), m = r.getBoundingRect(), y = zRe(g, v, {
          rect: m,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        y.beforeStep(function(C, S) {
          for (var b = 0, w = C.length; b < w; b++)
            C[b].fixed && Kn(C[b].p, i.getNodeByIndex(b).getLayout());
        }), y.afterStep(function(C, S, b) {
          for (var w = 0, x = C.length; w < x; w++)
            C[w].fixed || i.getNodeByIndex(w).setLayout(C[w].p), n[o.getId(w)] = C[w].p;
          for (var w = 0, x = S.length; w < x; w++) {
            var E = S[w], R = i.getEdgeByIndex(w), _ = E.n1.p, P = E.n2.p, D = R.getLayout();
            D = D ? D.slice() : [], D[0] = D[0] || [], D[1] = D[1] || [], Kn(D[0], _), Kn(D[1], P), +E.curveness && (D[2] = [(_[0] + P[0]) / 2 - (_[1] - P[1]) * E.curveness, (_[1] + P[1]) / 2 - (P[0] - _[0]) * E.curveness]), R.setLayout(D);
          }
        }), t.forceLayout = y, t.preservedPoints = n, y.step();
      } else
        t.forceLayout = null;
  });
}
function WRe(e, t, r) {
  var n = se(e.getBoxLayoutParams(), {
    aspect: r
  });
  return hn(n, {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function jRe(e, t) {
  var r = [];
  return e.eachSeriesByType("graph", function(n) {
    var i = n.get("coordinateSystem");
    if (!i || i === "view") {
      var o = n.getData(), a = o.mapArray(function(v) {
        var m = o.getItemModel(v);
        return [+m.get("x"), +m.get("y")];
      }), s = [], l = [];
      LS(a, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
      var u = (l[0] - s[0]) / (l[1] - s[1]), c = WRe(n, t, u);
      isNaN(u) && (s = [c.x, c.y], l = [c.x + c.width, c.y + c.height]);
      var d = l[0] - s[0], h = l[1] - s[1], f = c.width, p = c.height, g = n.coordinateSystem = new Wv();
      g.zoomLimit = n.get("scaleLimit"), g.setBoundingRect(s[0], s[1], d, h), g.setViewRect(c.x, c.y, f, p), g.setCenter(n.get("center"), t), g.setZoom(n.get("zoom")), r.push(g);
    }
  }), r;
}
var LV = wn.prototype, q1 = Av.prototype, tj = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return e;
  }()
);
(function(e) {
  ne(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t;
})(tj);
function Z1(e) {
  return isNaN(+e.cpx1) || isNaN(+e.cpy1);
}
var URe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "ec-line", n;
    }
    return t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new tj();
    }, t.prototype.buildPath = function(r, n) {
      Z1(n) ? LV.buildPath.call(this, r, n) : q1.buildPath.call(this, r, n);
    }, t.prototype.pointAt = function(r) {
      return Z1(this.shape) ? LV.pointAt.call(this, r) : q1.pointAt.call(this, r);
    }, t.prototype.tangentAt = function(r) {
      var n = this.shape, i = Z1(n) ? [n.x2 - n.x1, n.y2 - n.y1] : q1.tangentAt.call(this, r);
      return $c(i, i);
    }, t;
  }(Mt)
), X1 = ["fromSymbol", "toSymbol"];
function OV(e) {
  return "_" + e + "Type";
}
function NV(e, t, r) {
  var n = t.getItemVisual(r, e);
  if (!n || n === "none")
    return n;
  var i = t.getItemVisual(r, e + "Size"), o = t.getItemVisual(r, e + "Rotate"), a = t.getItemVisual(r, e + "Offset"), s = t.getItemVisual(r, e + "KeepAspect"), l = vf(i), u = qc(a || 0, l);
  return n + l + u + (o || "") + (s || "");
}
function kV(e, t, r) {
  var n = t.getItemVisual(r, e);
  if (!(!n || n === "none")) {
    var i = t.getItemVisual(r, e + "Size"), o = t.getItemVisual(r, e + "Rotate"), a = t.getItemVisual(r, e + "Offset"), s = t.getItemVisual(r, e + "KeepAspect"), l = vf(i), u = qc(a || 0, l), c = rn(n, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
    return c.__specifiedRotation = o == null || isNaN(o) ? void 0 : +o * Math.PI / 180 || 0, c.name = e, c;
  }
}
function KRe(e) {
  var t = new URe({
    name: "line",
    subPixelOptimize: !0
  });
  return W_(t.shape, e), t;
}
function W_(e, t) {
  e.x1 = t[0][0], e.y1 = t[0][1], e.x2 = t[1][0], e.y2 = t[1][1], e.percent = 1;
  var r = t[2];
  r ? (e.cpx1 = r[0], e.cpy1 = r[1]) : (e.cpx1 = NaN, e.cpy1 = NaN);
}
var DD = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i) {
      var o = e.call(this) || this;
      return o._createLine(r, n, i), o;
    }
    return t.prototype._createLine = function(r, n, i) {
      var o = r.hostModel, a = r.getItemLayout(n), s = KRe(a);
      s.shape.percent = 0, Pr(s, {
        shape: {
          percent: 1
        }
      }, o, n), this.add(s), B(X1, function(l) {
        var u = kV(l, r, n);
        this.add(u), this[OV(l)] = NV(l, r, n);
      }, this), this._updateCommonStl(r, n, i);
    }, t.prototype.updateData = function(r, n, i) {
      var o = r.hostModel, a = this.childOfName("line"), s = r.getItemLayout(n), l = {
        shape: {}
      };
      W_(l.shape, s), jt(a, l, o, n), B(X1, function(u) {
        var c = NV(u, r, n), d = OV(u);
        if (this[d] !== c) {
          this.remove(this.childOfName(u));
          var h = kV(u, r, n);
          this.add(h);
        }
        this[d] = c;
      }, this), this._updateCommonStl(r, n, i);
    }, t.prototype.getLinePath = function() {
      return this.childAt(0);
    }, t.prototype._updateCommonStl = function(r, n, i) {
      var o = r.hostModel, a = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, u = i && i.selectLineStyle, c = i && i.labelStatesModels, d = i && i.emphasisDisabled, h = i && i.focus, f = i && i.blurScope;
      if (!i || r.hasItemOption) {
        var p = r.getItemModel(n), g = p.getModel("emphasis");
        s = g.getModel("lineStyle").getLineStyle(), l = p.getModel(["blur", "lineStyle"]).getLineStyle(), u = p.getModel(["select", "lineStyle"]).getLineStyle(), d = g.get("disabled"), h = g.get("focus"), f = g.get("blurScope"), c = Rn(p);
      }
      var v = r.getItemVisual(n, "style"), m = v.stroke;
      a.useStyle(v), a.style.fill = null, a.style.strokeNoScale = !0, a.ensureState("emphasis").style = s, a.ensureState("blur").style = l, a.ensureState("select").style = u, B(X1, function(w) {
        var x = this.childOfName(w);
        if (x) {
          x.setColor(m), x.style.opacity = v.opacity;
          for (var E = 0; E < bi.length; E++) {
            var R = bi[E], _ = a.getState(R);
            if (_) {
              var P = _.style || {}, D = x.ensureState(R), I = D.style || (D.style = {});
              P.stroke != null && (I[x.__isEmptyBrush ? "stroke" : "fill"] = P.stroke), P.opacity != null && (I.opacity = P.opacity);
            }
          }
          x.markRedraw();
        }
      }, this);
      var y = o.getRawValue(n);
      Gn(this, c, {
        labelDataIndex: n,
        labelFetcher: {
          getFormattedLabel: function(w, x) {
            return o.getFormattedLabel(w, x, r.dataType);
          }
        },
        inheritColor: m || "#000",
        defaultOpacity: v.opacity,
        defaultText: (y == null ? r.getName(n) : isFinite(y) ? Gr(y) : y) + ""
      });
      var C = this.getTextContent();
      if (C) {
        var S = c.normal;
        C.__align = C.style.align, C.__verticalAlign = C.style.verticalAlign, C.__position = S.get("position") || "middle";
        var b = S.get("distance");
        fe(b) || (b = [b, b]), C.__labelDistance = b;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), Hr(this, h, f, d);
    }, t.prototype.highlight = function() {
      zs(this);
    }, t.prototype.downplay = function() {
      $s(this);
    }, t.prototype.updateLayout = function(r, n) {
      this.setLinePoints(r.getItemLayout(n));
    }, t.prototype.setLinePoints = function(r) {
      var n = this.childOfName("line");
      W_(n.shape, r), n.dirty();
    }, t.prototype.beforeUpdate = function() {
      var r = this, n = r.childOfName("fromSymbol"), i = r.childOfName("toSymbol"), o = r.getTextContent();
      if (!n && !i && (!o || o.ignore))
        return;
      for (var a = 1, s = this.parent; s; )
        s.scaleX && (a /= s.scaleX), s = s.parent;
      var l = r.childOfName("line");
      if (!this.__dirty && !l.__dirty)
        return;
      var u = l.shape.percent, c = l.pointAt(0), d = l.pointAt(u), h = El([], d, c);
      $c(h, h);
      function f(_, P) {
        var D = _.__specifiedRotation;
        if (D == null) {
          var I = l.tangentAt(P);
          _.attr("rotation", (P === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(I[1], I[0]));
        } else
          _.attr("rotation", D);
      }
      if (n && (n.setPosition(c), f(n, 0), n.scaleX = n.scaleY = a * u, n.markRedraw()), i && (i.setPosition(d), f(i, 1), i.scaleX = i.scaleY = a * u, i.markRedraw()), o && !o.ignore) {
        o.x = o.y = 0, o.originX = o.originY = 0;
        var p = void 0, g = void 0, v = o.__labelDistance, m = v[0] * a, y = v[1] * a, C = u / 2, S = l.tangentAt(C), b = [S[1], -S[0]], w = l.pointAt(C);
        b[1] > 0 && (b[0] = -b[0], b[1] = -b[1]);
        var x = S[0] < 0 ? -1 : 1;
        if (o.__position !== "start" && o.__position !== "end") {
          var E = -Math.atan2(S[1], S[0]);
          d[0] < c[0] && (E = Math.PI + E), o.rotation = E;
        }
        var R = void 0;
        switch (o.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            R = -y, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            R = y, g = "top";
            break;
          default:
            R = 0, g = "middle";
        }
        switch (o.__position) {
          case "end":
            o.x = h[0] * m + d[0], o.y = h[1] * y + d[1], p = h[0] > 0.8 ? "left" : h[0] < -0.8 ? "right" : "center", g = h[1] > 0.8 ? "top" : h[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            o.x = -h[0] * m + c[0], o.y = -h[1] * y + c[1], p = h[0] > 0.8 ? "right" : h[0] < -0.8 ? "left" : "center", g = h[1] > 0.8 ? "bottom" : h[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            o.x = m * x + c[0], o.y = c[1] + R, p = S[0] < 0 ? "right" : "left", o.originX = -m * x, o.originY = -R;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            o.x = w[0], o.y = w[1] + R, p = "center", o.originY = -R;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            o.x = -m * x + d[0], o.y = d[1] + R, p = S[0] >= 0 ? "right" : "left", o.originX = m * x, o.originY = -R;
            break;
        }
        o.scaleX = o.scaleY = a, o.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: o.__verticalAlign || g,
          align: o.__align || p
        });
      }
    }, t;
  }(it)
), AD = (
  /** @class */
  function() {
    function e(t) {
      this.group = new it(), this._LineCtor = t || DD;
    }
    return e.prototype.updateData = function(t) {
      var r = this;
      this._progressiveEls = null;
      var n = this, i = n.group, o = n._lineData;
      n._lineData = t, o || i.removeAll();
      var a = VV(t);
      t.diff(o).add(function(s) {
        r._doAdd(t, s, a);
      }).update(function(s, l) {
        r._doUpdate(o, t, l, s, a);
      }).remove(function(s) {
        i.remove(o.getItemGraphicEl(s));
      }).execute();
    }, e.prototype.updateLayout = function() {
      var t = this._lineData;
      t && t.eachItemGraphicEl(function(r, n) {
        r.updateLayout(t, n);
      }, this);
    }, e.prototype.incrementalPrepareUpdate = function(t) {
      this._seriesScope = VV(t), this._lineData = null, this.group.removeAll();
    }, e.prototype.incrementalUpdate = function(t, r) {
      this._progressiveEls = [];
      function n(s) {
        !s.isGroup && !YRe(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0);
      }
      for (var i = t.start; i < t.end; i++) {
        var o = r.getItemLayout(i);
        if (Q1(o)) {
          var a = new this._LineCtor(r, i, this._seriesScope);
          a.traverse(n), this.group.add(a), r.setItemGraphicEl(i, a), this._progressiveEls.push(a);
        }
      }
    }, e.prototype.remove = function() {
      this.group.removeAll();
    }, e.prototype.eachRendered = function(t) {
      iu(this._progressiveEls || this.group, t);
    }, e.prototype._doAdd = function(t, r, n) {
      var i = t.getItemLayout(r);
      if (Q1(i)) {
        var o = new this._LineCtor(t, r, n);
        t.setItemGraphicEl(r, o), this.group.add(o);
      }
    }, e.prototype._doUpdate = function(t, r, n, i, o) {
      var a = t.getItemGraphicEl(n);
      if (!Q1(r.getItemLayout(i))) {
        this.group.remove(a);
        return;
      }
      a ? a.updateData(r, i, o) : a = new this._LineCtor(r, i, o), r.setItemGraphicEl(i, a), this.group.add(a);
    }, e;
  }()
);
function YRe(e) {
  return e.animators && e.animators.length > 0;
}
function VV(e) {
  var t = e.hostModel, r = t.getModel("emphasis");
  return {
    lineStyle: t.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: r.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: t.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: t.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: r.get("disabled"),
    blurScope: r.get("blurScope"),
    focus: r.get("focus"),
    labelStatesModels: Rn(t)
  };
}
function BV(e) {
  return isNaN(e[0]) || isNaN(e[1]);
}
function Q1(e) {
  return e && !BV(e[0]) && !BV(e[1]);
}
var J1 = [], ex = [], tx = [], Id = Pn, rx = Al, GV = Math.abs;
function HV(e, t, r) {
  for (var n = e[0], i = e[1], o = e[2], a = 1 / 0, s, l = r * r, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
    J1[0] = Id(n[0], i[0], o[0], c), J1[1] = Id(n[1], i[1], o[1], c);
    var d = GV(rx(J1, t) - l);
    d < a && (a = d, s = c);
  }
  for (var h = 0; h < 32; h++) {
    var f = s + u;
    ex[0] = Id(n[0], i[0], o[0], s), ex[1] = Id(n[1], i[1], o[1], s), tx[0] = Id(n[0], i[0], o[0], f), tx[1] = Id(n[1], i[1], o[1], f);
    var d = rx(ex, t) - l;
    if (GV(d) < 0.01)
      break;
    var p = rx(tx, t) - l;
    u /= 2, d < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u;
  }
  return s;
}
function nx(e, t) {
  var r = [], n = Ig, i = [[], [], []], o = [[], []], a = [];
  t /= 2, e.eachEdge(function(s, l) {
    var u = s.getLayout(), c = s.getVisual("fromSymbol"), d = s.getVisual("toSymbol");
    u.__original || (u.__original = [Ua(u[0]), Ua(u[1])], u[2] && u.__original.push(Ua(u[2])));
    var h = u.__original;
    if (u[2] != null) {
      if (Kn(i[0], h[0]), Kn(i[1], h[2]), Kn(i[2], h[1]), c && c !== "none") {
        var f = Op(s.node1), p = HV(i, h[0], f * t);
        n(i[0][0], i[1][0], i[2][0], p, r), i[0][0] = r[3], i[1][0] = r[4], n(i[0][1], i[1][1], i[2][1], p, r), i[0][1] = r[3], i[1][1] = r[4];
      }
      if (d && d !== "none") {
        var f = Op(s.node2), p = HV(i, h[1], f * t);
        n(i[0][0], i[1][0], i[2][0], p, r), i[1][0] = r[1], i[2][0] = r[2], n(i[0][1], i[1][1], i[2][1], p, r), i[1][1] = r[1], i[2][1] = r[2];
      }
      Kn(u[0], i[0]), Kn(u[1], i[2]), Kn(u[2], i[1]);
    } else {
      if (Kn(o[0], h[0]), Kn(o[1], h[1]), El(a, o[1], o[0]), $c(a, a), c && c !== "none") {
        var f = Op(s.node1);
        k0(o[0], o[0], a, f * t);
      }
      if (d && d !== "none") {
        var f = Op(s.node2);
        k0(o[1], o[1], a, -f * t);
      }
      Kn(u[0], o[0]), Kn(u[1], o[1]);
    }
  });
}
function zV(e) {
  return e.type === "view";
}
var qRe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      var i = new Vv(), o = new AD(), a = this.group;
      this._controller = new $v(n.getZr()), this._controllerHost = {
        target: a
      }, a.add(i.group), a.add(o.group), this._symbolDraw = i, this._lineDraw = o, this._firstRender = !0;
    }, t.prototype.render = function(r, n, i) {
      var o = this, a = r.coordinateSystem;
      this._model = r;
      var s = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (zV(a)) {
        var c = {
          x: a.x,
          y: a.y,
          scaleX: a.scaleX,
          scaleY: a.scaleY
        };
        this._firstRender ? u.attr(c) : jt(u, c, r);
      }
      nx(r.getGraph(), Lp(r));
      var d = r.getData();
      s.updateData(d);
      var h = r.getEdgeData();
      l.updateData(h), this._updateNodeAndLinkScale(), this._updateController(r, n, i), clearTimeout(this._layoutTimeout);
      var f = r.forceLayout, p = r.get(["force", "layoutAnimation"]);
      f && this._startForceLayoutIteration(f, p);
      var g = r.get("layout");
      d.graph.eachNode(function(C) {
        var S = C.dataIndex, b = C.getGraphicEl(), w = C.getModel();
        if (b) {
          b.off("drag").off("dragend");
          var x = w.get("draggable");
          x && b.on("drag", function(R) {
            switch (g) {
              case "force":
                f.warmUp(), !o._layouting && o._startForceLayoutIteration(f, p), f.setFixed(S), d.setItemLayout(S, [b.x, b.y]);
                break;
              case "circular":
                d.setItemLayout(S, [b.x, b.y]), C.setLayout({
                  fixed: !0
                }, !0), MD(r, "symbolSize", C, [R.offsetX, R.offsetY]), o.updateLayout(r);
                break;
              case "none":
              default:
                d.setItemLayout(S, [b.x, b.y]), PD(r.getGraph(), r), o.updateLayout(r);
                break;
            }
          }).on("dragend", function() {
            f && f.setUnfixed(S);
          }), b.setDraggable(x, !!w.get("cursor"));
          var E = w.get(["emphasis", "focus"]);
          E === "adjacency" && (ot(b).focus = C.getAdjacentDataIndices());
        }
      }), d.graph.eachEdge(function(C) {
        var S = C.getGraphicEl(), b = C.getModel().get(["emphasis", "focus"]);
        S && b === "adjacency" && (ot(S).focus = {
          edge: [C.dataIndex],
          node: [C.node1.dataIndex, C.node2.dataIndex]
        });
      });
      var v = r.get("layout") === "circular" && r.get(["circular", "rotateLabel"]), m = d.getLayout("cx"), y = d.getLayout("cy");
      d.graph.eachNode(function(C) {
        ej(C, v, m, y);
      }), this._firstRender = !1;
    }, t.prototype.dispose = function() {
      this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._startForceLayoutIteration = function(r, n) {
      var i = this;
      (function o() {
        r.step(function(a) {
          i.updateLayout(i._model), (i._layouting = !a) && (n ? i._layoutTimeout = setTimeout(o, 16) : o());
        });
      })();
    }, t.prototype._updateController = function(r, n, i) {
      var o = this, a = this._controller, s = this._controllerHost, l = this.group;
      if (a.setPointerChecker(function(u, c, d) {
        var h = l.getBoundingRect();
        return h.applyTransform(l.transform), h.contain(c, d) && !ow(u, i, r);
      }), !zV(r.coordinateSystem)) {
        a.disable();
        return;
      }
      a.enable(r.get("roam")), s.zoomLimit = r.get("scaleLimit"), s.zoom = r.coordinateSystem.getZoom(), a.off("pan").off("zoom").on("pan", function(u) {
        CD(s, u.dx, u.dy), i.dispatchAction({
          seriesId: r.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        SD(s, u.scale, u.originX, u.originY), i.dispatchAction({
          seriesId: r.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), o._updateNodeAndLinkScale(), nx(r.getGraph(), Lp(r)), o._lineDraw.updateLayout(), i.updateLabelLayout();
      });
    }, t.prototype._updateNodeAndLinkScale = function() {
      var r = this._model, n = r.getData(), i = Lp(r);
      n.eachItemGraphicEl(function(o, a) {
        o && o.setSymbolScale(i);
      });
    }, t.prototype.updateLayout = function(r) {
      nx(r.getGraph(), Lp(r)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, t.prototype.remove = function() {
      clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, t.type = "graph", t;
  }(ar)
);
function Fd(e) {
  return "_EC_" + e;
}
var ZRe = (
  /** @class */
  function() {
    function e(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
    }
    return e.prototype.isDirected = function() {
      return this._directed;
    }, e.prototype.addNode = function(t, r) {
      t = t == null ? "" + r : "" + t;
      var n = this._nodesMap;
      if (n[Fd(t)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var i = new Hu(t, r);
      return i.hostGraph = this, this.nodes.push(i), n[Fd(t)] = i, i;
    }, e.prototype.getNodeByIndex = function(t) {
      var r = this.data.getRawIndex(t);
      return this.nodes[r];
    }, e.prototype.getNodeById = function(t) {
      return this._nodesMap[Fd(t)];
    }, e.prototype.addEdge = function(t, r, n) {
      var i = this._nodesMap, o = this._edgesMap;
      if ($t(t) && (t = this.nodes[t]), $t(r) && (r = this.nodes[r]), t instanceof Hu || (t = i[Fd(t)]), r instanceof Hu || (r = i[Fd(r)]), !(!t || !r)) {
        var a = t.id + "-" + r.id, s = new rj(t, r, n);
        return s.hostGraph = this, this._directed && (t.outEdges.push(s), r.inEdges.push(s)), t.edges.push(s), t !== r && r.edges.push(s), this.edges.push(s), o[a] = s, s;
      }
    }, e.prototype.getEdgeByIndex = function(t) {
      var r = this.edgeData.getRawIndex(t);
      return this.edges[r];
    }, e.prototype.getEdge = function(t, r) {
      t instanceof Hu && (t = t.id), r instanceof Hu && (r = r.id);
      var n = this._edgesMap;
      return this._directed ? n[t + "-" + r] : n[t + "-" + r] || n[r + "-" + t];
    }, e.prototype.eachNode = function(t, r) {
      for (var n = this.nodes, i = n.length, o = 0; o < i; o++)
        n[o].dataIndex >= 0 && t.call(r, n[o], o);
    }, e.prototype.eachEdge = function(t, r) {
      for (var n = this.edges, i = n.length, o = 0; o < i; o++)
        n[o].dataIndex >= 0 && n[o].node1.dataIndex >= 0 && n[o].node2.dataIndex >= 0 && t.call(r, n[o], o);
    }, e.prototype.breadthFirstTraverse = function(t, r, n, i) {
      if (r instanceof Hu || (r = this._nodesMap[Fd(r)]), !!r) {
        for (var o = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", a = 0; a < this.nodes.length; a++)
          this.nodes[a].__visited = !1;
        if (!t.call(i, r, null))
          for (var s = [r]; s.length; )
            for (var l = s.shift(), u = l[o], a = 0; a < u.length; a++) {
              var c = u[a], d = c.node1 === l ? c.node2 : c.node1;
              if (!d.__visited) {
                if (t.call(i, d, l))
                  return;
                s.push(d), d.__visited = !0;
              }
            }
      }
    }, e.prototype.update = function() {
      for (var t = this.data, r = this.edgeData, n = this.nodes, i = this.edges, o = 0, a = n.length; o < a; o++)
        n[o].dataIndex = -1;
      for (var o = 0, a = t.count(); o < a; o++)
        n[t.getRawIndex(o)].dataIndex = o;
      r.filterSelf(function(s) {
        var l = i[r.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var o = 0, a = i.length; o < a; o++)
        i[o].dataIndex = -1;
      for (var o = 0, a = r.count(); o < a; o++)
        i[r.getRawIndex(o)].dataIndex = o;
    }, e.prototype.clone = function() {
      for (var t = new e(this._directed), r = this.nodes, n = this.edges, i = 0; i < r.length; i++)
        t.addNode(r[i].id, r[i].dataIndex);
      for (var i = 0; i < n.length; i++) {
        var o = n[i];
        t.addEdge(o.node1.id, o.node2.id, o.dataIndex);
      }
      return t;
    }, e;
  }()
), Hu = (
  /** @class */
  function() {
    function e(t, r) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = r ?? -1;
    }
    return e.prototype.degree = function() {
      return this.edges.length;
    }, e.prototype.inDegree = function() {
      return this.inEdges.length;
    }, e.prototype.outDegree = function() {
      return this.outEdges.length;
    }, e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var r = this.hostGraph, n = r.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, r = 0; r < this.edges.length; r++) {
        var n = this.edges[r];
        n.dataIndex < 0 || (t.edge.push(n.dataIndex), t.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return t;
    }, e.prototype.getTrajectoryDataIndices = function() {
      for (var t = We(), r = We(), n = 0; n < this.edges.length; n++) {
        var i = this.edges[n];
        if (!(i.dataIndex < 0)) {
          t.set(i.dataIndex, !0);
          for (var o = [i.node1], a = [i.node2], s = 0; s < o.length; ) {
            var l = o[s];
            s++, r.set(l.dataIndex, !0);
            for (var u = 0; u < l.inEdges.length; u++)
              t.set(l.inEdges[u].dataIndex, !0), o.push(l.inEdges[u].node1);
          }
          for (s = 0; s < a.length; ) {
            var c = a[s];
            s++, r.set(c.dataIndex, !0);
            for (var u = 0; u < c.outEdges.length; u++)
              t.set(c.outEdges[u].dataIndex, !0), a.push(c.outEdges[u].node2);
          }
        }
      }
      return {
        edge: t.keys(),
        node: r.keys()
      };
    }, e;
  }()
), rj = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.dataIndex = -1, this.node1 = t, this.node2 = r, this.dataIndex = n ?? -1;
    }
    return e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var r = this.hostGraph, n = r.edgeData.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, e.prototype.getTrajectoryDataIndices = function() {
      var t = We(), r = We();
      t.set(this.dataIndex, !0);
      for (var n = [this.node1], i = [this.node2], o = 0; o < n.length; ) {
        var a = n[o];
        o++, r.set(a.dataIndex, !0);
        for (var s = 0; s < a.inEdges.length; s++)
          t.set(a.inEdges[s].dataIndex, !0), n.push(a.inEdges[s].node1);
      }
      for (o = 0; o < i.length; ) {
        var l = i[o];
        o++, r.set(l.dataIndex, !0);
        for (var s = 0; s < l.outEdges.length; s++)
          t.set(l.outEdges[s].dataIndex, !0), i.push(l.outEdges[s].node2);
      }
      return {
        edge: t.keys(),
        node: r.keys()
      };
    }, e;
  }()
);
function nj(e, t) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(r) {
      var n = this[e][t];
      return n.getStore().get(n.getDimensionIndex(r || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(r, n) {
      this.dataIndex >= 0 && this[e][t].setItemVisual(this.dataIndex, r, n);
    },
    getVisual: function(r) {
      return this[e][t].getItemVisual(this.dataIndex, r);
    },
    setLayout: function(r, n) {
      this.dataIndex >= 0 && this[e][t].setItemLayout(this.dataIndex, r, n);
    },
    getLayout: function() {
      return this[e][t].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[e][t].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[e][t].getRawIndex(this.dataIndex);
    }
  };
}
qr(Hu, nj("hostGraph", "data"));
qr(rj, nj("hostGraph", "edgeData"));
function ij(e, t, r, n, i) {
  for (var o = new ZRe(n), a = 0; a < e.length; a++)
    o.addNode(tn(
      // Id, name, dataIndex
      e[a].id,
      e[a].name,
      a
    ), a);
  for (var s = [], l = [], u = 0, a = 0; a < t.length; a++) {
    var c = t[a], d = c.source, h = c.target;
    o.addEdge(d, h, u) && (l.push(c), s.push(tn(vn(c.id, null), d + " > " + h)), u++);
  }
  var f = r.get("coordinateSystem"), p;
  if (f === "cartesian2d" || f === "polar")
    p = os(e, r);
  else {
    var g = Yc.get(f), v = g ? g.dimensions || [] : [];
    bt(v, "value") < 0 && v.concat(["value"]);
    var m = mf(e, {
      coordDimensions: v,
      encodeDefine: r.getEncode()
    }).dimensions;
    p = new Jn(m, r), p.initData(e);
  }
  var y = new Jn(["value"], r);
  return y.initData(l, s), i && i(p, y), B9({
    mainData: p,
    struct: o,
    structAttr: "graph",
    datas: {
      node: p,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), o.update(), o;
}
var XRe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments);
      var n = this;
      function i() {
        return n._categoriesData;
      }
      this.legendVisualProvider = new zv(i, i), this.fillDataTextStyle(r.edges || r.links), this._updateCategoriesData();
    }, t.prototype.mergeOption = function(r) {
      e.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(r.edges || r.links), this._updateCategoriesData();
    }, t.prototype.mergeDefaultAndTheme = function(r) {
      e.prototype.mergeDefaultAndTheme.apply(this, arguments), Tc(r, "edgeLabel", ["show"]);
    }, t.prototype.getInitialData = function(r, n) {
      var i = r.edges || r.links || [], o = r.data || r.nodes || [], a = this;
      if (o && i) {
        kRe(this);
        var s = ij(o, i, this, !0, l);
        return B(s.edges, function(u) {
          VRe(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var g = a._categoriesModels, v = p.getShallow("category"), m = g[v];
          return m && (m.parentModel = p.parentModel, p.parentModel = m), p;
        });
        var d = cr.prototype.getModel;
        function h(p, g) {
          var v = d.call(this, p, g);
          return v.resolveParentPath = f, v;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = f, p.getModel = h, p;
        });
        function f(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var g = p.slice();
            return p[0] === "label" ? g[0] = "edgeLabel" : p[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return p;
        }
      }
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, t.prototype.formatTooltip = function(r, n, i) {
      if (i === "edge") {
        var o = this.getData(), a = this.getDataParams(r, i), s = o.graph.getEdgeByIndex(r), l = o.getName(s.node1.dataIndex), u = o.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), _n("nameValue", {
          name: c.join(" > "),
          value: a.value,
          noValue: a.value == null
        });
      }
      var d = _W({
        series: this,
        dataIndex: r,
        multipleSeries: n
      });
      return d;
    }, t.prototype._updateCategoriesData = function() {
      var r = ge(this.option.categories || [], function(i) {
        return i.value != null ? i : se({
          value: 0
        }, i);
      }), n = new Jn(["value"], this);
      n.initData(r), this._categoriesData = n, this._categoriesModels = n.mapArray(function(i) {
        return n.getItemModel(i);
      });
    }, t.prototype.setZoom = function(r) {
      this.option.zoom = r;
    }, t.prototype.setCenter = function(r) {
      this.option.center = r;
    }, t.prototype.isAnimationEnabled = function() {
      return e.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, t.type = "series.graph", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, t;
  }(hr)
), QRe = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function JRe(e) {
  e.registerChartView(qRe), e.registerSeriesModel(XRe), e.registerProcessor(IRe), e.registerVisual(FRe), e.registerVisual(LRe), e.registerLayout(BRe), e.registerLayout(e.PRIORITY.VISUAL.POST_CHART_LAYOUT, HRe), e.registerLayout($Re), e.registerCoordinateSystem("graphView", {
    dimensions: Wv.dimensions,
    create: jRe
  }), e.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, Kr), e.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, Kr), e.registerAction(QRe, function(t, r, n) {
    r.eachComponent({
      mainType: "series",
      query: t
    }, function(i) {
      var o = i.coordinateSystem, a = bD(o, t, void 0, n);
      i.setCenter && i.setCenter(a.center), i.setZoom && i.setZoom(a.zoom);
    });
  });
}
var e_e = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return e;
  }()
), t_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "pointer", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new e_e();
    }, t.prototype.buildPath = function(r, n) {
      var i = Math.cos, o = Math.sin, a = n.r, s = n.width, l = n.angle, u = n.x - i(l) * s * (s >= a / 3 ? 1 : 2), c = n.y - o(l) * s * (s >= a / 3 ? 1 : 2);
      l = n.angle - Math.PI / 2, r.moveTo(u, c), r.lineTo(n.x + i(l) * s, n.y + o(l) * s), r.lineTo(n.x + i(n.angle) * a, n.y + o(n.angle) * a), r.lineTo(n.x - i(l) * s, n.y - o(l) * s), r.lineTo(u, c);
    }, t;
  }(Mt)
);
function r_e(e, t) {
  var r = e.get("center"), n = t.getWidth(), i = t.getHeight(), o = Math.min(n, i), a = Ae(r[0], t.getWidth()), s = Ae(r[1], t.getHeight()), l = Ae(e.get("radius"), o / 2);
  return {
    cx: a,
    cy: s,
    r: l
  };
}
function fy(e, t) {
  var r = e == null ? "" : e + "";
  return t && (Fe(t) ? r = t.replace("{value}", r) : Ye(t) && (r = t(e))), r;
}
var n_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      this.group.removeAll();
      var o = r.get(["axisLine", "lineStyle", "color"]), a = r_e(r, i);
      this._renderMain(r, n, i, o, a), this._data = r.getData();
    }, t.prototype.dispose = function() {
    }, t.prototype._renderMain = function(r, n, i, o, a) {
      var s = this.group, l = r.get("clockwise"), u = -r.get("startAngle") / 180 * Math.PI, c = -r.get("endAngle") / 180 * Math.PI, d = r.getModel("axisLine"), h = d.get("roundCap"), f = h ? yC : xi, p = d.get("show"), g = d.getModel("lineStyle"), v = g.get("width"), m = [u, c];
      hM(m, !l), u = m[0], c = m[1];
      for (var y = c - u, C = u, S = [], b = 0; p && b < o.length; b++) {
        var w = Math.min(Math.max(o[b][0], 0), 1);
        c = u + y * w;
        var x = new f({
          shape: {
            startAngle: C,
            endAngle: c,
            cx: a.cx,
            cy: a.cy,
            clockwise: l,
            r0: a.r - v,
            r: a.r
          },
          silent: !0
        });
        x.setStyle({
          fill: o[b][1]
        }), x.setStyle(g.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), S.push(x), C = c;
      }
      S.reverse(), B(S, function(R) {
        return s.add(R);
      });
      var E = function(R) {
        if (R <= 0)
          return o[0][1];
        var _;
        for (_ = 0; _ < o.length; _++)
          if (o[_][0] >= R && (_ === 0 ? 0 : o[_ - 1][0]) < R)
            return o[_][1];
        return o[_ - 1][1];
      };
      this._renderTicks(r, n, i, E, a, u, c, l, v), this._renderTitleAndDetail(r, n, i, E, a), this._renderAnchor(r, a), this._renderPointer(r, n, i, E, a, u, c, l, v);
    }, t.prototype._renderTicks = function(r, n, i, o, a, s, l, u, c) {
      for (var d = this.group, h = a.cx, f = a.cy, p = a.r, g = +r.get("min"), v = +r.get("max"), m = r.getModel("splitLine"), y = r.getModel("axisTick"), C = r.getModel("axisLabel"), S = r.get("splitNumber"), b = y.get("splitNumber"), w = Ae(m.get("length"), p), x = Ae(y.get("length"), p), E = s, R = (l - s) / S, _ = R / b, P = m.getModel("lineStyle").getLineStyle(), D = y.getModel("lineStyle").getLineStyle(), I = m.get("distance"), A, O, L = 0; L <= S; L++) {
        if (A = Math.cos(E), O = Math.sin(E), m.get("show")) {
          var N = I ? I + c : c, F = new wn({
            shape: {
              x1: A * (p - N) + h,
              y1: O * (p - N) + f,
              x2: A * (p - w - N) + h,
              y2: O * (p - w - N) + f
            },
            style: P,
            silent: !0
          });
          P.stroke === "auto" && F.setStyle({
            stroke: o(L / S)
          }), d.add(F);
        }
        if (C.get("show")) {
          var N = C.get("distance") + I, G = fy(Gr(L / S * (v - g) + g), C.get("formatter")), M = o(L / S), V = A * (p - w - N) + h, z = O * (p - w - N) + f, k = C.get("rotate"), $ = 0;
          k === "radial" ? ($ = -E + 2 * Math.PI, $ > Math.PI / 2 && ($ += Math.PI)) : k === "tangential" ? $ = -E - Math.PI / 2 : $t(k) && ($ = k * Math.PI / 180), $ === 0 ? d.add(new Vt({
            style: br(C, {
              text: G,
              x: V,
              y: z,
              verticalAlign: O < -0.8 ? "top" : O > 0.8 ? "bottom" : "middle",
              align: A < -0.4 ? "left" : A > 0.4 ? "right" : "center"
            }, {
              inheritColor: M
            }),
            silent: !0
          })) : d.add(new Vt({
            style: br(C, {
              text: G,
              x: V,
              y: z,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: M
            }),
            silent: !0,
            originX: V,
            originY: z,
            rotation: $
          }));
        }
        if (y.get("show") && L !== S) {
          var N = y.get("distance");
          N = N ? N + c : c;
          for (var W = 0; W <= b; W++) {
            A = Math.cos(E), O = Math.sin(E);
            var j = new wn({
              shape: {
                x1: A * (p - N) + h,
                y1: O * (p - N) + f,
                x2: A * (p - x - N) + h,
                y2: O * (p - x - N) + f
              },
              silent: !0,
              style: D
            });
            D.stroke === "auto" && j.setStyle({
              stroke: o((L + W / b) / S)
            }), d.add(j), E += _;
          }
          E -= _;
        } else
          E += R;
      }
    }, t.prototype._renderPointer = function(r, n, i, o, a, s, l, u, c) {
      var d = this.group, h = this._data, f = this._progressEls, p = [], g = r.get(["pointer", "show"]), v = r.getModel("progress"), m = v.get("show"), y = r.getData(), C = y.mapDimension("value"), S = +r.get("min"), b = +r.get("max"), w = [S, b], x = [s, l];
      function E(_, P) {
        var D = y.getItemModel(_), I = D.getModel("pointer"), A = Ae(I.get("width"), a.r), O = Ae(I.get("length"), a.r), L = r.get(["pointer", "icon"]), N = I.get("offsetCenter"), F = Ae(N[0], a.r), G = Ae(N[1], a.r), M = I.get("keepAspect"), V;
        return L ? V = rn(L, F - A / 2, G - O, A, O, null, M) : V = new t_e({
          shape: {
            angle: -Math.PI / 2,
            width: A,
            r: O,
            x: F,
            y: G
          }
        }), V.rotation = -(P + Math.PI / 2), V.x = a.cx, V.y = a.cy, V;
      }
      function R(_, P) {
        var D = v.get("roundCap"), I = D ? yC : xi, A = v.get("overlap"), O = A ? v.get("width") : c / y.count(), L = A ? a.r - O : a.r - (_ + 1) * O, N = A ? a.r : a.r - _ * O, F = new I({
          shape: {
            startAngle: s,
            endAngle: P,
            cx: a.cx,
            cy: a.cy,
            clockwise: u,
            r0: L,
            r: N
          }
        });
        return A && (F.z2 = b - y.get(C, _) % b), F;
      }
      (m || g) && (y.diff(h).add(function(_) {
        var P = y.get(C, _);
        if (g) {
          var D = E(_, s);
          Pr(D, {
            rotation: -((isNaN(+P) ? x[0] : nr(P, w, x, !0)) + Math.PI / 2)
          }, r), d.add(D), y.setItemGraphicEl(_, D);
        }
        if (m) {
          var I = R(_, s), A = v.get("clip");
          Pr(I, {
            shape: {
              endAngle: nr(P, w, x, A)
            }
          }, r), d.add(I), e_(r.seriesIndex, y.dataType, _, I), p[_] = I;
        }
      }).update(function(_, P) {
        var D = y.get(C, _);
        if (g) {
          var I = h.getItemGraphicEl(P), A = I ? I.rotation : s, O = E(_, A);
          O.rotation = A, jt(O, {
            rotation: -((isNaN(+D) ? x[0] : nr(D, w, x, !0)) + Math.PI / 2)
          }, r), d.add(O), y.setItemGraphicEl(_, O);
        }
        if (m) {
          var L = f[P], N = L ? L.shape.endAngle : s, F = R(_, N), G = v.get("clip");
          jt(F, {
            shape: {
              endAngle: nr(D, w, x, G)
            }
          }, r), d.add(F), e_(r.seriesIndex, y.dataType, _, F), p[_] = F;
        }
      }).execute(), y.each(function(_) {
        var P = y.getItemModel(_), D = P.getModel("emphasis"), I = D.get("focus"), A = D.get("blurScope"), O = D.get("disabled");
        if (g) {
          var L = y.getItemGraphicEl(_), N = y.getItemVisual(_, "style"), F = N.fill;
          if (L instanceof In) {
            var G = L.style;
            L.useStyle(se({
              image: G.image,
              x: G.x,
              y: G.y,
              width: G.width,
              height: G.height
            }, N));
          } else
            L.useStyle(N), L.type !== "pointer" && L.setColor(F);
          L.setStyle(P.getModel(["pointer", "itemStyle"]).getItemStyle()), L.style.fill === "auto" && L.setStyle("fill", o(nr(y.get(C, _), w, [0, 1], !0))), L.z2EmphasisLift = 0, Bn(L, P), Hr(L, I, A, O);
        }
        if (m) {
          var M = p[_];
          M.useStyle(y.getItemVisual(_, "style")), M.setStyle(P.getModel(["progress", "itemStyle"]).getItemStyle()), M.z2EmphasisLift = 0, Bn(M, P), Hr(M, I, A, O);
        }
      }), this._progressEls = p);
    }, t.prototype._renderAnchor = function(r, n) {
      var i = r.getModel("anchor"), o = i.get("show");
      if (o) {
        var a = i.get("size"), s = i.get("icon"), l = i.get("offsetCenter"), u = i.get("keepAspect"), c = rn(s, n.cx - a / 2 + Ae(l[0], n.r), n.cy - a / 2 + Ae(l[1], n.r), a, a, null, u);
        c.z2 = i.get("showAbove") ? 1 : 0, c.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, t.prototype._renderTitleAndDetail = function(r, n, i, o, a) {
      var s = this, l = r.getData(), u = l.mapDimension("value"), c = +r.get("min"), d = +r.get("max"), h = new it(), f = [], p = [], g = r.isAnimationEnabled(), v = r.get(["pointer", "showAbove"]);
      l.diff(this._data).add(function(m) {
        f[m] = new Vt({
          silent: !0
        }), p[m] = new Vt({
          silent: !0
        });
      }).update(function(m, y) {
        f[m] = s._titleEls[y], p[m] = s._detailEls[y];
      }).execute(), l.each(function(m) {
        var y = l.getItemModel(m), C = l.get(u, m), S = new it(), b = o(nr(C, [c, d], [0, 1], !0)), w = y.getModel("title");
        if (w.get("show")) {
          var x = w.get("offsetCenter"), E = a.cx + Ae(x[0], a.r), R = a.cy + Ae(x[1], a.r), _ = f[m];
          _.attr({
            z2: v ? 0 : 2,
            style: br(w, {
              x: E,
              y: R,
              text: l.getName(m),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: b
            })
          }), S.add(_);
        }
        var P = y.getModel("detail");
        if (P.get("show")) {
          var D = P.get("offsetCenter"), I = a.cx + Ae(D[0], a.r), A = a.cy + Ae(D[1], a.r), O = Ae(P.get("width"), a.r), L = Ae(P.get("height"), a.r), N = r.get(["progress", "show"]) ? l.getItemVisual(m, "style").fill : b, _ = p[m], F = P.get("formatter");
          _.attr({
            z2: v ? 0 : 2,
            style: br(P, {
              x: I,
              y: A,
              text: fy(C, F),
              width: isNaN(O) ? null : O,
              height: isNaN(L) ? null : L,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: N
            })
          }), L6(_, {
            normal: P
          }, C, function(M) {
            return fy(M, F);
          }), g && O6(_, m, l, r, {
            getFormattedLabel: function(M, V, z, k, $, W) {
              return fy(W ? W.interpolatedValue : C, F);
            }
          }), S.add(_);
        }
        h.add(S);
      }), this.group.add(h), this._titleEls = f, this._detailEls = p;
    }, t.type = "gauge", t;
  }(ar)
), i_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.visualStyleAccessPath = "itemStyle", r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return Sf(this, ["value"]);
    }, t.type = "series.gauge", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 默认全局居中
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 最小值
      min: 0,
      // 最大值
      max: 100,
      // 分割段数，默认为10
      splitNumber: 10,
      // 坐标轴线
      axisLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, "#E6EBF8"]],
          width: 10
        }
      },
      // 坐标轴线
      progress: {
        // 默认显示，属性show控制显示与否
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 分隔线
      splitLine: {
        // 默认显示，属性show控制显示与否
        show: !0,
        // 属性length控制线长
        length: 10,
        distance: 10,
        // 属性lineStyle（详见lineStyle）控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      // 坐标轴小标记
      axisTick: {
        // 属性show控制显示与否，默认不显示
        show: !0,
        // 每份split细分多少段
        splitNumber: 5,
        // 属性length控制线长
        length: 6,
        distance: 10,
        // 属性lineStyle控制线条样式
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: !0,
        // x, y，单位px
        offsetCenter: [0, "20%"],
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [5, 10],
        // x, y，单位px
        offsetCenter: [0, "40%"],
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, t;
  }(hr)
);
function o_e(e) {
  e.registerChartView(n_e), e.registerSeriesModel(i_e);
}
var a_e = ["itemStyle", "opacity"], s_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n) {
      var i = e.call(this) || this, o = i, a = new Ri(), s = new Vt();
      return o.setTextContent(s), i.setTextGuideLine(a), i.updateData(r, n, !0), i;
    }
    return t.prototype.updateData = function(r, n, i) {
      var o = this, a = r.hostModel, s = r.getItemModel(n), l = r.getItemLayout(n), u = s.getModel("emphasis"), c = s.get(a_e);
      c = c ?? 1, i || Ca(o), o.useStyle(r.getItemVisual(n, "style")), o.style.lineJoin = "round", i ? (o.setShape({
        points: l.points
      }), o.style.opacity = 0, Pr(o, {
        style: {
          opacity: c
        }
      }, a, n)) : jt(o, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, a, n), Bn(o, s), this._updateLabel(r, n), Hr(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(r, n) {
      var i = this, o = this.getTextGuideLine(), a = i.getTextContent(), s = r.hostModel, l = r.getItemModel(n), u = r.getItemLayout(n), c = u.label, d = r.getItemVisual(n, "style"), h = d.fill;
      Gn(
        // position will not be used in setLabelStyle
        a,
        Rn(l),
        {
          labelFetcher: r.hostModel,
          labelDataIndex: n,
          defaultOpacity: d.opacity,
          defaultText: r.getName(n)
        },
        {
          normal: {
            align: c.textAlign,
            verticalAlign: c.verticalAlign
          }
        }
      ), i.setTextConfig({
        local: !0,
        inside: !!c.inside,
        insideStroke: h,
        // insideFill: 'auto',
        outsideFill: h
      });
      var f = c.linePoints;
      o.setShape({
        points: f
      }), i.textGuideLineConfig = {
        anchor: f ? new Ct(f[0][0], f[0][1]) : null
      }, jt(a, {
        style: {
          x: c.x,
          y: c.y
        }
      }, s, n), a.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), lD(i, uD(l), {
        // Default use item visual color
        stroke: h
      });
    }, t;
  }(Ei)
), l_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.ignoreLabelLineUpdate = !0, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this._data, s = this.group;
      o.diff(a).add(function(l) {
        var u = new s_e(o, l);
        o.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var c = a.getItemGraphicEl(u);
        c.updateData(o, l), s.add(c), o.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = a.getItemGraphicEl(l);
        Vg(u, r, l);
      }).execute(), this._data = o;
    }, t.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, t.prototype.dispose = function() {
    }, t.type = "funnel", t;
  }(ar)
), u_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments), this.legendVisualProvider = new zv(ke(this.getData, this), ke(this.getRawData, this)), this._defaultLabelLine(r);
    }, t.prototype.getInitialData = function(r, n) {
      return Sf(this, {
        coordDimensions: ["value"],
        encodeDefaulter: dt(OM, this)
      });
    }, t.prototype._defaultLabelLine = function(r) {
      Tc(r, "labelLine", ["show"]);
      var n = r.labelLine, i = r.emphasis.labelLine;
      n.show = n.show && r.label.show, i.show = i.show && r.emphasis.label.show;
    }, t.prototype.getDataParams = function(r) {
      var n = this.getData(), i = e.prototype.getDataParams.call(this, r), o = n.mapDimension("value"), a = n.getSum(o);
      return i.percent = a ? +(n.get(o, r) / a * 100).toFixed(2) : 0, i.$vars.push("percent"), i;
    }, t.type = "series.funnel", t.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 默认取数据最小最大值
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: 各异,
          width: 1
        }
      },
      itemStyle: {
        // color: 各异,
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, t;
  }(hr)
);
function c_e(e, t) {
  return hn(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function d_e(e, t) {
  for (var r = e.mapDimension("value"), n = e.mapArray(r, function(l) {
    return l;
  }), i = [], o = t === "ascending", a = 0, s = e.count(); a < s; a++)
    i[a] = a;
  return Ye(t) ? i.sort(t) : t !== "none" && i.sort(function(l, u) {
    return o ? n[l] - n[u] : n[u] - n[l];
  }), i;
}
function h_e(e) {
  var t = e.hostModel, r = t.get("orient");
  e.each(function(n) {
    var i = e.getItemModel(n), o = i.getModel("label"), a = o.get("position"), s = i.getModel("labelLine"), l = e.getItemLayout(n), u = l.points, c = a === "inner" || a === "inside" || a === "center" || a === "insideLeft" || a === "insideRight", d, h, f, p;
    if (c)
      a === "insideLeft" ? (h = (u[0][0] + u[3][0]) / 2 + 5, f = (u[0][1] + u[3][1]) / 2, d = "left") : a === "insideRight" ? (h = (u[1][0] + u[2][0]) / 2 - 5, f = (u[1][1] + u[2][1]) / 2, d = "right") : (h = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, f = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, d = "center"), p = [[h, f], [h, f]];
    else {
      var g = void 0, v = void 0, m = void 0, y = void 0, C = s.get("length");
      process.env.NODE_ENV !== "production" && (r === "vertical" && ["top", "bottom"].indexOf(a) > -1 && (a = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), r === "horizontal" && ["left", "right"].indexOf(a) > -1 && (a = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), a === "left" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, m = g - C, h = m - 5, d = "right") : a === "right" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, m = g + C, h = m + 5, d = "left") : a === "top" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, y = v - C, f = y - 5, d = "center") : a === "bottom" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, y = v + C, f = y + 5, d = "center") : a === "rightTop" ? (g = r === "horizontal" ? u[3][0] : u[1][0], v = r === "horizontal" ? u[3][1] : u[1][1], r === "horizontal" ? (y = v - C, f = y - 5, d = "center") : (m = g + C, h = m + 5, d = "top")) : a === "rightBottom" ? (g = u[2][0], v = u[2][1], r === "horizontal" ? (y = v + C, f = y + 5, d = "center") : (m = g + C, h = m + 5, d = "bottom")) : a === "leftTop" ? (g = u[0][0], v = r === "horizontal" ? u[0][1] : u[1][1], r === "horizontal" ? (y = v - C, f = y - 5, d = "center") : (m = g - C, h = m - 5, d = "right")) : a === "leftBottom" ? (g = r === "horizontal" ? u[1][0] : u[3][0], v = r === "horizontal" ? u[1][1] : u[2][1], r === "horizontal" ? (y = v + C, f = y + 5, d = "center") : (m = g - C, h = m - 5, d = "right")) : (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, r === "horizontal" ? (y = v + C, f = y + 5, d = "center") : (m = g + C, h = m + 5, d = "left")), r === "horizontal" ? (m = g, h = m) : (y = v, f = y), p = [[g, v], [m, y]];
    }
    l.label = {
      linePoints: p,
      x: h,
      y: f,
      verticalAlign: "middle",
      textAlign: d,
      inside: c
    };
  });
}
function f_e(e, t) {
  e.eachSeriesByType("funnel", function(r) {
    var n = r.getData(), i = n.mapDimension("value"), o = r.get("sort"), a = c_e(r, t), s = r.get("orient"), l = a.width, u = a.height, c = d_e(n, o), d = a.x, h = a.y, f = s === "horizontal" ? [Ae(r.get("minSize"), u), Ae(r.get("maxSize"), u)] : [Ae(r.get("minSize"), l), Ae(r.get("maxSize"), l)], p = n.getDataExtent(i), g = r.get("min"), v = r.get("max");
    g == null && (g = Math.min(p[0], 0)), v == null && (v = p[1]);
    var m = r.get("funnelAlign"), y = r.get("gap"), C = s === "horizontal" ? l : u, S = (C - y * (n.count() - 1)) / n.count(), b = function(A, O) {
      if (s === "horizontal") {
        var L = n.get(i, A) || 0, N = nr(L, [g, v], f, !0), F = void 0;
        switch (m) {
          case "top":
            F = h;
            break;
          case "center":
            F = h + (u - N) / 2;
            break;
          case "bottom":
            F = h + (u - N);
            break;
        }
        return [[O, F], [O, F + N]];
      }
      var G = n.get(i, A) || 0, M = nr(G, [g, v], f, !0), V;
      switch (m) {
        case "left":
          V = d;
          break;
        case "center":
          V = d + (l - M) / 2;
          break;
        case "right":
          V = d + l - M;
          break;
      }
      return [[V, O], [V + M, O]];
    };
    o === "ascending" && (S = -S, y = -y, s === "horizontal" ? d += l : h += u, c = c.reverse());
    for (var w = 0; w < c.length; w++) {
      var x = c[w], E = c[w + 1], R = n.getItemModel(x);
      if (s === "horizontal") {
        var _ = R.get(["itemStyle", "width"]);
        _ == null ? _ = S : (_ = Ae(_, l), o === "ascending" && (_ = -_));
        var P = b(x, d), D = b(E, d + _);
        d += _ + y, n.setItemLayout(x, {
          points: P.concat(D.slice().reverse())
        });
      } else {
        var I = R.get(["itemStyle", "height"]);
        I == null ? I = S : (I = Ae(I, u), o === "ascending" && (I = -I));
        var P = b(x, h), D = b(E, h + I);
        h += I + y, n.setItemLayout(x, {
          points: P.concat(D.slice().reverse())
        });
      }
    }
    h_e(n);
  });
}
function p_e(e) {
  e.registerChartView(l_e), e.registerSeriesModel(u_e), e.registerLayout(f_e), e.registerProcessor(Hv("funnel"));
}
var g_e = 0.3, v_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._dataGroup = new it(), r._initialized = !1, r;
    }
    return t.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, t.prototype.render = function(r, n, i, o) {
      this._progressiveEls = null;
      var a = this._dataGroup, s = r.getData(), l = this._data, u = r.coordinateSystem, c = u.dimensions, d = WV(r);
      s.diff(l).add(h).update(f).remove(p).execute();
      function h(v) {
        var m = $V(s, a, v, c, u);
        ix(m, s, v, d);
      }
      function f(v, m) {
        var y = l.getItemGraphicEl(m), C = oj(s, v, c, u);
        s.setItemGraphicEl(v, y), jt(y, {
          shape: {
            points: C
          }
        }, r, v), Ca(y), ix(y, s, v, d);
      }
      function p(v) {
        var m = l.getItemGraphicEl(v);
        a.remove(m);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var g = m_e(u, r, function() {
          setTimeout(function() {
            a.removeClipPath();
          });
        });
        a.setClipPath(g);
      }
      this._data = s;
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, t.prototype.incrementalRender = function(r, n, i) {
      for (var o = n.getData(), a = n.coordinateSystem, s = a.dimensions, l = WV(n), u = this._progressiveEls = [], c = r.start; c < r.end; c++) {
        var d = $V(o, this._dataGroup, c, s, a);
        d.incremental = !0, ix(d, o, c, l), u.push(d);
      }
    }, t.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, t.type = "parallel", t;
  }(ar)
);
function m_e(e, t, r) {
  var n = e.model, i = e.getRect(), o = new Bt({
    shape: {
      x: i.x,
      y: i.y,
      width: i.width,
      height: i.height
    }
  }), a = n.get("layout") === "horizontal" ? "width" : "height";
  return o.setShape(a, 0), Pr(o, {
    shape: {
      width: i.width,
      height: i.height
    }
  }, t, r), o;
}
function oj(e, t, r, n) {
  for (var i = [], o = 0; o < r.length; o++) {
    var a = r[o], s = e.get(e.mapDimension(a), t);
    y_e(s, n.getAxis(a).type) || i.push(n.dataToPoint(s, a));
  }
  return i;
}
function $V(e, t, r, n, i) {
  var o = oj(e, r, n, i), a = new Ri({
    shape: {
      points: o
    },
    // silent: true,
    z2: 10
  });
  return t.add(a), e.setItemGraphicEl(r, a), a;
}
function WV(e) {
  var t = e.get("smooth", !0);
  return t === !0 && (t = g_e), t = Ja(t), $l(t) && (t = 0), {
    smooth: t
  };
}
function ix(e, t, r, n) {
  e.useStyle(t.getItemVisual(r, "style")), e.style.fill = null, e.setShape("smooth", n.smooth);
  var i = t.getItemModel(r), o = i.getModel("emphasis");
  Bn(e, i, "lineStyle"), Hr(e, o.get("focus"), o.get("blurScope"), o.get("disabled"));
}
function y_e(e, t) {
  return t === "category" ? e == null : e == null || isNaN(e);
}
var C_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.visualStyleAccessPath = "lineStyle", r.visualDrawType = "stroke", r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return os(null, this, {
        useEncodeDefaulter: ke(S_e, null, this)
      });
    }, t.prototype.getRawIndicesByActiveState = function(r) {
      var n = this.coordinateSystem, i = this.getData(), o = [];
      return n.eachActiveState(i, function(a, s) {
        r === a && o.push(i.getRawIndex(s));
      }), o;
    }, t.type = "series.parallel", t.dependencies = ["parallel"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, t;
  }(hr)
);
function S_e(e) {
  var t = e.ecModel.getComponent("parallel", e.get("parallelIndex"));
  if (t) {
    var r = {};
    return B(t.dimensions, function(n) {
      var i = w_e(n);
      r[n] = i;
    }), r;
  }
}
function w_e(e) {
  return +e.replace("dim", "");
}
var b_e = ["lineStyle", "opacity"], x_e = {
  seriesType: "parallel",
  reset: function(e, t) {
    var r = e.coordinateSystem, n = {
      normal: e.get(["lineStyle", "opacity"]),
      active: e.get("activeOpacity"),
      inactive: e.get("inactiveOpacity")
    };
    return {
      progress: function(i, o) {
        r.eachActiveState(o, function(a, s) {
          var l = n[a];
          if (a === "normal" && o.hasItemOption) {
            var u = o.getItemModel(s).get(b_e, !0);
            u != null && (l = u);
          }
          var c = o.ensureUniqueItemVisual(s, "style");
          c.opacity = l;
        }, i.start, i.end);
      }
    };
  }
};
function E_e(e) {
  R_e(e), __e(e);
}
function R_e(e) {
  if (!e.parallel) {
    var t = !1;
    B(e.series, function(r) {
      r && r.type === "parallel" && (t = !0);
    }), t && (e.parallel = [{}]);
  }
}
function __e(e) {
  var t = dr(e.parallelAxis);
  B(t, function(r) {
    if (Ze(r)) {
      var n = r.parallelIndex || 0, i = dr(e.parallel)[n];
      i && i.parallelAxisDefault && yt(r, i.parallelAxisDefault, !1);
    }
  });
}
var T_e = 5, P_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      this._model = r, this._api = i, this._handlers || (this._handlers = {}, B(M_e, function(o, a) {
        i.getZr().on(a, this._handlers[a] = ke(o, this));
      }, this)), gf(this, "_throttledDispatchExpand", r.get("axisExpandRate"), "fixRate");
    }, t.prototype.dispose = function(r, n) {
      zg(this, "_throttledDispatchExpand"), B(this._handlers, function(i, o) {
        n.getZr().off(o, i);
      }), this._handlers = null;
    }, t.prototype._throttledDispatchExpand = function(r) {
      this._dispatchExpand(r);
    }, t.prototype._dispatchExpand = function(r) {
      r && this._api.dispatchAction(se({
        type: "parallelAxisExpand"
      }, r));
    }, t.type = "parallel", t;
  }(Rr)
), M_e = {
  mousedown: function(e) {
    ox(this, "click") && (this._mouseDownPoint = [e.offsetX, e.offsetY]);
  },
  mouseup: function(e) {
    var t = this._mouseDownPoint;
    if (ox(this, "click") && t) {
      var r = [e.offsetX, e.offsetY], n = Math.pow(t[0] - r[0], 2) + Math.pow(t[1] - r[1], 2);
      if (n > T_e)
        return;
      var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]);
      i.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: i.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(e) {
    if (!(this._mouseDownPoint || !ox(this, "mousemove"))) {
      var t = this._model, r = t.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY]), n = r.behavior;
      n === "jump" && this._throttledDispatchExpand.debounceNextCall(t.get("axisExpandDebounce")), this._throttledDispatchExpand(n === "none" ? null : {
        axisExpandWindow: r.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: n === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function ox(e, t) {
  var r = e._model;
  return r.get("axisExpandable") && r.get("axisExpandTriggerOn") === t;
}
var D_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function() {
      e.prototype.init.apply(this, arguments), this.mergeOption({});
    }, t.prototype.mergeOption = function(r) {
      var n = this.option;
      r && yt(n, r, !0), this._initDimensions();
    }, t.prototype.contains = function(r, n) {
      var i = r.get("parallelIndex");
      return i != null && n.getComponent("parallel", i) === this;
    }, t.prototype.setAxisExpand = function(r) {
      B(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(n) {
        r.hasOwnProperty(n) && (this.option[n] = r[n]);
      }, this);
    }, t.prototype._initDimensions = function() {
      var r = this.dimensions = [], n = this.parallelAxisIndex = [], i = ir(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(o) {
        return (o.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      B(i, function(o) {
        r.push("dim" + o.get("dim")), n.push(o.componentIndex);
      });
    }, t.type = "parallel", t.dependencies = ["parallelAxis"], t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, t;
  }(Rt)
), A_e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i, o, a) {
      var s = e.call(this, r, n, i) || this;
      return s.type = o || "value", s.axisIndex = a, s;
    }
    return t.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, t;
  }(Wo)
);
function Qc(e, t, r, n, i, o) {
  e = e || 0;
  var a = r[1] - r[0];
  if (i != null && (i = Ld(i, [0, a])), o != null && (o = Math.max(o, i ?? 0)), n === "all") {
    var s = Math.abs(t[1] - t[0]);
    s = Ld(s, [0, a]), i = o = Ld(s, [i, o]), n = 0;
  }
  t[0] = Ld(t[0], r), t[1] = Ld(t[1], r);
  var l = ax(t, n);
  t[n] += e;
  var u = i || 0, c = r.slice();
  l.sign < 0 ? c[0] += u : c[1] -= u, t[n] = Ld(t[n], c);
  var d;
  return d = ax(t, n), i != null && (d.sign !== l.sign || d.span < i) && (t[1 - n] = t[n] + l.sign * i), d = ax(t, n), o != null && d.span > o && (t[1 - n] = t[n] + d.sign * o), t;
}
function ax(e, t) {
  var r = e[t] - e[1 - t];
  return {
    span: Math.abs(r),
    sign: r > 0 ? -1 : r < 0 ? 1 : t ? -1 : 1
  };
}
function Ld(e, t) {
  return Math.min(t[1] != null ? t[1] : 1 / 0, Math.max(t[0] != null ? t[0] : -1 / 0, e));
}
var sx = B, aj = Math.min, sj = Math.max, jV = Math.floor, I_e = Math.ceil, UV = Gr, F_e = Math.PI, L_e = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "parallel", this._axesMap = We(), this._axesLayout = {}, this.dimensions = t.dimensions, this._model = t, this._init(t, r, n);
    }
    return e.prototype._init = function(t, r, n) {
      var i = t.dimensions, o = t.parallelAxisIndex;
      sx(i, function(a, s) {
        var l = o[s], u = r.getComponent("parallelAxis", l), c = this._axesMap.set(a, new A_e(a, Nv(u), [0, 0], u.get("type"), l)), d = c.type === "category";
        c.onBand = d && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, e.prototype.update = function(t, r) {
      this._updateAxesFromSeries(this._model, t);
    }, e.prototype.containPoint = function(t) {
      var r = this._makeLayoutInfo(), n = r.axisBase, i = r.layoutBase, o = r.pixelDimIndex, a = t[1 - o], s = t[o];
      return a >= n && a <= n + r.axisLength && s >= i && s <= i + r.layoutLength;
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype._updateAxesFromSeries = function(t, r) {
      r.eachSeries(function(n) {
        if (t.contains(n, r)) {
          var i = n.getData();
          sx(this.dimensions, function(o) {
            var a = this._axesMap.get(o);
            a.scale.unionExtentFromData(i, i.mapDimension(o)), Ic(a.scale, a.model);
          }, this);
        }
      }, this);
    }, e.prototype.resize = function(t, r) {
      this._rect = hn(t.getBoxLayoutParams(), {
        width: r.getWidth(),
        height: r.getHeight()
      }), this._layoutAxes();
    }, e.prototype.getRect = function() {
      return this._rect;
    }, e.prototype._makeLayoutInfo = function() {
      var t = this._model, r = this._rect, n = ["x", "y"], i = ["width", "height"], o = t.get("layout"), a = o === "horizontal" ? 0 : 1, s = r[i[a]], l = [0, s], u = this.dimensions.length, c = py(t.get("axisExpandWidth"), l), d = py(t.get("axisExpandCount") || 0, [0, u]), h = t.get("axisExpandable") && u > 3 && u > d && d > 1 && c > 0 && s > 0, f = t.get("axisExpandWindow"), p;
      if (f)
        p = py(f[1] - f[0], l), f[1] = f[0] + p;
      else {
        p = py(c * (d - 1), l);
        var g = t.get("axisExpandCenter") || jV(u / 2);
        f = [c * g - p / 2], f[1] = f[0] + p;
      }
      var v = (s - p) / (u - d);
      v < 3 && (v = 0);
      var m = [jV(UV(f[0] / c, 1)) + 1, I_e(UV(f[1] / c, 1)) - 1], y = v / c * f[0];
      return {
        layout: o,
        pixelDimIndex: a,
        layoutBase: r[n[a]],
        layoutLength: s,
        axisBase: r[n[1 - a]],
        axisLength: r[i[1 - a]],
        axisExpandable: h,
        axisExpandWidth: c,
        axisCollapseWidth: v,
        axisExpandWindow: f,
        axisCount: u,
        winInnerIndices: m,
        axisExpandWindow0Pos: y
      };
    }, e.prototype._layoutAxes = function() {
      var t = this._rect, r = this._axesMap, n = this.dimensions, i = this._makeLayoutInfo(), o = i.layout;
      r.each(function(a) {
        var s = [0, i.axisLength], l = a.inverse ? 1 : 0;
        a.setExtent(s[l], s[1 - l]);
      }), sx(n, function(a, s) {
        var l = (i.axisExpandable ? N_e : O_e)(s, i), u = {
          horizontal: {
            x: l.position,
            y: i.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: F_e / 2,
          vertical: 0
        }, d = [u[o].x + t.x, u[o].y + t.y], h = c[o], f = ki();
        nu(f, f, h), ma(f, f, d), this._axesLayout[a] = {
          position: d,
          rotation: h,
          transform: f,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, e.prototype.getAxis = function(t) {
      return this._axesMap.get(t);
    }, e.prototype.dataToPoint = function(t, r) {
      return this.axisCoordToPoint(this._axesMap.get(r).dataToCoord(t), r);
    }, e.prototype.eachActiveState = function(t, r, n, i) {
      n == null && (n = 0), i == null && (i = t.count());
      var o = this._axesMap, a = this.dimensions, s = [], l = [];
      B(a, function(v) {
        s.push(t.mapDimension(v)), l.push(o.get(v).model);
      });
      for (var u = this.hasAxisBrushed(), c = n; c < i; c++) {
        var d = void 0;
        if (!u)
          d = "normal";
        else {
          d = "active";
          for (var h = t.getValues(s, c), f = 0, p = a.length; f < p; f++) {
            var g = l[f].getActiveState(h[f]);
            if (g === "inactive") {
              d = "inactive";
              break;
            }
          }
        }
        r(d, c);
      }
    }, e.prototype.hasAxisBrushed = function() {
      for (var t = this.dimensions, r = this._axesMap, n = !1, i = 0, o = t.length; i < o; i++)
        r.get(t[i]).model.getActiveState() !== "normal" && (n = !0);
      return n;
    }, e.prototype.axisCoordToPoint = function(t, r) {
      var n = this._axesLayout[r];
      return fa([t, 0], n.transform);
    }, e.prototype.getAxisLayout = function(t) {
      return et(this._axesLayout[t]);
    }, e.prototype.getSlidedAxisExpandWindow = function(t) {
      var r = this._makeLayoutInfo(), n = r.pixelDimIndex, i = r.axisExpandWindow.slice(), o = i[1] - i[0], a = [0, r.axisExpandWidth * (r.axisCount - 1)];
      if (!this.containPoint(t))
        return {
          behavior: "none",
          axisExpandWindow: i
        };
      var s = t[n] - r.layoutBase - r.axisExpandWindow0Pos, l, u = "slide", c = r.axisCollapseWidth, d = this._model.get("axisExpandSlideTriggerArea"), h = d[0] != null;
      if (c)
        h && c && s < o * d[0] ? (u = "jump", l = s - o * d[2]) : h && c && s > o * (1 - d[0]) ? (u = "jump", l = s - o * (1 - d[2])) : (l = s - o * d[1]) >= 0 && (l = s - o * (1 - d[1])) <= 0 && (l = 0), l *= r.axisExpandWidth / c, l ? Qc(l, i, a, "all") : u = "none";
      else {
        var f = i[1] - i[0], p = a[1] * s / f;
        i = [sj(0, p - f / 2)], i[1] = aj(a[1], i[0] + f), i[0] = i[1] - f;
      }
      return {
        axisExpandWindow: i,
        behavior: u
      };
    }, e;
  }()
);
function py(e, t) {
  return aj(sj(e, t[0]), t[1]);
}
function O_e(e, t) {
  var r = t.layoutLength / (t.axisCount - 1);
  return {
    position: r * e,
    axisNameAvailableWidth: r,
    axisLabelShow: !0
  };
}
function N_e(e, t) {
  var r = t.layoutLength, n = t.axisExpandWidth, i = t.axisCount, o = t.axisCollapseWidth, a = t.winInnerIndices, s, l = o, u = !1, c;
  return e < a[0] ? (s = e * o, c = o) : e <= a[1] ? (s = t.axisExpandWindow0Pos + e * n - t.axisExpandWindow[0], l = n, u = !0) : (s = r - (i - 1 - e) * o, c = o), {
    position: s,
    axisNameAvailableWidth: l,
    axisLabelShow: u,
    nameTruncateMaxWidth: c
  };
}
function k_e(e, t) {
  var r = [];
  return e.eachComponent("parallel", function(n, i) {
    var o = new L_e(n, e, t);
    o.name = "parallel_" + i, o.resize(n, t), n.coordinateSystem = o, o.model = n, r.push(o);
  }), e.eachSeries(function(n) {
    if (n.get("coordinateSystem") === "parallel") {
      var i = n.getReferringComponents("parallel", un).models[0];
      n.coordinateSystem = i.coordinateSystem;
    }
  }), r;
}
var V_e = {
  create: k_e
}, j_ = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.activeIntervals = [], r;
    }
    return t.prototype.getAreaSelectStyle = function() {
      return Mc([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, t.prototype.setActiveIntervals = function(r) {
      var n = this.activeIntervals = et(r);
      if (n)
        for (var i = n.length - 1; i >= 0; i--)
          Ji(n[i]);
    }, t.prototype.getActiveState = function(r) {
      var n = this.activeIntervals;
      if (!n.length)
        return "normal";
      if (r == null || isNaN(+r))
        return "inactive";
      if (n.length === 1) {
        var i = n[0];
        if (i[0] <= r && r <= i[1])
          return "active";
      } else
        for (var o = 0, a = n.length; o < a; o++)
          if (n[o][0] <= r && r <= n[o][1])
            return "active";
      return "inactive";
    }, t;
  }(Rt)
);
qr(j_, Cf);
var Fc = !0, ev = Math.min, Bh = Math.max, B_e = Math.pow, G_e = 1e4, H_e = 6, z_e = 6, KV = "globalPan", $_e = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, W_e = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, YV = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, j_e = 0, ID = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this) || this;
      return n._track = [], n._covers = [], n._handlers = {}, process.env.NODE_ENV !== "production" && Qe(r), n._zr = r, n.group = new it(), n._uid = "brushController_" + j_e++, B(Q_e, function(i, o) {
        this._handlers[o] = ke(i, this);
      }, n), n;
    }
    return t.prototype.enableBrush = function(r) {
      return process.env.NODE_ENV !== "production" && Qe(this._mounted), this._brushType && this._doDisableBrush(), r.brushType && this._doEnableBrush(r), this;
    }, t.prototype._doEnableBrush = function(r) {
      var n = this._zr;
      this._enableGlobalPan || Oxe(n, KV, this._uid), B(this._handlers, function(i, o) {
        n.on(o, i);
      }), this._brushType = r.brushType, this._brushOption = yt(et(YV), r, !0);
    }, t.prototype._doDisableBrush = function() {
      var r = this._zr;
      Nxe(r, KV, this._uid), B(this._handlers, function(n, i) {
        r.off(i, n);
      }), this._brushType = this._brushOption = null;
    }, t.prototype.setPanels = function(r) {
      if (r && r.length) {
        var n = this._panels = {};
        B(r, function(i) {
          n[i.panelId] = et(i);
        });
      } else
        this._panels = null;
      return this;
    }, t.prototype.mount = function(r) {
      r = r || {}, process.env.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = r.enableGlobalPan;
      var n = this.group;
      return this._zr.add(n), n.attr({
        x: r.x || 0,
        y: r.y || 0,
        rotation: r.rotation || 0,
        scaleX: r.scaleX || 1,
        scaleY: r.scaleY || 1
      }), this._transform = n.getLocalTransform(), this;
    }, t.prototype.updateCovers = function(r) {
      process.env.NODE_ENV !== "production" && Qe(this._mounted), r = ge(r, function(h) {
        return yt(et(YV), h, !0);
      });
      var n = "\0-brush-index-", i = this._covers, o = this._covers = [], a = this, s = this._creatingCover;
      return new Ws(i, r, u, l).add(c).update(c).remove(d).execute(), this;
      function l(h, f) {
        return (h.id != null ? h.id : n + f) + "-" + h.brushType;
      }
      function u(h, f) {
        return l(h.__brushOption, f);
      }
      function c(h, f) {
        var p = r[h];
        if (f != null && i[f] === s)
          o[h] = i[f];
        else {
          var g = o[h] = f != null ? (i[f].__brushOption = p, i[f]) : uj(a, lj(a, p));
          FD(a, g);
        }
      }
      function d(h) {
        i[h] !== s && a.group.remove(i[h]);
      }
    }, t.prototype.unmount = function() {
      if (!(process.env.NODE_ENV !== "production" && !this._mounted))
        return this.enableBrush(!1), U_(this), this._zr.remove(this.group), process.env.NODE_ENV !== "production" && (this._mounted = !1), this;
    }, t.prototype.dispose = function() {
      this.unmount(), this.off();
    }, t;
  }(Go)
);
function lj(e, t) {
  var r = uw[t.brushType].createCover(e, t);
  return r.__brushOption = t, dj(r, t), e.group.add(r), r;
}
function uj(e, t) {
  var r = LD(t);
  return r.endCreating && (r.endCreating(e, t), dj(t, t.__brushOption)), t;
}
function cj(e, t) {
  var r = t.__brushOption;
  LD(t).updateCoverShape(e, t, r.range, r);
}
function dj(e, t) {
  var r = t.z;
  r == null && (r = G_e), e.traverse(function(n) {
    n.z = r, n.z2 = r;
  });
}
function FD(e, t) {
  LD(t).updateCommon(e, t), cj(e, t);
}
function LD(e) {
  return uw[e.__brushOption.brushType];
}
function OD(e, t, r) {
  var n = e._panels;
  if (!n)
    return Fc;
  var i, o = e._transform;
  return B(n, function(a) {
    a.isTargetByCursor(t, r, o) && (i = a);
  }), i;
}
function hj(e, t) {
  var r = e._panels;
  if (!r)
    return Fc;
  var n = t.__brushOption.panelId;
  return n != null ? r[n] : Fc;
}
function U_(e) {
  var t = e._covers, r = t.length;
  return B(t, function(n) {
    e.group.remove(n);
  }, e), t.length = 0, !!r;
}
function Lc(e, t) {
  var r = ge(e._covers, function(n) {
    var i = n.__brushOption, o = et(i.range);
    return {
      brushType: i.brushType,
      panelId: i.panelId,
      range: o
    };
  });
  e.trigger("brush", {
    areas: r,
    isEnd: !!t.isEnd,
    removeOnClick: !!t.removeOnClick
  });
}
function U_e(e) {
  var t = e._track;
  if (!t.length)
    return !1;
  var r = t[t.length - 1], n = t[0], i = r[0] - n[0], o = r[1] - n[1], a = B_e(i * i + o * o, 0.5);
  return a > H_e;
}
function fj(e) {
  var t = e.length - 1;
  return t < 0 && (t = 0), [e[0], e[t]];
}
function pj(e, t, r, n) {
  var i = new it();
  return i.add(new Bt({
    name: "main",
    style: ND(r),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: dt(qV, e, t, i, ["n", "s", "w", "e"]),
    ondragend: dt(Lc, t, {
      isEnd: !0
    })
  })), B(n, function(o) {
    i.add(new Bt({
      name: o.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: dt(qV, e, t, i, o),
      ondragend: dt(Lc, t, {
        isEnd: !0
      })
    }));
  }), i;
}
function gj(e, t, r, n) {
  var i = n.brushStyle.lineWidth || 0, o = Bh(i, z_e), a = r[0][0], s = r[1][0], l = a - i / 2, u = s - i / 2, c = r[0][1], d = r[1][1], h = c - o + i / 2, f = d - o + i / 2, p = c - a, g = d - s, v = p + i, m = g + i;
  gs(e, t, "main", a, s, p, g), n.transformable && (gs(e, t, "w", l, u, o, m), gs(e, t, "e", h, u, o, m), gs(e, t, "n", l, u, v, o), gs(e, t, "s", l, f, v, o), gs(e, t, "nw", l, u, o, o), gs(e, t, "ne", h, u, o, o), gs(e, t, "sw", l, f, o, o), gs(e, t, "se", h, f, o, o));
}
function K_(e, t) {
  var r = t.__brushOption, n = r.transformable, i = t.childAt(0);
  i.useStyle(ND(r)), i.attr({
    silent: !n,
    cursor: n ? "move" : "default"
  }), B([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(o) {
    var a = t.childOfName(o.join("")), s = o.length === 1 ? Y_(e, o[0]) : Y_e(e, o);
    a && a.attr({
      silent: !n,
      invisible: !n,
      cursor: n ? W_e[s] + "-resize" : null
    });
  });
}
function gs(e, t, r, n, i, o, a) {
  var s = t.childOfName(r);
  s && s.setShape(Z_e(kD(e, t, [[n, i], [n + o, i + a]])));
}
function ND(e) {
  return Xe({
    strokeNoScale: !0
  }, e.brushStyle);
}
function vj(e, t, r, n) {
  var i = [ev(e, r), ev(t, n)], o = [Bh(e, r), Bh(t, n)];
  return [
    [i[0], o[0]],
    [i[1], o[1]]
    // y range
  ];
}
function K_e(e) {
  return Ll(e.group);
}
function Y_(e, t) {
  var r = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, n = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, i = HS(r[t], K_e(e));
  return n[i];
}
function Y_e(e, t) {
  var r = [Y_(e, t[0]), Y_(e, t[1])];
  return (r[0] === "e" || r[0] === "w") && r.reverse(), r.join("");
}
function qV(e, t, r, n, i, o) {
  var a = r.__brushOption, s = e.toRectRange(a.range), l = mj(t, i, o);
  B(n, function(u) {
    var c = $_e[u];
    s[c[0]][c[1]] += l[c[0]];
  }), a.range = e.fromRectRange(vj(s[0][0], s[1][0], s[0][1], s[1][1])), FD(t, r), Lc(t, {
    isEnd: !1
  });
}
function q_e(e, t, r, n) {
  var i = t.__brushOption.range, o = mj(e, r, n);
  B(i, function(a) {
    a[0] += o[0], a[1] += o[1];
  }), FD(e, t), Lc(e, {
    isEnd: !1
  });
}
function mj(e, t, r) {
  var n = e.group, i = n.transformCoordToLocal(t, r), o = n.transformCoordToLocal(0, 0);
  return [i[0] - o[0], i[1] - o[1]];
}
function kD(e, t, r) {
  var n = hj(e, t);
  return n && n !== Fc ? n.clipPath(r, e._transform) : et(r);
}
function Z_e(e) {
  var t = ev(e[0][0], e[1][0]), r = ev(e[0][1], e[1][1]), n = Bh(e[0][0], e[1][0]), i = Bh(e[0][1], e[1][1]);
  return {
    x: t,
    y: r,
    width: n - t,
    height: i - r
  };
}
function X_e(e, t, r) {
  if (
    // Check active
    !(!e._brushType || J_e(e, t.offsetX, t.offsetY))
  ) {
    var n = e._zr, i = e._covers, o = OD(e, t, r);
    if (!e._dragging)
      for (var a = 0; a < i.length; a++) {
        var s = i[a].__brushOption;
        if (o && (o === Fc || s.panelId === o.panelId) && uw[s.brushType].contain(i[a], r[0], r[1]))
          return;
      }
    o && n.setCursorStyle("crosshair");
  }
}
function q_(e) {
  var t = e.event;
  t.preventDefault && t.preventDefault();
}
function Z_(e, t, r) {
  return e.childOfName("main").contain(t, r);
}
function yj(e, t, r, n) {
  var i = e._creatingCover, o = e._creatingPanel, a = e._brushOption, s;
  if (e._track.push(r.slice()), U_e(e) || i) {
    if (o && !i) {
      a.brushMode === "single" && U_(e);
      var l = et(a);
      l.brushType = ZV(l.brushType, o), l.panelId = o === Fc ? null : o.panelId, i = e._creatingCover = lj(e, l), e._covers.push(i);
    }
    if (i) {
      var u = uw[ZV(e._brushType, o)], c = i.__brushOption;
      c.range = u.getCreatingRange(kD(e, i, e._track)), n && (uj(e, i), u.updateCommon(e, i)), cj(e, i), s = {
        isEnd: n
      };
    }
  } else n && a.brushMode === "single" && a.removeOnClick && OD(e, t, r) && U_(e) && (s = {
    isEnd: n,
    removeOnClick: !0
  });
  return s;
}
function ZV(e, t) {
  return e === "auto" ? (process.env.NODE_ENV !== "production" && Qe(t && t.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), t.defaultBrushType) : e;
}
var Q_e = {
  mousedown: function(e) {
    if (this._dragging)
      XV(this, e);
    else if (!e.target || !e.target.draggable) {
      q_(e);
      var t = this.group.transformCoordToLocal(e.offsetX, e.offsetY);
      this._creatingCover = null;
      var r = this._creatingPanel = OD(this, e, t);
      r && (this._dragging = !0, this._track = [t.slice()]);
    }
  },
  mousemove: function(e) {
    var t = e.offsetX, r = e.offsetY, n = this.group.transformCoordToLocal(t, r);
    if (X_e(this, e, n), this._dragging) {
      q_(e);
      var i = yj(this, e, n, !1);
      i && Lc(this, i);
    }
  },
  mouseup: function(e) {
    XV(this, e);
  }
};
function XV(e, t) {
  if (e._dragging) {
    q_(t);
    var r = t.offsetX, n = t.offsetY, i = e.group.transformCoordToLocal(r, n), o = yj(e, t, i, !0);
    e._dragging = !1, e._track = [], e._creatingCover = null, o && Lc(e, o);
  }
}
function J_e(e, t, r) {
  var n = e._zr;
  return t < 0 || t > n.getWidth() || r < 0 || r > n.getHeight();
}
var uw = {
  lineX: QV(0),
  lineY: QV(1),
  rect: {
    createCover: function(e, t) {
      function r(n) {
        return n;
      }
      return pj({
        toRectRange: r,
        fromRectRange: r
      }, e, t, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(e) {
      var t = fj(e);
      return vj(t[1][0], t[1][1], t[0][0], t[0][1]);
    },
    updateCoverShape: function(e, t, r, n) {
      gj(e, t, r, n);
    },
    updateCommon: K_,
    contain: Z_
  },
  polygon: {
    createCover: function(e, t) {
      var r = new it();
      return r.add(new Ri({
        name: "main",
        style: ND(t),
        silent: !0
      })), r;
    },
    getCreatingRange: function(e) {
      return e;
    },
    endCreating: function(e, t) {
      t.remove(t.childAt(0)), t.add(new Ei({
        name: "main",
        draggable: !0,
        drift: dt(q_e, e, t),
        ondragend: dt(Lc, e, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(e, t, r, n) {
      t.childAt(0).setShape({
        points: kD(e, t, r)
      });
    },
    updateCommon: K_,
    contain: Z_
  }
};
function QV(e) {
  return {
    createCover: function(t, r) {
      return pj({
        toRectRange: function(n) {
          var i = [n, [0, 100]];
          return e && i.reverse(), i;
        },
        fromRectRange: function(n) {
          return n[e];
        }
      }, t, r, [[["w"], ["e"]], [["n"], ["s"]]][e]);
    },
    getCreatingRange: function(t) {
      var r = fj(t), n = ev(r[0][e], r[1][e]), i = Bh(r[0][e], r[1][e]);
      return [n, i];
    },
    updateCoverShape: function(t, r, n, i) {
      var o, a = hj(t, r);
      if (a !== Fc && a.getLinearBrushOtherExtent)
        o = a.getLinearBrushOtherExtent(e);
      else {
        var s = t._zr;
        o = [0, [s.getWidth(), s.getHeight()][1 - e]];
      }
      var l = [n, o];
      e && l.reverse(), gj(t, r, l, i);
    },
    updateCommon: K_,
    contain: Z_
  };
}
function Cj(e) {
  return e = VD(e), function(t) {
    return xM(t, e);
  };
}
function Sj(e, t) {
  return e = VD(e), function(r) {
    var n = t ?? r, i = n ? e.width : e.height, o = n ? e.x : e.y;
    return [o, o + (i || 0)];
  };
}
function wj(e, t, r) {
  var n = VD(e);
  return function(i, o) {
    return n.contain(o[0], o[1]) && !ow(i, t, r);
  };
}
function VD(e) {
  return St.create(e);
}
var eTe = ["axisLine", "axisTickLabel", "axisName"], tTe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      e.prototype.init.apply(this, arguments), (this._brushController = new ID(n.getZr())).on("brush", ke(this._onBrush, this));
    }, t.prototype.render = function(r, n, i, o) {
      if (!rTe(r, n, o)) {
        this.axisModel = r, this.api = i, this.group.removeAll();
        var a = this._axisGroup;
        if (this._axisGroup = new it(), this.group.add(this._axisGroup), !!r.get("show")) {
          var s = iTe(r, n), l = s.coordinateSystem, u = r.getAreaSelectStyle(), c = u.width, d = r.axis.dim, h = l.getAxisLayout(d), f = se({
            strokeContainThreshold: c
          }, h), p = new Ci(r, f);
          B(eTe, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(f, u, r, s, c, i), Fv(a, this._axisGroup, r);
        }
      }
    }, t.prototype._refreshBrushController = function(r, n, i, o, a, s) {
      var l = i.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), d = St.create({
        x: l[0],
        y: -a / 2,
        width: u,
        height: a
      });
      d.x -= c, d.width += 2 * c, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: r.rotation,
        x: r.position[0],
        y: r.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: Cj(d),
        isTargetByCursor: wj(d, s, o),
        getLinearBrushOtherExtent: Sj(d, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: n,
        removeOnClick: !0
      }).updateCovers(nTe(i));
    }, t.prototype._onBrush = function(r) {
      var n = r.areas, i = this.axisModel, o = i.axis, a = ge(n, function(s) {
        return [o.coordToData(s.range[0], !0), o.coordToData(s.range[1], !0)];
      });
      (!i.option.realtime === r.isEnd || r.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: i.id,
        intervals: a
      });
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.type = "parallelAxis", t;
  }(Rr)
);
function rTe(e, t, r) {
  return r && r.type === "axisAreaSelect" && t.findComponents({
    mainType: "parallelAxis",
    query: r
  })[0] === e;
}
function nTe(e) {
  var t = e.axis;
  return ge(e.activeIntervals, function(r) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [t.dataToCoord(r[0], !0), t.dataToCoord(r[1], !0)]
    };
  });
}
function iTe(e, t) {
  return t.getComponent("parallel", e.get("parallelIndex"));
}
var oTe = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function aTe(e) {
  e.registerAction(oTe, function(t, r) {
    r.eachComponent({
      mainType: "parallelAxis",
      query: t
    }, function(n) {
      n.axis.model.setActiveIntervals(t.intervals);
    });
  }), e.registerAction("parallelAxisExpand", function(t, r) {
    r.eachComponent({
      mainType: "parallel",
      query: t
    }, function(n) {
      n.setAxisExpand(t);
    });
  });
}
var sTe = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function bj(e) {
  e.registerComponentView(P_e), e.registerComponentModel(D_e), e.registerCoordinateSystem("parallel", V_e), e.registerPreprocessor(E_e), e.registerComponentModel(j_), e.registerComponentView(tTe), Vh(e, "parallel", j_, sTe), aTe(e);
}
function lTe(e) {
  _t(bj), e.registerChartView(v_e), e.registerSeriesModel(C_e), e.registerVisual(e.PRIORITY.VISUAL.BRUSH, x_e);
}
var uTe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return e;
  }()
), cTe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      return e.call(this, r) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new uTe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.extent;
      r.moveTo(n.x1, n.y1), r.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (r.lineTo(n.x2 + i, n.y2), r.bezierCurveTo(n.cpx2 + i, n.cpy2, n.cpx1 + i, n.cpy1, n.x1 + i, n.y1)) : (r.lineTo(n.x2, n.y2 + i), r.bezierCurveTo(n.cpx2, n.cpy2 + i, n.cpx1, n.cpy1 + i, n.x1, n.y1 + i)), r.closePath();
    }, t.prototype.highlight = function() {
      zs(this);
    }, t.prototype.downplay = function() {
      $s(this);
    }, t;
  }(Mt)
), dTe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._focusAdjacencyDisabled = !1, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = this, a = r.getGraph(), s = this.group, l = r.layoutInfo, u = l.width, c = l.height, d = r.getData(), h = r.getData("edge"), f = r.get("orient");
      this._model = r, s.removeAll(), s.x = l.x, s.y = l.y, a.eachEdge(function(p) {
        var g = new cTe(), v = ot(g);
        v.dataIndex = p.dataIndex, v.seriesIndex = r.seriesIndex, v.dataType = "edge";
        var m = p.getModel(), y = m.getModel("lineStyle"), C = y.get("curveness"), S = p.node1.getLayout(), b = p.node1.getModel(), w = b.get("localX"), x = b.get("localY"), E = p.node2.getLayout(), R = p.node2.getModel(), _ = R.get("localX"), P = R.get("localY"), D = p.getLayout(), I, A, O, L, N, F, G, M;
        g.shape.extent = Math.max(1, D.dy), g.shape.orient = f, f === "vertical" ? (I = (w != null ? w * u : S.x) + D.sy, A = (x != null ? x * c : S.y) + S.dy, O = (_ != null ? _ * u : E.x) + D.ty, L = P != null ? P * c : E.y, N = I, F = A * (1 - C) + L * C, G = O, M = A * C + L * (1 - C)) : (I = (w != null ? w * u : S.x) + S.dx, A = (x != null ? x * c : S.y) + D.sy, O = _ != null ? _ * u : E.x, L = (P != null ? P * c : E.y) + D.ty, N = I * (1 - C) + O * C, F = A, G = I * C + O * (1 - C), M = L), g.setShape({
          x1: I,
          y1: A,
          x2: O,
          y2: L,
          cpx1: N,
          cpy1: F,
          cpx2: G,
          cpy2: M
        }), g.useStyle(y.getItemStyle()), JV(g.style, f, p);
        var V = "" + m.get("value"), z = Rn(m, "edgeLabel");
        Gn(g, z, {
          labelFetcher: {
            getFormattedLabel: function(W, j, U, Z, ee, J) {
              return r.getFormattedLabel(
                W,
                j,
                "edge",
                Z,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                ro(ee, z.normal && z.normal.get("formatter"), V),
                J
              );
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: V
        }), g.setTextConfig({
          position: "inside"
        });
        var k = m.getModel("emphasis");
        Bn(g, m, "lineStyle", function(W) {
          var j = W.getItemStyle();
          return JV(j, f, p), j;
        }), s.add(g), h.setItemGraphicEl(p.dataIndex, g);
        var $ = k.get("focus");
        Hr(g, $ === "adjacency" ? p.getAdjacentDataIndices() : $ === "trajectory" ? p.getTrajectoryDataIndices() : $, k.get("blurScope"), k.get("disabled"));
      }), a.eachNode(function(p) {
        var g = p.getLayout(), v = p.getModel(), m = v.get("localX"), y = v.get("localY"), C = v.getModel("emphasis"), S = v.get(["itemStyle", "borderRadius"]) || 0, b = new Bt({
          shape: {
            x: m != null ? m * u : g.x,
            y: y != null ? y * c : g.y,
            width: g.dx,
            height: g.dy,
            r: S
          },
          style: v.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Gn(b, Rn(v), {
          labelFetcher: {
            getFormattedLabel: function(x, E) {
              return r.getFormattedLabel(x, E, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), b.disableLabelAnimation = !0, b.setStyle("fill", p.getVisual("color")), b.setStyle("decal", p.getVisual("style").decal), Bn(b, v), s.add(b), d.setItemGraphicEl(p.dataIndex, b), ot(b).dataType = "node";
        var w = C.get("focus");
        Hr(b, w === "adjacency" ? p.getAdjacentDataIndices() : w === "trajectory" ? p.getTrajectoryDataIndices() : w, C.get("blurScope"), C.get("disabled"));
      }), d.eachItemGraphicEl(function(p, g) {
        var v = d.getItemModel(g);
        v.get("draggable") && (p.drift = function(m, y) {
          o._focusAdjacencyDisabled = !0, this.shape.x += m, this.shape.y += y, this.dirty(), i.dispatchAction({
            type: "dragNode",
            seriesId: r.id,
            dataIndex: d.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          o._focusAdjacencyDisabled = !1;
        }, p.draggable = !0, p.cursor = "move");
      }), !this._data && r.isAnimationEnabled() && s.setClipPath(hTe(s.getBoundingRect(), r, function() {
        s.removeClipPath();
      })), this._data = r.getData();
    }, t.prototype.dispose = function() {
    }, t.type = "sankey", t;
  }(ar)
);
function JV(e, t, r) {
  switch (e.fill) {
    case "source":
      e.fill = r.node1.getVisual("color"), e.decal = r.node1.getVisual("style").decal;
      break;
    case "target":
      e.fill = r.node2.getVisual("color"), e.decal = r.node2.getVisual("style").decal;
      break;
    case "gradient":
      var n = r.node1.getVisual("color"), i = r.node2.getVisual("color");
      Fe(n) && Fe(i) && (e.fill = new af(0, 0, +(t === "horizontal"), +(t === "vertical"), [{
        color: n,
        offset: 0
      }, {
        color: i,
        offset: 1
      }]));
  }
}
function hTe(e, t, r) {
  var n = new Bt({
    shape: {
      x: e.x - 10,
      y: e.y - 10,
      width: 0,
      height: e.height + 20
    }
  });
  return Pr(n, {
    shape: {
      width: e.width + 20
    }
  }, t, r), n;
}
var fTe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      var i = r.edges || r.links, o = r.data || r.nodes, a = r.levels;
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < a.length; l++)
        if (a[l].depth != null && a[l].depth >= 0)
          s[a[l].depth] = new cr(a[l], this, n);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      if (o && i) {
        var u = ij(o, i, this, !0, c);
        return u.data;
      }
      function c(d, h) {
        d.wrapMethod("getItemModel", function(f, p) {
          var g = f.parentModel, v = g.getData().getItemLayout(p);
          if (v) {
            var m = v.depth, y = g.levelModels[m];
            y && (f.parentModel = y);
          }
          return f;
        }), h.wrapMethod("getItemModel", function(f, p) {
          var g = f.parentModel, v = g.getGraph().getEdgeByIndex(p), m = v.node1.getLayout();
          if (m) {
            var y = m.depth, C = g.levelModels[y];
            C && (f.parentModel = C);
          }
          return f;
        });
      }
    }, t.prototype.setNodePosition = function(r, n) {
      var i = this.option.data || this.option.nodes, o = i[r];
      o.localX = n[0], o.localY = n[1];
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(r, n, i) {
      function o(f) {
        return isNaN(f) || f == null;
      }
      if (i === "edge") {
        var a = this.getDataParams(r, i), s = a.data, l = a.value, u = s.source + " -- " + s.target;
        return _n("nameValue", {
          name: u,
          value: l,
          noValue: o(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(r), d = c.getLayout().value, h = this.getDataParams(r, i).data.name;
        return _n("nameValue", {
          name: h != null ? h + "" : null,
          value: d,
          noValue: o(d)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(r, n) {
      var i = e.prototype.getDataParams.call(this, r, n);
      if (i.value == null && n === "node") {
        var o = this.getGraph().getNodeByIndex(r), a = o.getLayout().value;
        i.value = a;
      }
      return i;
    }, t.type = "series.sankey", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  }(hr)
);
function pTe(e, t) {
  e.eachSeriesByType("sankey", function(r) {
    var n = r.get("nodeWidth"), i = r.get("nodeGap"), o = gTe(r, t);
    r.layoutInfo = o;
    var a = o.width, s = o.height, l = r.getGraph(), u = l.nodes, c = l.edges;
    mTe(u);
    var d = ir(u, function(g) {
      return g.getLayout().value === 0;
    }), h = d.length !== 0 ? 0 : r.get("layoutIterations"), f = r.get("orient"), p = r.get("nodeAlign");
    vTe(u, c, n, i, a, s, h, f, p);
  });
}
function gTe(e, t) {
  return hn(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  });
}
function vTe(e, t, r, n, i, o, a, s, l) {
  yTe(e, t, r, i, o, s, l), bTe(e, t, o, i, n, a, s), ATe(e, s);
}
function mTe(e) {
  B(e, function(t) {
    var r = Nl(t.outEdges, EC), n = Nl(t.inEdges, EC), i = t.getValue() || 0, o = Math.max(r, n, i);
    t.setLayout({
      value: o
    }, !0);
  });
}
function yTe(e, t, r, n, i, o, a) {
  for (var s = [], l = [], u = [], c = [], d = 0, h = 0; h < t.length; h++)
    s[h] = 1;
  for (var h = 0; h < e.length; h++)
    l[h] = e[h].inEdges.length, l[h] === 0 && u.push(e[h]);
  for (var f = -1; u.length; ) {
    for (var p = 0; p < u.length; p++) {
      var g = u[p], v = g.hostGraph.data.getRawDataItem(g.dataIndex), m = v.depth != null && v.depth >= 0;
      m && v.depth > f && (f = v.depth), g.setLayout({
        depth: m ? v.depth : d
      }, !0), o === "vertical" ? g.setLayout({
        dy: r
      }, !0) : g.setLayout({
        dx: r
      }, !0);
      for (var y = 0; y < g.outEdges.length; y++) {
        var C = g.outEdges[y], S = t.indexOf(C);
        s[S] = 0;
        var b = C.node2, w = e.indexOf(b);
        --l[w] === 0 && c.indexOf(b) < 0 && c.push(b);
      }
    }
    ++d, u = c, c = [];
  }
  for (var h = 0; h < s.length; h++)
    if (s[h] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var x = f > d - 1 ? f : d - 1;
  a && a !== "left" && CTe(e, a, o, x);
  var E = o === "vertical" ? (i - r) / x : (n - r) / x;
  wTe(e, E, o);
}
function xj(e) {
  var t = e.hostGraph.data.getRawDataItem(e.dataIndex);
  return t.depth != null && t.depth >= 0;
}
function CTe(e, t, r, n) {
  if (t === "right") {
    for (var i = [], o = e, a = 0; o.length; ) {
      for (var s = 0; s < o.length; s++) {
        var l = o[s];
        l.setLayout({
          skNodeHeight: a
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          i.indexOf(c.node1) < 0 && i.push(c.node1);
        }
      }
      o = i, i = [], ++a;
    }
    B(e, function(d) {
      xj(d) || d.setLayout({
        depth: Math.max(0, n - d.getLayout().skNodeHeight)
      }, !0);
    });
  } else t === "justify" && STe(e, n);
}
function STe(e, t) {
  B(e, function(r) {
    !xj(r) && !r.outEdges.length && r.setLayout({
      depth: t
    }, !0);
  });
}
function wTe(e, t, r) {
  B(e, function(n) {
    var i = n.getLayout().depth * t;
    r === "vertical" ? n.setLayout({
      y: i
    }, !0) : n.setLayout({
      x: i
    }, !0);
  });
}
function bTe(e, t, r, n, i, o, a) {
  var s = xTe(e, a);
  ETe(s, t, r, n, i, a), lx(s, i, r, n, a);
  for (var l = 1; o > 0; o--)
    l *= 0.99, RTe(s, l, a), lx(s, i, r, n, a), DTe(s, l, a), lx(s, i, r, n, a);
}
function xTe(e, t) {
  var r = [], n = t === "vertical" ? "y" : "x", i = ZR(e, function(o) {
    return o.getLayout()[n];
  });
  return i.keys.sort(function(o, a) {
    return o - a;
  }), B(i.keys, function(o) {
    r.push(i.buckets.get(o));
  }), r;
}
function ETe(e, t, r, n, i, o) {
  var a = 1 / 0;
  B(e, function(s) {
    var l = s.length, u = 0;
    B(s, function(d) {
      u += d.getLayout().value;
    });
    var c = o === "vertical" ? (n - (l - 1) * i) / u : (r - (l - 1) * i) / u;
    c < a && (a = c);
  }), B(e, function(s) {
    B(s, function(l, u) {
      var c = l.getLayout().value * a;
      o === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), B(t, function(s) {
    var l = +s.getValue() * a;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function lx(e, t, r, n, i) {
  var o = i === "vertical" ? "x" : "y";
  B(e, function(a) {
    a.sort(function(g, v) {
      return g.getLayout()[o] - v.getLayout()[o];
    });
    for (var s, l, u, c = 0, d = a.length, h = i === "vertical" ? "dx" : "dy", f = 0; f < d; f++)
      l = a[f], u = c - l.getLayout()[o], u > 0 && (s = l.getLayout()[o] + u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), c = l.getLayout()[o] + l.getLayout()[h] + t;
    var p = i === "vertical" ? n : r;
    if (u = c - t - p, u > 0) {
      s = l.getLayout()[o] - u, i === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), c = s;
      for (var f = d - 2; f >= 0; --f)
        l = a[f], u = l.getLayout()[o] + l.getLayout()[h] + t - c, u > 0 && (s = l.getLayout()[o] - u, i === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), c = l.getLayout()[o];
    }
  });
}
function RTe(e, t, r) {
  B(e.slice().reverse(), function(n) {
    B(n, function(i) {
      if (i.outEdges.length) {
        var o = Nl(i.outEdges, _Te, r) / Nl(i.outEdges, EC);
        if (isNaN(o)) {
          var a = i.outEdges.length;
          o = a ? Nl(i.outEdges, TTe, r) / a : 0;
        }
        if (r === "vertical") {
          var s = i.getLayout().x + (o - Yl(i, r)) * t;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (o - Yl(i, r)) * t;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function _Te(e, t) {
  return Yl(e.node2, t) * e.getValue();
}
function TTe(e, t) {
  return Yl(e.node2, t);
}
function PTe(e, t) {
  return Yl(e.node1, t) * e.getValue();
}
function MTe(e, t) {
  return Yl(e.node1, t);
}
function Yl(e, t) {
  return t === "vertical" ? e.getLayout().x + e.getLayout().dx / 2 : e.getLayout().y + e.getLayout().dy / 2;
}
function EC(e) {
  return e.getValue();
}
function Nl(e, t, r) {
  for (var n = 0, i = e.length, o = -1; ++o < i; ) {
    var a = +t(e[o], r);
    isNaN(a) || (n += a);
  }
  return n;
}
function DTe(e, t, r) {
  B(e, function(n) {
    B(n, function(i) {
      if (i.inEdges.length) {
        var o = Nl(i.inEdges, PTe, r) / Nl(i.inEdges, EC);
        if (isNaN(o)) {
          var a = i.inEdges.length;
          o = a ? Nl(i.inEdges, MTe, r) / a : 0;
        }
        if (r === "vertical") {
          var s = i.getLayout().x + (o - Yl(i, r)) * t;
          i.setLayout({
            x: s
          }, !0);
        } else {
          var l = i.getLayout().y + (o - Yl(i, r)) * t;
          i.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function ATe(e, t) {
  var r = t === "vertical" ? "x" : "y";
  B(e, function(n) {
    n.outEdges.sort(function(i, o) {
      return i.node2.getLayout()[r] - o.node2.getLayout()[r];
    }), n.inEdges.sort(function(i, o) {
      return i.node1.getLayout()[r] - o.node1.getLayout()[r];
    });
  }), B(e, function(n) {
    var i = 0, o = 0;
    B(n.outEdges, function(a) {
      a.setLayout({
        sy: i
      }, !0), i += a.getLayout().dy;
    }), B(n.inEdges, function(a) {
      a.setLayout({
        ty: o
      }, !0), o += a.getLayout().dy;
    });
  });
}
function ITe(e) {
  e.eachSeriesByType("sankey", function(t) {
    var r = t.getGraph(), n = r.nodes, i = r.edges;
    if (n.length) {
      var o = 1 / 0, a = -1 / 0;
      B(n, function(s) {
        var l = s.getLayout().value;
        l < o && (o = l), l > a && (a = l);
      }), B(n, function(s) {
        var l = new xn({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [o, a],
          visual: t.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get(["itemStyle", "color"]);
        c != null ? (s.setVisual("color", c), s.setVisual("style", {
          fill: c
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    i.length && B(i, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function FTe(e) {
  e.registerChartView(dTe), e.registerSeriesModel(fTe), e.registerLayout(pTe), e.registerVisual(ITe), e.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(t, r) {
    r.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(n) {
      n.setNodePosition(t.dataIndex, [t.localX, t.localY]);
    });
  });
}
var Ej = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.getInitialData = function(t, r) {
      var n, i = r.getComponent("xAxis", this.get("xAxisIndex")), o = r.getComponent("yAxis", this.get("yAxisIndex")), a = i.get("type"), s = o.get("type"), l;
      a === "category" ? (t.layout = "horizontal", n = i.getOrdinalMeta(), l = !0) : s === "category" ? (t.layout = "vertical", n = o.getOrdinalMeta(), l = !0) : t.layout = t.layout || "horizontal";
      var u = ["x", "y"], c = t.layout === "horizontal" ? 0 : 1, d = this._baseAxisDim = u[c], h = u[1 - c], f = [i, o], p = f[c].get("type"), g = f[1 - c].get("type"), v = t.data;
      if (v && l) {
        var m = [];
        B(v, function(S, b) {
          var w;
          fe(S) ? (w = S.slice(), S.unshift(b)) : fe(S.value) ? (w = se({}, S), w.value = w.value.slice(), S.value.unshift(b)) : w = S, m.push(w);
        }), t.data = m;
      }
      var y = this.defaultValueDimensions, C = [{
        name: d,
        type: fC(p),
        ordinalMeta: n,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: h,
        type: fC(g),
        dimsDef: y.slice()
      }];
      return Sf(this, {
        coordDimensions: C,
        dimensionsCount: y.length + 1,
        encodeDefaulter: dt(J6, C, this)
      });
    }, e.prototype.getBaseAxis = function() {
      var t = this._baseAxisDim;
      return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis;
    }, e;
  }()
), Rj = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], r.visualDrawType = "stroke", r;
    }
    return t.type = "series.boxplot", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, t;
  }(hr)
);
qr(Rj, Ej, !0);
var LTe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this.group, s = this._data;
      this._data || a.removeAll();
      var l = r.get("layout") === "horizontal" ? 1 : 0;
      o.diff(s).add(function(u) {
        if (o.hasValue(u)) {
          var c = o.getItemLayout(u), d = eB(c, o, u, l, !0);
          o.setItemGraphicEl(u, d), a.add(d);
        }
      }).update(function(u, c) {
        var d = s.getItemGraphicEl(c);
        if (!o.hasValue(u)) {
          a.remove(d);
          return;
        }
        var h = o.getItemLayout(u);
        d ? (Ca(d), _j(h, d, o, u)) : d = eB(h, o, u, l), a.add(d), o.setItemGraphicEl(u, d);
      }).remove(function(u) {
        var c = s.getItemGraphicEl(u);
        c && a.remove(c);
      }).execute(), this._data = o;
    }, t.prototype.remove = function(r) {
      var n = this.group, i = this._data;
      this._data = null, i && i.eachItemGraphicEl(function(o) {
        o && n.remove(o);
      });
    }, t.type = "boxplot", t;
  }(ar)
), OTe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), NTe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "boxplotBoxPath", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new OTe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points, o = 0;
      for (r.moveTo(i[o][0], i[o][1]), o++; o < 4; o++)
        r.lineTo(i[o][0], i[o][1]);
      for (r.closePath(); o < i.length; o++)
        r.moveTo(i[o][0], i[o][1]), o++, r.lineTo(i[o][0], i[o][1]);
    }, t;
  }(Mt)
);
function eB(e, t, r, n, i) {
  var o = e.ends, a = new NTe({
    shape: {
      points: i ? kTe(o, n, e) : o
    }
  });
  return _j(e, a, t, r, i), a;
}
function _j(e, t, r, n, i) {
  var o = r.hostModel, a = jc[i ? "initProps" : "updateProps"];
  a(t, {
    shape: {
      points: e.ends
    }
  }, o, n), t.useStyle(r.getItemVisual(n, "style")), t.style.strokeNoScale = !0, t.z2 = 100;
  var s = r.getItemModel(n), l = s.getModel("emphasis");
  Bn(t, s), Hr(t, l.get("focus"), l.get("blurScope"), l.get("disabled"));
}
function kTe(e, t, r) {
  return ge(e, function(n) {
    return n = n.slice(), n[t] = r.initBaseline, n;
  });
}
var sg = B;
function VTe(e) {
  var t = BTe(e);
  sg(t, function(r) {
    var n = r.seriesModels;
    n.length && (GTe(r), sg(n, function(i, o) {
      HTe(i, r.boxOffsetList[o], r.boxWidthList[o]);
    }));
  });
}
function BTe(e) {
  var t = [], r = [];
  return e.eachSeriesByType("boxplot", function(n) {
    var i = n.getBaseAxis(), o = bt(r, i);
    o < 0 && (o = r.length, r[o] = i, t[o] = {
      axis: i,
      seriesModels: []
    }), t[o].seriesModels.push(n);
  }), t;
}
function GTe(e) {
  var t = e.axis, r = e.seriesModels, n = r.length, i = e.boxWidthList = [], o = e.boxOffsetList = [], a = [], s;
  if (t.type === "category")
    s = t.getBandWidth();
  else {
    var l = 0;
    sg(r, function(p) {
      l = Math.max(l, p.getData().count());
    });
    var u = t.getExtent();
    s = Math.abs(u[1] - u[0]) / l;
  }
  sg(r, function(p) {
    var g = p.get("boxWidth");
    fe(g) || (g = [g, g]), a.push([Ae(g[0], s) || 0, Ae(g[1], s) || 0]);
  });
  var c = s * 0.8 - 2, d = c / n * 0.3, h = (c - d * (n - 1)) / n, f = h / 2 - c / 2;
  sg(r, function(p, g) {
    o.push(f), f += d + h, i.push(Math.min(Math.max(h, a[g][0]), a[g][1]));
  });
}
function HTe(e, t, r) {
  var n = e.coordinateSystem, i = e.getData(), o = r / 2, a = e.get("layout") === "horizontal" ? 0 : 1, s = 1 - a, l = ["x", "y"], u = i.mapDimension(l[a]), c = i.mapDimensionsAll(l[s]);
  if (u == null || c.length < 5)
    return;
  for (var d = 0; d < i.count(); d++) {
    var h = i.get(u, d), f = C(h, c[2], d), p = C(h, c[0], d), g = C(h, c[1], d), v = C(h, c[3], d), m = C(h, c[4], d), y = [];
    S(y, g, !1), S(y, v, !0), y.push(p, g, m, v), b(y, p), b(y, m), b(y, f), i.setItemLayout(d, {
      initBaseline: f[s],
      ends: y
    });
  }
  function C(w, x, E) {
    var R = i.get(x, E), _ = [];
    _[a] = w, _[s] = R;
    var P;
    return isNaN(w) || isNaN(R) ? P = [NaN, NaN] : (P = n.dataToPoint(_), P[a] += t), P;
  }
  function S(w, x, E) {
    var R = x.slice(), _ = x.slice();
    R[a] += o, _[a] -= o, E ? w.push(R, _) : w.push(_, R);
  }
  function b(w, x) {
    var E = x.slice(), R = x.slice();
    E[a] -= o, R[a] += o, w.push(E, R);
  }
}
function zTe(e, t) {
  t = t || {};
  for (var r = [], n = [], i = t.boundIQR, o = i === "none" || i === 0, a = 0; a < e.length; a++) {
    var s = Ji(e[a].slice()), l = e0(s, 0.25), u = e0(s, 0.5), c = e0(s, 0.75), d = s[0], h = s[s.length - 1], f = (i ?? 1.5) * (c - l), p = o ? d : Math.max(d, l - f), g = o ? h : Math.min(h, c + f), v = t.itemNameFormatter, m = Ye(v) ? v({
      value: a
    }) : Fe(v) ? v.replace("{value}", a + "") : a + "";
    r.push([m, p, l, u, c, g]);
    for (var y = 0; y < s.length; y++) {
      var C = s[y];
      if (C < p || C > g) {
        var S = [m, C];
        n.push(S);
      }
    }
  }
  return {
    boxData: r,
    outliers: n
  };
}
var $Te = {
  type: "echarts:boxplot",
  transform: function(t) {
    var r = t.upstream;
    if (r.sourceFormat !== ti) {
      var n = "";
      process.env.NODE_ENV !== "production" && (n = wi("source data is not applicable for this boxplot transform. Expect number[][].")), er(n);
    }
    var i = zTe(r.getRawData(), t.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: i.boxData
    }, {
      data: i.outliers
    }];
  }
};
function WTe(e) {
  e.registerSeriesModel(Rj), e.registerChartView(LTe), e.registerLayout(VTe), e.registerTransform($Te);
}
var jTe = ["color", "borderColor"], UTe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(r), this._isLargeDraw ? this._renderLarge(r) : this._renderNormal(r);
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      this._clear(), this._updateDrawMode(r);
    }, t.prototype.incrementalRender = function(r, n, i, o) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(r, n) : this._incrementalRenderNormal(r, n);
    }, t.prototype.eachRendered = function(r) {
      iu(this._progressiveEls || this.group, r);
    }, t.prototype._updateDrawMode = function(r) {
      var n = r.pipelineContext.large;
      (this._isLargeDraw == null || n !== this._isLargeDraw) && (this._isLargeDraw = n, this._clear());
    }, t.prototype._renderNormal = function(r) {
      var n = r.getData(), i = this._data, o = this.group, a = n.getLayout("isSimpleBox"), s = r.get("clip", !0), l = r.coordinateSystem, u = l.getArea && l.getArea();
      this._data || o.removeAll(), n.diff(i).add(function(c) {
        if (n.hasValue(c)) {
          var d = n.getItemLayout(c);
          if (s && tB(u, d))
            return;
          var h = ux(d, c, !0);
          Pr(h, {
            shape: {
              points: d.ends
            }
          }, r, c), cx(h, n, c, a), o.add(h), n.setItemGraphicEl(c, h);
        }
      }).update(function(c, d) {
        var h = i.getItemGraphicEl(d);
        if (!n.hasValue(c)) {
          o.remove(h);
          return;
        }
        var f = n.getItemLayout(c);
        if (s && tB(u, f)) {
          o.remove(h);
          return;
        }
        h ? (jt(h, {
          shape: {
            points: f.ends
          }
        }, r, c), Ca(h)) : h = ux(f), cx(h, n, c, a), o.add(h), n.setItemGraphicEl(c, h);
      }).remove(function(c) {
        var d = i.getItemGraphicEl(c);
        d && o.remove(d);
      }).execute(), this._data = n;
    }, t.prototype._renderLarge = function(r) {
      this._clear(), rB(r, this.group);
      var n = r.get("clip", !0) ? Bv(r.coordinateSystem, !1, r) : null;
      n ? this.group.setClipPath(n) : this.group.removeClipPath();
    }, t.prototype._incrementalRenderNormal = function(r, n) {
      for (var i = n.getData(), o = i.getLayout("isSimpleBox"), a; (a = r.next()) != null; ) {
        var s = i.getItemLayout(a), l = ux(s);
        cx(l, i, a, o), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l);
      }
    }, t.prototype._incrementalRenderLarge = function(r, n) {
      rB(n, this.group, this._progressiveEls, !0);
    }, t.prototype.remove = function(r) {
      this._clear();
    }, t.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, t.type = "candlestick", t;
  }(ar)
), KTe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), YTe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "normalCandlestickBox", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new KTe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.points;
      this.__simpleBox ? (r.moveTo(i[4][0], i[4][1]), r.lineTo(i[6][0], i[6][1])) : (r.moveTo(i[0][0], i[0][1]), r.lineTo(i[1][0], i[1][1]), r.lineTo(i[2][0], i[2][1]), r.lineTo(i[3][0], i[3][1]), r.closePath(), r.moveTo(i[4][0], i[4][1]), r.lineTo(i[5][0], i[5][1]), r.moveTo(i[6][0], i[6][1]), r.lineTo(i[7][0], i[7][1]));
    }, t;
  }(Mt)
);
function ux(e, t, r) {
  var n = e.ends;
  return new YTe({
    shape: {
      points: r ? qTe(n, e) : n
    },
    z2: 100
  });
}
function tB(e, t) {
  for (var r = !0, n = 0; n < t.ends.length; n++)
    if (e.contain(t.ends[n][0], t.ends[n][1])) {
      r = !1;
      break;
    }
  return r;
}
function cx(e, t, r, n) {
  var i = t.getItemModel(r);
  e.useStyle(t.getItemVisual(r, "style")), e.style.strokeNoScale = !0, e.__simpleBox = n, Bn(e, i);
}
function qTe(e, t) {
  return ge(e, function(r) {
    return r = r.slice(), r[1] = t.initBaseline, r;
  });
}
var ZTe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), dx = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.type = "largeCandlestickBox", n;
    }
    return t.prototype.getDefaultShape = function() {
      return new ZTe();
    }, t.prototype.buildPath = function(r, n) {
      for (var i = n.points, o = 0; o < i.length; )
        if (this.__sign === i[o++]) {
          var a = i[o++];
          r.moveTo(a, i[o++]), r.lineTo(a, i[o++]);
        } else
          o += 3;
    }, t;
  }(Mt)
);
function rB(e, t, r, n) {
  var i = e.getData(), o = i.getLayout("largePoints"), a = new dx({
    shape: {
      points: o
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  t.add(a);
  var s = new dx({
    shape: {
      points: o
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  t.add(s);
  var l = new dx({
    shape: {
      points: o
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  t.add(l), hx(1, a, e), hx(-1, s, e), hx(0, l, e), n && (a.incremental = !0, s.incremental = !0), r && r.push(a, s);
}
function hx(e, t, r, n) {
  var i = r.get(["itemStyle", e > 0 ? "borderColor" : "borderColor0"]) || r.get(["itemStyle", e > 0 ? "color" : "color0"]);
  e === 0 && (i = r.get(["itemStyle", "borderColorDoji"]));
  var o = r.getModel("itemStyle").getItemStyle(jTe);
  t.useStyle(o), t.style.fill = null, t.style.stroke = i;
}
var Tj = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], r;
    }
    return t.prototype.getShadowDim = function() {
      return "open";
    }, t.prototype.brushSelector = function(r, n, i) {
      var o = n.getItemLayout(r);
      return o && i.rect(o.brushRect);
    }, t.type = "series.candlestick", t.dependencies = ["xAxis", "yAxis", "grid"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, t;
  }(hr)
);
qr(Tj, Ej, !0);
function XTe(e) {
  !e || !fe(e.series) || B(e.series, function(t) {
    Ze(t) && t.type === "k" && (t.type = "candlestick");
  });
}
var QTe = ["itemStyle", "borderColor"], JTe = ["itemStyle", "borderColor0"], ePe = ["itemStyle", "borderColorDoji"], tPe = ["itemStyle", "color"], rPe = ["itemStyle", "color0"], nPe = {
  seriesType: "candlestick",
  plan: pf(),
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    function r(o, a) {
      return a.get(o > 0 ? tPe : rPe);
    }
    function n(o, a) {
      return a.get(o === 0 ? ePe : o > 0 ? QTe : JTe);
    }
    if (!t.isSeriesFiltered(e)) {
      var i = e.pipelineContext.large;
      return !i && {
        progress: function(o, a) {
          for (var s; (s = o.next()) != null; ) {
            var l = a.getItemModel(s), u = a.getItemLayout(s).sign, c = l.getItemStyle();
            c.fill = r(u, l), c.stroke = n(u, l) || c.fill;
            var d = a.ensureUniqueItemVisual(s, "style");
            se(d, c);
          }
        }
      };
    }
  }
}, iPe = {
  seriesType: "candlestick",
  plan: pf(),
  reset: function(e) {
    var t = e.coordinateSystem, r = e.getData(), n = oPe(e, r), i = 0, o = 1, a = ["x", "y"], s = r.getDimensionIndex(r.mapDimension(a[i])), l = ge(r.mapDimensionsAll(a[o]), r.getDimensionIndex, r), u = l[0], c = l[1], d = l[2], h = l[3];
    if (r.setLayout({
      candleWidth: n,
      // The value is experimented visually.
      isSimpleBox: n <= 1.3
    }), s < 0 || l.length < 4)
      return;
    return {
      progress: e.pipelineContext.large ? p : f
    };
    function f(g, v) {
      for (var m, y = v.getStore(); (m = g.next()) != null; ) {
        var C = y.get(s, m), S = y.get(u, m), b = y.get(c, m), w = y.get(d, m), x = y.get(h, m), E = Math.min(S, b), R = Math.max(S, b), _ = N(E, C), P = N(R, C), D = N(w, C), I = N(x, C), A = [];
        F(A, P, 0), F(A, _, 1), A.push(M(I), M(P), M(D), M(_));
        var O = v.getItemModel(m), L = !!O.get(["itemStyle", "borderColorDoji"]);
        v.setItemLayout(m, {
          sign: nB(y, m, S, b, c, L),
          initBaseline: S > b ? P[o] : _[o],
          ends: A,
          brushRect: G(w, x, C)
        });
      }
      function N(V, z) {
        var k = [];
        return k[i] = z, k[o] = V, isNaN(z) || isNaN(V) ? [NaN, NaN] : t.dataToPoint(k);
      }
      function F(V, z, k) {
        var $ = z.slice(), W = z.slice();
        $[i] = n0($[i] + n / 2, 1, !1), W[i] = n0(W[i] - n / 2, 1, !0), k ? V.push($, W) : V.push(W, $);
      }
      function G(V, z, k) {
        var $ = N(V, k), W = N(z, k);
        return $[i] -= n / 2, W[i] -= n / 2, {
          x: $[0],
          y: $[1],
          width: n,
          height: W[1] - $[1]
        };
      }
      function M(V) {
        return V[i] = n0(V[i], 1), V;
      }
    }
    function p(g, v) {
      for (var m = $a(g.count * 4), y = 0, C, S = [], b = [], w, x = v.getStore(), E = !!e.get(["itemStyle", "borderColorDoji"]); (w = g.next()) != null; ) {
        var R = x.get(s, w), _ = x.get(u, w), P = x.get(c, w), D = x.get(d, w), I = x.get(h, w);
        if (isNaN(R) || isNaN(D) || isNaN(I)) {
          m[y++] = NaN, y += 3;
          continue;
        }
        m[y++] = nB(x, w, _, P, c, E), S[i] = R, S[o] = D, C = t.dataToPoint(S, null, b), m[y++] = C ? C[0] : NaN, m[y++] = C ? C[1] : NaN, S[o] = I, C = t.dataToPoint(S, null, b), m[y++] = C ? C[1] : NaN;
      }
      v.setLayout("largePoints", m);
    }
  }
};
function nB(e, t, r, n, i, o) {
  var a;
  return r > n ? a = -1 : r < n ? a = 1 : a = o ? 0 : t > 0 ? e.get(i, t - 1) <= n ? 1 : -1 : 1, a;
}
function oPe(e, t) {
  var r = e.getBaseAxis(), n, i = r.type === "category" ? r.getBandWidth() : (n = r.getExtent(), Math.abs(n[1] - n[0]) / t.count()), o = Ae(st(e.get("barMaxWidth"), i), i), a = Ae(st(e.get("barMinWidth"), 1), i), s = e.get("barWidth");
  return s != null ? Ae(s, i) : Math.max(Math.min(i / 2, o), a);
}
function aPe(e) {
  e.registerChartView(UTe), e.registerSeriesModel(Tj), e.registerPreprocessor(XTe), e.registerVisual(nPe), e.registerLayout(iPe);
}
function iB(e, t) {
  var r = t.rippleEffectColor || t.color;
  e.eachChild(function(n) {
    n.attr({
      z: t.z,
      zlevel: t.zlevel,
      style: {
        stroke: t.brushType === "stroke" ? r : null,
        fill: t.brushType === "fill" ? r : null
      }
    });
  });
}
var sPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n) {
      var i = e.call(this) || this, o = new kv(r, n), a = new it();
      return i.add(o), i.add(a), i.updateData(r, n), i;
    }
    return t.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, t.prototype.startEffectAnimation = function(r) {
      for (var n = r.symbolType, i = r.color, o = r.rippleNumber, a = this.childAt(1), s = 0; s < o; s++) {
        var l = rn(n, -1, -1, 2, 2, i);
        l.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / o * r.period + r.effectOffset;
        l.animate("", !0).when(r.period, {
          scaleX: r.rippleScale / 2,
          scaleY: r.rippleScale / 2
        }).delay(u).start(), l.animateStyle(!0).when(r.period, {
          opacity: 0
        }).delay(u).start(), a.add(l);
      }
      iB(a, r);
    }, t.prototype.updateEffectAnimation = function(r) {
      for (var n = this._effectCfg, i = this.childAt(1), o = ["symbolType", "period", "rippleScale", "rippleNumber"], a = 0; a < o.length; a++) {
        var s = o[a];
        if (n[s] !== r[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(r);
          return;
        }
      }
      iB(i, r);
    }, t.prototype.highlight = function() {
      zs(this);
    }, t.prototype.downplay = function() {
      $s(this);
    }, t.prototype.getSymbolType = function() {
      var r = this.childAt(0);
      return r && r.getSymbolType();
    }, t.prototype.updateData = function(r, n) {
      var i = this, o = r.hostModel;
      this.childAt(0).updateData(r, n);
      var a = this.childAt(1), s = r.getItemModel(n), l = r.getItemVisual(n, "symbol"), u = vf(r.getItemVisual(n, "symbolSize")), c = r.getItemVisual(n, "style"), d = c && c.fill, h = s.getModel("emphasis");
      a.setScale(u), a.traverse(function(v) {
        v.setStyle("fill", d);
      });
      var f = qc(r.getItemVisual(n, "symbolOffset"), u);
      f && (a.x = f[0], a.y = f[1]);
      var p = r.getItemVisual(n, "symbolRotate");
      a.rotation = (p || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = o.get("showEffectOn"), g.rippleScale = s.get(["rippleEffect", "scale"]), g.brushType = s.get(["rippleEffect", "brushType"]), g.period = s.get(["rippleEffect", "period"]) * 1e3, g.effectOffset = n / r.count(), g.z = o.getShallow("z") || 0, g.zlevel = o.getShallow("zlevel") || 0, g.symbolType = l, g.color = d, g.rippleEffectColor = s.get(["rippleEffect", "color"]), g.rippleNumber = s.get(["rippleEffect", "number"]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(v) {
        v === "emphasis" ? g.showEffectOn !== "render" && i.startEffectAnimation(g) : v === "normal" && g.showEffectOn !== "render" && i.stopEffectAnimation();
      }), this._effectCfg = g, Hr(this, h.get("focus"), h.get("blurScope"), h.get("disabled"));
    }, t.prototype.fadeOut = function(r) {
      r && r();
    }, t;
  }(it)
), lPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function() {
      this._symbolDraw = new Vv(sPe);
    }, t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this._symbolDraw;
      a.updateData(o, {
        clipShape: this._getClipShape(r)
      }), this.group.add(a.group);
    }, t.prototype._getClipShape = function(r) {
      var n = r.coordinateSystem, i = n && n.getArea && n.getArea();
      return r.get("clip", !0) ? i : null;
    }, t.prototype.updateTransform = function(r, n, i) {
      var o = r.getData();
      this.group.dirty();
      var a = Gv("").reset(r, n, i);
      a.progress && a.progress({
        start: 0,
        end: o.count(),
        count: o.count()
      }, o), this._symbolDraw.updateLayout();
    }, t.prototype._updateGroupTransform = function(r) {
      var n = r.coordinateSystem;
      n && n.getRoamTransform && (this.group.transform = e$(n.getRoamTransform()), this.group.decomposeTransform());
    }, t.prototype.remove = function(r, n) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, t.type = "effectScatter", t;
  }(ar)
), uPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return os(null, this, {
        useEncodeDefaulter: !0
      });
    }, t.prototype.brushSelector = function(r, n, i) {
      return i.point(n.getItemLayout(r));
    }, t.type = "series.effectScatter", t.dependencies = ["grid", "polar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 图形类型
      symbolSize: 10
      // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
      // symbolRotate: null,  // 图形旋转控制
      // itemStyle: {
      //     opacity: 1
      // }
    }, t;
  }(hr)
);
function cPe(e) {
  e.registerChartView(lPe), e.registerSeriesModel(uPe), e.registerLayout(Gv("effectScatter"));
}
var Pj = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i) {
      var o = e.call(this) || this;
      return o.add(o.createLine(r, n, i)), o._updateEffectSymbol(r, n), o;
    }
    return t.prototype.createLine = function(r, n, i) {
      return new DD(r, n, i);
    }, t.prototype._updateEffectSymbol = function(r, n) {
      var i = r.getItemModel(n), o = i.getModel("effect"), a = o.get("symbolSize"), s = o.get("symbol");
      fe(a) || (a = [a, a]);
      var l = r.getItemVisual(n, "style"), u = o.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== s && (this.remove(c), c = rn(s, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = !0, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(o.getItemStyle(["color"])), c.scaleX = a[0], c.scaleY = a[1], c.setColor(u), this._symbolType = s, this._symbolScale = a, this._updateEffectAnimation(r, o, n));
    }, t.prototype._updateEffectAnimation = function(r, n, i) {
      var o = this.childAt(1);
      if (o) {
        var a = r.getItemLayout(i), s = n.get("period") * 1e3, l = n.get("loop"), u = n.get("roundTrip"), c = n.get("constantSpeed"), d = tn(n.get("delay"), function(f) {
          return f / r.count() * s / 3;
        });
        if (o.ignore = !0, this._updateAnimationPoints(o, a), c > 0 && (s = this._getLineLength(o) / c * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          o.stopAnimation();
          var h = void 0;
          Ye(d) ? h = d(i) : h = d, o.__t > 0 && (h = -s * o.__t), this._animateSymbol(o, s, h, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, t.prototype._animateSymbol = function(r, n, i, o, a) {
      if (n > 0) {
        r.__t = 0;
        var s = this, l = r.animate("", o).when(a ? n * 2 : n, {
          __t: a ? 2 : 1
        }).delay(i).during(function() {
          s._updateSymbolPosition(r);
        });
        o || l.done(function() {
          s.remove(r);
        }), l.start();
      }
    }, t.prototype._getLineLength = function(r) {
      return Es(r.__p1, r.__cp1) + Es(r.__cp1, r.__p2);
    }, t.prototype._updateAnimationPoints = function(r, n) {
      r.__p1 = n[0], r.__p2 = n[1], r.__cp1 = n[2] || [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2];
    }, t.prototype.updateData = function(r, n, i) {
      this.childAt(0).updateData(r, n, i), this._updateEffectSymbol(r, n);
    }, t.prototype._updateSymbolPosition = function(r) {
      var n = r.__p1, i = r.__p2, o = r.__cp1, a = r.__t < 1 ? r.__t : 2 - r.__t, s = [r.x, r.y], l = s.slice(), u = Pn, c = LR;
      s[0] = u(n[0], o[0], i[0], a), s[1] = u(n[1], o[1], i[1], a);
      var d = r.__t < 1 ? c(n[0], o[0], i[0], a) : c(i[0], o[0], n[0], 1 - a), h = r.__t < 1 ? c(n[1], o[1], i[1], a) : c(i[1], o[1], n[1], 1 - a);
      r.rotation = -Math.atan2(h, d) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (r.__lastT !== void 0 && r.__lastT < r.__t ? (r.scaleY = Es(l, s) * 1.05, a === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : r.__lastT === 1 ? r.scaleY = 2 * Es(n, s) : r.scaleY = this._symbolScale[1]), r.__lastT = r.__t, r.ignore = !1, r.x = s[0], r.y = s[1];
    }, t.prototype.updateLayout = function(r, n) {
      this.childAt(0).updateLayout(r, n);
      var i = r.getItemModel(n).getModel("effect");
      this._updateEffectAnimation(r, i, n);
    }, t;
  }(it)
), Mj = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i) {
      var o = e.call(this) || this;
      return o._createPolyline(r, n, i), o;
    }
    return t.prototype._createPolyline = function(r, n, i) {
      var o = r.getItemLayout(n), a = new Ri({
        shape: {
          points: o
        }
      });
      this.add(a), this._updateCommonStl(r, n, i);
    }, t.prototype.updateData = function(r, n, i) {
      var o = r.hostModel, a = this.childAt(0), s = {
        shape: {
          points: r.getItemLayout(n)
        }
      };
      jt(a, s, o, n), this._updateCommonStl(r, n, i);
    }, t.prototype._updateCommonStl = function(r, n, i) {
      var o = this.childAt(0), a = r.getItemModel(n), s = i && i.emphasisLineStyle, l = i && i.focus, u = i && i.blurScope, c = i && i.emphasisDisabled;
      if (!i || r.hasItemOption) {
        var d = a.getModel("emphasis");
        s = d.getModel("lineStyle").getLineStyle(), c = d.get("disabled"), l = d.get("focus"), u = d.get("blurScope");
      }
      o.useStyle(r.getItemVisual(n, "style")), o.style.fill = null, o.style.strokeNoScale = !0;
      var h = o.ensureState("emphasis");
      h.style = s, Hr(this, l, u, c);
    }, t.prototype.updateLayout = function(r, n) {
      var i = this.childAt(0);
      i.setShape("points", r.getItemLayout(n));
    }, t;
  }(it)
), dPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r._lastFrame = 0, r._lastFramePercent = 0, r;
    }
    return t.prototype.createLine = function(r, n, i) {
      return new Mj(r, n, i);
    }, t.prototype._updateAnimationPoints = function(r, n) {
      this._points = n;
      for (var i = [0], o = 0, a = 1; a < n.length; a++) {
        var s = n[a - 1], l = n[a];
        o += Es(s, l), i.push(o);
      }
      if (o === 0) {
        this._length = 0;
        return;
      }
      for (var a = 0; a < i.length; a++)
        i[a] /= o;
      this._offsets = i, this._length = o;
    }, t.prototype._getLineLength = function() {
      return this._length;
    }, t.prototype._updateSymbolPosition = function(r) {
      var n = r.__t < 1 ? r.__t : 2 - r.__t, i = this._points, o = this._offsets, a = i.length;
      if (o) {
        var s = this._lastFrame, l;
        if (n < this._lastFramePercent) {
          var u = Math.min(s + 1, a - 1);
          for (l = u; l >= 0 && !(o[l] <= n); l--)
            ;
          l = Math.min(l, a - 2);
        } else {
          for (l = s; l < a && !(o[l] > n); l++)
            ;
          l = Math.min(l - 1, a - 2);
        }
        var c = (n - o[l]) / (o[l + 1] - o[l]), d = i[l], h = i[l + 1];
        r.x = d[0] * (1 - c) + c * h[0], r.y = d[1] * (1 - c) + c * h[1];
        var f = r.__t < 1 ? h[0] - d[0] : d[0] - h[0], p = r.__t < 1 ? h[1] - d[1] : d[1] - h[1];
        r.rotation = -Math.atan2(p, f) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = n, r.ignore = !1;
      }
    }, t;
  }(Pj)
), hPe = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return e;
  }()
), fPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n._off = 0, n.hoverDataIdx = -1, n;
    }
    return t.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, t.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, t.prototype.getDefaultShape = function() {
      return new hPe();
    }, t.prototype.buildPath = function(r, n) {
      var i = n.segs, o = n.curveness, a;
      if (n.polyline)
        for (a = this._off; a < i.length; ) {
          var s = i[a++];
          if (s > 0) {
            r.moveTo(i[a++], i[a++]);
            for (var l = 1; l < s; l++)
              r.lineTo(i[a++], i[a++]);
          }
        }
      else
        for (a = this._off; a < i.length; ) {
          var u = i[a++], c = i[a++], d = i[a++], h = i[a++];
          if (r.moveTo(u, c), o > 0) {
            var f = (u + d) / 2 - (c - h) * o, p = (c + h) / 2 - (d - u) * o;
            r.quadraticCurveTo(f, p, d, h);
          } else
            r.lineTo(d, h);
        }
      this.incremental && (this._off = a, this.notClear = !0);
    }, t.prototype.findDataIndex = function(r, n) {
      var i = this.shape, o = i.segs, a = i.curveness, s = this.style.lineWidth;
      if (i.polyline)
        for (var l = 0, u = 0; u < o.length; ) {
          var c = o[u++];
          if (c > 0)
            for (var d = o[u++], h = o[u++], f = 1; f < c; f++) {
              var p = o[u++], g = o[u++];
              if (Sl(d, h, p, g, s, r, n))
                return l;
            }
          l++;
        }
      else
        for (var l = 0, u = 0; u < o.length; ) {
          var d = o[u++], h = o[u++], p = o[u++], g = o[u++];
          if (a > 0) {
            var v = (d + p) / 2 - (h - g) * a, m = (h + g) / 2 - (p - d) * a;
            if (j$(d, h, v, m, p, g, s, r, n))
              return l;
          } else if (Sl(d, h, p, g, s, r, n))
            return l;
          l++;
        }
      return -1;
    }, t.prototype.contain = function(r, n) {
      var i = this.transformCoordToLocal(r, n), o = this.getBoundingRect();
      if (r = i[0], n = i[1], o.contain(r, n)) {
        var a = this.hoverDataIdx = this.findDataIndex(r, n);
        return a >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, t.prototype.getBoundingRect = function() {
      var r = this._rect;
      if (!r) {
        for (var n = this.shape, i = n.segs, o = 1 / 0, a = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < i.length; ) {
          var c = i[u++], d = i[u++];
          o = Math.min(c, o), s = Math.max(c, s), a = Math.min(d, a), l = Math.max(d, l);
        }
        r = this._rect = new St(o, a, s, l);
      }
      return r;
    }, t;
  }(Mt)
), pPe = (
  /** @class */
  function() {
    function e() {
      this.group = new it();
    }
    return e.prototype.updateData = function(t) {
      this._clear();
      var r = this._create();
      r.setShape({
        segs: t.getLayout("linesPoints")
      }), this._setCommon(r, t);
    }, e.prototype.incrementalPrepareUpdate = function(t) {
      this.group.removeAll(), this._clear();
    }, e.prototype.incrementalUpdate = function(t, r) {
      var n = this._newAdded[0], i = r.getLayout("linesPoints"), o = n && n.shape.segs;
      if (o && o.length < 2e4) {
        var a = o.length, s = new Float32Array(a + i.length);
        s.set(o), s.set(i, a), n.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = !0, l.setShape({
          segs: i
        }), this._setCommon(l, r), l.__startIndex = t.start;
      }
    }, e.prototype.remove = function() {
      this._clear();
    }, e.prototype.eachRendered = function(t) {
      this._newAdded[0] && t(this._newAdded[0]);
    }, e.prototype._create = function() {
      var t = new fPe({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(t), this.group.add(t), t;
    }, e.prototype._setCommon = function(t, r, n) {
      var i = r.hostModel;
      t.setShape({
        polyline: i.get("polyline"),
        curveness: i.get(["lineStyle", "curveness"])
      }), t.useStyle(i.getModel("lineStyle").getLineStyle()), t.style.strokeNoScale = !0;
      var o = r.getVisual("style");
      o && o.stroke && t.setStyle("stroke", o.stroke), t.setStyle("fill", null);
      var a = ot(t);
      a.seriesIndex = i.seriesIndex, t.on("mousemove", function(s) {
        a.dataIndex = null;
        var l = t.hoverDataIdx;
        l > 0 && (a.dataIndex = l + t.__startIndex);
      });
    }, e.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, e;
  }()
), Dj = {
  seriesType: "lines",
  plan: pf(),
  reset: function(e) {
    var t = e.coordinateSystem;
    if (!t) {
      process.env.NODE_ENV !== "production" && Vn("The lines series must have a coordinate system.");
      return;
    }
    var r = e.get("polyline"), n = e.pipelineContext.large;
    return {
      progress: function(i, o) {
        var a = [];
        if (n) {
          var s = void 0, l = i.end - i.start;
          if (r) {
            for (var u = 0, c = i.start; c < i.end; c++)
              u += e.getLineCoordsCount(c);
            s = new Float32Array(l + u * 2);
          } else
            s = new Float32Array(l * 4);
          for (var d = 0, h = [], c = i.start; c < i.end; c++) {
            var f = e.getLineCoords(c, a);
            r && (s[d++] = f);
            for (var p = 0; p < f; p++)
              h = t.dataToPoint(a[p], !1, h), s[d++] = h[0], s[d++] = h[1];
          }
          o.setLayout("linesPoints", s);
        } else
          for (var c = i.start; c < i.end; c++) {
            var g = o.getItemModel(c), f = e.getLineCoords(c, a), v = [];
            if (r)
              for (var m = 0; m < f; m++)
                v.push(t.dataToPoint(a[m]));
            else {
              v[0] = t.dataToPoint(a[0]), v[1] = t.dataToPoint(a[1]);
              var y = g.get(["lineStyle", "curveness"]);
              +y && (v[2] = [(v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * y, (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * y]);
            }
            o.setItemLayout(c, v);
          }
      }
    };
  }
}, gPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this._updateLineDraw(o, r), s = r.get("zlevel"), l = r.get(["effect", "trailLength"]), u = i.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(r) && l > 0 && (c ? process.env.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : u.configLayer(s, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), a.updateData(o);
      var d = r.get("clip", !0) && Bv(r.coordinateSystem, !1, r);
      d ? this.group.setClipPath(d) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0;
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      var o = r.getData(), a = this._updateLineDraw(o, r);
      a.incrementalPrepareUpdate(o), this._clearLayer(i), this._finished = !1;
    }, t.prototype.incrementalRender = function(r, n, i) {
      this._lineDraw.incrementalUpdate(r, n.getData()), this._finished = r.end === n.getData().count();
    }, t.prototype.eachRendered = function(r) {
      this._lineDraw && this._lineDraw.eachRendered(r);
    }, t.prototype.updateTransform = function(r, n, i) {
      var o = r.getData(), a = r.pipelineContext;
      if (!this._finished || a.large || a.progressiveRender)
        return {
          update: !0
        };
      var s = Dj.reset(r, n, i);
      s.progress && s.progress({
        start: 0,
        end: o.count(),
        count: o.count()
      }, o), this._lineDraw.updateLayout(), this._clearLayer(i);
    }, t.prototype._updateLineDraw = function(r, n) {
      var i = this._lineDraw, o = this._showEffect(n), a = !!n.get("polyline"), s = n.pipelineContext, l = s.large;
      return process.env.NODE_ENV !== "production" && o && l && console.warn("Large lines not support effect"), (!i || o !== this._hasEffet || a !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new pPe() : new AD(a ? o ? dPe : Mj : o ? Pj : DD), this._hasEffet = o, this._isPolyline = a, this._isLargeDraw = l), this.group.add(i.group), i;
    }, t.prototype._showEffect = function(r) {
      return !!r.get(["effect", "show"]);
    }, t.prototype._clearLayer = function(r) {
      var n = r.getZr(), i = n.painter.getType() === "svg";
      !i && this._lastZlevel != null && n.painter.getLayer(this._lastZlevel).clear(!0);
    }, t.prototype.remove = function(r, n) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(n);
    }, t.prototype.dispose = function(r, n) {
      this.remove(r, n);
    }, t.type = "lines", t;
  }(ar)
), vPe = typeof Uint32Array > "u" ? Array : Uint32Array, mPe = typeof Float64Array > "u" ? Array : Float64Array;
function oB(e) {
  var t = e.data;
  t && t[0] && t[0][0] && t[0][0].coord && (process.env.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), e.data = ge(t, function(r) {
    var n = [r[0].coord, r[1].coord], i = {
      coords: n
    };
    return r[0].name && (i.fromName = r[0].name), r[1].name && (i.toName = r[1].name), wS([i, r[0], r[1]]);
  }));
}
var yPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.visualStyleAccessPath = "lineStyle", r.visualDrawType = "stroke", r;
    }
    return t.prototype.init = function(r) {
      r.data = r.data || [], oB(r);
      var n = this._processFlatCoordsArray(r.data);
      this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (r.data = new Float32Array(n.count)), e.prototype.init.apply(this, arguments);
    }, t.prototype.mergeOption = function(r) {
      if (oB(r), r.data) {
        var n = this._processFlatCoordsArray(r.data);
        this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset, n.flatCoords && (r.data = new Float32Array(n.count));
      }
      e.prototype.mergeOption.apply(this, arguments);
    }, t.prototype.appendData = function(r) {
      var n = this._processFlatCoordsArray(r.data);
      n.flatCoords && (this._flatCoords ? (this._flatCoords = Dg(this._flatCoords, n.flatCoords), this._flatCoordsOffset = Dg(this._flatCoordsOffset, n.flatCoordsOffset)) : (this._flatCoords = n.flatCoords, this._flatCoordsOffset = n.flatCoordsOffset), r.data = new Float32Array(n.count)), this.getRawData().appendData(r.data);
    }, t.prototype._getCoordsFromItemModel = function(r) {
      var n = this.getData().getItemModel(r), i = n.option instanceof Array ? n.option : n.getShallow("coords");
      if (process.env.NODE_ENV !== "production" && !(i instanceof Array && i.length > 0 && i[0] instanceof Array))
        throw new Error("Invalid coords " + JSON.stringify(i) + ". Lines must have 2d coords array in data item.");
      return i;
    }, t.prototype.getLineCoordsCount = function(r) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[r * 2 + 1] : this._getCoordsFromItemModel(r).length;
    }, t.prototype.getLineCoords = function(r, n) {
      if (this._flatCoordsOffset) {
        for (var i = this._flatCoordsOffset[r * 2], o = this._flatCoordsOffset[r * 2 + 1], a = 0; a < o; a++)
          n[a] = n[a] || [], n[a][0] = this._flatCoords[i + a * 2], n[a][1] = this._flatCoords[i + a * 2 + 1];
        return o;
      } else {
        for (var s = this._getCoordsFromItemModel(r), a = 0; a < s.length; a++)
          n[a] = n[a] || [], n[a][0] = s[a][0], n[a][1] = s[a][1];
        return s.length;
      }
    }, t.prototype._processFlatCoordsArray = function(r) {
      var n = 0;
      if (this._flatCoords && (n = this._flatCoords.length), $t(r[0])) {
        for (var i = r.length, o = new vPe(i), a = new mPe(i), s = 0, l = 0, u = 0, c = 0; c < i; ) {
          u++;
          var d = r[c++];
          o[l++] = s + n, o[l++] = d;
          for (var h = 0; h < d; h++) {
            var f = r[c++], p = r[c++];
            if (a[s++] = f, a[s++] = p, c > i && process.env.NODE_ENV !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(o.buffer, 0, l),
          flatCoords: a,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: r.length
      };
    }, t.prototype.getInitialData = function(r, n) {
      if (process.env.NODE_ENV !== "production") {
        var i = Yc.get(r.coordinateSystem);
        if (!i)
          throw new Error("Unknown coordinate system " + r.coordinateSystem);
      }
      var o = new Jn(["value"], this);
      return o.hasItemOption = !1, o.initData(r.data, [], function(a, s, l, u) {
        if (a instanceof Array)
          return NaN;
        o.hasItemOption = !0;
        var c = a.value;
        if (c != null)
          return c instanceof Array ? c[u] : c;
      }), o;
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = o.getItemModel(r), s = a.get("name");
      if (s)
        return s;
      var l = a.get("fromName"), u = a.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), _n("nameValue", {
        name: c.join(" > ")
      });
    }, t.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, t.prototype.getProgressive = function() {
      var r = this.option.progressive;
      return r ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, t.prototype.getProgressiveThreshold = function() {
      var r = this.option.progressiveThreshold;
      return r ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, t.prototype.getZLevelKey = function() {
      var r = this.getModel("effect"), n = r.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : r.get("show") && n > 0 ? n + "" : "";
    }, t.type = "series.lines", t.dependencies = ["grid", "polar", "geo", "calendar"], t.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
      },
      lineStyle: {
        opacity: 0.5
      }
    }, t;
  }(hr)
);
function gy(e) {
  return e instanceof Array || (e = [e, e]), e;
}
var CPe = {
  seriesType: "lines",
  reset: function(e) {
    var t = gy(e.get("symbol")), r = gy(e.get("symbolSize")), n = e.getData();
    n.setVisual("fromSymbol", t && t[0]), n.setVisual("toSymbol", t && t[1]), n.setVisual("fromSymbolSize", r && r[0]), n.setVisual("toSymbolSize", r && r[1]);
    function i(o, a) {
      var s = o.getItemModel(a), l = gy(s.getShallow("symbol", !0)), u = gy(s.getShallow("symbolSize", !0));
      l[0] && o.setItemVisual(a, "fromSymbol", l[0]), l[1] && o.setItemVisual(a, "toSymbol", l[1]), u[0] && o.setItemVisual(a, "fromSymbolSize", u[0]), u[1] && o.setItemVisual(a, "toSymbolSize", u[1]);
    }
    return {
      dataEach: n.hasItemOption ? i : null
    };
  }
};
function SPe(e) {
  e.registerChartView(gPe), e.registerSeriesModel(yPe), e.registerLayout(Dj), e.registerVisual(CPe);
}
var wPe = 256, bPe = (
  /** @class */
  function() {
    function e() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var t = va.createCanvas();
      this.canvas = t;
    }
    return e.prototype.update = function(t, r, n, i, o, a) {
      var s = this._getBrush(), l = this._getGradient(o, "inRange"), u = this._getGradient(o, "outOfRange"), c = this.pointSize + this.blurSize, d = this.canvas, h = d.getContext("2d"), f = t.length;
      d.width = r, d.height = n;
      for (var p = 0; p < f; ++p) {
        var g = t[p], v = g[0], m = g[1], y = g[2], C = i(y);
        h.globalAlpha = C, h.drawImage(s, v - c, m - c);
      }
      if (!d.width || !d.height)
        return d;
      for (var S = h.getImageData(0, 0, d.width, d.height), b = S.data, w = 0, x = b.length, E = this.minOpacity, R = this.maxOpacity, _ = R - E; w < x; ) {
        var C = b[w + 3] / 256, P = Math.floor(C * (wPe - 1)) * 4;
        if (C > 0) {
          var D = a(C) ? l : u;
          C > 0 && (C = C * _ + E), b[w++] = D[P], b[w++] = D[P + 1], b[w++] = D[P + 2], b[w++] = D[P + 3] * C * 256;
        } else
          w += 4;
      }
      return h.putImageData(S, 0, 0), d;
    }, e.prototype._getBrush = function() {
      var t = this._brushCanvas || (this._brushCanvas = va.createCanvas()), r = this.pointSize + this.blurSize, n = r * 2;
      t.width = n, t.height = n;
      var i = t.getContext("2d");
      return i.clearRect(0, 0, n, n), i.shadowOffsetX = n, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-r, r, this.pointSize, 0, Math.PI * 2, !0), i.closePath(), i.fill(), t;
    }, e.prototype._getGradient = function(t, r) {
      for (var n = this._gradientPixels, i = n[r] || (n[r] = new Uint8ClampedArray(256 * 4)), o = [0, 0, 0, 0], a = 0, s = 0; s < 256; s++)
        t[r](s / 255, !0, o), i[a++] = o[0], i[a++] = o[1], i[a++] = o[2], i[a++] = o[3];
      return i;
    }, e;
  }()
);
function xPe(e, t, r) {
  var n = e[1] - e[0];
  t = ge(t, function(a) {
    return {
      interval: [(a.interval[0] - e[0]) / n, (a.interval[1] - e[0]) / n]
    };
  });
  var i = t.length, o = 0;
  return function(a) {
    var s;
    for (s = o; s < i; s++) {
      var l = t[s].interval;
      if (l[0] <= a && a <= l[1]) {
        o = s;
        break;
      }
    }
    if (s === i)
      for (s = o - 1; s >= 0; s--) {
        var l = t[s].interval;
        if (l[0] <= a && a <= l[1]) {
          o = s;
          break;
        }
      }
    return s >= 0 && s < i && r[s];
  };
}
function EPe(e, t) {
  var r = e[1] - e[0];
  return t = [(t[0] - e[0]) / r, (t[1] - e[0]) / r], function(n) {
    return n >= t[0] && n <= t[1];
  };
}
function aB(e) {
  var t = e.dimensions;
  return t[0] === "lng" && t[1] === "lat";
}
var RPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o;
      if (n.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === r && (o = s);
        });
      }), process.env.NODE_ENV !== "production" && !o)
        throw new Error("Heatmap must use with visualMap");
      this._progressiveEls = null, this.group.removeAll();
      var a = r.coordinateSystem;
      a.type === "cartesian2d" || a.type === "calendar" ? this._renderOnCartesianAndCalendar(r, i, 0, r.getData().count()) : aB(a) && this._renderOnGeo(a, r, o, i);
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      this.group.removeAll();
    }, t.prototype.incrementalRender = function(r, n, i, o) {
      var a = n.coordinateSystem;
      a && (aB(a) ? this.render(n, i, o) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(n, o, r.start, r.end, !0)));
    }, t.prototype.eachRendered = function(r) {
      iu(this._progressiveEls || this.group, r);
    }, t.prototype._renderOnCartesianAndCalendar = function(r, n, i, o, a) {
      var s = r.coordinateSystem, l = Zc(s, "cartesian2d"), u, c, d, h;
      if (l) {
        var f = s.getAxis("x"), p = s.getAxis("y");
        if (process.env.NODE_ENV !== "production") {
          if (!(f.type === "category" && p.type === "category"))
            throw new Error("Heatmap on cartesian must have two category axes");
          if (!(f.onBand && p.onBand))
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
        u = f.getBandWidth() + 0.5, c = p.getBandWidth() + 0.5, d = f.scale.getExtent(), h = p.scale.getExtent();
      }
      for (var g = this.group, v = r.getData(), m = r.getModel(["emphasis", "itemStyle"]).getItemStyle(), y = r.getModel(["blur", "itemStyle"]).getItemStyle(), C = r.getModel(["select", "itemStyle"]).getItemStyle(), S = r.get(["itemStyle", "borderRadius"]), b = Rn(r), w = r.getModel("emphasis"), x = w.get("focus"), E = w.get("blurScope"), R = w.get("disabled"), _ = l ? [v.mapDimension("x"), v.mapDimension("y"), v.mapDimension("value")] : [v.mapDimension("time"), v.mapDimension("value")], P = i; P < o; P++) {
        var D = void 0, I = v.getItemVisual(P, "style");
        if (l) {
          var A = v.get(_[0], P), O = v.get(_[1], P);
          if (isNaN(v.get(_[2], P)) || isNaN(A) || isNaN(O) || A < d[0] || A > d[1] || O < h[0] || O > h[1])
            continue;
          var L = s.dataToPoint([A, O]);
          D = new Bt({
            shape: {
              x: L[0] - u / 2,
              y: L[1] - c / 2,
              width: u,
              height: c
            },
            style: I
          });
        } else {
          if (isNaN(v.get(_[1], P)))
            continue;
          D = new Bt({
            z2: 1,
            shape: s.dataToRect([v.get(_[0], P)]).contentShape,
            style: I
          });
        }
        if (v.hasItemOption) {
          var N = v.getItemModel(P), F = N.getModel("emphasis");
          m = F.getModel("itemStyle").getItemStyle(), y = N.getModel(["blur", "itemStyle"]).getItemStyle(), C = N.getModel(["select", "itemStyle"]).getItemStyle(), S = N.get(["itemStyle", "borderRadius"]), x = F.get("focus"), E = F.get("blurScope"), R = F.get("disabled"), b = Rn(N);
        }
        D.shape.r = S;
        var G = r.getRawValue(P), M = "-";
        G && G[2] != null && (M = G[2] + ""), Gn(D, b, {
          labelFetcher: r,
          labelDataIndex: P,
          defaultOpacity: I.opacity,
          defaultText: M
        }), D.ensureState("emphasis").style = m, D.ensureState("blur").style = y, D.ensureState("select").style = C, Hr(D, x, E, R), D.incremental = a, a && (D.states.emphasis.hoverLayer = !0), g.add(D), v.setItemGraphicEl(P, D), this._progressiveEls && this._progressiveEls.push(D);
      }
    }, t.prototype._renderOnGeo = function(r, n, i, o) {
      var a = i.targetVisuals.inRange, s = i.targetVisuals.outOfRange, l = n.getData(), u = this._hmLayer || this._hmLayer || new bPe();
      u.blurSize = n.get("blurSize"), u.pointSize = n.get("pointSize"), u.minOpacity = n.get("minOpacity"), u.maxOpacity = n.get("maxOpacity");
      var c = r.getViewRect().clone(), d = r.getRoamTransform();
      c.applyTransform(d);
      var h = Math.max(c.x, 0), f = Math.max(c.y, 0), p = Math.min(c.width + c.x, o.getWidth()), g = Math.min(c.height + c.y, o.getHeight()), v = p - h, m = g - f, y = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], C = l.mapArray(y, function(x, E, R) {
        var _ = r.dataToPoint([x, E]);
        return _[0] -= h, _[1] -= f, _.push(R), _;
      }), S = i.getExtent(), b = i.type === "visualMap.continuous" ? EPe(S, i.option.range) : xPe(S, i.getPieceList(), i.option.selected);
      u.update(C, v, m, a.color.getNormalizer(), {
        inRange: a.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, b);
      var w = new In({
        style: {
          width: v,
          height: m,
          x: h,
          y: f,
          image: u.canvas
        },
        silent: !0
      });
      this.group.add(w);
    }, t.type = "heatmap", t;
  }(ar)
), _Pe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      return os(null, this, {
        generateCoord: "value"
      });
    }, t.prototype.preventIncremental = function() {
      var r = Yc.get(this.get("coordinateSystem"));
      if (r && r.dimensions)
        return r.dimensions[0] === "lng" && r.dimensions[1] === "lat";
    }, t.type = "series.heatmap", t.dependencies = ["grid", "geo", "calendar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, t;
  }(hr)
);
function TPe(e) {
  e.registerChartView(RPe), e.registerSeriesModel(_Pe);
}
var PPe = ["itemStyle", "borderWidth"], sB = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], fx = new Js(), MPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = this.group, a = r.getData(), s = this._data, l = r.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), d = l.master.getRect(), h = {
        ecSize: {
          width: i.getWidth(),
          height: i.getHeight()
        },
        seriesModel: r,
        coordSys: l,
        coordSysExtent: [[d.x, d.x + d.width], [d.y, d.y + d.height]],
        isHorizontal: c,
        valueDim: sB[+c],
        categoryDim: sB[1 - +c]
      };
      a.diff(s).add(function(p) {
        if (a.hasValue(p)) {
          var g = uB(a, p), v = lB(a, p, g, h), m = cB(a, h, v);
          a.setItemGraphicEl(p, m), o.add(m), hB(m, h, v);
        }
      }).update(function(p, g) {
        var v = s.getItemGraphicEl(g);
        if (!a.hasValue(p)) {
          o.remove(v);
          return;
        }
        var m = uB(a, p), y = lB(a, p, m, h), C = Nj(a, y);
        v && C !== v.__pictorialShapeStr && (o.remove(v), a.setItemGraphicEl(p, null), v = null), v ? NPe(v, h, y) : v = cB(a, h, y, !0), a.setItemGraphicEl(p, v), v.__pictorialSymbolMeta = y, o.add(v), hB(v, h, y);
      }).remove(function(p) {
        var g = s.getItemGraphicEl(p);
        g && dB(s, p, g.__pictorialSymbolMeta.animationModel, g);
      }).execute();
      var f = r.get("clip", !0) ? Bv(r.coordinateSystem, !1, r) : null;
      return f ? o.setClipPath(f) : o.removeClipPath(), this._data = a, this.group;
    }, t.prototype.remove = function(r, n) {
      var i = this.group, o = this._data;
      r.get("animation") ? o && o.eachItemGraphicEl(function(a) {
        dB(o, ot(a).dataIndex, r, a);
      }) : i.removeAll();
    }, t.type = "pictorialBar", t;
  }(ar)
);
function lB(e, t, r, n) {
  var i = e.getItemLayout(t), o = r.get("symbolRepeat"), a = r.get("symbolClip"), s = r.get("symbolPosition") || "start", l = r.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = r.get("symbolPatternSize") || 2, d = r.isAnimationEnabled(), h = {
    dataIndex: t,
    layout: i,
    itemModel: r,
    symbolType: e.getItemVisual(t, "symbol") || "circle",
    style: e.getItemVisual(t, "style"),
    symbolClip: a,
    symbolRepeat: o,
    symbolRepeatDirection: r.get("symbolRepeatDirection"),
    symbolPatternSize: c,
    rotation: u,
    animationModel: d ? r : null,
    hoverScale: d && r.get(["emphasis", "scale"]),
    z2: r.getShallow("z", !0) || 0
  };
  DPe(r, o, i, n, h), APe(e, t, i, o, a, h.boundingLength, h.pxSign, c, n, h), IPe(r, h.symbolScale, u, n, h);
  var f = h.symbolSize, p = qc(r.get("symbolOffset"), f);
  return FPe(r, f, i, o, a, p, s, h.valueLineWidth, h.boundingLength, h.repeatCutLength, n, h), h;
}
function DPe(e, t, r, n, i) {
  var o = n.valueDim, a = e.get("symbolBoundingData"), s = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(r[o.wh] <= 0), c;
  if (fe(a)) {
    var d = [px(s, a[0]) - l, px(s, a[1]) - l];
    d[1] < d[0] && d.reverse(), c = d[u];
  } else a != null ? c = px(s, a) - l : t ? c = n.coordSysExtent[o.index][u] - l : c = r[o.wh];
  i.boundingLength = c, t && (i.repeatCutLength = r[o.wh]), i.pxSign = c > 0 ? 1 : -1;
}
function px(e, t) {
  return e.toGlobalCoord(e.dataToCoord(e.scale.parse(t)));
}
function APe(e, t, r, n, i, o, a, s, l, u) {
  var c = l.valueDim, d = l.categoryDim, h = Math.abs(r[d.wh]), f = e.getItemVisual(t, "symbolSize"), p;
  fe(f) ? p = f.slice() : f == null ? p = ["100%", "100%"] : p = [f, f], p[d.index] = Ae(p[d.index], h), p[c.index] = Ae(p[c.index], n ? h : Math.abs(o)), u.symbolSize = p;
  var g = u.symbolScale = [p[0] / s, p[1] / s];
  g[c.index] *= (l.isHorizontal ? -1 : 1) * a;
}
function IPe(e, t, r, n, i) {
  var o = e.get(PPe) || 0;
  o && (fx.attr({
    scaleX: t[0],
    scaleY: t[1],
    rotation: r
  }), fx.updateTransform(), o /= fx.getLineScale(), o *= t[n.valueDim.index]), i.valueLineWidth = o || 0;
}
function FPe(e, t, r, n, i, o, a, s, l, u, c, d) {
  var h = c.categoryDim, f = c.valueDim, p = d.pxSign, g = Math.max(t[f.index] + s, 0), v = g;
  if (n) {
    var m = Math.abs(l), y = tn(e.get("symbolMargin"), "15%") + "", C = !1;
    y.lastIndexOf("!") === y.length - 1 && (C = !0, y = y.slice(0, y.length - 1));
    var S = Ae(y, t[f.index]), b = Math.max(g + S * 2, 0), w = C ? 0 : S * 2, x = MS(n), E = x ? n : fB((m + w) / b), R = m - E * g;
    S = R / 2 / (C ? E : Math.max(E - 1, 1)), b = g + S * 2, w = C ? 0 : S * 2, !x && n !== "fixed" && (E = u ? fB((Math.abs(u) + w) / b) : 0), v = E * b - w, d.repeatTimes = E, d.symbolMargin = S;
  }
  var _ = p * (v / 2), P = d.pathPosition = [];
  P[h.index] = r[h.wh] / 2, P[f.index] = a === "start" ? _ : a === "end" ? l - _ : l / 2, o && (P[0] += o[0], P[1] += o[1]);
  var D = d.bundlePosition = [];
  D[h.index] = r[h.xy], D[f.index] = r[f.xy];
  var I = d.barRectShape = se({}, r);
  I[f.wh] = p * Math.max(Math.abs(r[f.wh]), Math.abs(P[f.index] + _)), I[h.wh] = r[h.wh];
  var A = d.clipShape = {};
  A[h.xy] = -r[h.xy], A[h.wh] = c.ecSize[h.wh], A[f.xy] = 0, A[f.wh] = r[f.wh];
}
function Aj(e) {
  var t = e.symbolPatternSize, r = rn(
    // Consider texture img, make a big size.
    e.symbolType,
    -t / 2,
    -t / 2,
    t,
    t
  );
  return r.attr({
    culling: !0
  }), r.type !== "image" && r.setStyle({
    strokeNoScale: !0
  }), r;
}
function Ij(e, t, r, n) {
  var i = e.__pictorialBundle, o = r.symbolSize, a = r.valueLineWidth, s = r.pathPosition, l = t.valueDim, u = r.repeatTimes || 0, c = 0, d = o[t.valueDim.index] + a + r.symbolMargin * 2;
  for (BD(e, function(g) {
    g.__pictorialAnimationIndex = c, g.__pictorialRepeatTimes = u, c < u ? Ch(g, null, p(c), r, n) : Ch(g, null, {
      scaleX: 0,
      scaleY: 0
    }, r, n, function() {
      i.remove(g);
    }), c++;
  }); c < u; c++) {
    var h = Aj(r);
    h.__pictorialAnimationIndex = c, h.__pictorialRepeatTimes = u, i.add(h);
    var f = p(c);
    Ch(h, {
      x: f.x,
      y: f.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: f.scaleX,
      scaleY: f.scaleY,
      rotation: f.rotation
    }, r, n);
  }
  function p(g) {
    var v = s.slice(), m = r.pxSign, y = g;
    return (r.symbolRepeatDirection === "start" ? m > 0 : m < 0) && (y = u - 1 - g), v[l.index] = d * (y - u / 2 + 0.5) + s[l.index], {
      x: v[0],
      y: v[1],
      scaleX: r.symbolScale[0],
      scaleY: r.symbolScale[1],
      rotation: r.rotation
    };
  }
}
function Fj(e, t, r, n) {
  var i = e.__pictorialBundle, o = e.__pictorialMainPath;
  o ? Ch(o, null, {
    x: r.pathPosition[0],
    y: r.pathPosition[1],
    scaleX: r.symbolScale[0],
    scaleY: r.symbolScale[1],
    rotation: r.rotation
  }, r, n) : (o = e.__pictorialMainPath = Aj(r), i.add(o), Ch(o, {
    x: r.pathPosition[0],
    y: r.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: r.rotation
  }, {
    scaleX: r.symbolScale[0],
    scaleY: r.symbolScale[1]
  }, r, n));
}
function Lj(e, t, r) {
  var n = se({}, t.barRectShape), i = e.__pictorialBarRect;
  i ? Ch(i, null, {
    shape: n
  }, t, r) : (i = e.__pictorialBarRect = new Bt({
    z2: 2,
    shape: n,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), i.disableMorphing = !0, e.add(i));
}
function Oj(e, t, r, n) {
  if (r.symbolClip) {
    var i = e.__pictorialClipPath, o = se({}, r.clipShape), a = t.valueDim, s = r.animationModel, l = r.dataIndex;
    if (i)
      jt(i, {
        shape: o
      }, s, l);
    else {
      o[a.wh] = 0, i = new Bt({
        shape: o
      }), e.__pictorialBundle.setClipPath(i), e.__pictorialClipPath = i;
      var u = {};
      u[a.wh] = r.clipShape[a.wh], jc[n ? "updateProps" : "initProps"](i, {
        shape: u
      }, s, l);
    }
  }
}
function uB(e, t) {
  var r = e.getItemModel(t);
  return r.getAnimationDelayParams = LPe, r.isAnimationEnabled = OPe, r;
}
function LPe(e) {
  return {
    index: e.__pictorialAnimationIndex,
    count: e.__pictorialRepeatTimes
  };
}
function OPe() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function cB(e, t, r, n) {
  var i = new it(), o = new it();
  return i.add(o), i.__pictorialBundle = o, o.x = r.bundlePosition[0], o.y = r.bundlePosition[1], r.symbolRepeat ? Ij(i, t, r) : Fj(i, t, r), Lj(i, r, n), Oj(i, t, r, n), i.__pictorialShapeStr = Nj(e, r), i.__pictorialSymbolMeta = r, i;
}
function NPe(e, t, r) {
  var n = r.animationModel, i = r.dataIndex, o = e.__pictorialBundle;
  jt(o, {
    x: r.bundlePosition[0],
    y: r.bundlePosition[1]
  }, n, i), r.symbolRepeat ? Ij(e, t, r, !0) : Fj(e, t, r, !0), Lj(e, r, !0), Oj(e, t, r, !0);
}
function dB(e, t, r, n) {
  var i = n.__pictorialBarRect;
  i && i.removeTextContent();
  var o = [];
  BD(n, function(a) {
    o.push(a);
  }), n.__pictorialMainPath && o.push(n.__pictorialMainPath), n.__pictorialClipPath && (r = null), B(o, function(a) {
    Ul(a, {
      scaleX: 0,
      scaleY: 0
    }, r, t, function() {
      n.parent && n.parent.remove(n);
    });
  }), e.setItemGraphicEl(t, null);
}
function Nj(e, t) {
  return [e.getItemVisual(t.dataIndex, "symbol") || "none", !!t.symbolRepeat, !!t.symbolClip].join(":");
}
function BD(e, t, r) {
  B(e.__pictorialBundle.children(), function(n) {
    n !== e.__pictorialBarRect && t.call(r, n);
  });
}
function Ch(e, t, r, n, i, o) {
  t && e.attr(t), n.symbolClip && !i ? r && e.attr(r) : r && jc[i ? "updateProps" : "initProps"](e, r, n.animationModel, n.dataIndex, o);
}
function hB(e, t, r) {
  var n = r.dataIndex, i = r.itemModel, o = i.getModel("emphasis"), a = o.getModel("itemStyle").getItemStyle(), s = i.getModel(["blur", "itemStyle"]).getItemStyle(), l = i.getModel(["select", "itemStyle"]).getItemStyle(), u = i.getShallow("cursor"), c = o.get("focus"), d = o.get("blurScope"), h = o.get("scale");
  BD(e, function(g) {
    if (g instanceof In) {
      var v = g.style;
      g.useStyle(se({
        // TODO other properties like dx, dy ?
        image: v.image,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      }, r.style));
    } else
      g.useStyle(r.style);
    var m = g.ensureState("emphasis");
    m.style = a, h && (m.scaleX = g.scaleX * 1.1, m.scaleY = g.scaleY * 1.1), g.ensureState("blur").style = s, g.ensureState("select").style = l, u && (g.cursor = u), g.z2 = r.z2;
  });
  var f = t.valueDim.posDesc[+(r.boundingLength > 0)], p = e.__pictorialBarRect;
  p.ignoreClip = !0, Gn(p, Rn(i), {
    labelFetcher: t.seriesModel,
    labelDataIndex: n,
    defaultText: kh(t.seriesModel.getData(), n),
    inheritColor: r.style.fill,
    defaultOpacity: r.style.opacity,
    defaultOutsidePosition: f
  }), Hr(e, c, d, o.get("disabled"));
}
function fB(e) {
  var t = Math.round(e);
  return Math.abs(e - t) < 1e-4 ? t : Math.ceil(e);
}
var kPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.hasSymbolVisual = !0, r.defaultSymbol = "roundRect", r;
    }
    return t.prototype.getInitialData = function(r) {
      return r.stack = null, e.prototype.getInitialData.apply(this, arguments);
    }, t.type = "series.pictorialBar", t.dependencies = ["grid"], t.defaultOption = ou(Yg.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // Pictorial bar do not clip by default because in many cases
      // xAxis and yAxis are not displayed and it's expected not to clip
      clip: !1,
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), t;
  }(Yg)
);
function VPe(e) {
  e.registerChartView(MPe), e.registerSeriesModel(kPe), e.registerLayout(e.PRIORITY.VISUAL.LAYOUT, dt(y7, "pictorialBar")), e.registerLayout(e.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, C7("pictorialBar"));
}
var BPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._layers = [], r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = r.getData(), a = this, s = this.group, l = r.getLayerSeries(), u = o.getLayout("layoutInfo"), c = u.rect, d = u.boundaryGap;
      s.x = 0, s.y = c.y + d[0];
      function h(v) {
        return v.name;
      }
      var f = new Ws(this._layersSeries || [], l, h, h), p = [];
      f.add(ke(g, this, "add")).update(ke(g, this, "update")).remove(ke(g, this, "remove")).execute();
      function g(v, m, y) {
        var C = a._layers;
        if (v === "remove") {
          s.remove(C[m]);
          return;
        }
        for (var S = [], b = [], w, x = l[m].indices, E = 0; E < x.length; E++) {
          var R = o.getItemLayout(x[E]), _ = R.x, P = R.y0, D = R.y;
          S.push(_, P), b.push(_, P + D), w = o.getItemVisual(x[E], "style");
        }
        var I, A = o.getItemLayout(x[0]), O = r.getModel("label"), L = O.get("margin"), N = r.getModel("emphasis");
        if (v === "add") {
          var F = p[m] = new it();
          I = new s9({
            shape: {
              points: S,
              stackedOnPoints: b,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), F.add(I), s.add(F), r.isAnimationEnabled() && I.setClipPath(GPe(I.getBoundingRect(), r, function() {
            I.removeClipPath();
          }));
        } else {
          var F = C[y];
          I = F.childAt(0), s.add(F), p[m] = F, jt(I, {
            shape: {
              points: S,
              stackedOnPoints: b
            }
          }, r), Ca(I);
        }
        Gn(I, Rn(r), {
          labelDataIndex: x[E - 1],
          defaultText: o.getName(x[E - 1]),
          inheritColor: w.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), I.setTextConfig({
          position: null,
          local: !0
        });
        var G = I.getTextContent();
        G && (G.x = A.x - L, G.y = A.y0 + A.y / 2), I.useStyle(w), o.setItemGraphicEl(m, I), Bn(I, r), Hr(I, N.get("focus"), N.get("blurScope"), N.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, t.type = "themeRiver", t;
  }(ar)
);
function GPe(e, t, r) {
  var n = new Bt({
    shape: {
      x: e.x - 10,
      y: e.y - 10,
      width: 0,
      height: e.height + 20
    }
  });
  return Pr(n, {
    shape: {
      x: e.x - 50,
      width: e.width + 100,
      height: e.height + 20
    }
  }, t, r), n;
}
var gx = 2, HPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r) {
      e.prototype.init.apply(this, arguments), this.legendVisualProvider = new zv(ke(this.getData, this), ke(this.getRawData, this));
    }, t.prototype.fixData = function(r) {
      var n = r.length, i = {}, o = ZR(r, function(h) {
        return i.hasOwnProperty(h[0] + "") || (i[h[0] + ""] = -1), h[2];
      }), a = [];
      o.buckets.each(function(h, f) {
        a.push({
          name: f,
          dataList: h
        });
      });
      for (var s = a.length, l = 0; l < s; ++l) {
        for (var u = a[l].name, c = 0; c < a[l].dataList.length; ++c) {
          var d = a[l].dataList[c][0] + "";
          i[d] = l;
        }
        for (var d in i)
          i.hasOwnProperty(d) && i[d] !== l && (i[d] = l, r[n] = [d, 0, u], n++);
      }
      return r;
    }, t.prototype.getInitialData = function(r, n) {
      for (var i = this.getReferringComponents("singleAxis", un).models[0], o = i.get("type"), a = ir(r.data, function(p) {
        return p[2] !== void 0;
      }), s = this.fixData(a || []), l = [], u = this.nameMap = We(), c = 0, d = 0; d < s.length; ++d)
        l.push(s[d][gx]), u.get(s[d][gx]) || (u.set(s[d][gx], c), c++);
      var h = mf(s, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: fC(o)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, f = new Jn(h, this);
      return f.initData(s), f;
    }, t.prototype.getLayerSeries = function() {
      for (var r = this.getData(), n = r.count(), i = [], o = 0; o < n; ++o)
        i[o] = o;
      var a = r.mapDimension("single"), s = ZR(i, function(u) {
        return r.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, c) {
        u.sort(function(d, h) {
          return r.get(a, d) - r.get(a, h);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, t.prototype.getAxisTooltipData = function(r, n, i) {
      fe(r) || (r = r ? [r] : []);
      for (var o = this.getData(), a = this.getLayerSeries(), s = [], l = a.length, u, c = 0; c < l; ++c) {
        for (var d = Number.MAX_VALUE, h = -1, f = a[c].indices.length, p = 0; p < f; ++p) {
          var g = o.get(r[0], a[c].indices[p]), v = Math.abs(g - n);
          v <= d && (u = g, d = v, h = a[c].indices[p]);
        }
        s.push(h);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = o.getName(r), s = o.get(o.mapDimension("value"), r);
      return _n("nameValue", {
        name: a,
        value: s
      });
    }, t.type = "series.themeRiver", t.dependencies = ["singleAxis"], t.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, t;
  }(hr)
);
function zPe(e, t) {
  e.eachSeriesByType("themeRiver", function(r) {
    var n = r.getData(), i = r.coordinateSystem, o = {}, a = i.getRect();
    o.rect = a;
    var s = r.get("boundaryGap"), l = i.getAxis();
    if (o.boundaryGap = s, l.orient === "horizontal") {
      s[0] = Ae(s[0], a.height), s[1] = Ae(s[1], a.height);
      var u = a.height - s[0] - s[1];
      pB(n, r, u);
    } else {
      s[0] = Ae(s[0], a.width), s[1] = Ae(s[1], a.width);
      var c = a.width - s[0] - s[1];
      pB(n, r, c);
    }
    n.setLayout("layoutInfo", o);
  });
}
function pB(e, t, r) {
  if (e.count())
    for (var n = t.coordinateSystem, i = t.getLayerSeries(), o = e.mapDimension("single"), a = e.mapDimension("value"), s = ge(i, function(v) {
      return ge(v.indices, function(m) {
        var y = n.dataToPoint(e.get(o, m));
        return y[1] = e.get(a, m), y;
      });
    }), l = $Pe(s), u = l.y0, c = r / l.max, d = i.length, h = i[0].indices.length, f, p = 0; p < h; ++p) {
      f = u[p] * c, e.setItemLayout(i[0].indices[p], {
        layerIndex: 0,
        x: s[0][p][0],
        y0: f,
        y: s[0][p][1] * c
      });
      for (var g = 1; g < d; ++g)
        f += s[g - 1][p][1] * c, e.setItemLayout(i[g].indices[p], {
          layerIndex: g,
          x: s[g][p][0],
          y0: f,
          y: s[g][p][1] * c
        });
    }
}
function $Pe(e) {
  for (var t = e.length, r = e[0].length, n = [], i = [], o = 0, a = 0; a < r; ++a) {
    for (var s = 0, l = 0; l < t; ++l)
      s += e[l][a][1];
    s > o && (o = s), n.push(s);
  }
  for (var u = 0; u < r; ++u)
    i[u] = (o - n[u]) / 2;
  o = 0;
  for (var c = 0; c < r; ++c) {
    var d = n[c] + i[c];
    d > o && (o = d);
  }
  return {
    y0: i,
    max: o
  };
}
function WPe(e) {
  e.registerChartView(BPe), e.registerSeriesModel(HPe), e.registerLayout(zPe), e.registerProcessor(Hv("themeRiver"));
}
var jPe = 2, UPe = 4, gB = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i, o) {
      var a = e.call(this) || this;
      a.z2 = jPe, a.textConfig = {
        inside: !0
      }, ot(a).seriesIndex = n.seriesIndex;
      var s = new Vt({
        z2: UPe,
        silent: r.getModel().get(["label", "silent"])
      });
      return a.setTextContent(s), a.updateData(!0, r, n, i, o), a;
    }
    return t.prototype.updateData = function(r, n, i, o, a) {
      this.node = n, n.piece = this, i = i || this._seriesModel, o = o || this._ecModel;
      var s = this;
      ot(s).dataIndex = n.dataIndex;
      var l = n.getModel(), u = l.getModel("emphasis"), c = n.getLayout(), d = se({}, c);
      d.label = null;
      var h = n.getVisual("style");
      h.lineJoin = "bevel";
      var f = n.getVisual("decal");
      f && (h.decal = Nh(f, a));
      var p = sc(l.getModel("itemStyle"), d, !0);
      se(d, p), B(bi, function(y) {
        var C = s.ensureState(y), S = l.getModel([y, "itemStyle"]);
        C.style = S.getItemStyle();
        var b = sc(S, d);
        b && (C.shape = b);
      }), r ? (s.setShape(d), s.shape.r = c.r0, Pr(s, {
        shape: {
          r: c.r
        }
      }, i, n.dataIndex)) : (jt(s, {
        shape: d
      }, i), Ca(s)), s.useStyle(h), this._updateLabel(i);
      var g = l.getShallow("cursor");
      g && s.attr("cursor", g), this._seriesModel = i || this._seriesModel, this._ecModel = o || this._ecModel;
      var v = u.get("focus"), m = v === "ancestor" ? n.getAncestorsIndices() : v === "descendant" ? n.getDescendantIndices() : v;
      Hr(this, m, u.get("blurScope"), u.get("disabled"));
    }, t.prototype._updateLabel = function(r) {
      var n = this, i = this.node.getModel(), o = i.getModel("label"), a = this.node.getLayout(), s = a.endAngle - a.startAngle, l = (a.startAngle + a.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), d = this, h = d.getTextContent(), f = this.node.dataIndex, p = o.get("minAngle") / 180 * Math.PI, g = o.get("show") && !(p != null && Math.abs(s) < p);
      h.ignore = !g, B(kg, function(m) {
        var y = m === "normal" ? i.getModel("label") : i.getModel([m, "label"]), C = m === "normal", S = C ? h : h.ensureState(m), b = r.getFormattedLabel(f, m);
        C && (b = b || n.node.name), S.style = br(y, {}, null, m !== "normal", !0), b && (S.style.text = b);
        var w = y.get("show");
        w != null && !C && (S.ignore = !w);
        var x = v(y, "position"), E = C ? d : d.states[m], R = E.style.fill;
        E.textConfig = {
          outsideFill: y.get("color") === "inherit" ? R : null,
          inside: x !== "outside"
        };
        var _, P = v(y, "distance") || 0, D = v(y, "align"), I = v(y, "rotate"), A = Math.PI * 0.5, O = Math.PI * 1.5, L = eo(I === "tangential" ? Math.PI / 2 - l : l), N = L > A && !Ah(L - A) && L < O;
        x === "outside" ? (_ = a.r + P, D = N ? "right" : "left") : !D || D === "center" ? (s === 2 * Math.PI && a.r0 === 0 ? _ = 0 : _ = (a.r + a.r0) / 2, D = "center") : D === "left" ? (_ = a.r0 + P, D = N ? "right" : "left") : D === "right" && (_ = a.r - P, D = N ? "left" : "right"), S.style.align = D, S.style.verticalAlign = v(y, "verticalAlign") || "middle", S.x = _ * u + a.cx, S.y = _ * c + a.cy;
        var F = 0;
        I === "radial" ? F = eo(-l) + (N ? Math.PI : 0) : I === "tangential" ? F = eo(Math.PI / 2 - l) + (N ? Math.PI : 0) : $t(I) && (F = I * Math.PI / 180), S.rotation = eo(F);
      });
      function v(m, y) {
        var C = m.get(y);
        return C ?? o.get(y);
      }
      h.dirtyStyle();
    }, t;
  }(xi)
), X_ = "sunburstRootToNode", vB = "sunburstHighlight", KPe = "sunburstUnhighlight";
function YPe(e) {
  e.registerAction({
    type: X_,
    update: "updateView"
  }, function(t, r) {
    r.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: t
    }, n);
    function n(i, o) {
      var a = Zg(t, [X_], i);
      if (a) {
        var s = i.getViewRoot();
        s && (t.direction = RD(s, a.node) ? "rollUp" : "drillDown"), i.resetViewRoot(a.node);
      }
    }
  }), e.registerAction({
    type: vB,
    update: "none"
  }, function(t, r, n) {
    t = se({}, t), r.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: t
    }, i);
    function i(o) {
      var a = Zg(t, [vB], o);
      a && (t.dataIndex = a.node.dataIndex);
    }
    process.env.NODE_ENV !== "production" && Jr("sunburstHighlight", "highlight"), n.dispatchAction(se(t, {
      type: "highlight"
    }));
  }), e.registerAction({
    type: KPe,
    update: "updateView"
  }, function(t, r, n) {
    t = se({}, t), process.env.NODE_ENV !== "production" && Jr("sunburstUnhighlight", "downplay"), n.dispatchAction(se(t, {
      type: "downplay"
    }));
  });
}
var qPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = this;
      this.seriesModel = r, this.api = i, this.ecModel = n;
      var s = r.getData(), l = s.tree.root, u = r.getViewRoot(), c = this.group, d = r.get("renderLabelForZeroData"), h = [];
      u.eachNode(function(y) {
        h.push(y);
      });
      var f = this._oldChildren || [];
      p(h, f), m(l, u), this._initEvents(), this._oldChildren = h;
      function p(y, C) {
        if (y.length === 0 && C.length === 0)
          return;
        new Ws(C, y, S, S).add(b).update(b).remove(dt(b, null)).execute();
        function S(w) {
          return w.getId();
        }
        function b(w, x) {
          var E = w == null ? null : y[w], R = x == null ? null : C[x];
          g(E, R);
        }
      }
      function g(y, C) {
        if (!d && y && !y.getValue() && (y = null), y !== l && C !== l) {
          if (C && C.piece)
            y ? (C.piece.updateData(!1, y, r, n, i), s.setItemGraphicEl(y.dataIndex, C.piece)) : v(C);
          else if (y) {
            var S = new gB(y, r, n, i);
            c.add(S), s.setItemGraphicEl(y.dataIndex, S);
          }
        }
      }
      function v(y) {
        y && y.piece && (c.remove(y.piece), y.piece = null);
      }
      function m(y, C) {
        C.depth > 0 ? (a.virtualPiece ? a.virtualPiece.updateData(!1, y, r, n, i) : (a.virtualPiece = new gB(y, r, n, i), c.add(a.virtualPiece)), C.piece.off("click"), a.virtualPiece.on("click", function(S) {
          a._rootToNode(C.parentNode);
        })) : a.virtualPiece && (c.remove(a.virtualPiece), a.virtualPiece = null);
      }
    }, t.prototype._initEvents = function() {
      var r = this;
      this.group.off("click"), this.group.on("click", function(n) {
        var i = !1, o = r.seriesModel.getViewRoot();
        o.eachNode(function(a) {
          if (!i && a.piece && a.piece === n.target) {
            var s = a.getModel().get("nodeClick");
            if (s === "rootToNode")
              r._rootToNode(a);
            else if (s === "link") {
              var l = a.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", !0) || "_blank";
                tC(u, c);
              }
            }
            i = !0;
          }
        });
      });
    }, t.prototype._rootToNode = function(r) {
      r !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: X_,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: r
      });
    }, t.prototype.containPoint = function(r, n) {
      var i = n.getData(), o = i.getItemLayout(0);
      if (o) {
        var a = r[0] - o.cx, s = r[1] - o.cy, l = Math.sqrt(a * a + s * s);
        return l <= o.r && l >= o.r0;
      }
    }, t.type = "sunburst", t;
  }(ar)
), ZPe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.ignoreStyleOnData = !0, r;
    }
    return t.prototype.getInitialData = function(r, n) {
      var i = {
        name: r.name,
        children: r.data
      };
      kj(i);
      var o = this._levelModels = ge(r.levels || [], function(l) {
        return new cr(l, this, n);
      }, this), a = ED.createTree(i, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var d = a.getNodeByDataIndex(c), h = o[d.depth];
          return h && (u.parentModel = h), u;
        });
      }
      return a.data;
    }, t.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, t.prototype.getDataParams = function(r) {
      var n = e.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(r);
      return n.treePathInfo = sw(i, this), n;
    }, t.prototype.getLevelModel = function(r) {
      return this._levelModels && this._levelModels[r.depth];
    }, t.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, t.prototype.resetViewRoot = function(r) {
      r ? this._viewRoot = r : r = this._viewRoot;
      var n = this.getRawData().tree.root;
      (!r || r !== n && !n.contains(r)) && (this._viewRoot = n);
    }, t.prototype.enableAriaDecal = function() {
      z9(this);
    }, t.type = "series.sunburst", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 默认全局居中
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 默认顺时针
      clockwise: !0,
      startAngle: 90,
      // 最小角度改为0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, t;
  }(hr)
);
function kj(e) {
  var t = 0;
  B(e.children, function(n) {
    kj(n);
    var i = n.value;
    fe(i) && (i = i[0]), t += i;
  });
  var r = e.value;
  fe(r) && (r = r[0]), (r == null || isNaN(r)) && (r = t), r < 0 && (r = 0), fe(e.value) ? e.value[0] = r : e.value = r;
}
var mB = Math.PI / 180;
function XPe(e, t, r) {
  t.eachSeriesByType(e, function(n) {
    var i = n.get("center"), o = n.get("radius");
    fe(o) || (o = [0, o]), fe(i) || (i = [i, i]);
    var a = r.getWidth(), s = r.getHeight(), l = Math.min(a, s), u = Ae(i[0], a), c = Ae(i[1], s), d = Ae(o[0], l / 2), h = Ae(o[1], l / 2), f = -n.get("startAngle") * mB, p = n.get("minAngle") * mB, g = n.getData().tree.root, v = n.getViewRoot(), m = v.depth, y = n.get("sort");
    y != null && Vj(v, y);
    var C = 0;
    B(v.children, function(L) {
      !isNaN(L.getValue()) && C++;
    });
    var S = v.getValue(), b = Math.PI / (S || C) * 2, w = v.depth > 0, x = v.height - (w ? -1 : 1), E = (h - d) / (x || 1), R = n.get("clockwise"), _ = n.get("stillShowZeroSum"), P = R ? 1 : -1, D = function(L, N) {
      if (L) {
        var F = N;
        if (L !== g) {
          var G = L.getValue(), M = S === 0 && _ ? b : G * b;
          M < p && (M = p), F = N + P * M;
          var V = L.depth - m - (w ? -1 : 1), z = d + E * V, k = d + E * (V + 1), $ = n.getLevelModel(L);
          if ($) {
            var W = $.get("r0", !0), j = $.get("r", !0), U = $.get("radius", !0);
            U != null && (W = U[0], j = U[1]), W != null && (z = Ae(W, l / 2)), j != null && (k = Ae(j, l / 2));
          }
          L.setLayout({
            angle: M,
            startAngle: N,
            endAngle: F,
            clockwise: R,
            cx: u,
            cy: c,
            r0: z,
            r: k
          });
        }
        if (L.children && L.children.length) {
          var Z = 0;
          B(L.children, function(ee) {
            Z += D(ee, N + Z);
          });
        }
        return F - N;
      }
    };
    if (w) {
      var I = d, A = d + E, O = Math.PI * 2;
      g.setLayout({
        angle: O,
        startAngle: f,
        endAngle: f + O,
        clockwise: R,
        cx: u,
        cy: c,
        r0: I,
        r: A
      });
    }
    D(v, f);
  });
}
function Vj(e, t) {
  var r = e.children || [];
  e.children = QPe(r, t), r.length && B(e.children, function(n) {
    Vj(n, t);
  });
}
function QPe(e, t) {
  if (Ye(t)) {
    var r = ge(e, function(i, o) {
      var a = i.getValue();
      return {
        params: {
          depth: i.depth,
          height: i.height,
          dataIndex: i.dataIndex,
          getValue: function() {
            return a;
          }
        },
        index: o
      };
    });
    return r.sort(function(i, o) {
      return t(i.params, o.params);
    }), ge(r, function(i) {
      return e[i.index];
    });
  } else {
    var n = t === "asc";
    return e.sort(function(i, o) {
      var a = (i.getValue() - o.getValue()) * (n ? 1 : -1);
      return a === 0 ? (i.dataIndex - o.dataIndex) * (n ? -1 : 1) : a;
    });
  }
}
function JPe(e) {
  var t = {};
  function r(n, i, o) {
    for (var a = n; a && a.depth > 1; )
      a = a.parentNode;
    var s = i.getColorFromPalette(a.name || a.dataIndex + "", t);
    return n.depth > 1 && Fe(s) && (s = z0(s, (n.depth - 1) / (o - 1) * 0.5)), s;
  }
  e.eachSeriesByType("sunburst", function(n) {
    var i = n.getData(), o = i.tree;
    o.eachNode(function(a) {
      var s = a.getModel(), l = s.getModel("itemStyle").getItemStyle();
      l.fill || (l.fill = r(a, n, o.root.height));
      var u = i.ensureUniqueItemVisual(a.dataIndex, "style");
      se(u, l);
    });
  });
}
function eMe(e) {
  e.registerChartView(qPe), e.registerSeriesModel(ZPe), e.registerLayout(dt(XPe, "sunburst")), e.registerProcessor(dt(Hv, "sunburst")), e.registerVisual(JPe), YPe(e);
}
var yB = {
  color: "fill",
  borderColor: "stroke"
}, tMe = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, Is = Gt(), rMe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, t.prototype.getInitialData = function(r, n) {
      return os(null, this);
    }, t.prototype.getDataParams = function(r, n, i) {
      var o = e.prototype.getDataParams.call(this, r, n);
      return i && (o.info = Is(i).info), o;
    }, t.type = "series.custom", t.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], t.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, t;
  }(hr)
);
function nMe(e, t) {
  return t = t || [0, 0], ge(["x", "y"], function(r, n) {
    var i = this.getAxis(r), o = t[n], a = e[n] / 2;
    return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(o - a) - i.dataToCoord(o + a));
  }, this);
}
function iMe(e) {
  var t = e.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(r) {
        return e.dataToPoint(r);
      },
      size: ke(nMe, e)
    }
  };
}
function oMe(e, t) {
  return t = t || [0, 0], ge([0, 1], function(r) {
    var n = t[r], i = e[r] / 2, o = [], a = [];
    return o[r] = n - i, a[r] = n + i, o[1 - r] = a[1 - r] = t[1 - r], Math.abs(this.dataToPoint(o)[r] - this.dataToPoint(a)[r]);
  }, this);
}
function aMe(e) {
  var t = e.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      zoom: e.getZoom()
    },
    api: {
      coord: function(r) {
        return e.dataToPoint(r);
      },
      size: ke(oMe, e)
    }
  };
}
function sMe(e, t) {
  var r = this.getAxis(), n = t instanceof Array ? t[0] : t, i = (e instanceof Array ? e[0] : e) / 2;
  return r.type === "category" ? r.getBandWidth() : Math.abs(r.dataToCoord(n - i) - r.dataToCoord(n + i));
}
function lMe(e) {
  var t = e.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    api: {
      coord: function(r) {
        return e.dataToPoint(r);
      },
      size: ke(sMe, e)
    }
  };
}
function uMe(e, t) {
  return t = t || [0, 0], ge(["Radius", "Angle"], function(r, n) {
    var i = "get" + r + "Axis", o = this[i](), a = t[n], s = e[n] / 2, l = o.type === "category" ? o.getBandWidth() : Math.abs(o.dataToCoord(a - s) - o.dataToCoord(a + s));
    return r === "Angle" && (l = l * Math.PI / 180), l;
  }, this);
}
function cMe(e) {
  var t = e.getRadiusAxis(), r = e.getAngleAxis(), n = t.getExtent();
  return n[0] > n[1] && n.reverse(), {
    coordSys: {
      type: "polar",
      cx: e.cx,
      cy: e.cy,
      r: n[1],
      r0: n[0]
    },
    api: {
      coord: function(i) {
        var o = t.dataToRadius(i[0]), a = r.dataToAngle(i[1]), s = e.coordToPoint([o, a]);
        return s.push(o, a * Math.PI / 180), s;
      },
      size: ke(uMe, e)
    }
  };
}
function dMe(e) {
  var t = e.getRect(), r = e.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height,
      cellWidth: e.getCellWidth(),
      cellHeight: e.getCellHeight(),
      rangeInfo: {
        start: r.start,
        end: r.end,
        weeks: r.weeks,
        dayCount: r.allDay
      }
    },
    api: {
      coord: function(n, i) {
        return e.dataToPoint(n, i);
      }
    }
  };
}
var CB = {};
function Bj(e, t, r, n) {
  return e && (e.legacy || e.legacy !== !1 && !r && !n && t !== "tspan" && (t === "text" || Be(e, "text")));
}
function Gj(e, t, r) {
  var n = e, i, o, a;
  if (t === "text")
    a = n;
  else {
    a = {}, Be(n, "text") && (a.text = n.text), Be(n, "rich") && (a.rich = n.rich), Be(n, "textFill") && (a.fill = n.textFill), Be(n, "textStroke") && (a.stroke = n.textStroke), Be(n, "fontFamily") && (a.fontFamily = n.fontFamily), Be(n, "fontSize") && (a.fontSize = n.fontSize), Be(n, "fontStyle") && (a.fontStyle = n.fontStyle), Be(n, "fontWeight") && (a.fontWeight = n.fontWeight), o = {
      type: "text",
      style: a,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, i = {};
    var s = Be(n, "textPosition");
    r ? i.position = s ? n.textPosition : "inside" : s && (i.position = n.textPosition), Be(n, "textPosition") && (i.position = n.textPosition), Be(n, "textOffset") && (i.offset = n.textOffset), Be(n, "textRotation") && (i.rotation = n.textRotation), Be(n, "textDistance") && (i.distance = n.textDistance);
  }
  return SB(a, e), B(a.rich, function(l) {
    SB(l, l);
  }), {
    textConfig: i,
    textContent: o
  };
}
function SB(e, t) {
  t && (t.font = t.textFont || t.font, Be(t, "textStrokeWidth") && (e.lineWidth = t.textStrokeWidth), Be(t, "textAlign") && (e.align = t.textAlign), Be(t, "textVerticalAlign") && (e.verticalAlign = t.textVerticalAlign), Be(t, "textLineHeight") && (e.lineHeight = t.textLineHeight), Be(t, "textWidth") && (e.width = t.textWidth), Be(t, "textHeight") && (e.height = t.textHeight), Be(t, "textBackgroundColor") && (e.backgroundColor = t.textBackgroundColor), Be(t, "textPadding") && (e.padding = t.textPadding), Be(t, "textBorderColor") && (e.borderColor = t.textBorderColor), Be(t, "textBorderWidth") && (e.borderWidth = t.textBorderWidth), Be(t, "textBorderRadius") && (e.borderRadius = t.textBorderRadius), Be(t, "textBoxShadowColor") && (e.shadowColor = t.textBoxShadowColor), Be(t, "textBoxShadowBlur") && (e.shadowBlur = t.textBoxShadowBlur), Be(t, "textBoxShadowOffsetX") && (e.shadowOffsetX = t.textBoxShadowOffsetX), Be(t, "textBoxShadowOffsetY") && (e.shadowOffsetY = t.textBoxShadowOffsetY));
}
function wB(e, t, r) {
  var n = e;
  n.textPosition = n.textPosition || r.position || "inside", r.offset != null && (n.textOffset = r.offset), r.rotation != null && (n.textRotation = r.rotation), r.distance != null && (n.textDistance = r.distance);
  var i = n.textPosition.indexOf("inside") >= 0, o = e.fill || "#000";
  bB(n, t);
  var a = n.textFill == null;
  return i ? a && (n.textFill = r.insideFill || "#fff", !n.textStroke && r.insideStroke && (n.textStroke = r.insideStroke), !n.textStroke && (n.textStroke = o), n.textStrokeWidth == null && (n.textStrokeWidth = 2)) : (a && (n.textFill = e.fill || r.outsideFill || "#000"), !n.textStroke && r.outsideStroke && (n.textStroke = r.outsideStroke)), n.text = t.text, n.rich = t.rich, B(t.rich, function(s) {
    bB(s, s);
  }), n;
}
function bB(e, t) {
  t && (Be(t, "fill") && (e.textFill = t.fill), Be(t, "stroke") && (e.textStroke = t.fill), Be(t, "lineWidth") && (e.textStrokeWidth = t.lineWidth), Be(t, "font") && (e.font = t.font), Be(t, "fontStyle") && (e.fontStyle = t.fontStyle), Be(t, "fontWeight") && (e.fontWeight = t.fontWeight), Be(t, "fontSize") && (e.fontSize = t.fontSize), Be(t, "fontFamily") && (e.fontFamily = t.fontFamily), Be(t, "align") && (e.textAlign = t.align), Be(t, "verticalAlign") && (e.textVerticalAlign = t.verticalAlign), Be(t, "lineHeight") && (e.textLineHeight = t.lineHeight), Be(t, "width") && (e.textWidth = t.width), Be(t, "height") && (e.textHeight = t.height), Be(t, "backgroundColor") && (e.textBackgroundColor = t.backgroundColor), Be(t, "padding") && (e.textPadding = t.padding), Be(t, "borderColor") && (e.textBorderColor = t.borderColor), Be(t, "borderWidth") && (e.textBorderWidth = t.borderWidth), Be(t, "borderRadius") && (e.textBorderRadius = t.borderRadius), Be(t, "shadowColor") && (e.textBoxShadowColor = t.shadowColor), Be(t, "shadowBlur") && (e.textBoxShadowBlur = t.shadowBlur), Be(t, "shadowOffsetX") && (e.textBoxShadowOffsetX = t.shadowOffsetX), Be(t, "shadowOffsetY") && (e.textBoxShadowOffsetY = t.shadowOffsetY), Be(t, "textShadowColor") && (e.textShadowColor = t.textShadowColor), Be(t, "textShadowBlur") && (e.textShadowBlur = t.textShadowBlur), Be(t, "textShadowOffsetX") && (e.textShadowOffsetX = t.textShadowOffsetX), Be(t, "textShadowOffsetY") && (e.textShadowOffsetY = t.textShadowOffsetY));
}
function xB(e, t) {
  if (process.env.NODE_ENV !== "production") {
    var r = e + "^_^" + t;
    CB[r] || (console.warn('[ECharts] DEPRECATED: "' + e + '" has been deprecated. ' + t), CB[r] = !0);
  }
}
var Hj = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, EB = At(Hj), RC = Oo(Qa, function(e, t) {
  return e[t] = 1, e;
}, {}), RB = Qa.join(", "), _C = ["", "style", "shape", "extra"], Gh = Gt();
function GD(e, t, r, n, i) {
  var o = e + "Animation", a = sf(e, n, i) || {}, s = Gh(t).userDuring;
  return a.duration > 0 && (a.during = s ? ke(vMe, {
    el: t,
    userDuring: s
  }) : null, a.setToFinal = !0, a.scope = e), se(a, r[o]), a;
}
function u0(e, t, r, n) {
  n = n || {};
  var i = n.dataIndex, o = n.isInit, a = n.clearStyle, s = r.isAnimationEnabled(), l = Gh(e), u = t.style;
  l.userDuring = t.during;
  var c = {}, d = {};
  if (yMe(e, t, d), TB("shape", t, d), TB("extra", t, d), !o && s && (mMe(e, t, c), _B("shape", e, t, c), _B("extra", e, t, c), CMe(e, t, u, c)), d.style = u, hMe(e, d, a), pMe(e, t), s)
    if (o) {
      var h = {};
      B(_C, function(p) {
        var g = p ? t[p] : t;
        g && g.enterFrom && (p && (h[p] = h[p] || {}), se(p ? h[p] : h, g.enterFrom));
      });
      var f = GD("enter", e, t, r, i);
      f.duration > 0 && e.animateFrom(h, f);
    } else
      fMe(e, t, i || 0, r, c);
  zj(e, t), u ? e.dirty() : e.markRedraw();
}
function zj(e, t) {
  for (var r = Gh(e).leaveToProps, n = 0; n < _C.length; n++) {
    var i = _C[n], o = i ? t[i] : t;
    o && o.leaveTo && (r || (r = Gh(e).leaveToProps = {}), i && (r[i] = r[i] || {}), se(i ? r[i] : r, o.leaveTo));
  }
}
function cw(e, t, r, n) {
  if (e) {
    var i = e.parent, o = Gh(e).leaveToProps;
    if (o) {
      var a = GD("update", e, t, r, 0);
      a.done = function() {
        i.remove(e);
      }, e.animateTo(o, a);
    } else
      i.remove(e);
  }
}
function mc(e) {
  return e === "all";
}
function hMe(e, t, r) {
  var n = t.style;
  if (!e.isGroup && n) {
    if (r) {
      e.useStyle({});
      for (var i = e.animators, o = 0; o < i.length; o++) {
        var a = i[o];
        a.targetName === "style" && a.changeTarget(e.style);
      }
    }
    e.setStyle(n);
  }
  t && (t.style = null, t && e.attr(t), t.style = n);
}
function fMe(e, t, r, n, i) {
  if (i) {
    var o = GD("update", e, t, n, r);
    o.duration > 0 && e.animateFrom(i, o);
  }
}
function pMe(e, t) {
  Be(t, "silent") && (e.silent = t.silent), Be(t, "ignore") && (e.ignore = t.ignore), e instanceof ko && Be(t, "invisible") && (e.invisible = t.invisible), e instanceof Mt && Be(t, "autoBatch") && (e.autoBatch = t.autoBatch);
}
var La = {}, gMe = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(e, t) {
    return process.env.NODE_ENV !== "production" && Qe(Be(RC, e), "Only " + RB + " available in `setTransform`."), La.el[e] = t, this;
  },
  getTransform: function(e) {
    return process.env.NODE_ENV !== "production" && Qe(Be(RC, e), "Only " + RB + " available in `getTransform`."), La.el[e];
  },
  setShape: function(e, t) {
    process.env.NODE_ENV !== "production" && Od(e);
    var r = La.el, n = r.shape || (r.shape = {});
    return n[e] = t, r.dirtyShape && r.dirtyShape(), this;
  },
  getShape: function(e) {
    process.env.NODE_ENV !== "production" && Od(e);
    var t = La.el.shape;
    if (t)
      return t[e];
  },
  setStyle: function(e, t) {
    process.env.NODE_ENV !== "production" && Od(e);
    var r = La.el, n = r.style;
    return n && (process.env.NODE_ENV !== "production" && $l(t) && Vr("style." + e + " must not be assigned with NaN."), n[e] = t, r.dirtyStyle && r.dirtyStyle()), this;
  },
  getStyle: function(e) {
    process.env.NODE_ENV !== "production" && Od(e);
    var t = La.el.style;
    if (t)
      return t[e];
  },
  setExtra: function(e, t) {
    process.env.NODE_ENV !== "production" && Od(e);
    var r = La.el.extra || (La.el.extra = {});
    return r[e] = t, this;
  },
  getExtra: function(e) {
    process.env.NODE_ENV !== "production" && Od(e);
    var t = La.el.extra;
    if (t)
      return t[e];
  }
};
function Od(e) {
  if (process.env.NODE_ENV !== "production" && (e === "transition" || e === "enterFrom" || e === "leaveTo"))
    throw new Error('key must not be "' + e + '"');
}
function vMe() {
  var e = this, t = e.el;
  if (t) {
    var r = Gh(t).userDuring, n = e.userDuring;
    if (r !== n) {
      e.el = e.userDuring = null;
      return;
    }
    La.el = t, n(gMe);
  }
}
function _B(e, t, r, n) {
  var i = r[e];
  if (i) {
    var o = t[e], a;
    if (o) {
      var s = r.transition, l = i.transition;
      if (l)
        if (!a && (a = n[e] = {}), mc(l))
          se(a, o);
        else
          for (var u = dr(l), c = 0; c < u.length; c++) {
            var d = u[c], h = o[d];
            a[d] = h;
          }
      else if (mc(s) || bt(s, e) >= 0) {
        !a && (a = n[e] = {});
        for (var f = At(o), c = 0; c < f.length; c++) {
          var d = f[c], h = o[d];
          SMe(i[d], h) && (a[d] = h);
        }
      }
    }
  }
}
function TB(e, t, r) {
  var n = t[e];
  if (n)
    for (var i = r[e] = {}, o = At(n), a = 0; a < o.length; a++) {
      var s = o[a];
      i[s] = Xp(n[s]);
    }
}
function mMe(e, t, r) {
  for (var n = t.transition, i = mc(n) ? Qa : dr(n || []), o = 0; o < i.length; o++) {
    var a = i[o];
    if (!(a === "style" || a === "shape" || a === "extra")) {
      var s = e[a];
      process.env.NODE_ENV !== "production" && $j(a, "el.transition"), r[a] = s;
    }
  }
}
function yMe(e, t, r) {
  for (var n = 0; n < EB.length; n++) {
    var i = EB[n], o = Hj[i], a = t[i];
    a && (r[o[0]] = a[0], r[o[1]] = a[1]);
  }
  for (var n = 0; n < Qa.length; n++) {
    var s = Qa[n];
    t[s] != null && (r[s] = t[s]);
  }
}
function CMe(e, t, r, n) {
  if (r) {
    var i = e.style, o;
    if (i) {
      var a = r.transition, s = t.transition;
      if (a && !mc(a)) {
        var l = dr(a);
        !o && (o = n.style = {});
        for (var u = 0; u < l.length; u++) {
          var c = l[u], d = i[c];
          o[c] = d;
        }
      } else if (e.getAnimationStyleProps && (mc(s) || mc(a) || bt(s, "style") >= 0)) {
        var h = e.getAnimationStyleProps(), f = h ? h.style : null;
        if (f) {
          !o && (o = n.style = {});
          for (var p = At(r), u = 0; u < p.length; u++) {
            var c = p[u];
            if (f[c]) {
              var d = i[c];
              o[c] = d;
            }
          }
        }
      }
    }
  }
}
function SMe(e, t) {
  return kn(e) ? e !== t : e != null && isFinite(e);
}
var $j;
process.env.NODE_ENV !== "production" && ($j = function(e, t) {
  Be(RC, e) || Vr("Prop `" + e + "` is not a permitted in `" + t + "`. Only `" + At(RC).join("`, `") + "` are permitted.");
});
var Wj = Gt(), wMe = ["percent", "easing", "shape", "style", "extra"];
function jj(e) {
  e.stopAnimation("keyframe"), e.attr(Wj(e));
}
function TC(e, t, r) {
  if (!(!r.isAnimationEnabled() || !t)) {
    if (fe(t)) {
      B(t, function(s) {
        TC(e, s, r);
      });
      return;
    }
    var n = t.keyframes, i = t.duration;
    if (r && i == null) {
      var o = sf("enter", r, 0);
      i = o && o.duration;
    }
    if (!(!n || !i)) {
      var a = Wj(e);
      B(_C, function(s) {
        if (!(s && !e[s])) {
          var l, u = !1;
          n.sort(function(c, d) {
            return c.percent - d.percent;
          }), B(n, function(c) {
            var d = e.animators, h = s ? c[s] : c;
            if (process.env.NODE_ENV !== "production" && c.percent >= 1 && (u = !0), !!h) {
              var f = At(h);
              if (s || (f = ir(f, function(v) {
                return bt(wMe, v) < 0;
              })), !!f.length) {
                l || (l = e.animate(s, t.loop, !0), l.scope = "keyframe");
                for (var p = 0; p < d.length; p++)
                  d[p] !== l && d[p].targetName === l.targetName && d[p].stopTracks(f);
                s && (a[s] = a[s] || {});
                var g = s ? a[s] : a;
                B(f, function(v) {
                  g[v] = ((s ? e[s] : e) || {})[v];
                }), l.whenWithKeys(i * c.percent, h, f, c.easing);
              }
            }
          }), l && (process.env.NODE_ENV !== "production" && (u || Vr("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), l.delay(t.delay || 0).duration(i).start(t.easing));
        }
      });
    }
  }
}
var Fs = "emphasis", Ml = "normal", HD = "blur", zD = "select", ql = [Ml, Fs, HD, zD], vx = {
  normal: ["itemStyle"],
  emphasis: [Fs, "itemStyle"],
  blur: [HD, "itemStyle"],
  select: [zD, "itemStyle"]
}, mx = {
  normal: ["label"],
  emphasis: [Fs, "label"],
  blur: [HD, "label"],
  select: [zD, "label"]
}, bMe = ["x", "y"], xMe = "e\0\0", go = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, PB = {
  cartesian2d: iMe,
  geo: aMe,
  single: lMe,
  polar: cMe,
  calendar: dMe
};
function PC(e) {
  return e instanceof Mt;
}
function Q_(e) {
  return e instanceof ko;
}
function EMe(e, t) {
  t.copyTransform(e), Q_(t) && Q_(e) && (t.setStyle(e.style), t.z = e.z, t.z2 = e.z2, t.zlevel = e.zlevel, t.invisible = e.invisible, t.ignore = e.ignore, PC(t) && PC(e) && t.setShape(e.shape));
}
var RMe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this._progressiveEls = null;
      var a = this._data, s = r.getData(), l = this.group, u = MB(r, s, n, i);
      a || l.removeAll(), s.diff(a).add(function(d) {
        yx(i, null, d, u(d, o), r, l, s);
      }).remove(function(d) {
        var h = a.getItemGraphicEl(d);
        h && cw(h, Is(h).option, r);
      }).update(function(d, h) {
        var f = a.getItemGraphicEl(h);
        yx(i, f, d, u(d, o), r, l, s);
      }).execute();
      var c = r.get("clip", !0) ? Bv(r.coordinateSystem, !1, r) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = s;
    }, t.prototype.incrementalPrepareRender = function(r, n, i) {
      this.group.removeAll(), this._data = null;
    }, t.prototype.incrementalRender = function(r, n, i, o, a) {
      var s = n.getData(), l = MB(n, s, i, o), u = this._progressiveEls = [];
      function c(f) {
        f.isGroup || (f.incremental = !0, f.ensureState("emphasis").hoverLayer = !0);
      }
      for (var d = r.start; d < r.end; d++) {
        var h = yx(null, null, d, l(d, a), n, this.group, s);
        h && (h.traverse(c), u.push(h));
      }
    }, t.prototype.eachRendered = function(r) {
      iu(this._progressiveEls || this.group, r);
    }, t.prototype.filterForExposedEvent = function(r, n, i, o) {
      var a = n.element;
      if (a == null || i.name === a)
        return !0;
      for (; (i = i.__hostTarget || i.parent) && i !== this.group; )
        if (i.name === a)
          return !0;
      return !1;
    }, t.type = "custom", t;
  }(ar)
);
function $D(e) {
  var t = e.type, r;
  if (t === "path") {
    var n = e.shape, i = n.width != null && n.height != null ? {
      x: n.x || 0,
      y: n.y || 0,
      width: n.width,
      height: n.height
    } : null, o = Yj(n);
    r = Iv(o, null, i, n.layout || "center"), Is(r).customPathData = o;
  } else if (t === "image")
    r = new In({}), Is(r).customImagePath = e.style.image;
  else if (t === "text")
    r = new Vt({});
  else if (t === "group")
    r = new it();
  else {
    if (t === "compoundPath")
      throw new Error('"compoundPath" is not supported yet.');
    var a = GS(t);
    if (!a) {
      var s = "";
      process.env.NODE_ENV !== "production" && (s = 'graphic type "' + t + '" can not be found.'), er(s);
    }
    r = new a();
  }
  return Is(r).customGraphicType = t, r.name = e.name, r.z2EmphasisLift = 1, r.z2SelectLift = 1, r;
}
function WD(e, t, r, n, i, o, a) {
  jj(t);
  var s = i && i.normal.cfg;
  s && t.setTextConfig(s), n && n.transition == null && (n.transition = bMe);
  var l = n && n.style;
  if (l) {
    if (t.type === "text") {
      var u = l;
      Be(u, "textFill") && (u.fill = u.textFill), Be(u, "textStroke") && (u.stroke = u.textStroke);
    }
    var c = void 0, d = PC(t) ? l.decal : null;
    e && d && (d.dirty = !0, c = Nh(d, e)), l.__decalPattern = c;
  }
  if (Q_(t) && l) {
    var c = l.__decalPattern;
    c && (l.decal = c);
  }
  u0(t, n, o, {
    dataIndex: r,
    isInit: a,
    clearStyle: !0
  }), TC(t, n.keyframeAnimation, o);
}
function Uj(e, t, r, n, i) {
  var o = t.isGroup ? null : t, a = i && i[e].cfg;
  if (o) {
    var s = o.ensureState(e);
    if (n === !1) {
      var l = o.getState(e);
      l && (l.style = null);
    } else
      s.style = n || null;
    a && (s.textConfig = a), Dc(o);
  }
}
function _Me(e, t, r) {
  if (!e.isGroup) {
    var n = e, i = r.currentZ, o = r.currentZLevel;
    n.z = i, n.zlevel = o;
    var a = t.z2;
    a != null && (n.z2 = a || 0);
    for (var s = 0; s < ql.length; s++)
      TMe(n, t, ql[s]);
  }
}
function TMe(e, t, r) {
  var n = r === Ml, i = n ? t : MC(t, r), o = i ? i.z2 : null, a;
  o != null && (a = n ? e : e.ensureState(r), a.z2 = o || 0);
}
function MB(e, t, r, n) {
  var i = e.get("renderItem"), o = e.coordinateSystem, a = {};
  o && (process.env.NODE_ENV !== "production" && (Qe(i, "series.render is required."), Qe(o.prepareCustoms || PB[o.type], "This coordSys does not support custom series.")), a = o.prepareCustoms ? o.prepareCustoms(o) : PB[o.type](o));
  for (var s = Xe({
    getWidth: n.getWidth,
    getHeight: n.getHeight,
    getZr: n.getZr,
    getDevicePixelRatio: n.getDevicePixelRatio,
    value: S,
    style: w,
    ordinalRawValue: b,
    styleEmphasis: x,
    visual: _,
    barLayout: P,
    currentSeriesIndices: D,
    font: I
  }, a.api || {}), l = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: e.id,
    seriesName: e.name,
    seriesIndex: e.seriesIndex,
    coordSys: a.coordSys,
    dataInsideLength: t.count(),
    encode: PMe(e.getData())
  }, u, c, d = {}, h = {}, f = {}, p = {}, g = 0; g < ql.length; g++) {
    var v = ql[g];
    f[v] = e.getModel(vx[v]), p[v] = e.getModel(mx[v]);
  }
  function m(A) {
    return A === u ? c || (c = t.getItemModel(A)) : t.getItemModel(A);
  }
  function y(A, O) {
    return t.hasItemOption ? A === u ? d[O] || (d[O] = m(A).getModel(vx[O])) : m(A).getModel(vx[O]) : f[O];
  }
  function C(A, O) {
    return t.hasItemOption ? A === u ? h[O] || (h[O] = m(A).getModel(mx[O])) : m(A).getModel(mx[O]) : p[O];
  }
  return function(A, O) {
    return u = A, c = null, d = {}, h = {}, i && i(Xe({
      dataIndexInside: A,
      dataIndex: t.getRawIndex(A),
      // Can be used for optimization when zoom or roam.
      actionType: O ? O.type : null
    }, l), s);
  };
  function S(A, O) {
    return O == null && (O = u), t.getStore().get(t.getDimensionIndex(A || 0), O);
  }
  function b(A, O) {
    O == null && (O = u), A = A || 0;
    var L = t.getDimensionInfo(A);
    if (!L) {
      var N = t.getDimensionIndex(A);
      return N >= 0 ? t.getStore().get(N, O) : void 0;
    }
    var F = t.get(L.name, O), G = L && L.ordinalMeta;
    return G ? G.categories[F] : F;
  }
  function w(A, O) {
    process.env.NODE_ENV !== "production" && xB("api.style", "Please write literal style directly instead."), O == null && (O = u);
    var L = t.getItemVisual(O, "style"), N = L && L.fill, F = L && L.opacity, G = y(O, Ml).getItemStyle();
    N != null && (G.fill = N), F != null && (G.opacity = F);
    var M = {
      inheritColor: Fe(N) ? N : "#000"
    }, V = C(O, Ml), z = br(V, null, M, !1, !0);
    z.text = V.getShallow("show") ? st(e.getFormattedLabel(O, Ml), kh(t, O)) : null;
    var k = J0(V, M, !1);
    return R(A, G), G = wB(G, z, k), A && E(G, A), G.legacy = !0, G;
  }
  function x(A, O) {
    process.env.NODE_ENV !== "production" && xB("api.styleEmphasis", "Please write literal style directly instead."), O == null && (O = u);
    var L = y(O, Fs).getItemStyle(), N = C(O, Fs), F = br(N, null, null, !0, !0);
    F.text = N.getShallow("show") ? ro(e.getFormattedLabel(O, Fs), e.getFormattedLabel(O, Ml), kh(t, O)) : null;
    var G = J0(N, null, !0);
    return R(A, L), L = wB(L, F, G), A && E(L, A), L.legacy = !0, L;
  }
  function E(A, O) {
    for (var L in O)
      Be(O, L) && (A[L] = O[L]);
  }
  function R(A, O) {
    A && (A.textFill && (O.textFill = A.textFill), A.textPosition && (O.textPosition = A.textPosition));
  }
  function _(A, O) {
    if (O == null && (O = u), Be(yB, A)) {
      var L = t.getItemVisual(O, "style");
      return L ? L[yB[A]] : null;
    }
    if (Be(tMe, A))
      return t.getItemVisual(O, A);
  }
  function P(A) {
    if (o.type === "cartesian2d") {
      var O = o.getBaseAxis();
      return nwe(Xe({
        axis: O
      }, A));
    }
  }
  function D() {
    return r.getCurrentSeriesIndices();
  }
  function I(A) {
    return EM(A, r);
  }
}
function PMe(e) {
  var t = {};
  return B(e.dimensions, function(r) {
    var n = e.getDimensionInfo(r);
    if (!n.isExtraCoord) {
      var i = n.coordDim, o = t[i] = t[i] || [];
      o[n.coordDimIndex] = e.getDimensionIndex(r);
    }
  }), t;
}
function yx(e, t, r, n, i, o, a) {
  if (!n) {
    o.remove(t);
    return;
  }
  var s = jD(e, t, r, n, i, o);
  return s && a.setItemGraphicEl(r, s), s && Hr(s, n.focus, n.blurScope, n.emphasisDisabled), s;
}
function jD(e, t, r, n, i, o) {
  process.env.NODE_ENV !== "production" && Qe(n, "should not have an null/undefined element setting");
  var a = -1, s = t;
  t && Kj(t, n, i) && (a = bt(o.childrenRef(), t), t = null);
  var l = !t, u = t;
  u ? u.clearStates() : (u = $D(n), s && EMe(s, u)), n.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), go.normal.cfg = go.normal.conOpt = go.emphasis.cfg = go.emphasis.conOpt = go.blur.cfg = go.blur.conOpt = go.select.cfg = go.select.conOpt = null, go.isLegacy = !1, DMe(u, r, n, i, l, go), MMe(u, r, n, i, l), WD(e, u, r, n, go, i, l), Be(n, "info") && (Is(u).info = n.info);
  for (var c = 0; c < ql.length; c++) {
    var d = ql[c];
    if (d !== Ml) {
      var h = MC(n, d), f = UD(n, h, d);
      Uj(d, u, h, f, go);
    }
  }
  return _Me(u, n, i), n.type === "group" && AMe(e, u, r, n, i), a >= 0 ? o.replaceAt(u, a) : o.add(u), u;
}
function Kj(e, t, r) {
  var n = Is(e), i = t.type, o = t.shape, a = t.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    r.isUniversalTransitionEnabled() || i != null && i !== n.customGraphicType || i === "path" && OMe(o) && Yj(o) !== n.customPathData || i === "image" && Be(a, "image") && a.image !== n.customImagePath
  );
}
function MMe(e, t, r, n, i) {
  var o = r.clipPath;
  if (o === !1)
    e && e.getClipPath() && e.removeClipPath();
  else if (o) {
    var a = e.getClipPath();
    a && Kj(a, o, n) && (a = null), a || (a = $D(o), process.env.NODE_ENV !== "production" && Qe(PC(a), "Only any type of `path` can be used in `clipPath`, rather than " + a.type + "."), e.setClipPath(a)), WD(null, a, t, o, null, n, i);
  }
}
function DMe(e, t, r, n, i, o) {
  if (!e.isGroup) {
    DB(r, null, o), DB(r, Fs, o);
    var a = o.normal.conOpt, s = o.emphasis.conOpt, l = o.blur.conOpt, u = o.select.conOpt;
    if (a != null || s != null || u != null || l != null) {
      var c = e.getTextContent();
      if (a === !1)
        c && e.removeTextContent();
      else {
        a = o.normal.conOpt = a || {
          type: "text"
        }, c ? c.clearStates() : (c = $D(a), e.setTextContent(c)), WD(null, c, t, a, null, n, i);
        for (var d = a && a.style, h = 0; h < ql.length; h++) {
          var f = ql[h];
          if (f !== Ml) {
            var p = o[f].conOpt;
            Uj(f, c, p, UD(a, p, f), null);
          }
        }
        d ? c.dirty() : c.markRedraw();
      }
    }
  }
}
function DB(e, t, r) {
  var n = t ? MC(e, t) : e, i = t ? UD(e, n, Fs) : e.style, o = e.type, a = n ? n.textConfig : null, s = e.textContent, l = s ? t ? MC(s, t) : s : null;
  if (i && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (r.isLegacy || Bj(i, o, !!a, !!l))) {
    r.isLegacy = !0;
    var u = Gj(i, o, !t);
    !a && u.textConfig && (a = u.textConfig), !l && u.textContent && (l = u.textContent);
  }
  if (!t && l) {
    var c = l;
    !c.type && (c.type = "text"), process.env.NODE_ENV !== "production" && Qe(c.type === "text", 'textContent.type must be "text"');
  }
  var d = t ? r[t] : r.normal;
  d.cfg = a, d.conOpt = l;
}
function MC(e, t) {
  return t ? e ? e[t] : null : e;
}
function UD(e, t, r) {
  var n = t && t.style;
  return n == null && r === Fs && e && (n = e.styleEmphasis), n;
}
function AMe(e, t, r, n, i) {
  var o = n.children, a = o ? o.length : 0, s = n.$mergeChildren, l = s === "byName" || n.diffChildrenByName, u = s === !1;
  if (!(!a && !l && !u)) {
    if (l) {
      FMe({
        api: e,
        oldChildren: t.children() || [],
        newChildren: o || [],
        dataIndex: r,
        seriesModel: i,
        group: t
      });
      return;
    }
    u && t.removeAll();
    for (var c = 0; c < a; c++) {
      var d = o[c], h = t.childAt(c);
      d ? (d.ignore == null && (d.ignore = !1), jD(e, h, r, d, i, t)) : (process.env.NODE_ENV !== "production" && Qe(h, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), h.ignore = !0);
    }
    for (var f = t.childCount() - 1; f >= c; f--) {
      var p = t.childAt(f);
      IMe(t, p, i);
    }
  }
}
function IMe(e, t, r) {
  t && cw(t, Is(e).option, r);
}
function FMe(e) {
  new Ws(e.oldChildren, e.newChildren, AB, AB, e).add(IB).update(IB).remove(LMe).execute();
}
function AB(e, t) {
  var r = e && e.name;
  return r ?? xMe + t;
}
function IB(e, t) {
  var r = this.context, n = e != null ? r.newChildren[e] : null, i = t != null ? r.oldChildren[t] : null;
  jD(r.api, i, r.dataIndex, n, r.seriesModel, r.group);
}
function LMe(e) {
  var t = this.context, r = t.oldChildren[e];
  r && cw(r, Is(r).option, t.seriesModel);
}
function Yj(e) {
  return e && (e.pathData || e.d);
}
function OMe(e) {
  return e && (Be(e, "pathData") || Be(e, "d"));
}
function NMe(e) {
  e.registerChartView(RMe), e.registerSeriesModel(rMe);
}
var Yu = Gt(), FB = et, Cx = ke, KD = (
  /** @class */
  function() {
    function e() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return e.prototype.render = function(t, r, n, i) {
      var o = r.get("value"), a = r.get("status");
      if (this._axisModel = t, this._axisPointerModel = r, this._api = n, !(!i && this._lastValue === o && this._lastStatus === a)) {
        this._lastValue = o, this._lastStatus = a;
        var s = this._group, l = this._handle;
        if (!a || a === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, o, t, r, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var d = this._moveAnimation = this.determineAnimation(t, r);
        if (!s)
          s = this._group = new it(), this.createPointerEl(s, u, t, r), this.createLabelEl(s, u, t, r), n.getZr().add(s);
        else {
          var h = dt(LB, r, d);
          this.updatePointerEl(s, u, h), this.updateLabelEl(s, u, h, r);
        }
        NB(s, r, !0), this._renderHandle(o);
      }
    }, e.prototype.remove = function(t) {
      this.clear(t);
    }, e.prototype.dispose = function(t) {
      this.clear(t);
    }, e.prototype.determineAnimation = function(t, r) {
      var n = r.get("animation"), i = t.axis, o = i.type === "category", a = r.get("snap");
      if (!a && !o)
        return !1;
      if (n === "auto" || n == null) {
        var s = this.animationThreshold;
        if (o && i.getBandWidth() > s)
          return !0;
        if (a) {
          var l = mD(t).seriesDataCount, u = i.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return n === !0;
    }, e.prototype.makeElOption = function(t, r, n, i, o) {
    }, e.prototype.createPointerEl = function(t, r, n, i) {
      var o = r.pointer;
      if (o) {
        var a = Yu(t).pointerEl = new jc[o.type](FB(r.pointer));
        t.add(a);
      }
    }, e.prototype.createLabelEl = function(t, r, n, i) {
      if (r.label) {
        var o = Yu(t).labelEl = new Vt(FB(r.label));
        t.add(o), OB(o, i);
      }
    }, e.prototype.updatePointerEl = function(t, r, n) {
      var i = Yu(t).pointerEl;
      i && r.pointer && (i.setStyle(r.pointer.style), n(i, {
        shape: r.pointer.shape
      }));
    }, e.prototype.updateLabelEl = function(t, r, n, i) {
      var o = Yu(t).labelEl;
      o && (o.setStyle(r.label.style), n(o, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: r.label.x,
        y: r.label.y
      }), OB(o, i));
    }, e.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var r = this._axisPointerModel, n = this._api.getZr(), i = this._handle, o = r.getModel("handle"), a = r.get("status");
        if (!o.get("show") || !a || a === "hide") {
          i && n.remove(i), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, i = this._handle = lf(o.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Hs(u.event);
          },
          onmousedown: Cx(this._onHandleDragMove, this, 0, 0),
          drift: Cx(this._onHandleDragMove, this),
          ondragend: Cx(this._onHandleDragEnd, this)
        }), n.add(i)), NB(i, r, !1), i.setStyle(o.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = o.get("size");
        fe(l) || (l = [l, l]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, gf(this, "_doDispatchAxisPointer", o.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, s);
      }
    }, e.prototype._moveHandleToValue = function(t, r) {
      LB(this._axisPointerModel, !r && this._moveAnimation, this._handle, Sx(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, e.prototype._onHandleDragMove = function(t, r) {
      var n = this._handle;
      if (n) {
        this._dragging = !0;
        var i = this.updateHandleTransform(Sx(n), [t, r], this._axisModel, this._axisPointerModel);
        this._payloadInfo = i, n.stopAnimation(), n.attr(Sx(i)), Yu(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, e.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var r = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: r.cursorPoint[0],
          y: r.cursorPoint[1],
          tooltipOption: r.tooltipOption,
          axesInfo: [{
            axisDim: n.axis.dim,
            axisIndex: n.componentIndex
          }]
        });
      }
    }, e.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var t = this._handle;
      if (t) {
        var r = this._axisPointerModel.get("value");
        this._moveHandleToValue(r), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, e.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var r = t.getZr(), n = this._group, i = this._handle;
      r && n && (this._lastGraphicKey = null, n && r.remove(n), i && r.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), zg(this, "_doDispatchAxisPointer");
    }, e.prototype.doClear = function() {
    }, e.prototype.buildLabel = function(t, r, n) {
      return n = n || 0, {
        x: t[n],
        y: t[1 - n],
        width: r[n],
        height: r[1 - n]
      };
    }, e;
  }()
);
function LB(e, t, r, n) {
  qj(Yu(r).lastProp, n) || (Yu(r).lastProp = n, t ? jt(r, n, e) : (r.stopAnimation(), r.attr(n)));
}
function qj(e, t) {
  if (Ze(e) && Ze(t)) {
    var r = !0;
    return B(t, function(n, i) {
      r = r && qj(e[i], n);
    }), !!r;
  } else
    return e === t;
}
function OB(e, t) {
  e[t.get(["label", "show"]) ? "show" : "hide"]();
}
function Sx(e) {
  return {
    x: e.x || 0,
    y: e.y || 0,
    rotation: e.rotation || 0
  };
}
function NB(e, t, r) {
  var n = t.get("z"), i = t.get("zlevel");
  e && e.traverse(function(o) {
    o.type !== "group" && (n != null && (o.z = n), i != null && (o.zlevel = i), o.silent = r);
  });
}
function YD(e) {
  var t = e.get("type"), r = e.getModel(t + "Style"), n;
  return t === "line" ? (n = r.getLineStyle(), n.fill = null) : t === "shadow" && (n = r.getAreaStyle(), n.stroke = null), n;
}
function Zj(e, t, r, n, i) {
  var o = r.get("value"), a = Xj(o, t.axis, t.ecModel, r.get("seriesDataIndices"), {
    precision: r.get(["label", "precision"]),
    formatter: r.get(["label", "formatter"])
  }), s = r.getModel("label"), l = Kc(s.get("padding") || 0), u = s.getFont(), c = _v(a, u), d = i.position, h = c.width + l[1] + l[3], f = c.height + l[0] + l[2], p = i.align;
  p === "right" && (d[0] -= h), p === "center" && (d[0] -= h / 2);
  var g = i.verticalAlign;
  g === "bottom" && (d[1] -= f), g === "middle" && (d[1] -= f / 2), kMe(d, h, f, n);
  var v = s.get("backgroundColor");
  (!v || v === "auto") && (v = t.get(["axisLine", "lineStyle", "color"])), e.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: d[0],
    y: d[1],
    style: br(s, {
      text: a,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: v
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function kMe(e, t, r, n) {
  var i = n.getWidth(), o = n.getHeight();
  e[0] = Math.min(e[0] + t, i) - t, e[1] = Math.min(e[1] + r, o) - r, e[0] = Math.max(e[0], 0), e[1] = Math.max(e[1], 0);
}
function Xj(e, t, r, n, i) {
  e = t.scale.parse(e);
  var o = t.scale.getLabel({
    value: e
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: i.precision
  }), a = i.formatter;
  if (a) {
    var s = {
      value: aD(t, {
        value: e
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    };
    B(n, function(l) {
      var u = r.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, d = u && u.getDataParams(c);
      d && s.seriesData.push(d);
    }), Fe(a) ? o = a.replace("{value}", o) : Ye(a) && (o = a(s));
  }
  return o;
}
function qD(e, t, r) {
  var n = ki();
  return nu(n, n, r.rotation), ma(n, n, r.position), fa([e.dataToCoord(t), (r.labelOffset || 0) + (r.labelDirection || 1) * (r.labelMargin || 0)], n);
}
function Qj(e, t, r, n, i, o) {
  var a = Ci.innerTextLayout(r.rotation, 0, r.labelDirection);
  r.labelMargin = i.get(["label", "margin"]), Zj(t, n, i, o, {
    position: qD(n.axis, e, r),
    align: a.textAlign,
    verticalAlign: a.textVerticalAlign
  });
}
function ZD(e, t, r) {
  return r = r || 0, {
    x1: e[r],
    y1: e[1 - r],
    x2: t[r],
    y2: t[1 - r]
  };
}
function Jj(e, t, r) {
  return r = r || 0, {
    x: e[r],
    y: e[1 - r],
    width: t[r],
    height: t[1 - r]
  };
}
function kB(e, t, r, n, i, o) {
  return {
    cx: e,
    cy: t,
    r0: r,
    r: n,
    startAngle: i,
    endAngle: o,
    clockwise: !0
  };
}
var VMe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(r, n, i, o, a) {
      var s = i.axis, l = s.grid, u = o.get("type"), c = VB(l, s).getOtherAxis(s).getGlobalExtent(), d = s.toGlobalCoord(s.dataToCoord(n, !0));
      if (u && u !== "none") {
        var h = YD(o), f = BMe[u](s, d, c);
        f.style = h, r.graphicKey = f.type, r.pointer = f;
      }
      var p = L_(l.model, i);
      Qj(
        // @ts-ignore
        n,
        r,
        p,
        i,
        o,
        a
      );
    }, t.prototype.getHandleTransform = function(r, n, i) {
      var o = L_(n.axis.grid.model, n, {
        labelInside: !1
      });
      o.labelMargin = i.get(["handle", "margin"]);
      var a = qD(n.axis, r, o);
      return {
        x: a[0],
        y: a[1],
        rotation: o.rotation + (o.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(r, n, i, o) {
      var a = i.axis, s = a.grid, l = a.getGlobalExtent(!0), u = VB(s, a).getOtherAxis(a).getGlobalExtent(), c = a.dim === "x" ? 0 : 1, d = [r.x, r.y];
      d[c] += n[c], d[c] = Math.min(l[1], d[c]), d[c] = Math.max(l[0], d[c]);
      var h = (u[1] + u[0]) / 2, f = [h, h];
      f[c] = d[c];
      var p = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: d[0],
        y: d[1],
        rotation: r.rotation,
        cursorPoint: f,
        tooltipOption: p[c]
      };
    }, t;
  }(KD)
);
function VB(e, t) {
  var r = {};
  return r[t.dim + "AxisIndex"] = t.index, e.getCartesian(r);
}
var BMe = {
  line: function(e, t, r) {
    var n = ZD([t, r[0]], [t, r[1]], BB(e));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(e, t, r) {
    var n = Math.max(1, e.getBandWidth()), i = r[1] - r[0];
    return {
      type: "Rect",
      shape: Jj([t - n / 2, r[0]], [n, i], BB(e))
    };
  }
};
function BB(e) {
  return e.dim === "x" ? 0 : 1;
}
var GMe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "axisPointer", t.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }, t;
  }(Rt)
), Ps = Gt(), HMe = B;
function eU(e, t, r) {
  if (!kt.node) {
    var n = t.getZr();
    Ps(n).records || (Ps(n).records = {}), zMe(n, t);
    var i = Ps(n).records[e] || (Ps(n).records[e] = {});
    i.handler = r;
  }
}
function zMe(e, t) {
  if (Ps(e).initialized)
    return;
  Ps(e).initialized = !0, r("click", dt(GB, "click")), r("mousemove", dt(GB, "mousemove")), r("globalout", WMe);
  function r(n, i) {
    e.on(n, function(o) {
      var a = jMe(t);
      HMe(Ps(e).records, function(s) {
        s && i(s, o, a.dispatchAction);
      }), $Me(a.pendings, t);
    });
  }
}
function $Me(e, t) {
  var r = e.showTip.length, n = e.hideTip.length, i;
  r ? i = e.showTip[r - 1] : n && (i = e.hideTip[n - 1]), i && (i.dispatchAction = null, t.dispatchAction(i));
}
function WMe(e, t, r) {
  e.handler("leave", null, r);
}
function GB(e, t, r, n) {
  t.handler(e, r, n);
}
function jMe(e) {
  var t = {
    showTip: [],
    hideTip: []
  }, r = function(n) {
    var i = t[n.type];
    i ? i.push(n) : (n.dispatchAction = r, e.dispatchAction(n));
  };
  return {
    dispatchAction: r,
    pendings: t
  };
}
function J_(e, t) {
  if (!kt.node) {
    var r = t.getZr(), n = (Ps(r).records || {})[e];
    n && (Ps(r).records[e] = null);
  }
}
var UMe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = n.getComponent("tooltip"), a = r.get("triggerOn") || o && o.get("triggerOn") || "mousemove|click";
      eU("axisPointer", i, function(s, l, u) {
        a !== "none" && (s === "leave" || a.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(r, n) {
      J_("axisPointer", n);
    }, t.prototype.dispose = function(r, n) {
      J_("axisPointer", n);
    }, t.type = "axisPointer", t;
  }(Rr)
);
function tU(e, t) {
  var r = [], n = e.seriesIndex, i;
  if (n == null || !(i = t.getSeriesByIndex(n)))
    return {
      point: []
    };
  var o = i.getData(), a = Pc(o, e);
  if (a == null || a < 0 || fe(a))
    return {
      point: []
    };
  var s = o.getItemGraphicEl(a), l = i.coordinateSystem;
  if (i.getTooltipPosition)
    r = i.getTooltipPosition(a) || [];
  else if (l && l.dataToPoint)
    if (e.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), d = c.dim, h = u.dim, f = d === "x" || d === "radius" ? 1 : 0, p = o.mapDimension(h), g = [];
      g[f] = o.get(p, a), g[1 - f] = o.get(o.getCalculationInfo("stackResultDimension"), a), r = l.dataToPoint(g) || [];
    } else
      r = l.dataToPoint(o.getValues(ge(l.dimensions, function(m) {
        return o.mapDimension(m);
      }), a)) || [];
  else if (s) {
    var v = s.getBoundingRect().clone();
    v.applyTransform(s.transform), r = [v.x + v.width / 2, v.y + v.height / 2];
  }
  return {
    point: r,
    el: s
  };
}
var HB = Gt();
function KMe(e, t, r) {
  var n = e.currTrigger, i = [e.x, e.y], o = e, a = e.dispatchAction || ke(r.dispatchAction, r), s = t.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    c0(i) && (i = tU({
      seriesIndex: o.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: o.dataIndex
    }, t).point);
    var l = c0(i), u = o.axesInfo, c = s.axesInfo, d = n === "leave" || c0(i), h = {}, f = {}, p = {
      list: [],
      map: {}
    }, g = {
      showPointer: dt(qMe, f),
      showTooltip: dt(ZMe, p)
    };
    B(s.coordSysMap, function(m, y) {
      var C = l || m.containPoint(i);
      B(s.coordSysAxesInfo[y], function(S, b) {
        var w = S.axis, x = eDe(u, S);
        if (!d && C && (!u || x)) {
          var E = x && x.value;
          E == null && !l && (E = w.pointToData(i)), E != null && zB(S, E, g, !1, h);
        }
      });
    });
    var v = {};
    return B(c, function(m, y) {
      var C = m.linkGroup;
      C && !f[y] && B(C.axesInfo, function(S, b) {
        var w = f[b];
        if (S !== m && w) {
          var x = w.value;
          C.mapper && (x = m.axis.scale.parse(C.mapper(x, $B(S), $B(m)))), v[m.key] = x;
        }
      });
    }), B(v, function(m, y) {
      zB(c[y], m, g, !0, h);
    }), XMe(f, c, h), QMe(p, i, e, a), JMe(c, a, r), h;
  }
}
function zB(e, t, r, n, i) {
  var o = e.axis;
  if (!(o.scale.isBlank() || !o.containData(t))) {
    if (!e.involveSeries) {
      r.showPointer(e, t);
      return;
    }
    var a = YMe(t, e), s = a.payloadBatch, l = a.snapToValue;
    s[0] && i.seriesIndex == null && se(i, s[0]), !n && e.snap && o.containData(l) && l != null && (t = l), r.showPointer(e, t, s), r.showTooltip(e, a, l);
  }
}
function YMe(e, t) {
  var r = t.axis, n = r.dim, i = e, o = [], a = Number.MAX_VALUE, s = -1;
  return B(t.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(n), d, h;
    if (l.getAxisTooltipData) {
      var f = l.getAxisTooltipData(c, e, r);
      h = f.dataIndices, d = f.nestestValue;
    } else {
      if (h = l.getData().indicesOfNearest(
        c[0],
        e,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        r.type === "category" ? 0.5 : null
      ), !h.length)
        return;
      d = l.getData().get(c[0], h[0]);
    }
    if (!(d == null || !isFinite(d))) {
      var p = e - d, g = Math.abs(p);
      g <= a && ((g < a || p >= 0 && s < 0) && (a = g, s = p, i = d, o.length = 0), B(h, function(v) {
        o.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: v,
          dataIndex: l.getData().getRawIndex(v)
        });
      }));
    }
  }), {
    payloadBatch: o,
    snapToValue: i
  };
}
function qMe(e, t, r, n) {
  e[t.key] = {
    value: r,
    payloadBatch: n
  };
}
function ZMe(e, t, r, n) {
  var i = r.payloadBatch, o = t.axis, a = o.model, s = t.axisPointerModel;
  if (!(!t.triggerTooltip || !i.length)) {
    var l = t.coordSys.model, u = qg(l), c = e.map[u];
    c || (c = e.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, e.list.push(c)), c.dataByAxis.push({
      axisDim: o.dim,
      axisIndex: a.componentIndex,
      axisType: a.type,
      axisId: a.id,
      value: n,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: i.slice()
    });
  }
}
function XMe(e, t, r) {
  var n = r.axesInfo = [];
  B(t, function(i, o) {
    var a = i.axisPointerModel.option, s = e[o];
    s ? (!i.useHandle && (a.status = "show"), a.value = s.value, a.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (a.status = "hide"), a.status === "show" && n.push({
      axisDim: i.axis.dim,
      axisIndex: i.axis.model.componentIndex,
      value: a.value
    });
  });
}
function QMe(e, t, r, n) {
  if (c0(t) || !e.list.length) {
    n({
      type: "hideTip"
    });
    return;
  }
  var i = ((e.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  n({
    type: "showTip",
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: r.tooltipOption,
    position: r.position,
    dataIndexInside: i.dataIndexInside,
    dataIndex: i.dataIndex,
    seriesIndex: i.seriesIndex,
    dataByCoordSys: e.list
  });
}
function JMe(e, t, r) {
  var n = r.getZr(), i = "axisPointerLastHighlights", o = HB(n)[i] || {}, a = HB(n)[i] = {};
  B(e, function(u, c) {
    var d = u.axisPointerModel.option;
    d.status === "show" && u.triggerEmphasis && B(d.seriesDataIndices, function(h) {
      var f = h.seriesIndex + " | " + h.dataIndex;
      a[f] = h;
    });
  });
  var s = [], l = [];
  B(o, function(u, c) {
    !a[c] && l.push(u);
  }), B(a, function(u, c) {
    !o[c] && s.push(u);
  }), l.length && r.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && r.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function eDe(e, t) {
  for (var r = 0; r < (e || []).length; r++) {
    var n = e[r];
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n;
  }
}
function $B(e) {
  var t = e.axis.model, r = {}, n = r.axisDim = e.axis.dim;
  return r.axisIndex = r[n + "AxisIndex"] = t.componentIndex, r.axisName = r[n + "AxisName"] = t.name, r.axisId = r[n + "AxisId"] = t.id, r;
}
function c0(e) {
  return !e || e[0] == null || isNaN(e[0]) || e[1] == null || isNaN(e[1]);
}
function jv(e) {
  Xc.registerAxisPointerClass("CartesianAxisPointer", VMe), e.registerComponentModel(GMe), e.registerComponentView(UMe), e.registerPreprocessor(function(t) {
    if (t) {
      (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
      var r = t.axisPointer.link;
      r && !fe(r) && (t.axisPointer.link = [r]);
    }
  }), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, function(t, r) {
    t.getComponent("axisPointer").coordSysAxesInfo = dxe(t, r);
  }), e.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, KMe);
}
function tDe(e) {
  _t(T9), _t(jv);
}
var rDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(r, n, i, o, a) {
      var s = i.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), c = u.getExtent(), d = s.dataToCoord(n), h = o.get("type");
      if (h && h !== "none") {
        var f = YD(o), p = iDe[h](s, l, d, c);
        p.style = f, r.graphicKey = p.type, r.pointer = p;
      }
      var g = o.get(["label", "margin"]), v = nDe(n, i, o, l, g);
      Zj(r, i, o, a, v);
    }, t;
  }(KD)
);
function nDe(e, t, r, n, i) {
  var o = t.axis, a = o.dataToCoord(e), s = n.getAngleAxis().getExtent()[0];
  s = s / 180 * Math.PI;
  var l = n.getRadiusAxis().getExtent(), u, c, d;
  if (o.dim === "radius") {
    var h = ki();
    nu(h, h, s), ma(h, h, [n.cx, n.cy]), u = fa([a, -i], h);
    var f = t.getModel("axisLabel").get("rotate") || 0, p = Ci.innerTextLayout(s, f * Math.PI / 180, -1);
    c = p.textAlign, d = p.textVerticalAlign;
  } else {
    var g = l[1];
    u = n.coordToPoint([g + i, a]);
    var v = n.cx, m = n.cy;
    c = Math.abs(u[0] - v) / g < 0.3 ? "center" : u[0] > v ? "left" : "right", d = Math.abs(u[1] - m) / g < 0.3 ? "middle" : u[1] > m ? "top" : "bottom";
  }
  return {
    position: u,
    align: c,
    verticalAlign: d
  };
}
var iDe = {
  line: function(e, t, r, n) {
    return e.dim === "angle" ? {
      type: "Line",
      shape: ZD(t.coordToPoint([n[0], r]), t.coordToPoint([n[1], r]))
    } : {
      type: "Circle",
      shape: {
        cx: t.cx,
        cy: t.cy,
        r
      }
    };
  },
  shadow: function(e, t, r, n) {
    var i = Math.max(1, e.getBandWidth()), o = Math.PI / 180;
    return e.dim === "angle" ? {
      type: "Sector",
      shape: kB(
        t.cx,
        t.cy,
        n[0],
        n[1],
        // In ECharts y is negative if angle is positive
        (-r - i / 2) * o,
        (-r + i / 2) * o
      )
    } : {
      type: "Sector",
      shape: kB(t.cx, t.cy, r - i / 2, r + i / 2, 0, Math.PI * 2)
    };
  }
}, oDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.findAxisModel = function(r) {
      var n, i = this.ecModel;
      return i.eachComponent(r, function(o) {
        o.getCoordSysModel() === this && (n = o);
      }, this), n;
    }, t.type = "polar", t.dependencies = ["radiusAxis", "angleAxis"], t.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, t;
  }(Rt)
), XD = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", un).models[0];
    }, t.type = "polarAxis", t;
  }(Rt)
);
qr(XD, Cf);
var aDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "angleAxis", t;
  }(XD)
), sDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "radiusAxis", t;
  }(XD)
), QD = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n) {
      return e.call(this, "radius", r, n) || this;
    }
    return t.prototype.pointToData = function(r, n) {
      return this.polar.pointToData(r, n)[this.dim === "radius" ? 0 : 1];
    }, t;
  }(Wo)
);
QD.prototype.dataToRadius = Wo.prototype.dataToCoord;
QD.prototype.radiusToData = Wo.prototype.coordToData;
var lDe = Gt(), JD = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n) {
      return e.call(this, "angle", r, n || [0, 360]) || this;
    }
    return t.prototype.pointToData = function(r, n) {
      return this.polar.pointToData(r, n)[this.dim === "radius" ? 0 : 1];
    }, t.prototype.calculateCategoryInterval = function() {
      var r = this, n = r.getLabelModel(), i = r.scale, o = i.getExtent(), a = i.count();
      if (o[1] - o[0] < 1)
        return 0;
      var s = o[0], l = r.dataToCoord(s + 1) - r.dataToCoord(s), u = Math.abs(l), c = _v(s == null ? "" : s + "", n.getFont(), "center", "top"), d = Math.max(c.height, 7), h = d / u;
      isNaN(h) && (h = 1 / 0);
      var f = Math.max(0, Math.floor(h)), p = lDe(r.model), g = p.lastAutoInterval, v = p.lastTickCount;
      return g != null && v != null && Math.abs(g - f) <= 1 && Math.abs(v - a) <= 1 && g > f ? f = g : (p.lastTickCount = a, p.lastAutoInterval = f), f;
    }, t;
  }(Wo)
);
JD.prototype.dataToAngle = Wo.prototype.dataToCoord;
JD.prototype.angleToData = Wo.prototype.coordToData;
var rU = ["radius", "angle"], uDe = (
  /** @class */
  function() {
    function e(t) {
      this.dimensions = rU, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new QD(), this._angleAxis = new JD(), this.axisPointerEnabled = !0, this.name = t || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return e.prototype.containPoint = function(t) {
      var r = this.pointToCoord(t);
      return this._radiusAxis.contain(r[0]) && this._angleAxis.contain(r[1]);
    }, e.prototype.containData = function(t) {
      return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1]);
    }, e.prototype.getAxis = function(t) {
      var r = "_" + t + "Axis";
      return this[r];
    }, e.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, e.prototype.getAxesByScale = function(t) {
      var r = [], n = this._angleAxis, i = this._radiusAxis;
      return n.scale.type === t && r.push(n), i.scale.type === t && r.push(i), r;
    }, e.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, e.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, e.prototype.getOtherAxis = function(t) {
      var r = this._angleAxis;
      return t === r ? this._radiusAxis : r;
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, e.prototype.getTooltipAxes = function(t) {
      var r = t != null && t !== "auto" ? this.getAxis(t) : this.getBaseAxis();
      return {
        baseAxes: [r],
        otherAxes: [this.getOtherAxis(r)]
      };
    }, e.prototype.dataToPoint = function(t, r) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], r), this._angleAxis.dataToAngle(t[1], r)]);
    }, e.prototype.pointToData = function(t, r) {
      var n = this.pointToCoord(t);
      return [this._radiusAxis.radiusToData(n[0], r), this._angleAxis.angleToData(n[1], r)];
    }, e.prototype.pointToCoord = function(t) {
      var r = t[0] - this.cx, n = t[1] - this.cy, i = this.getAngleAxis(), o = i.getExtent(), a = Math.min(o[0], o[1]), s = Math.max(o[0], o[1]);
      i.inverse ? a = s - 360 : s = a + 360;
      var l = Math.sqrt(r * r + n * n);
      r /= l, n /= l;
      for (var u = Math.atan2(-n, r) / Math.PI * 180, c = u < a ? 1 : -1; u < a || u > s; )
        u += c * 360;
      return [l, u];
    }, e.prototype.coordToPoint = function(t) {
      var r = t[0], n = t[1] / 180 * Math.PI, i = Math.cos(n) * r + this.cx, o = -Math.sin(n) * r + this.cy;
      return [i, o];
    }, e.prototype.getArea = function() {
      var t = this.getAngleAxis(), r = this.getRadiusAxis(), n = r.getExtent().slice();
      n[0] > n[1] && n.reverse();
      var i = t.getExtent(), o = Math.PI / 180;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: n[0],
        r: n[1],
        startAngle: -i[0] * o,
        endAngle: -i[1] * o,
        clockwise: t.inverse,
        contain: function(a, s) {
          var l = a - this.cx, u = s - this.cy, c = l * l + u * u - 1e-4, d = this.r, h = this.r0;
          return c <= d * d && c >= h * h;
        }
      };
    }, e.prototype.convertToPixel = function(t, r, n) {
      var i = WB(r);
      return i === this ? this.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      var i = WB(r);
      return i === this ? this.pointToData(n) : null;
    }, e;
  }()
);
function WB(e) {
  var t = e.seriesModel, r = e.polarModel;
  return r && r.coordinateSystem || t && t.coordinateSystem;
}
const cDe = uDe;
function dDe(e, t, r) {
  var n = t.get("center"), i = r.getWidth(), o = r.getHeight();
  e.cx = Ae(n[0], i), e.cy = Ae(n[1], o);
  var a = e.getRadiusAxis(), s = Math.min(i, o) / 2, l = t.get("radius");
  l == null ? l = [0, "100%"] : fe(l) || (l = [0, l]);
  var u = [Ae(l[0], s), Ae(l[1], s)];
  a.inverse ? a.setExtent(u[1], u[0]) : a.setExtent(u[0], u[1]);
}
function hDe(e, t) {
  var r = this, n = r.getAngleAxis(), i = r.getRadiusAxis();
  if (n.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), e.eachSeries(function(s) {
    if (s.coordinateSystem === r) {
      var l = s.getData();
      B(pC(l, "radius"), function(u) {
        i.scale.unionExtentFromData(l, u);
      }), B(pC(l, "angle"), function(u) {
        n.scale.unionExtentFromData(l, u);
      });
    }
  }), Ic(n.scale, n.model), Ic(i.scale, i.model), n.type === "category" && !n.onBand) {
    var o = n.getExtent(), a = 360 / n.scale.count();
    n.inverse ? o[1] += a : o[1] -= a, n.setExtent(o[0], o[1]);
  }
}
function fDe(e) {
  return e.mainType === "angleAxis";
}
function jB(e, t) {
  var r;
  if (e.type = t.get("type"), e.scale = Nv(t), e.onBand = t.get("boundaryGap") && e.type === "category", e.inverse = t.get("inverse"), fDe(t)) {
    e.inverse = e.inverse !== t.get("clockwise");
    var n = t.get("startAngle"), i = (r = t.get("endAngle")) !== null && r !== void 0 ? r : n + (e.inverse ? -360 : 360);
    e.setExtent(n, i);
  }
  t.axis = e, e.model = t;
}
var pDe = {
  dimensions: rU,
  create: function(e, t) {
    var r = [];
    return e.eachComponent("polar", function(n, i) {
      var o = new cDe(i + "");
      o.update = hDe;
      var a = o.getRadiusAxis(), s = o.getAngleAxis(), l = n.findAxisModel("radiusAxis"), u = n.findAxisModel("angleAxis");
      jB(a, l), jB(s, u), dDe(o, n, t), r.push(o), n.coordinateSystem = o, o.model = n;
    }), e.eachSeries(function(n) {
      if (n.get("coordinateSystem") === "polar") {
        var i = n.getReferringComponents("polar", un).models[0];
        if (process.env.NODE_ENV !== "production" && !i)
          throw new Error('Polar "' + tn(n.get("polarIndex"), n.get("polarId"), 0) + '" not found');
        n.coordinateSystem = i.coordinateSystem;
      }
    }), r;
  }
}, gDe = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function vy(e, t, r) {
  t[1] > t[0] && (t = t.slice().reverse());
  var n = e.coordToPoint([t[0], r]), i = e.coordToPoint([t[1], r]);
  return {
    x1: n[0],
    y1: n[1],
    x2: i[0],
    y2: i[1]
  };
}
function my(e) {
  var t = e.getRadiusAxis();
  return t.inverse ? 0 : 1;
}
function UB(e) {
  var t = e[0], r = e[e.length - 1];
  t && r && Math.abs(Math.abs(t.coord - r.coord) - 360) < 1e-4 && e.pop();
}
var vDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.axisPointerClass = "PolarAxisPointer", r;
    }
    return t.prototype.render = function(r, n) {
      if (this.group.removeAll(), !!r.get("show")) {
        var i = r.axis, o = i.polar, a = o.getRadiusAxis().getExtent(), s = i.getTicksCoords(), l = i.getMinorTicksCoords(), u = ge(i.getViewLabels(), function(c) {
          c = et(c);
          var d = i.scale, h = d.type === "ordinal" ? d.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = i.dataToCoord(h), c;
        });
        UB(u), UB(s), B(gDe, function(c) {
          r.get([c, "show"]) && (!i.scale.isBlank() || c === "axisLine") && mDe[c](this.group, r, o, s, l, a, u);
        }, this);
      }
    }, t.type = "angleAxis", t;
  }(Xc)
), mDe = {
  axisLine: function(e, t, r, n, i, o) {
    var a = t.getModel(["axisLine", "lineStyle"]), s = r.getAngleAxis(), l = Math.PI / 180, u = s.getExtent(), c = my(r), d = c ? 0 : 1, h, f = Math.abs(u[1] - u[0]) === 360 ? "Circle" : "Arc";
    o[d] === 0 ? h = new jc[f]({
      shape: {
        cx: r.cx,
        cy: r.cy,
        r: o[c],
        startAngle: -u[0] * l,
        endAngle: -u[1] * l,
        clockwise: s.inverse
      },
      style: a.getLineStyle(),
      z2: 1,
      silent: !0
    }) : h = new Dv({
      shape: {
        cx: r.cx,
        cy: r.cy,
        r: o[c],
        r0: o[d]
      },
      style: a.getLineStyle(),
      z2: 1,
      silent: !0
    }), h.style.fill = null, e.add(h);
  },
  axisTick: function(e, t, r, n, i, o) {
    var a = t.getModel("axisTick"), s = (a.get("inside") ? -1 : 1) * a.get("length"), l = o[my(r)], u = ge(n, function(c) {
      return new wn({
        shape: vy(r, [l, l + s], c.coord)
      });
    });
    e.add(Zi(u, {
      style: Xe(a.getModel("lineStyle").getLineStyle(), {
        stroke: t.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(e, t, r, n, i, o) {
    if (i.length) {
      for (var a = t.getModel("axisTick"), s = t.getModel("minorTick"), l = (a.get("inside") ? -1 : 1) * s.get("length"), u = o[my(r)], c = [], d = 0; d < i.length; d++)
        for (var h = 0; h < i[d].length; h++)
          c.push(new wn({
            shape: vy(r, [u, u + l], i[d][h].coord)
          }));
      e.add(Zi(c, {
        style: Xe(s.getModel("lineStyle").getLineStyle(), Xe(a.getLineStyle(), {
          stroke: t.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(e, t, r, n, i, o, a) {
    var s = t.getCategories(!0), l = t.getModel("axisLabel"), u = l.get("margin"), c = t.get("triggerEvent");
    B(a, function(d, h) {
      var f = l, p = d.tickValue, g = o[my(r)], v = r.coordToPoint([g + u, d.coord]), m = r.cx, y = r.cy, C = Math.abs(v[0] - m) / g < 0.3 ? "center" : v[0] > m ? "left" : "right", S = Math.abs(v[1] - y) / g < 0.3 ? "middle" : v[1] > y ? "top" : "bottom";
      if (s && s[p]) {
        var b = s[p];
        Ze(b) && b.textStyle && (f = new cr(b.textStyle, l, l.ecModel));
      }
      var w = new Vt({
        silent: Ci.isLabelSilent(t),
        style: br(f, {
          x: v[0],
          y: v[1],
          fill: f.getTextColor() || t.get(["axisLine", "lineStyle", "color"]),
          text: d.formattedLabel,
          align: C,
          verticalAlign: S
        })
      });
      if (e.add(w), c) {
        var x = Ci.makeAxisEventDataBase(t);
        x.targetType = "axisLabel", x.value = d.rawLabel, ot(w).eventData = x;
      }
    }, this);
  },
  splitLine: function(e, t, r, n, i, o) {
    var a = t.getModel("splitLine"), s = a.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var c = [], d = 0; d < n.length; d++) {
      var h = u++ % l.length;
      c[h] = c[h] || [], c[h].push(new wn({
        shape: vy(r, o, n[d].coord)
      }));
    }
    for (var d = 0; d < c.length; d++)
      e.add(Zi(c[d], {
        style: Xe({
          stroke: l[d % l.length]
        }, s.getLineStyle()),
        silent: !0,
        z: t.get("z")
      }));
  },
  minorSplitLine: function(e, t, r, n, i, o) {
    if (i.length) {
      for (var a = t.getModel("minorSplitLine"), s = a.getModel("lineStyle"), l = [], u = 0; u < i.length; u++)
        for (var c = 0; c < i[u].length; c++)
          l.push(new wn({
            shape: vy(r, o, i[u][c].coord)
          }));
      e.add(Zi(l, {
        style: s.getLineStyle(),
        silent: !0,
        z: t.get("z")
      }));
    }
  },
  splitArea: function(e, t, r, n, i, o) {
    if (n.length) {
      var a = t.getModel("splitArea"), s = a.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], d = Math.PI / 180, h = -n[0].coord * d, f = Math.min(o[0], o[1]), p = Math.max(o[0], o[1]), g = t.get("clockwise"), v = 1, m = n.length; v <= m; v++) {
        var y = v === m ? n[0].coord : n[v].coord, C = u++ % l.length;
        c[C] = c[C] || [], c[C].push(new xi({
          shape: {
            cx: r.cx,
            cy: r.cy,
            r0: f,
            r: p,
            startAngle: h,
            endAngle: -y * d,
            clockwise: g
          },
          silent: !0
        })), h = -y * d;
      }
      for (var v = 0; v < c.length; v++)
        e.add(Zi(c[v], {
          style: Xe({
            fill: l[v % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
}, yDe = ["axisLine", "axisTickLabel", "axisName"], CDe = ["splitLine", "splitArea", "minorSplitLine"], SDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.axisPointerClass = "PolarAxisPointer", r;
    }
    return t.prototype.render = function(r, n) {
      if (this.group.removeAll(), !!r.get("show")) {
        var i = this._axisGroup, o = this._axisGroup = new it();
        this.group.add(o);
        var a = r.axis, s = a.polar, l = s.getAngleAxis(), u = a.getTicksCoords(), c = a.getMinorTicksCoords(), d = l.getExtent()[0], h = a.getExtent(), f = bDe(s, r, d), p = new Ci(r, f);
        B(yDe, p.add, p), o.add(p.getGroup()), Fv(i, o, r), B(CDe, function(g) {
          r.get([g, "show"]) && !a.scale.isBlank() && wDe[g](this.group, r, s, d, h, u, c);
        }, this);
      }
    }, t.type = "radiusAxis", t;
  }(Xc)
), wDe = {
  splitLine: function(e, t, r, n, i, o) {
    var a = t.getModel("splitLine"), s = a.getModel("lineStyle"), l = s.get("color"), u = 0, c = r.getAngleAxis(), d = Math.PI / 180, h = c.getExtent(), f = Math.abs(h[1] - h[0]) === 360 ? "Circle" : "Arc";
    l = l instanceof Array ? l : [l];
    for (var p = [], g = 0; g < o.length; g++) {
      var v = u++ % l.length;
      p[v] = p[v] || [], p[v].push(new jc[f]({
        shape: {
          cx: r.cx,
          cy: r.cy,
          // ensure circle radius >= 0
          r: Math.max(o[g].coord, 0),
          startAngle: -h[0] * d,
          endAngle: -h[1] * d,
          clockwise: c.inverse
        }
      }));
    }
    for (var g = 0; g < p.length; g++)
      e.add(Zi(p[g], {
        style: Xe({
          stroke: l[g % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(e, t, r, n, i, o, a) {
    if (a.length) {
      for (var s = t.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], c = 0; c < a.length; c++)
        for (var d = 0; d < a[c].length; d++)
          u.push(new Js({
            shape: {
              cx: r.cx,
              cy: r.cy,
              r: a[c][d].coord
            }
          }));
      e.add(Zi(u, {
        style: Xe({
          fill: null
        }, l.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(e, t, r, n, i, o) {
    if (o.length) {
      var a = t.getModel("splitArea"), s = a.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], d = o[0].coord, h = 1; h < o.length; h++) {
        var f = u++ % l.length;
        c[f] = c[f] || [], c[f].push(new xi({
          shape: {
            cx: r.cx,
            cy: r.cy,
            r0: d,
            r: o[h].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), d = o[h].coord;
      }
      for (var h = 0; h < c.length; h++)
        e.add(Zi(c[h], {
          style: Xe({
            fill: l[h % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function bDe(e, t, r) {
  return {
    position: [e.cx, e.cy],
    rotation: r / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: t.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
function nU(e) {
  return e.get("stack") || "__ec_stack_" + e.seriesIndex;
}
function iU(e, t) {
  return t.dim + e.model.componentIndex;
}
function xDe(e, t, r) {
  var n = {}, i = EDe(ir(t.getSeriesByType(e), function(o) {
    return !t.isSeriesFiltered(o) && o.coordinateSystem && o.coordinateSystem.type === "polar";
  }));
  t.eachSeriesByType(e, function(o) {
    if (o.coordinateSystem.type === "polar") {
      var a = o.getData(), s = o.coordinateSystem, l = s.getBaseAxis(), u = iU(s, l), c = nU(o), d = i[u][c], h = d.offset, f = d.width, p = s.getOtherAxis(l), g = o.coordinateSystem.cx, v = o.coordinateSystem.cy, m = o.get("barMinHeight") || 0, y = o.get("barMinAngle") || 0;
      n[c] = n[c] || [];
      for (var C = a.mapDimension(p.dim), S = a.mapDimension(l.dim), b = js(
        a,
        C
        /* , baseDim */
      ), w = l.dim !== "radius" || !o.get("roundCap", !0), x = p.model, E = x.get("startValue"), R = p.dataToCoord(E || 0), _ = 0, P = a.count(); _ < P; _++) {
        var D = a.get(C, _), I = a.get(S, _), A = D >= 0 ? "p" : "n", O = R;
        b && (n[c][I] || (n[c][I] = {
          p: R,
          n: R
          // Negative stack
        }), O = n[c][I][A]);
        var L = void 0, N = void 0, F = void 0, G = void 0;
        if (p.dim === "radius") {
          var M = p.dataToCoord(D) - R, V = l.dataToCoord(I);
          Math.abs(M) < m && (M = (M < 0 ? -1 : 1) * m), L = O, N = O + M, F = V - h, G = F - f, b && (n[c][I][A] = N);
        } else {
          var z = p.dataToCoord(D, w) - R, k = l.dataToCoord(I);
          Math.abs(z) < y && (z = (z < 0 ? -1 : 1) * y), L = k + h, N = L + f, F = O, G = O + z, b && (n[c][I][A] = G);
        }
        a.setItemLayout(_, {
          cx: g,
          cy: v,
          r0: L,
          r: N,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -F * Math.PI / 180,
          endAngle: -G * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: F >= G
        });
      }
    }
  });
}
function EDe(e) {
  var t = {};
  B(e, function(n, i) {
    var o = n.getData(), a = n.coordinateSystem, s = a.getBaseAxis(), l = iU(a, s), u = s.getExtent(), c = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / o.count(), d = t[l] || {
      bandWidth: c,
      remainedWidth: c,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, h = d.stacks;
    t[l] = d;
    var f = nU(n);
    h[f] || d.autoWidthCount++, h[f] = h[f] || {
      width: 0,
      maxWidth: 0
    };
    var p = Ae(n.get("barWidth"), c), g = Ae(n.get("barMaxWidth"), c), v = n.get("barGap"), m = n.get("barCategoryGap");
    p && !h[f].width && (p = Math.min(d.remainedWidth, p), h[f].width = p, d.remainedWidth -= p), g && (h[f].maxWidth = g), v != null && (d.gap = v), m != null && (d.categoryGap = m);
  });
  var r = {};
  return B(t, function(n, i) {
    r[i] = {};
    var o = n.stacks, a = n.bandWidth, s = Ae(n.categoryGap, a), l = Ae(n.gap, 1), u = n.remainedWidth, c = n.autoWidthCount, d = (u - s) / (c + (c - 1) * l);
    d = Math.max(d, 0), B(o, function(g, v) {
      var m = g.maxWidth;
      m && m < d && (m = Math.min(m, u), g.width && (m = Math.min(m, g.width)), u -= m, g.width = m, c--);
    }), d = (u - s) / (c + (c - 1) * l), d = Math.max(d, 0);
    var h = 0, f;
    B(o, function(g, v) {
      g.width || (g.width = d), f = g, h += g.width * (1 + l);
    }), f && (h -= f.width * l);
    var p = -h / 2;
    B(o, function(g, v) {
      r[i][v] = r[i][v] || {
        offset: p,
        width: g.width
      }, p += g.width * (1 + l);
    });
  }), r;
}
var RDe = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, _De = {
  splitNumber: 5
}, TDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "polar", t;
  }(Rr)
);
function PDe(e) {
  _t(jv), Xc.registerAxisPointerClass("PolarAxisPointer", rDe), e.registerCoordinateSystem("polar", pDe), e.registerComponentModel(oDe), e.registerComponentView(TDe), Vh(e, "angle", aDe, RDe), Vh(e, "radius", sDe, _De), e.registerComponentView(vDe), e.registerComponentView(SDe), e.registerLayout(dt(xDe, "bar"));
}
function eT(e, t) {
  t = t || {};
  var r = e.coordinateSystem, n = e.axis, i = {}, o = n.position, a = n.orient, s = r.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = {
    horizontal: {
      top: l[2],
      bottom: l[3]
    },
    vertical: {
      left: l[0],
      right: l[1]
    }
  };
  i.position = [a === "vertical" ? u.vertical[o] : l[0], a === "horizontal" ? u.horizontal[o] : l[3]];
  var c = {
    horizontal: 0,
    vertical: 1
  };
  i.rotation = Math.PI / 2 * c[a];
  var d = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  i.labelDirection = i.tickDirection = i.nameDirection = d[o], e.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), tn(t.labelInside, e.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection);
  var h = t.rotate;
  return h == null && (h = e.get(["axisLabel", "rotate"])), i.labelRotation = o === "top" ? -h : h, i.z2 = 1, i;
}
var MDe = ["axisLine", "axisTickLabel", "axisName"], DDe = ["splitArea", "splitLine"], ADe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.axisPointerClass = "SingleAxisPointer", r;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = this.group;
      a.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new it();
      var l = eT(r), u = new Ci(r, l);
      B(MDe, u.add, u), a.add(this._axisGroup), a.add(u.getGroup()), B(DDe, function(c) {
        r.get([c, "show"]) && IDe[c](this, this.group, this._axisGroup, r);
      }, this), Fv(s, this._axisGroup, r), e.prototype.render.call(this, r, n, i, o);
    }, t.prototype.remove = function() {
      E9(this);
    }, t.type = "singleAxis", t;
  }(Xc)
), IDe = {
  splitLine: function(e, t, r, n) {
    var i = n.axis;
    if (!i.scale.isBlank()) {
      var o = n.getModel("splitLine"), a = o.getModel("lineStyle"), s = a.get("color");
      s = s instanceof Array ? s : [s];
      for (var l = a.get("width"), u = n.coordinateSystem.getRect(), c = i.isHorizontal(), d = [], h = 0, f = i.getTicksCoords({
        tickModel: o
      }), p = [], g = [], v = 0; v < f.length; ++v) {
        var m = i.toGlobalCoord(f[v].coord);
        c ? (p[0] = m, p[1] = u.y, g[0] = m, g[1] = u.y + u.height) : (p[0] = u.x, p[1] = m, g[0] = u.x + u.width, g[1] = m);
        var y = new wn({
          shape: {
            x1: p[0],
            y1: p[1],
            x2: g[0],
            y2: g[1]
          },
          silent: !0
        });
        Lh(y.shape, l);
        var C = h++ % s.length;
        d[C] = d[C] || [], d[C].push(y);
      }
      for (var S = a.getLineStyle(["color"]), v = 0; v < d.length; ++v)
        t.add(Zi(d[v], {
          style: Xe({
            stroke: s[v % s.length]
          }, S),
          silent: !0
        }));
    }
  },
  splitArea: function(e, t, r, n) {
    x9(e, r, n, n);
  }
}, d0 = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.getCoordSysModel = function() {
      return this;
    }, t.type = "singleAxis", t.layoutMode = "box", t.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, t;
  }(Rt)
);
qr(d0, Cf.prototype);
var FDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i, o, a) {
      var s = e.call(this, r, n, i) || this;
      return s.type = o || "value", s.position = a || "bottom", s;
    }
    return t.prototype.isHorizontal = function() {
      var r = this.position;
      return r === "top" || r === "bottom";
    }, t.prototype.pointToData = function(r, n) {
      return this.coordinateSystem.pointToData(r)[0];
    }, t;
  }(Wo)
), oU = ["single"], LDe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "single", this.dimension = "single", this.dimensions = oU, this.axisPointerEnabled = !0, this.model = t, this._init(t, r, n);
    }
    return e.prototype._init = function(t, r, n) {
      var i = this.dimension, o = new FDe(i, Nv(t), [0, 0], t.get("type"), t.get("position")), a = o.type === "category";
      o.onBand = a && t.get("boundaryGap"), o.inverse = t.get("inverse"), o.orient = t.get("orient"), t.axis = o, o.model = t, o.coordinateSystem = this, this._axis = o;
    }, e.prototype.update = function(t, r) {
      t.eachSeries(function(n) {
        if (n.coordinateSystem === this) {
          var i = n.getData();
          B(i.mapDimensionsAll(this.dimension), function(o) {
            this._axis.scale.unionExtentFromData(i, o);
          }, this), Ic(this._axis.scale, this._axis.model);
        }
      }, this);
    }, e.prototype.resize = function(t, r) {
      this._rect = hn({
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      }, {
        width: r.getWidth(),
        height: r.getHeight()
      }), this._adjustAxis();
    }, e.prototype.getRect = function() {
      return this._rect;
    }, e.prototype._adjustAxis = function() {
      var t = this._rect, r = this._axis, n = r.isHorizontal(), i = n ? [0, t.width] : [0, t.height], o = r.inverse ? 1 : 0;
      r.setExtent(i[o], i[1 - o]), this._updateAxisTransform(r, n ? t.x : t.y);
    }, e.prototype._updateAxisTransform = function(t, r) {
      var n = t.getExtent(), i = n[0] + n[1], o = t.isHorizontal();
      t.toGlobalCoord = o ? function(a) {
        return a + r;
      } : function(a) {
        return i - a + r;
      }, t.toLocalCoord = o ? function(a) {
        return a - r;
      } : function(a) {
        return i - a + r;
      };
    }, e.prototype.getAxis = function() {
      return this._axis;
    }, e.prototype.getBaseAxis = function() {
      return this._axis;
    }, e.prototype.getAxes = function() {
      return [this._axis];
    }, e.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, e.prototype.containPoint = function(t) {
      var r = this.getRect(), n = this.getAxis(), i = n.orient;
      return i === "horizontal" ? n.contain(n.toLocalCoord(t[0])) && t[1] >= r.y && t[1] <= r.y + r.height : n.contain(n.toLocalCoord(t[1])) && t[0] >= r.y && t[0] <= r.y + r.height;
    }, e.prototype.pointToData = function(t) {
      var r = this.getAxis();
      return [r.coordToData(r.toLocalCoord(t[r.orient === "horizontal" ? 0 : 1]))];
    }, e.prototype.dataToPoint = function(t) {
      var r = this.getAxis(), n = this.getRect(), i = [], o = r.orient === "horizontal" ? 0 : 1;
      return t instanceof Array && (t = t[0]), i[o] = r.toGlobalCoord(r.dataToCoord(+t)), i[1 - o] = o === 0 ? n.y + n.height / 2 : n.x + n.width / 2, i;
    }, e.prototype.convertToPixel = function(t, r, n) {
      var i = KB(r);
      return i === this ? this.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      var i = KB(r);
      return i === this ? this.pointToData(n) : null;
    }, e;
  }()
);
function KB(e) {
  var t = e.seriesModel, r = e.singleAxisModel;
  return r && r.coordinateSystem || t && t.coordinateSystem;
}
function ODe(e, t) {
  var r = [];
  return e.eachComponent("singleAxis", function(n, i) {
    var o = new LDe(n, e, t);
    o.name = "single_" + i, o.resize(n, t), n.coordinateSystem = o, r.push(o);
  }), e.eachSeries(function(n) {
    if (n.get("coordinateSystem") === "singleAxis") {
      var i = n.getReferringComponents("singleAxis", un).models[0];
      n.coordinateSystem = i && i.coordinateSystem;
    }
  }), r;
}
var NDe = {
  create: ODe,
  dimensions: oU
}, YB = ["x", "y"], kDe = ["width", "height"], VDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(r, n, i, o, a) {
      var s = i.axis, l = s.coordinateSystem, u = bx(l, 1 - DC(s)), c = l.dataToPoint(n)[0], d = o.get("type");
      if (d && d !== "none") {
        var h = YD(o), f = BDe[d](s, c, u);
        f.style = h, r.graphicKey = f.type, r.pointer = f;
      }
      var p = eT(i);
      Qj(
        // @ts-ignore
        n,
        r,
        p,
        i,
        o,
        a
      );
    }, t.prototype.getHandleTransform = function(r, n, i) {
      var o = eT(n, {
        labelInside: !1
      });
      o.labelMargin = i.get(["handle", "margin"]);
      var a = qD(n.axis, r, o);
      return {
        x: a[0],
        y: a[1],
        rotation: o.rotation + (o.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(r, n, i, o) {
      var a = i.axis, s = a.coordinateSystem, l = DC(a), u = bx(s, l), c = [r.x, r.y];
      c[l] += n[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var d = bx(s, 1 - l), h = (d[1] + d[0]) / 2, f = [h, h];
      return f[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: r.rotation,
        cursorPoint: f,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, t;
  }(KD)
), BDe = {
  line: function(e, t, r) {
    var n = ZD([t, r[0]], [t, r[1]], DC(e));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(e, t, r) {
    var n = e.getBandWidth(), i = r[1] - r[0];
    return {
      type: "Rect",
      shape: Jj([t - n / 2, r[0]], [n, i], DC(e))
    };
  }
};
function DC(e) {
  return e.isHorizontal() ? 0 : 1;
}
function bx(e, t) {
  var r = e.getRect();
  return [r[YB[t]], r[YB[t]] + r[kDe[t]]];
}
var GDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "single", t;
  }(Rr)
);
function HDe(e) {
  _t(jv), Xc.registerAxisPointerClass("SingleAxisPointer", VDe), e.registerComponentView(GDe), e.registerComponentView(ADe), e.registerComponentModel(d0), Vh(e, "single", d0, d0.defaultOption), e.registerCoordinateSystem("single", NDe);
}
var zDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n, i) {
      var o = hf(r);
      e.prototype.init.apply(this, arguments), qB(r, o);
    }, t.prototype.mergeOption = function(r) {
      e.prototype.mergeOption.apply(this, arguments), qB(this.option, r);
    }, t.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, t.type = "calendar", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: "50%",
        color: "#000"
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: 5,
        // center or left
        align: "center",
        formatter: null,
        color: "#000"
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, t;
  }(Rt)
);
function qB(e, t) {
  var r = e.cellSize, n;
  fe(r) ? n = r : n = e.cellSize = [r, r], n.length === 1 && (n[1] = n[0]);
  var i = ge([0, 1], function(o) {
    return zye(t, o) && (n[o] = "auto"), n[o] != null && n[o] !== "auto";
  });
  Kl(e, t, {
    type: "box",
    ignoreSize: i
  });
}
var $De = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      var o = this.group;
      o.removeAll();
      var a = r.coordinateSystem, s = a.getRangeInfo(), l = a.getOrient(), u = n.getLocaleModel();
      this._renderDayRect(r, s, o), this._renderLines(r, s, l, o), this._renderYearText(r, s, l, o), this._renderMonthText(r, u, l, o), this._renderWeekText(r, u, s, l, o);
    }, t.prototype._renderDayRect = function(r, n, i) {
      for (var o = r.coordinateSystem, a = r.getModel("itemStyle").getItemStyle(), s = o.getCellWidth(), l = o.getCellHeight(), u = n.start.time; u <= n.end.time; u = o.getNextNDay(u, 1).time) {
        var c = o.dataToRect([u], !1).tl, d = new Bt({
          shape: {
            x: c[0],
            y: c[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: a
        });
        i.add(d);
      }
    }, t.prototype._renderLines = function(r, n, i, o) {
      var a = this, s = r.coordinateSystem, l = r.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = r.get(["splitLine", "show"]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var d = n.start, h = 0; d.time <= n.end.time; h++) {
        p(d.formatedDate), h === 0 && (d = s.getDateInfo(n.start.y + "-" + n.start.m));
        var f = d.date;
        f.setMonth(f.getMonth() + 1), d = s.getDateInfo(f);
      }
      p(s.getNextNDay(n.end.time, 1).formatedDate);
      function p(g) {
        a._firstDayOfMonth.push(s.getDateInfo(g)), a._firstDayPoints.push(s.dataToRect([g], !1).tl);
        var v = a._getLinePointsOfOneWeek(r, g, i);
        a._tlpoints.push(v[0]), a._blpoints.push(v[v.length - 1]), u && a._drawSplitline(v, l, o);
      }
      u && this._drawSplitline(a._getEdgesPoints(a._tlpoints, c, i), l, o), u && this._drawSplitline(a._getEdgesPoints(a._blpoints, c, i), l, o);
    }, t.prototype._getEdgesPoints = function(r, n, i) {
      var o = [r[0].slice(), r[r.length - 1].slice()], a = i === "horizontal" ? 0 : 1;
      return o[0][a] = o[0][a] - n / 2, o[1][a] = o[1][a] + n / 2, o;
    }, t.prototype._drawSplitline = function(r, n, i) {
      var o = new Ri({
        z2: 20,
        shape: {
          points: r
        },
        style: n
      });
      i.add(o);
    }, t.prototype._getLinePointsOfOneWeek = function(r, n, i) {
      for (var o = r.coordinateSystem, a = o.getDateInfo(n), s = [], l = 0; l < 7; l++) {
        var u = o.getNextNDay(a.time, l), c = o.dataToRect([u.time], !1);
        s[2 * u.day] = c.tl, s[2 * u.day + 1] = c[i === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, t.prototype._formatterLabel = function(r, n) {
      return Fe(r) && r ? Vye(r, n) : Ye(r) ? r(n) : n.nameMap;
    }, t.prototype._yearTextPositionControl = function(r, n, i, o, a) {
      var s = n[0], l = n[1], u = ["center", "bottom"];
      o === "bottom" ? (l += a, u = ["center", "top"]) : o === "left" ? s -= a : o === "right" ? (s += a, u = ["center", "top"]) : l -= a;
      var c = 0;
      return (o === "left" || o === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, t.prototype._renderYearText = function(r, n, i, o) {
      var a = r.getModel("yearLabel");
      if (a.get("show")) {
        var s = a.get("margin"), l = a.get("position");
        l || (l = i !== "horizontal" ? "top" : "left");
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], c = (u[0][0] + u[1][0]) / 2, d = (u[0][1] + u[1][1]) / 2, h = i === "horizontal" ? 0 : 1, f = {
          top: [c, u[h][1]],
          bottom: [c, u[1 - h][1]],
          left: [u[1 - h][0], d],
          right: [u[h][0], d]
        }, p = n.start.y;
        +n.end.y > +n.start.y && (p = p + "-" + n.end.y);
        var g = a.get("formatter"), v = {
          start: n.start.y,
          end: n.end.y,
          nameMap: p
        }, m = this._formatterLabel(g, v), y = new Vt({
          z2: 30,
          style: br(a, {
            text: m
          })
        });
        y.attr(this._yearTextPositionControl(y, f[l], i, l, s)), o.add(y);
      }
    }, t.prototype._monthTextPositionControl = function(r, n, i, o, a) {
      var s = "left", l = "top", u = r[0], c = r[1];
      return i === "horizontal" ? (c = c + a, n && (s = "center"), o === "start" && (l = "bottom")) : (u = u + a, n && (l = "middle"), o === "start" && (s = "right")), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, t.prototype._renderMonthText = function(r, n, i, o) {
      var a = r.getModel("monthLabel");
      if (a.get("show")) {
        var s = a.get("nameMap"), l = a.get("margin"), u = a.get("position"), c = a.get("align"), d = [this._tlpoints, this._blpoints];
        (!s || Fe(s)) && (s && (n = l_(s) || n), s = n.get(["time", "monthAbbr"]) || []);
        var h = u === "start" ? 0 : 1, f = i === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", g = 0; g < d[h].length - 1; g++) {
          var v = d[h][g].slice(), m = this._firstDayOfMonth[g];
          if (p) {
            var y = this._firstDayPoints[g];
            v[f] = (y[f] + d[0][g + 1][f]) / 2;
          }
          var C = a.get("formatter"), S = s[+m.m - 1], b = {
            yyyy: m.y,
            yy: (m.y + "").slice(2),
            MM: m.m,
            M: +m.m,
            nameMap: S
          }, w = this._formatterLabel(C, b), x = new Vt({
            z2: 30,
            style: se(br(a, {
              text: w
            }), this._monthTextPositionControl(v, p, i, u, l))
          });
          o.add(x);
        }
      }
    }, t.prototype._weekTextPositionControl = function(r, n, i, o, a) {
      var s = "center", l = "middle", u = r[0], c = r[1], d = i === "start";
      return n === "horizontal" ? (u = u + o + (d ? 1 : -1) * a[0] / 2, s = d ? "right" : "left") : (c = c + o + (d ? 1 : -1) * a[1] / 2, l = d ? "bottom" : "top"), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, t.prototype._renderWeekText = function(r, n, i, o, a) {
      var s = r.getModel("dayLabel");
      if (s.get("show")) {
        var l = r.coordinateSystem, u = s.get("position"), c = s.get("nameMap"), d = s.get("margin"), h = l.getFirstDayOfWeek();
        if (!c || Fe(c)) {
          c && (n = l_(c) || n);
          var f = n.get(["time", "dayOfWeekShort"]);
          c = f || ge(n.get(["time", "dayOfWeekAbbr"]), function(b) {
            return b[0];
          });
        }
        var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, g = [l.getCellWidth(), l.getCellHeight()];
        d = Ae(d, Math.min(g[1], g[0])), u === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, d = -d);
        for (var v = 0; v < 7; v++) {
          var m = l.getNextNDay(p, v), y = l.dataToRect([m.time], !1).center, C = v;
          C = Math.abs((v + h) % 7);
          var S = new Vt({
            z2: 30,
            style: se(br(s, {
              text: c[C]
            }), this._weekTextPositionControl(y, o, u, d, g))
          });
          a.add(S);
        }
      }
    }, t.type = "calendar", t;
  }(Rr)
), xx = 864e5, WDe = (
  /** @class */
  function() {
    function e(t, r, n) {
      this.type = "calendar", this.dimensions = e.dimensions, this.getDimensionsInfo = e.getDimensionsInfo, this._model = t;
    }
    return e.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, e.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getRect = function() {
      return this._rect;
    }, e.prototype.getCellWidth = function() {
      return this._sw;
    }, e.prototype.getCellHeight = function() {
      return this._sh;
    }, e.prototype.getOrient = function() {
      return this._orient;
    }, e.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, e.prototype.getDateInfo = function(t) {
      t = io(t);
      var r = t.getFullYear(), n = t.getMonth() + 1, i = n < 10 ? "0" + n : "" + n, o = t.getDate(), a = o < 10 ? "0" + o : "" + o, s = t.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: r + "",
        m: i,
        d: a,
        day: s,
        time: t.getTime(),
        formatedDate: r + "-" + i + "-" + a,
        date: t
      };
    }, e.prototype.getNextNDay = function(t, r) {
      return r = r || 0, r === 0 ? this.getDateInfo(t) : (t = new Date(this.getDateInfo(t).time), t.setDate(t.getDate() + r), this.getDateInfo(t));
    }, e.prototype.update = function(t, r) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var n = this._rangeInfo.weeks || 1, i = ["width", "height"], o = this._model.getCellSize().slice(), a = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [n, 7] : [7, n];
      B([0, 1], function(d) {
        c(o, d) && (a[i[d]] = o[d] * s[d]);
      });
      var l = {
        width: r.getWidth(),
        height: r.getHeight()
      }, u = this._rect = hn(a, l);
      B([0, 1], function(d) {
        c(o, d) || (o[d] = u[i[d]] / s[d]);
      });
      function c(d, h) {
        return d[h] != null && d[h] !== "auto";
      }
      this._sw = o[0], this._sh = o[1];
    }, e.prototype.dataToPoint = function(t, r) {
      fe(t) && (t = t[0]), r == null && (r = !0);
      var n = this.getDateInfo(t), i = this._rangeInfo, o = n.formatedDate;
      if (r && !(n.time >= i.start.time && n.time < i.end.time + xx))
        return [NaN, NaN];
      var a = n.day, s = this._getRangeInfo([i.start.time, o]).nthWeek;
      return this._orient === "vertical" ? [this._rect.x + a * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + a * this._sh + this._sh / 2];
    }, e.prototype.pointToData = function(t) {
      var r = this.pointToDate(t);
      return r && r.time;
    }, e.prototype.dataToRect = function(t, r) {
      var n = this.dataToPoint(t, r);
      return {
        contentShape: {
          x: n[0] - (this._sw - this._lineWidth) / 2,
          y: n[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: n,
        tl: [n[0] - this._sw / 2, n[1] - this._sh / 2],
        tr: [n[0] + this._sw / 2, n[1] - this._sh / 2],
        br: [n[0] + this._sw / 2, n[1] + this._sh / 2],
        bl: [n[0] - this._sw / 2, n[1] + this._sh / 2]
      };
    }, e.prototype.pointToDate = function(t) {
      var r = Math.floor((t[0] - this._rect.x) / this._sw) + 1, n = Math.floor((t[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(n, r - 1, i) : this._getDateByWeeksAndDay(r, n - 1, i);
    }, e.prototype.convertToPixel = function(t, r, n) {
      var i = ZB(r);
      return i === this ? i.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, r, n) {
      var i = ZB(r);
      return i === this ? i.pointToData(n) : null;
    }, e.prototype.containPoint = function(t) {
      return console.warn("Not implemented."), !1;
    }, e.prototype._initRangeOption = function() {
      var t = this._model.get("range"), r;
      if (fe(t) && t.length === 1 && (t = t[0]), fe(t))
        r = t;
      else {
        var n = t.toString();
        if (/^\d{4}$/.test(n) && (r = [n + "-01-01", n + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(n)) {
          var i = this.getDateInfo(n), o = i.date;
          o.setMonth(o.getMonth() + 1);
          var a = this.getNextNDay(o, -1);
          r = [i.formatedDate, a.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(n) && (r = [n, n]);
      }
      if (!r)
        return process.env.NODE_ENV !== "production" && Mo("Invalid date range."), t;
      var s = this._getRangeInfo(r);
      return s.start.time > s.end.time && r.reverse(), r;
    }, e.prototype._getRangeInfo = function(t) {
      var r = [this.getDateInfo(t[0]), this.getDateInfo(t[1])], n;
      r[0].time > r[1].time && (n = !0, r.reverse());
      var i = Math.floor(r[1].time / xx) - Math.floor(r[0].time / xx) + 1, o = new Date(r[0].time), a = o.getDate(), s = r[1].date.getDate();
      o.setDate(a + i - 1);
      var l = o.getDate();
      if (l !== s)
        for (var u = o.getTime() - r[1].time > 0 ? 1 : -1; (l = o.getDate()) !== s && (o.getTime() - r[1].time) * u > 0; )
          i -= u, o.setDate(l - u);
      var c = Math.floor((i + r[0].day + 6) / 7), d = n ? -c + 1 : c - 1;
      return n && r.reverse(), {
        range: [r[0].formatedDate, r[1].formatedDate],
        start: r[0],
        end: r[1],
        allDay: i,
        weeks: c,
        // From 0.
        nthWeek: d,
        fweek: r[0].day,
        lweek: r[1].day
      };
    }, e.prototype._getDateByWeeksAndDay = function(t, r, n) {
      var i = this._getRangeInfo(n);
      if (t > i.weeks || t === 0 && r < i.fweek || t === i.weeks && r > i.lweek)
        return null;
      var o = (t - 1) * 7 - i.fweek + r, a = new Date(i.start.time);
      return a.setDate(+i.start.d + o), this.getDateInfo(a);
    }, e.create = function(t, r) {
      var n = [];
      return t.eachComponent("calendar", function(i) {
        var o = new e(i);
        n.push(o), i.coordinateSystem = o;
      }), t.eachSeries(function(i) {
        i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = n[i.get("calendarIndex") || 0]);
      }), n;
    }, e.dimensions = ["time", "value"], e;
  }()
);
function ZB(e) {
  var t = e.calendarModel, r = e.seriesModel, n = t ? t.coordinateSystem : r ? r.coordinateSystem : null;
  return n;
}
function jDe(e) {
  e.registerComponentModel(zDe), e.registerComponentView($De), e.registerCoordinateSystem("calendar", WDe);
}
function UDe(e, t) {
  var r = e.existing;
  if (t.id = e.keyInfo.id, !t.type && r && (t.type = r.type), t.parentId == null) {
    var n = t.parentOption;
    n ? t.parentId = n.id : r && (t.parentId = r.parentId);
  }
  t.parentOption = null;
}
function XB(e, t) {
  var r;
  return B(t, function(n) {
    e[n] != null && e[n] !== "auto" && (r = !0);
  }), r;
}
function KDe(e, t, r) {
  var n = se({}, r), i = e[t], o = r.$action || "merge";
  if (o === "merge")
    if (i) {
      if (process.env.NODE_ENV !== "production") {
        var a = r.type;
        Qe(!a || i.type === a, 'Please set $action: "replace" to change `type`');
      }
      yt(i, n, !0), Kl(i, n, {
        ignoreSize: !0
      }), q6(r, i), yy(r, i), yy(r, i, "shape"), yy(r, i, "style"), yy(r, i, "extra"), r.clipPath = i.clipPath;
    } else
      e[t] = n;
  else o === "replace" ? e[t] = n : o === "remove" && i && (e[t] = null);
}
var aU = ["transition", "enterFrom", "leaveTo"], YDe = aU.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function yy(e, t, r) {
  if (r && (!e[r] && t[r] && (e[r] = {}), e = e[r], t = t[r]), !(!e || !t))
    for (var n = r ? aU : YDe, i = 0; i < n.length; i++) {
      var o = n[i];
      e[o] == null && t[o] != null && (e[o] = t[o]);
    }
}
function qDe(e, t) {
  if (e && (e.hv = t.hv = [
    // Rigid body, don't care about `width`.
    XB(t, ["left", "right"]),
    // Rigid body, don't care about `height`.
    XB(t, ["top", "bottom"])
  ], e.type === "group")) {
    var r = e, n = t;
    r.width == null && (r.width = n.width = 0), r.height == null && (r.height = n.height = 0);
  }
}
var ZDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.preventAutoZ = !0, r;
    }
    return t.prototype.mergeOption = function(r, n) {
      var i = this.option.elements;
      this.option.elements = null, e.prototype.mergeOption.call(this, r, n), this.option.elements = i;
    }, t.prototype.optionUpdated = function(r, n) {
      var i = this.option, o = (n ? i : r).elements, a = i.elements = n ? [] : i.elements, s = [];
      this._flatten(o, s, null);
      var l = O$(a, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      B(l, function(c, d) {
        var h = c.newOption;
        process.env.NODE_ENV !== "production" && Qe(Ze(h) || c.existing, "Empty graphic option definition"), h && (u.push(h), UDe(c, h), KDe(a, d, h), qDe(a[d], h));
      }, this), i.elements = ir(a, function(c) {
        return c && delete c.$action, c != null;
      });
    }, t.prototype._flatten = function(r, n, i) {
      B(r, function(o) {
        if (o) {
          i && (o.parentOption = i), n.push(o);
          var a = o.children;
          a && a.length && this._flatten(a, n, o), delete o.children;
        }
      }, this);
    }, t.prototype.useElOptionsToUpdate = function() {
      var r = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, r;
    }, t.type = "graphic", t.defaultOption = {
      elements: []
      // parentId: null
    }, t;
  }(Rt)
), QB = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: it,
  image: In,
  text: Vt
}, wo = Gt(), XDe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function() {
      this._elMap = We();
    }, t.prototype.render = function(r, n, i) {
      r !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = r, this._updateElements(r), this._relocate(r, i);
    }, t.prototype._updateElements = function(r) {
      var n = r.useElOptionsToUpdate();
      if (n) {
        var i = this._elMap, o = this.group, a = r.get("z"), s = r.get("zlevel");
        B(n, function(l) {
          var u = vn(l.id, null), c = u != null ? i.get(u) : null, d = vn(l.parentId, null), h = d != null ? i.get(d) : o, f = l.type, p = l.style;
          f === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var g = l.textContent, v = l.textConfig;
          if (p && Bj(p, f, !!v, !!g)) {
            var m = Gj(p, f, !0);
            !v && m.textConfig && (v = l.textConfig = m.textConfig), !g && m.textContent && (g = m.textContent);
          }
          var y = QDe(l);
          process.env.NODE_ENV !== "production" && c && Qe(h === c.parent, "Changing parent is not supported.");
          var C = l.$action || "merge", S = C === "merge", b = C === "replace";
          if (S) {
            var w = !c, x = c;
            w ? x = JB(u, h, l.type, i) : (x && (wo(x).isNew = !1), jj(x)), x && (u0(x, y, r, {
              isInit: w
            }), e4(x, l, a, s));
          } else if (b) {
            h0(c, l, i, r);
            var E = JB(u, h, l.type, i);
            E && (u0(E, y, r, {
              isInit: !0
            }), e4(E, l, a, s));
          } else C === "remove" && (zj(c, l), h0(c, l, i, r));
          var R = i.get(u);
          if (R && g)
            if (S) {
              var _ = R.getTextContent();
              _ ? _.attr(g) : R.setTextContent(new Vt(g));
            } else b && R.setTextContent(new Vt(g));
          if (R) {
            var P = l.clipPath;
            if (P) {
              var D = P.type, I = void 0, w = !1;
              if (S) {
                var A = R.getClipPath();
                w = !A || wo(A).type !== D, I = w ? tT(D) : A;
              } else b && (w = !0, I = tT(D));
              R.setClipPath(I), u0(I, P, r, {
                isInit: w
              }), TC(I, P.keyframeAnimation, r);
            }
            var O = wo(R);
            R.setTextConfig(v), O.option = l, JDe(R, r, l), uf({
              el: R,
              componentModel: r,
              itemName: R.name,
              itemTooltipOption: l.tooltip
            }), TC(R, l.keyframeAnimation, r);
          }
        });
      }
    }, t.prototype._relocate = function(r, n) {
      for (var i = r.option.elements, o = this.group, a = this._elMap, s = n.getWidth(), l = n.getHeight(), u = ["x", "y"], c = 0; c < i.length; c++) {
        var d = i[c], h = vn(d.id, null), f = h != null ? a.get(h) : null;
        if (!(!f || !f.isGroup)) {
          var p = f.parent, g = p === o, v = wo(f), m = wo(p);
          v.width = Ae(v.option.width, g ? s : m.width) || 0, v.height = Ae(v.option.height, g ? l : m.height) || 0;
        }
      }
      for (var c = i.length - 1; c >= 0; c--) {
        var d = i[c], h = vn(d.id, null), f = h != null ? a.get(h) : null;
        if (f) {
          var p = f.parent, m = wo(p), y = p === o ? {
            width: s,
            height: l
          } : {
            width: m.width,
            height: m.height
          }, C = {}, S = KS(f, d, y, null, {
            hv: d.hv,
            boundingMode: d.bounding
          }, C);
          if (!wo(f).isNew && S) {
            for (var b = d.transition, w = {}, x = 0; x < u.length; x++) {
              var E = u[x], R = C[E];
              b && (mc(b) || bt(b, E) >= 0) ? w[E] = R : f[E] = R;
            }
            jt(f, w, r, 0);
          } else
            f.attr(C);
        }
      }
    }, t.prototype._clear = function() {
      var r = this, n = this._elMap;
      n.each(function(i) {
        h0(i, wo(i).option, n, r._lastGraphicModel);
      }), this._elMap = We();
    }, t.prototype.dispose = function() {
      this._clear();
    }, t.type = "graphic", t;
  }(Rr)
);
function tT(e) {
  process.env.NODE_ENV !== "production" && Qe(e, "graphic type MUST be set");
  var t = Be(QB, e) ? QB[e] : GS(e);
  process.env.NODE_ENV !== "production" && Qe(t, "graphic type " + e + " can not be found");
  var r = new t({});
  return wo(r).type = e, r;
}
function JB(e, t, r, n) {
  var i = tT(r);
  return t.add(i), n.set(e, i), wo(i).id = e, wo(i).isNew = !0, i;
}
function h0(e, t, r, n) {
  var i = e && e.parent;
  i && (e.type === "group" && e.traverse(function(o) {
    h0(o, t, r, n);
  }), cw(e, t, n), r.removeKey(wo(e).id));
}
function e4(e, t, r, n) {
  e.isGroup || B([
    ["cursor", ko.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", n || 0],
    ["z", r || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(i) {
    var o = i[0];
    Be(t, o) ? e[o] = st(t[o], i[1]) : e[o] == null && (e[o] = i[1]);
  }), B(At(t), function(i) {
    if (i.indexOf("on") === 0) {
      var o = t[i];
      e[i] = Ye(o) ? o : null;
    }
  }), Be(t, "draggable") && (e.draggable = t.draggable), t.name != null && (e.name = t.name), t.id != null && (e.id = t.id);
}
function QDe(e) {
  return e = se({}, e), B(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(Y6), function(t) {
    delete e[t];
  }), e;
}
function JDe(e, t, r) {
  var n = ot(e).eventData;
  !e.silent && !e.ignore && !n && (n = ot(e).eventData = {
    componentType: "graphic",
    componentIndex: t.componentIndex,
    name: e.name
  }), n && (n.info = r.info);
}
function eAe(e) {
  e.registerComponentModel(ZDe), e.registerComponentView(XDe), e.registerPreprocessor(function(t) {
    var r = t.graphic;
    fe(r) ? !r[0] || !r[0].elements ? t.graphic = [{
      elements: r
    }] : t.graphic = [t.graphic[0]] : r && !r.elements && (t.graphic = [{
      elements: [r]
    }]);
  });
}
var t4 = ["x", "y", "radius", "angle", "single"], tAe = ["cartesian2d", "polar", "singleAxis"];
function rAe(e) {
  var t = e.get("coordinateSystem");
  return bt(tAe, t) >= 0;
}
function Dl(e) {
  return process.env.NODE_ENV !== "production" && Qe(e), e + "Axis";
}
function nAe(e, t) {
  var r = We(), n = [], i = We();
  e.eachComponent({
    mainType: "dataZoom",
    query: t
  }, function(c) {
    i.get(c.uid) || s(c);
  });
  var o;
  do
    o = !1, e.eachComponent("dataZoom", a);
  while (o);
  function a(c) {
    !i.get(c.uid) && l(c) && (s(c), o = !0);
  }
  function s(c) {
    i.set(c.uid, !0), n.push(c), u(c);
  }
  function l(c) {
    var d = !1;
    return c.eachTargetAxis(function(h, f) {
      var p = r.get(h);
      p && p[f] && (d = !0);
    }), d;
  }
  function u(c) {
    c.eachTargetAxis(function(d, h) {
      (r.get(d) || r.set(d, []))[h] = !0;
    });
  }
  return n;
}
function sU(e) {
  var t = e.ecModel, r = {
    infoList: [],
    infoMap: We()
  };
  return e.eachTargetAxis(function(n, i) {
    var o = t.getComponent(Dl(n), i);
    if (o) {
      var a = o.getCoordSysModel();
      if (a) {
        var s = a.uid, l = r.infoMap.get(s);
        l || (l = {
          model: a,
          axisModels: []
        }, r.infoList.push(l), r.infoMap.set(s, l)), l.axisModels.push(o);
      }
    }
  }), r;
}
var Ex = (
  /** @class */
  function() {
    function e() {
      this.indexList = [], this.indexMap = [];
    }
    return e.prototype.add = function(t) {
      this.indexMap[t] || (this.indexList.push(t), this.indexMap[t] = !0);
    }, e;
  }()
), tv = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._autoThrottle = !0, r._noTarget = !0, r._rangePropMode = ["percent", "percent"], r;
    }
    return t.prototype.init = function(r, n, i) {
      var o = r4(r);
      this.settledOption = o, this.mergeDefaultAndTheme(r, i), this._doInit(o);
    }, t.prototype.mergeOption = function(r) {
      var n = r4(r);
      yt(this.option, r, !0), yt(this.settledOption, n, !0), this._doInit(n);
    }, t.prototype._doInit = function(r) {
      var n = this.option;
      this._setDefaultThrottle(r), this._updateRangeUse(r);
      var i = this.settledOption;
      B([["start", "startValue"], ["end", "endValue"]], function(o, a) {
        this._rangePropMode[a] === "value" && (n[o[0]] = i[o[0]] = null);
      }, this), this._resetTarget();
    }, t.prototype._resetTarget = function() {
      var r = this.get("orient", !0), n = this._targetAxisInfoMap = We(), i = this._fillSpecifiedTargetAxis(n);
      i ? this._orient = r || this._makeAutoOrientByTargetAxis() : (this._orient = r || "horizontal", this._fillAutoTargetAxisByOrient(n, this._orient)), this._noTarget = !0, n.each(function(o) {
        o.indexList.length && (this._noTarget = !1);
      }, this);
    }, t.prototype._fillSpecifiedTargetAxis = function(r) {
      var n = !1;
      return B(t4, function(i) {
        var o = this.getReferringComponents(Dl(i), Rve);
        if (o.specified) {
          n = !0;
          var a = new Ex();
          B(o.models, function(s) {
            a.add(s.componentIndex);
          }), r.set(i, a);
        }
      }, this), n;
    }, t.prototype._fillAutoTargetAxisByOrient = function(r, n) {
      var i = this.ecModel, o = !0;
      if (o) {
        var a = n === "vertical" ? "y" : "x", s = i.findComponents({
          mainType: a + "Axis"
        });
        l(s, a);
      }
      if (o) {
        var s = i.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", !0) === n;
          }
        });
        l(s, "single");
      }
      function l(u, c) {
        var d = u[0];
        if (d) {
          var h = new Ex();
          if (h.add(d.componentIndex), r.set(c, h), o = !1, c === "x" || c === "y") {
            var f = d.getReferringComponents("grid", un).models[0];
            f && B(u, function(p) {
              d.componentIndex !== p.componentIndex && f === p.getReferringComponents("grid", un).models[0] && h.add(p.componentIndex);
            });
          }
        }
      }
      o && B(t4, function(u) {
        if (o) {
          var c = i.findComponents({
            mainType: Dl(u),
            filter: function(h) {
              return h.get("type", !0) === "category";
            }
          });
          if (c[0]) {
            var d = new Ex();
            d.add(c[0].componentIndex), r.set(u, d), o = !1;
          }
        }
      }, this);
    }, t.prototype._makeAutoOrientByTargetAxis = function() {
      var r;
      return this.eachTargetAxis(function(n) {
        !r && (r = n);
      }, this), r === "y" ? "vertical" : "horizontal";
    }, t.prototype._setDefaultThrottle = function(r) {
      if (r.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var n = this.ecModel.option;
        this.option.throttle = n.animation && n.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, t.prototype._updateRangeUse = function(r) {
      var n = this._rangePropMode, i = this.get("rangeMode");
      B([["start", "startValue"], ["end", "endValue"]], function(o, a) {
        var s = r[o[0]] != null, l = r[o[1]] != null;
        s && !l ? n[a] = "percent" : !s && l ? n[a] = "value" : i ? n[a] = i[a] : s && (n[a] = "percent");
      });
    }, t.prototype.noTarget = function() {
      return this._noTarget;
    }, t.prototype.getFirstTargetAxisModel = function() {
      var r;
      return this.eachTargetAxis(function(n, i) {
        r == null && (r = this.ecModel.getComponent(Dl(n), i));
      }, this), r;
    }, t.prototype.eachTargetAxis = function(r, n) {
      this._targetAxisInfoMap.each(function(i, o) {
        B(i.indexList, function(a) {
          r.call(n, o, a);
        });
      });
    }, t.prototype.getAxisProxy = function(r, n) {
      var i = this.getAxisModel(r, n);
      if (i)
        return i.__dzAxisProxy;
    }, t.prototype.getAxisModel = function(r, n) {
      process.env.NODE_ENV !== "production" && Qe(r && n != null);
      var i = this._targetAxisInfoMap.get(r);
      if (i && i.indexMap[n])
        return this.ecModel.getComponent(Dl(r), n);
    }, t.prototype.setRawRange = function(r) {
      var n = this.option, i = this.settledOption;
      B([["start", "startValue"], ["end", "endValue"]], function(o) {
        (r[o[0]] != null || r[o[1]] != null) && (n[o[0]] = i[o[0]] = r[o[0]], n[o[1]] = i[o[1]] = r[o[1]]);
      }, this), this._updateRangeUse(r);
    }, t.prototype.setCalculatedRange = function(r) {
      var n = this.option;
      B(["start", "startValue", "end", "endValue"], function(i) {
        n[i] = r[i];
      });
    }, t.prototype.getPercentRange = function() {
      var r = this.findRepresentativeAxisProxy();
      if (r)
        return r.getDataPercentWindow();
    }, t.prototype.getValueRange = function(r, n) {
      if (r == null && n == null) {
        var i = this.findRepresentativeAxisProxy();
        if (i)
          return i.getDataValueWindow();
      } else
        return this.getAxisProxy(r, n).getDataValueWindow();
    }, t.prototype.findRepresentativeAxisProxy = function(r) {
      if (r)
        return r.__dzAxisProxy;
      for (var n, i = this._targetAxisInfoMap.keys(), o = 0; o < i.length; o++)
        for (var a = i[o], s = this._targetAxisInfoMap.get(a), l = 0; l < s.indexList.length; l++) {
          var u = this.getAxisProxy(a, s.indexList[l]);
          if (u.hostedBy(this))
            return u;
          n || (n = u);
        }
      return n;
    }, t.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, t.prototype.getOrient = function() {
      return process.env.NODE_ENV !== "production" && Qe(this._orient), this._orient;
    }, t.type = "dataZoom", t.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], t.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, t;
  }(Rt)
);
function r4(e) {
  var t = {};
  return B(["start", "end", "startValue", "endValue", "throttle"], function(r) {
    e.hasOwnProperty(r) && (t[r] = e[r]);
  }), t;
}
var iAe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "dataZoom.select", t;
  }(tv)
), eA = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i, o) {
      this.dataZoomModel = r, this.ecModel = n, this.api = i;
    }, t.type = "dataZoom", t;
  }(Rr)
), oAe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "dataZoom.select", t;
  }(eA)
), Kd = B, n4 = Ji, aAe = (
  /** @class */
  function() {
    function e(t, r, n, i) {
      this._dimName = t, this._axisIndex = r, this.ecModel = i, this._dataZoomModel = n;
    }
    return e.prototype.hostedBy = function(t) {
      return this._dataZoomModel === t;
    }, e.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, e.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, e.prototype.getTargetSeriesModels = function() {
      var t = [];
      return this.ecModel.eachSeries(function(r) {
        if (rAe(r)) {
          var n = Dl(this._dimName), i = r.getReferringComponents(n, un).models[0];
          i && this._axisIndex === i.componentIndex && t.push(r);
        }
      }, this), t;
    }, e.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, e.prototype.getMinMaxSpan = function() {
      return et(this._minMaxSpan);
    }, e.prototype.calculateDataWindow = function(t) {
      var r = this._dataExtent, n = this.getAxisModel(), i = n.axis.scale, o = this._dataZoomModel.getRangePropMode(), a = [0, 100], s = [], l = [], u;
      Kd(["start", "end"], function(h, f) {
        var p = t[h], g = t[h + "Value"];
        o[f] === "percent" ? (p == null && (p = a[f]), g = i.parse(nr(p, a, r))) : (u = !0, g = g == null ? r[f] : i.parse(g), p = nr(g, r, a)), l[f] = g == null || isNaN(g) ? r[f] : g, s[f] = p == null || isNaN(p) ? a[f] : p;
      }), n4(l), n4(s);
      var c = this._minMaxSpan;
      u ? d(l, s, r, a, !1) : d(s, l, a, r, !0);
      function d(h, f, p, g, v) {
        var m = v ? "Span" : "ValueSpan";
        Qc(0, h, p, "all", c["min" + m], c["max" + m]);
        for (var y = 0; y < 2; y++)
          f[y] = nr(h[y], p, g, !0), v && (f[y] = i.parse(f[y]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, e.prototype.reset = function(t) {
      if (t === this._dataZoomModel) {
        var r = this.getTargetSeriesModels();
        this._dataExtent = sAe(this, this._dimName, r), this._updateMinMaxSpan();
        var n = this.calculateDataWindow(t.settledOption);
        this._valueWindow = n.valueWindow, this._percentWindow = n.percentWindow, this._setAxisModel();
      }
    }, e.prototype.filterData = function(t, r) {
      if (t !== this._dataZoomModel)
        return;
      var n = this._dimName, i = this.getTargetSeriesModels(), o = t.get("filterMode"), a = this._valueWindow;
      if (o === "none")
        return;
      Kd(i, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(n);
        if (c.length) {
          if (o === "weakFilter") {
            var d = u.getStore(), h = ge(c, function(f) {
              return u.getDimensionIndex(f);
            }, u);
            u.filterSelf(function(f) {
              for (var p, g, v, m = 0; m < c.length; m++) {
                var y = d.get(h[m], f), C = !isNaN(y), S = y < a[0], b = y > a[1];
                if (C && !S && !b)
                  return !0;
                C && (v = !0), S && (p = !0), b && (g = !0);
              }
              return v && p && g;
            });
          } else
            Kd(c, function(f) {
              if (o === "empty")
                l.setData(u = u.map(f, function(g) {
                  return s(g) ? g : NaN;
                }));
              else {
                var p = {};
                p[f] = a, u.selectRange(p);
              }
            });
          Kd(c, function(f) {
            u.setApproximateExtent(a, f);
          });
        }
      });
      function s(l) {
        return l >= a[0] && l <= a[1];
      }
    }, e.prototype._updateMinMaxSpan = function() {
      var t = this._minMaxSpan = {}, r = this._dataZoomModel, n = this._dataExtent;
      Kd(["min", "max"], function(i) {
        var o = r.get(i + "Span"), a = r.get(i + "ValueSpan");
        a != null && (a = this.getAxisModel().axis.scale.parse(a)), a != null ? o = nr(n[0] + a, n, [0, 100], !0) : o != null && (a = nr(o, [0, 100], n, !0) - n[0]), t[i + "Span"] = o, t[i + "ValueSpan"] = a;
      }, this);
    }, e.prototype._setAxisModel = function() {
      var t = this.getAxisModel(), r = this._percentWindow, n = this._valueWindow;
      if (r) {
        var i = oM(n, [0, 500]);
        i = Math.min(i, 20);
        var o = t.axis.scale.rawExtentInfo;
        r[0] !== 0 && o.setDeterminedMinMax("min", +n[0].toFixed(i)), r[1] !== 100 && o.setDeterminedMinMax("max", +n[1].toFixed(i)), o.freeze();
      }
    }, e;
  }()
);
function sAe(e, t, r) {
  var n = [1 / 0, -1 / 0];
  Kd(r, function(a) {
    Rwe(n, a.getData(), t);
  });
  var i = e.getAxisModel(), o = x7(i.axis.scale, i, n).calculate();
  return [o.min, o.max];
}
var lAe = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(e) {
    function t(i) {
      e.eachComponent("dataZoom", function(o) {
        o.eachTargetAxis(function(a, s) {
          var l = e.getComponent(Dl(a), s);
          i(a, s, l, o);
        });
      });
    }
    t(function(i, o, a, s) {
      a.__dzAxisProxy = null;
    });
    var r = [];
    t(function(i, o, a, s) {
      a.__dzAxisProxy || (a.__dzAxisProxy = new aAe(i, o, s, e), r.push(a.__dzAxisProxy));
    });
    var n = We();
    return B(r, function(i) {
      B(i.getTargetSeriesModels(), function(o) {
        n.set(o.uid, o);
      });
    }), n;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(e, t) {
    e.eachComponent("dataZoom", function(r) {
      r.eachTargetAxis(function(n, i) {
        r.getAxisProxy(n, i).reset(r);
      }), r.eachTargetAxis(function(n, i) {
        r.getAxisProxy(n, i).filterData(r, t);
      });
    }), e.eachComponent("dataZoom", function(r) {
      var n = r.findRepresentativeAxisProxy();
      if (n) {
        var i = n.getDataPercentWindow(), o = n.getDataValueWindow();
        r.setCalculatedRange({
          start: i[0],
          end: i[1],
          startValue: o[0],
          endValue: o[1]
        });
      }
    });
  }
};
function uAe(e) {
  e.registerAction("dataZoom", function(t, r) {
    var n = nAe(r, t);
    B(n, function(i) {
      i.setRawRange({
        start: t.start,
        end: t.end,
        startValue: t.startValue,
        endValue: t.endValue
      });
    });
  });
}
var i4 = !1;
function tA(e) {
  i4 || (i4 = !0, e.registerProcessor(e.PRIORITY.PROCESSOR.FILTER, lAe), uAe(e), e.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function cAe(e) {
  e.registerComponentModel(iAe), e.registerComponentView(oAe), tA(e);
}
var Eo = (
  /** @class */
  /* @__PURE__ */ function() {
    function e() {
    }
    return e;
  }()
), lU = {};
function Yd(e, t) {
  lU[e] = t;
}
function uU(e) {
  return lU[e];
}
var dAe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.optionUpdated = function() {
      e.prototype.optionUpdated.apply(this, arguments);
      var r = this.ecModel;
      B(this.option.feature, function(n, i) {
        var o = uU(i);
        o && (o.getDefaultOption && (o.defaultOption = o.getDefaultOption(r)), yt(n, o.defaultOption));
      });
    }, t.type = "toolbox", t.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, t.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, t;
  }(Rt)
);
function hAe(e, t, r) {
  var n = t.getBoxLayoutParams(), i = t.get("padding"), o = {
    width: r.getWidth(),
    height: r.getHeight()
  }, a = hn(n, o, i);
  pc(t.get("orient"), e, t.get("itemGap"), a.width, a.height), KS(e, n, o, i);
}
function cU(e, t) {
  var r = Kc(t.get("padding")), n = t.getItemStyle(["color", "opacity"]);
  return n.fill = t.get("backgroundColor"), e = new Bt({
    shape: {
      x: e.x - r[3],
      y: e.y - r[0],
      width: e.width + r[1] + r[3],
      height: e.height + r[0] + r[2],
      r: t.get("borderRadius")
    },
    style: n,
    silent: !0,
    z2: -1
  }), e;
}
var fAe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.render = function(r, n, i, o) {
      var a = this.group;
      if (a.removeAll(), !r.get("show"))
        return;
      var s = +r.get("itemSize"), l = r.get("orient") === "vertical", u = r.get("feature") || {}, c = this._features || (this._features = {}), d = [];
      B(u, function(p, g) {
        d.push(g);
      }), new Ws(this._featureNames || [], d).add(h).update(h).remove(dt(h, null)).execute(), this._featureNames = d;
      function h(p, g) {
        var v = d[p], m = d[g], y = u[v], C = new cr(y, r, r.ecModel), S;
        if (o && o.newTitle != null && o.featureName === v && (y.title = o.newTitle), v && !m) {
          if (pAe(v))
            S = {
              onclick: C.option.onclick,
              featureName: v
            };
          else {
            var b = uU(v);
            if (!b)
              return;
            S = new b();
          }
          c[v] = S;
        } else if (S = c[m], !S)
          return;
        S.uid = df("toolbox-feature"), S.model = C, S.ecModel = n, S.api = i;
        var w = S instanceof Eo;
        if (!v && m) {
          w && S.dispose && S.dispose(n, i);
          return;
        }
        if (!C.get("show") || w && S.unusable) {
          w && S.remove && S.remove(n, i);
          return;
        }
        f(C, S, v), C.setIconStatus = function(x, E) {
          var R = this.option, _ = this.iconPaths;
          R.iconStatus = R.iconStatus || {}, R.iconStatus[x] = E, _[x] && (E === "emphasis" ? zs : $s)(_[x]);
        }, S instanceof Eo && S.render && S.render(C, n, i, o);
      }
      function f(p, g, v) {
        var m = p.getModel("iconStyle"), y = p.getModel(["emphasis", "iconStyle"]), C = g instanceof Eo && g.getIcons ? g.getIcons() : p.get("icon"), S = p.get("title") || {}, b, w;
        Fe(C) ? (b = {}, b[v] = C) : b = C, Fe(S) ? (w = {}, w[v] = S) : w = S;
        var x = p.iconPaths = {};
        B(b, function(E, R) {
          var _ = lf(E, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          _.setStyle(m.getItemStyle());
          var P = _.ensureState("emphasis");
          P.style = y.getItemStyle();
          var D = new Vt({
            style: {
              text: w[R],
              align: y.get("textAlign"),
              borderRadius: y.get("textBorderRadius"),
              padding: y.get("textPadding"),
              fill: null,
              font: EM({
                fontStyle: y.get("textFontStyle"),
                fontFamily: y.get("textFontFamily"),
                fontSize: y.get("textFontSize"),
                fontWeight: y.get("textFontWeight")
              }, n)
            },
            ignore: !0
          });
          _.setTextContent(D), uf({
            el: _,
            componentModel: r,
            itemName: R,
            formatterParamsExtra: {
              title: w[R]
            }
          }), _.__title = w[R], _.on("mouseover", function() {
            var I = y.getItemStyle(), A = l ? r.get("right") == null && r.get("left") !== "right" ? "right" : "left" : r.get("bottom") == null && r.get("top") !== "bottom" ? "bottom" : "top";
            D.setStyle({
              fill: y.get("textFill") || I.fill || I.stroke || "#000",
              backgroundColor: y.get("textBackgroundColor")
            }), _.setTextConfig({
              position: y.get("textPosition") || A
            }), D.ignore = !r.get("showTitle"), i.enterEmphasis(this);
          }).on("mouseout", function() {
            p.get(["iconStatus", R]) !== "emphasis" && i.leaveEmphasis(this), D.hide();
          }), (p.get(["iconStatus", R]) === "emphasis" ? zs : $s)(_), a.add(_), _.on("click", ke(g.onclick, g, n, i, R)), x[R] = _;
        });
      }
      hAe(a, r, i), a.add(cU(a.getBoundingRect(), r)), l || a.eachChild(function(p) {
        var g = p.__title, v = p.ensureState("emphasis"), m = v.textConfig || (v.textConfig = {}), y = p.getTextContent(), C = y && y.ensureState("emphasis");
        if (C && !Ye(C) && g) {
          var S = C.style || (C.style = {}), b = _v(g, Vt.makeFont(S)), w = p.x + a.x, x = p.y + a.y + s, E = !1;
          x + b.height > i.getHeight() && (m.position = "top", E = !0);
          var R = E ? -5 - b.height : s + 10;
          w + b.width / 2 > i.getWidth() ? (m.position = ["100%", R], S.align = "right") : w - b.width / 2 < 0 && (m.position = [0, R], S.align = "left");
        }
      });
    }, t.prototype.updateView = function(r, n, i, o) {
      B(this._features, function(a) {
        a instanceof Eo && a.updateView && a.updateView(a.model, n, i, o);
      });
    }, t.prototype.remove = function(r, n) {
      B(this._features, function(i) {
        i instanceof Eo && i.remove && i.remove(r, n);
      }), this.group.removeAll();
    }, t.prototype.dispose = function(r, n) {
      B(this._features, function(i) {
        i instanceof Eo && i.dispose && i.dispose(r, n);
      });
    }, t.type = "toolbox", t;
  }(Rr)
);
function pAe(e) {
  return e.indexOf("my") === 0;
}
var gAe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(r, n) {
      var i = this.model, o = i.get("name") || r.get("title.0.text") || "echarts", a = n.getZr().painter.getType() === "svg", s = a ? "svg" : i.get("type", !0) || "png", l = n.getConnectedDataURL({
        type: s,
        backgroundColor: i.get("backgroundColor", !0) || r.get("backgroundColor") || "#fff",
        connectedBackgroundColor: i.get("connectedBackgroundColor"),
        excludeComponents: i.get("excludeComponents"),
        pixelRatio: i.get("pixelRatio")
      }), u = kt.browser;
      if (typeof MouseEvent == "function" && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = o + "." + s, c.target = "_blank", c.href = l;
        var d = new MouseEvent("click", {
          // some micro front-end framework， window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        c.dispatchEvent(d);
      } else if (window.navigator.msSaveOrOpenBlob || a) {
        var h = l.split(","), f = h[0].indexOf("base64") > -1, p = a ? decodeURIComponent(h[1]) : h[1];
        f && (p = window.atob(p));
        var g = o + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, m = new Uint8Array(v); v--; )
            m[v] = p.charCodeAt(v);
          var y = new Blob([m]);
          window.navigator.msSaveOrOpenBlob(y, g);
        } else {
          var C = document.createElement("iframe");
          document.body.appendChild(C);
          var S = C.contentWindow, b = S.document;
          b.open("image/svg+xml", "replace"), b.write(p), b.close(), S.focus(), b.execCommand("SaveAs", !0, g), document.body.removeChild(C);
        }
      } else {
        var w = i.get("lang"), x = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (w && w[0] || "") + '" /></body>', E = window.open();
        E.document.write(x), E.document.title = o;
      }
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: r.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: r.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return n;
    }, t;
  }(Eo)
), o4 = "__ec_magicType_stack__", vAe = [["line", "bar"], ["stack"]], mAe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.getIcons = function() {
      var r = this.model, n = r.get("icon"), i = {};
      return B(r.get("type"), function(o) {
        n[o] && (i[o] = n[o]);
      }), i;
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: r.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return n;
    }, t.prototype.onclick = function(r, n, i) {
      var o = this.model, a = o.get(["seriesIndex", i]);
      if (a4[i]) {
        var s = {
          series: []
        }, l = function(d) {
          var h = d.subType, f = d.id, p = a4[i](h, f, d, o);
          p && (Xe(p, d.option), s.series.push(p));
          var g = d.coordinateSystem;
          if (g && g.type === "cartesian2d" && (i === "line" || i === "bar")) {
            var v = g.getAxesByScale("ordinal")[0];
            if (v) {
              var m = v.dim, y = m + "Axis", C = d.getReferringComponents(y, un).models[0], S = C.componentIndex;
              s[y] = s[y] || [];
              for (var b = 0; b <= S; b++)
                s[y][S] = s[y][S] || {};
              s[y][S].boundaryGap = i === "bar";
            }
          }
        };
        B(vAe, function(d) {
          bt(d, i) >= 0 && B(d, function(h) {
            o.setIconStatus(h, "normal");
          });
        }), o.setIconStatus(i, "emphasis"), r.eachComponent({
          mainType: "series",
          query: a == null ? null : {
            seriesIndex: a
          }
        }, l);
        var u, c = i;
        i === "stack" && (u = yt({
          stack: o.option.title.tiled,
          tiled: o.option.title.stack
        }, o.option.title), o.get(["iconStatus", i]) !== "emphasis" && (c = "tiled")), n.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, t;
  }(Eo)
), a4 = {
  line: function(e, t, r, n) {
    if (e === "bar")
      return yt({
        id: t,
        type: "line",
        // Preserve data related option
        data: r.get("data"),
        stack: r.get("stack"),
        markPoint: r.get("markPoint"),
        markLine: r.get("markLine")
      }, n.get(["option", "line"]) || {}, !0);
  },
  bar: function(e, t, r, n) {
    if (e === "line")
      return yt({
        id: t,
        type: "bar",
        // Preserve data related option
        data: r.get("data"),
        stack: r.get("stack"),
        markPoint: r.get("markPoint"),
        markLine: r.get("markLine")
      }, n.get(["option", "bar"]) || {}, !0);
  },
  stack: function(e, t, r, n) {
    var i = r.get("stack") === o4;
    if (e === "line" || e === "bar")
      return n.setIconStatus("stack", i ? "normal" : "emphasis"), yt({
        id: t,
        stack: i ? "" : o4
      }, n.get(["option", "stack"]) || {}, !0);
  }
};
wa({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(e, t) {
  t.mergeOption(e.newOption);
});
var dw = new Array(60).join("-"), Hh = "	";
function yAe(e) {
  var t = {}, r = [], n = [];
  return e.eachRawSeries(function(i) {
    var o = i.coordinateSystem;
    if (o && (o.type === "cartesian2d" || o.type === "polar")) {
      var a = o.getBaseAxis();
      if (a.type === "category") {
        var s = a.dim + "_" + a.index;
        t[s] || (t[s] = {
          categoryAxis: a,
          valueAxis: o.getOtherAxis(a),
          series: []
        }, n.push({
          axisDim: a.dim,
          axisIndex: a.index
        })), t[s].series.push(i);
      } else
        r.push(i);
    } else
      r.push(i);
  }), {
    seriesGroupByCategoryAxis: t,
    other: r,
    meta: n
  };
}
function CAe(e) {
  var t = [];
  return B(e, function(r, n) {
    var i = r.categoryAxis, o = r.valueAxis, a = o.dim, s = [" "].concat(ge(r.series, function(f) {
      return f.name;
    })), l = [i.model.getCategories()];
    B(r.series, function(f) {
      var p = f.getRawData();
      l.push(f.getRawData().mapArray(p.mapDimension(a), function(g) {
        return g;
      }));
    });
    for (var u = [s.join(Hh)], c = 0; c < l[0].length; c++) {
      for (var d = [], h = 0; h < l.length; h++)
        d.push(l[h][c]);
      u.push(d.join(Hh));
    }
    t.push(u.join(`
`));
  }), t.join(`

` + dw + `

`);
}
function SAe(e) {
  return ge(e, function(t) {
    var r = t.getRawData(), n = [t.name], i = [];
    return r.each(r.dimensions, function() {
      for (var o = arguments.length, a = arguments[o - 1], s = r.getName(a), l = 0; l < o - 1; l++)
        i[l] = arguments[l];
      n.push((s ? s + Hh : "") + i.join(Hh));
    }), n.join(`
`);
  }).join(`

` + dw + `

`);
}
function wAe(e) {
  var t = yAe(e);
  return {
    value: ir([CAe(t.seriesGroupByCategoryAxis), SAe(t.other)], function(r) {
      return !!r.replace(/[\n\t\s]/g, "");
    }).join(`

` + dw + `

`),
    meta: t.meta
  };
}
function AC(e) {
  return e.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function bAe(e) {
  var t = e.slice(0, e.indexOf(`
`));
  if (t.indexOf(Hh) >= 0)
    return !0;
}
var rT = new RegExp("[" + Hh + "]+", "g");
function xAe(e) {
  for (var t = e.split(/\n+/g), r = AC(t.shift()).split(rT), n = [], i = ge(r, function(l) {
    return {
      name: l,
      data: []
    };
  }), o = 0; o < t.length; o++) {
    var a = AC(t[o]).split(rT);
    n.push(a.shift());
    for (var s = 0; s < a.length; s++)
      i[s] && (i[s].data[o] = a[s]);
  }
  return {
    series: i,
    categories: n
  };
}
function EAe(e) {
  for (var t = e.split(/\n+/g), r = AC(t.shift()), n = [], i = 0; i < t.length; i++) {
    var o = AC(t[i]);
    if (o) {
      var a = o.split(rT), s = "", l = void 0, u = !1;
      isNaN(a[0]) ? (u = !0, s = a[0], a = a.slice(1), n[i] = {
        name: s,
        value: []
      }, l = n[i].value) : l = n[i] = [];
      for (var c = 0; c < a.length; c++)
        l.push(+a[c]);
      l.length === 1 && (u ? n[i].value = l[0] : n[i] = l[0]);
    }
  }
  return {
    name: r,
    data: n
  };
}
function RAe(e, t) {
  var r = e.split(new RegExp(`
*` + dw + `
*`, "g")), n = {
    series: []
  };
  return B(r, function(i, o) {
    if (bAe(i)) {
      var a = xAe(i), s = t[o], l = s.axisDim + "Axis";
      s && (n[l] = n[l] || [], n[l][s.axisIndex] = {
        data: a.categories
      }, n.series = n.series.concat(a.series));
    } else {
      var a = EAe(i);
      n.series.push(a);
    }
  }), n;
}
var _Ae = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(r, n) {
      setTimeout(function() {
        n.dispatchAction({
          type: "hideTip"
        });
      });
      var i = n.getDom(), o = this.model;
      this._dom && i.removeChild(this._dom);
      var a = document.createElement("div");
      a.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", a.style.backgroundColor = o.get("backgroundColor") || "#fff";
      var s = document.createElement("h4"), l = o.get("lang") || [];
      s.innerHTML = l[0] || o.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = o.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var d = o.get("optionToContent"), h = o.get("contentToOption"), f = wAe(r);
      if (Ye(d)) {
        var p = d(n.getOption());
        Fe(p) ? u.innerHTML = p : zl(p) && u.appendChild(p);
      } else {
        c.readOnly = o.get("readOnly");
        var g = c.style;
        g.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", g.color = o.get("textColor"), g.borderColor = o.get("textareaBorderColor"), g.backgroundColor = o.get("textareaColor"), c.value = f.value, u.appendChild(c);
      }
      var v = f.meta, m = document.createElement("div");
      m.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var y = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", C = document.createElement("div"), S = document.createElement("div");
      y += ";background-color:" + o.get("buttonColor"), y += ";color:" + o.get("buttonTextColor");
      var b = this;
      function w() {
        i.removeChild(a), b._dom = null;
      }
      FR(C, "click", w), FR(S, "click", function() {
        if (h == null && d != null || h != null && d == null) {
          process.env.NODE_ENV !== "production" && Vr("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), w();
          return;
        }
        var x;
        try {
          Ye(h) ? x = h(u, n.getOption()) : x = RAe(c.value, v);
        } catch (E) {
          throw w(), new Error("Data view format error " + E);
        }
        x && n.dispatchAction({
          type: "changeDataView",
          newOption: x
        }), w();
      }), C.innerHTML = l[1], S.innerHTML = l[2], S.style.cssText = C.style.cssText = y, !o.get("readOnly") && m.appendChild(S), m.appendChild(C), a.appendChild(s), a.appendChild(u), a.appendChild(m), u.style.height = i.clientHeight - 80 + "px", i.appendChild(a), this._dom = a;
    }, t.prototype.remove = function(r, n) {
      this._dom && n.getDom().removeChild(this._dom);
    }, t.prototype.dispose = function(r, n) {
      this.remove(r, n);
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: r.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: r.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return n;
    }, t;
  }(Eo)
);
function TAe(e, t) {
  return ge(e, function(r, n) {
    var i = t && t[n];
    if (Ze(i) && !fe(i)) {
      var o = Ze(r) && !fe(r);
      o || (r = {
        value: r
      });
      var a = i.name != null && r.name == null;
      return r = Xe(r, i), a && delete r.name, r;
    } else
      return r;
  });
}
wa({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(e, t) {
  var r = [];
  B(e.newOption.series, function(n) {
    var i = t.getSeriesByName(n.name)[0];
    if (!i)
      r.push(se({
        // Default is scatter
        type: "scatter"
      }, n));
    else {
      var o = i.get("data");
      r.push({
        name: n.name,
        data: TAe(n.data, o)
      });
    }
  }), t.mergeOption(Xe({
    series: r
  }, e.newOption));
});
var dU = B, hU = Gt();
function PAe(e, t) {
  var r = rA(e);
  dU(t, function(n, i) {
    for (var o = r.length - 1; o >= 0; o--) {
      var a = r[o];
      if (a[i])
        break;
    }
    if (o < 0) {
      var s = e.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: i
      })[0];
      if (s) {
        var l = s.getPercentRange();
        r[0][i] = {
          dataZoomId: i,
          start: l[0],
          end: l[1]
        };
      }
    }
  }), r.push(t);
}
function MAe(e) {
  var t = rA(e), r = t[t.length - 1];
  t.length > 1 && t.pop();
  var n = {};
  return dU(r, function(i, o) {
    for (var a = t.length - 1; a >= 0; a--)
      if (i = t[a][o], i) {
        n[o] = i;
        break;
      }
  }), n;
}
function DAe(e) {
  hU(e).snapshots = null;
}
function AAe(e) {
  return rA(e).length;
}
function rA(e) {
  var t = hU(e);
  return t.snapshots || (t.snapshots = [{}]), t.snapshots;
}
var IAe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.onclick = function(r, n) {
      DAe(r), n.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: r.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return n;
    }, t;
  }(Eo)
);
wa({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(e, t) {
  t.resetOption("recreate");
});
var FAe = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], nA = (
  /** @class */
  function() {
    function e(t, r, n) {
      var i = this;
      this._targetInfoList = [];
      var o = s4(r, t);
      B(LAe, function(a, s) {
        (!n || !n.include || bt(n.include, s) >= 0) && a(o, i._targetInfoList);
      });
    }
    return e.prototype.setOutputRanges = function(t, r) {
      return this.matchOutputRanges(t, r, function(n, i, o) {
        if ((n.coordRanges || (n.coordRanges = [])).push(i), !n.coordRange) {
          n.coordRange = i;
          var a = Rx[n.brushType](0, o, i);
          n.__rangeOffset = {
            offset: d4[n.brushType](a.values, n.range, [1, 1]),
            xyMinMax: a.xyMinMax
          };
        }
      }), t;
    }, e.prototype.matchOutputRanges = function(t, r, n) {
      B(t, function(i) {
        var o = this.findTargetInfo(i, r);
        o && o !== !0 && B(o.coordSyses, function(a) {
          var s = Rx[i.brushType](1, a, i.range, !0);
          n(i, s.values, a, r);
        });
      }, this);
    }, e.prototype.setInputRanges = function(t, r) {
      B(t, function(n) {
        var i = this.findTargetInfo(n, r);
        if (process.env.NODE_ENV !== "production" && (Qe(!i || i === !0 || n.coordRange, "coordRange must be specified when coord index specified."), Qe(!i || i !== !0 || n.range, "range must be specified in global brush.")), n.range = n.range || [], i && i !== !0) {
          n.panelId = i.panelId;
          var o = Rx[n.brushType](0, i.coordSys, n.coordRange), a = n.__rangeOffset;
          n.range = a ? d4[n.brushType](o.values, a.offset, OAe(o.xyMinMax, a.xyMinMax)) : o.values;
        }
      }, this);
    }, e.prototype.makePanelOpts = function(t, r) {
      return ge(this._targetInfoList, function(n) {
        var i = n.getPanelRect();
        return {
          panelId: n.panelId,
          defaultBrushType: r ? r(n) : null,
          clipPath: Cj(i),
          isTargetByCursor: wj(i, t, n.coordSysModel),
          getLinearBrushOtherExtent: Sj(i)
        };
      });
    }, e.prototype.controlSeries = function(t, r, n) {
      var i = this.findTargetInfo(t, n);
      return i === !0 || i && bt(i.coordSyses, r.coordinateSystem) >= 0;
    }, e.prototype.findTargetInfo = function(t, r) {
      for (var n = this._targetInfoList, i = s4(r, t), o = 0; o < n.length; o++) {
        var a = n[o], s = t.panelId;
        if (s) {
          if (a.panelId === s)
            return a;
        } else
          for (var l = 0; l < l4.length; l++)
            if (l4[l](i, a))
              return a;
      }
      return !0;
    }, e;
  }()
);
function nT(e) {
  return e[0] > e[1] && e.reverse(), e;
}
function s4(e, t) {
  return Jp(e, t, {
    includeMainTypes: FAe
  });
}
var LAe = {
  grid: function(e, t) {
    var r = e.xAxisModels, n = e.yAxisModels, i = e.gridModels, o = We(), a = {}, s = {};
    !r && !n && !i || (B(r, function(l) {
      var u = l.axis.grid.model;
      o.set(u.id, u), a[u.id] = !0;
    }), B(n, function(l) {
      var u = l.axis.grid.model;
      o.set(u.id, u), s[u.id] = !0;
    }), B(i, function(l) {
      o.set(l.id, l), a[l.id] = !0, s[l.id] = !0;
    }), o.each(function(l) {
      var u = l.coordinateSystem, c = [];
      B(u.getCartesians(), function(d, h) {
        (bt(r, d.getAxis("x").model) >= 0 || bt(n, d.getAxis("y").model) >= 0) && c.push(d);
      }), t.push({
        panelId: "grid--" + l.id,
        gridModel: l,
        coordSysModel: l,
        // Use the first one as the representitive coordSys.
        coordSys: c[0],
        coordSyses: c,
        getPanelRect: u4.grid,
        xAxisDeclared: a[l.id],
        yAxisDeclared: s[l.id]
      });
    }));
  },
  geo: function(e, t) {
    B(e.geoModels, function(r) {
      var n = r.coordinateSystem;
      t.push({
        panelId: "geo--" + r.id,
        geoModel: r,
        coordSysModel: r,
        coordSys: n,
        coordSyses: [n],
        getPanelRect: u4.geo
      });
    });
  }
}, l4 = [
  // grid
  function(e, t) {
    var r = e.xAxisModel, n = e.yAxisModel, i = e.gridModel;
    return !i && r && (i = r.axis.grid.model), !i && n && (i = n.axis.grid.model), i && i === t.gridModel;
  },
  // geo
  function(e, t) {
    var r = e.geoModel;
    return r && r === t.geoModel;
  }
], u4 = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var e = this.coordSys, t = e.getBoundingRect().clone();
    return t.applyTransform(Ll(e)), t;
  }
}, Rx = {
  lineX: dt(c4, 0),
  lineY: dt(c4, 1),
  rect: function(e, t, r, n) {
    var i = e ? t.pointToData([r[0][0], r[1][0]], n) : t.dataToPoint([r[0][0], r[1][0]], n), o = e ? t.pointToData([r[0][1], r[1][1]], n) : t.dataToPoint([r[0][1], r[1][1]], n), a = [nT([i[0], o[0]]), nT([i[1], o[1]])];
    return {
      values: a,
      xyMinMax: a
    };
  },
  polygon: function(e, t, r, n) {
    var i = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], o = ge(r, function(a) {
      var s = e ? t.pointToData(a, n) : t.dataToPoint(a, n);
      return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s;
    });
    return {
      values: o,
      xyMinMax: i
    };
  }
};
function c4(e, t, r, n) {
  process.env.NODE_ENV !== "production" && Qe(r.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  var i = r.getAxis(["x", "y"][e]), o = nT(ge([0, 1], function(s) {
    return t ? i.coordToData(i.toLocalCoord(n[s]), !0) : i.toGlobalCoord(i.dataToCoord(n[s]));
  })), a = [];
  return a[e] = o, a[1 - e] = [NaN, NaN], {
    values: o,
    xyMinMax: a
  };
}
var d4 = {
  lineX: dt(h4, 0),
  lineY: dt(h4, 1),
  rect: function(e, t, r) {
    return [[e[0][0] - r[0] * t[0][0], e[0][1] - r[0] * t[0][1]], [e[1][0] - r[1] * t[1][0], e[1][1] - r[1] * t[1][1]]];
  },
  polygon: function(e, t, r) {
    return ge(e, function(n, i) {
      return [n[0] - r[0] * t[i][0], n[1] - r[1] * t[i][1]];
    });
  }
};
function h4(e, t, r, n) {
  return [t[0] - n[e] * r[0], t[1] - n[e] * r[1]];
}
function OAe(e, t) {
  var r = f4(e), n = f4(t), i = [r[0] / n[0], r[1] / n[1]];
  return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i;
}
function f4(e) {
  return e ? [e[0][1] - e[0][0], e[1][1] - e[1][0]] : [NaN, NaN];
}
var iT = B, NAe = Sve("toolbox-dataZoom_"), kAe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.render = function(r, n, i, o) {
      this._brushController || (this._brushController = new ID(i.getZr()), this._brushController.on("brush", ke(this._onBrush, this)).mount()), GAe(r, n, this, o, i), BAe(r, n);
    }, t.prototype.onclick = function(r, n, i) {
      VAe[i].call(this);
    }, t.prototype.remove = function(r, n) {
      this._brushController && this._brushController.unmount();
    }, t.prototype.dispose = function(r, n) {
      this._brushController && this._brushController.dispose();
    }, t.prototype._onBrush = function(r) {
      var n = r.areas;
      if (!r.isEnd || !n.length)
        return;
      var i = {}, o = this.ecModel;
      this._brushController.updateCovers([]);
      var a = new nA(iA(this.model), o, {
        include: ["grid"]
      });
      a.matchOutputRanges(n, o, function(u, c, d) {
        if (d.type === "cartesian2d") {
          var h = u.brushType;
          h === "rect" ? (s("x", d, c[0]), s("y", d, c[1])) : s({
            lineX: "x",
            lineY: "y"
          }[h], d, c);
        }
      }), PAe(o, i), this._dispatchZoomAction(i);
      function s(u, c, d) {
        var h = c.getAxis(u), f = h.model, p = l(u, f, o), g = p.findRepresentativeAxisProxy(f).getMinMaxSpan();
        (g.minValueSpan != null || g.maxValueSpan != null) && (d = Qc(0, d.slice(), h.scale.getExtent(), 0, g.minValueSpan, g.maxValueSpan)), p && (i[p.id] = {
          dataZoomId: p.id,
          startValue: d[0],
          endValue: d[1]
        });
      }
      function l(u, c, d) {
        var h;
        return d.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(f) {
          var p = f.getAxisModel(u, c.componentIndex);
          p && (h = f);
        }), h;
      }
    }, t.prototype._dispatchZoomAction = function(r) {
      var n = [];
      iT(r, function(i, o) {
        n.push(et(i));
      }), n.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: n
      });
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: r.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return n;
    }, t;
  }(Eo)
), VAe = {
  zoom: function() {
    var e = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: e
    });
  },
  back: function() {
    this._dispatchZoomAction(MAe(this.ecModel));
  }
};
function iA(e) {
  var t = {
    xAxisIndex: e.get("xAxisIndex", !0),
    yAxisIndex: e.get("yAxisIndex", !0),
    xAxisId: e.get("xAxisId", !0),
    yAxisId: e.get("yAxisId", !0)
  };
  return t.xAxisIndex == null && t.xAxisId == null && (t.xAxisIndex = "all"), t.yAxisIndex == null && t.yAxisId == null && (t.yAxisIndex = "all"), t;
}
function BAe(e, t) {
  e.setIconStatus("back", AAe(t) > 1 ? "emphasis" : "normal");
}
function GAe(e, t, r, n, i) {
  var o = r._isZoomActive;
  n && n.type === "takeGlobalCursor" && (o = n.key === "dataZoomSelect" ? n.dataZoomSelectActive : !1), r._isZoomActive = o, e.setIconStatus("zoom", o ? "emphasis" : "normal");
  var a = new nA(iA(e), t, {
    include: ["grid"]
  }), s = a.makePanelOpts(i, function(l) {
    return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
  });
  r._brushController.setPanels(s).enableBrush(o && s.length ? {
    brushType: "auto",
    brushStyle: e.getModel("brushStyle").getItemStyle()
  } : !1);
}
Yye("dataZoom", function(e) {
  var t = e.getComponent("toolbox", 0), r = ["feature", "dataZoom"];
  if (!t || t.get(r) == null)
    return;
  var n = t.getModel(r), i = [], o = iA(n), a = Jp(e, o);
  iT(a.xAxisModels, function(l) {
    return s(l, "xAxis", "xAxisIndex");
  }), iT(a.yAxisModels, function(l) {
    return s(l, "yAxis", "yAxisIndex");
  });
  function s(l, u, c) {
    var d = l.componentIndex, h = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: n.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: NAe + u + d
    };
    h[c] = d, i.push(h);
  }
  return i;
});
function HAe(e) {
  e.registerComponentModel(dAe), e.registerComponentView(fAe), Yd("saveAsImage", gAe), Yd("magicType", mAe), Yd("dataView", _Ae), Yd("dataZoom", kAe), Yd("restore", IAe), _t(cAe);
}
var zAe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaut false (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "#fff",
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, t;
  }(Rt)
);
function fU(e) {
  var t = e.get("confine");
  return t != null ? !!t : e.get("renderMode") === "richText";
}
function pU(e) {
  if (kt.domSupported) {
    for (var t = document.documentElement.style, r = 0, n = e.length; r < n; r++)
      if (e[r] in t)
        return e[r];
  }
}
var gU = pU(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), $Ae = pU(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function vU(e, t) {
  if (!e)
    return t;
  t = IM(t, !0);
  var r = e.indexOf(t);
  return e = r === -1 ? t : "-" + e.slice(0, r) + "-" + t, e.toLowerCase();
}
function WAe(e, t) {
  var r = e.currentStyle || document.defaultView && document.defaultView.getComputedStyle(e);
  return r ? r[t] : null;
}
var jAe = vU($Ae, "transition"), oA = vU(gU, "transform"), UAe = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (kt.transform3dSupported ? "will-change:transform;" : "");
function KAe(e) {
  return e = e === "left" ? "right" : e === "right" ? "left" : e === "top" ? "bottom" : "top", e;
}
function YAe(e, t, r) {
  if (!Fe(r) || r === "inside")
    return "";
  var n = e.get("backgroundColor"), i = e.get("borderWidth");
  t = Ac(t);
  var o = KAe(r), a = Math.max(Math.round(i) * 1.5, 6), s = "", l = oA + ":", u;
  bt(["left", "right"], o) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = o === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = o === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, d = a + i, h = d * Math.abs(Math.cos(c)) + d * Math.abs(Math.sin(c)), f = Math.round(((h - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (h - d) / 2) * 100) / 100;
  s += ";" + o + ":-" + f + "px";
  var p = t + " solid " + i + "px;", g = ["position:absolute;width:" + a + "px;height:" + a + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + p, "border-right:" + p, "background-color:" + n + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function qAe(e, t) {
  var r = "cubic-bezier(0.23,1,0.32,1)", n = " " + e / 2 + "s " + r, i = "opacity" + n + ",visibility" + n;
  return t || (n = " " + e + "s " + r, i += kt.transformSupported ? "," + oA + n : ",left" + n + ",top" + n), jAe + ":" + i;
}
function p4(e, t, r) {
  var n = e.toFixed(0) + "px", i = t.toFixed(0) + "px";
  if (!kt.transformSupported)
    return r ? "top:" + i + ";left:" + n + ";" : [["top", i], ["left", n]];
  var o = kt.transform3dSupported, a = "translate" + (o ? "3d" : "") + "(" + n + "," + i + (o ? ",0" : "") + ")";
  return r ? "top:0;left:0;" + oA + ":" + a + ";" : [["top", 0], ["left", 0], [gU, a]];
}
function ZAe(e) {
  var t = [], r = e.get("fontSize"), n = e.getTextColor();
  n && t.push("color:" + n), t.push("font:" + e.getFont()), r && t.push("line-height:" + Math.round(r * 3 / 2) + "px");
  var i = e.get("textShadowColor"), o = e.get("textShadowBlur") || 0, a = e.get("textShadowOffsetX") || 0, s = e.get("textShadowOffsetY") || 0;
  return i && o && t.push("text-shadow:" + a + "px " + s + "px " + o + "px " + i), B(["decoration", "align"], function(l) {
    var u = e.get(l);
    u && t.push("text-" + l + ":" + u);
  }), t.join(";");
}
function XAe(e, t, r) {
  var n = [], i = e.get("transitionDuration"), o = e.get("backgroundColor"), a = e.get("shadowBlur"), s = e.get("shadowColor"), l = e.get("shadowOffsetX"), u = e.get("shadowOffsetY"), c = e.getModel("textStyle"), d = RW(e, "html"), h = l + "px " + u + "px " + a + "px " + s;
  return n.push("box-shadow:" + h), t && i && n.push(qAe(i, r)), o && n.push("background-color:" + o), B(["width", "color", "radius"], function(f) {
    var p = "border-" + f, g = IM(p), v = e.get(g);
    v != null && n.push(p + ":" + v + (f === "color" ? "" : "px"));
  }), n.push(ZAe(c)), d != null && n.push("padding:" + Kc(d).join("px ") + "px"), n.join(";") + ";";
}
function g4(e, t, r, n, i) {
  var o = t && t.painter;
  if (r) {
    var a = o && o.getViewportRoot();
    a && $pe(e, a, r, n, i);
  } else {
    e[0] = n, e[1] = i;
    var s = o && o.getViewportRootOffset();
    s && (e[0] += s.offsetLeft, e[1] += s.offsetTop);
  }
  e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var QAe = (
  /** @class */
  function() {
    function e(t, r) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, kt.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var i = this._zr = t.getZr(), o = r.appendTo, a = o && (Fe(o) ? document.querySelector(o) : zl(o) ? o : Ye(o) && o(t.getDom()));
      g4(this._styleCoord, i, a, t.getWidth() / 2, t.getHeight() / 2), (a || t.getDom()).appendChild(n), this._api = t, this._container = a;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = i.handler, c = i.painter.getViewportRoot();
          yo(c, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return e.prototype.update = function(t) {
      if (!this._container) {
        var r = this._api.getDom(), n = WAe(r, "position"), i = r.style;
        i.position !== "absolute" && n !== "absolute" && (i.position = "relative");
      }
      var o = t.get("alwaysShowContent");
      o && this._moveIfResized(), this._alwaysShowContent = o, this.el.className = t.get("className") || "";
    }, e.prototype.show = function(t, r) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, i = n.style, o = this._styleCoord;
      n.innerHTML ? i.cssText = UAe + XAe(t, !this._firstShow, this._longHide) + p4(o[0], o[1], !0) + ("border-color:" + Ac(r) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, e.prototype.setContent = function(t, r, n, i, o) {
      var a = this.el;
      if (t == null) {
        a.innerHTML = "";
        return;
      }
      var s = "";
      if (Fe(o) && n.get("trigger") === "item" && !fU(n) && (s = YAe(n, i, o)), Fe(t))
        a.innerHTML = t + s;
      else if (t) {
        a.innerHTML = "", fe(t) || (t = [t]);
        for (var l = 0; l < t.length; l++)
          zl(t[l]) && t[l].parentNode !== a && a.appendChild(t[l]);
        if (s && a.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, a.appendChild(u);
        }
      }
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el;
      return [t.offsetWidth, t.offsetHeight];
    }, e.prototype.moveTo = function(t, r) {
      var n = this._styleCoord;
      if (g4(n, this._zr, this._container, t, r), n[0] != null && n[1] != null) {
        var i = this.el.style, o = p4(n[0], n[1]);
        B(o, function(a) {
          i[a[0]] = a[1];
        });
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], r = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), r * this._zr.getHeight());
    }, e.prototype.hide = function() {
      var t = this, r = this.el.style;
      r.visibility = "hidden", r.opacity = "0", kt.transform3dSupported && (r.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return t._longHide = !0;
      }, 500);
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(ke(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this.el.parentNode;
      t && t.removeChild(this.el), this.el = this._container = null;
    }, e;
  }()
), JAe = (
  /** @class */
  function() {
    function e(t) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), m4(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return e.prototype.update = function(t) {
      var r = t.get("alwaysShowContent");
      r && this._moveIfResized(), this._alwaysShowContent = r;
    }, e.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, e.prototype.setContent = function(t, r, n, i, o) {
      var a = this;
      Ze(t) && er(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var s = n.getModel("textStyle");
      this.el = new Vt({
        style: {
          rich: r.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: i,
          textShadowColor: s.get("textShadowColor"),
          fill: n.get(["textStyle", "color"]),
          padding: RW(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), B(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        a.el.style[u] = n.get(u);
      }), B(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        a.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el, r = this.el.getBoundingRect(), n = v4(t.style);
      return [r.width + n.left + n.right, r.height + n.top + n.bottom];
    }, e.prototype.moveTo = function(t, r) {
      var n = this.el;
      if (n) {
        var i = this._styleCoord;
        m4(i, this._zr, t, r), t = i[0], r = i[1];
        var o = n.style, a = Cl(o.borderWidth || 0), s = v4(o);
        n.x = t + a + s.left, n.y = r + a + s.top, n.markRedraw();
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], r = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), r * this._zr.getHeight());
    }, e.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(ke(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, e;
  }()
);
function Cl(e) {
  return Math.max(0, e);
}
function v4(e) {
  var t = Cl(e.shadowBlur || 0), r = Cl(e.shadowOffsetX || 0), n = Cl(e.shadowOffsetY || 0);
  return {
    left: Cl(t - r),
    right: Cl(t + r),
    top: Cl(t - n),
    bottom: Cl(t + n)
  };
}
function m4(e, t, r, n) {
  e[0] = r, e[1] = n, e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var eIe = new Bt({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), tIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      if (!(kt.node || !n.getDom())) {
        var i = r.getComponent("tooltip"), o = this._renderMode = Tve(i.get("renderMode"));
        this._tooltipContent = o === "richText" ? new JAe(n) : new QAe(n, {
          appendTo: i.get("appendToBody", !0) ? "body" : i.get("appendTo", !0)
        });
      }
    }, t.prototype.render = function(r, n, i) {
      if (!(kt.node || !i.getDom())) {
        this.group.removeAll(), this._tooltipModel = r, this._ecModel = n, this._api = i;
        var o = this._tooltipContent;
        o.update(r), o.setEnterable(r.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && r.get("transitionDuration") ? gf(this, "_updatePosition", 50, "fixRate") : zg(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var r = this._tooltipModel, n = r.get("triggerOn");
      eU("itemTooltip", this._api, ke(function(i, o, a) {
        n !== "none" && (n.indexOf(i) >= 0 ? this._tryShow(o, a) : i === "leave" && this._hide(a));
      }, this));
    }, t.prototype._keepShow = function() {
      var r = this._tooltipModel, n = this._ecModel, i = this._api, o = r.get("triggerOn");
      if (this._lastX != null && this._lastY != null && o !== "none" && o !== "click") {
        var a = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !i.isDisposed() && a.manuallyShowTip(r, n, i, {
            x: a._lastX,
            y: a._lastY,
            dataByCoordSys: a._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(r, n, i, o) {
      if (!(o.from === this.uid || kt.node || !i.getDom())) {
        var a = y4(o, i);
        this._ticket = "";
        var s = o.dataByCoordSys, l = oIe(o, n, i);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: o.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, a);
        } else if (o.tooltip && o.x != null && o.y != null) {
          var c = eIe;
          c.x = o.x, c.y = o.y, c.update(), ot(c).tooltipConfig = {
            name: null,
            option: o.tooltip
          }, this._tryShow({
            offsetX: o.x,
            offsetY: o.y,
            target: c
          }, a);
        } else if (s)
          this._tryShow({
            offsetX: o.x,
            offsetY: o.y,
            position: o.position,
            dataByCoordSys: s,
            tooltipOption: o.tooltipOption
          }, a);
        else if (o.seriesIndex != null) {
          if (this._manuallyAxisShowTip(r, n, i, o))
            return;
          var d = tU(o, n), h = d.point[0], f = d.point[1];
          h != null && f != null && this._tryShow({
            offsetX: h,
            offsetY: f,
            target: d.el,
            position: o.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, a);
        } else o.x != null && o.y != null && (i.dispatchAction({
          type: "updateAxisPointer",
          x: o.x,
          y: o.y
        }), this._tryShow({
          offsetX: o.x,
          offsetY: o.y,
          position: o.position,
          target: i.getZr().findHover(o.x, o.y).target
        }, a));
      }
    }, t.prototype.manuallyHideTip = function(r, n, i, o) {
      var a = this._tooltipContent;
      this._tooltipModel && a.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, o.from !== this.uid && this._hide(y4(o, i));
    }, t.prototype._manuallyAxisShowTip = function(r, n, i, o) {
      var a = o.seriesIndex, s = o.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(a == null || s == null || l == null)) {
        var u = n.getSeriesByIndex(a);
        if (u) {
          var c = u.getData(), d = fp([c.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (d.get("trigger") === "axis")
            return i.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: a,
              dataIndex: s,
              position: o.position
            }), !0;
        }
      }
    }, t.prototype._tryShow = function(r, n) {
      var i = r.target, o = this._tooltipModel;
      if (o) {
        this._lastX = r.offsetX, this._lastY = r.offsetY;
        var a = r.dataByCoordSys;
        if (a && a.length)
          this._showAxisTooltip(a, r);
        else if (i) {
          var s = ot(i);
          if (s.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          ic(i, function(c) {
            if (ot(c).dataIndex != null)
              return l = c, !0;
            if (ot(c).tooltipConfig != null)
              return u = c, !0;
          }, !0), l ? this._showSeriesItemTooltip(r, l, n) : u ? this._showComponentItemTooltip(r, u, n) : this._hide(n);
        } else
          this._lastDataByCoordSys = null, this._hide(n);
      }
    }, t.prototype._showOrMove = function(r, n) {
      var i = r.get("showDelay");
      n = ke(n, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(n, i) : n();
    }, t.prototype._showAxisTooltip = function(r, n) {
      var i = this._ecModel, o = this._tooltipModel, a = [n.offsetX, n.offsetY], s = fp([n.tooltipOption], o), l = this._renderMode, u = [], c = _n("section", {
        blocks: [],
        noHeader: !0
      }), d = [], h = new l1();
      B(r, function(y) {
        B(y.dataByAxis, function(C) {
          var S = i.getComponent(C.axisDim + "Axis", C.axisIndex), b = C.value;
          if (!(!S || b == null)) {
            var w = Xj(b, S.axis, i, C.seriesDataIndices, C.valueLabelOpt), x = _n("section", {
              header: w,
              noHeader: !_o(w),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(x), B(C.seriesDataIndices, function(E) {
              var R = i.getSeriesByIndex(E.seriesIndex), _ = E.dataIndexInside, P = R.getDataParams(_);
              if (!(P.dataIndex < 0)) {
                P.axisDim = C.axisDim, P.axisIndex = C.axisIndex, P.axisType = C.axisType, P.axisId = C.axisId, P.axisValue = aD(S.axis, {
                  value: b
                }), P.axisValueLabel = w, P.marker = h.makeTooltipMarker("item", Ac(P.color), l);
                var D = tN(R.formatTooltip(_, !0, null)), I = D.frag;
                if (I) {
                  var A = fp([R], o).get("valueFormatter");
                  x.blocks.push(A ? se({
                    valueFormatter: A
                  }, I) : I);
                }
                D.text && d.push(D.text), u.push(P);
              }
            });
          }
        });
      }), c.blocks.reverse(), d.reverse();
      var f = n.position, p = s.get("order"), g = sN(c, h, l, p, i.get("useUTC"), s.get("textStyle"));
      g && d.unshift(g);
      var v = l === "richText" ? `

` : "<br/>", m = d.join(v);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(r, u) ? this._updatePosition(s, f, a[0], a[1], this._tooltipContent, u) : this._showTooltipContent(s, m, u, Math.random() + "", a[0], a[1], f, null, h);
      });
    }, t.prototype._showSeriesItemTooltip = function(r, n, i) {
      var o = this._ecModel, a = ot(n), s = a.seriesIndex, l = o.getSeriesByIndex(s), u = a.dataModel || l, c = a.dataIndex, d = a.dataType, h = u.getData(d), f = this._renderMode, p = r.positionDefault, g = fp([h.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, p ? {
        position: p
      } : null), v = g.get("trigger");
      if (!(v != null && v !== "item")) {
        var m = u.getDataParams(c, d), y = new l1();
        m.marker = y.makeTooltipMarker("item", Ac(m.color), f);
        var C = tN(u.formatTooltip(c, !1, d)), S = g.get("order"), b = g.get("valueFormatter"), w = C.frag, x = w ? sN(b ? se({
          valueFormatter: b
        }, w) : w, y, f, S, o.get("useUTC"), g.get("textStyle")) : C.text, E = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, x, m, E, r.offsetX, r.offsetY, r.position, r.target, y);
        }), i({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: h.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(r, n, i) {
      var o = this._renderMode === "html", a = ot(n), s = a.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
      if (Fe(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && o && l.content && (l = et(l), l.content = fi(l.content));
      var d = [l], h = this._ecModel.getComponent(a.componentMainType, a.componentIndex);
      h && d.push(h), d.push({
        formatter: l.content
      });
      var f = r.positionDefault, p = fp(d, this._tooltipModel, f ? {
        position: f
      } : null), g = p.get("content"), v = Math.random() + "", m = new l1();
      this._showOrMove(p, function() {
        var y = et(p.get("formatterParams") || {});
        this._showTooltipContent(p, g, y, v, r.offsetX, r.offsetY, r.position, n, m);
      }), i({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(r, n, i, o, a, s, l, u, c) {
      if (this._ticket = "", !(!r.get("showContent") || !r.get("show"))) {
        var d = this._tooltipContent;
        d.setEnterable(r.get("enterable"));
        var h = r.get("formatter");
        l = l || r.get("position");
        var f = n, p = this._getNearestPoint([a, s], i, r.get("trigger"), r.get("borderColor")), g = p.color;
        if (h)
          if (Fe(h)) {
            var v = r.ecModel.get("useUTC"), m = fe(i) ? i[0] : i, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
            f = h, y && (f = Lv(m.axisValue, f, v)), f = FM(f, i, !0);
          } else if (Ye(h)) {
            var C = ke(function(S, b) {
              S === this._ticket && (d.setContent(b, c, r, g, l), this._updatePosition(r, l, a, s, d, i, u));
            }, this);
            this._ticket = o, f = h(i, o, C);
          } else
            f = h;
        d.setContent(f, c, r, g, l), d.show(r, g), this._updatePosition(r, l, a, s, d, i, u);
      }
    }, t.prototype._getNearestPoint = function(r, n, i, o) {
      if (i === "axis" || fe(n))
        return {
          color: o || (this._renderMode === "html" ? "#fff" : "none")
        };
      if (!fe(n))
        return {
          color: o || n.color || n.borderColor
        };
    }, t.prototype._updatePosition = function(r, n, i, o, a, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || r.get("position");
      var d = a.getSize(), h = r.get("align"), f = r.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), Ye(n) && (n = n([i, o], s, a.el, p, {
        viewSize: [u, c],
        contentSize: d.slice()
      })), fe(n))
        i = Ae(n[0], u), o = Ae(n[1], c);
      else if (Ze(n)) {
        var g = n;
        g.width = d[0], g.height = d[1];
        var v = hn(g, {
          width: u,
          height: c
        });
        i = v.x, o = v.y, h = null, f = null;
      } else if (Fe(n) && l) {
        var m = iIe(n, p, d, r.get("borderWidth"));
        i = m[0], o = m[1];
      } else {
        var m = rIe(i, o, a, u, c, h ? null : 20, f ? null : 20);
        i = m[0], o = m[1];
      }
      if (h && (i -= C4(h) ? d[0] / 2 : h === "right" ? d[0] : 0), f && (o -= C4(f) ? d[1] / 2 : f === "bottom" ? d[1] : 0), fU(r)) {
        var m = nIe(i, o, a, u, c);
        i = m[0], o = m[1];
      }
      a.moveTo(i, o);
    }, t.prototype._updateContentNotChangedOnAxis = function(r, n) {
      var i = this._lastDataByCoordSys, o = this._cbParamsList, a = !!i && i.length === r.length;
      return a && B(i, function(s, l) {
        var u = s.dataByAxis || [], c = r[l] || {}, d = c.dataByAxis || [];
        a = a && u.length === d.length, a && B(u, function(h, f) {
          var p = d[f] || {}, g = h.seriesDataIndices || [], v = p.seriesDataIndices || [];
          a = a && h.value === p.value && h.axisType === p.axisType && h.axisId === p.axisId && g.length === v.length, a && B(g, function(m, y) {
            var C = v[y];
            a = a && m.seriesIndex === C.seriesIndex && m.dataIndex === C.dataIndex;
          }), o && B(h.seriesDataIndices, function(m) {
            var y = m.seriesIndex, C = n[y], S = o[y];
            C && S && S.data !== C.data && (a = !1);
          });
        });
      }), this._lastDataByCoordSys = r, this._cbParamsList = n, !!a;
    }, t.prototype._hide = function(r) {
      this._lastDataByCoordSys = null, r({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(r, n) {
      kt.node || !n.getDom() || (zg(this, "_updatePosition"), this._tooltipContent.dispose(), J_("itemTooltip", n));
    }, t.type = "tooltip", t;
  }(Rr)
);
function fp(e, t, r) {
  var n = t.ecModel, i;
  r ? (i = new cr(r, n, n), i = new cr(t.option, i, n)) : i = t;
  for (var o = e.length - 1; o >= 0; o--) {
    var a = e[o];
    a && (a instanceof cr && (a = a.get("tooltip", !0)), Fe(a) && (a = {
      formatter: a
    }), a && (i = new cr(a, i, n)));
  }
  return i;
}
function y4(e, t) {
  return e.dispatchAction || ke(t.dispatchAction, t);
}
function rIe(e, t, r, n, i, o, a) {
  var s = r.getSize(), l = s[0], u = s[1];
  return o != null && (e + l + o + 2 > n ? e -= l + o : e += o), a != null && (t + u + a > i ? t -= u + a : t += a), [e, t];
}
function nIe(e, t, r, n, i) {
  var o = r.getSize(), a = o[0], s = o[1];
  return e = Math.min(e + a, n) - a, t = Math.min(t + s, i) - s, e = Math.max(e, 0), t = Math.max(t, 0), [e, t];
}
function iIe(e, t, r, n) {
  var i = r[0], o = r[1], a = Math.ceil(Math.SQRT2 * n) + 8, s = 0, l = 0, u = t.width, c = t.height;
  switch (e) {
    case "inside":
      s = t.x + u / 2 - i / 2, l = t.y + c / 2 - o / 2;
      break;
    case "top":
      s = t.x + u / 2 - i / 2, l = t.y - o - a;
      break;
    case "bottom":
      s = t.x + u / 2 - i / 2, l = t.y + c + a;
      break;
    case "left":
      s = t.x - i - a, l = t.y + c / 2 - o / 2;
      break;
    case "right":
      s = t.x + u + a, l = t.y + c / 2 - o / 2;
  }
  return [s, l];
}
function C4(e) {
  return e === "center" || e === "middle";
}
function oIe(e, t, r) {
  var n = uM(e).queryOptionMap, i = n.keys()[0];
  if (!(!i || i === "series")) {
    var o = Pv(t, i, n.get(i), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), a = o.models[0];
    if (a) {
      var s = r.getViewOfComponentModel(a), l;
      if (s.group.traverse(function(u) {
        var c = ot(u).tooltipConfig;
        if (c && c.name === e.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: i,
          componentIndex: a.componentIndex,
          el: l
        };
    }
  }
}
function aIe(e) {
  _t(jv), e.registerComponentModel(zAe), e.registerComponentView(tIe), e.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, Kr), e.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, Kr);
}
var sIe = ["rect", "polygon", "keep", "clear"];
function lIe(e, t) {
  var r = dr(e ? e.brush : []);
  if (r.length) {
    var n = [];
    B(r, function(l) {
      var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
      u instanceof Array && (n = n.concat(u));
    });
    var i = e && e.toolbox;
    fe(i) && (i = i[0]), i || (i = {
      feature: {}
    }, e.toolbox = [i]);
    var o = i.feature || (i.feature = {}), a = o.brush || (o.brush = {}), s = a.type || (a.type = []);
    s.push.apply(s, n), uIe(s), t && !s.length && s.push.apply(s, sIe);
  }
}
function uIe(e) {
  var t = {};
  B(e, function(r) {
    t[r] = 1;
  }), e.length = 0, B(t, function(r, n) {
    e.push(n);
  });
}
var S4 = B;
function w4(e) {
  if (e) {
    for (var t in e)
      if (e.hasOwnProperty(t))
        return !0;
  }
}
function oT(e, t, r) {
  var n = {};
  return S4(t, function(o) {
    var a = n[o] = i();
    S4(e[o], function(s, l) {
      if (xn.isValidType(l)) {
        var u = {
          type: l,
          visual: s
        };
        r && r(u, o), a[l] = new xn(u), l === "opacity" && (u = et(u), u.type = "colorAlpha", a.__hidden.__alphaForOpacity = new xn(u));
      }
    });
  }), n;
  function i() {
    var o = function() {
    };
    o.prototype.__hidden = o.prototype;
    var a = new o();
    return a;
  }
}
function mU(e, t, r) {
  var n;
  B(r, function(i) {
    t.hasOwnProperty(i) && w4(t[i]) && (n = !0);
  }), n && B(r, function(i) {
    t.hasOwnProperty(i) && w4(t[i]) ? e[i] = et(t[i]) : delete e[i];
  });
}
function cIe(e, t, r, n, i, o) {
  var a = {};
  B(e, function(d) {
    var h = xn.prepareVisualTypes(t[d]);
    a[d] = h;
  });
  var s;
  function l(d) {
    return $M(r, s, d);
  }
  function u(d, h) {
    OW(r, s, d, h);
  }
  r.each(c);
  function c(d, h) {
    s = d;
    var f = r.getRawDataItem(s);
    if (!(f && f.visualMap === !1))
      for (var p = n.call(i, d), g = t[p], v = a[p], m = 0, y = v.length; m < y; m++) {
        var C = v[m];
        g[C] && g[C].applyVisual(d, l, u);
      }
  }
}
function dIe(e, t, r, n) {
  var i = {};
  return B(e, function(o) {
    var a = xn.prepareVisualTypes(t[o]);
    i[o] = a;
  }), {
    progress: function(a, s) {
      var l;
      n != null && (l = s.getDimensionIndex(n));
      function u(b) {
        return $M(s, d, b);
      }
      function c(b, w) {
        OW(s, d, b, w);
      }
      for (var d, h = s.getStore(); (d = a.next()) != null; ) {
        var f = s.getRawDataItem(d);
        if (!(f && f.visualMap === !1))
          for (var p = n != null ? h.get(l, d) : d, g = r(p), v = t[g], m = i[g], y = 0, C = m.length; y < C; y++) {
            var S = m[y];
            v[S] && v[S].applyVisual(p, u, c);
          }
      }
    }
  };
}
function hIe(e) {
  var t = e.brushType, r = {
    point: function(n) {
      return b4[t].point(n, r, e);
    },
    rect: function(n) {
      return b4[t].rect(n, r, e);
    }
  };
  return r;
}
var b4 = {
  lineX: x4(0),
  lineY: x4(1),
  rect: {
    point: function(e, t, r) {
      return e && r.boundingRect.contain(e[0], e[1]);
    },
    rect: function(e, t, r) {
      return e && r.boundingRect.intersect(e);
    }
  },
  polygon: {
    point: function(e, t, r) {
      return e && r.boundingRect.contain(e[0], e[1]) && Uu(r.range, e[0], e[1]);
    },
    rect: function(e, t, r) {
      var n = r.range;
      if (!e || n.length <= 1)
        return !1;
      var i = e.x, o = e.y, a = e.width, s = e.height, l = n[0];
      if (Uu(n, i, o) || Uu(n, i + a, o) || Uu(n, i, o + s) || Uu(n, i + a, o + s) || St.create(e).contain(l[0], l[1]) || Pp(i, o, i + a, o, n) || Pp(i, o, i, o + s, n) || Pp(i + a, o, i + a, o + s, n) || Pp(i, o + s, i + a, o + s, n))
        return !0;
    }
  }
};
function x4(e) {
  var t = ["x", "y"], r = ["width", "height"];
  return {
    point: function(n, i, o) {
      if (n) {
        var a = o.range, s = n[e];
        return pp(s, a);
      }
    },
    rect: function(n, i, o) {
      if (n) {
        var a = o.range, s = [n[t[e]], n[t[e]] + n[r[e]]];
        return s[1] < s[0] && s.reverse(), pp(s[0], a) || pp(s[1], a) || pp(a[0], s) || pp(a[1], s);
      }
    }
  };
}
function pp(e, t) {
  return t[0] <= e && e <= t[1];
}
var E4 = ["inBrush", "outOfBrush"], _x = "__ecBrushSelect", aT = "__ecInBrushSelectEvent";
function yU(e) {
  e.eachComponent({
    mainType: "brush"
  }, function(t) {
    var r = t.brushTargetManager = new nA(t.option, e);
    r.setInputRanges(t.areas, e);
  });
}
function fIe(e, t, r) {
  var n = [], i, o;
  e.eachComponent({
    mainType: "brush"
  }, function(a) {
    r && r.type === "takeGlobalCursor" && a.setBrushOption(r.key === "brush" ? r.brushOption : {
      brushType: !1
    });
  }), yU(e), e.eachComponent({
    mainType: "brush"
  }, function(a, s) {
    var l = {
      brushId: a.id,
      brushIndex: s,
      brushName: a.name,
      areas: et(a.areas),
      selected: []
    };
    n.push(l);
    var u = a.option, c = u.brushLink, d = [], h = [], f = [], p = !1;
    s || (i = u.throttleType, o = u.throttleDelay);
    var g = ge(a.areas, function(b) {
      var w = mIe[b.brushType], x = Xe({
        boundingRect: w ? w(b) : void 0
      }, b);
      return x.selectors = hIe(x), x;
    }), v = oT(a.option, E4, function(b) {
      b.mappingMethod = "fixed";
    });
    fe(c) && B(c, function(b) {
      d[b] = 1;
    });
    function m(b) {
      return c === "all" || !!d[b];
    }
    function y(b) {
      return !!b.length;
    }
    e.eachSeries(function(b, w) {
      var x = f[w] = [];
      b.subType === "parallel" ? C(b, w) : S(b, w, x);
    });
    function C(b, w) {
      var x = b.coordinateSystem;
      p = p || x.hasAxisBrushed(), m(w) && x.eachActiveState(b.getData(), function(E, R) {
        E === "active" && (h[R] = 1);
      });
    }
    function S(b, w, x) {
      if (!(!b.brushSelector || vIe(a, w)) && (B(g, function(R) {
        a.brushTargetManager.controlSeries(R, b, e) && x.push(R), p = p || y(x);
      }), m(w) && y(x))) {
        var E = b.getData();
        E.each(function(R) {
          R4(b, x, E, R) && (h[R] = 1);
        });
      }
    }
    e.eachSeries(function(b, w) {
      var x = {
        seriesId: b.id,
        seriesIndex: w,
        seriesName: b.name,
        dataIndex: []
      };
      l.selected.push(x);
      var E = f[w], R = b.getData(), _ = m(w) ? function(P) {
        return h[P] ? (x.dataIndex.push(R.getRawIndex(P)), "inBrush") : "outOfBrush";
      } : function(P) {
        return R4(b, E, R, P) ? (x.dataIndex.push(R.getRawIndex(P)), "inBrush") : "outOfBrush";
      };
      (m(w) ? p : y(E)) && cIe(E4, v, R, _);
    });
  }), pIe(t, i, o, n, r);
}
function pIe(e, t, r, n, i) {
  if (i) {
    var o = e.getZr();
    if (!o[aT]) {
      o[_x] || (o[_x] = gIe);
      var a = gf(o, _x, r, t);
      a(e, n);
    }
  }
}
function gIe(e, t) {
  if (!e.isDisposed()) {
    var r = e.getZr();
    r[aT] = !0, e.dispatchAction({
      type: "brushSelect",
      batch: t
    }), r[aT] = !1;
  }
}
function R4(e, t, r, n) {
  for (var i = 0, o = t.length; i < o; i++) {
    var a = t[i];
    if (e.brushSelector(n, r, a.selectors, a))
      return !0;
  }
}
function vIe(e, t) {
  var r = e.option.seriesIndex;
  return r != null && r !== "all" && (fe(r) ? bt(r, t) < 0 : t !== r);
}
var mIe = {
  rect: function(e) {
    return _4(e.range);
  },
  polygon: function(e) {
    for (var t, r = e.range, n = 0, i = r.length; n < i; n++) {
      t = t || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var o = r[n];
      o[0] < t[0][0] && (t[0][0] = o[0]), o[0] > t[0][1] && (t[0][1] = o[0]), o[1] < t[1][0] && (t[1][0] = o[1]), o[1] > t[1][1] && (t[1][1] = o[1]);
    }
    return t && _4(t);
  }
};
function _4(e) {
  return new St(e[0][0], e[1][0], e[0][1] - e[0][0], e[1][1] - e[1][0]);
}
var yIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      this.ecModel = r, this.api = n, this.model, (this._brushController = new ID(n.getZr())).on("brush", ke(this._onBrush, this)).mount();
    }, t.prototype.render = function(r, n, i, o) {
      this.model = r, this._updateController(r, n, i, o);
    }, t.prototype.updateTransform = function(r, n, i, o) {
      yU(n), this._updateController(r, n, i, o);
    }, t.prototype.updateVisual = function(r, n, i, o) {
      this.updateTransform(r, n, i, o);
    }, t.prototype.updateView = function(r, n, i, o) {
      this._updateController(r, n, i, o);
    }, t.prototype._updateController = function(r, n, i, o) {
      (!o || o.$from !== r.id) && this._brushController.setPanels(r.brushTargetManager.makePanelOpts(i)).enableBrush(r.brushOption).updateCovers(r.areas.slice());
    }, t.prototype.dispose = function() {
      this._brushController.dispose();
    }, t.prototype._onBrush = function(r) {
      var n = this.model.id, i = this.model.brushTargetManager.setOutputRanges(r.areas, this.ecModel);
      (!r.isEnd || r.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: n,
        areas: et(i),
        $from: n
      }), r.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: n,
        areas: et(i),
        $from: n
      });
    }, t.type = "brush", t;
  }(Rr)
), CIe = "#ddd", SIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.areas = [], r.brushOption = {}, r;
    }
    return t.prototype.optionUpdated = function(r, n) {
      var i = this.option;
      !n && mU(i, r, ["inBrush", "outOfBrush"]);
      var o = i.inBrush = i.inBrush || {};
      i.outOfBrush = i.outOfBrush || {
        color: CIe
      }, o.hasOwnProperty("liftZ") || (o.liftZ = 5);
    }, t.prototype.setAreas = function(r) {
      process.env.NODE_ENV !== "production" && (Qe(fe(r)), B(r, function(n) {
        Qe(n.brushType, "Illegal areas");
      })), r && (this.areas = ge(r, function(n) {
        return T4(this.option, n);
      }, this));
    }, t.prototype.setBrushOption = function(r) {
      this.brushOption = T4(this.option, r), this.brushType = this.brushOption.brushType;
    }, t.type = "brush", t.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], t.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4
    }, t;
  }(Rt)
);
function T4(e, t) {
  return yt({
    brushType: e.brushType,
    brushMode: e.brushMode,
    transformable: e.transformable,
    brushStyle: new cr(e.brushStyle).getItemStyle(),
    removeOnClick: e.removeOnClick,
    z: e.z
  }, t, !0);
}
var wIe = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], bIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.render = function(r, n, i) {
      var o, a, s;
      n.eachComponent({
        mainType: "brush"
      }, function(l) {
        o = l.brushType, a = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = o, this._brushMode = a, B(r.get("type", !0), function(l) {
        r.setIconStatus(l, (l === "keep" ? a === "multiple" : l === "clear" ? s : l === o) ? "emphasis" : "normal");
      });
    }, t.prototype.updateView = function(r, n, i) {
      this.render(r, n, i);
    }, t.prototype.getIcons = function() {
      var r = this.model, n = r.get("icon", !0), i = {};
      return B(r.get("type", !0), function(o) {
        n[o] && (i[o] = n[o]);
      }), i;
    }, t.prototype.onclick = function(r, n, i) {
      var o = this._brushType, a = this._brushMode;
      i === "clear" ? (n.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), n.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : n.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: i === "keep" ? o : o === i ? !1 : i,
          brushMode: i === "keep" ? a === "multiple" ? "single" : "multiple" : a
        }
      });
    }, t.getDefaultOption = function(r) {
      var n = {
        show: !0,
        type: wIe.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: r.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return n;
    }, t;
  }(Eo)
);
function xIe(e) {
  e.registerComponentView(yIe), e.registerComponentModel(SIe), e.registerPreprocessor(lIe), e.registerVisual(e.PRIORITY.VISUAL.BRUSH, fIe), e.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(t, r) {
    r.eachComponent({
      mainType: "brush",
      query: t
    }, function(n) {
      n.setAreas(t.areas);
    });
  }), e.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, Kr), e.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, Kr), Yd("brush", bIe);
}
var EIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, r;
    }
    return t.type = "title", t.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, t;
  }(Rt)
), RIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.render = function(r, n, i) {
      if (this.group.removeAll(), !!r.get("show")) {
        var o = this.group, a = r.getModel("textStyle"), s = r.getModel("subtextStyle"), l = r.get("textAlign"), u = st(r.get("textBaseline"), r.get("textVerticalAlign")), c = new Vt({
          style: br(a, {
            text: r.get("text"),
            fill: a.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), d = c.getBoundingRect(), h = r.get("subtext"), f = new Vt({
          style: br(s, {
            text: h,
            fill: s.getTextColor(),
            y: d.height + r.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), p = r.get("link"), g = r.get("sublink"), v = r.get("triggerEvent", !0);
        c.silent = !p && !v, f.silent = !g && !v, p && c.on("click", function() {
          tC(p, "_" + r.get("target"));
        }), g && f.on("click", function() {
          tC(g, "_" + r.get("subtarget"));
        }), ot(c).eventData = ot(f).eventData = v ? {
          componentType: "title",
          componentIndex: r.componentIndex
        } : null, o.add(c), h && o.add(f);
        var m = o.getBoundingRect(), y = r.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var C = hn(y, {
          width: i.getWidth(),
          height: i.getHeight()
        }, r.get("padding"));
        l || (l = r.get("left") || r.get("right"), l === "middle" && (l = "center"), l === "right" ? C.x += C.width : l === "center" && (C.x += C.width / 2)), u || (u = r.get("top") || r.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? C.y += C.height : u === "middle" && (C.y += C.height / 2), u = u || "top"), o.x = C.x, o.y = C.y, o.markRedraw();
        var S = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(S), f.setStyle(S), m = o.getBoundingRect();
        var b = C.margin, w = r.getItemStyle(["color", "opacity"]);
        w.fill = r.get("backgroundColor");
        var x = new Bt({
          shape: {
            x: m.x - b[3],
            y: m.y - b[0],
            width: m.width + b[1] + b[3],
            height: m.height + b[0] + b[2],
            r: r.get("borderRadius")
          },
          style: w,
          subPixelOptimize: !0,
          silent: !0
        });
        o.add(x);
      }
    }, t.type = "title", t;
  }(Rr)
);
function _Ie(e) {
  e.registerComponentModel(EIe), e.registerComponentView(RIe);
}
var P4 = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.layoutMode = "box", r;
    }
    return t.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i), this._initData();
    }, t.prototype.mergeOption = function(r) {
      e.prototype.mergeOption.apply(this, arguments), this._initData();
    }, t.prototype.setCurrentIndex = function(r) {
      r == null && (r = this.option.currentIndex);
      var n = this._data.count();
      this.option.loop ? r = (r % n + n) % n : (r >= n && (r = n - 1), r < 0 && (r = 0)), this.option.currentIndex = r;
    }, t.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, t.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, t.prototype.setPlayState = function(r) {
      this.option.autoPlay = !!r;
    }, t.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, t.prototype._initData = function() {
      var r = this.option, n = r.data || [], i = r.axisType, o = this._names = [], a;
      i === "category" ? (a = [], B(n, function(u, c) {
        var d = vn(nf(u), ""), h;
        Ze(u) ? (h = et(u), h.value = c) : h = c, a.push(h), o.push(d);
      })) : a = n;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[i] || "number", l = this._data = new Jn([{
        name: "value",
        type: s
      }], this);
      l.initData(a, o);
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, t.type = "timeline", t.defaultOption = {
      // zlevel: 0,                  // 一级层叠
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, t;
  }(Rt)
), CU = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "timeline.slider", t.defaultOption = ou(P4.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // 其余属性默认使用全局文本样式，详见TEXTSTYLE
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        // eslint-disable-next-line max-len
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        // eslint-disable-next-line max-len
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), t;
  }(P4)
);
qr(CU, qS.prototype);
var TIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "timeline", t;
  }(Rr)
), PIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t(r, n, i, o) {
      var a = e.call(this, r, n, i) || this;
      return a.type = o || "value", a;
    }
    return t.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, t.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, t;
  }(Wo)
), Tx = Math.PI, M4 = Gt(), MIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function(r, n) {
      this.api = n;
    }, t.prototype.render = function(r, n, i) {
      if (this.model = r, this.api = i, this.ecModel = n, this.group.removeAll(), r.get("show", !0)) {
        var o = this._layout(r, i), a = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(o, r);
        r.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return _n("nameValue", {
            noName: !0,
            value: c
          });
        }, B(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
          this["_render" + u](o, a, l, r);
        }, this), this._renderAxisLabel(o, s, l, r), this._position(o, r);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, t.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, t.prototype.dispose = function() {
      this._clearTimer();
    }, t.prototype._layout = function(r, n) {
      var i = r.get(["label", "position"]), o = r.get("orient"), a = AIe(r, n), s;
      i == null || i === "auto" ? s = o === "horizontal" ? a.y + a.height / 2 < n.getHeight() / 2 ? "-" : "+" : a.x + a.width / 2 < n.getWidth() / 2 ? "+" : "-" : Fe(i) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[o][i] : s = i;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: Tx / 2
      }, d = o === "vertical" ? a.height : a.width, h = r.getModel("controlStyle"), f = h.get("show", !0), p = f ? h.get("itemSize") : 0, g = f ? h.get("itemGap") : 0, v = p + g, m = r.get(["label", "rotate"]) || 0;
      m = m * Tx / 180;
      var y, C, S, b = h.get("position", !0), w = f && h.get("showPlayBtn", !0), x = f && h.get("showPrevBtn", !0), E = f && h.get("showNextBtn", !0), R = 0, _ = d;
      b === "left" || b === "bottom" ? (w && (y = [0, 0], R += v), x && (C = [R, 0], R += v), E && (S = [_ - p, 0], _ -= v)) : (w && (y = [_ - p, 0], _ -= v), x && (C = [0, 0], R += v), E && (S = [_ - p, 0], _ -= v));
      var P = [R, _];
      return r.get("inverse") && P.reverse(), {
        viewRect: a,
        mainLength: d,
        orient: o,
        rotation: c[o],
        labelRotation: m,
        labelPosOpt: s,
        labelAlign: r.get(["label", "align"]) || l[o],
        labelBaseline: r.get(["label", "verticalAlign"]) || r.get(["label", "baseline"]) || u[o],
        // Based on mainGroup.
        playPosition: y,
        prevBtnPosition: C,
        nextBtnPosition: S,
        axisExtent: P,
        controlSize: p,
        controlGap: g
      };
    }, t.prototype._position = function(r, n) {
      var i = this._mainGroup, o = this._labelGroup, a = r.viewRect;
      if (r.orient === "vertical") {
        var s = ki(), l = a.x, u = a.y + a.height;
        ma(s, s, [-l, -u]), nu(s, s, -Tx / 2), ma(s, s, [l, u]), a = a.clone(), a.applyTransform(s);
      }
      var c = y(a), d = y(i.getBoundingRect()), h = y(o.getBoundingRect()), f = [i.x, i.y], p = [o.x, o.y];
      p[0] = f[0] = c[0][0];
      var g = r.labelPosOpt;
      if (g == null || Fe(g)) {
        var v = g === "+" ? 0 : 1;
        C(f, d, c, 1, v), C(p, h, c, 1, 1 - v);
      } else {
        var v = g >= 0 ? 0 : 1;
        C(f, d, c, 1, v), p[1] = f[1] + g;
      }
      i.setPosition(f), o.setPosition(p), i.rotation = o.rotation = r.rotation, m(i), m(o);
      function m(S) {
        S.originX = c[0][0] - S.x, S.originY = c[1][0] - S.y;
      }
      function y(S) {
        return [[S.x, S.x + S.width], [S.y, S.y + S.height]];
      }
      function C(S, b, w, x, E) {
        S[x] += w[x][E] - b[x][E];
      }
    }, t.prototype._createAxis = function(r, n) {
      var i = n.getData(), o = n.get("axisType"), a = DIe(n, o);
      a.getTicks = function() {
        return i.mapArray(["value"], function(u) {
          return {
            value: u
          };
        });
      };
      var s = i.getDataExtent("value");
      a.setExtent(s[0], s[1]), a.calcNiceTicks();
      var l = new PIe("value", a, r.axisExtent, o);
      return l.model = n, l;
    }, t.prototype._createGroup = function(r) {
      var n = this[r] = new it();
      return this.group.add(n), n;
    }, t.prototype._renderAxisLine = function(r, n, i, o) {
      var a = i.getExtent();
      if (o.get(["lineStyle", "show"])) {
        var s = new wn({
          shape: {
            x1: a[0],
            y1: 0,
            x2: a[1],
            y2: 0
          },
          style: se({
            lineCap: "round"
          }, o.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        n.add(s);
        var l = this._progressLine = new wn({
          shape: {
            x1: a[0],
            x2: this._currentPointer ? this._currentPointer.x : a[0],
            y1: 0,
            y2: 0
          },
          style: Xe({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, o.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        n.add(l);
      }
    }, t.prototype._renderAxisTick = function(r, n, i, o) {
      var a = this, s = o.getData(), l = i.scale.getTicks();
      this._tickSymbols = [], B(l, function(u) {
        var c = i.dataToCoord(u.value), d = s.getItemModel(u.value), h = d.getModel("itemStyle"), f = d.getModel(["emphasis", "itemStyle"]), p = d.getModel(["progress", "itemStyle"]), g = {
          x: c,
          y: 0,
          onclick: ke(a._changeTimeline, a, u.value)
        }, v = D4(d, h, n, g);
        v.ensureState("emphasis").style = f.getItemStyle(), v.ensureState("progress").style = p.getItemStyle(), Fl(v);
        var m = ot(v);
        d.get("tooltip") ? (m.dataIndex = u.value, m.dataModel = o) : m.dataIndex = m.dataModel = null, a._tickSymbols.push(v);
      });
    }, t.prototype._renderAxisLabel = function(r, n, i, o) {
      var a = this, s = i.getLabelModel();
      if (s.get("show")) {
        var l = o.getData(), u = i.getViewLabels();
        this._tickLabels = [], B(u, function(c) {
          var d = c.tickValue, h = l.getItemModel(d), f = h.getModel("label"), p = h.getModel(["emphasis", "label"]), g = h.getModel(["progress", "label"]), v = i.dataToCoord(c.tickValue), m = new Vt({
            x: v,
            y: 0,
            rotation: r.labelRotation - r.rotation,
            onclick: ke(a._changeTimeline, a, d),
            silent: !1,
            style: br(f, {
              text: c.formattedLabel,
              align: r.labelAlign,
              verticalAlign: r.labelBaseline
            })
          });
          m.ensureState("emphasis").style = br(p), m.ensureState("progress").style = br(g), n.add(m), Fl(m), M4(m).dataIndex = d, a._tickLabels.push(m);
        });
      }
    }, t.prototype._renderControl = function(r, n, i, o) {
      var a = r.controlSize, s = r.rotation, l = o.getModel("controlStyle").getItemStyle(), u = o.getModel(["emphasis", "controlStyle"]).getItemStyle(), c = o.getPlayState(), d = o.get("inverse", !0);
      h(r.nextBtnPosition, "next", ke(this._changeTimeline, this, d ? "-" : "+")), h(r.prevBtnPosition, "prev", ke(this._changeTimeline, this, d ? "+" : "-")), h(r.playPosition, c ? "stop" : "play", ke(this._handlePlayClick, this, !c), !0);
      function h(f, p, g, v) {
        if (f) {
          var m = ya(st(o.get(["controlStyle", p + "BtnSize"]), a), a), y = [0, -m / 2, m, m], C = IIe(o, p + "Icon", y, {
            x: f[0],
            y: f[1],
            originX: a / 2,
            originY: 0,
            rotation: v ? -s : 0,
            rectHover: !0,
            style: l,
            onclick: g
          });
          C.ensureState("emphasis").style = u, n.add(C), Fl(C);
        }
      }
    }, t.prototype._renderCurrentPointer = function(r, n, i, o) {
      var a = o.getData(), s = o.getCurrentIndex(), l = a.getItemModel(s).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(d) {
          d.draggable = !0, d.drift = ke(u._handlePointerDrag, u), d.ondragend = ke(u._handlePointerDragend, u), A4(d, u._progressLine, s, i, o, !0);
        },
        onUpdate: function(d) {
          A4(d, u._progressLine, s, i, o);
        }
      };
      this._currentPointer = D4(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, t.prototype._handlePlayClick = function(r) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: r,
        from: this.uid
      });
    }, t.prototype._handlePointerDrag = function(r, n, i) {
      this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]);
    }, t.prototype._handlePointerDragend = function(r) {
      this._pointerChangeTimeline([r.offsetX, r.offsetY], !0);
    }, t.prototype._pointerChangeTimeline = function(r, n) {
      var i = this._toAxisCoord(r)[0], o = this._axis, a = Ji(o.getExtent().slice());
      i > a[1] && (i = a[1]), i < a[0] && (i = a[0]), this._currentPointer.x = i, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = i, s.dirty());
      var l = this._findNearestTick(i), u = this.model;
      (n || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, t.prototype._doPlayStop = function() {
      var r = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var n = r.model;
        r._changeTimeline(n.getCurrentIndex() + (n.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, t.prototype._toAxisCoord = function(r) {
      var n = this._mainGroup.getLocalTransform();
      return fa(r, n, !0);
    }, t.prototype._findNearestTick = function(r) {
      var n = this.model.getData(), i = 1 / 0, o, a = this._axis;
      return n.each(["value"], function(s, l) {
        var u = a.dataToCoord(s), c = Math.abs(u - r);
        c < i && (i = c, o = l);
      }), o;
    }, t.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, t.prototype._changeTimeline = function(r) {
      var n = this.model.getCurrentIndex();
      r === "+" ? r = n + 1 : r === "-" && (r = n - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: r,
        from: this.uid
      });
    }, t.prototype._updateTicksStatus = function() {
      var r = this.model.getCurrentIndex(), n = this._tickSymbols, i = this._tickLabels;
      if (n)
        for (var o = 0; o < n.length; o++)
          n && n[o] && n[o].toggleState("progress", o < r);
      if (i)
        for (var o = 0; o < i.length; o++)
          i && i[o] && i[o].toggleState("progress", M4(i[o]).dataIndex <= r);
    }, t.type = "timeline.slider", t;
  }(TIe)
);
function DIe(e, t) {
  if (t = t || e.get("type"), t)
    switch (t) {
      case "category":
        return new nw({
          ordinalMeta: e.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new iD({
          locale: e.ecModel.getLocaleModel(),
          useUTC: e.ecModel.get("useUTC")
        });
      default:
        return new Us();
    }
}
function AIe(e, t) {
  return hn(e.getBoxLayoutParams(), {
    width: t.getWidth(),
    height: t.getHeight()
  }, e.get("padding"));
}
function IIe(e, t, r, n) {
  var i = n.style, o = lf(e.get(["controlStyle", t]), n || {}, new St(r[0], r[1], r[2], r[3]));
  return i && o.setStyle(i), o;
}
function D4(e, t, r, n, i, o) {
  var a = t.get("color");
  if (i)
    i.setColor(a), r.add(i), o && o.onUpdate(i);
  else {
    var s = e.get("symbol");
    i = rn(s, -1, -1, 2, 2, a), i.setStyle("strokeNoScale", !0), r.add(i), o && o.onCreate(i);
  }
  var l = t.getItemStyle(["color"]);
  i.setStyle(l), n = yt({
    rectHover: !0,
    z2: 100
  }, n, !0);
  var u = vf(e.get("symbolSize"));
  n.scaleX = u[0] / 2, n.scaleY = u[1] / 2;
  var c = qc(e.get("symbolOffset"), u);
  c && (n.x = (n.x || 0) + c[0], n.y = (n.y || 0) + c[1]);
  var d = e.get("symbolRotate");
  return n.rotation = (d || 0) * Math.PI / 180 || 0, i.attr(n), i.updateTransform(), i;
}
function A4(e, t, r, n, i, o) {
  if (!e.dragging) {
    var a = i.getModel("checkpointStyle"), s = n.dataToCoord(i.getData().get("value", r));
    if (o || !a.get("animation", !0))
      e.attr({
        x: s,
        y: 0
      }), t && t.attr({
        shape: {
          x2: s
        }
      });
    else {
      var l = {
        duration: a.get("animationDuration", !0),
        easing: a.get("animationEasing", !0)
      };
      e.stopAnimation(null, !0), e.animateTo({
        x: s,
        y: 0
      }, l), t && t.animateTo({
        shape: {
          x2: s
        }
      }, l);
    }
  }
}
function FIe(e) {
  e.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(t, r, n) {
    var i = r.getComponent("timeline");
    return i && t.currentIndex != null && (i.setCurrentIndex(t.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(!1), n.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: t.from
    }))), r.resetOption("timeline", {
      replaceMerge: i.get("replaceMerge", !0)
    }), Xe({
      currentIndex: i.option.currentIndex
    }, t);
  }), e.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(t, r) {
    var n = r.getComponent("timeline");
    n && t.playState != null && n.setPlayState(t.playState);
  });
}
function LIe(e) {
  var t = e && e.timeline;
  fe(t) || (t = t ? [t] : []), B(t, function(r) {
    r && OIe(r);
  });
}
function OIe(e) {
  var t = e.type, r = {
    number: "value",
    time: "time"
  };
  if (r[t] && (e.axisType = r[t], delete e.type), I4(e), qu(e, "controlPosition")) {
    var n = e.controlStyle || (e.controlStyle = {});
    qu(n, "position") || (n.position = e.controlPosition), n.position === "none" && !qu(n, "show") && (n.show = !1, delete n.position), delete e.controlPosition;
  }
  B(e.data || [], function(i) {
    Ze(i) && !fe(i) && (!qu(i, "value") && qu(i, "name") && (i.value = i.name), I4(i));
  });
}
function I4(e) {
  var t = e.itemStyle || (e.itemStyle = {}), r = t.emphasis || (t.emphasis = {}), n = e.label || e.label || {}, i = n.normal || (n.normal = {}), o = {
    normal: 1,
    emphasis: 1
  };
  B(n, function(a, s) {
    !o[s] && !qu(i, s) && (i[s] = a);
  }), r.label && !qu(n, "emphasis") && (n.emphasis = r.label, delete r.label);
}
function qu(e, t) {
  return e.hasOwnProperty(t);
}
function NIe(e) {
  e.registerComponentModel(CU), e.registerComponentView(MIe), e.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), FIe(e), e.registerPreprocessor(LIe);
}
function aA(e, t) {
  if (!e)
    return !1;
  for (var r = fe(e) ? e : [e], n = 0; n < r.length; n++)
    if (r[n] && r[n][t])
      return !0;
  return !1;
}
function Cy(e) {
  Tc(e, "label", ["show"]);
}
var Sy = Gt(), Ys = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.createdBySelf = !1, r;
    }
    return t.prototype.init = function(r, n, i) {
      if (process.env.NODE_ENV !== "production" && this.type === "marker")
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      this.mergeDefaultAndTheme(r, i), this._mergeOption(r, i, !1, !0);
    }, t.prototype.isAnimationEnabled = function() {
      if (kt.node)
        return !1;
      var r = this.__hostSeries;
      return this.getShallow("animation") && r && r.isAnimationEnabled();
    }, t.prototype.mergeOption = function(r, n) {
      this._mergeOption(r, n, !1, !1);
    }, t.prototype._mergeOption = function(r, n, i, o) {
      var a = this.mainType;
      i || n.eachSeries(function(s) {
        var l = s.get(this.mainType, !0), u = Sy(s)[a];
        if (!l || !l.data) {
          Sy(s)[a] = null;
          return;
        }
        u ? u._mergeOption(l, n, !0) : (o && Cy(l), B(l.data, function(c) {
          c instanceof Array ? (Cy(c[0]), Cy(c[1])) : Cy(c);
        }), u = this.createMarkerModelFromSeries(l, this, n), se(u, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: !0
        }), u.__hostSeries = s), Sy(s)[a] = u;
      }, this);
    }, t.prototype.formatTooltip = function(r, n, i) {
      var o = this.getData(), a = this.getRawValue(r), s = o.getName(r);
      return _n("section", {
        header: this.name,
        blocks: [_n("nameValue", {
          name: s,
          value: a,
          noName: !s,
          noValue: a == null
        })]
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.setData = function(r) {
      this._data = r;
    }, t.prototype.getDataParams = function(r, n) {
      var i = qS.prototype.getDataParams.call(this, r, n), o = this.__hostSeries;
      return o && (i.seriesId = o.id, i.seriesName = o.name, i.seriesType = o.subType), i;
    }, t.getMarkerModelFromSeries = function(r, n) {
      return Sy(r)[n];
    }, t.type = "marker", t.dependencies = ["series", "grid", "polar", "geo"], t;
  }(Rt)
);
qr(Ys, qS.prototype);
var kIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.createMarkerModelFromSeries = function(r, n, i) {
      return new t(r, n, i);
    }, t.type = "markPoint", t.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, t;
  }(Ys)
);
function sT(e) {
  return !(isNaN(parseFloat(e.x)) && isNaN(parseFloat(e.y)));
}
function VIe(e) {
  return !isNaN(parseFloat(e.x)) && !isNaN(parseFloat(e.y));
}
function wy(e, t, r, n, i, o) {
  var a = [], s = js(
    t,
    n
    /* , otherDataDim */
  ), l = s ? t.getCalculationInfo("stackResultDimension") : n, u = sA(t, l, e), c = t.indicesOfNearest(l, u)[0];
  a[i] = t.get(r, c), a[o] = t.get(l, c);
  var d = t.get(n, c), h = oa(t.get(n, c));
  return h = Math.min(h, 20), h >= 0 && (a[o] = +a[o].toFixed(h)), [a, d];
}
var Px = {
  min: dt(wy, "min"),
  max: dt(wy, "max"),
  average: dt(wy, "average"),
  median: dt(wy, "median")
};
function rv(e, t) {
  if (t) {
    var r = e.getData(), n = e.coordinateSystem, i = n && n.dimensions;
    if (!VIe(t) && !fe(t.coord) && fe(i)) {
      var o = SU(t, r, n, e);
      if (t = et(t), t.type && Px[t.type] && o.baseAxis && o.valueAxis) {
        var a = bt(i, o.baseAxis.dim), s = bt(i, o.valueAxis.dim), l = Px[t.type](r, o.baseDataDim, o.valueDataDim, a, s);
        t.coord = l[0], t.value = l[1];
      } else
        t.coord = [t.xAxis != null ? t.xAxis : t.radiusAxis, t.yAxis != null ? t.yAxis : t.angleAxis];
    }
    if (t.coord == null || !fe(i))
      t.coord = [];
    else
      for (var u = t.coord, c = 0; c < 2; c++)
        Px[u[c]] && (u[c] = sA(r, r.mapDimension(i[c]), u[c]));
    return t;
  }
}
function SU(e, t, r, n) {
  var i = {};
  return e.valueIndex != null || e.valueDim != null ? (i.valueDataDim = e.valueIndex != null ? t.getDimension(e.valueIndex) : e.valueDim, i.valueAxis = r.getAxis(BIe(n, i.valueDataDim)), i.baseAxis = r.getOtherAxis(i.valueAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim)) : (i.baseAxis = n.getBaseAxis(), i.valueAxis = r.getOtherAxis(i.baseAxis), i.baseDataDim = t.mapDimension(i.baseAxis.dim), i.valueDataDim = t.mapDimension(i.valueAxis.dim)), i;
}
function BIe(e, t) {
  var r = e.getData().getDimensionInfo(t);
  return r && r.coordDim;
}
function nv(e, t) {
  return e && e.containData && t.coord && !sT(t) ? e.containData(t.coord) : !0;
}
function GIe(e, t, r) {
  return e && e.containZone && t.coord && r.coord && !sT(t) && !sT(r) ? e.containZone(t.coord, r.coord) : !0;
}
function wU(e, t) {
  return e ? function(r, n, i, o) {
    var a = o < 2 ? r.coord && r.coord[o] : r.value;
    return Ol(a, t[o]);
  } : function(r, n, i, o) {
    return Ol(r.value, t[o]);
  };
}
function sA(e, t, r) {
  if (r === "average") {
    var n = 0, i = 0;
    return e.each(t, function(o, a) {
      isNaN(o) || (n += o, i++);
    }), n / i;
  } else return r === "median" ? e.getMedian(t) : e.getDataExtent(t)[r === "max" ? 1 : 0];
}
var Mx = Gt(), lA = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.init = function() {
      this.markerGroupMap = We();
    }, t.prototype.render = function(r, n, i) {
      var o = this, a = this.markerGroupMap;
      a.each(function(s) {
        Mx(s).keep = !1;
      }), n.eachSeries(function(s) {
        var l = Ys.getMarkerModelFromSeries(s, o.type);
        l && o.renderSeries(s, l, n, i);
      }), a.each(function(s) {
        !Mx(s).keep && o.group.remove(s.group);
      });
    }, t.prototype.markKeep = function(r) {
      Mx(r).keep = !0;
    }, t.prototype.toggleBlurSeries = function(r, n) {
      var i = this;
      B(r, function(o) {
        var a = Ys.getMarkerModelFromSeries(o, i.type);
        if (a) {
          var s = a.getData();
          s.eachItemGraphicEl(function(l) {
            l && (n ? i6(l) : vM(l));
          });
        }
      });
    }, t.type = "marker", t;
  }(Rr)
);
function F4(e, t, r) {
  var n = t.coordinateSystem;
  e.each(function(i) {
    var o = e.getItemModel(i), a, s = Ae(o.get("x"), r.getWidth()), l = Ae(o.get("y"), r.getHeight());
    if (!isNaN(s) && !isNaN(l))
      a = [s, l];
    else if (t.getMarkerPosition)
      a = t.getMarkerPosition(e.getValues(e.dimensions, i));
    else if (n) {
      var u = e.get(n.dimensions[0], i), c = e.get(n.dimensions[1], i);
      a = n.dataToPoint([u, c]);
    }
    isNaN(s) || (a[0] = s), isNaN(l) || (a[1] = l), e.setItemLayout(i, a);
  });
}
var HIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.updateTransform = function(r, n, i) {
      n.eachSeries(function(o) {
        var a = Ys.getMarkerModelFromSeries(o, "markPoint");
        a && (F4(a.getData(), o, i), this.markerGroupMap.get(o.id).updateLayout());
      }, this);
    }, t.prototype.renderSeries = function(r, n, i, o) {
      var a = r.coordinateSystem, s = r.id, l = r.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new Vv()), d = zIe(a, r, n);
      n.setData(d), F4(n.getData(), r, o), d.each(function(h) {
        var f = d.getItemModel(h), p = f.getShallow("symbol"), g = f.getShallow("symbolSize"), v = f.getShallow("symbolRotate"), m = f.getShallow("symbolOffset"), y = f.getShallow("symbolKeepAspect");
        if (Ye(p) || Ye(g) || Ye(v) || Ye(m)) {
          var C = n.getRawValue(h), S = n.getDataParams(h);
          Ye(p) && (p = p(C, S)), Ye(g) && (g = g(C, S)), Ye(v) && (v = v(C, S)), Ye(m) && (m = m(C, S));
        }
        var b = f.getModel("itemStyle").getItemStyle(), w = Ov(l, "color");
        b.fill || (b.fill = w), d.setItemVisual(h, {
          symbol: p,
          symbolSize: g,
          symbolRotate: v,
          symbolOffset: m,
          symbolKeepAspect: y,
          style: b
        });
      }), c.updateData(d), this.group.add(c.group), d.eachItemGraphicEl(function(h) {
        h.traverse(function(f) {
          ot(f).dataModel = n;
        });
      }), this.markKeep(c), c.group.silent = n.get("silent") || r.get("silent");
    }, t.type = "markPoint", t;
  }(lA)
);
function zIe(e, t, r) {
  var n;
  e ? n = ge(e && e.dimensions, function(s) {
    var l = t.getData().getDimensionInfo(t.getData().mapDimension(s)) || {};
    return se(se({}, l), {
      name: s,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : n = [{
    name: "value",
    type: "float"
  }];
  var i = new Jn(n, r), o = ge(r.get("data"), dt(rv, t));
  e && (o = ir(o, dt(nv, e)));
  var a = wU(!!e, n);
  return i.initData(o, null, a), i;
}
function $Ie(e) {
  e.registerComponentModel(kIe), e.registerComponentView(HIe), e.registerPreprocessor(function(t) {
    aA(t.series, "markPoint") && (t.markPoint = t.markPoint || {});
  });
}
var WIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.createMarkerModelFromSeries = function(r, n, i) {
      return new t(r, n, i);
    }, t.type = "markLine", t.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, t;
  }(Ys)
), by = Gt(), jIe = function(e, t, r, n) {
  var i = e.getData(), o;
  if (fe(n))
    o = n;
  else {
    var a = n.type;
    if (a === "min" || a === "max" || a === "average" || a === "median" || n.xAxis != null || n.yAxis != null) {
      var s = void 0, l = void 0;
      if (n.yAxis != null || n.xAxis != null)
        s = t.getAxis(n.yAxis != null ? "y" : "x"), l = tn(n.yAxis, n.xAxis);
      else {
        var u = SU(n, i, t, e);
        s = u.valueAxis;
        var c = tD(i, u.valueDataDim);
        l = sA(i, c, a);
      }
      var d = s.dim === "x" ? 0 : 1, h = 1 - d, f = et(n), p = {
        coord: []
      };
      f.type = null, f.coord = [], f.coord[h] = -1 / 0, p.coord[h] = 1 / 0;
      var g = r.get("precision");
      g >= 0 && $t(l) && (l = +l.toFixed(Math.min(g, 20))), f.coord[d] = p.coord[d] = l, o = [f, p, {
        type: a,
        valueIndex: n.valueIndex,
        // Force to use the value of calculated value.
        value: l
      }];
    } else
      process.env.NODE_ENV !== "production" && Mo("Invalid markLine data."), o = [];
  }
  var v = [rv(e, o[0]), rv(e, o[1]), se({}, o[2])];
  return v[2].type = v[2].type || null, yt(v[2], v[0]), yt(v[2], v[1]), v;
};
function IC(e) {
  return !isNaN(e) && !isFinite(e);
}
function L4(e, t, r, n) {
  var i = 1 - e, o = n.dimensions[e];
  return IC(t[i]) && IC(r[i]) && t[e] === r[e] && n.getAxis(o).containData(t[e]);
}
function UIe(e, t) {
  if (e.type === "cartesian2d") {
    var r = t[0].coord, n = t[1].coord;
    if (r && n && (L4(1, r, n, e) || L4(0, r, n, e)))
      return !0;
  }
  return nv(e, t[0]) && nv(e, t[1]);
}
function Dx(e, t, r, n, i) {
  var o = n.coordinateSystem, a = e.getItemModel(t), s, l = Ae(a.get("x"), i.getWidth()), u = Ae(a.get("y"), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (n.getMarkerPosition)
      s = n.getMarkerPosition(e.getValues(e.dimensions, t));
    else {
      var c = o.dimensions, d = e.get(c[0], t), h = e.get(c[1], t);
      s = o.dataToPoint([d, h]);
    }
    if (Zc(o, "cartesian2d")) {
      var f = o.getAxis("x"), p = o.getAxis("y"), c = o.dimensions;
      IC(e.get(c[0], t)) ? s[0] = f.toGlobalCoord(f.getExtent()[r ? 0 : 1]) : IC(e.get(c[1], t)) && (s[1] = p.toGlobalCoord(p.getExtent()[r ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  e.setItemLayout(t, s);
}
var KIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.updateTransform = function(r, n, i) {
      n.eachSeries(function(o) {
        var a = Ys.getMarkerModelFromSeries(o, "markLine");
        if (a) {
          var s = a.getData(), l = by(a).from, u = by(a).to;
          l.each(function(c) {
            Dx(l, c, !0, o, i), Dx(u, c, !1, o, i);
          }), s.each(function(c) {
            s.setItemLayout(c, [l.getItemLayout(c), u.getItemLayout(c)]);
          }), this.markerGroupMap.get(o.id).updateLayout();
        }
      }, this);
    }, t.prototype.renderSeries = function(r, n, i, o) {
      var a = r.coordinateSystem, s = r.id, l = r.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new AD());
      this.group.add(c.group);
      var d = YIe(a, r, n), h = d.from, f = d.to, p = d.line;
      by(n).from = h, by(n).to = f, n.setData(p);
      var g = n.get("symbol"), v = n.get("symbolSize"), m = n.get("symbolRotate"), y = n.get("symbolOffset");
      fe(g) || (g = [g, g]), fe(v) || (v = [v, v]), fe(m) || (m = [m, m]), fe(y) || (y = [y, y]), d.from.each(function(S) {
        C(h, S, !0), C(f, S, !1);
      }), p.each(function(S) {
        var b = p.getItemModel(S).getModel("lineStyle").getLineStyle();
        p.setItemLayout(S, [h.getItemLayout(S), f.getItemLayout(S)]), b.stroke == null && (b.stroke = h.getItemVisual(S, "style").fill), p.setItemVisual(S, {
          fromSymbolKeepAspect: h.getItemVisual(S, "symbolKeepAspect"),
          fromSymbolOffset: h.getItemVisual(S, "symbolOffset"),
          fromSymbolRotate: h.getItemVisual(S, "symbolRotate"),
          fromSymbolSize: h.getItemVisual(S, "symbolSize"),
          fromSymbol: h.getItemVisual(S, "symbol"),
          toSymbolKeepAspect: f.getItemVisual(S, "symbolKeepAspect"),
          toSymbolOffset: f.getItemVisual(S, "symbolOffset"),
          toSymbolRotate: f.getItemVisual(S, "symbolRotate"),
          toSymbolSize: f.getItemVisual(S, "symbolSize"),
          toSymbol: f.getItemVisual(S, "symbol"),
          style: b
        });
      }), c.updateData(p), d.line.eachItemGraphicEl(function(S) {
        ot(S).dataModel = n, S.traverse(function(b) {
          ot(b).dataModel = n;
        });
      });
      function C(S, b, w) {
        var x = S.getItemModel(b);
        Dx(S, b, w, r, o);
        var E = x.getModel("itemStyle").getItemStyle();
        E.fill == null && (E.fill = Ov(l, "color")), S.setItemVisual(b, {
          symbolKeepAspect: x.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: st(x.get("symbolOffset", !0), y[w ? 0 : 1]),
          symbolRotate: st(x.get("symbolRotate", !0), m[w ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: st(x.get("symbolSize"), v[w ? 0 : 1]),
          symbol: st(x.get("symbol", !0), g[w ? 0 : 1]),
          style: E
        });
      }
      this.markKeep(c), c.group.silent = n.get("silent") || r.get("silent");
    }, t.type = "markLine", t;
  }(lA)
);
function YIe(e, t, r) {
  var n;
  e ? n = ge(e && e.dimensions, function(u) {
    var c = t.getData().getDimensionInfo(t.getData().mapDimension(u)) || {};
    return se(se({}, c), {
      name: u,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : n = [{
    name: "value",
    type: "float"
  }];
  var i = new Jn(n, r), o = new Jn(n, r), a = new Jn([], r), s = ge(r.get("data"), dt(jIe, t, e, r));
  e && (s = ir(s, dt(UIe, e)));
  var l = wU(!!e, n);
  return i.initData(ge(s, function(u) {
    return u[0];
  }), null, l), o.initData(ge(s, function(u) {
    return u[1];
  }), null, l), a.initData(ge(s, function(u) {
    return u[2];
  })), a.hasItemOption = !0, {
    from: i,
    to: o,
    line: a
  };
}
function qIe(e) {
  e.registerComponentModel(WIe), e.registerComponentView(KIe), e.registerPreprocessor(function(t) {
    aA(t.series, "markLine") && (t.markLine = t.markLine || {});
  });
}
var ZIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.createMarkerModelFromSeries = function(r, n, i) {
      return new t(r, n, i);
    }, t.type = "markArea", t.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, t;
  }(Ys)
), xy = Gt(), XIe = function(e, t, r, n) {
  var i = n[0], o = n[1];
  if (!(!i || !o)) {
    var a = rv(e, i), s = rv(e, o), l = a.coord, u = s.coord;
    l[0] = tn(l[0], -1 / 0), l[1] = tn(l[1], -1 / 0), u[0] = tn(u[0], 1 / 0), u[1] = tn(u[1], 1 / 0);
    var c = wS([{}, a, s]);
    return c.coord = [a.coord, s.coord], c.x0 = a.x, c.y0 = a.y, c.x1 = s.x, c.y1 = s.y, c;
  }
};
function FC(e) {
  return !isNaN(e) && !isFinite(e);
}
function O4(e, t, r, n) {
  var i = 1 - e;
  return FC(t[i]) && FC(r[i]);
}
function QIe(e, t) {
  var r = t.coord[0], n = t.coord[1], i = {
    coord: r,
    x: t.x0,
    y: t.y0
  }, o = {
    coord: n,
    x: t.x1,
    y: t.y1
  };
  return Zc(e, "cartesian2d") ? r && n && (O4(1, r, n) || O4(0, r, n)) ? !0 : GIe(e, i, o) : nv(e, i) || nv(e, o);
}
function N4(e, t, r, n, i) {
  var o = n.coordinateSystem, a = e.getItemModel(t), s, l = Ae(a.get(r[0]), i.getWidth()), u = Ae(a.get(r[1]), i.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (n.getMarkerPosition) {
      var c = e.getValues(["x0", "y0"], t), d = e.getValues(["x1", "y1"], t), h = o.clampData(c), f = o.clampData(d), p = [];
      r[0] === "x0" ? p[0] = h[0] > f[0] ? d[0] : c[0] : p[0] = h[0] > f[0] ? c[0] : d[0], r[1] === "y0" ? p[1] = h[1] > f[1] ? d[1] : c[1] : p[1] = h[1] > f[1] ? c[1] : d[1], s = n.getMarkerPosition(p, r, !0);
    } else {
      var g = e.get(r[0], t), v = e.get(r[1], t), m = [g, v];
      o.clampData && o.clampData(m, m), s = o.dataToPoint(m, !0);
    }
    if (Zc(o, "cartesian2d")) {
      var y = o.getAxis("x"), C = o.getAxis("y"), g = e.get(r[0], t), v = e.get(r[1], t);
      FC(g) ? s[0] = y.toGlobalCoord(y.getExtent()[r[0] === "x0" ? 0 : 1]) : FC(v) && (s[1] = C.toGlobalCoord(C.getExtent()[r[1] === "y0" ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  return s;
}
var k4 = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], JIe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.updateTransform = function(r, n, i) {
      n.eachSeries(function(o) {
        var a = Ys.getMarkerModelFromSeries(o, "markArea");
        if (a) {
          var s = a.getData();
          s.each(function(l) {
            var u = ge(k4, function(d) {
              return N4(s, l, d, o, i);
            });
            s.setItemLayout(l, u);
            var c = s.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, t.prototype.renderSeries = function(r, n, i, o) {
      var a = r.coordinateSystem, s = r.id, l = r.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, {
        group: new it()
      });
      this.group.add(c.group), this.markKeep(c);
      var d = e2e(a, r, n);
      n.setData(d), d.each(function(h) {
        var f = ge(k4, function(E) {
          return N4(d, h, E, r, o);
        }), p = a.getAxis("x").scale, g = a.getAxis("y").scale, v = p.getExtent(), m = g.getExtent(), y = [p.parse(d.get("x0", h)), p.parse(d.get("x1", h))], C = [g.parse(d.get("y0", h)), g.parse(d.get("y1", h))];
        Ji(y), Ji(C);
        var S = !(v[0] > y[1] || v[1] < y[0] || m[0] > C[1] || m[1] < C[0]), b = !S;
        d.setItemLayout(h, {
          points: f,
          allClipped: b
        });
        var w = d.getItemModel(h).getModel("itemStyle").getItemStyle(), x = Ov(l, "color");
        w.fill || (w.fill = x, Fe(w.fill) && (w.fill = Lg(w.fill, 0.4))), w.stroke || (w.stroke = x), d.setItemVisual(h, "style", w);
      }), d.diff(xy(c).data).add(function(h) {
        var f = d.getItemLayout(h);
        if (!f.allClipped) {
          var p = new Ei({
            shape: {
              points: f.points
            }
          });
          d.setItemGraphicEl(h, p), c.group.add(p);
        }
      }).update(function(h, f) {
        var p = xy(c).data.getItemGraphicEl(f), g = d.getItemLayout(h);
        g.allClipped ? p && c.group.remove(p) : (p ? jt(p, {
          shape: {
            points: g.points
          }
        }, n, h) : p = new Ei({
          shape: {
            points: g.points
          }
        }), d.setItemGraphicEl(h, p), c.group.add(p));
      }).remove(function(h) {
        var f = xy(c).data.getItemGraphicEl(h);
        c.group.remove(f);
      }).execute(), d.eachItemGraphicEl(function(h, f) {
        var p = d.getItemModel(f), g = d.getItemVisual(f, "style");
        h.useStyle(d.getItemVisual(f, "style")), Gn(h, Rn(p), {
          labelFetcher: n,
          labelDataIndex: f,
          defaultText: d.getName(f) || "",
          inheritColor: Fe(g.fill) ? Lg(g.fill, 1) : "#000"
        }), Bn(h, p), Hr(h, null, null, p.get(["emphasis", "disabled"])), ot(h).dataModel = n;
      }), xy(c).data = d, c.group.silent = n.get("silent") || r.get("silent");
    }, t.type = "markArea", t;
  }(lA)
);
function e2e(e, t, r) {
  var n, i, o = ["x0", "y0", "x1", "y1"];
  if (e) {
    var a = ge(e && e.dimensions, function(u) {
      var c = t.getData(), d = c.getDimensionInfo(c.mapDimension(u)) || {};
      return se(se({}, d), {
        name: u,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    i = ge(o, function(u, c) {
      return {
        name: u,
        type: a[c % 2].type
      };
    }), n = new Jn(i, r);
  } else
    i = [{
      name: "value",
      type: "float"
    }], n = new Jn(i, r);
  var s = ge(r.get("data"), dt(XIe, t, e, r));
  e && (s = ir(s, dt(QIe, e)));
  var l = e ? function(u, c, d, h) {
    var f = u.coord[Math.floor(h / 2)][h % 2];
    return Ol(f, i[h]);
  } : function(u, c, d, h) {
    return Ol(u.value, i[h]);
  };
  return n.initData(s, null, l), n.hasItemOption = !0, n;
}
function t2e(e) {
  e.registerComponentModel(ZIe), e.registerComponentView(JIe), e.registerPreprocessor(function(t) {
    aA(t.series, "markArea") && (t.markArea = t.markArea || {});
  });
}
var r2e = function(e, t) {
  if (t === "all")
    return {
      type: "all",
      title: e.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (t === "inverse")
    return {
      type: "inverse",
      title: e.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, lT = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, r;
    }
    return t.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i), r.selected = r.selected || {}, this._updateSelector(r);
    }, t.prototype.mergeOption = function(r, n) {
      e.prototype.mergeOption.call(this, r, n), this._updateSelector(r);
    }, t.prototype._updateSelector = function(r) {
      var n = r.selector, i = this.ecModel;
      n === !0 && (n = r.selector = ["all", "inverse"]), fe(n) && B(n, function(o, a) {
        Fe(o) && (o = {
          type: o
        }), n[a] = yt(o, r2e(i, o.type));
      });
    }, t.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var r = this._data;
      if (r[0] && this.get("selectedMode") === "single") {
        for (var n = !1, i = 0; i < r.length; i++) {
          var o = r[i].get("name");
          if (this.isSelected(o)) {
            this.select(o), n = !0;
            break;
          }
        }
        !n && this.select(r[0].get("name"));
      }
    }, t.prototype._updateData = function(r) {
      var n = [], i = [];
      r.eachRawSeries(function(l) {
        var u = l.name;
        i.push(u);
        var c;
        if (l.legendVisualProvider) {
          var d = l.legendVisualProvider, h = d.getAllNames();
          r.isSeriesFiltered(l) || (i = i.concat(h)), h.length ? n = n.concat(h) : c = !0;
        } else
          c = !0;
        c && lM(l) && n.push(l.name);
      }), this._availableNames = i;
      var o = this.get("data") || n, a = We(), s = ge(o, function(l) {
        return (Fe(l) || $t(l)) && (l = {
          name: l
        }), a.get(l.name) ? null : (a.set(l.name, !0), new cr(l, this, this.ecModel));
      }, this);
      this._data = ir(s, function(l) {
        return !!l;
      });
    }, t.prototype.getData = function() {
      return this._data;
    }, t.prototype.select = function(r) {
      var n = this.option.selected, i = this.get("selectedMode");
      if (i === "single") {
        var o = this._data;
        B(o, function(a) {
          n[a.get("name")] = !1;
        });
      }
      n[r] = !0;
    }, t.prototype.unSelect = function(r) {
      this.get("selectedMode") !== "single" && (this.option.selected[r] = !1);
    }, t.prototype.toggleSelected = function(r) {
      var n = this.option.selected;
      n.hasOwnProperty(r) || (n[r] = !0), this[n[r] ? "unSelect" : "select"](r);
    }, t.prototype.allSelect = function() {
      var r = this._data, n = this.option.selected;
      B(r, function(i) {
        n[i.get("name", !0)] = !0;
      });
    }, t.prototype.inverseSelect = function() {
      var r = this._data, n = this.option.selected;
      B(r, function(i) {
        var o = i.get("name", !0);
        n.hasOwnProperty(o) || (n[o] = !0), n[o] = !n[o];
      });
    }, t.prototype.isSelected = function(r) {
      var n = this.option.selected;
      return !(n.hasOwnProperty(r) && !n[r]) && bt(this._availableNames, r) >= 0;
    }, t.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, t.type = "legend.plain", t.dependencies = ["series"], t.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      }
    }, t;
  }(Rt)
), Nd = dt, uT = B, Ey = it, bU = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.newlineDisabled = !1, r;
    }
    return t.prototype.init = function() {
      this.group.add(this._contentGroup = new Ey()), this.group.add(this._selectorGroup = new Ey()), this._isFirstRender = !0;
    }, t.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, t.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, t.prototype.render = function(r, n, i) {
      var o = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!r.get("show", !0)) {
        var a = r.get("align"), s = r.get("orient");
        (!a || a === "auto") && (a = r.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = r.get("selector", !0), u = r.get("selectorPosition", !0);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(a, r, n, i, l, s, u);
        var c = r.getBoxLayoutParams(), d = {
          width: i.getWidth(),
          height: i.getHeight()
        }, h = r.get("padding"), f = hn(c, d, h), p = this.layoutInner(r, a, f, o, l, u), g = hn(Xe({
          width: p.width,
          height: p.height
        }, c), d, h);
        this.group.x = g.x - p.x, this.group.y = g.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = cU(p, r));
      }
    }, t.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, t.prototype.renderInner = function(r, n, i, o, a, s, l) {
      var u = this.getContentGroup(), c = We(), d = n.get("selectedMode"), h = [];
      i.eachRawSeries(function(f) {
        !f.get("legendHoverLink") && h.push(f.id);
      }), uT(n.getData(), function(f, p) {
        var g = f.get("name");
        if (!this.newlineDisabled && (g === "" || g === `
`)) {
          var v = new Ey();
          v.newline = !0, u.add(v);
          return;
        }
        var m = i.getSeriesByName(g)[0];
        if (!c.get(g)) {
          if (m) {
            var y = m.getData(), C = y.getVisual("legendLineStyle") || {}, S = y.getVisual("legendIcon"), b = y.getVisual("style"), w = this._createItem(m, g, p, f, n, r, C, b, S, d, o);
            w.on("click", Nd(V4, g, null, o, h)).on("mouseover", Nd(cT, m.name, null, o, h)).on("mouseout", Nd(dT, m.name, null, o, h)), i.ssr && w.eachChild(function(x) {
              var E = ot(x);
              E.seriesIndex = m.seriesIndex, E.dataIndex = p, E.ssrType = "legend";
            }), c.set(g, !0);
          } else
            i.eachRawSeries(function(x) {
              if (!c.get(g) && x.legendVisualProvider) {
                var E = x.legendVisualProvider;
                if (!E.containName(g))
                  return;
                var R = E.indexOfName(g), _ = E.getItemVisual(R, "style"), P = E.getItemVisual(R, "legendIcon"), D = yi(_.fill);
                D && D[3] === 0 && (D[3] = 0.2, _ = se(se({}, _), {
                  fill: ha(D, "rgba")
                }));
                var I = this._createItem(x, g, p, f, n, r, {}, _, P, d, o);
                I.on("click", Nd(V4, null, g, o, h)).on("mouseover", Nd(cT, null, g, o, h)).on("mouseout", Nd(dT, null, g, o, h)), i.ssr && I.eachChild(function(A) {
                  var O = ot(A);
                  O.seriesIndex = x.seriesIndex, O.dataIndex = p, O.ssrType = "legend";
                }), c.set(g, !0);
              }
            }, this);
          process.env.NODE_ENV !== "production" && (c.get(g) || console.warn(g + " series not exists. Legend data should be same with series name or data name."));
        }
      }, this), a && this._createSelector(a, n, o, s, l);
    }, t.prototype._createSelector = function(r, n, i, o, a) {
      var s = this.getSelectorGroup();
      uT(r, function(u) {
        var c = u.type, d = new Vt({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            i.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect"
            });
          }
        });
        s.add(d);
        var h = n.getModel("selectorLabel"), f = n.getModel(["emphasis", "selectorLabel"]);
        Gn(d, {
          normal: h,
          emphasis: f
        }, {
          defaultText: u.title
        }), Fl(d);
      });
    }, t.prototype._createItem = function(r, n, i, o, a, s, l, u, c, d, h) {
      var f = r.visualDrawType, p = a.get("itemWidth"), g = a.get("itemHeight"), v = a.isSelected(n), m = o.get("symbolRotate"), y = o.get("symbolKeepAspect"), C = o.get("icon");
      c = C || c || "roundRect";
      var S = n2e(c, o, l, u, f, v, h), b = new Ey(), w = o.getModel("textStyle");
      if (Ye(r.getLegendIcon) && (!C || C === "inherit"))
        b.add(r.getLegendIcon({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: m,
          itemStyle: S.itemStyle,
          lineStyle: S.lineStyle,
          symbolKeepAspect: y
        }));
      else {
        var x = C === "inherit" && r.getData().getVisual("symbol") ? m === "inherit" ? r.getData().getVisual("symbolRotate") : m : 0;
        b.add(i2e({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: x,
          itemStyle: S.itemStyle,
          lineStyle: S.lineStyle,
          symbolKeepAspect: y
        }));
      }
      var E = s === "left" ? p + 5 : -5, R = s, _ = a.get("formatter"), P = n;
      Fe(_) && _ ? P = _.replace("{name}", n ?? "") : Ye(_) && (P = _(n));
      var D = v ? w.getTextColor() : o.get("inactiveColor");
      b.add(new Vt({
        style: br(w, {
          text: P,
          x: E,
          y: g / 2,
          fill: D,
          align: R,
          verticalAlign: "middle"
        }, {
          inheritColor: D
        })
      }));
      var I = new Bt({
        shape: b.getBoundingRect(),
        style: {
          // Cannot use 'invisible' because SVG SSR will miss the node
          fill: "transparent"
        }
      }), A = o.getModel("tooltip");
      return A.get("show") && uf({
        el: I,
        componentModel: a,
        itemName: n,
        itemTooltipOption: A.option
      }), b.add(I), b.eachChild(function(O) {
        O.silent = !0;
      }), I.silent = !d, this.getContentGroup().add(b), Fl(b), b.__legendDataIndex = i, b;
    }, t.prototype.layoutInner = function(r, n, i, o, a, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      pc(r.get("orient"), l, r.get("itemGap"), i.width, i.height);
      var c = l.getBoundingRect(), d = [-c.x, -c.y];
      if (u.markRedraw(), l.markRedraw(), a) {
        pc(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          u,
          r.get("selectorItemGap", !0)
        );
        var h = u.getBoundingRect(), f = [-h.x, -h.y], p = r.get("selectorButtonGap", !0), g = r.getOrient().index, v = g === 0 ? "width" : "height", m = g === 0 ? "height" : "width", y = g === 0 ? "y" : "x";
        s === "end" ? f[g] += c[v] + p : d[g] += h[v] + p, f[1 - g] += c[m] / 2 - h[m] / 2, u.x = f[0], u.y = f[1], l.x = d[0], l.y = d[1];
        var C = {
          x: 0,
          y: 0
        };
        return C[v] = c[v] + p + h[v], C[m] = Math.max(c[m], h[m]), C[y] = Math.min(0, h[y] + f[1 - g]), C;
      } else
        return l.x = d[0], l.y = d[1], this.group.getBoundingRect();
    }, t.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, t.type = "legend.plain", t;
  }(Rr)
);
function n2e(e, t, r, n, i, o, a) {
  function s(v, m) {
    v.lineWidth === "auto" && (v.lineWidth = m.lineWidth > 0 ? 2 : 0), uT(v, function(y, C) {
      v[C] === "inherit" && (v[C] = m[C]);
    });
  }
  var l = t.getModel("itemStyle"), u = l.getItemStyle(), c = e.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", d = l.getShallow("decal");
  u.decal = !d || d === "inherit" ? n.decal : Nh(d, a), u.fill === "inherit" && (u.fill = n[i]), u.stroke === "inherit" && (u.stroke = n[c]), u.opacity === "inherit" && (u.opacity = (i === "fill" ? n : r).opacity), s(u, n);
  var h = t.getModel("lineStyle"), f = h.getLineStyle();
  if (s(f, r), u.fill === "auto" && (u.fill = n.fill), u.stroke === "auto" && (u.stroke = n.fill), f.stroke === "auto" && (f.stroke = n.fill), !o) {
    var p = t.get("inactiveBorderWidth"), g = u[c];
    u.lineWidth = p === "auto" ? n.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = t.get("inactiveColor"), u.stroke = t.get("inactiveBorderColor"), f.stroke = h.get("inactiveColor"), f.lineWidth = h.get("inactiveWidth");
  }
  return {
    itemStyle: u,
    lineStyle: f
  };
}
function i2e(e) {
  var t = e.icon || "roundRect", r = rn(t, 0, 0, e.itemWidth, e.itemHeight, e.itemStyle.fill, e.symbolKeepAspect);
  return r.setStyle(e.itemStyle), r.rotation = (e.iconRotate || 0) * Math.PI / 180, r.setOrigin([e.itemWidth / 2, e.itemHeight / 2]), t.indexOf("empty") > -1 && (r.style.stroke = r.style.fill, r.style.fill = "#fff", r.style.lineWidth = 2), r;
}
function V4(e, t, r, n) {
  dT(e, t, r, n), r.dispatchAction({
    type: "legendToggleSelect",
    name: e ?? t
  }), cT(e, t, r, n);
}
function xU(e) {
  for (var t = e.getZr().storage.getDisplayList(), r, n = 0, i = t.length; n < i && !(r = t[n].states.emphasis); )
    n++;
  return r && r.hoverLayer;
}
function cT(e, t, r, n) {
  xU(r) || r.dispatchAction({
    type: "highlight",
    seriesName: e,
    name: t,
    excludeSeriesId: n
  });
}
function dT(e, t, r, n) {
  xU(r) || r.dispatchAction({
    type: "downplay",
    seriesName: e,
    name: t,
    excludeSeriesId: n
  });
}
function o2e(e) {
  var t = e.findComponents({
    mainType: "legend"
  });
  t && t.length && e.filterSeries(function(r) {
    for (var n = 0; n < t.length; n++)
      if (!t[n].isSelected(r.name))
        return !1;
    return !0;
  });
}
function gp(e, t, r) {
  var n = {}, i = e === "toggleSelected", o;
  return r.eachComponent("legend", function(a) {
    i && o != null ? a[o ? "select" : "unSelect"](t.name) : e === "allSelect" || e === "inverseSelect" ? a[e]() : (a[e](t.name), o = a.isSelected(t.name));
    var s = a.getData();
    B(s, function(l) {
      var u = l.get("name");
      if (!(u === `
` || u === "")) {
        var c = a.isSelected(u);
        n.hasOwnProperty(u) ? n[u] = n[u] && c : n[u] = c;
      }
    });
  }), e === "allSelect" || e === "inverseSelect" ? {
    selected: n
  } : {
    name: t.name,
    selected: n
  };
}
function a2e(e) {
  e.registerAction("legendToggleSelect", "legendselectchanged", dt(gp, "toggleSelected")), e.registerAction("legendAllSelect", "legendselectall", dt(gp, "allSelect")), e.registerAction("legendInverseSelect", "legendinverseselect", dt(gp, "inverseSelect")), e.registerAction("legendSelect", "legendselected", dt(gp, "select")), e.registerAction("legendUnSelect", "legendunselected", dt(gp, "unSelect"));
}
function EU(e) {
  e.registerComponentModel(lT), e.registerComponentView(bU), e.registerProcessor(e.PRIORITY.PROCESSOR.SERIES_FILTER, o2e), e.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), a2e(e);
}
var s2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.setScrollDataIndex = function(r) {
      this.option.scrollDataIndex = r;
    }, t.prototype.init = function(r, n, i) {
      var o = hf(r);
      e.prototype.init.call(this, r, n, i), B4(this, r, o);
    }, t.prototype.mergeOption = function(r, n) {
      e.prototype.mergeOption.call(this, r, n), B4(this, this.option, r);
    }, t.type = "legend.scroll", t.defaultOption = ou(lT.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), t;
  }(lT)
);
function B4(e, t, r) {
  var n = e.getOrient(), i = [1, 1];
  i[n.index] = 0, Kl(t, r, {
    type: "box",
    ignoreSize: !!i
  });
}
var G4 = it, Ax = ["width", "height"], Ix = ["x", "y"], l2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.newlineDisabled = !0, r._currentIndex = 0, r;
    }
    return t.prototype.init = function() {
      e.prototype.init.call(this), this.group.add(this._containerGroup = new G4()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new G4());
    }, t.prototype.resetInner = function() {
      e.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, t.prototype.renderInner = function(r, n, i, o, a, s, l) {
      var u = this;
      e.prototype.renderInner.call(this, r, n, i, o, a, s, l);
      var c = this._controllerGroup, d = n.get("pageIconSize", !0), h = fe(d) ? d : [d, d];
      p("pagePrev", 0);
      var f = n.getModel("pageTextStyle");
      c.add(new Vt({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: f.getTextColor(),
          font: f.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), p("pageNext", 1);
      function p(g, v) {
        var m = g + "DataIndex", y = lf(n.get("pageIcons", !0)[n.getOrient().name][v], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: ke(u._pageGo, u, m, n, o)
        }, {
          x: -h[0] / 2,
          y: -h[1] / 2,
          width: h[0],
          height: h[1]
        });
        y.name = g, c.add(y);
      }
    }, t.prototype.layoutInner = function(r, n, i, o, a, s) {
      var l = this.getSelectorGroup(), u = r.getOrient().index, c = Ax[u], d = Ix[u], h = Ax[1 - u], f = Ix[1 - u];
      a && pc(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        l,
        r.get("selectorItemGap", !0)
      );
      var p = r.get("selectorButtonGap", !0), g = l.getBoundingRect(), v = [-g.x, -g.y], m = et(i);
      a && (m[c] = i[c] - g[c] - p);
      var y = this._layoutContentAndController(r, o, m, u, c, h, f, d);
      if (a) {
        if (s === "end")
          v[u] += y[c] + p;
        else {
          var C = g[c] + p;
          v[u] -= C, y[d] -= C;
        }
        y[c] += g[c] + p, v[1 - u] += y[f] + y[h] / 2 - g[h] / 2, y[h] = Math.max(y[h], g[h]), y[f] = Math.min(y[f], g[f] + v[1 - u]), l.x = v[0], l.y = v[1], l.markRedraw();
      }
      return y;
    }, t.prototype._layoutContentAndController = function(r, n, i, o, a, s, l, u) {
      var c = this.getContentGroup(), d = this._containerGroup, h = this._controllerGroup;
      pc(r.get("orient"), c, r.get("itemGap"), o ? i.width : null, o ? null : i.height), pc(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        h,
        r.get("pageButtonItemGap", !0)
      );
      var f = c.getBoundingRect(), p = h.getBoundingRect(), g = this._showController = f[a] > i[a], v = [-f.x, -f.y];
      n || (v[o] = c[u]);
      var m = [0, 0], y = [-p.x, -p.y], C = st(r.get("pageButtonGap", !0), r.get("itemGap", !0));
      if (g) {
        var S = r.get("pageButtonPosition", !0);
        S === "end" ? y[o] += i[a] - p[a] : m[o] += p[a] + C;
      }
      y[1 - o] += f[s] / 2 - p[s] / 2, c.setPosition(v), d.setPosition(m), h.setPosition(y);
      var b = {
        x: 0,
        y: 0
      };
      if (b[a] = g ? i[a] : f[a], b[s] = Math.max(f[s], p[s]), b[l] = Math.min(0, p[l] + y[1 - o]), d.__rectSize = i[a], g) {
        var w = {
          x: 0,
          y: 0
        };
        w[a] = Math.max(i[a] - p[a] - C, 0), w[s] = b[s], d.setClipPath(new Bt({
          shape: w
        })), d.__rectSize = w[a];
      } else
        h.eachChild(function(E) {
          E.attr({
            invisible: !0,
            silent: !0
          });
        });
      var x = this._getPageInfo(r);
      return x.pageIndex != null && jt(
        c,
        {
          x: x.contentPosition[0],
          y: x.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        g ? r : null
      ), this._updatePageInfoView(r, x), b;
    }, t.prototype._pageGo = function(r, n, i) {
      var o = this._getPageInfo(n)[r];
      o != null && i.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: o,
        legendId: n.id
      });
    }, t.prototype._updatePageInfoView = function(r, n) {
      var i = this._controllerGroup;
      B(["pagePrev", "pageNext"], function(c) {
        var d = c + "DataIndex", h = n[d] != null, f = i.childOfName(c);
        f && (f.setStyle("fill", h ? r.get("pageIconColor", !0) : r.get("pageIconInactiveColor", !0)), f.cursor = h ? "pointer" : "default");
      });
      var o = i.childOfName("pageText"), a = r.get("pageFormatter"), s = n.pageIndex, l = s != null ? s + 1 : 0, u = n.pageCount;
      o && a && o.setStyle("text", Fe(a) ? a.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : a({
        current: l,
        total: u
      }));
    }, t.prototype._getPageInfo = function(r) {
      var n = r.get("scrollDataIndex", !0), i = this.getContentGroup(), o = this._containerGroup.__rectSize, a = r.getOrient().index, s = Ax[a], l = Ix[a], u = this._findTargetItemIndex(n), c = i.children(), d = c[u], h = c.length, f = h ? 1 : 0, p = {
        contentPosition: [i.x, i.y],
        pageCount: f,
        pageIndex: f - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!d)
        return p;
      var g = S(d);
      p.contentPosition[a] = -g.s;
      for (var v = u + 1, m = g, y = g, C = null; v <= h; ++v)
        C = S(c[v]), // Half of the last item is out of the window.
        (!C && y.e > m.s + o || C && !b(C, m.s)) && (y.i > m.i ? m = y : m = C, m && (p.pageNextDataIndex == null && (p.pageNextDataIndex = m.i), ++p.pageCount)), y = C;
      for (var v = u - 1, m = g, y = g, C = null; v >= -1; --v)
        C = S(c[v]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!C || !b(y, C.s)) && m.i < y.i && (y = m, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = m.i), ++p.pageCount, ++p.pageIndex), m = C;
      return p;
      function S(w) {
        if (w) {
          var x = w.getBoundingRect(), E = x[l] + w[l];
          return {
            s: E,
            e: E + x[s],
            i: w.__legendDataIndex
          };
        }
      }
      function b(w, x) {
        return w.e >= x && w.s <= x + o;
      }
    }, t.prototype._findTargetItemIndex = function(r) {
      if (!this._showController)
        return 0;
      var n, i = this.getContentGroup(), o;
      return i.eachChild(function(a, s) {
        var l = a.__legendDataIndex;
        o == null && l != null && (o = s), l === r && (n = s);
      }), n ?? o;
    }, t.type = "legend.scroll", t;
  }(bU)
);
function u2e(e) {
  e.registerAction("legendScroll", "legendscroll", function(t, r) {
    var n = t.scrollDataIndex;
    n != null && r.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: t
    }, function(i) {
      i.setScrollDataIndex(n);
    });
  });
}
function c2e(e) {
  _t(EU), e.registerComponentModel(s2e), e.registerComponentView(l2e), u2e(e);
}
function d2e(e) {
  _t(EU), _t(c2e);
}
var h2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "dataZoom.inside", t.defaultOption = ou(tv.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), t;
  }(tv)
), uA = Gt();
function f2e(e, t, r) {
  uA(e).coordSysRecordMap.each(function(n) {
    var i = n.dataZoomInfoMap.get(t.uid);
    i && (i.getRange = r);
  });
}
function p2e(e, t) {
  for (var r = uA(e).coordSysRecordMap, n = r.keys(), i = 0; i < n.length; i++) {
    var o = n[i], a = r.get(o), s = a.dataZoomInfoMap;
    if (s) {
      var l = t.uid, u = s.get(l);
      u && (s.removeKey(l), s.keys().length || RU(r, a));
    }
  }
}
function RU(e, t) {
  if (t) {
    e.removeKey(t.model.uid);
    var r = t.controller;
    r && r.dispose();
  }
}
function g2e(e, t) {
  var r = {
    model: t,
    containsPoint: dt(m2e, t),
    dispatchAction: dt(v2e, e),
    dataZoomInfoMap: null,
    controller: null
  }, n = r.controller = new $v(e.getZr());
  return B(["pan", "zoom", "scrollMove"], function(i) {
    n.on(i, function(o) {
      var a = [];
      r.dataZoomInfoMap.each(function(s) {
        if (o.isAvailableBehavior(s.model.option)) {
          var l = (s.getRange || {})[i], u = l && l(s.dzReferCoordSysInfo, r.model.mainType, r.controller, o);
          !s.model.get("disabled", !0) && u && a.push({
            dataZoomId: s.model.id,
            start: u[0],
            end: u[1]
          });
        }
      }), a.length && r.dispatchAction(a);
    });
  }), r;
}
function v2e(e, t) {
  e.isDisposed() || e.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: t
  });
}
function m2e(e, t, r, n) {
  return e.coordinateSystem.containPoint([r, n]);
}
function y2e(e) {
  var t, r = "type_", n = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, i = !0;
  return e.each(function(o) {
    var a = o.model, s = a.get("disabled", !0) ? !1 : a.get("zoomLock", !0) ? "move" : !0;
    n[r + s] > n[r + t] && (t = s), i = i && a.get("preventDefaultMouseMove", !0);
  }), {
    controlType: t,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!i
    }
  };
}
function C2e(e) {
  e.registerProcessor(e.PRIORITY.PROCESSOR.FILTER, function(t, r) {
    var n = uA(r), i = n.coordSysRecordMap || (n.coordSysRecordMap = We());
    i.each(function(o) {
      o.dataZoomInfoMap = null;
    }), t.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(o) {
      var a = sU(o);
      B(a.infoList, function(s) {
        var l = s.model.uid, u = i.get(l) || i.set(l, g2e(r, s.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = We());
        c.set(o.uid, {
          dzReferCoordSysInfo: s,
          model: o,
          getRange: null
        });
      });
    }), i.each(function(o) {
      var a = o.controller, s, l = o.dataZoomInfoMap;
      if (l) {
        var u = l.keys()[0];
        u != null && (s = l.get(u));
      }
      if (!s) {
        RU(i, o);
        return;
      }
      var c = y2e(l);
      a.enable(c.controlType, c.opt), a.setPointerChecker(o.containsPoint), gf(o, "dispatchAction", s.model.get("throttle", !0), "fixRate");
    });
  });
}
var S2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "dataZoom.inside", r;
    }
    return t.prototype.render = function(r, n, i) {
      if (e.prototype.render.apply(this, arguments), r.noTarget()) {
        this._clear();
        return;
      }
      this.range = r.getPercentRange(), f2e(i, r, {
        pan: ke(Fx.pan, this),
        zoom: ke(Fx.zoom, this),
        scrollMove: ke(Fx.scrollMove, this)
      });
    }, t.prototype.dispose = function() {
      this._clear(), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      p2e(this.api, this.dataZoomModel), this.range = null;
    }, t.type = "dataZoom.inside", t;
  }(eA)
), Fx = {
  zoom: function(e, t, r, n) {
    var i = this.range, o = i.slice(), a = e.axisModels[0];
    if (a) {
      var s = Lx[t](null, [n.originX, n.originY], a, r, e), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (o[1] - o[0]) + o[0], u = Math.max(1 / n.scale, 0);
      o[0] = (o[0] - l) * u + l, o[1] = (o[1] - l) * u + l;
      var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (Qc(0, o, [0, 100], 0, c.minSpan, c.maxSpan), this.range = o, i[0] !== o[0] || i[1] !== o[1])
        return o;
    }
  },
  pan: H4(function(e, t, r, n, i, o) {
    var a = Lx[n]([o.oldX, o.oldY], [o.newX, o.newY], t, i, r);
    return a.signal * (e[1] - e[0]) * a.pixel / a.pixelLength;
  }),
  scrollMove: H4(function(e, t, r, n, i, o) {
    var a = Lx[n]([0, 0], [o.scrollDelta, o.scrollDelta], t, i, r);
    return a.signal * (e[1] - e[0]) * o.scrollDelta;
  })
};
function H4(e) {
  return function(t, r, n, i) {
    var o = this.range, a = o.slice(), s = t.axisModels[0];
    if (s) {
      var l = e(a, s, t, r, n, i);
      if (Qc(l, a, [0, 100], "all"), this.range = a, o[0] !== a[0] || o[1] !== a[1])
        return a;
    }
  };
}
var Lx = {
  grid: function(e, t, r, n, i) {
    var o = r.axis, a = {}, s = i.model.coordinateSystem.getRect();
    return e = e || [0, 0], o.dim === "x" ? (a.pixel = t[0] - e[0], a.pixelLength = s.width, a.pixelStart = s.x, a.signal = o.inverse ? 1 : -1) : (a.pixel = t[1] - e[1], a.pixelLength = s.height, a.pixelStart = s.y, a.signal = o.inverse ? -1 : 1), a;
  },
  polar: function(e, t, r, n, i) {
    var o = r.axis, a = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
    return e = e ? s.pointToCoord(e) : [0, 0], t = s.pointToCoord(t), r.mainType === "radiusAxis" ? (a.pixel = t[0] - e[0], a.pixelLength = l[1] - l[0], a.pixelStart = l[0], a.signal = o.inverse ? 1 : -1) : (a.pixel = t[1] - e[1], a.pixelLength = u[1] - u[0], a.pixelStart = u[0], a.signal = o.inverse ? -1 : 1), a;
  },
  singleAxis: function(e, t, r, n, i) {
    var o = r.axis, a = i.model.coordinateSystem.getRect(), s = {};
    return e = e || [0, 0], o.orient === "horizontal" ? (s.pixel = t[0] - e[0], s.pixelLength = a.width, s.pixelStart = a.x, s.signal = o.inverse ? 1 : -1) : (s.pixel = t[1] - e[1], s.pixelLength = a.height, s.pixelStart = a.y, s.signal = o.inverse ? -1 : 1), s;
  }
};
function _U(e) {
  tA(e), e.registerComponentModel(h2e), e.registerComponentView(S2e), C2e(e);
}
var w2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.type = "dataZoom.slider", t.layoutMode = "box", t.defaultOption = ou(tv.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: !0,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), t;
  }(tv)
), vp = Bt, z4 = 7, b2e = 1, Ox = 30, x2e = 7, mp = "horizontal", $4 = "vertical", E2e = 5, R2e = ["line", "bar", "candlestick", "scatter"], _2e = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, T2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._displayables = {}, r;
    }
    return t.prototype.init = function(r, n) {
      this.api = n, this._onBrush = ke(this._onBrush, this), this._onBrushEnd = ke(this._onBrushEnd, this);
    }, t.prototype.render = function(r, n, i, o) {
      if (e.prototype.render.apply(this, arguments), gf(this, "_dispatchZoomAction", r.get("throttle"), "fixRate"), this._orient = r.getOrient(), r.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (r.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!o || o.type !== "dataZoom" || o.from !== this.uid) && this._buildView(), this._updateView();
    }, t.prototype.dispose = function() {
      this._clear(), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._clear = function() {
      zg(this, "_dispatchZoomAction");
      var r = this.api.getZr();
      r.off("mousemove", this._onBrush), r.off("mouseup", this._onBrushEnd);
    }, t.prototype._buildView = function() {
      var r = this.group;
      r.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var n = this._displayables.sliderGroup = new it();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), r.add(n), this._positionGroup();
    }, t.prototype._resetLocation = function() {
      var r = this.dataZoomModel, n = this.api, i = r.get("brushSelect"), o = i ? x2e : 0, a = this._findCoordRect(), s = {
        width: n.getWidth(),
        height: n.getHeight()
      }, l = this._orient === mp ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: s.width - a.x - a.width,
        top: s.height - Ox - z4 - o,
        width: a.width,
        height: Ox
      } : {
        right: z4,
        top: a.y,
        width: Ox,
        height: a.height
      }, u = hf(r.option);
      B(["right", "top", "width", "height"], function(d) {
        u[d] === "ph" && (u[d] = l[d]);
      });
      var c = hn(u, s);
      this._location = {
        x: c.x,
        y: c.y
      }, this._size = [c.width, c.height], this._orient === $4 && this._size.reverse();
    }, t.prototype._positionGroup = function() {
      var r = this.group, n = this._location, i = this._orient, o = this.dataZoomModel.getFirstTargetAxisModel(), a = o && o.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(i === mp && !a ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : i === mp && a ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : i === $4 && !a ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = r.getBoundingRect([s]);
      r.x = n.x - u.x, r.y = n.y - u.y, r.markRedraw();
    }, t.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, t.prototype._renderBackground = function() {
      var r = this.dataZoomModel, n = this._size, i = this._displayables.sliderGroup, o = r.get("brushSelect");
      i.add(new vp({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: r.get("backgroundColor")
        },
        z2: -40
      }));
      var a = new vp({
        shape: {
          x: 0,
          y: 0,
          width: n[0],
          height: n[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: ke(this._onClickPanel, this)
      }), s = this.api.getZr();
      o ? (a.on("mousedown", this._onBrushStart, this), a.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(a);
    }, t.prototype._renderDataShadow = function() {
      var r = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !r)
        return;
      var n = this._size, i = this._shadowSize || [], o = r.series, a = o.getRawData(), s = o.getShadowDim && o.getShadowDim(), l = s && a.getDimensionInfo(s) ? o.getShadowDim() : r.otherDim;
      if (l == null)
        return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (a !== this._shadowData || l !== this._shadowDim || n[0] !== i[0] || n[1] !== i[1]) {
        var d = a.getDataExtent(l), h = (d[1] - d[0]) * 0.3;
        d = [d[0] - h, d[1] + h];
        var f = [0, n[1]], p = [0, n[0]], g = [[n[0], 0], [0, 0]], v = [], m = p[1] / (a.count() - 1), y = 0, C = Math.round(a.count() / n[0]), S;
        a.each([l], function(R, _) {
          if (C > 0 && _ % C) {
            y += m;
            return;
          }
          var P = R == null || isNaN(R) || R === "", D = P ? 0 : nr(R, d, f, !0);
          P && !S && _ ? (g.push([g[g.length - 1][0], 0]), v.push([v[v.length - 1][0], 0])) : !P && S && (g.push([y, 0]), v.push([y, 0])), g.push([y, D]), v.push([y, D]), y += m, S = P;
        }), u = this._shadowPolygonPts = g, c = this._shadowPolylinePts = v;
      }
      this._shadowData = a, this._shadowDim = l, this._shadowSize = [n[0], n[1]];
      var b = this.dataZoomModel;
      function w(R) {
        var _ = b.getModel(R ? "selectedDataBackground" : "dataBackground"), P = new it(), D = new Ei({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: _.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), I = new Ri({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: _.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return P.add(D), P.add(I), P;
      }
      for (var x = 0; x < 3; x++) {
        var E = w(x === 1);
        this._displayables.sliderGroup.add(E), this._displayables.dataShadowSegs.push(E);
      }
    }, t.prototype._prepareDataShadowInfo = function() {
      var r = this.dataZoomModel, n = r.get("showDataShadow");
      if (n !== !1) {
        var i, o = this.ecModel;
        return r.eachTargetAxis(function(a, s) {
          var l = r.getAxisProxy(a, s).getTargetSeriesModels();
          B(l, function(u) {
            if (!i && !(n !== !0 && bt(R2e, u.get("type")) < 0)) {
              var c = o.getComponent(Dl(a), s).axis, d = P2e(a), h, f = u.coordinateSystem;
              d != null && f.getOtherAxis && (h = f.getOtherAxis(c).inverse), d = u.getData().mapDimension(d), i = {
                thisAxis: c,
                series: u,
                thisDim: a,
                otherDim: d,
                otherAxisInverse: h
              };
            }
          }, this);
        }, this), i;
      }
    }, t.prototype._renderHandle = function() {
      var r = this.group, n = this._displayables, i = n.handles = [null, null], o = n.handleLabels = [null, null], a = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, d = l.get("brushSelect"), h = n.filler = new vp({
        silent: d,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      a.add(h), a.add(new vp({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: c
        },
        style: {
          // deprecated option
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: b2e,
          fill: "rgba(0,0,0,0)"
        }
      })), B([0, 1], function(C) {
        var S = l.get("handleIcon");
        !oC[S] && S.indexOf("path://") < 0 && S.indexOf("image://") < 0 && (S = "path://" + S, process.env.NODE_ENV !== "production" && No("handleIcon now needs 'path://' prefix when using a path string"));
        var b = rn(S, -1, 0, 2, 2, null, !0);
        b.attr({
          cursor: W4(this._orient),
          draggable: !0,
          drift: ke(this._onDragMove, this, C),
          ondragend: ke(this._onDragEnd, this),
          onmouseover: ke(this._showDataInfo, this, !0),
          onmouseout: ke(this._showDataInfo, this, !1),
          z2: 5
        });
        var w = b.getBoundingRect(), x = l.get("handleSize");
        this._handleHeight = Ae(x, this._size[1]), this._handleWidth = w.width / w.height * this._handleHeight, b.setStyle(l.getModel("handleStyle").getItemStyle()), b.style.strokeNoScale = !0, b.rectHover = !0, b.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), Fl(b);
        var E = l.get("handleColor");
        E != null && (b.style.fill = E), a.add(i[C] = b);
        var R = l.getModel("textStyle");
        r.add(o[C] = new Vt({
          silent: !0,
          invisible: !0,
          style: br(R, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: R.getTextColor(),
            font: R.getFont()
          }),
          z2: 10
        }));
      }, this);
      var f = h;
      if (d) {
        var p = Ae(l.get("moveHandleSize"), s[1]), g = n.moveHandle = new Bt({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: s[1] - 0.5,
            height: p
          }
        }), v = p * 0.8, m = n.moveHandleIcon = rn(l.get("moveHandleIcon"), -v / 2, -v / 2, v, v, "#fff", !0);
        m.silent = !0, m.y = s[1] + p / 2 - 0.5, g.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var y = Math.min(s[1] / 2, Math.max(p, 10));
        f = n.moveZone = new Bt({
          invisible: !0,
          shape: {
            y: s[1] - y,
            height: p + y
          }
        }), f.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), a.add(g), a.add(m), a.add(f);
      }
      f.attr({
        draggable: !0,
        cursor: W4(this._orient),
        drift: ke(this._onDragMove, this, "all"),
        ondragstart: ke(this._showDataInfo, this, !0),
        ondragend: ke(this._onDragEnd, this),
        onmouseover: ke(this._showDataInfo, this, !0),
        onmouseout: ke(this._showDataInfo, this, !1)
      });
    }, t.prototype._resetInterval = function() {
      var r = this._range = this.dataZoomModel.getPercentRange(), n = this._getViewExtent();
      this._handleEnds = [nr(r[0], [0, 100], n, !0), nr(r[1], [0, 100], n, !0)];
    }, t.prototype._updateInterval = function(r, n) {
      var i = this.dataZoomModel, o = this._handleEnds, a = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
      Qc(n, o, a, i.get("zoomLock") ? "all" : r, s.minSpan != null ? nr(s.minSpan, l, a, !0) : null, s.maxSpan != null ? nr(s.maxSpan, l, a, !0) : null);
      var u = this._range, c = this._range = Ji([nr(o[0], a, l, !0), nr(o[1], a, l, !0)]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, t.prototype._updateView = function(r) {
      var n = this._displayables, i = this._handleEnds, o = Ji(i.slice()), a = this._size;
      B([0, 1], function(f) {
        var p = n.handles[f], g = this._handleHeight;
        p.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: i[f] + (f ? -1 : 1),
          y: a[1] / 2 - g / 2
        });
      }, this), n.filler.setShape({
        x: o[0],
        y: 0,
        width: o[1] - o[0],
        height: a[1]
      });
      var s = {
        x: o[0],
        width: o[1] - o[0]
      };
      n.moveHandle && (n.moveHandle.setShape(s), n.moveZone.setShape(s), n.moveZone.getBoundingRect(), n.moveHandleIcon && n.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = n.dataShadowSegs, u = [0, o[0], o[1], a[0]], c = 0; c < l.length; c++) {
        var d = l[c], h = d.getClipPath();
        h || (h = new Bt(), d.setClipPath(h)), h.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: a[1]
        });
      }
      this._updateDataInfo(r);
    }, t.prototype._updateDataInfo = function(r) {
      var n = this.dataZoomModel, i = this._displayables, o = i.handleLabels, a = this._orient, s = ["", ""];
      if (n.get("showDetail")) {
        var l = n.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, d = r ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          s = [this._formatLabel(d[0], u), this._formatLabel(d[1], u)];
        }
      }
      var h = Ji(this._handleEnds.slice());
      f.call(this, 0), f.call(this, 1);
      function f(p) {
        var g = Ll(i.handles[p].parent, this.group), v = HS(p === 0 ? "right" : "left", g), m = this._handleWidth / 2 + E2e, y = fa([h[p] + (p === 0 ? -m : m), this._size[1] / 2], g);
        o[p].setStyle({
          x: y[0],
          y: y[1],
          verticalAlign: a === mp ? "middle" : v,
          align: a === mp ? v : "center",
          text: s[p]
        });
      }
    }, t.prototype._formatLabel = function(r, n) {
      var i = this.dataZoomModel, o = i.get("labelFormatter"), a = i.get("labelPrecision");
      (a == null || a === "auto") && (a = n.getPixelPrecision());
      var s = r == null || isNaN(r) ? "" : n.type === "category" || n.type === "time" ? n.scale.getLabel({
        value: Math.round(r)
      }) : r.toFixed(Math.min(a, 20));
      return Ye(o) ? o(r, s) : Fe(o) ? o.replace("{value}", s) : s;
    }, t.prototype._showDataInfo = function(r) {
      r = this._dragging || r;
      var n = this._displayables, i = n.handleLabels;
      i[0].attr("invisible", !r), i[1].attr("invisible", !r), n.moveHandle && this.api[r ? "enterEmphasis" : "leaveEmphasis"](n.moveHandle, 1);
    }, t.prototype._onDragMove = function(r, n, i, o) {
      this._dragging = !0, Hs(o.event);
      var a = this._displayables.sliderGroup.getLocalTransform(), s = fa([n, i], a, !0), l = this._updateInterval(r, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(!0);
    }, t.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var r = this.dataZoomModel.get("realtime");
      !r && this._dispatchZoomAction(!1);
    }, t.prototype._onClickPanel = function(r) {
      var n = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(r.offsetX, r.offsetY);
      if (!(i[0] < 0 || i[0] > n[0] || i[1] < 0 || i[1] > n[1])) {
        var o = this._handleEnds, a = (o[0] + o[1]) / 2, s = this._updateInterval("all", i[0] - a);
        this._updateView(), s && this._dispatchZoomAction(!1);
      }
    }, t.prototype._onBrushStart = function(r) {
      var n = r.offsetX, i = r.offsetY;
      this._brushStart = new Ct(n, i), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, t.prototype._onBrushEnd = function(r) {
      if (this._brushing) {
        var n = this._displayables.brushRect;
        if (this._brushing = !1, !!n) {
          n.attr("ignore", !0);
          var i = n.shape, o = +/* @__PURE__ */ new Date();
          if (!(o - this._brushStartTime < 200 && Math.abs(i.width) < 5)) {
            var a = this._getViewExtent(), s = [0, 100];
            this._range = Ji([nr(i.x, a, s, !0), nr(i.x + i.width, a, s, !0)]), this._handleEnds = [i.x, i.x + i.width], this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, t.prototype._onBrush = function(r) {
      this._brushing && (Hs(r.event), this._updateBrushRect(r.offsetX, r.offsetY));
    }, t.prototype._updateBrushRect = function(r, n) {
      var i = this._displayables, o = this.dataZoomModel, a = i.brushRect;
      a || (a = i.brushRect = new vp({
        silent: !0,
        style: o.getModel("brushStyle").getItemStyle()
      }), i.sliderGroup.add(a)), a.attr("ignore", !1);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(r, n), c = l.transformCoordToLocal(s.x, s.y), d = this._size;
      u[0] = Math.max(Math.min(d[0], u[0]), 0), a.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: d[1]
      });
    }, t.prototype._dispatchZoomAction = function(r) {
      var n = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: r ? _2e : null,
        start: n[0],
        end: n[1]
      });
    }, t.prototype._findCoordRect = function() {
      var r, n = sU(this.dataZoomModel).infoList;
      if (!r && n.length) {
        var i = n[0].model.coordinateSystem;
        r = i.getRect && i.getRect();
      }
      if (!r) {
        var o = this.api.getWidth(), a = this.api.getHeight();
        r = {
          x: o * 0.2,
          y: a * 0.2,
          width: o * 0.6,
          height: a * 0.6
        };
      }
      return r;
    }, t.type = "dataZoom.slider", t;
  }(eA)
);
function P2e(e) {
  var t = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return t[e];
}
function W4(e) {
  return e === "vertical" ? "ns-resize" : "ew-resize";
}
function TU(e) {
  e.registerComponentModel(w2e), e.registerComponentView(T2e), tA(e);
}
function M2e(e) {
  _t(_U), _t(TU);
}
var PU = {
  /**
   * @public
   */
  get: function(e, t, r) {
    var n = et((D2e[e] || {})[t]);
    return r && fe(n) ? n[n.length - 1] : n;
  }
}, D2e = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
}, j4 = xn.mapVisual, A2e = xn.eachVisual, I2e = fe, U4 = B, F2e = Ji, L2e = nr, LC = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.stateList = ["inRange", "outOfRange"], r.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], r.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, r.dataBound = [-1 / 0, 1 / 0], r.targetVisuals = {}, r.controllerVisuals = {}, r;
    }
    return t.prototype.init = function(r, n, i) {
      this.mergeDefaultAndTheme(r, i);
    }, t.prototype.optionUpdated = function(r, n) {
      var i = this.option;
      !n && mU(i, r, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, t.prototype.resetVisual = function(r) {
      var n = this.stateList;
      r = ke(r, this), this.controllerVisuals = oT(this.option.controller, n, r), this.targetVisuals = oT(this.option.target, n, r);
    }, t.prototype.getItemSymbol = function() {
      return null;
    }, t.prototype.getTargetSeriesIndices = function() {
      var r = this.option.seriesIndex, n = [];
      return r == null || r === "all" ? this.ecModel.eachSeries(function(i, o) {
        n.push(o);
      }) : n = dr(r), n;
    }, t.prototype.eachTargetSeries = function(r, n) {
      B(this.getTargetSeriesIndices(), function(i) {
        var o = this.ecModel.getSeriesByIndex(i);
        o && r.call(n, o);
      }, this);
    }, t.prototype.isTargetSeries = function(r) {
      var n = !1;
      return this.eachTargetSeries(function(i) {
        i === r && (n = !0);
      }), n;
    }, t.prototype.formatValueText = function(r, n, i) {
      var o = this.option, a = o.precision, s = this.dataBound, l = o.formatter, u;
      i = i || ["<", ">"], fe(r) && (r = r.slice(), u = !0);
      var c = n ? r : u ? [d(r[0]), d(r[1])] : d(r);
      if (Fe(l))
        return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (Ye(l))
        return u ? l(r[0], r[1]) : l(r);
      if (u)
        return r[0] === s[0] ? i[0] + " " + c[1] : r[1] === s[1] ? i[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function d(h) {
        return h === s[0] ? "min" : h === s[1] ? "max" : (+h).toFixed(Math.min(a, 20));
      }
    }, t.prototype.resetExtent = function() {
      var r = this.option, n = F2e([r.min, r.max]);
      this._dataExtent = n;
    }, t.prototype.getDataDimensionIndex = function(r) {
      var n = this.option.dimension;
      if (n != null)
        return r.getDimensionIndex(n);
      for (var i = r.dimensions, o = i.length - 1; o >= 0; o--) {
        var a = i[o], s = r.getDimensionInfo(a);
        if (!s.isCalculationCoord)
          return s.storeDimIndex;
      }
    }, t.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, t.prototype.completeVisualOption = function() {
      var r = this.ecModel, n = this.option, i = {
        inRange: n.inRange,
        outOfRange: n.outOfRange
      }, o = n.target || (n.target = {}), a = n.controller || (n.controller = {});
      yt(o, i), yt(a, i);
      var s = this.isCategory();
      l.call(this, o), l.call(this, a), u.call(this, o, "inRange", "outOfRange"), c.call(this, a);
      function l(d) {
        I2e(n.color) && !d.inRange && (d.inRange = {
          color: n.color.slice().reverse()
        }), d.inRange = d.inRange || {
          color: r.get("gradientColor")
        };
      }
      function u(d, h, f) {
        var p = d[h], g = d[f];
        p && !g && (g = d[f] = {}, U4(p, function(v, m) {
          if (xn.isValidType(m)) {
            var y = PU.get(m, "inactive", s);
            y != null && (g[m] = y, m === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [0, 0]));
          }
        }));
      }
      function c(d) {
        var h = (d.inRange || {}).symbol || (d.outOfRange || {}).symbol, f = (d.inRange || {}).symbolSize || (d.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), g = this.getItemSymbol(), v = g || "roundRect";
        U4(this.stateList, function(m) {
          var y = this.itemSize, C = d[m];
          C || (C = d[m] = {
            color: s ? p : [p]
          }), C.symbol == null && (C.symbol = h && et(h) || (s ? v : [v])), C.symbolSize == null && (C.symbolSize = f && et(f) || (s ? y[0] : [y[0], y[0]])), C.symbol = j4(C.symbol, function(w) {
            return w === "none" ? v : w;
          });
          var S = C.symbolSize;
          if (S != null) {
            var b = -1 / 0;
            A2e(S, function(w) {
              w > b && (b = w);
            }), C.symbolSize = j4(S, function(w) {
              return L2e(w, [0, b], [0, y[0]], !0);
            });
          }
        }, this);
      }
    }, t.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, t.prototype.isCategory = function() {
      return !!this.option.categories;
    }, t.prototype.setSelected = function(r) {
    }, t.prototype.getSelected = function() {
      return null;
    }, t.prototype.getValueState = function(r) {
      return null;
    }, t.prototype.getVisualMeta = function(r) {
      return null;
    }, t.type = "visualMap", t.dependencies = ["series"], t.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      // 接受数组分别设定上右下左边距，同css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
        // 值域文字颜色
      }
    }, t;
  }(Rt)
), K4 = [20, 140], O2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.optionUpdated = function(r, n) {
      e.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(i) {
        i.mappingMethod = "linear", i.dataExtent = this.getExtent();
      }), this._resetRange();
    }, t.prototype.resetItemSize = function() {
      e.prototype.resetItemSize.apply(this, arguments);
      var r = this.itemSize;
      (r[0] == null || isNaN(r[0])) && (r[0] = K4[0]), (r[1] == null || isNaN(r[1])) && (r[1] = K4[1]);
    }, t.prototype._resetRange = function() {
      var r = this.getExtent(), n = this.option.range;
      !n || n.auto ? (r.auto = 1, this.option.range = r) : fe(n) && (n[0] > n[1] && n.reverse(), n[0] = Math.max(n[0], r[0]), n[1] = Math.min(n[1], r[1]));
    }, t.prototype.completeVisualOption = function() {
      e.prototype.completeVisualOption.apply(this, arguments), B(this.stateList, function(r) {
        var n = this.option.controller[r].symbolSize;
        n && n[0] !== n[1] && (n[0] = n[1] / 3);
      }, this);
    }, t.prototype.setSelected = function(r) {
      this.option.range = r.slice(), this._resetRange();
    }, t.prototype.getSelected = function() {
      var r = this.getExtent(), n = Ji((this.get("range") || []).slice());
      return n[0] > r[1] && (n[0] = r[1]), n[1] > r[1] && (n[1] = r[1]), n[0] < r[0] && (n[0] = r[0]), n[1] < r[0] && (n[1] = r[0]), n;
    }, t.prototype.getValueState = function(r) {
      var n = this.option.range, i = this.getExtent();
      return (n[0] <= i[0] || n[0] <= r) && (n[1] >= i[1] || r <= n[1]) ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(r) {
      var n = [];
      return this.eachTargetSeries(function(i) {
        var o = [], a = i.getData();
        a.each(this.getDataDimensionIndex(a), function(s, l) {
          r[0] <= s && s <= r[1] && o.push(l);
        }, this), n.push({
          seriesId: i.id,
          dataIndex: o
        });
      }, this), n;
    }, t.prototype.getVisualMeta = function(r) {
      var n = Y4(this, "outOfRange", this.getExtent()), i = Y4(this, "inRange", this.option.range.slice()), o = [];
      function a(f, p) {
        o.push({
          value: f,
          color: r(f, p)
        });
      }
      for (var s = 0, l = 0, u = i.length, c = n.length; l < c && (!i.length || n[l] <= i[0]); l++)
        n[l] < i[s] && a(n[l], "outOfRange");
      for (var d = 1; s < u; s++, d = 0)
        d && o.length && a(i[s], "outOfRange"), a(i[s], "inRange");
      for (var d = 1; l < c; l++)
        (!i.length || i[i.length - 1] < n[l]) && (d && (o.length && a(o[o.length - 1].value, "outOfRange"), d = 0), a(n[l], "outOfRange"));
      var h = o.length;
      return {
        stops: o,
        outerColors: [h ? o[0].color : "transparent", h ? o[h - 1].color : "transparent"]
      };
    }, t.type = "visualMap.continuous", t.defaultOption = ou(LC.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: 'rgba(0,0,0,0.2)'
      //     }
      // }
    }), t;
  }(LC)
);
function Y4(e, t, r) {
  if (r[0] === r[1])
    return r.slice();
  for (var n = 200, i = (r[1] - r[0]) / n, o = r[0], a = [], s = 0; s <= n && o < r[1]; s++)
    a.push(o), o += i;
  return a.push(r[1]), a;
}
var MU = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, r;
    }
    return t.prototype.init = function(r, n) {
      this.ecModel = r, this.api = n;
    }, t.prototype.render = function(r, n, i, o) {
      if (this.visualMapModel = r, r.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(r, n, i, o);
    }, t.prototype.renderBackground = function(r) {
      var n = this.visualMapModel, i = Kc(n.get("padding") || 0), o = r.getBoundingRect();
      r.add(new Bt({
        z2: -1,
        silent: !0,
        shape: {
          x: o.x - i[3],
          y: o.y - i[0],
          width: o.width + i[3] + i[1],
          height: o.height + i[0] + i[2]
        },
        style: {
          fill: n.get("backgroundColor"),
          stroke: n.get("borderColor"),
          lineWidth: n.get("borderWidth")
        }
      }));
    }, t.prototype.getControllerVisual = function(r, n, i) {
      i = i || {};
      var o = i.forceState, a = this.visualMapModel, s = {};
      if (n === "color") {
        var l = a.get("contentColor");
        s.color = l;
      }
      function u(f) {
        return s[f];
      }
      function c(f, p) {
        s[f] = p;
      }
      var d = a.controllerVisuals[o || a.getValueState(r)], h = xn.prepareVisualTypes(d);
      return B(h, function(f) {
        var p = d[f];
        i.convertOpacityToAlpha && f === "opacity" && (f = "colorAlpha", p = d.__alphaForOpacity), xn.dependsOn(f, n) && p && p.applyVisual(r, u, c);
      }), s[n];
    }, t.prototype.positionGroup = function(r) {
      var n = this.visualMapModel, i = this.api;
      KS(r, n.getBoxLayoutParams(), {
        width: i.getWidth(),
        height: i.getHeight()
      });
    }, t.prototype.doRender = function(r, n, i, o) {
    }, t.type = "visualMap", t;
  }(Rr)
), q4 = [["left", "right", "width"], ["top", "bottom", "height"]];
function DU(e, t, r) {
  var n = e.option, i = n.align;
  if (i != null && i !== "auto")
    return i;
  for (var o = {
    width: t.getWidth(),
    height: t.getHeight()
  }, a = n.orient === "horizontal" ? 1 : 0, s = q4[a], l = [0, null, 10], u = {}, c = 0; c < 3; c++)
    u[q4[1 - a][c]] = l[c], u[s[c]] = c === 2 ? r[0] : n[s[c]];
  var d = [["x", "width", 3], ["y", "height", 0]][a], h = hn(u, o, n.padding);
  return s[(h.margin[d[2]] || 0) + h[d[0]] + h[d[1]] * 0.5 < o[d[1]] * 0.5 ? 0 : 1];
}
function f0(e, t) {
  return B(e || [], function(r) {
    r.dataIndex != null && (r.dataIndexInside = r.dataIndex, r.dataIndex = null), r.highlightKey = "visualMap" + (t ? t.componentIndex : "");
  }), e;
}
var Oa = nr, N2e = B, Z4 = Math.min, Nx = Math.max, k2e = 12, V2e = 6, B2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._shapes = {}, r._dataInterval = [], r._handleEnds = [], r._hoverLinkDataIndices = [], r;
    }
    return t.prototype.init = function(r, n) {
      e.prototype.init.call(this, r, n), this._hoverLinkFromSeriesMouseOver = ke(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = ke(this._hideIndicator, this);
    }, t.prototype.doRender = function(r, n, i, o) {
      (!o || o.type !== "selectDataRange" || o.from !== this.uid) && this._buildView();
    }, t.prototype._buildView = function() {
      this.group.removeAll();
      var r = this.visualMapModel, n = this.group;
      this._orient = r.get("orient"), this._useHandle = r.get("calculable"), this._resetInterval(), this._renderBar(n);
      var i = r.get("text");
      this._renderEndsText(n, i, 0), this._renderEndsText(n, i, 1), this._updateView(!0), this.renderBackground(n), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(n);
    }, t.prototype._renderEndsText = function(r, n, i) {
      if (n) {
        var o = n[1 - i];
        o = o != null ? o + "" : "";
        var a = this.visualMapModel, s = a.get("textGap"), l = a.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], u), d = this._applyTransform(i === 0 ? "bottom" : "top", u), h = this._orient, f = this.visualMapModel.textStyleModel;
        this.group.add(new Vt({
          style: br(f, {
            x: c[0],
            y: c[1],
            verticalAlign: h === "horizontal" ? "middle" : d,
            align: h === "horizontal" ? d : "center",
            text: o
          })
        }));
      }
    }, t.prototype._renderBar = function(r) {
      var n = this.visualMapModel, i = this._shapes, o = n.itemSize, a = this._orient, s = this._useHandle, l = DU(n, this.api, o), u = i.mainGroup = this._createBarGroup(l), c = new it();
      u.add(c), c.add(i.outOfRange = X4()), c.add(i.inRange = X4(null, s ? J4(this._orient) : null, ke(this._dragHandle, this, "all", !1), ke(this._dragHandle, this, "all", !0))), c.setClipPath(new Bt({
        shape: {
          x: 0,
          y: 0,
          width: o[0],
          height: o[1],
          r: 3
        }
      }));
      var d = n.textStyleModel.getTextRect("国"), h = Nx(d.width, d.height);
      s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(n, u, 0, o, h, a), this._createHandle(n, u, 1, o, h, a)), this._createIndicator(n, u, o, h, a), r.add(u);
    }, t.prototype._createHandle = function(r, n, i, o, a, s) {
      var l = ke(this._dragHandle, this, i, !1), u = ke(this._dragHandle, this, i, !0), c = ya(r.get("handleSize"), o[0]), d = rn(r.get("handleIcon"), -c / 2, -c / 2, c, c, null, !0), h = J4(this._orient);
      d.attr({
        cursor: h,
        draggable: !0,
        drift: l,
        ondragend: u,
        onmousemove: function(m) {
          Hs(m.event);
        }
      }), d.x = o[0] / 2, d.useStyle(r.getModel("handleStyle").getItemStyle()), d.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), d.style.lineWidth *= 2, d.ensureState("emphasis").style = r.getModel(["emphasis", "handleStyle"]).getItemStyle(), rc(d, !0), n.add(d);
      var f = this.visualMapModel.textStyleModel, p = new Vt({
        cursor: h,
        draggable: !0,
        drift: l,
        onmousemove: function(m) {
          Hs(m.event);
        },
        ondragend: u,
        style: br(f, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var g = [c, 0], v = this._shapes;
      v.handleThumbs[i] = d, v.handleLabelPoints[i] = g, v.handleLabels[i] = p;
    }, t.prototype._createIndicator = function(r, n, i, o, a) {
      var s = ya(r.get("indicatorSize"), i[0]), l = rn(r.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
      l.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: i[0] / 2
      });
      var u = r.getModel("indicatorStyle").getItemStyle();
      if (l instanceof In) {
        var c = l.style;
        l.useStyle(se({
          // TODO other properties like x, y ?
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else
        l.useStyle(u);
      n.add(l);
      var d = this.visualMapModel.textStyleModel, h = new Vt({
        silent: !0,
        invisible: !0,
        style: br(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(h);
      var f = [(a === "horizontal" ? o / 2 : V2e) + i[0] / 2, 0], p = this._shapes;
      p.indicator = l, p.indicatorLabel = h, p.indicatorLabelPoint = f, this._firstShowIndicator = !0;
    }, t.prototype._dragHandle = function(r, n, i, o) {
      if (this._useHandle) {
        if (this._dragging = !n, !n) {
          var a = this._applyTransform([i, o], this._shapes.mainGroup, !0);
          this._updateInterval(r, a[1]), this._hideIndicator(), this._updateView();
        }
        n === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), n ? !this._hovering && this._clearHoverLinkToSeries() : Q4(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[r], !1);
      }
    }, t.prototype._resetInterval = function() {
      var r = this.visualMapModel, n = this._dataInterval = r.getSelected(), i = r.getExtent(), o = [0, r.itemSize[1]];
      this._handleEnds = [Oa(n[0], i, o, !0), Oa(n[1], i, o, !0)];
    }, t.prototype._updateInterval = function(r, n) {
      n = n || 0;
      var i = this.visualMapModel, o = this._handleEnds, a = [0, i.itemSize[1]];
      Qc(
        n,
        o,
        a,
        r,
        // cross is forbidden
        0
      );
      var s = i.getExtent();
      this._dataInterval = [Oa(o[0], a, s, !0), Oa(o[1], a, s, !0)];
    }, t.prototype._updateView = function(r) {
      var n = this.visualMapModel, i = n.getExtent(), o = this._shapes, a = [0, n.itemSize[1]], s = r ? a : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), u = this._createBarVisual(i, i, a, "outOfRange");
      o.inRange.setStyle({
        fill: l.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", l.barPoints), o.outOfRange.setStyle({
        fill: u.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, t.prototype._createBarVisual = function(r, n, i, o) {
      var a = {
        forceState: o,
        convertOpacityToAlpha: !0
      }, s = this._makeColorGradient(r, a), l = [this.getControllerVisual(r[0], "symbolSize", a), this.getControllerVisual(r[1], "symbolSize", a)], u = this._createBarPoints(i, l);
      return {
        barColor: new af(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [s[0].color, s[s.length - 1].color]
      };
    }, t.prototype._makeColorGradient = function(r, n) {
      var i = 100, o = [], a = (r[1] - r[0]) / i;
      o.push({
        color: this.getControllerVisual(r[0], "color", n),
        offset: 0
      });
      for (var s = 1; s < i; s++) {
        var l = r[0] + a * s;
        if (l > r[1])
          break;
        o.push({
          color: this.getControllerVisual(l, "color", n),
          offset: s / i
        });
      }
      return o.push({
        color: this.getControllerVisual(r[1], "color", n),
        offset: 1
      }), o;
    }, t.prototype._createBarPoints = function(r, n) {
      var i = this.visualMapModel.itemSize;
      return [[i[0] - n[0], r[0]], [i[0], r[0]], [i[0], r[1]], [i[0] - n[1], r[1]]];
    }, t.prototype._createBarGroup = function(r) {
      var n = this._orient, i = this.visualMapModel.get("inverse");
      return new it(n === "horizontal" && !i ? {
        scaleX: r === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : n === "horizontal" && i ? {
        scaleX: r === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : n === "vertical" && !i ? {
        scaleX: r === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: r === "left" ? 1 : -1
      });
    }, t.prototype._updateHandle = function(r, n) {
      if (this._useHandle) {
        var i = this._shapes, o = this.visualMapModel, a = i.handleThumbs, s = i.handleLabels, l = o.itemSize, u = o.getExtent();
        N2e([0, 1], function(c) {
          var d = a[c];
          d.setStyle("fill", n.handlesColor[c]), d.y = r[c];
          var h = Oa(r[c], [0, l[1]], u, !0), f = this.getControllerVisual(h, "symbolSize");
          d.scaleX = d.scaleY = f / l[0], d.x = l[0] - f / 2;
          var p = fa(i.handleLabelPoints[c], Ll(d, this.group));
          s[c].setStyle({
            x: p[0],
            y: p[1],
            text: o.formatValueText(this._dataInterval[c]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center"
          });
        }, this);
      }
    }, t.prototype._showIndicator = function(r, n, i, o) {
      var a = this.visualMapModel, s = a.getExtent(), l = a.itemSize, u = [0, l[1]], c = this._shapes, d = c.indicator;
      if (d) {
        d.attr("invisible", !1);
        var h = {
          convertOpacityToAlpha: !0
        }, f = this.getControllerVisual(r, "color", h), p = this.getControllerVisual(r, "symbolSize"), g = Oa(r, s, u, !0), v = l[0] - p / 2, m = {
          x: d.x,
          y: d.y
        };
        d.y = g, d.x = v;
        var y = fa(c.indicatorLabelPoint, Ll(d, this.group)), C = c.indicatorLabel;
        C.attr("invisible", !1);
        var S = this._applyTransform("left", c.mainGroup), b = this._orient, w = b === "horizontal";
        C.setStyle({
          text: (i || "") + a.formatValueText(n),
          verticalAlign: w ? S : "middle",
          align: w ? "center" : S
        });
        var x = {
          x: v,
          y: g,
          style: {
            fill: f
          }
        }, E = {
          style: {
            x: y[0],
            y: y[1]
          }
        };
        if (a.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var R = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          d.x = m.x, d.y = m.y, d.animateTo(x, R), C.animateTo(E, R);
        } else
          d.attr(x), C.attr(E);
        this._firstShowIndicator = !1;
        var _ = this._shapes.handleLabels;
        if (_)
          for (var P = 0; P < _.length; P++)
            this.api.enterBlur(_[P]);
      }
    }, t.prototype._enableHoverLinkToSeries = function() {
      var r = this;
      this._shapes.mainGroup.on("mousemove", function(n) {
        if (r._hovering = !0, !r._dragging) {
          var i = r.visualMapModel.itemSize, o = r._applyTransform([n.offsetX, n.offsetY], r._shapes.mainGroup, !0, !0);
          o[1] = Z4(Nx(0, o[1]), i[1]), r._doHoverLinkToSeries(o[1], 0 <= o[0] && o[0] <= i[0]);
        }
      }).on("mouseout", function() {
        r._hovering = !1, !r._dragging && r._clearHoverLinkToSeries();
      });
    }, t.prototype._enableHoverLinkFromSeries = function() {
      var r = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (r.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), r.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, t.prototype._doHoverLinkToSeries = function(r, n) {
      var i = this.visualMapModel, o = i.itemSize;
      if (i.option.hoverLink) {
        var a = [0, o[1]], s = i.getExtent();
        r = Z4(Nx(a[0], r), a[1]);
        var l = G2e(i, s, a), u = [r - l, r + l], c = Oa(r, a, s, !0), d = [Oa(u[0], a, s, !0), Oa(u[1], a, s, !0)];
        u[0] < a[0] && (d[0] = -1 / 0), u[1] > a[1] && (d[1] = 1 / 0), n && (d[0] === -1 / 0 ? this._showIndicator(c, d[1], "< ", l) : d[1] === 1 / 0 ? this._showIndicator(c, d[0], "> ", l) : this._showIndicator(c, c, "≈ ", l));
        var h = this._hoverLinkDataIndices, f = [];
        (n || Q4(i)) && (f = this._hoverLinkDataIndices = i.findTargetDataIndices(d));
        var p = xve(h, f);
        this._dispatchHighDown("downplay", f0(p[0], i)), this._dispatchHighDown("highlight", f0(p[1], i));
      }
    }, t.prototype._hoverLinkFromSeriesMouseOver = function(r) {
      var n;
      if (ic(r.target, function(l) {
        var u = ot(l);
        if (u.dataIndex != null)
          return n = u, !0;
      }, !0), !!n) {
        var i = this.ecModel.getSeriesByIndex(n.seriesIndex), o = this.visualMapModel;
        if (o.isTargetSeries(i)) {
          var a = i.getData(n.dataType), s = a.getStore().get(o.getDataDimensionIndex(a), n.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, t.prototype._hideIndicator = function() {
      var r = this._shapes;
      r.indicator && r.indicator.attr("invisible", !0), r.indicatorLabel && r.indicatorLabel.attr("invisible", !0);
      var n = this._shapes.handleLabels;
      if (n)
        for (var i = 0; i < n.length; i++)
          this.api.leaveBlur(n[i]);
    }, t.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var r = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", f0(r, this.visualMapModel)), r.length = 0;
    }, t.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var r = this.api.getZr();
      r.off("mouseover", this._hoverLinkFromSeriesMouseOver), r.off("mouseout", this._hideIndicator);
    }, t.prototype._applyTransform = function(r, n, i, o) {
      var a = Ll(n, o ? null : this.group);
      return fe(r) ? fa(r, a, i) : HS(r, a, i);
    }, t.prototype._dispatchHighDown = function(r, n) {
      n && n.length && this.api.dispatchAction({
        type: r,
        batch: n
      });
    }, t.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, t.type = "visualMap.continuous", t;
  }(MU)
);
function X4(e, t, r, n) {
  return new Ei({
    shape: {
      points: e
    },
    draggable: !!r,
    cursor: t,
    drift: r,
    onmousemove: function(i) {
      Hs(i.event);
    },
    ondragend: n
  });
}
function G2e(e, t, r) {
  var n = k2e / 2, i = e.get("hoverLinkDataSize");
  return i && (n = Oa(i, t, r, !0) / 2), n;
}
function Q4(e) {
  var t = e.get("hoverLinkOnHandle");
  return !!(t ?? e.get("realtime"));
}
function J4(e) {
  return e === "vertical" ? "ns-resize" : "ew-resize";
}
var H2e = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, z2e = function(e, t) {
  t.eachComponent({
    mainType: "visualMap",
    query: e
  }, function(r) {
    r.setSelected(e.selected);
  });
}, $2e = [
  {
    createOnAllSeries: !0,
    reset: function(e, t) {
      var r = [];
      return t.eachComponent("visualMap", function(n) {
        var i = e.pipelineContext;
        !n.isTargetSeries(e) || i && i.large || r.push(dIe(n.stateList, n.targetVisuals, ke(n.getValueState, n), n.getDataDimensionIndex(e.getData())));
      }), r;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(e, t) {
      var r = e.getData(), n = [];
      t.eachComponent("visualMap", function(i) {
        if (i.isTargetSeries(e)) {
          var o = i.getVisualMeta(ke(W2e, null, e, i)) || {
            stops: [],
            outerColors: []
          }, a = i.getDataDimensionIndex(r);
          a >= 0 && (o.dimension = a, n.push(o));
        }
      }), e.getData().setVisual("visualMeta", n);
    }
  }
];
function W2e(e, t, r, n) {
  for (var i = t.targetVisuals[n], o = xn.prepareVisualTypes(i), a = {
    color: Ov(e.getData(), "color")
    // default color.
  }, s = 0, l = o.length; s < l; s++) {
    var u = o[s], c = i[u === "opacity" ? "__alphaForOpacity" : u];
    c && c.applyVisual(r, d, h);
  }
  return a.color;
  function d(f) {
    return a[f];
  }
  function h(f, p) {
    a[f] = p;
  }
}
var eG = B;
function j2e(e) {
  var t = e && e.visualMap;
  fe(t) || (t = t ? [t] : []), eG(t, function(r) {
    if (r) {
      kd(r, "splitList") && !kd(r, "pieces") && (r.pieces = r.splitList, delete r.splitList);
      var n = r.pieces;
      n && fe(n) && eG(n, function(i) {
        Ze(i) && (kd(i, "start") && !kd(i, "min") && (i.min = i.start), kd(i, "end") && !kd(i, "max") && (i.max = i.end));
      });
    }
  });
}
function kd(e, t) {
  return e && e.hasOwnProperty && e.hasOwnProperty(t);
}
var tG = !1;
function AU(e) {
  tG || (tG = !0, e.registerSubTypeDefaulter("visualMap", function(t) {
    return !t.categories && (!(t.pieces ? t.pieces.length > 0 : t.splitNumber > 0) || t.calculable) ? "continuous" : "piecewise";
  }), e.registerAction(H2e, z2e), B($2e, function(t) {
    e.registerVisual(e.PRIORITY.VISUAL.COMPONENT, t);
  }), e.registerPreprocessor(j2e));
}
function IU(e) {
  e.registerComponentModel(O2e), e.registerComponentView(B2e), AU(e);
}
var U2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r._pieceList = [], r;
    }
    return t.prototype.optionUpdated = function(r, n) {
      e.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var i = this._mode = this._determineMode();
      this._pieceList = [], K2e[this._mode].call(this, this._pieceList), this._resetSelected(r, n);
      var o = this.option.categories;
      this.resetVisual(function(a, s) {
        i === "categories" ? (a.mappingMethod = "category", a.categories = et(o)) : (a.dataExtent = this.getExtent(), a.mappingMethod = "piecewise", a.pieceList = ge(this._pieceList, function(l) {
          return l = et(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, t.prototype.completeVisualOption = function() {
      var r = this.option, n = {}, i = xn.listVisualTypes(), o = this.isCategory();
      B(r.pieces, function(s) {
        B(i, function(l) {
          s.hasOwnProperty(l) && (n[l] = 1);
        });
      }), B(n, function(s, l) {
        var u = !1;
        B(this.stateList, function(c) {
          u = u || a(r, c, l) || a(r.target, c, l);
        }, this), !u && B(this.stateList, function(c) {
          (r[c] || (r[c] = {}))[l] = PU.get(l, c === "inRange" ? "active" : "inactive", o);
        });
      }, this);
      function a(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      e.prototype.completeVisualOption.apply(this, arguments);
    }, t.prototype._resetSelected = function(r, n) {
      var i = this.option, o = this._pieceList, a = (n ? i : r).selected || {};
      if (i.selected = a, B(o, function(l, u) {
        var c = this.getSelectedMapKey(l);
        a.hasOwnProperty(c) || (a[c] = !0);
      }, this), i.selectedMode === "single") {
        var s = !1;
        B(o, function(l, u) {
          var c = this.getSelectedMapKey(l);
          a[c] && (s ? a[c] = !1 : s = !0);
        }, this);
      }
    }, t.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, t.prototype.getSelectedMapKey = function(r) {
      return this._mode === "categories" ? r.value + "" : r.index + "";
    }, t.prototype.getPieceList = function() {
      return this._pieceList;
    }, t.prototype._determineMode = function() {
      var r = this.option;
      return r.pieces && r.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, t.prototype.setSelected = function(r) {
      this.option.selected = et(r);
    }, t.prototype.getValueState = function(r) {
      var n = xn.findPieceIndex(r, this._pieceList);
      return n != null && this.option.selected[this.getSelectedMapKey(this._pieceList[n])] ? "inRange" : "outOfRange";
    }, t.prototype.findTargetDataIndices = function(r) {
      var n = [], i = this._pieceList;
      return this.eachTargetSeries(function(o) {
        var a = [], s = o.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var c = xn.findPieceIndex(l, i);
          c === r && a.push(u);
        }, this), n.push({
          seriesId: o.id,
          dataIndex: a
        });
      }, this), n;
    }, t.prototype.getRepresentValue = function(r) {
      var n;
      if (this.isCategory())
        n = r.value;
      else if (r.value != null)
        n = r.value;
      else {
        var i = r.interval || [];
        n = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2;
      }
      return n;
    }, t.prototype.getVisualMeta = function(r) {
      if (this.isCategory())
        return;
      var n = [], i = ["", ""], o = this;
      function a(c, d) {
        var h = o.getRepresentValue({
          interval: c
        });
        d || (d = o.getValueState(h));
        var f = r(h, d);
        c[0] === -1 / 0 ? i[0] = f : c[1] === 1 / 0 ? i[1] = f : n.push({
          value: c[0],
          color: f
        }, {
          value: c[1],
          color: f
        });
      }
      var s = this._pieceList.slice();
      if (!s.length)
        s.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [-1 / 0, l]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [l, 1 / 0]
        });
      }
      var u = -1 / 0;
      return B(s, function(c) {
        var d = c.interval;
        d && (d[0] > u && a([u, d[0]], "outOfRange"), a(d.slice()), u = d[1]);
      }, this), {
        stops: n,
        outerColors: i
      };
    }, t.type = "visualMap.piecewise", t.defaultOption = ou(LC.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), t;
  }(LC)
), K2e = {
  splitNumber: function(e) {
    var t = this.option, r = Math.min(t.precision, 20), n = this.getExtent(), i = t.splitNumber;
    i = Math.max(parseInt(i, 10), 1), t.splitNumber = i;
    for (var o = (n[1] - n[0]) / i; +o.toFixed(r) !== o && r < 5; )
      r++;
    t.precision = r, o = +o.toFixed(r), t.minOpen && e.push({
      interval: [-1 / 0, n[0]],
      close: [0, 0]
    });
    for (var a = 0, s = n[0]; a < i; s += o, a++) {
      var l = a === i - 1 ? n[1] : s + o;
      e.push({
        interval: [s, l],
        close: [1, 1]
      });
    }
    t.maxOpen && e.push({
      interval: [n[1], 1 / 0],
      close: [0, 0]
    }), qR(e), B(e, function(u, c) {
      u.index = c, u.text = this.formatValueText(u.interval);
    }, this);
  },
  categories: function(e) {
    var t = this.option;
    B(t.categories, function(r) {
      e.push({
        text: this.formatValueText(r, !0),
        value: r
      });
    }, this), rG(t, e);
  },
  pieces: function(e) {
    var t = this.option;
    B(t.pieces, function(r, n) {
      Ze(r) || (r = {
        value: r
      });
      var i = {
        text: "",
        index: n
      };
      if (r.label != null && (i.text = r.label), r.hasOwnProperty("value")) {
        var o = i.value = r.value;
        i.interval = [o, o], i.close = [1, 1];
      } else {
        for (var a = i.interval = [], s = i.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], c = [], d = 0; d < 2; d++) {
          for (var h = [["gte", "gt", "min"], ["lte", "lt", "max"]][d], f = 0; f < 3 && a[d] == null; f++)
            a[d] = r[h[f]], s[d] = l[f], c[d] = f === 2;
          a[d] == null && (a[d] = u[d]);
        }
        c[0] && a[1] === 1 / 0 && (s[0] = 0), c[1] && a[0] === -1 / 0 && (s[1] = 0), process.env.NODE_ENV !== "production" && a[0] > a[1] && console.warn("Piece " + n + "is illegal: " + a + " lower bound should not greater then uppper bound."), a[0] === a[1] && s[0] && s[1] && (i.value = a[0]);
      }
      i.visual = xn.retrieveVisuals(r), e.push(i);
    }, this), rG(t, e), qR(e), B(e, function(r) {
      var n = r.close, i = [["<", "≤"][n[1]], [">", "≥"][n[0]]];
      r.text = r.text || this.formatValueText(r.value != null ? r.value : r.interval, !1, i);
    }, this);
  }
};
function rG(e, t) {
  var r = e.inverse;
  (e.orient === "vertical" ? !r : r) && t.reverse();
}
var Y2e = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = t.type, r;
    }
    return t.prototype.doRender = function() {
      var r = this.group;
      r.removeAll();
      var n = this.visualMapModel, i = n.get("textGap"), o = n.textStyleModel, a = o.getFont(), s = o.getTextColor(), l = this._getItemAlign(), u = n.itemSize, c = this._getViewData(), d = c.endsText, h = tn(n.get("showLabel", !0), !d);
      d && this._renderEndsText(r, d[0], u, h, l), B(c.viewPieceList, function(f) {
        var p = f.piece, g = new it();
        g.onclick = ke(this._onItemClick, this, p), this._enableHoverLink(g, f.indexInModelPieceList);
        var v = n.getRepresentValue(p);
        if (this._createItemSymbol(g, v, [0, 0, u[0], u[1]]), h) {
          var m = this.visualMapModel.getValueState(v);
          g.add(new Vt({
            style: {
              x: l === "right" ? -i : u[0] + i,
              y: u[1] / 2,
              text: p.text,
              verticalAlign: "middle",
              align: l,
              font: a,
              fill: s,
              opacity: m === "outOfRange" ? 0.5 : 1
            }
          }));
        }
        r.add(g);
      }, this), d && this._renderEndsText(r, d[1], u, h, l), pc(n.get("orient"), r, n.get("itemGap")), this.renderBackground(r), this.positionGroup(r);
    }, t.prototype._enableHoverLink = function(r, n) {
      var i = this;
      r.on("mouseover", function() {
        return o("highlight");
      }).on("mouseout", function() {
        return o("downplay");
      });
      var o = function(a) {
        var s = i.visualMapModel;
        s.option.hoverLink && i.api.dispatchAction({
          type: a,
          batch: f0(s.findTargetDataIndices(n), s)
        });
      };
    }, t.prototype._getItemAlign = function() {
      var r = this.visualMapModel, n = r.option;
      if (n.orient === "vertical")
        return DU(r, this.api, r.itemSize);
      var i = n.align;
      return (!i || i === "auto") && (i = "left"), i;
    }, t.prototype._renderEndsText = function(r, n, i, o, a) {
      if (n) {
        var s = new it(), l = this.visualMapModel.textStyleModel;
        s.add(new Vt({
          style: br(l, {
            x: o ? a === "right" ? i[0] : 0 : i[0] / 2,
            y: i[1] / 2,
            verticalAlign: "middle",
            align: o ? a : "center",
            text: n
          })
        })), r.add(s);
      }
    }, t.prototype._getViewData = function() {
      var r = this.visualMapModel, n = ge(r.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), i = r.get("text"), o = r.get("orient"), a = r.get("inverse");
      return (o === "horizontal" ? a : !a) ? n.reverse() : i && (i = i.slice().reverse()), {
        viewPieceList: n,
        endsText: i
      };
    }, t.prototype._createItemSymbol = function(r, n, i) {
      r.add(rn(
        // symbol will be string
        this.getControllerVisual(n, "symbol"),
        i[0],
        i[1],
        i[2],
        i[3],
        // color will be string
        this.getControllerVisual(n, "color")
      ));
    }, t.prototype._onItemClick = function(r) {
      var n = this.visualMapModel, i = n.option, o = i.selectedMode;
      if (o) {
        var a = et(i.selected), s = n.getSelectedMapKey(r);
        o === "single" || o === !0 ? (a[s] = !0, B(a, function(l, u) {
          a[u] = u === s;
        })) : a[s] = !a[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: a
        });
      }
    }, t.type = "visualMap.piecewise", t;
  }(MU)
);
function FU(e) {
  e.registerComponentModel(U2e), e.registerComponentView(Y2e), AU(e);
}
function q2e(e) {
  _t(IU), _t(FU);
}
var Z2e = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, nG = Gt(), X2e = {};
function Q2e(e, t) {
  var r = e.getModel("aria");
  if (!r.get("enabled"))
    return;
  var n = et(Z2e);
  yt(n.label, e.getLocaleModel().get("aria"), !1), yt(r.option, n, !1), i(), o();
  function i() {
    var u = r.getModel("decal"), c = u.get("show");
    if (c) {
      var d = We();
      e.eachSeries(function(h) {
        if (!h.isColorBySeries()) {
          var f = d.get(h.type);
          f || (f = {}, d.set(h.type, f)), nG(h).scope = f;
        }
      }), e.eachRawSeries(function(h) {
        if (e.isSeriesFiltered(h))
          return;
        if (Ye(h.enableAriaDecal)) {
          h.enableAriaDecal();
          return;
        }
        var f = h.getData();
        if (h.isColorBySeries()) {
          var y = h_(h.ecModel, h.name, X2e, e.getSeriesCount()), C = f.getVisual("decal");
          f.setVisual("decal", S(C, y));
        } else {
          var p = h.getRawData(), g = {}, v = nG(h).scope;
          f.each(function(b) {
            var w = f.getRawIndex(b);
            g[w] = b;
          });
          var m = p.count();
          p.each(function(b) {
            var w = g[b], x = p.getName(b) || b + "", E = h_(h.ecModel, x, v, m), R = f.getItemVisual(w, "decal");
            f.setItemVisual(w, "decal", S(R, E));
          });
        }
        function S(b, w) {
          var x = b ? se(se({}, w), b) : w;
          return x.dirty = !0, x;
        }
      });
    }
  }
  function o() {
    var u = t.getZr().dom;
    if (u) {
      var c = e.getLocaleModel().get("aria"), d = r.getModel("label");
      if (d.option = Xe(d.option, c), !!d.get("enabled")) {
        if (d.get("description")) {
          u.setAttribute("aria-label", d.get("description"));
          return;
        }
        var h = e.getSeriesCount(), f = d.get(["data", "maxCount"]) || 10, p = d.get(["series", "maxCount"]) || 10, g = Math.min(h, p), v;
        if (!(h < 1)) {
          var m = s();
          if (m) {
            var y = d.get(["general", "withTitle"]);
            v = a(y, {
              title: m
            });
          } else
            v = d.get(["general", "withoutTitle"]);
          var C = [], S = h > 1 ? d.get(["series", "multiple", "prefix"]) : d.get(["series", "single", "prefix"]);
          v += a(S, {
            seriesCount: h
          }), e.eachSeries(function(E, R) {
            if (R < g) {
              var _ = void 0, P = E.get("name"), D = P ? "withName" : "withoutName";
              _ = h > 1 ? d.get(["series", "multiple", D]) : d.get(["series", "single", D]), _ = a(_, {
                seriesId: E.seriesIndex,
                seriesName: E.get("name"),
                seriesType: l(E.subType)
              });
              var I = E.getData();
              if (I.count() > f) {
                var A = d.get(["data", "partialData"]);
                _ += a(A, {
                  displayCnt: f
                });
              } else
                _ += d.get(["data", "allData"]);
              for (var O = d.get(["data", "separator", "middle"]), L = d.get(["data", "separator", "end"]), N = [], F = 0; F < I.count(); F++)
                if (F < f) {
                  var G = I.getName(F), M = I.getValues(F), V = d.get(["data", G ? "withName" : "withoutName"]);
                  N.push(a(V, {
                    name: G,
                    value: M.join(O)
                  }));
                }
              _ += N.join(O) + L, C.push(_);
            }
          });
          var b = d.getModel(["series", "multiple", "separator"]), w = b.get("middle"), x = b.get("end");
          v += C.join(w) + x, u.setAttribute("aria-label", v);
        }
      }
    }
  }
  function a(u, c) {
    if (!Fe(u))
      return u;
    var d = u;
    return B(c, function(h, f) {
      d = d.replace(new RegExp("\\{\\s*" + f + "\\s*\\}", "g"), h);
    }), d;
  }
  function s() {
    var u = e.get("title");
    return u && u.length && (u = u[0]), u && u.text;
  }
  function l(u) {
    var c = e.getLocaleModel().get(["series", "typeNames"]);
    return c[u] || c.chart;
  }
}
function J2e(e) {
  if (!(!e || !e.aria)) {
    var t = e.aria;
    t.show != null && (t.enabled = t.show), t.label = t.label || {}, B(["description", "general", "series", "data"], function(r) {
      t[r] != null && (t.label[r] = t[r]);
    });
  }
}
function eFe(e) {
  e.registerPreprocessor(J2e), e.registerVisual(e.PRIORITY.VISUAL.ARIA, Q2e);
}
var iG = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, tFe = (
  /** @class */
  function() {
    function e(t) {
      var r = this._condVal = Fe(t) ? new RegExp(t) : XP(t) ? t : null;
      if (r == null) {
        var n = "";
        process.env.NODE_ENV !== "production" && (n = wi("Illegal regexp", t, "in")), er(n);
      }
    }
    return e.prototype.evaluate = function(t) {
      var r = typeof t;
      return Fe(r) ? this._condVal.test(t) : $t(r) ? this._condVal.test(t + "") : !1;
    }, e;
  }()
), rFe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      return this.value;
    }, e;
  }()
), nFe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      for (var t = this.children, r = 0; r < t.length; r++)
        if (!t[r].evaluate())
          return !1;
      return !0;
    }, e;
  }()
), iFe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      for (var t = this.children, r = 0; r < t.length; r++)
        if (t[r].evaluate())
          return !0;
      return !1;
    }, e;
  }()
), oFe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, e;
  }()
), aFe = (
  /** @class */
  function() {
    function e() {
    }
    return e.prototype.evaluate = function() {
      for (var t = !!this.valueParser, r = this.getValue, n = r(this.valueGetterParam), i = t ? this.valueParser(n) : null, o = 0; o < this.subCondList.length; o++)
        if (!this.subCondList[o].evaluate(t ? i : n))
          return !1;
      return !0;
    }, e;
  }()
);
function cA(e, t) {
  if (e === !0 || e === !1) {
    var r = new rFe();
    return r.value = e, r;
  }
  var n = "";
  return LU(e) || (process.env.NODE_ENV !== "production" && (n = wi("Illegal config. Expect a plain object but actually", e)), er(n)), e.and ? oG("and", e, t) : e.or ? oG("or", e, t) : e.not ? sFe(e, t) : lFe(e, t);
}
function oG(e, t, r) {
  var n = t[e], i = "";
  process.env.NODE_ENV !== "production" && (i = wi('"and"/"or" condition should only be `' + e + ": [...]` and must not be empty array.", "Illegal condition:", t)), fe(n) || er(i), n.length || er(i);
  var o = e === "and" ? new nFe() : new iFe();
  return o.children = ge(n, function(a) {
    return cA(a, r);
  }), o.children.length || er(i), o;
}
function sFe(e, t) {
  var r = e.not, n = "";
  process.env.NODE_ENV !== "production" && (n = wi('"not" condition should only be `not: {}`.', "Illegal condition:", e)), LU(r) || er(n);
  var i = new oFe();
  return i.child = cA(r, t), i.child || er(n), i;
}
function lFe(e, t) {
  for (var r = "", n = t.prepareGetValue(e), i = [], o = At(e), a = e.parser, s = a ? hW(a) : null, l = 0; l < o.length; l++) {
    var u = o[l];
    if (!(u === "parser" || t.valueGetterAttrMap.get(u))) {
      var c = Be(iG, u) ? iG[u] : u, d = e[u], h = s ? s(d) : d, f = A0e(c, h) || c === "reg" && new tFe(h);
      f || (process.env.NODE_ENV !== "production" && (r = wi('Illegal relational operation: "' + u + '" in condition:', e)), er(r)), i.push(f);
    }
  }
  i.length || (process.env.NODE_ENV !== "production" && (r = wi("Relational condition must have at least one operator.", "Illegal condition:", e)), er(r));
  var p = new aFe();
  return p.valueGetterParam = n, p.valueParser = s, p.getValue = t.getValue, p.subCondList = i, p;
}
function LU(e) {
  return Ze(e) && !kn(e);
}
var uFe = (
  /** @class */
  function() {
    function e(t, r) {
      this._cond = cA(t, r);
    }
    return e.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, e;
  }()
);
function cFe(e, t) {
  return new uFe(e, t);
}
var dFe = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(e) {
    for (var t = e.upstream, r, n = cFe(e.config, {
      valueGetterAttrMap: We({
        dimension: !0
      }),
      prepareGetValue: function(s) {
        var l = "", u = s.dimension;
        Be(s, "dimension") || (process.env.NODE_ENV !== "production" && (l = wi('Relation condition must has prop "dimension" specified.', "Illegal condition:", s)), er(l));
        var c = t.getDimensionInfo(u);
        return c || (process.env.NODE_ENV !== "production" && (l = wi("Can not find dimension info via: " + u + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal condition:", s, `.
`)), er(l)), {
          dimIdx: c.index
        };
      },
      getValue: function(s) {
        return t.retrieveValueFromItem(r, s.dimIdx);
      }
    }), i = [], o = 0, a = t.count(); o < a; o++)
      r = t.getRawDataItem(o), n.evaluate() && i.push(r);
    return {
      data: i
    };
  }
}, hT = "";
process.env.NODE_ENV !== "production" && (hT = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" "));
var hFe = {
  type: "echarts:sort",
  transform: function(e) {
    var t = e.upstream, r = e.config, n = "", i = dr(r);
    i.length || (process.env.NODE_ENV !== "production" && (n = "Empty `config` in sort transform."), er(n));
    var o = [];
    B(i, function(c) {
      var d = c.dimension, h = c.order, f = c.parser, p = c.incomparable;
      if (d == null && (process.env.NODE_ENV !== "production" && (n = 'Sort transform config must has "dimension" specified.' + hT), er(n)), h !== "asc" && h !== "desc" && (process.env.NODE_ENV !== "production" && (n = 'Sort transform config must has "order" specified.' + hT), er(n)), p && p !== "min" && p !== "max") {
        var g = "";
        process.env.NODE_ENV !== "production" && (g = 'incomparable must be "min" or "max" rather than "' + p + '".'), er(g);
      }
      if (h !== "asc" && h !== "desc") {
        var v = "";
        process.env.NODE_ENV !== "production" && (v = 'order must be "asc" or "desc" rather than "' + h + '".'), er(v);
      }
      var m = t.getDimensionInfo(d);
      m || (process.env.NODE_ENV !== "production" && (n = wi("Can not find dimension info via: " + d + `.
`, "Existing dimensions: ", t.cloneAllDimensionInfo(), `.
`, "Illegal config:", c, `.
`)), er(n));
      var y = f ? hW(f) : null;
      f && !y && (process.env.NODE_ENV !== "production" && (n = wi("Invalid parser name " + f + `.
`, "Illegal config:", c, `.
`)), er(n)), o.push({
        dimIdx: m.index,
        parser: y,
        comparator: new pW(h, p)
      });
    });
    var a = t.sourceFormat;
    a !== ti && a !== $o && (process.env.NODE_ENV !== "production" && (n = 'sourceFormat "' + a + '" is not supported yet'), er(n));
    for (var s = [], l = 0, u = t.count(); l < u; l++)
      s.push(t.getRawDataItem(l));
    return s.sort(function(c, d) {
      for (var h = 0; h < o.length; h++) {
        var f = o[h], p = t.retrieveValueFromItem(c, f.dimIdx), g = t.retrieveValueFromItem(d, f.dimIdx);
        f.parser && (p = f.parser(p), g = f.parser(g));
        var v = f.comparator.evaluate(p, g);
        if (v !== 0)
          return v;
      }
      return 0;
    }), {
      data: s
    };
  }
};
function fFe(e) {
  e.registerTransform(dFe), e.registerTransform(hFe);
}
var pFe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "dataset", r;
    }
    return t.prototype.init = function(r, n, i) {
      e.prototype.init.call(this, r, n, i), this._sourceManager = new yW(this), oN(this);
    }, t.prototype.mergeOption = function(r, n) {
      e.prototype.mergeOption.call(this, r, n), oN(this);
    }, t.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, t.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, t.type = "dataset", t.defaultOption = {
      seriesLayoutBy: Ya
    }, t;
  }(Rt)
), gFe = (
  /** @class */
  function(e) {
    ne(t, e);
    function t() {
      var r = e !== null && e.apply(this, arguments) || this;
      return r.type = "dataset", r;
    }
    return t.type = "dataset", t;
  }(Rr)
);
function vFe(e) {
  e.registerComponentModel(pFe), e.registerComponentView(gFe);
}
var Da = es.CMD;
function ih(e, t) {
  return Math.abs(e - t) < 1e-5;
}
function fT(e) {
  var t = e.data, r = e.len(), n = [], i, o = 0, a = 0, s = 0, l = 0;
  function u(I, A) {
    i && i.length > 2 && n.push(i), i = [I, A];
  }
  function c(I, A, O, L) {
    ih(I, O) && ih(A, L) || i.push(I, A, O, L, O, L);
  }
  function d(I, A, O, L, N, F) {
    var G = Math.abs(A - I), M = Math.tan(G / 4) * 4 / 3, V = A < I ? -1 : 1, z = Math.cos(I), k = Math.sin(I), $ = Math.cos(A), W = Math.sin(A), j = z * N + O, U = k * F + L, Z = $ * N + O, ee = W * F + L, J = N * M * V, X = F * M * V;
    i.push(j - J * k, U + X * z, Z + J * W, ee - X * $, Z, ee);
  }
  for (var h, f, p, g, v = 0; v < r; ) {
    var m = t[v++], y = v === 1;
    switch (y && (o = t[v], a = t[v + 1], s = o, l = a, (m === Da.L || m === Da.C || m === Da.Q) && (i = [s, l])), m) {
      case Da.M:
        o = s = t[v++], a = l = t[v++], u(s, l);
        break;
      case Da.L:
        h = t[v++], f = t[v++], c(o, a, h, f), o = h, a = f;
        break;
      case Da.C:
        i.push(t[v++], t[v++], t[v++], t[v++], o = t[v++], a = t[v++]);
        break;
      case Da.Q:
        h = t[v++], f = t[v++], p = t[v++], g = t[v++], i.push(o + 2 / 3 * (h - o), a + 2 / 3 * (f - a), p + 2 / 3 * (h - p), g + 2 / 3 * (f - g), p, g), o = p, a = g;
        break;
      case Da.A:
        var C = t[v++], S = t[v++], b = t[v++], w = t[v++], x = t[v++], E = t[v++] + x;
        v += 1;
        var R = !t[v++];
        h = Math.cos(x) * b + C, f = Math.sin(x) * w + S, y ? (s = h, l = f, u(s, l)) : c(o, a, h, f), o = Math.cos(E) * b + C, a = Math.sin(E) * w + S;
        for (var _ = (R ? -1 : 1) * Math.PI / 2, P = x; R ? P > E : P < E; P += _) {
          var D = R ? Math.max(P + _, E) : Math.min(P + _, E);
          d(P, D, C, S, b, w);
        }
        break;
      case Da.R:
        s = o = t[v++], l = a = t[v++], h = s + t[v++], f = l + t[v++], u(h, l), c(h, l, h, f), c(h, f, s, f), c(s, f, s, l), c(s, l, h, l);
        break;
      case Da.Z:
        i && c(o, a, s, l), o = s, a = l;
        break;
    }
  }
  return i && i.length > 2 && n.push(i), n;
}
function pT(e, t, r, n, i, o, a, s, l, u) {
  if (ih(e, r) && ih(t, n) && ih(i, a) && ih(o, s)) {
    l.push(a, s);
    return;
  }
  var c = 2 / u, d = c * c, h = a - e, f = s - t, p = Math.sqrt(h * h + f * f);
  h /= p, f /= p;
  var g = r - e, v = n - t, m = i - a, y = o - s, C = g * g + v * v, S = m * m + y * y;
  if (C < d && S < d) {
    l.push(a, s);
    return;
  }
  var b = h * g + f * v, w = -h * m - f * y, x = C - b * b, E = S - w * w;
  if (x < d && b >= 0 && E < d && w >= 0) {
    l.push(a, s);
    return;
  }
  var R = [], _ = [];
  Wl(e, r, i, a, 0.5, R), Wl(t, n, o, s, 0.5, _), pT(R[0], _[0], R[1], _[1], R[2], _[2], R[3], _[3], l, u), pT(R[4], _[4], R[5], _[5], R[6], _[6], R[7], _[7], l, u);
}
function mFe(e, t) {
  var r = fT(e), n = [];
  t = t || 1;
  for (var i = 0; i < r.length; i++) {
    var o = r[i], a = [], s = o[0], l = o[1];
    a.push(s, l);
    for (var u = 2; u < o.length; ) {
      var c = o[u++], d = o[u++], h = o[u++], f = o[u++], p = o[u++], g = o[u++];
      pT(s, l, c, d, h, f, p, g, a, t), s = p, l = g;
    }
    n.push(a);
  }
  return n;
}
function OU(e, t, r) {
  var n = e[t], i = e[1 - t], o = Math.abs(n / i), a = Math.ceil(Math.sqrt(o * r)), s = Math.floor(r / a);
  s === 0 && (s = 1, a = r);
  for (var l = [], u = 0; u < a; u++)
    l.push(s);
  var c = a * s, d = r - c;
  if (d > 0)
    for (var u = 0; u < d; u++)
      l[u % a] += 1;
  return l;
}
function aG(e, t, r) {
  for (var n = e.r0, i = e.r, o = e.startAngle, a = e.endAngle, s = Math.abs(a - o), l = s * i, u = i - n, c = l > Math.abs(u), d = OU([l, u], c ? 0 : 1, t), h = (c ? s : u) / d.length, f = 0; f < d.length; f++)
    for (var p = (c ? u : s) / d[f], g = 0; g < d[f]; g++) {
      var v = {};
      c ? (v.startAngle = o + h * f, v.endAngle = o + h * (f + 1), v.r0 = n + p * g, v.r = n + p * (g + 1)) : (v.startAngle = o + p * g, v.endAngle = o + p * (g + 1), v.r0 = n + h * f, v.r = n + h * (f + 1)), v.clockwise = e.clockwise, v.cx = e.cx, v.cy = e.cy, r.push(v);
    }
}
function yFe(e, t, r) {
  for (var n = e.width, i = e.height, o = n > i, a = OU([n, i], o ? 0 : 1, t), s = o ? "width" : "height", l = o ? "height" : "width", u = o ? "x" : "y", c = o ? "y" : "x", d = e[s] / a.length, h = 0; h < a.length; h++)
    for (var f = e[l] / a[h], p = 0; p < a[h]; p++) {
      var g = {};
      g[u] = h * d, g[c] = p * f, g[s] = d, g[l] = f, g.x += e.x, g.y += e.y, r.push(g);
    }
}
function sG(e, t, r, n) {
  return e * n - r * t;
}
function CFe(e, t, r, n, i, o, a, s) {
  var l = r - e, u = n - t, c = a - i, d = s - o, h = sG(c, d, l, u);
  if (Math.abs(h) < 1e-6)
    return null;
  var f = e - i, p = t - o, g = sG(f, p, c, d) / h;
  return g < 0 || g > 1 ? null : new Ct(g * l + e, g * u + t);
}
function SFe(e, t, r) {
  var n = new Ct();
  Ct.sub(n, r, t), n.normalize();
  var i = new Ct();
  Ct.sub(i, e, t);
  var o = i.dot(n);
  return o;
}
function Vd(e, t) {
  var r = e[e.length - 1];
  r && r[0] === t[0] && r[1] === t[1] || e.push(t);
}
function wFe(e, t, r) {
  for (var n = e.length, i = [], o = 0; o < n; o++) {
    var a = e[o], s = e[(o + 1) % n], l = CFe(a[0], a[1], s[0], s[1], t.x, t.y, r.x, r.y);
    l && i.push({
      projPt: SFe(l, t, r),
      pt: l,
      idx: o
    });
  }
  if (i.length < 2)
    return [{ points: e }, { points: e }];
  i.sort(function(v, m) {
    return v.projPt - m.projPt;
  });
  var u = i[0], c = i[i.length - 1];
  if (c.idx < u.idx) {
    var d = u;
    u = c, c = d;
  }
  for (var h = [u.pt.x, u.pt.y], f = [c.pt.x, c.pt.y], p = [h], g = [f], o = u.idx + 1; o <= c.idx; o++)
    Vd(p, e[o].slice());
  Vd(p, f), Vd(p, h);
  for (var o = c.idx + 1; o <= u.idx + n; o++)
    Vd(g, e[o % n].slice());
  return Vd(g, h), Vd(g, f), [{
    points: p
  }, {
    points: g
  }];
}
function lG(e) {
  var t = e.points, r = [], n = [];
  LS(t, r, n);
  var i = new St(r[0], r[1], n[0] - r[0], n[1] - r[1]), o = i.width, a = i.height, s = i.x, l = i.y, u = new Ct(), c = new Ct();
  return o > a ? (u.x = c.x = s + o / 2, u.y = l, c.y = l + a) : (u.y = c.y = l + a / 2, u.x = s, c.x = s + o), wFe(t, u, c);
}
function OC(e, t, r, n) {
  if (r === 1)
    n.push(t);
  else {
    var i = Math.floor(r / 2), o = e(t);
    OC(e, o[0], i, n), OC(e, o[1], r - i, n);
  }
  return n;
}
function bFe(e, t) {
  for (var r = [], n = 0; n < t; n++)
    r.push(yM(e));
  return r;
}
function xFe(e, t) {
  t.setStyle(e.style), t.z = e.z, t.z2 = e.z2, t.zlevel = e.zlevel;
}
function EFe(e) {
  for (var t = [], r = 0; r < e.length; )
    t.push([e[r++], e[r++]]);
  return t;
}
function RFe(e, t) {
  var r = [], n = e.shape, i;
  switch (e.type) {
    case "rect":
      yFe(n, t, r), i = Bt;
      break;
    case "sector":
      aG(n, t, r), i = xi;
      break;
    case "circle":
      aG({
        r0: 0,
        r: n.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: n.cx,
        cy: n.cy
      }, t, r), i = xi;
      break;
    default:
      var o = e.getComputedTransform(), a = o ? Math.sqrt(Math.max(o[0] * o[0] + o[1] * o[1], o[2] * o[2] + o[3] * o[3])) : 1, s = ge(mFe(e.getUpdatedPathProxy(), a), function(m) {
        return EFe(m);
      }), l = s.length;
      if (l === 0)
        OC(lG, {
          points: s[0]
        }, t, r);
      else if (l === t)
        for (var u = 0; u < l; u++)
          r.push({
            points: s[u]
          });
      else {
        var c = 0, d = ge(s, function(m) {
          var y = [], C = [];
          LS(m, y, C);
          var S = (C[1] - y[1]) * (C[0] - y[0]);
          return c += S, { poly: m, area: S };
        });
        d.sort(function(m, y) {
          return y.area - m.area;
        });
        for (var h = t, u = 0; u < l; u++) {
          var f = d[u];
          if (h <= 0)
            break;
          var p = u === l - 1 ? h : Math.ceil(f.area / c * t);
          p < 0 || (OC(lG, {
            points: f.poly
          }, p, r), h -= p);
        }
      }
      i = Ei;
      break;
  }
  if (!i)
    return bFe(e, t);
  for (var g = [], u = 0; u < r.length; u++) {
    var v = new i();
    v.setShape(r[u]), xFe(e, v), g.push(v);
  }
  return g;
}
function _Fe(e, t) {
  var r = e.length, n = t.length;
  if (r === n)
    return [e, t];
  for (var i = [], o = [], a = r < n ? e : t, s = Math.min(r, n), l = Math.abs(n - r) / 6, u = (s - 2) / 6, c = Math.ceil(l / u) + 1, d = [a[0], a[1]], h = l, f = 2; f < s; ) {
    var p = a[f - 2], g = a[f - 1], v = a[f++], m = a[f++], y = a[f++], C = a[f++], S = a[f++], b = a[f++];
    if (h <= 0) {
      d.push(v, m, y, C, S, b);
      continue;
    }
    for (var w = Math.min(h, c - 1) + 1, x = 1; x <= w; x++) {
      var E = x / w;
      Wl(p, v, y, S, E, i), Wl(g, m, C, b, E, o), p = i[3], g = o[3], d.push(i[1], o[1], i[2], o[2], p, g), v = i[5], m = o[5], y = i[6], C = o[6];
    }
    h -= w - 1;
  }
  return a === e ? [d, t] : [e, d];
}
function uG(e, t) {
  for (var r = e.length, n = e[r - 2], i = e[r - 1], o = [], a = 0; a < t.length; )
    o[a++] = n, o[a++] = i;
  return o;
}
function TFe(e, t) {
  for (var r, n, i, o = [], a = [], s = 0; s < Math.max(e.length, t.length); s++) {
    var l = e[s], u = t[s], c = void 0, d = void 0;
    l ? u ? (r = _Fe(l, u), c = r[0], d = r[1], n = c, i = d) : (d = uG(i || l, l), c = l) : (c = uG(n || u, u), d = u), o.push(c), a.push(d);
  }
  return [o, a];
}
function cG(e) {
  for (var t = 0, r = 0, n = 0, i = e.length, o = 0, a = i - 2; o < i; a = o, o += 2) {
    var s = e[a], l = e[a + 1], u = e[o], c = e[o + 1], d = s * c - u * l;
    t += d, r += (s + u) * d, n += (l + c) * d;
  }
  return t === 0 ? [e[0] || 0, e[1] || 0] : [r / t / 3, n / t / 3, t];
}
function PFe(e, t, r, n) {
  for (var i = (e.length - 2) / 6, o = 1 / 0, a = 0, s = e.length, l = s - 2, u = 0; u < i; u++) {
    for (var c = u * 6, d = 0, h = 0; h < s; h += 2) {
      var f = h === 0 ? c : (c + h - 2) % l + 2, p = e[f] - r[0], g = e[f + 1] - r[1], v = t[h] - n[0], m = t[h + 1] - n[1], y = v - p, C = m - g;
      d += y * y + C * C;
    }
    d < o && (o = d, a = u);
  }
  return a;
}
function MFe(e) {
  for (var t = [], r = e.length, n = 0; n < r; n += 2)
    t[n] = e[r - n - 2], t[n + 1] = e[r - n - 1];
  return t;
}
function DFe(e, t, r, n) {
  for (var i = [], o, a = 0; a < e.length; a++) {
    var s = e[a], l = t[a], u = cG(s), c = cG(l);
    o == null && (o = u[2] < 0 != c[2] < 0);
    var d = [], h = [], f = 0, p = 1 / 0, g = [], v = s.length;
    o && (s = MFe(s));
    for (var m = PFe(s, l, u, c) * 6, y = v - 2, C = 0; C < y; C += 2) {
      var S = (m + C) % y + 2;
      d[C + 2] = s[S] - u[0], d[C + 3] = s[S + 1] - u[1];
    }
    d[0] = s[m] - u[0], d[1] = s[m + 1] - u[1];
    for (var b = n / r, w = -n / 2; w <= n / 2; w += b) {
      for (var x = Math.sin(w), E = Math.cos(w), R = 0, C = 0; C < s.length; C += 2) {
        var _ = d[C], P = d[C + 1], D = l[C] - c[0], I = l[C + 1] - c[1], A = D * E - I * x, O = D * x + I * E;
        g[C] = A, g[C + 1] = O;
        var L = A - _, N = O - P;
        R += L * L + N * N;
      }
      if (R < p) {
        p = R, f = w;
        for (var F = 0; F < g.length; F++)
          h[F] = g[F];
      }
    }
    i.push({
      from: d,
      to: h,
      fromCp: u,
      toCp: c,
      rotation: -f
    });
  }
  return i;
}
function NC(e) {
  return e.__isCombineMorphing;
}
var NU = "__mOriginal_";
function kC(e, t, r) {
  var n = NU + t, i = e[n] || e[t];
  e[n] || (e[n] = e[t]);
  var o = r.replace, a = r.after, s = r.before;
  e[t] = function() {
    var l = arguments, u;
    return s && s.apply(this, l), o ? u = o.apply(this, l) : u = i.apply(this, l), a && a.apply(this, l), u;
  };
}
function lg(e, t) {
  var r = NU + t;
  e[r] && (e[t] = e[r], e[r] = null);
}
function dG(e, t) {
  for (var r = 0; r < e.length; r++)
    for (var n = e[r], i = 0; i < n.length; ) {
      var o = n[i], a = n[i + 1];
      n[i++] = t[0] * o + t[2] * a + t[4], n[i++] = t[1] * o + t[3] * a + t[5];
    }
}
function kU(e, t) {
  var r = e.getUpdatedPathProxy(), n = t.getUpdatedPathProxy(), i = TFe(fT(r), fT(n)), o = i[0], a = i[1], s = e.getComputedTransform(), l = t.getComputedTransform();
  function u() {
    this.transform = null;
  }
  s && dG(o, s), l && dG(a, l), kC(t, "updateTransform", { replace: u }), t.transform = null;
  var c = DFe(o, a, 10, Math.PI), d = [];
  kC(t, "buildPath", { replace: function(h) {
    for (var f = t.__morphT, p = 1 - f, g = [], v = 0; v < c.length; v++) {
      var m = c[v], y = m.from, C = m.to, S = m.rotation * f, b = m.fromCp, w = m.toCp, x = Math.sin(S), E = Math.cos(S);
      Yp(g, b, w, f);
      for (var R = 0; R < y.length; R += 2) {
        var _ = y[R], P = y[R + 1], D = C[R], I = C[R + 1], A = _ * p + D * f, O = P * p + I * f;
        d[R] = A * E - O * x + g[0], d[R + 1] = A * x + O * E + g[1];
      }
      var L = d[0], N = d[1];
      h.moveTo(L, N);
      for (var R = 2; R < y.length; ) {
        var D = d[R++], I = d[R++], F = d[R++], G = d[R++], M = d[R++], V = d[R++];
        L === D && N === I && F === M && G === V ? h.lineTo(M, V) : h.bezierCurveTo(D, I, F, G, M, V), L = M, N = V;
      }
    }
  } });
}
function dA(e, t, r) {
  if (!e || !t)
    return t;
  var n = r.done, i = r.during;
  kU(e, t), t.__morphT = 0;
  function o() {
    lg(t, "buildPath"), lg(t, "updateTransform"), t.__morphT = -1, t.createPathProxy(), t.dirtyShape();
  }
  return t.animateTo({
    __morphT: 1
  }, Xe({
    during: function(a) {
      t.dirtyShape(), i && i(a);
    },
    done: function() {
      o(), n && n();
    }
  }, r)), t;
}
function AFe(e, t, r, n, i, o) {
  var a = 16;
  e = i === r ? 0 : Math.round(32767 * (e - r) / (i - r)), t = o === n ? 0 : Math.round(32767 * (t - n) / (o - n));
  for (var s = 0, l, u = (1 << a) / 2; u > 0; u /= 2) {
    var c = 0, d = 0;
    (e & u) > 0 && (c = 1), (t & u) > 0 && (d = 1), s += u * u * (3 * c ^ d), d === 0 && (c === 1 && (e = u - 1 - e, t = u - 1 - t), l = e, e = t, t = l);
  }
  return s;
}
function VC(e) {
  var t = 1 / 0, r = 1 / 0, n = -1 / 0, i = -1 / 0, o = ge(e, function(s) {
    var l = s.getBoundingRect(), u = s.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), d = l.y + l.height / 2 + (u ? u[5] : 0);
    return t = Math.min(c, t), r = Math.min(d, r), n = Math.max(c, n), i = Math.max(d, i), [c, d];
  }), a = ge(o, function(s, l) {
    return {
      cp: s,
      z: AFe(s[0], s[1], t, r, n, i),
      path: e[l]
    };
  });
  return a.sort(function(s, l) {
    return s.z - l.z;
  }).map(function(s) {
    return s.path;
  });
}
function VU(e) {
  return RFe(e.path, e.count);
}
function gT() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function IFe(e, t, r) {
  var n = [];
  function i(b) {
    for (var w = 0; w < b.length; w++) {
      var x = b[w];
      NC(x) ? i(x.childrenRef()) : x instanceof Mt && n.push(x);
    }
  }
  i(e);
  var o = n.length;
  if (!o)
    return gT();
  var a = r.dividePath || VU, s = a({
    path: t,
    count: o
  });
  if (s.length !== o)
    return console.error("Invalid morphing: unmatched splitted path"), gT();
  n = VC(n), s = VC(s);
  for (var l = r.done, u = r.during, c = r.individualDelay, d = new Ts(), h = 0; h < o; h++) {
    var f = n[h], p = s[h];
    p.parent = t, p.copyTransform(d), c || kU(f, p);
  }
  t.__isCombineMorphing = !0, t.childrenRef = function() {
    return s;
  };
  function g(b) {
    for (var w = 0; w < s.length; w++)
      s[w].addSelfToZr(b);
  }
  kC(t, "addSelfToZr", {
    after: function(b) {
      g(b);
    }
  }), kC(t, "removeSelfFromZr", {
    after: function(b) {
      for (var w = 0; w < s.length; w++)
        s[w].removeSelfFromZr(b);
    }
  });
  function v() {
    t.__isCombineMorphing = !1, t.__morphT = -1, t.childrenRef = null, lg(t, "addSelfToZr"), lg(t, "removeSelfFromZr");
  }
  var m = s.length;
  if (c)
    for (var y = m, C = function() {
      y--, y === 0 && (v(), l && l());
    }, h = 0; h < m; h++) {
      var S = c ? Xe({
        delay: (r.delay || 0) + c(h, m, n[h], s[h]),
        done: C
      }, r) : r;
      dA(n[h], s[h], S);
    }
  else
    t.__morphT = 0, t.animateTo({
      __morphT: 1
    }, Xe({
      during: function(b) {
        for (var w = 0; w < m; w++) {
          var x = s[w];
          x.__morphT = t.__morphT, x.dirtyShape();
        }
        u && u(b);
      },
      done: function() {
        v();
        for (var b = 0; b < e.length; b++)
          lg(e[b], "updateTransform");
        l && l();
      }
    }, r));
  return t.__zr && g(t.__zr), {
    fromIndividuals: n,
    toIndividuals: s,
    count: m
  };
}
function FFe(e, t, r) {
  var n = t.length, i = [], o = r.dividePath || VU;
  function a(f) {
    for (var p = 0; p < f.length; p++) {
      var g = f[p];
      NC(g) ? a(g.childrenRef()) : g instanceof Mt && i.push(g);
    }
  }
  if (NC(e)) {
    a(e.childrenRef());
    var s = i.length;
    if (s < n)
      for (var l = 0, u = s; u < n; u++)
        i.push(yM(i[l++ % s]));
    i.length = n;
  } else {
    i = o({ path: e, count: n });
    for (var c = e.getComputedTransform(), u = 0; u < i.length; u++)
      i[u].setLocalTransform(c);
    if (i.length !== n)
      return console.error("Invalid morphing: unmatched splitted path"), gT();
  }
  i = VC(i), t = VC(t);
  for (var d = r.individualDelay, u = 0; u < n; u++) {
    var h = d ? Xe({
      delay: (r.delay || 0) + d(u, n, i[u], t[u])
    }, r) : r;
    dA(i[u], t[u], h);
  }
  return {
    fromIndividuals: i,
    toIndividuals: t,
    count: t.length
  };
}
function hG(e) {
  return fe(e[0]);
}
function fG(e, t) {
  for (var r = [], n = e.length, i = 0; i < n; i++)
    r.push({
      one: e[i],
      many: []
    });
  for (var i = 0; i < t.length; i++) {
    var o = t[i].length, a = void 0;
    for (a = 0; a < o; a++)
      r[a % n].many.push(t[i][a]);
  }
  for (var s = 0, i = n - 1; i >= 0; i--)
    if (!r[i].many.length) {
      var l = r[s].many;
      if (l.length <= 1)
        if (s)
          s = 0;
        else
          return r;
      var o = l.length, u = Math.ceil(o / 2);
      r[i].many = l.slice(u, o), r[s].many = l.slice(0, u), s++;
    }
  return r;
}
var LFe = {
  clone: function(e) {
    for (var t = [], r = 1 - Math.pow(1 - e.path.style.opacity, 1 / e.count), n = 0; n < e.count; n++) {
      var i = yM(e.path);
      i.setStyle("opacity", r), t.push(i);
    }
    return t;
  },
  // Use the default divider
  split: null
};
function kx(e, t, r, n, i, o) {
  if (!e.length || !t.length)
    return;
  var a = sf("update", n, i);
  if (!(a && a.duration > 0))
    return;
  var s = n.getModel("universalTransition").get("delay"), l = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, a), u, c;
  hG(e) && (u = e, c = t), hG(t) && (u = t, c = e);
  function d(m, y, C, S, b) {
    var w = m.many, x = m.one;
    if (w.length === 1 && !b) {
      var E = y ? w[0] : x, R = y ? x : w[0];
      if (NC(E))
        d({
          many: [E],
          one: R
        }, !0, C, S, !0);
      else {
        var _ = s ? Xe({
          delay: s(C, S)
        }, l) : l;
        dA(E, R, _), o(E, R, E, R, _);
      }
    } else
      for (var P = Xe({
        dividePath: LFe[r],
        individualDelay: s && function(N, F, G, M) {
          return s(N + C, S);
        }
      }, l), D = y ? IFe(w, x, P) : FFe(x, w, P), I = D.fromIndividuals, A = D.toIndividuals, O = I.length, L = 0; L < O; L++) {
        var _ = s ? Xe({
          delay: s(L, O)
        }, l) : l;
        o(I[L], A[L], y ? w[L] : m.one, y ? m.one : w[L], _);
      }
  }
  for (var h = u ? u === e : e.length > t.length, f = u ? fG(c, u) : fG(h ? t : e, [h ? e : t]), p = 0, g = 0; g < f.length; g++)
    p += f[g].many.length;
  for (var v = 0, g = 0; g < f.length; g++)
    d(f[g], h, v, p), v += f[g].many.length;
}
function zu(e) {
  if (!e)
    return [];
  if (fe(e)) {
    for (var t = [], r = 0; r < e.length; r++)
      t.push(zu(e[r]));
    return t;
  }
  var n = [];
  return e.traverse(function(i) {
    i instanceof Mt && !i.disableMorphing && !i.invisible && !i.ignore && n.push(i);
  }), n;
}
var BU = 1e4, OFe = 0, pG = 1, gG = 2, NFe = Gt();
function kFe(e, t) {
  for (var r = e.dimensions, n = 0; n < r.length; n++) {
    var i = e.getDimensionInfo(r[n]);
    if (i && i.otherDims[t] === 0)
      return r[n];
  }
}
function VFe(e, t, r) {
  var n = e.getDimensionInfo(r), i = n && n.ordinalMeta;
  if (n) {
    var o = e.get(n.name, t);
    return i && i.categories[o] || o + "";
  }
}
function vG(e, t, r, n) {
  var i = n ? "itemChildGroupId" : "itemGroupId", o = kFe(e, i);
  if (o) {
    var a = VFe(e, t, o);
    return a;
  }
  var s = e.getRawDataItem(t), l = n ? "childGroupId" : "groupId";
  if (s && s[l])
    return s[l] + "";
  if (!n)
    return r || e.getId(t);
}
function mG(e) {
  var t = [];
  return B(e, function(r) {
    var n = r.data, i = r.dataGroupId;
    if (n.count() > BU) {
      process.env.NODE_ENV !== "production" && Vr("Universal transition is disabled on large data > 10k.");
      return;
    }
    for (var o = n.getIndices(), a = 0; a < o.length; a++)
      t.push({
        data: n,
        groupId: vG(n, a, i, !1),
        childGroupId: vG(n, a, i, !0),
        divide: r.divide,
        dataIndex: a
      });
  }), t;
}
function Vx(e, t, r) {
  e.traverse(function(n) {
    n instanceof Mt && Pr(n, {
      style: {
        opacity: 0
      }
    }, t, {
      dataIndex: r,
      isFrom: !0
    });
  });
}
function Bx(e) {
  if (e.parent) {
    var t = e.getComputedTransform();
    e.setLocalTransform(t), e.parent.remove(e);
  }
}
function Bd(e) {
  e.stopAnimation(), e.isGroup && e.traverse(function(t) {
    t.stopAnimation();
  });
}
function BFe(e, t, r) {
  var n = sf("update", r, t);
  n && e.traverse(function(i) {
    if (i instanceof ko) {
      var o = fye(i);
      o && i.animateFrom({
        style: o
      }, n);
    }
  });
}
function GFe(e, t) {
  var r = e.length;
  if (r !== t.length)
    return !1;
  for (var n = 0; n < r; n++) {
    var i = e[n], o = t[n];
    if (i.data.getId(i.dataIndex) !== o.data.getId(o.dataIndex))
      return !1;
  }
  return !0;
}
function GU(e, t, r) {
  var n = mG(e), i = mG(t);
  function o(C, S, b, w, x) {
    (b || C) && S.animateFrom({
      style: b && b !== C ? se(se({}, b.style), C.style) : C.style
    }, x);
  }
  var a = !1, s = OFe, l = We(), u = We();
  n.forEach(function(C) {
    C.groupId && l.set(C.groupId, !0), C.childGroupId && u.set(C.childGroupId, !0);
  });
  for (var c = 0; c < i.length; c++) {
    var d = i[c].groupId;
    if (u.get(d)) {
      s = pG;
      break;
    }
    var h = i[c].childGroupId;
    if (h && l.get(h)) {
      s = gG;
      break;
    }
  }
  function f(C, S) {
    return function(b) {
      var w = b.data, x = b.dataIndex;
      return S ? w.getId(x) : C ? s === pG ? b.childGroupId : b.groupId : s === gG ? b.childGroupId : b.groupId;
    };
  }
  var p = GFe(n, i), g = {};
  if (!p)
    for (var c = 0; c < i.length; c++) {
      var v = i[c], m = v.data.getItemGraphicEl(v.dataIndex);
      m && (g[m.id] = !0);
    }
  function y(C, S) {
    var b = n[S], w = i[C], x = w.data.hostModel, E = b.data.getItemGraphicEl(b.dataIndex), R = w.data.getItemGraphicEl(w.dataIndex);
    if (E === R) {
      R && BFe(R, w.dataIndex, x);
      return;
    }
    // We can't use the elements that already being morphed
    E && g[E.id] || R && (Bd(R), E ? (Bd(E), Bx(E), a = !0, kx(zu(E), zu(R), w.divide, x, C, o)) : Vx(R, x, C));
  }
  new Ws(n, i, f(!0, p), f(!1, p), null, "multiple").update(y).updateManyToOne(function(C, S) {
    var b = i[C], w = b.data, x = w.hostModel, E = w.getItemGraphicEl(b.dataIndex), R = ir(ge(S, function(_) {
      return n[_].data.getItemGraphicEl(n[_].dataIndex);
    }), function(_) {
      return _ && _ !== E && !g[_.id];
    });
    E && (Bd(E), R.length ? (B(R, function(_) {
      Bd(_), Bx(_);
    }), a = !0, kx(zu(R), zu(E), b.divide, x, C, o)) : Vx(E, x, b.dataIndex));
  }).updateOneToMany(function(C, S) {
    var b = n[S], w = b.data.getItemGraphicEl(b.dataIndex);
    if (!(w && g[w.id])) {
      var x = ir(ge(C, function(R) {
        return i[R].data.getItemGraphicEl(i[R].dataIndex);
      }), function(R) {
        return R && R !== w;
      }), E = i[C[0]].data.hostModel;
      x.length && (B(x, function(R) {
        return Bd(R);
      }), w ? (Bd(w), Bx(w), a = !0, kx(
        zu(w),
        zu(x),
        b.divide,
        // Use divide on old.
        E,
        C[0],
        o
      )) : B(x, function(R) {
        return Vx(R, E, C[0]);
      }));
    }
  }).updateManyToMany(function(C, S) {
    new Ws(S, C, function(b) {
      return n[b].data.getId(n[b].dataIndex);
    }, function(b) {
      return i[b].data.getId(i[b].dataIndex);
    }).update(function(b, w) {
      y(C[b], S[w]);
    }).execute();
  }).execute(), a && B(t, function(C) {
    var S = C.data, b = S.hostModel, w = b && r.getViewOfSeriesModel(b), x = sf("update", b, 0);
    w && b.isAnimationEnabled() && x && x.duration > 0 && w.group.traverse(function(E) {
      E instanceof Mt && !E.animators.length && E.animateFrom({
        style: {
          opacity: 0
        }
      }, x);
    });
  });
}
function yG(e) {
  var t = e.getModel("universalTransition").get("seriesKey");
  return t || e.id;
}
function CG(e) {
  return fe(e) ? e.sort().join(",") : e;
}
function wl(e) {
  if (e.hostModel)
    return e.hostModel.getModel("universalTransition").get("divideShape");
}
function HFe(e, t) {
  var r = We(), n = We(), i = We();
  B(e.oldSeries, function(a, s) {
    var l = e.oldDataGroupIds[s], u = e.oldData[s], c = yG(a), d = CG(c);
    n.set(d, {
      dataGroupId: l,
      data: u
    }), fe(c) && B(c, function(h) {
      i.set(h, {
        key: d,
        dataGroupId: l,
        data: u
      });
    });
  });
  function o(a) {
    r.get(a) && Vr("Duplicated seriesKey in universalTransition " + a);
  }
  return B(t.updatedSeries, function(a) {
    if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
      var s = a.get("dataGroupId"), l = a.getData(), u = yG(a), c = CG(u), d = n.get(c);
      if (d)
        process.env.NODE_ENV !== "production" && o(c), r.set(c, {
          oldSeries: [{
            dataGroupId: d.dataGroupId,
            divide: wl(d.data),
            data: d.data
          }],
          newSeries: [{
            dataGroupId: s,
            divide: wl(l),
            data: l
          }]
        });
      else if (fe(u)) {
        process.env.NODE_ENV !== "production" && o(c);
        var h = [];
        B(u, function(g) {
          var v = n.get(g);
          v.data && h.push({
            dataGroupId: v.dataGroupId,
            divide: wl(v.data),
            data: v.data
          });
        }), h.length && r.set(c, {
          oldSeries: h,
          newSeries: [{
            dataGroupId: s,
            data: l,
            divide: wl(l)
          }]
        });
      } else {
        var f = i.get(u);
        if (f) {
          var p = r.get(f.key);
          p || (p = {
            oldSeries: [{
              dataGroupId: f.dataGroupId,
              data: f.data,
              divide: wl(f.data)
            }],
            newSeries: []
          }, r.set(f.key, p)), p.newSeries.push({
            dataGroupId: s,
            data: l,
            divide: wl(l)
          });
        }
      }
    }
  }), r;
}
function SG(e, t) {
  for (var r = 0; r < e.length; r++) {
    var n = t.seriesIndex != null && t.seriesIndex === e[r].seriesIndex || t.seriesId != null && t.seriesId === e[r].id;
    if (n)
      return r;
  }
}
function zFe(e, t, r, n) {
  var i = [], o = [];
  B(dr(e.from), function(a) {
    var s = SG(t.oldSeries, a);
    s >= 0 && i.push({
      dataGroupId: t.oldDataGroupIds[s],
      data: t.oldData[s],
      // TODO can specify divideShape in transition.
      divide: wl(t.oldData[s]),
      groupIdDim: a.dimension
    });
  }), B(dr(e.to), function(a) {
    var s = SG(r.updatedSeries, a);
    if (s >= 0) {
      var l = r.updatedSeries[s].getData();
      o.push({
        dataGroupId: t.oldDataGroupIds[s],
        data: l,
        divide: wl(l),
        groupIdDim: a.dimension
      });
    }
  }), i.length > 0 && o.length > 0 && GU(i, o, n);
}
function $Fe(e) {
  e.registerUpdateLifecycle("series:beforeupdate", function(t, r, n) {
    B(dr(n.seriesTransition), function(i) {
      B(dr(i.to), function(o) {
        for (var a = n.updatedSeries, s = 0; s < a.length; s++)
          (o.seriesIndex != null && o.seriesIndex === a[s].seriesIndex || o.seriesId != null && o.seriesId === a[s].id) && (a[s][a0] = !0);
      });
    });
  }), e.registerUpdateLifecycle("series:transition", function(t, r, n) {
    var i = NFe(r);
    if (i.oldSeries && n.updatedSeries && n.optionChanged) {
      var o = n.seriesTransition;
      if (o)
        B(dr(o), function(f) {
          zFe(f, i, n, r);
        });
      else {
        var a = HFe(i, n);
        B(a.keys(), function(f) {
          var p = a.get(f);
          GU(p.oldSeries, p.newSeries, r);
        });
      }
      B(n.updatedSeries, function(f) {
        f[a0] && (f[a0] = !1);
      });
    }
    for (var s = t.getSeries(), l = i.oldSeries = [], u = i.oldDataGroupIds = [], c = i.oldData = [], d = 0; d < s.length; d++) {
      var h = s[d].getData();
      h.count() < BU && (l.push(s[d]), u.push(s[d].get("dataGroupId")), c.push(h));
    }
  });
}
_t([Jbe]);
_t([Ybe]);
_t([C1e, L1e, W1e, xxe, Lxe, SEe, YEe, ARe, JRe, o_e, p_e, lTe, FTe, WTe, aPe, cPe, SPe, TPe, VPe, WPe, eMe, NMe]);
_t(tDe);
_t(PDe);
_t(k9);
_t(HDe);
_t(bj);
_t(jDe);
_t(eAe);
_t(HAe);
_t(aIe);
_t(jv);
_t(xIe);
_t(_Ie);
_t(NIe);
_t($Ie);
_t(qIe);
_t(t2e);
_t(d2e);
_t(M2e);
_t(_U);
_t(TU);
_t(q2e);
_t(IU);
_t(FU);
_t(eFe);
_t(fFe);
_t(vFe);
_t($Fe);
_t(pbe);
const WFe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Axis: Wo,
  ChartView: ar,
  ComponentModel: Rt,
  ComponentView: Rr,
  List: Jn,
  Model: cr,
  PRIORITY: UW,
  SeriesModel: hr,
  color: xge,
  connect: SSe,
  dataTool: TSe,
  dependencies: rSe,
  disConnect: wSe,
  disconnect: e7,
  dispose: bSe,
  env: kt,
  extendChartView: tbe,
  extendComponentModel: Qwe,
  extendComponentView: Jwe,
  extendSeriesModel: ebe,
  format: Gwe,
  getCoordinateSystemDimensions: ESe,
  getInstanceByDom: qM,
  getInstanceById: xSe,
  getMap: _Se,
  graphic: Bwe,
  helper: Awe,
  init: CSe,
  innerDrawElementOnCanvas: jM,
  matrix: ege,
  number: kwe,
  parseGeoJSON: T_,
  parseGeoJson: T_,
  registerAction: wa,
  registerCoordinateSystem: n7,
  registerLayout: i7,
  registerLoading: eD,
  registerLocale: TM,
  registerMap: o7,
  registerPostInit: t7,
  registerPostUpdate: r7,
  registerPreprocessor: XM,
  registerProcessor: QM,
  registerTheme: ZM,
  registerTransform: a7,
  registerUpdateLifecycle: JS,
  registerVisual: au,
  setCanvasCreator: RSe,
  setPlatformAPI: $3,
  throttle: XS,
  time: Vwe,
  use: _t,
  util: Hwe,
  vector: Gpe,
  version: tSe,
  zrUtil: Fpe,
  zrender: ove
}, Symbol.toStringTag, { value: "Module" }));
var yc = {}, kl = {}, HU = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = void 0;
  var t = 1, r = function() {
    return "".concat(t++);
  };
  e.default = r;
})(HU);
var hw = {}, fw = {}, hA = {};
(function(e) {
  Object.defineProperty(e, "__esModule", {
    value: !0
  }), e.default = void 0;
  var t = function(n) {
    var i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 60, o = null;
    return function() {
      for (var a = this, s = arguments.length, l = new Array(s), u = 0; u < s; u++)
        l[u] = arguments[u];
      clearTimeout(o), o = setTimeout(function() {
        n.apply(a, l);
      }, i);
    };
  };
  e.default = t;
})(hA);
var qa = {};
Object.defineProperty(qa, "__esModule", {
  value: !0
});
qa.SizeSensorId = qa.SensorTabIndex = qa.SensorClassName = void 0;
var jFe = "size-sensor-id";
qa.SizeSensorId = jFe;
var UFe = "size-sensor-object";
qa.SensorClassName = UFe;
var KFe = "-1";
qa.SensorTabIndex = KFe;
Object.defineProperty(fw, "__esModule", {
  value: !0
});
fw.createSensor = void 0;
var YFe = qFe(hA), Gx = qa;
function qFe(e) {
  return e && e.__esModule ? e : { default: e };
}
var ZFe = function(t, r) {
  var n = void 0, i = [], o = function() {
    getComputedStyle(t).position === "static" && (t.style.position = "relative");
    var d = document.createElement("object");
    return d.onload = function() {
      d.contentDocument.defaultView.addEventListener("resize", a), a();
    }, d.style.display = "block", d.style.position = "absolute", d.style.top = "0", d.style.left = "0", d.style.height = "100%", d.style.width = "100%", d.style.overflow = "hidden", d.style.pointerEvents = "none", d.style.zIndex = "-1", d.style.opacity = "0", d.setAttribute("class", Gx.SensorClassName), d.setAttribute("tabindex", Gx.SensorTabIndex), d.type = "text/html", t.appendChild(d), d.data = "about:blank", d;
  }, a = (0, YFe.default)(function() {
    i.forEach(function(c) {
      c(t);
    });
  }), s = function(d) {
    n || (n = o()), i.indexOf(d) === -1 && i.push(d);
  }, l = function() {
    n && n.parentNode && (n.contentDocument && n.contentDocument.defaultView.removeEventListener("resize", a), n.parentNode.removeChild(n), t.removeAttribute(Gx.SizeSensorId), n = void 0, i = [], r && r());
  }, u = function(d) {
    var h = i.indexOf(d);
    h !== -1 && i.splice(h, 1), i.length === 0 && n && l();
  };
  return {
    element: t,
    bind: s,
    destroy: l,
    unbind: u
  };
};
fw.createSensor = ZFe;
var pw = {};
Object.defineProperty(pw, "__esModule", {
  value: !0
});
pw.createSensor = void 0;
var XFe = qa, QFe = JFe(hA);
function JFe(e) {
  return e && e.__esModule ? e : { default: e };
}
var eLe = function(t, r) {
  var n = void 0, i = [], o = (0, QFe.default)(function() {
    i.forEach(function(c) {
      c(t);
    });
  }), a = function() {
    var d = new ResizeObserver(o);
    return d.observe(t), o(), d;
  }, s = function(d) {
    n || (n = a()), i.indexOf(d) === -1 && i.push(d);
  }, l = function() {
    n.disconnect(), i = [], n = void 0, t.removeAttribute(XFe.SizeSensorId), r && r();
  }, u = function(d) {
    var h = i.indexOf(d);
    h !== -1 && i.splice(h, 1), i.length === 0 && n && l();
  };
  return {
    element: t,
    bind: s,
    destroy: l,
    unbind: u
  };
};
pw.createSensor = eLe;
Object.defineProperty(hw, "__esModule", {
  value: !0
});
hw.createSensor = void 0;
var tLe = fw, rLe = pw, nLe = typeof ResizeObserver < "u" ? rLe.createSensor : tLe.createSensor;
hw.createSensor = nLe;
Object.defineProperty(kl, "__esModule", {
  value: !0
});
kl.removeSensor = kl.getSensor = kl.Sensors = void 0;
var iLe = aLe(HU), oLe = hw, vT = qa;
function aLe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Sh = {};
kl.Sensors = Sh;
function zU(e) {
  e && Sh[e] && delete Sh[e];
}
var sLe = function(t) {
  var r = t.getAttribute(vT.SizeSensorId);
  if (r && Sh[r])
    return Sh[r];
  var n = (0, iLe.default)();
  t.setAttribute(vT.SizeSensorId, n);
  var i = (0, oLe.createSensor)(t, function() {
    return zU(n);
  });
  return Sh[n] = i, i;
};
kl.getSensor = sLe;
var lLe = function(t) {
  var r = t.element.getAttribute(vT.SizeSensorId);
  t.destroy(), zU(r);
};
kl.removeSensor = lLe;
Object.defineProperty(yc, "__esModule", {
  value: !0
});
yc.ver = WU = yc.clear = $U = yc.bind = void 0;
var mT = kl, uLe = function(t, r) {
  var n = (0, mT.getSensor)(t);
  return n.bind(r), function() {
    n.unbind(r);
  };
}, $U = yc.bind = uLe, cLe = function(t) {
  var r = (0, mT.getSensor)(t);
  (0, mT.removeSensor)(r);
}, WU = yc.clear = cLe, dLe = "1.0.2";
yc.ver = dLe;
function wG(e, t) {
  var r = {};
  return t.forEach(function(n) {
    r[n] = e[n];
  }), r;
}
function Hx(e) {
  return typeof e == "function";
}
function hLe(e) {
  return typeof e == "string";
}
var fLe = function e(t, r) {
  if (t === r) return !0;
  if (t && r && typeof t == "object" && typeof r == "object") {
    if (t.constructor !== r.constructor) return !1;
    var n, i, o;
    if (Array.isArray(t)) {
      if (n = t.length, n != r.length) return !1;
      for (i = n; i-- !== 0; )
        if (!e(t[i], r[i])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === r.source && t.flags === r.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === r.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === r.toString();
    if (o = Object.keys(t), n = o.length, n !== Object.keys(r).length) return !1;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(r, o[i])) return !1;
    for (i = n; i-- !== 0; ) {
      var a = o[i];
      if (!e(t[a], r[a])) return !1;
    }
    return !0;
  }
  return t !== t && r !== r;
};
const Gd = /* @__PURE__ */ Uh(fLe);
var pLe = (
  /** @class */
  function(e) {
    H3(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.echarts = r.echarts, n.ele = null, n.isInitialResize = !0, n;
    }
    return t.prototype.componentDidMount = function() {
      this.renderNewEcharts();
    }, t.prototype.componentDidUpdate = function(r) {
      var n = this.props.shouldSetOption;
      if (!(Hx(n) && !n(r, this.props))) {
        if (!Gd(r.theme, this.props.theme) || !Gd(r.opts, this.props.opts) || !Gd(r.onEvents, this.props.onEvents)) {
          this.dispose(), this.renderNewEcharts();
          return;
        }
        var i = ["option", "notMerge", "lazyUpdate", "showLoading", "loadingOption"];
        Gd(wG(this.props, i), wG(r, i)) || this.updateEChartsOption(), (!Gd(r.style, this.props.style) || !Gd(r.className, this.props.className)) && this.resize();
      }
    }, t.prototype.componentWillUnmount = function() {
      this.dispose();
    }, t.prototype.getEchartsInstance = function() {
      return this.echarts.getInstanceByDom(this.ele) || this.echarts.init(this.ele, this.props.theme, this.props.opts);
    }, t.prototype.dispose = function() {
      if (this.ele) {
        try {
          WU(this.ele);
        } catch (r) {
          console.warn(r);
        }
        this.echarts.dispose(this.ele);
      }
    }, t.prototype.renderNewEcharts = function() {
      var r = this, n = this.props, i = n.onEvents, o = n.onChartReady, a = this.updateEChartsOption();
      this.bindEvents(a, i || {}), Hx(o) && o(a), this.ele && $U(this.ele, function() {
        r.resize();
      });
    }, t.prototype.bindEvents = function(r, n) {
      function i(a, s) {
        hLe(a) && Hx(s) && r.on(a, function(l) {
          s(l, r);
        });
      }
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && i(o, n[o]);
    }, t.prototype.updateEChartsOption = function() {
      var r = this.props, n = r.option, i = r.notMerge, o = i === void 0 ? !1 : i, a = r.lazyUpdate, s = a === void 0 ? !1 : a, l = r.showLoading, u = r.loadingOption, c = u === void 0 ? null : u, d = this.getEchartsInstance();
      return d.setOption(n, o, s), l ? d.showLoading(c) : d.hideLoading(), d;
    }, t.prototype.resize = function() {
      var r = this.getEchartsInstance();
      if (!this.isInitialResize)
        try {
          r.resize();
        } catch (n) {
          console.warn(n);
        }
      this.isInitialResize = !1;
    }, t.prototype.render = function() {
      var r = this, n = this.props, i = n.style, o = n.className, a = o === void 0 ? "" : o, s = RR({ height: 300 }, i);
      return H.createElement("div", { ref: function(l) {
        r.ele = l;
      }, style: s, className: "echarts-for-react " + a });
    }, t;
  }(rq)
), jU = (
  /** @class */
  function(e) {
    H3(t, e);
    function t(r) {
      var n = e.call(this, r) || this;
      return n.echarts = WFe, n;
    }
    return t;
  }(pLe)
);
Li.extend(s8);
function zx(e, t) {
  var s;
  const r = `Overall Conversion (${((s = t == null ? void 0 : t.conversion) == null ? void 0 : s.criteria) || "Uniques"})`;
  let n = `${e != null && e.cohort ? e != null && e.cohort_value ? `${e.cohort}` : `Not in ${e.cohort}` : (e == null ? void 0 : e.value) === "$all" ? r : e.value}`;
  const i = e != null && e.cohort ? e.cohort_value ? `${e.cohort}` : `Not in ${e.cohort}` : "", o = [...(e == null ? void 0 : e.dimensions) ?? []], a = o != null && o.length ? o.map((l) => `${l.name} is ${l.value}`).join(" & ") : "";
  return (i || a) && (n = `${i}${i && a ? ", " : ""}${a}`), { conversionCriteriaLabel: r, seriesNameToGroupBy: n };
}
const gLe = ({
  eventName: e,
  eventIndex: t,
  columnFields: r,
  funnelsConfiguration: n
}) => {
  var s, l, u, c;
  const i = "////", o = (n == null ? void 0 : n.steps) || [];
  if (r) {
    const d = /* @__PURE__ */ new Set(), h = {};
    return r.forEach((f, p) => {
      const g = o.findIndex(
        (v, m) => !d.has(m) && v.name === f
      );
      g !== -1 && (h[p] = o[g].label, d.add(g));
    }), (s = h[t]) == null ? void 0 : s.split(i)[0];
  }
  return ((l = o[t]) == null ? void 0 : l.name) === e && ((c = (u = o[t]) == null ? void 0 : u.label) == null ? void 0 : c.split(i)[0]) || e;
};
function vLe({
  chartData: e,
  queryConfiguration: t,
  themeColors: r,
  themeMode: n
}) {
  var s;
  const i = t.steps.map((l) => l.name).join(" -> "), o = e.reduce((l, u) => {
    var h;
    let { seriesNameToGroupBy: c, conversionCriteriaLabel: d } = zx(
      u,
      t
    );
    return c === "<nil>" && (c = d), [
      ...l,
      {
        data: [],
        type: "bar",
        zlevel: 1,
        emphasis: {
          focus: "series"
        },
        stack: `conversion_funnel_${c}_${u.value}`,
        name: c,
        label: u.dimension !== "$all" || (h = e[0]) != null && h.cohort ? {} : {
          show: !(u != null && u.dimensions),
          formatter: function({ data: f }) {
            const { conversionNumber: p, conversionPercentage: g } = f || {};
            return [
              `{percentage|${Number(g).toFixed(2)}%}`,
              `{number|${p}}`
            ].join(`
`);
          },
          position: "top",
          align: "center",
          rich: {
            percentage: {
              color: r["--secondary-text"],
              fontWeight: 600,
              lineHeight: 18,
              fontSize: 14
            },
            number: {
              color: r["--secondary-text"],
              fontWeight: 500,
              lineHeight: 14,
              fontSize: 11
            }
          }
        }
      },
      {
        name: c,
        data: [],
        type: "bar",
        stack: `conversion_funnel_${c}_${u.value}`,
        itemStyle: {
          color: "rgba(66,56,202, .1)"
        }
      }
    ];
  }, []), a = {
    grid: {
      left: 50,
      top: 95,
      right: 30,
      bottom: 30
    },
    title: {
      show: !0,
      text: `Funnels: ${i}`,
      left: 20,
      textStyle: {
        fontFamily: "HousewareFont",
        fontSize: 15,
        fontWeight: "bold",
        color: r["--primary-text"]
      }
    },
    xAxis: {
      type: "category",
      data: [],
      axisLabel: {
        interval: 0,
        width: 300,
        align: "center",
        overflow: "break",
        color: r["--secondary-text"],
        hideOverlap: !0,
        formatter: (l) => l.split("_").join(" "),
        fontFamily: "ChartsFont",
        fontSize: 10
      },
      axisLine: {
        lineStyle: {
          color: r["--border"]
        }
      }
    },
    yAxis: {
      type: "value",
      position: "left",
      alignTicks: !0,
      axisLine: {
        show: !0,
        lineStyle: {
          color: r["--border"]
        }
      },
      axisLabel: {
        color: r["--secondary-text"],
        fontFamily: "ChartsFont",
        fontSize: 10
      },
      splitLine: {
        lineStyle: {
          color: r["--border"],
          width: 0.4
        }
      },
      max: 100
    },
    series: o,
    legend: {
      data: o.map((l) => l.name),
      top: 40,
      left: 20,
      color: r["--secondary-text"],
      icon: "circle",
      textStyle: {
        color: r["--primary-text"],
        fontSize: 12,
        fontWeight: "normal",
        fontFamily: "HousewareFont"
      },
      inActiveColor: "red"
    },
    toolbox: {
      feature: {
        saveAsImage: {
          title: "Download chart",
          name: `Funnel Chart - ${i}`,
          show: !0,
          icon: `image://chart-download-${n}-mode.png`
        }
      }
    },
    tooltip: {
      trigger: "item",
      confine: !0,
      order: "valueDesc",
      backgroundColor: r["--foreground"],
      borderColor: r["--border"],
      textStyle: {
        color: r["--secondary-text"],
        fontFamily: "HousewareFont"
      },
      formatter: function({ data: l }) {
        const {
          conversionNumber: u,
          conversionPercentage: c,
          dropOffPercentage: d,
          dropOffNumber: h,
          name: f,
          seriesLabel: p,
          config: g
        } = l || {}, v = (Number(u || h) / Number(c || d) * 100).toLocaleString();
        let m = ` <b>${f}</b>`;
        return g.start_date && (m = `${m} (from ${Li(g == null ? void 0 : g.start_date).format(
          "Do MMM YY"
        )}`), g.end_date && (m = `${m} to ${Li(g == null ? void 0 : g.end_date).format(
          "Do MMM YY"
        )})`), `
          ${m}
          </br>
          <br />
          ${p}
          </br>
          ${Number(c).toFixed(
          2
        )}% (${u.toLocaleString()} of ${v}) converted
          </br>
          ${Number(d).toFixed(
          2
        )}% (${h.toLocaleString()} of ${v}) drop-off
          `;
      }
    }
  };
  for (let l = 0; l < e[0].steps.length; l++) {
    e.forEach((c, d) => {
      const h = c.steps[l], f = h.prev_step_conversion_percentage, p = l > 0 ? 100 - f : 0, g = l > 0 ? c.steps[l - 1].value - h.value : 0;
      a.series[2 * d].data.push({
        value: h.value / e[d].steps[0].value * 100,
        name: h.event_name,
        config: t,
        seriesLabel: zx(c, t).seriesNameToGroupBy,
        dimensions: c.dimensions,
        cohort: {
          cohort_uuid: c == null ? void 0 : c.cohort_uuid,
          cohort_value: c == null ? void 0 : c.cohort_value
        },
        conversionNumber: h.value,
        dropOffPercentage: p,
        dropOffNumber: g,
        conversionPercentage: f,
        seriesType: "converted",
        stepIndex: l
      }), a.series[2 * d + 1].data.push({
        value: g / e[d].steps[0].value * 100,
        name: h.event_name,
        config: t,
        seriesLabel: zx(c, t).seriesNameToGroupBy,
        dimensions: c.dimensions,
        dropOffNumber: g,
        dropOffPercentage: p,
        conversionNumber: h.value,
        conversionPercentage: f,
        seriesType: "dropped off",
        stepIndex: l
      });
    });
    const u = gLe({
      eventName: e[0].steps[l].event_name,
      eventIndex: l,
      funnelsConfiguration: t
    });
    (s = a == null ? void 0 : a.xAxis) == null || s.data.push(u);
  }
  return a;
}
function mLe({
  chartResponse: e,
  queryConfiguration: t
}) {
  const { themeColors: r, currentTheme: n } = Cv(), i = vLe({
    chartData: e == null ? void 0 : e.data,
    queryConfiguration: t,
    themeColors: r,
    themeMode: n
  });
  return /* @__PURE__ */ ce.jsxs(
    fr,
    {
      vertical: !0,
      gap: 16,
      style: {
        width: "100%"
      },
      children: [
        /* @__PURE__ */ ce.jsx(
          Lo,
          {
            size: "small",
            style: {
              backgroundColor: "var(--background)",
              width: "100%"
            },
            children: /* @__PURE__ */ ce.jsx(
              jU,
              {
                style: { height: "40vh", width: "100%" },
                option: i,
                theme: {
                  color: r["--chart-colors"]
                },
                notMerge: !0,
                opts: { renderer: "canvas" }
              }
            )
          }
        ),
        /* @__PURE__ */ ce.jsx(Ur, { children: /* @__PURE__ */ ce.jsx(CS, { children: e.summary }) })
      ]
    }
  );
}
Li.extend(s8);
function yLe({
  chartData: e,
  queryConfiguration: t,
  themeColors: r,
  themeMode: n
}) {
  var g, v;
  const i = t.events.map((m) => m.name).join(" , "), o = t == null ? void 0 : t.breakdown, a = o != null && o.dimension ? {
    name: o.dimension,
    is_event_property: o == null ? void 0 : o.is_event_property,
    type: "dimension"
  } : null, s = {};
  (g = t == null ? void 0 : t.events) == null || g.forEach((m) => {
    s[m.label] = m.measure || "uniques";
  });
  const l = {};
  e.map((m) => {
    l[m.period] = !0;
  });
  const u = Object.keys(l).sort((m, y) => Li(m).valueOf() - Li(y).valueOf()).reduce((m, y) => (m[y] = l[y], m), {}), c = {
    data: {},
    type: "line",
    smooth: !0,
    name: ""
  }, d = {};
  (a == null ? void 0 : a.name) === void 0 ? e.forEach((m) => {
    const [y] = typeof (m == null ? void 0 : m.label) == "string" ? m.label.split(":") : [], C = Number(m.measure), S = Number.isInteger(C) ? C : C.toFixed(2), b = m.period;
    if (d[y]) {
      const w = "";
      d[y].data[b] = {
        value: S,
        unit: w
      };
    } else {
      const w = `${y} (${m.label})`, x = "";
      d[y] = {
        ...c,
        lineStyle: {
          type: "solid"
        },
        name: w,
        data: {},
        yAxisIndex: 0,
        unit: x
      }, d[y].data[b] = {
        value: S,
        unit: x
      };
    }
  }) : e.forEach((m) => {
    const y = m.label, C = Number(m.measure), S = Number.isInteger(C) ? C : C.toFixed(2), b = m[a == null ? void 0 : a.name], w = `${y} / ${b}`, x = m.period;
    if (d[w]) {
      let E = "";
      d[w].data[x] = {
        value: S,
        unit: E,
        breakdown: {
          ...a,
          value: b
        }
      };
    } else {
      let E = "";
      const R = `${w} (${s[y]})`;
      d[w] = {
        ...c,
        lineStyle: {
          type: "solid"
        },
        name: R,
        data: {},
        yAxisIndex: 0
      }, d[w].data[x] = {
        value: S,
        unit: E,
        breakdown: {
          ...a,
          value: a.type === "cohort" ? m.cohort : b
        }
      };
    }
  });
  for (const m in d) {
    const y = d[m], C = (v = Object.keys(u)) == null ? void 0 : v.map(
      (S) => y.data[S] || {
        value: 0,
        unit: "",
        ...y.originalSeriesName && {
          seriesLabel: y.originalSeriesName
        }
      }
    );
    d[m].data = C;
  }
  const h = Object.values(d), f = Object.keys(u);
  return {
    grid: {
      left: 50,
      top: 95,
      right: 30,
      bottom: 30
    },
    title: {
      show: !0,
      text: `Trends: ${i}`,
      left: 20,
      textStyle: {
        fontFamily: "HousewareFont",
        fontSize: 15,
        fontWeight: "bold",
        color: r["--primary-text"]
      }
    },
    xAxis: {
      type: "category",
      data: f,
      axisLabel: {
        width: 200,
        align: "center",
        overflow: "break",
        hideOverlap: !0,
        fontFamily: "ChartsFont",
        fontSize: 10,
        cursor: "pointer",
        color: r["--secondary-text"],
        formatter: (m) => {
          var C;
          return bG(
            m,
            (C = t == null ? void 0 : t.time) == null ? void 0 : C.granularity,
            !1
          );
        }
      },
      axisLine: {
        lineStyle: {
          color: r["--border"]
        }
      }
    },
    yAxis: [
      {
        name: "",
        type: "value",
        position: "left",
        alignTicks: !0,
        nameTextStyle: {
          fontWeight: "bolder"
        },
        axisLine: {
          show: !0,
          lineStyle: {
            color: r["--border"]
          }
        },
        axisLabel: {
          hideOverlap: !0,
          color: r["--secondary-text"],
          fontFamily: "ChartsFont",
          fontSize: 10
        },
        splitLine: {
          lineStyle: {
            color: r["--border"],
            width: 0.4
          }
        }
      }
    ],
    legend: {
      data: h.map((m) => m.name),
      top: 40,
      left: 20,
      color: r["--primary-text"],
      icon: "circle",
      textStyle: {
        color: r["--secondary-text"],
        fontFamily: "HousewareFont",
        fontSize: 12,
        fontWeight: "normal"
      }
    },
    toolbox: {
      feature: {
        saveAsImage: {
          title: "Download chart",
          name: `Trends Chart - ${i}`,
          show: !0,
          icon: `image://chart-download-${n}-mode.png`
        }
      }
    },
    series: [...h],
    tooltip: {
      trigger: "axis",
      confine: !0,
      order: "valueDesc",
      backgroundColor: r["--foreground"],
      borderColor: r["--border"],
      textStyle: {
        color: r["--secondary-text"],
        fontFamily: "HousewareFont"
      },
      formatter: (m) => {
        var S;
        let y = "<div>";
        y += `<div><strong>${CLe(
          m[0].name,
          (S = t == null ? void 0 : t.time) == null ? void 0 : S.granularity
        )}</strong></div><br />`;
        const C = m.filter(
          (b, w, x) => w === x.findIndex(
            (E) => {
              var R, _;
              return E.seriesName === b.seriesName && E.value === b.value && ((R = E.data) == null ? void 0 : R.period) === ((_ = b.data) == null ? void 0 : _.period);
            }
          )
        );
        return y += C.map(
          (b) => {
            var w, x, E;
            return `<div style="display:flex; align-items:center"><div style="height:1rem; width:1rem; border-radius:.5rem; background:${b.color}"></div> &nbsp;${(w = b.data) != null && w.prevPeriod ? `(${bG(
              b.data.prevPeriod,
              ((x = t == null ? void 0 : t.time) == null ? void 0 : x.granularity) === "hour" ? "day" : (E = t == null ? void 0 : t.time) == null ? void 0 : E.granularity,
              !1
            )}):  ${b.data.seriesLabel}` : b.seriesName}:  &nbsp; &nbsp; &nbsp;<strong>${Number(b.value)}${b.data.unit ? b.data.unit : ""}</strong></div>`;
          }
        ).join(""), y += "</div>", y;
      }
    },
    axisPointer: {
      type: "line"
    }
  };
}
const Np = {
  hour: "h:mm A, Do MMM",
  day: "Do MMM",
  week: "Do MMM YYYY",
  month: "MMM YYYY",
  quarter: "[Q]Q-Y",
  year: "YYYY",
  all_time: ""
};
function bG(e, t, r = !0) {
  return t === "week" ? `${Li(e).format(
    Np[t]
  )} - ${Li(e).add(6, "day").format(Np[t])}` : r ? Li(e).format(Np[t]).replace(/ /g, `
`) : Li(e).format(Np[t]);
}
function CLe(e, t) {
  return t === "week" ? `${Li(e).format("[Week] WW, Do MMM YYYY")} - ${Li(e).add(6, "day").format("Do MMM YYYY")}` : t === "day" ? Li(e).format("Do MMM YYYY") : Li(e).format(Np[t]);
}
function SLe({
  chartResponse: e,
  queryConfiguration: t
}) {
  const { themeColors: r, currentTheme: n } = Cv(), i = yLe({
    chartData: (e == null ? void 0 : e.data) ?? [],
    queryConfiguration: t ?? {},
    themeColors: r,
    themeMode: n
  });
  return /* @__PURE__ */ ce.jsxs(
    fr,
    {
      vertical: !0,
      gap: 16,
      style: {
        width: "100%"
      },
      children: [
        /* @__PURE__ */ ce.jsx(
          Lo,
          {
            size: "small",
            style: {
              backgroundColor: "var(--background)",
              width: "100%"
            },
            children: /* @__PURE__ */ ce.jsx(
              jU,
              {
                style: { height: "40vh", width: "100%" },
                option: i,
                theme: {
                  color: r["--chart-colors"]
                },
                notMerge: !0,
                opts: { renderer: "canvas" }
              }
            )
          }
        ),
        /* @__PURE__ */ ce.jsx(Ur, { children: /* @__PURE__ */ ce.jsx(CS, { children: e.summary }) })
      ]
    }
  );
}
function wLe({
  index: e,
  messages: t,
  handleRegenerateResponse: r,
  hideActionCardItems: n = [],
  customMessageActionCardItem: i = []
}) {
  var c;
  const o = (c = t[e]) == null ? void 0 : c.content, [a, s] = Ee(!1), l = () => {
    const d = (() => {
      var p, g, v;
      const h = (p = o == null ? void 0 : o.query_response) == null ? void 0 : p.type, f = (g = o == null ? void 0 : o.query_response) == null ? void 0 : g.data;
      switch (h) {
        case "text":
          return f;
        case "trend":
        case "funnel":
          return ((v = o == null ? void 0 : o.query_response) == null ? void 0 : v.summary) || "";
        default:
          return "I am not sure how to respond to that, can you please try again?";
      }
    })();
    navigator.clipboard.writeText(d), s(!0), setTimeout(() => {
      s(!1);
    }, 2e3);
  }, u = ct(
    () => ({
      copy: /* @__PURE__ */ ce.jsx(
        Qn,
        {
          size: "small",
          onClick: l,
          type: "text",
          icon: a ? /* @__PURE__ */ ce.jsx(pH, { size: "0.7rem" }) : /* @__PURE__ */ ce.jsx(gH, { size: "0.7rem" }),
          style: {
            fontSize: "0.7rem",
            color: "var(--secondary-text)"
          },
          children: "Copy"
        }
      ),
      regenerate: /* @__PURE__ */ ce.jsx(
        Qn,
        {
          size: "small",
          onClick: () => {
            var d;
            r(
              ((d = t[t.length - 2]) == null ? void 0 : d.content) || "",
              !0
            );
          },
          type: "text",
          icon: /* @__PURE__ */ ce.jsx(fH, { size: "0.7rem" }),
          style: {
            fontSize: "0.7rem",
            color: "var(--secondary-text)"
          },
          children: "Regenerate"
        }
      )
    }),
    [a, r, t]
  );
  return /* @__PURE__ */ ce.jsx(
    Lo,
    {
      className: "ai-message-actions",
      size: "small",
      style: {
        width: "max-content",
        backgroundColor: "var(--background)",
        alignSelf: "flex-end"
      },
      styles: {
        body: {
          padding: 3
        }
      },
      children: /* @__PURE__ */ ce.jsxs(fr, { children: [
        Object.keys(u).map(
          (d) => !n.includes(d) && /* @__PURE__ */ ce.jsx(nq, { children: u[d] }, d)
        ),
        i
      ] })
    }
  );
}
function bLe({
  index: e,
  messages: t,
  showMessageActionCard: r,
  hideActionCardItems: n = [],
  handleRegenerateResponse: i,
  customMessageComponent: o,
  customMessageActionCardItem: a
}) {
  var f;
  const s = (f = t[e]) == null ? void 0 : f.content, u = (t == null ? void 0 : t.length) - 1 === e && r, c = o == null ? void 0 : o.component, d = ({
    messages: p,
    index: g,
    handleRegenerateResponse: v
  }) => c ? /* @__PURE__ */ ce.jsx(
    c,
    {
      messages: p,
      index: g,
      handleSendFollowupMessage: v
    }
  ) : null, h = () => {
    var m, y;
    const p = (m = s == null ? void 0 : s.query_response) == null ? void 0 : m.type, g = (y = s == null ? void 0 : s.query_response) == null ? void 0 : y.data, v = s == null ? void 0 : s.query_configuration;
    switch (p) {
      case "text":
        return /* @__PURE__ */ ce.jsx(Ur, { children: /* @__PURE__ */ ce.jsx(CS, { children: g }) });
      case "trend":
        return /* @__PURE__ */ ce.jsx(
          SLe,
          {
            chartResponse: s.query_response,
            queryConfiguration: v
          }
        );
      case "funnel":
        return /* @__PURE__ */ ce.jsx(
          mLe,
          {
            chartResponse: s.query_response,
            queryConfiguration: v
          }
        );
      default:
        return /* @__PURE__ */ ce.jsx(Ur, { children: "I am not sure how to respond to that, can you please try again?" });
    }
  };
  return /* @__PURE__ */ ce.jsxs(
    fr,
    {
      style: { width: "90%" },
      align: "flex-start",
      gap: 8,
      className: "ai-message-wrapper",
      children: [
        /* @__PURE__ */ ce.jsx(
          yv,
          {
            src: "/ai-icon.svg",
            height: 40,
            width: 40,
            style: {
              height: "2rem",
              width: "2rem"
            },
            preview: !1
          }
        ),
        /* @__PURE__ */ ce.jsxs(
          fr,
          {
            vertical: !0,
            style: {
              width: "100%"
            },
            gap: 14,
            children: [
              c ? d({
                messages: t,
                index: e,
                handleRegenerateResponse: i
              }) : h(),
              u && /* @__PURE__ */ ce.jsx(
                wLe,
                {
                  index: e,
                  messages: t,
                  hideActionCardItems: n,
                  handleRegenerateResponse: i,
                  customMessageActionCardItem: a
                },
                e
              )
            ]
          }
        )
      ]
    }
  );
}
function xLe({
  messages: e,
  index: t,
  customMessageComponent: r
}) {
  var o;
  const n = r == null ? void 0 : r.component, i = ({
    messages: a,
    index: s
  }) => n ? /* @__PURE__ */ ce.jsx(n, { messages: a, index: s }) : null;
  return /* @__PURE__ */ ce.jsx(fr, { style: { width: "100%" }, justify: "flex-end", gap: 12, children: /* @__PURE__ */ ce.jsx(
    fr,
    {
      vertical: !0,
      style: {
        minWidth: "30%"
      },
      gap: 2,
      align: "flex-end",
      children: /* @__PURE__ */ ce.jsx(
        Lo,
        {
          size: "small",
          style: {
            borderTopRightRadius: 0
          },
          children: n ? i({
            messages: e,
            index: t
          }) : /* @__PURE__ */ ce.jsx(Ur, { children: (o = e[t]) == null ? void 0 : o.content })
        }
      )
    }
  ) });
}
function E3e({
  messages: e,
  handleSendFollowupMessage: t,
  isMessageLoading: r,
  setMessages: n,
  showMessageActionCard: i = !0,
  hideActionCardItems: o = [],
  customMessageComponent: a,
  customMessageActionCardItem: s
}) {
  const [l, u] = Ee(""), c = le(null);
  It(() => {
    const h = c.current;
    h && (h.scrollTop = h.scrollHeight);
  }, [e]);
  const d = e.length > 1 && r || e.length === 1;
  return /* @__PURE__ */ ce.jsxs(
    fr,
    {
      style: {
        height: "100vh",
        width: "100vw",
        padding: 16,
        overflow: "hidden"
      },
      vertical: !0,
      align: "center",
      justify: "flex-start",
      children: [
        /* @__PURE__ */ ce.jsx(
          TP,
          {
            title: "You'll lose your current chat history.",
            description: "Are you sure you want to start a new chat?",
            placement: "bottomLeft",
            okText: "Yes",
            cancelText: "No",
            onConfirm: () => {
              n([]);
            },
            children: /* @__PURE__ */ ce.jsx(
              Qn,
              {
                type: "primary",
                style: {
                  position: "absolute",
                  top: 16,
                  right: 32
                },
                children: "Start new chat"
              }
            )
          }
        ),
        /* @__PURE__ */ ce.jsxs(
          fr,
          {
            ref: c,
            vertical: !0,
            style: {
              width: "58vw",
              height: "86vh",
              overflowY: "scroll",
              overflowX: "hidden",
              padding: "0 24px 10vh",
              marginTop: "4vh",
              position: "relative"
            },
            align: "flex-start",
            rootClassName: "chat-container",
            gap: 48,
            children: [
              e.filter(Boolean).map((h, f) => ((h.type === "ai" || h.type === "human") && (a == null || a.type, h.type), null)),
              d && /* @__PURE__ */ ce.jsx($ue, {})
            ]
          }
        ),
        /* @__PURE__ */ ce.jsx(
          J8,
          {
            inputRef: null,
            userQuery: l,
            setUserQuery: u,
            handleSendMessage: () => {
              t(l), u("");
            },
            placeholder: "Follow up with your question here...",
            isFollowupDisabled: d
          }
        )
      ]
    }
  );
}
var wf = class {
  constructor() {
    this.allSyncListeners = /* @__PURE__ */ new Map(), this.allAsyncListeners = /* @__PURE__ */ new Map(), this.globalSyncListeners = /* @__PURE__ */ new Set(), this.globalAsyncListeners = /* @__PURE__ */ new Set(), this.asyncFunctionsQueue = [], this.scheduled = !1, this.firedEvents = {};
  }
  setFrameworkOverrides(e) {
    this.frameworkOverrides = e;
  }
  getListeners(e, t, r) {
    const n = t ? this.allAsyncListeners : this.allSyncListeners;
    let i = n.get(e);
    return !i && r && (i = /* @__PURE__ */ new Set(), n.set(e, i)), i;
  }
  noRegisteredListenersExist() {
    return this.allSyncListeners.size === 0 && this.allAsyncListeners.size === 0 && this.globalSyncListeners.size === 0 && this.globalAsyncListeners.size === 0;
  }
  addEventListener(e, t, r = !1) {
    this.getListeners(e, r, !0).add(t);
  }
  removeEventListener(e, t, r = !1) {
    const n = this.getListeners(e, r, !1);
    n && (n.delete(t), n.size === 0 && (r ? this.allAsyncListeners : this.allSyncListeners).delete(e));
  }
  addGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).add(e);
  }
  removeGlobalListener(e, t = !1) {
    (t ? this.globalAsyncListeners : this.globalSyncListeners).delete(e);
  }
  dispatchEvent(e) {
    const t = e;
    this.dispatchToListeners(t, !0), this.dispatchToListeners(t, !1), this.firedEvents[t.type] = !0;
  }
  dispatchEventOnce(e) {
    this.firedEvents[e.type] || this.dispatchEvent(e);
  }
  dispatchToListeners(e, t) {
    const r = e.type;
    if (t && "event" in e) {
      const s = e.event;
      s instanceof Event && (e.eventPath = s.composedPath());
    }
    const n = (s, l) => s.forEach((u) => {
      if (!l.has(u))
        return;
      const c = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => u(e)) : () => u(e);
      t ? this.dispatchAsync(c) : c();
    }), i = this.getListeners(r, t, !1) ?? /* @__PURE__ */ new Set(), o = new Set(i);
    o.size > 0 && n(o, i), new Set(
      t ? this.globalAsyncListeners : this.globalSyncListeners
    ).forEach((s) => {
      const l = this.frameworkOverrides ? () => this.frameworkOverrides.wrapIncoming(() => s(r, e)) : () => s(r, e);
      t ? this.dispatchAsync(l) : l();
    });
  }
  // this gets called inside the grid's thread, for each event that it
  // wants to set async. the grid then batches the events into one setTimeout()
  // because setTimeout() is an expensive operation. ideally we would have
  // each event in it's own setTimeout(), but we batch for performance.
  dispatchAsync(e) {
    if (this.asyncFunctionsQueue.push(e), !this.scheduled) {
      const t = () => {
        window.setTimeout(this.flushAsyncQueue.bind(this), 0);
      };
      this.frameworkOverrides ? this.frameworkOverrides.wrapIncoming(t) : t(), this.scheduled = !0;
    }
  }
  // this happens in the next VM turn only, and empties the queue of events
  flushAsyncQueue() {
    this.scheduled = !1;
    const e = this.asyncFunctionsQueue.slice();
    this.asyncFunctionsQueue = [], e.forEach((t) => t());
  }
};
function Jt(e) {
  if (!(!e || !e.length))
    return e[e.length - 1];
}
function Jc(e, t, r) {
  return e == null && t == null ? !0 : e != null && t != null && e.length === t.length && e.every((n, i) => r ? r(n, t[i]) : t[i] === n);
}
function ELe(e) {
  return e.sort((t, r) => t - r);
}
function UU(e, t) {
  const r = e.indexOf(t);
  r >= 0 && (e[r] = e[e.length - 1], e.pop());
}
function gi(e, t) {
  const r = e.indexOf(t);
  r >= 0 && e.splice(r, 1);
}
function RLe(e, t) {
  for (let r = 0; r < t.length; r++)
    UU(e, t[r]);
}
function _Le(e, t) {
  for (let r = 0; r < t.length; r++)
    gi(e, t[r]);
}
function BC(e, t, r) {
  e.splice(r, 0, t);
}
function KU(e, t, r) {
  _Le(e, t), t.slice().reverse().forEach((n) => BC(e, n, r));
}
function Cc(e, t) {
  return e.indexOf(t) > -1;
}
function TLe(e) {
  return [].concat.apply([], e);
}
function xG(e, t) {
  t == null || e == null || t.forEach((r) => e.push(r));
}
var YU = "__ag_Grid_Stop_Propagation", PLe = ["touchstart", "touchend", "touchmove", "touchcancel", "scroll"], $x = {};
function zh(e) {
  e[YU] = !0;
}
function Vl(e) {
  return e[YU] === !0;
}
var qU = /* @__PURE__ */ (() => {
  const e = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  return (r) => {
    if (typeof $x[r] == "boolean")
      return $x[r];
    const n = document.createElement(e[r] || "div");
    return r = "on" + r, $x[r] = r in n;
  };
})();
function yT(e, t, r) {
  let n = t;
  for (; n; ) {
    const i = e.getDomData(n, r);
    if (i)
      return i;
    n = n.parentElement;
  }
  return null;
}
function MLe(e, t) {
  return !t || !e ? !1 : ALe(t).indexOf(e) >= 0;
}
function DLe(e) {
  const t = [];
  let r = e.target;
  for (; r; )
    t.push(r), r = r.parentElement;
  return t;
}
function ALe(e) {
  const t = e;
  return t.path ? t.path : t.composedPath ? t.composedPath() : DLe(t);
}
function ILe(e, t, r, n) {
  const o = Cc(PLe, r) ? { passive: !0 } : void 0;
  e && e.addEventListener && e.addEventListener(t, r, n, o);
}
var he = class {
  constructor() {
    this.destroyFunctions = [], this.destroyed = !1, this.__v_skip = !0, this.propertyListenerId = 0, this.lastChangeSetIdLookup = {}, this.isAlive = () => !this.destroyed;
  }
  preWireBeans(e) {
    this.gridId = e.context.getGridId(), this.frameworkOverrides = e.frameworkOverrides, this.stubContext = e.context, this.eventService = e.eventService, this.gos = e.gos, this.localeService = e.localeService;
  }
  // this was a test constructor niall built, when active, it prints after 5 seconds all beans/components that are
  // not destroyed. to use, create a new grid, then api.destroy() before 5 seconds. then anything that gets printed
  // points to a bean or component that was not properly disposed of.
  // constructor() {
  //     setTimeout(()=> {
  //         if (this.isAlive()) {
  //             let prototype: any = Object.getPrototypeOf(this);
  //             const constructor: any = prototype.constructor;
  //             const constructorString = constructor.toString();
  //             const beanName = constructorString.substring(9, constructorString.indexOf("("));
  //             console.log('is alive ' + beanName);
  //         }
  //     }, 5000);
  // }
  // CellComp and GridComp and override this because they get the FrameworkOverrides from the Beans bean
  getFrameworkOverrides() {
    return this.frameworkOverrides;
  }
  destroy() {
    for (let e = 0; e < this.destroyFunctions.length; e++)
      this.destroyFunctions[e]();
    this.destroyFunctions.length = 0, this.destroyed = !0, this.dispatchLocalEvent({ type: "destroyed" });
  }
  // The typing of AgEventListener<any, any, any> is not ideal, but it's the best we can do at the moment to enable
  // eventService to have the best typing at the expense of BeanStub local events
  /** Add a local event listener against this BeanStub */
  addEventListener(e, t) {
    this.localEventService || (this.localEventService = new wf()), this.localEventService.addEventListener(e, t);
  }
  /** Remove a local event listener from this BeanStub */
  removeEventListener(e, t) {
    this.localEventService && this.localEventService.removeEventListener(e, t);
  }
  dispatchLocalEvent(e) {
    this.localEventService && this.localEventService.dispatchEvent(e);
  }
  addManagedElementListeners(e, t) {
    return this._setupListeners(e, t);
  }
  addManagedEventListeners(e) {
    return this._setupListeners(this.eventService, e);
  }
  addManagedListeners(e, t) {
    return this._setupListeners(e, t);
  }
  _setupListeners(e, t) {
    const r = [];
    for (const n in t) {
      const i = t[n];
      i && r.push(this._setupListener(e, n, i));
    }
    return r;
  }
  _setupListener(e, t, r) {
    if (this.destroyed)
      return () => null;
    e instanceof HTMLElement ? ILe(this.getFrameworkOverrides(), e, t, r) : e.addEventListener(t, r);
    const n = () => (e.removeEventListener(t, r), null);
    return this.destroyFunctions.push(n), () => (n(), this.destroyFunctions = this.destroyFunctions.filter((i) => i !== n), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * However, stores the destroy function in the beanStub so that if this bean
   * is a component the destroy function will be called when the component is destroyed
   * as opposed to being cleaned up only when the GridOptionsService is destroyed.
   */
  setupGridOptionListener(e, t) {
    this.gos.addPropertyEventListener(e, t);
    const r = () => (this.gos.removePropertyEventListener(e, t), null);
    return this.destroyFunctions.push(r), () => (r(), this.destroyFunctions = this.destroyFunctions.filter((n) => n !== r), null);
  }
  /**
   * Setup a managed property listener for the given GridOption property.
   * @param event GridOption property to listen to changes for.
   * @param listener Listener to run when property value changes
   */
  addManagedPropertyListener(e, t) {
    return this.destroyed ? () => null : this.setupGridOptionListener(e, t);
  }
  /**
   * Setup managed property listeners for the given set of GridOption properties.
   * The listener will be run if any of the property changes but will only run once if
   * multiple of the properties change within the same framework lifecycle event.
   * Works on the basis that GridOptionsService updates all properties *before* any property change events are fired.
   * @param events Array of GridOption properties to listen for changes too.
   * @param listener Shared listener to run if any of the properties change
   */
  addManagedPropertyListeners(e, t) {
    if (this.destroyed)
      return;
    const r = e.join("-") + this.propertyListenerId++, n = (i) => {
      if (i.changeSet) {
        if (i.changeSet && i.changeSet.id === this.lastChangeSetIdLookup[r])
          return;
        this.lastChangeSetIdLookup[r] = i.changeSet.id;
      }
      const o = {
        type: "gridPropertyChanged",
        changeSet: i.changeSet,
        source: i.source
      };
      t(o);
    };
    e.forEach((i) => this.setupGridOptionListener(i, n));
  }
  addDestroyFunc(e) {
    this.isAlive() ? this.destroyFunctions.push(e) : e();
  }
  createManagedBean(e, t) {
    const r = this.createBean(e, t);
    return this.addDestroyFunc(this.destroyBean.bind(this, e, t)), r;
  }
  createBean(e, t, r) {
    return (t || this.stubContext).createBean(e, r);
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e, t) {
    return (t || this.stubContext).destroyBean(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e, t) {
    return (t || this.stubContext).destroyBeans(e);
  }
}, fA = class {
  constructor(e) {
    this.frameworkOverrides = e, this.wrappedListeners = /* @__PURE__ */ new Map(), this.wrappedGlobalListeners = /* @__PURE__ */ new Map();
  }
  wrap(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (r) => {
      this.frameworkOverrides.wrapOutgoing(() => e(r));
    }, this.wrappedListeners.set(e, t)), t;
  }
  wrapGlobal(e) {
    let t = e;
    return this.frameworkOverrides.shouldWrapOutgoing && (t = (r, n) => {
      this.frameworkOverrides.wrapOutgoing(() => e(r, n));
    }, this.wrappedGlobalListeners.set(e, t)), t;
  }
  unwrap(e) {
    return this.wrappedListeners.get(e) ?? e;
  }
  unwrapGlobal(e) {
    return this.wrappedGlobalListeners.get(e) ?? e;
  }
};
function Sc(e) {
  return e == null || e === "" ? null : e;
}
function Me(e, t = !1) {
  return e != null && (e !== "" || t);
}
function Zt(e) {
  return !Me(e);
}
function Dn(e) {
  return e == null || e.length === 0;
}
function CT(e) {
  return e != null && typeof e.toString == "function" ? e.toString() : null;
}
function wc(e) {
  if (e === void 0)
    return;
  if (e === null || e === "")
    return null;
  if (typeof e == "number")
    return isNaN(e) ? void 0 : e;
  const t = parseInt(e, 10);
  return isNaN(t) ? void 0 : t;
}
function ST(e) {
  if (e !== void 0)
    return e === null || e === "" ? !1 : wT(e);
}
function wT(e) {
  return typeof e == "boolean" ? e : typeof e == "string" ? e.toUpperCase() === "TRUE" || e == "" : !1;
}
function GC(e, t) {
  const r = e ? JSON.stringify(e) : null, n = t ? JSON.stringify(t) : null;
  return r === n;
}
function FLe(e, t, r = !1) {
  const n = e == null, i = t == null;
  if (e && e.toNumber && (e = e.toNumber()), t && t.toNumber && (t = t.toNumber()), n && i)
    return 0;
  if (n)
    return -1;
  if (i)
    return 1;
  function o(a, s) {
    return a > s ? 1 : a < s ? -1 : 0;
  }
  if (typeof e != "string" || !r)
    return o(e, t);
  try {
    return e.localeCompare(t);
  } catch {
    return o(e, t);
  }
}
function p0(e) {
  if (e instanceof Set || e instanceof Map) {
    const t = [];
    return e.forEach((r) => t.push(r)), t;
  }
  return Object.values(e);
}
var pA = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
function ia(e, t) {
  if (e != null) {
    if (Array.isArray(e)) {
      for (let r = 0; r < e.length; r++)
        t(r.toString(), e[r]);
      return;
    }
    for (const [r, n] of Object.entries(e))
      t(r, n);
  }
}
function ZU(e) {
  const t = {}, r = Object.keys(e);
  for (let n = 0; n < r.length; n++) {
    if (pA.has(r[n]))
      continue;
    const i = r[n], o = e[i];
    t[i] = o;
  }
  return t;
}
function bT(e, t) {
  if (!e)
    return;
  const r = e, n = {};
  return Object.keys(r).forEach((i) => {
    if (t && t.indexOf(i) >= 0 || pA.has(i))
      return;
    const o = r[i];
    ET(o) && o.constructor === Object ? n[i] = bT(o) : n[i] = o;
  }), n;
}
function xT(e) {
  if (!e)
    return [];
  const t = Object;
  if (typeof t.values == "function")
    return t.values(e);
  const r = [];
  for (const n in e)
    e.hasOwnProperty(n) && e.propertyIsEnumerable(n) && r.push(e[n]);
  return r;
}
function To(e, t, r = !0, n = !1) {
  Me(t) && ia(t, (i, o) => {
    if (pA.has(i))
      return;
    let a = e[i];
    a !== o && (n && a == null && o != null && typeof o == "object" && o.constructor === Object && (a = {}, e[i] = a), ET(o) && ET(a) && !Array.isArray(a) ? To(a, o, r, n) : (r || o !== void 0) && (e[i] = o));
  });
}
function ug(e, t, r) {
  if (!t || !e)
    return;
  if (!r)
    return e[t];
  const n = t.split(".");
  let i = e;
  for (let o = 0; o < n.length; o++) {
    if (i == null)
      return;
    i = i[n[o]];
  }
  return i;
}
function ET(e) {
  return typeof e == "object" && e !== null;
}
var LLe = {
  resizable: !0,
  sortable: !0
}, OLe = 0;
function XU() {
  return OLe++;
}
function Zl(e) {
  return e instanceof JU;
}
var QU = 20, JU = class extends he {
  constructor(e, t, r, n) {
    super(), this.isColumn = !0, this.instanceId = XU(), this.autoHeaderHeight = null, this.moving = !1, this.menuVisible = !1, this.lastLeftPinned = !1, this.firstRightPinned = !1, this.filterActive = !1, this.columnEventService = new wf(), this.tooltipEnabled = !1, this.rowGroupActive = !1, this.pivotActive = !1, this.aggregationActive = !1, this.colDef = e, this.userProvidedColDef = t, this.colId = r, this.primary = n, this.setState(e);
  }
  wireBeans(e) {
    this.columnHoverService = e.columnHoverService;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setState(e) {
    e.sort !== void 0 ? (e.sort === "asc" || e.sort === "desc") && (this.sort = e.sort) : (e.initialSort === "asc" || e.initialSort === "desc") && (this.sort = e.initialSort);
    const t = e.sortIndex, r = e.initialSortIndex;
    t !== void 0 ? t !== null && (this.sortIndex = t) : r !== null && (this.sortIndex = r);
    const n = e.hide, i = e.initialHide;
    n !== void 0 ? this.visible = !n : this.visible = !i, e.pinned !== void 0 ? this.setPinned(e.pinned) : this.setPinned(e.initialPinned);
    const o = e.flex, a = e.initialFlex;
    o !== void 0 ? this.flex = o : a !== void 0 && (this.flex = a);
  }
  // gets called when user provides an alternative colDef, eg
  setColDef(e, t, r) {
    this.colDef = e, this.userProvidedColDef = t, this.initMinAndMaxWidths(), this.initDotNotation(), this.initTooltip(), this.columnEventService.dispatchEvent(this.createColumnEvent("colDefChanged", r));
  }
  getUserProvidedColDef() {
    return this.userProvidedColDef;
  }
  setParent(e) {
    this.parent = e;
  }
  getParent() {
    return this.parent;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  // this is done after constructor as it uses gridOptionsService
  postConstruct() {
    this.initMinAndMaxWidths(), this.resetActualWidth("gridInitializing"), this.initDotNotation(), this.initTooltip();
  }
  initDotNotation() {
    const e = this.gos.get("suppressFieldDotNotation");
    this.fieldContainsDots = Me(this.colDef.field) && this.colDef.field.indexOf(".") >= 0 && !e, this.tooltipFieldContainsDots = Me(this.colDef.tooltipField) && this.colDef.tooltipField.indexOf(".") >= 0 && !e;
  }
  initMinAndMaxWidths() {
    const e = this.colDef;
    this.minWidth = e.minWidth ?? QU, this.maxWidth = e.maxWidth ?? Number.MAX_SAFE_INTEGER;
  }
  initTooltip() {
    this.tooltipEnabled = Me(this.colDef.tooltipField) || Me(this.colDef.tooltipValueGetter) || Me(this.colDef.tooltipComponent);
  }
  resetActualWidth(e) {
    const t = this.calculateColInitialWidth(this.colDef);
    this.setActualWidth(t, e, !0);
  }
  calculateColInitialWidth(e) {
    let t;
    const r = wc(e.width), n = wc(e.initialWidth);
    return r != null ? t = r : n != null ? t = n : t = 200, Math.max(Math.min(t, this.maxWidth), this.minWidth);
  }
  isEmptyGroup() {
    return !1;
  }
  isRowGroupDisplayed(e) {
    if (Zt(this.colDef) || Zt(this.colDef.showRowGroup))
      return !1;
    const t = this.colDef.showRowGroup === !0, r = this.colDef.showRowGroup === e;
    return t || r;
  }
  isPrimary() {
    return this.primary;
  }
  isFilterAllowed() {
    return !!this.colDef.filter;
  }
  isFieldContainsDots() {
    return this.fieldContainsDots;
  }
  isTooltipEnabled() {
    return this.tooltipEnabled;
  }
  isTooltipFieldContainsDots() {
    return this.tooltipFieldContainsDots;
  }
  addEventListener(e, t) {
    var n;
    this.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.columnEventService.setFrameworkOverrides(this.frameworkOverrides), this.frameworkEventListenerService = new fA(this.frameworkOverrides));
    const r = ((n = this.frameworkEventListenerService) == null ? void 0 : n.wrap(t)) ?? t;
    this.columnEventService.addEventListener(e, r);
  }
  removeEventListener(e, t) {
    var n;
    const r = ((n = this.frameworkEventListenerService) == null ? void 0 : n.unwrap(t)) ?? t;
    this.columnEventService.removeEventListener(e, r);
  }
  createColumnFunctionCallbackParams(e) {
    return this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      column: this,
      colDef: this.colDef
    });
  }
  isSuppressNavigable(e) {
    if (typeof this.colDef.suppressNavigable == "boolean")
      return this.colDef.suppressNavigable;
    if (typeof this.colDef.suppressNavigable == "function") {
      const t = this.createColumnFunctionCallbackParams(e), r = this.colDef.suppressNavigable;
      return r(t);
    }
    return !1;
  }
  isCellEditable(e) {
    return e.group && !this.gos.get("enableGroupEdit") ? !1 : this.isColumnFunc(e, this.colDef.editable);
  }
  isSuppressFillHandle() {
    return !!this.colDef.suppressFillHandle;
  }
  isAutoHeight() {
    return !!this.colDef.autoHeight;
  }
  isAutoHeaderHeight() {
    return !!this.colDef.autoHeaderHeight;
  }
  isRowDrag(e) {
    return this.isColumnFunc(e, this.colDef.rowDrag);
  }
  isDndSource(e) {
    return this.isColumnFunc(e, this.colDef.dndSource);
  }
  isCellCheckboxSelection(e) {
    return this.isColumnFunc(e, this.colDef.checkboxSelection);
  }
  isSuppressPaste(e) {
    return this.isColumnFunc(e, this.colDef ? this.colDef.suppressPaste : null);
  }
  isResizable() {
    return !!this.getColDefValue("resizable");
  }
  /** Get value from ColDef or default if it exists. */
  getColDefValue(e) {
    return this.colDef[e] ?? LLe[e];
  }
  isColumnFunc(e, t) {
    if (typeof t == "boolean")
      return t;
    if (typeof t == "function") {
      const r = this.createColumnFunctionCallbackParams(e);
      return t(r);
    }
    return !1;
  }
  setMoving(e, t) {
    this.moving = e, this.columnEventService.dispatchEvent(this.createColumnEvent("movingChanged", t));
  }
  createColumnEvent(e, t) {
    return this.gos.addGridCommonParams({
      type: e,
      column: this,
      columns: [this],
      source: t
    });
  }
  isMoving() {
    return this.moving;
  }
  getSort() {
    return this.sort;
  }
  setSort(e, t) {
    this.sort !== e && (this.sort = e, this.columnEventService.dispatchEvent(this.createColumnEvent("sortChanged", t))), this.dispatchStateUpdatedEvent("sort");
  }
  isSortable() {
    return !!this.getColDefValue("sortable");
  }
  /** @deprecated v32 use col.getSort() === 'asc */
  isSortAscending() {
    return this.sort === "asc";
  }
  /** @deprecated v32 use col.getSort() === 'desc */
  isSortDescending() {
    return this.sort === "desc";
  }
  /** @deprecated v32 use col.getSort() === undefined */
  isSortNone() {
    return Zt(this.sort);
  }
  /** @deprecated v32 use col.getSort() !== undefined */
  isSorting() {
    return Me(this.sort);
  }
  getSortIndex() {
    return this.sortIndex;
  }
  setSortIndex(e) {
    this.sortIndex = e, this.dispatchStateUpdatedEvent("sortIndex");
  }
  setMenuVisible(e, t) {
    this.menuVisible !== e && (this.menuVisible = e, this.columnEventService.dispatchEvent(this.createColumnEvent("menuVisibleChanged", t)));
  }
  isMenuVisible() {
    return this.menuVisible;
  }
  setAggFunc(e) {
    this.aggFunc = e, this.dispatchStateUpdatedEvent("aggFunc");
  }
  getAggFunc() {
    return this.aggFunc;
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  getRight() {
    return this.left + this.actualWidth;
  }
  setLeft(e, t) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.columnEventService.dispatchEvent(this.createColumnEvent("leftChanged", t)));
  }
  isFilterActive() {
    return this.filterActive;
  }
  // additionalEventAttributes is used by provided simple floating filter, so it can add 'floatingFilter=true' to the event
  setFilterActive(e, t, r) {
    this.filterActive !== e && (this.filterActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("filterActiveChanged", t)));
    const n = this.createColumnEvent("filterChanged", t);
    r && To(n, r), this.columnEventService.dispatchEvent(n);
  }
  isHovered() {
    return this.columnHoverService.isHovered(this);
  }
  setPinned(e) {
    e === !0 || e === "left" ? this.pinned = "left" : e === "right" ? this.pinned = "right" : this.pinned = null, this.dispatchStateUpdatedEvent("pinned");
  }
  setFirstRightPinned(e, t) {
    this.firstRightPinned !== e && (this.firstRightPinned = e, this.columnEventService.dispatchEvent(this.createColumnEvent("firstRightPinnedChanged", t)));
  }
  setLastLeftPinned(e, t) {
    this.lastLeftPinned !== e && (this.lastLeftPinned = e, this.columnEventService.dispatchEvent(this.createColumnEvent("lastLeftPinnedChanged", t)));
  }
  isFirstRightPinned() {
    return this.firstRightPinned;
  }
  isLastLeftPinned() {
    return this.lastLeftPinned;
  }
  isPinned() {
    return this.pinned === "left" || this.pinned === "right";
  }
  isPinnedLeft() {
    return this.pinned === "left";
  }
  isPinnedRight() {
    return this.pinned === "right";
  }
  getPinned() {
    return this.pinned;
  }
  setVisible(e, t) {
    const r = e === !0;
    this.visible !== r && (this.visible = r, this.columnEventService.dispatchEvent(this.createColumnEvent("visibleChanged", t))), this.dispatchStateUpdatedEvent("hide");
  }
  isVisible() {
    return this.visible;
  }
  isSpanHeaderHeight() {
    const e = this.getColDef();
    return !e.suppressSpanHeaderHeight && !e.autoHeaderHeight;
  }
  getColumnGroupPaddingInfo() {
    let e = this.getParent();
    if (!e || !e.isPadding())
      return { numberOfParents: 0, isSpanningTotal: !1 };
    const t = e.getPaddingLevel() + 1;
    let r = !0;
    for (; e; ) {
      if (!e.isPadding()) {
        r = !1;
        break;
      }
      e = e.getParent();
    }
    return { numberOfParents: t, isSpanningTotal: r };
  }
  getColDef() {
    return this.colDef;
  }
  getDefinition() {
    return this.colDef;
  }
  getColumnGroupShow() {
    return this.colDef.columnGroupShow;
  }
  getColId() {
    return this.colId;
  }
  getId() {
    return this.colId;
  }
  getUniqueId() {
    return this.colId;
  }
  getActualWidth() {
    return this.actualWidth;
  }
  getAutoHeaderHeight() {
    return this.autoHeaderHeight;
  }
  /** Returns true if the header height has changed */
  setAutoHeaderHeight(e) {
    const t = e !== this.autoHeaderHeight;
    return this.autoHeaderHeight = e, t;
  }
  createBaseColDefParams(e) {
    return this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      colDef: this.colDef,
      column: this
    });
  }
  getColSpan(e) {
    if (Zt(this.colDef.colSpan))
      return 1;
    const t = this.createBaseColDefParams(e), r = this.colDef.colSpan(t);
    return Math.max(r, 1);
  }
  getRowSpan(e) {
    if (Zt(this.colDef.rowSpan))
      return 1;
    const t = this.createBaseColDefParams(e), r = this.colDef.rowSpan(t);
    return Math.max(r, 1);
  }
  setActualWidth(e, t, r = !1) {
    e = Math.max(e, this.minWidth), e = Math.min(e, this.maxWidth), this.actualWidth !== e && (this.actualWidth = e, this.flex && t !== "flex" && t !== "gridInitializing" && (this.flex = null), r || this.fireColumnWidthChangedEvent(t)), this.dispatchStateUpdatedEvent("width");
  }
  fireColumnWidthChangedEvent(e) {
    this.columnEventService.dispatchEvent(this.createColumnEvent("widthChanged", e));
  }
  isGreaterThanMax(e) {
    return e > this.maxWidth;
  }
  getMinWidth() {
    return this.minWidth;
  }
  getMaxWidth() {
    return this.maxWidth;
  }
  getFlex() {
    return this.flex || 0;
  }
  // this method should only be used by the columnModel to
  // change flex when required by the applyColumnState method.
  setFlex(e) {
    this.flex !== e && (this.flex = e), this.dispatchStateUpdatedEvent("flex");
  }
  setMinimum(e) {
    this.setActualWidth(this.minWidth, e);
  }
  setRowGroupActive(e, t) {
    this.rowGroupActive !== e && (this.rowGroupActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnRowGroupChanged", t))), this.dispatchStateUpdatedEvent("rowGroup");
  }
  isRowGroupActive() {
    return this.rowGroupActive;
  }
  setPivotActive(e, t) {
    this.pivotActive !== e && (this.pivotActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnPivotChanged", t))), this.dispatchStateUpdatedEvent("pivot");
  }
  isPivotActive() {
    return this.pivotActive;
  }
  isAnyFunctionActive() {
    return this.isPivotActive() || this.isRowGroupActive() || this.isValueActive();
  }
  isAnyFunctionAllowed() {
    return this.isAllowPivot() || this.isAllowRowGroup() || this.isAllowValue();
  }
  setValueActive(e, t) {
    this.aggregationActive !== e && (this.aggregationActive = e, this.columnEventService.dispatchEvent(this.createColumnEvent("columnValueChanged", t)));
  }
  isValueActive() {
    return this.aggregationActive;
  }
  isAllowPivot() {
    return this.colDef.enablePivot === !0;
  }
  isAllowValue() {
    return this.colDef.enableValue === !0;
  }
  isAllowRowGroup() {
    return this.colDef.enableRowGroup === !0;
  }
  dispatchStateUpdatedEvent(e) {
    this.columnEventService.dispatchEvent({
      type: "columnStateUpdated",
      key: e
    });
  }
};
function pi(e) {
  return e instanceof g0;
}
var g0 = class extends he {
  constructor(e, t, r, n) {
    super(), this.isColumn = !1, this.expandable = !1, this.instanceId = XU(), this.expandableListenerRemoveCallback = null, this.colGroupDef = e, this.groupId = t, this.expanded = !!e && !!e.openByDefault, this.padding = r, this.level = n;
  }
  destroy() {
    this.expandableListenerRemoveCallback && this.reset(null, void 0), super.destroy();
  }
  reset(e, t) {
    this.colGroupDef = e, this.level = t, this.originalParent = null, this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback(), this.children = void 0, this.expandable = void 0;
  }
  getInstanceId() {
    return this.instanceId;
  }
  setOriginalParent(e) {
    this.originalParent = e;
  }
  getOriginalParent() {
    return this.originalParent;
  }
  getLevel() {
    return this.level;
  }
  isVisible() {
    return this.children ? this.children.some((e) => e.isVisible()) : !1;
  }
  isPadding() {
    return this.padding;
  }
  setExpanded(e) {
    this.expanded = e === void 0 ? !1 : e, this.dispatchLocalEvent({ type: "expandedChanged" });
  }
  isExpandable() {
    return this.expandable;
  }
  isExpanded() {
    return this.expanded;
  }
  getGroupId() {
    return this.groupId;
  }
  getId() {
    return this.getGroupId();
  }
  setChildren(e) {
    this.children = e;
  }
  getChildren() {
    return this.children;
  }
  getColGroupDef() {
    return this.colGroupDef;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  addLeafColumns(e) {
    this.children && this.children.forEach((t) => {
      Zl(t) ? e.push(t) : pi(t) && t.addLeafColumns(e);
    });
  }
  getColumnGroupShow() {
    const e = this.colGroupDef;
    if (e)
      return e.columnGroupShow;
  }
  // need to check that this group has at least one col showing when both expanded and contracted.
  // if not, then we don't allow expanding and contracting on this group
  setupExpandable() {
    this.setExpandable(), this.expandableListenerRemoveCallback && this.expandableListenerRemoveCallback();
    const e = this.onColumnVisibilityChanged.bind(this);
    this.getLeafColumns().forEach((t) => t.addEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = () => {
      this.getLeafColumns().forEach((t) => t.removeEventListener("visibleChanged", e)), this.expandableListenerRemoveCallback = null;
    };
  }
  setExpandable() {
    if (this.isPadding())
      return;
    let e = !1, t = !1, r = !1;
    const n = this.findChildrenRemovingPadding();
    for (let o = 0, a = n.length; o < a; o++) {
      const s = n[o];
      if (!s.isVisible())
        continue;
      const l = s.getColumnGroupShow();
      l === "open" ? (e = !0, r = !0) : l === "closed" ? (t = !0, r = !0) : (e = !0, t = !0);
    }
    const i = e && t && r;
    this.expandable !== i && (this.expandable = i, this.dispatchLocalEvent({ type: "expandableChanged" }));
  }
  findChildrenRemovingPadding() {
    const e = [], t = (r) => {
      r.forEach((n) => {
        pi(n) && n.isPadding() ? t(n.children) : e.push(n);
      });
    };
    return t(this.children), e;
  }
  onColumnVisibilityChanged() {
    this.setExpandable();
  }
}, NLe = {
  numericColumn: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  },
  rightAligned: {
    headerClass: "ag-right-aligned-header",
    cellClass: "ag-right-aligned-cell"
  }
}, EG = {};
function gA(e, t) {
  EG[t] || (e(), EG[t] = !0);
}
function sa(e, ...t) {
  console.log("AG Grid: " + e, ...t);
}
function Se(e, ...t) {
  gA(() => console.warn("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function sr(e, ...t) {
  gA(() => console.error("AG Grid: " + e, ...t), e + (t == null ? void 0 : t.join("")));
}
function vA(e) {
  return !!(e && e.constructor && e.call && e.apply);
}
function kLe(e) {
  VLe(e, 400);
}
var Wx = [], jx = !1;
function RG(e) {
  Wx.push(e), !jx && (jx = !0, window.setTimeout(() => {
    const t = Wx.slice();
    Wx.length = 0, jx = !1, t.forEach((r) => r());
  }, 0));
}
function VLe(e, t = 0) {
  e.length > 0 && window.setTimeout(() => e.forEach((r) => r()), t);
}
function vi(e, t) {
  let r;
  return function(...n) {
    const i = this;
    window.clearTimeout(r), r = window.setTimeout(function() {
      e.apply(i, n);
    }, t);
  };
}
function _G(e, t) {
  let r = 0;
  return function(...n) {
    const i = this, o = (/* @__PURE__ */ new Date()).getTime();
    o - r < t || (r = o, e.apply(i, n));
  };
}
function BLe(e, t, r = 100, n) {
  const i = (/* @__PURE__ */ new Date()).getTime();
  let o = null, a = !1;
  const s = () => {
    const l = (/* @__PURE__ */ new Date()).getTime() - i > r;
    (e() || l) && (t(), a = !0, o != null && (window.clearInterval(o), o = null), l && n && Se(n));
  };
  s(), a || (o = window.setInterval(s, 10));
}
function GLe(...e) {
  return (t) => e.reduce((r, n) => n(r), t);
}
var HLe = class {
  constructor() {
    this.existingKeys = {};
  }
  addExistingKeys(e) {
    for (let t = 0; t < e.length; t++)
      this.existingKeys[e[t]] = !0;
  }
  getUniqueKey(e, t) {
    e = CT(e);
    let r = 0;
    for (; ; ) {
      let n;
      if (e ? (n = e, r !== 0 && (n += "_" + r)) : t ? (n = t, r !== 0 && (n += "_" + r)) : n = r, !this.existingKeys[n])
        return this.existingKeys[n] = !0, String(n);
      r++;
    }
  }
}, Uv = "ag-Grid-AutoColumn";
function mA(e) {
  const t = [], r = (n) => {
    for (let i = 0; i < n.length; i++) {
      const o = n[i];
      Zl(o) ? t.push(o) : pi(o) && r(o.getChildren());
    }
  };
  return r(e), t;
}
function bs(e) {
  return e.reduce((t, r) => t + r.getActualWidth(), 0);
}
function oh(e, t, r) {
  const n = {};
  if (!t)
    return;
  qs(null, t, (o) => {
    n[o.getInstanceId()] = o;
  }), r && qs(null, r, (o) => {
    n[o.getInstanceId()] = null;
  });
  const i = Object.values(n).filter((o) => o != null);
  e.destroyBeans(i);
}
function TG(e) {
  return e.getId().startsWith(Uv);
}
function v0(e) {
  let t = [];
  return e instanceof Array ? e.some((n) => typeof n != "string") ? Se("if colDef.type is supplied an array it should be of type 'string[]'") : t = e : typeof e == "string" ? t = e.split(",") : Se("colDef.type should be of type 'string' | 'string[]'"), t;
}
var zLe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnFactory";
  }
  wireBeans(e) {
    this.dataTypeService = e.dataTypeService;
  }
  createColumnTree(e, t, r, n) {
    const i = new HLe(), { existingCols: o, existingGroups: a, existingColKeys: s } = this.extractExistingTreeData(r);
    i.addExistingKeys(s);
    const l = this.recursivelyCreateColumns(
      e,
      0,
      t,
      o,
      i,
      a,
      n
    ), u = this.findMaxDept(l, 0), c = this.balanceColumnTree(l, 0, u, i);
    return qs(null, c, (h, f) => {
      pi(h) && h.setupExpandable(), h.setOriginalParent(f);
    }), {
      columnTree: c,
      treeDept: u
    };
  }
  extractExistingTreeData(e) {
    const t = [], r = [], n = [];
    return e && qs(null, e, (i) => {
      if (pi(i)) {
        const o = i;
        r.push(o);
      } else {
        const o = i;
        n.push(o.getId()), t.push(o);
      }
    }), { existingCols: t, existingGroups: r, existingColKeys: n };
  }
  createForAutoGroups(e, t) {
    const r = [], n = this.findDepth(t);
    return e.forEach((i) => {
      let o = i;
      for (let a = n - 1; a >= 0; a--) {
        const s = new g0(null, `FAKE_PATH_${i.getId()}}_${a}`, !0, a);
        this.createBean(s), s.setChildren([o]), o.setOriginalParent(s), o = s;
      }
      n === 0 && i.setOriginalParent(null), r.push(o);
    }), [r, n];
  }
  findDepth(e) {
    let t = 0, r = e;
    for (; r && r[0] && pi(r[0]); )
      t++, r = r[0].getChildren();
    return t;
  }
  balanceColumnTree(e, t, r, n) {
    const i = [];
    for (let o = 0; o < e.length; o++) {
      const a = e[o];
      if (pi(a)) {
        const s = a, l = this.balanceColumnTree(
          s.getChildren(),
          t + 1,
          r,
          n
        );
        s.setChildren(l), i.push(s);
      } else {
        let s, l;
        for (let u = r - 1; u >= t; u--) {
          const c = n.getUniqueKey(null, null), d = this.createMergedColGroupDef(null), h = new g0(d, c, !0, t);
          this.createBean(h), l && l.setChildren([h]), l = h, s || (s = l);
        }
        if (s && l)
          if (i.push(s), e.some((c) => pi(c))) {
            l.setChildren([a]);
            continue;
          } else {
            l.setChildren(e);
            break;
          }
        i.push(a);
      }
    }
    return i;
  }
  findMaxDept(e, t) {
    let r = t;
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (pi(i)) {
        const o = i, a = this.findMaxDept(o.getChildren(), t + 1);
        r < a && (r = a);
      }
    }
    return r;
  }
  recursivelyCreateColumns(e, t, r, n, i, o, a) {
    if (!e)
      return [];
    const s = new Array(e.length);
    for (let l = 0; l < s.length; l++) {
      const u = e[l];
      this.isColumnGroup(u) ? s[l] = this.createColumnGroup(
        r,
        u,
        t,
        n,
        i,
        o,
        a
      ) : s[l] = this.createColumn(
        r,
        u,
        n,
        i,
        a
      );
    }
    return s;
  }
  createColumnGroup(e, t, r, n, i, o, a) {
    const s = this.createMergedColGroupDef(t), l = i.getUniqueKey(s.groupId || null, null), u = new g0(s, l, !1, r);
    this.createBean(u);
    const c = this.findExistingGroup(t, o);
    c && o.splice(c.idx, 1);
    const d = c == null ? void 0 : c.group;
    d && u.setExpanded(d.isExpanded());
    const h = this.recursivelyCreateColumns(
      s.children,
      r + 1,
      e,
      n,
      i,
      o,
      a
    );
    return u.setChildren(h), u;
  }
  createMergedColGroupDef(e) {
    const t = {};
    return Object.assign(t, this.gos.get("defaultColGroupDef")), Object.assign(t, e), t;
  }
  createColumn(e, t, r, n, i) {
    var s;
    const o = this.findExistingColumn(t, r);
    o && (r == null || r.splice(o.idx, 1));
    let a = o == null ? void 0 : o.column;
    if (a) {
      const l = this.addColumnDefaultAndTypes(t, a.getColId());
      a.setColDef(l, t, i), this.applyColumnState(a, l, i);
    } else {
      const l = n.getUniqueKey(t.colId, t.field), u = this.addColumnDefaultAndTypes(t, l);
      a = new JU(u, t, l, e), this.createBean(a);
    }
    return (s = this.dataTypeService) == null || s.addColumnListeners(a), a;
  }
  applyColumnState(e, t, r) {
    const n = wc(t.flex);
    if (n !== void 0 && e.setFlex(n), e.getFlex() <= 0) {
      const s = wc(t.width);
      if (s != null)
        e.setActualWidth(s, r);
      else {
        const l = e.getActualWidth();
        e.setActualWidth(l, r);
      }
    }
    t.sort !== void 0 && (t.sort == "asc" || t.sort == "desc" ? e.setSort(t.sort, r) : e.setSort(void 0, r));
    const o = wc(t.sortIndex);
    o !== void 0 && e.setSortIndex(o);
    const a = ST(t.hide);
    a !== void 0 && e.setVisible(!a, r), t.pinned !== void 0 && e.setPinned(t.pinned);
  }
  findExistingColumn(e, t) {
    if (t)
      for (let r = 0; r < t.length; r++) {
        const n = t[r].getUserProvidedColDef();
        if (!n)
          continue;
        if (e.colId != null) {
          if (t[r].getId() === e.colId)
            return { idx: r, column: t[r] };
          continue;
        }
        if (e.field != null) {
          if (n.field === e.field)
            return { idx: r, column: t[r] };
          continue;
        }
        if (n === e)
          return { idx: r, column: t[r] };
      }
  }
  findExistingGroup(e, t) {
    if (e.groupId != null)
      for (let n = 0; n < t.length; n++) {
        const i = t[n];
        if (i.getColGroupDef() && i.getId() === e.groupId)
          return { idx: n, group: i };
      }
  }
  addColumnDefaultAndTypes(e, t) {
    var s;
    const r = {}, n = this.gos.get("defaultColDef");
    To(r, n, !1, !0);
    const i = this.updateColDefAndGetColumnType(r, e, t);
    i && this.assignColumnTypes(i, r), To(r, e, !1, !0);
    const o = this.gos.get("autoGroupColumnDef"), a = this.gos.isColumnsSortingCoupledToGroup();
    return e.rowGroup && o && a && To(
      r,
      { sort: o.sort, initialSort: o.initialSort },
      !1,
      !0
    ), (s = this.dataTypeService) == null || s.validateColDef(r), r;
  }
  updateColDefAndGetColumnType(e, t, r) {
    var o;
    const n = (o = this.dataTypeService) == null ? void 0 : o.updateColDefAndGetColumnType(
      e,
      t,
      r
    ), i = t.type ?? n ?? e.type;
    return e.type = i, i ? v0(i) : void 0;
  }
  assignColumnTypes(e, t) {
    if (!e.length)
      return;
    const r = Object.assign({}, NLe), n = this.gos.get("columnTypes") || {};
    ia(n, (i, o) => {
      i in r ? Se(`the column type '${i}' is a default column type and cannot be overridden.`) : (o.type && Se(
        "Column type definitions 'columnTypes' with a 'type' attribute are not supported because a column type cannot refer to another column type. Only column definitions 'columnDefs' can use the 'type' attribute to refer to a column type."
      ), r[i] = o);
    }), e.forEach((i) => {
      const o = r[i.trim()];
      o ? To(t, o, !1, !0) : Se("colDef.type '" + i + "' does not correspond to defined gridOptions.columnTypes");
    });
  }
  // if object has children, we assume it's a group
  isColumnGroup(e) {
    return e.children !== void 0;
  }
};
function qs(e, t, r) {
  if (t)
    for (let n = 0; n < t.length; n++) {
      const i = t[n];
      pi(i) && qs(i, i.getChildren(), r), r(i, e);
    }
}
var $Le = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnModel", this.pivotMode = !1, this.autoHeightActiveAtLeastOnce = !1, this.ready = !1, this.changeEventsDispatching = !1, this.shouldQueueResizeOperations = !1, this.resizeOperationQueue = [];
  }
  wireBeans(e) {
    this.context = e.context, this.columnFactory = e.columnFactory, this.columnSizeService = e.columnSizeService, this.visibleColsService = e.visibleColsService, this.columnViewportService = e.columnViewportService, this.pivotResultColsService = e.pivotResultColsService, this.columnAnimationService = e.columnAnimationService, this.autoColService = e.autoColService, this.valueCache = e.valueCache, this.columnDefFactory = e.columnDefFactory, this.columnApplyStateService = e.columnApplyStateService, this.columnGroupStateService = e.columnGroupStateService, this.eventDispatcher = e.columnEventDispatcher, this.columnMoveService = e.columnMoveService, this.columnAutosizeService = e.columnAutosizeService, this.funcColsService = e.funcColsService, this.quickFilterService = e.quickFilterService, this.showRowGroupColsService = e.showRowGroupColsService, this.environment = e.environment;
  }
  postConstruct() {
    const e = this.gos.get("pivotMode");
    this.isPivotSettingAllowed(e) && (this.pivotMode = e), this.addManagedPropertyListeners(
      ["groupDisplayType", "treeData", "treeDataDisplayType", "groupHideOpenParents"],
      (t) => this.refreshAll(ah(t.source))
    ), this.addManagedPropertyListener(
      "autoGroupColumnDef",
      (t) => this.onAutoGroupColumnDefChanged(ah(t.source))
    ), this.addManagedPropertyListeners(
      ["defaultColDef", "columnTypes", "suppressFieldDotNotation"],
      (t) => this.recreateColumnDefs(ah(t.source))
    ), this.addManagedPropertyListener(
      "pivotMode",
      (t) => this.setPivotMode(this.gos.get("pivotMode"), ah(t.source))
    ), this.addManagedEventListeners({ firstDataRendered: () => this.onFirstDataRendered() });
  }
  // called from SyncService, when grid has finished initialising
  createColsFromColDefs(e, t) {
    var d;
    const r = e ? this.columnApplyStateService.compareColumnStatesAndDispatchEvents(t) : void 0;
    this.valueCache.expire();
    const n = this.colDefCols && this.colDefCols.list, i = this.colDefCols && this.colDefCols.tree, o = this.columnFactory.createColumnTree(this.colDefs, !0, i, t);
    oh(this.context, (d = this.colDefCols) == null ? void 0 : d.tree, o.columnTree);
    const a = o.columnTree, s = o.treeDept, l = mA(a), u = {};
    l.forEach((h) => u[h.getId()] = h), this.colDefCols = { tree: a, treeDepth: s, list: l, map: u }, this.funcColsService.extractCols(t, n), this.ready = !0, this.refreshCols(), e && !this.showingPivotResult && !this.gos.get("maintainColumnOrder") && this.orderColsLikeColDefCols(), this.visibleColsService.refresh(t), this.columnViewportService.checkViewportColumns(), this.eventDispatcher.everythingChanged(t), r && (this.changeEventsDispatching = !0, r(), this.changeEventsDispatching = !1), this.eventDispatcher.newColumnsLoaded(t), t === "gridInitializing" && this.columnSizeService.applyAutosizeStrategy();
  }
  // called from: buildAutoGroupColumns (events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents')
  // createColsFromColDefs (recreateColumnDefs, setColumnsDefs),
  // setPivotMode, applyColumnState,
  // functionColsService.setPrimaryColList, functionColsService.updatePrimaryColList,
  // pivotResultColsService.setPivotResultCols
  refreshCols() {
    var r, n, i;
    if (!this.colDefCols)
      return;
    const e = (r = this.cols) == null ? void 0 : r.tree;
    this.saveColOrder(), this.selectCols(), this.createAutoCols(), this.addAutoCols(), this.restoreColOrder(), this.positionLockedCols(), (n = this.showRowGroupColsService) == null || n.refresh(), (i = this.quickFilterService) == null || i.refreshQuickFilterCols(), this.setColSpanActive(), this.setAutoHeightActive(), this.visibleColsService.clear(), this.columnViewportService.clear(), !Jc(e, this.cols.tree) && this.eventDispatcher.gridColumns();
  }
  selectCols() {
    const e = this.pivotResultColsService.getPivotResultCols();
    if (this.showingPivotResult = e != null, e) {
      const { map: t, list: r, tree: n, treeDepth: i } = e;
      this.cols = {
        list: r.slice(),
        map: { ...t },
        tree: n.slice(),
        treeDepth: i
      }, e.list.some((a) => {
        var s;
        return ((s = this.cols) == null ? void 0 : s.map[a.getColId()]) !== void 0;
      }) || (this.lastPivotOrder = null);
    } else {
      const { map: t, list: r, tree: n, treeDepth: i } = this.colDefCols;
      this.cols = {
        list: r.slice(),
        map: { ...t },
        tree: n.slice(),
        treeDepth: i
      };
    }
  }
  getColsToShow() {
    const e = this.isPivotMode() && !this.isShowingPivotResult(), t = this.funcColsService.getValueColumns();
    return this.cols.list.filter((n) => {
      const i = TG(n);
      if (e) {
        const o = t && Cc(t, n);
        return i || o;
      } else
        return i || n.isVisible();
    });
  }
  addAutoCols() {
    this.autoCols != null && (this.cols.list = this.autoCols.list.concat(this.cols.list), this.cols.tree = this.autoCols.tree.concat(this.cols.tree), WLe(this.cols));
  }
  createAutoCols() {
    var p, g;
    const e = this.gos.isGroupUseEntireRow(this.pivotMode), t = this.pivotMode ? this.gos.get("pivotSuppressAutoColumn") : this.isSuppressAutoCol(), r = this.funcColsService.getRowGroupColumns(), i = !(r.length > 0 || this.gos.get("treeData")) || t || e, o = () => {
      this.autoCols && (oh(this.context, this.autoCols.tree), this.autoCols = null);
    };
    if (i || !this.autoColService) {
      o();
      return;
    }
    const a = this.autoColService.createAutoCols(r) ?? [], s = jLe(a, ((p = this.autoCols) == null ? void 0 : p.list) || null), l = this.cols.treeDepth, c = (this.autoCols ? this.autoCols.treeDepth : -1) == l;
    if (s && c)
      return;
    o();
    const [d, h] = this.columnFactory.createForAutoGroups(a, (g = this.cols) == null ? void 0 : g.tree);
    this.autoCols = {
      list: a,
      tree: d,
      treeDepth: h,
      map: {}
    };
    const f = (v) => {
      if (!v)
        return null;
      const m = v.filter((y) => !TG(y));
      return [...a, ...m];
    };
    this.lastOrder = f(this.lastOrder), this.lastPivotOrder = f(this.lastPivotOrder);
  }
  // on events 'groupDisplayType', 'treeData', 'treeDataDisplayType', 'groupHideOpenParents'
  refreshAll(e) {
    this.isReady() && (this.refreshCols(), this.visibleColsService.refresh(e));
  }
  setColsVisible(e, t = !1, r) {
    this.columnApplyStateService.applyColumnState(
      {
        state: e.map((n) => ({
          colId: typeof n == "string" ? n : n.getColId(),
          hide: !t
        }))
      },
      r
    );
  }
  setColsPinned(e, t, r) {
    if (!this.cols || Dn(e))
      return;
    if (this.gos.isDomLayout("print")) {
      Se("Changing the column pinning status is not allowed with domLayout='print'");
      return;
    }
    this.columnAnimationService.start();
    let n;
    t === !0 || t === "left" ? n = "left" : t === "right" ? n = "right" : n = null;
    const i = [];
    e.forEach((o) => {
      if (!o)
        return;
      const a = this.getCol(o);
      a && a.getPinned() !== n && (a.setPinned(n), i.push(a));
    }), i.length && (this.visibleColsService.refresh(r), this.eventDispatcher.columnPinned(i, r)), this.columnAnimationService.finish();
  }
  // called by headerRenderer - when a header is opened or closed
  setColumnGroupOpened(e, t, r) {
    let n;
    pi(e) ? n = e.getId() : n = e || "", this.columnGroupStateService.setColumnGroupState([{ groupId: n, open: t }], r);
  }
  getProvidedColGroup(e) {
    var r;
    let t = null;
    return qs(null, (r = this.cols) == null ? void 0 : r.tree, (n) => {
      pi(n) && n.getId() === e && (t = n);
    }), t;
  }
  isColGroupLocked(e) {
    const t = this.gos.get("groupLockGroupColumns");
    if (!e.isRowGroupActive() || t === 0)
      return !1;
    if (t === -1)
      return !0;
    const n = this.funcColsService.getRowGroupColumns().findIndex((i) => i.getColId() === e.getColId());
    return t > n;
  }
  isSuppressAutoCol() {
    return this.gos.get("groupDisplayType") === "custom" ? !0 : this.gos.get("treeDataDisplayType") === "custom";
  }
  setAutoHeightActive() {
    this.autoHeightActive = this.cols.list.some((e) => e.isAutoHeight()), this.autoHeightActive && (this.autoHeightActiveAtLeastOnce = !0, this.gos.isRowModelType("clientSide") || this.gos.isRowModelType("serverSide") || Se("autoHeight columns only work with Client Side Row Model and Server Side Row Model."));
  }
  restoreColOrder() {
    const e = this.showingPivotResult ? this.lastPivotOrder : this.lastOrder;
    if (!e)
      return;
    const t = new Map(e.map((l, u) => [l, u]));
    if (!this.cols.list.some((l) => t.has(l)))
      return;
    const n = new Map(this.cols.list.map((l) => [l, !0])), i = e.filter((l) => n.has(l)), o = new Map(i.map((l) => [l, !0])), a = this.cols.list.filter((l) => !o.has(l)), s = i.slice();
    a.forEach((l) => {
      let u = l.getOriginalParent();
      if (!u) {
        s.push(l);
        return;
      }
      const c = [];
      for (; !c.length && u; )
        u.getLeafColumns().forEach((p) => {
          const g = s.indexOf(p) >= 0, v = c.indexOf(p) < 0;
          g && v && c.push(p);
        }), u = u.getOriginalParent();
      if (!c.length) {
        s.push(l);
        return;
      }
      const d = c.map((f) => s.indexOf(f)), h = Math.max(...d);
      BC(s, l, h + 1);
    }), this.cols.list = s;
  }
  orderColsLikeColDefCols() {
    if (!this.colDefCols || !this.cols)
      return;
    const e = this.colDefCols.list.filter((r) => this.cols.list.indexOf(r) >= 0), t = this.cols.list.filter((r) => e.indexOf(r) < 0);
    this.cols.list = [...t, ...e], this.cols.list = this.columnMoveService.placeLockedColumns(this.cols.list);
  }
  sortColsLikeKeys(e) {
    if (this.cols == null)
      return;
    let t = [];
    const r = {};
    e.forEach((i) => {
      if (r[i])
        return;
      const o = this.cols.map[i];
      o && (t.push(o), r[i] = !0);
    });
    let n = 0;
    if (this.cols.list.forEach((i) => {
      const o = i.getColId();
      if (r[o] != null)
        return;
      o.startsWith(Uv) ? BC(t, i, n++) : t.push(i);
    }), t = this.columnMoveService.placeLockedColumns(t), !this.columnMoveService.doesMovePassMarryChildren(t)) {
      Se(
        "Applying column order broke a group where columns should be married together. Applying new order has been discarded."
      );
      return;
    }
    this.cols.list = t;
  }
  // returns the provided cols sorted in same order as they appear in this.cols, eg if this.cols
  // contains [a,b,c,d,e] and col passed is [e,a] then the passed cols are sorted into [a,e]
  sortColsLikeCols(e) {
    !e || e.length <= 1 || e.filter((r) => this.cols.list.indexOf(r) < 0).length > 0 || e.sort((r, n) => {
      const i = this.cols.list.indexOf(r), o = this.cols.list.indexOf(n);
      return i - o;
    });
  }
  resetColDefIntoCol(e, t) {
    const r = e.getUserProvidedColDef();
    if (!r)
      return !1;
    const n = this.columnFactory.addColumnDefaultAndTypes(r, e.getColId());
    return e.setColDef(n, r, t), !0;
  }
  queueResizeOperations() {
    this.shouldQueueResizeOperations = !0;
  }
  isShouldQueueResizeOperations() {
    return this.shouldQueueResizeOperations;
  }
  processResizeOperations() {
    this.shouldQueueResizeOperations = !1, this.resizeOperationQueue.forEach((e) => e()), this.resizeOperationQueue = [];
  }
  pushResizeOperation(e) {
    this.resizeOperationQueue.push(e);
  }
  moveInCols(e, t, r) {
    var n;
    KU((n = this.cols) == null ? void 0 : n.list, e, t), this.visibleColsService.refresh(r);
  }
  positionLockedCols() {
    this.cols.list = this.columnMoveService.placeLockedColumns(this.cols.list);
  }
  saveColOrder() {
    var e, t;
    this.showingPivotResult ? this.lastPivotOrder = (e = this.cols) == null ? void 0 : e.list : this.lastOrder = (t = this.cols) == null ? void 0 : t.list;
  }
  getColumnDefs() {
    if (!this.colDefCols)
      return;
    const e = this.colDefCols.list.slice();
    this.showingPivotResult ? e.sort((n, i) => this.lastOrder.indexOf(n) - this.lastOrder.indexOf(i)) : this.lastOrder && e.sort((n, i) => this.cols.list.indexOf(n) - this.cols.list.indexOf(i));
    const t = this.funcColsService.getRowGroupColumns(), r = this.funcColsService.getPivotColumns();
    return this.columnDefFactory.buildColumnDefs(e, t, r);
  }
  isShowingPivotResult() {
    return this.showingPivotResult;
  }
  // called by clientSideRowModel.refreshModel
  isChangeEventsDispatching() {
    return this.changeEventsDispatching;
  }
  isColSpanActive() {
    return this.colSpanActive;
  }
  // used by Column Tool Panel
  isProvidedColGroupsPresent() {
    var e;
    return ((e = this.colDefCols) == null ? void 0 : e.treeDepth) > 0;
  }
  setColSpanActive() {
    this.colSpanActive = this.cols.list.some((e) => e.getColDef().colSpan != null);
  }
  isAutoRowHeightActive() {
    return this.autoHeightActive;
  }
  wasAutoRowHeightEverActive() {
    return this.autoHeightActiveAtLeastOnce;
  }
  // + gridPanel -> for resizing the body and setting top margin
  getHeaderRowCount() {
    return this.cols ? this.cols.treeDepth + 1 : -1;
  }
  isReady() {
    return this.ready;
  }
  isPivotMode() {
    return this.pivotMode;
  }
  setPivotMode(e, t) {
    e === this.pivotMode || !this.isPivotSettingAllowed(this.pivotMode) || (this.pivotMode = e, this.ready && (this.refreshCols(), this.visibleColsService.refresh(t), this.eventDispatcher.pivotModeChanged()));
  }
  isPivotSettingAllowed(e) {
    return e && this.gos.get("treeData") ? (Se("Pivot mode not available with treeData."), !1) : !0;
  }
  // + clientSideRowModel
  isPivotActive() {
    const e = this.funcColsService.getPivotColumns();
    return this.pivotMode && !Dn(e);
  }
  // called when dataTypes change
  recreateColumnDefs(e) {
    this.cols && (this.autoCols && this.autoColService.updateAutoCols(this.autoCols.list, e), this.createColsFromColDefs(!0, e));
  }
  setColumnDefs(e, t) {
    const r = !!this.colDefs;
    this.colDefs = e, this.createColsFromColDefs(r, t);
  }
  destroy() {
    var e, t;
    oh(this.context, (e = this.colDefCols) == null ? void 0 : e.tree), oh(this.context, (t = this.autoCols) == null ? void 0 : t.tree), super.destroy();
  }
  getColTree() {
    return this.cols.tree;
  }
  // + columnSelectPanel
  getColDefColTree() {
    return this.colDefCols.tree;
  }
  // + clientSideRowController -> sorting, building quick filter text
  // + headerRenderer -> sorting (clearing icon)
  getColDefCols() {
    var e;
    return (e = this.colDefCols) != null && e.list ? this.colDefCols.list : null;
  }
  // + moveColumnController
  getCols() {
    var e;
    return ((e = this.cols) == null ? void 0 : e.list) ?? [];
  }
  // returns colDefCols, pivotResultCols and autoCols
  getAllCols() {
    var r, n;
    const e = this.pivotResultColsService.getPivotResultCols(), t = e == null ? void 0 : e.list;
    return [].concat(
      ((r = this.colDefCols) == null ? void 0 : r.list) || [],
      ((n = this.autoCols) == null ? void 0 : n.list) || [],
      t || []
    );
  }
  getColsForKeys(e) {
    return e ? e.map((r) => this.getCol(r)).filter((r) => r != null) : [];
  }
  getColDefCol(e) {
    var t;
    return (t = this.colDefCols) != null && t.list ? this.getColFromCollection(e, this.colDefCols) : null;
  }
  getCol(e) {
    return e == null ? null : this.getColFromCollection(e, this.cols);
  }
  getColFromCollection(e, t) {
    if (t == null)
      return null;
    const { map: r, list: n } = t;
    if (typeof e == "string" && r[e])
      return r[e];
    for (let i = 0; i < n.length; i++)
      if (PG(n[i], e))
        return n[i];
    return this.getAutoCol(e);
  }
  getAutoCol(e) {
    return this.autoCols == null ? null : this.autoCols.list.find((t) => PG(t, e)) || null;
  }
  getAutoCols() {
    var e;
    return ((e = this.autoCols) == null ? void 0 : e.list) || null;
  }
  setColHeaderHeight(e, t) {
    e.setAutoHeaderHeight(t) && this.eventDispatcher.headerHeight(e);
  }
  getColumnGroupHeaderRowHeight() {
    return this.isPivotMode() ? this.getPivotGroupHeaderHeight() : this.getGroupHeaderHeight();
  }
  getColumnHeaderRowHeight() {
    const e = this.isPivotMode() ? this.getPivotHeaderHeight() : this.getHeaderHeight(), r = this.visibleColsService.getAllCols().filter((n) => n.isAutoHeaderHeight()).map((n) => n.getAutoHeaderHeight() || 0);
    return Math.max(e, ...r);
  }
  getHeaderHeight() {
    return this.gos.get("headerHeight") ?? this.environment.getDefaultHeaderHeight();
  }
  getFloatingFiltersHeight() {
    return this.gos.get("floatingFiltersHeight") ?? this.getHeaderHeight();
  }
  getGroupHeaderHeight() {
    return this.gos.get("groupHeaderHeight") ?? this.getHeaderHeight();
  }
  getPivotHeaderHeight() {
    return this.gos.get("pivotHeaderHeight") ?? this.getHeaderHeight();
  }
  getPivotGroupHeaderHeight() {
    return this.gos.get("pivotGroupHeaderHeight") ?? this.getGroupHeaderHeight();
  }
  onFirstDataRendered() {
    const e = this.gos.get("autoSizeStrategy");
    if ((e == null ? void 0 : e.type) !== "fitCellContents")
      return;
    const { colIds: t, skipHeader: r } = e;
    setTimeout(() => {
      t ? this.columnAutosizeService.autoSizeCols({
        colKeys: t,
        skipHeader: r,
        source: "autosizeColumns"
      }) : this.columnAutosizeService.autoSizeAllColumns("autosizeColumns", r);
    });
  }
  onAutoGroupColumnDefChanged(e) {
    this.autoCols && this.autoColService.updateAutoCols(this.autoCols.list, e);
  }
};
function ah(e) {
  return e === "gridOptionsUpdated" ? "gridOptionsChanged" : e;
}
function WLe(e) {
  e.map = {}, e.list.forEach((t) => e.map[t.getId()] = t);
}
function PG(e, t) {
  const r = e === t, n = e.getColDef() === t, i = e.getColId() == t;
  return r || n || i;
}
function jLe(e, t) {
  return Jc(e, t, (r, n) => r.getColId() === n.getColId());
}
var ULe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnAutosizeService", this.timesDelayed = 0;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.animationFrameService = e.animationFrameService, this.autoWidthCalculator = e.autoWidthCalculator, this.eventDispatcher = e.columnEventDispatcher, this.ctrlsService = e.ctrlsService, this.renderStatusService = e.renderStatusService;
  }
  autoSizeCols(e) {
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.autoSizeCols(e));
      return;
    }
    const { colKeys: t, skipHeader: r, skipHeaderGroups: n, stopAtGroup: i, source: o = "api" } = e;
    if (this.animationFrameService.flushAllFrames(), this.timesDelayed < 5 && this.renderStatusService && !this.renderStatusService.areHeaderCellsRendered()) {
      this.timesDelayed++, setTimeout(() => this.autoSizeCols(e));
      return;
    }
    this.timesDelayed = 0;
    const a = [];
    let s = -1;
    const l = r ?? this.gos.get("skipHeaderOnAutoSize"), u = n ?? l;
    for (; s !== 0; ) {
      s = 0;
      const c = [];
      t.forEach((d) => {
        if (!d)
          return;
        const h = this.columnModel.getCol(d);
        if (!h || a.indexOf(h) >= 0)
          return;
        const f = this.autoWidthCalculator.getPreferredWidthForColumn(h, l);
        if (f > 0) {
          const p = this.normaliseColumnWidth(h, f);
          h.setActualWidth(p, o), a.push(h), s++;
        }
        c.push(h);
      }), c.length && this.visibleColsService.refresh(o);
    }
    u || this.autoSizeColumnGroupsByColumns(t, o, i), this.eventDispatcher.columnResized(a, !0, "autosizeColumns");
  }
  autoSizeColumn(e, t, r) {
    e && this.autoSizeCols({ colKeys: [e], skipHeader: r, skipHeaderGroups: !0, source: t });
  }
  autoSizeColumnGroupsByColumns(e, t, r) {
    const n = /* @__PURE__ */ new Set();
    this.columnModel.getColsForKeys(e).forEach((s) => {
      let l = s.getParent();
      for (; l && l != r; )
        l.isPadding() || n.add(l), l = l.getParent();
    });
    let o;
    const a = [];
    for (const s of n) {
      for (const l of this.ctrlsService.getHeaderRowContainerCtrls())
        if (o = l.getHeaderCtrlForColumn(s), o)
          break;
      o && o.resizeLeafColumnsToFit(t);
    }
    return a;
  }
  autoSizeAllColumns(e, t) {
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.autoSizeAllColumns(e, t));
      return;
    }
    const r = this.visibleColsService.getAllCols();
    this.autoSizeCols({ colKeys: r, skipHeader: t, source: e });
  }
  // returns the width we can set to this col, taking into consideration min and max widths
  normaliseColumnWidth(e, t) {
    const r = e.getMinWidth();
    t < r && (t = r);
    const n = e.getMaxWidth();
    return e.isGreaterThanMax(t) && (t = n), t;
  }
}, KLe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "funcColsService", this.rowGroupCols = [], this.valueCols = [], this.pivotCols = [];
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher, this.aggFuncService = e.aggFuncService, this.visibleColsService = e.visibleColsService;
  }
  getModifyColumnsNoEventsCallbacks() {
    return {
      addGroupCol: (e) => this.rowGroupCols.push(e),
      removeGroupCol: (e) => gi(this.rowGroupCols, e),
      addPivotCol: (e) => this.pivotCols.push(e),
      removePivotCol: (e) => gi(this.pivotCols, e),
      addValueCol: (e) => this.valueCols.push(e),
      removeValueCol: (e) => gi(this.valueCols, e)
    };
  }
  getSourceColumnsForGroupColumn(e) {
    const t = e.getColDef().showRowGroup;
    if (!t)
      return null;
    if (t === !0)
      return this.rowGroupCols.slice(0);
    const r = this.columnModel.getColDefCol(t);
    return r ? [r] : null;
  }
  sortRowGroupColumns(e) {
    this.rowGroupCols.sort(e);
  }
  sortPivotColumns(e) {
    this.pivotCols.sort(e);
  }
  // + rowController
  getValueColumns() {
    return this.valueCols ? this.valueCols : [];
  }
  // + rowController
  getPivotColumns() {
    return this.pivotCols ? this.pivotCols : [];
  }
  // + toolPanel
  getRowGroupColumns() {
    return this.rowGroupCols ? this.rowGroupCols : [];
  }
  isRowGroupEmpty() {
    return Dn(this.rowGroupCols);
  }
  setColumnAggFunc(e, t, r) {
    if (!e)
      return;
    const n = this.columnModel.getColDefCol(e);
    n && (n.setAggFunc(t), this.eventDispatcher.columnChanged("columnValueChanged", [n], r));
  }
  setRowGroupColumns(e, t) {
    this.setColList(
      e,
      this.rowGroupCols,
      "columnRowGroupChanged",
      !0,
      !0,
      (r, n) => this.setRowGroupActive(r, n, t),
      t
    );
  }
  setRowGroupActive(e, t, r) {
    e !== t.isRowGroupActive() && (t.setRowGroupActive(e, r), e && !this.gos.get("suppressRowGroupHidesColumns") && this.columnModel.setColsVisible([t], !1, r), !e && !this.gos.get("suppressMakeColumnVisibleAfterUnGroup") && this.columnModel.setColsVisible([t], !0, r));
  }
  addRowGroupColumns(e, t) {
    this.updateColList(
      e,
      this.rowGroupCols,
      !0,
      !0,
      (r) => this.setRowGroupActive(!0, r, t),
      "columnRowGroupChanged",
      t
    );
  }
  removeRowGroupColumns(e, t) {
    this.updateColList(
      e,
      this.rowGroupCols,
      !1,
      !0,
      (r) => this.setRowGroupActive(!1, r, t),
      "columnRowGroupChanged",
      t
    );
  }
  addPivotColumns(e, t) {
    this.updateColList(
      e,
      this.pivotCols,
      !0,
      !1,
      (r) => r.setPivotActive(!0, t),
      "columnPivotChanged",
      t
    );
  }
  setPivotColumns(e, t) {
    this.setColList(
      e,
      this.pivotCols,
      "columnPivotChanged",
      !0,
      !1,
      (r, n) => {
        n.setPivotActive(r, t);
      },
      t
    );
  }
  removePivotColumns(e, t) {
    this.updateColList(
      e,
      this.pivotCols,
      !1,
      !1,
      (r) => r.setPivotActive(!1, t),
      "columnPivotChanged",
      t
    );
  }
  setValueColumns(e, t) {
    this.setColList(
      e,
      this.valueCols,
      "columnValueChanged",
      !1,
      !1,
      (r, n) => this.setValueActive(r, n, t),
      t
    );
  }
  setValueActive(e, t, r) {
    if (e !== t.isValueActive() && (t.setValueActive(e, r), e && !t.getAggFunc() && this.aggFuncService)) {
      const n = this.aggFuncService.getDefaultAggFunc(t);
      t.setAggFunc(n);
    }
  }
  addValueColumns(e, t) {
    this.updateColList(
      e,
      this.valueCols,
      !0,
      !1,
      (r) => this.setValueActive(!0, r, t),
      "columnValueChanged",
      t
    );
  }
  removeValueColumns(e, t) {
    this.updateColList(
      e,
      this.valueCols,
      !1,
      !1,
      (r) => this.setValueActive(!1, r, t),
      "columnValueChanged",
      t
    );
  }
  moveRowGroupColumn(e, t, r) {
    if (this.isRowGroupEmpty())
      return;
    const n = this.rowGroupCols[e], i = this.rowGroupCols.slice(e, t);
    this.rowGroupCols.splice(e, 1), this.rowGroupCols.splice(t, 0, n), this.eventDispatcher.rowGroupChanged(i, r);
  }
  setColList(e, t, r, n, i, o, a) {
    const s = this.columnModel.getCols();
    if (Dn(s))
      return;
    const l = /* @__PURE__ */ new Map();
    t.forEach((c, d) => l.set(c, d)), t.length = 0, Me(e) && e.forEach((c) => {
      const d = this.columnModel.getColDefCol(c);
      d && t.push(d);
    }), t.forEach((c, d) => {
      const h = l.get(c);
      if (h === void 0) {
        l.set(c, 0);
        return;
      }
      n && h !== d || l.delete(c);
    }), (this.columnModel.getColDefCols() || []).forEach((c) => {
      const d = t.indexOf(c) >= 0;
      o(d, c);
    }), i && this.columnModel.refreshCols(), this.visibleColsService.refresh(a), this.eventDispatcher.columnChanged(r, [...l.keys()], a);
  }
  updateColList(e, t, r, n, i, o, a) {
    if (!e || Dn(e))
      return;
    let s = !1;
    e.forEach((l) => {
      if (!l)
        return;
      const u = this.columnModel.getColDefCol(l);
      if (u) {
        if (r) {
          if (t.indexOf(u) >= 0)
            return;
          t.push(u);
        } else {
          if (t.indexOf(u) < 0)
            return;
          gi(t, u);
        }
        i(u), s = !0;
      }
    }), s && (n && this.columnModel.refreshCols(), this.visibleColsService.refresh(a), this.eventDispatcher.genericColumnEvent(o, t, a));
  }
  extractCols(e, t) {
    this.extractRowGroupCols(e, t), this.extractPivotCols(e, t), this.extractValueCols(e, t);
  }
  extractValueCols(e, t) {
    this.valueCols = this.extractColsCommon(
      t,
      this.valueCols,
      (r, n) => r.setValueActive(n, e),
      // aggFunc doesn't have index variant, cos order of value cols doesn't matter, so always return null
      () => {
      },
      () => {
      },
      // aggFunc is a string, so return it's existence
      (r) => {
        const n = r.aggFunc;
        if (n === null || n === "")
          return null;
        if (n !== void 0)
          return !!n;
      },
      (r) => r.initialAggFunc != null && r.initialAggFunc != ""
    ), this.valueCols.forEach((r) => {
      const n = r.getColDef();
      n.aggFunc != null && n.aggFunc != "" ? r.setAggFunc(n.aggFunc) : r.getAggFunc() || r.setAggFunc(n.initialAggFunc);
    });
  }
  extractRowGroupCols(e, t) {
    this.rowGroupCols = this.extractColsCommon(
      t,
      this.rowGroupCols,
      (r, n) => r.setRowGroupActive(n, e),
      (r) => r.rowGroupIndex,
      (r) => r.initialRowGroupIndex,
      (r) => r.rowGroup,
      (r) => r.initialRowGroup
    );
  }
  extractPivotCols(e, t) {
    this.pivotCols = this.extractColsCommon(
      t,
      this.pivotCols,
      (r, n) => r.setPivotActive(n, e),
      (r) => r.pivotIndex,
      (r) => r.initialPivotIndex,
      (r) => r.pivot,
      (r) => r.initialPivot
    );
  }
  extractColsCommon(e = [], t = [], r, n, i, o, a) {
    const s = [], l = [];
    (this.columnModel.getColDefCols() || []).forEach((h) => {
      const f = e.indexOf(h) < 0, p = h.getColDef(), g = ST(o(p)), v = ST(a(p)), m = wc(n(p)), y = wc(i(p));
      let C;
      g !== void 0 ? C = g : m !== void 0 ? m === null ? C = !1 : C = m >= 0 : f ? v !== void 0 ? C = v : y !== void 0 ? C = y != null && y >= 0 : C = !1 : C = t.indexOf(h) >= 0, C && ((f ? m != null || y != null : m != null) ? s.push(h) : l.push(h));
    });
    const c = (h) => {
      const f = n(h.getColDef()), p = i(h.getColDef());
      return f ?? p;
    };
    s.sort((h, f) => {
      const p = c(h), g = c(f);
      return p === g ? 0 : p < g ? -1 : 1;
    });
    const d = [].concat(s);
    return t.forEach((h) => {
      l.indexOf(h) >= 0 && d.push(h);
    }), l.forEach((h) => {
      d.indexOf(h) < 0 && d.push(h);
    }), t.forEach((h) => {
      d.indexOf(h) < 0 && r(h, !1);
    }), d.forEach((h) => {
      t.indexOf(h) < 0 && r(h, !0);
    }), d;
  }
  generateColumnStateForRowGroupAndPivotIndexes(e, t) {
    const r = {}, n = (i, o, a, s, l, u) => {
      const c = this.columnModel.getColDefCols();
      if (!o.length || !c)
        return [];
      const d = Object.keys(i), h = new Set(d), f = new Set(d), p = new Set(
        o.map((w) => {
          const x = w.getColId();
          return f.delete(x), x;
        }).concat(d)
      ), g = [], v = {};
      let m = 0;
      for (let w = 0; w < c.length; w++) {
        const x = c[w].getColId();
        p.has(x) && (g.push(x), v[x] = m++);
      }
      let y = 1e3, C = !1, S = 0;
      const b = (w) => {
        const x = v[w];
        for (let E = S; E < x; E++) {
          const R = g[E];
          f.has(R) && (i[R][l] = y++, f.delete(R));
        }
        S = x;
      };
      o.forEach((w) => {
        const x = w.getColId();
        if (h.has(x))
          b(x), i[x][l] = y++;
        else {
          const E = w.getColDef();
          (E[l] === null || E[l] === void 0 && E[u] == null) && (C || (E[a] || E[a] === void 0 && E[s] ? b(x) : (f.forEach((P) => {
            i[P][l] = y + v[P];
          }), y += g.length, C = !0)), r[x] || (r[x] = { colId: x }), r[x][l] = y++);
        }
      });
    };
    return n(
      e,
      this.rowGroupCols,
      "rowGroup",
      "initialRowGroup",
      "rowGroupIndex",
      "initialRowGroupIndex"
    ), n(
      t,
      this.pivotCols,
      "pivot",
      "initialPivot",
      "pivotIndex",
      "initialPivotIndex"
    ), Object.values(r);
  }
}, YLe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnApplyStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher, this.sortController = e.sortController, this.columnGetStateService = e.columnGetStateService, this.funcColsService = e.funcColsService, this.visibleColsService = e.visibleColsService, this.columnAnimationService = e.columnAnimationService, this.pivotResultColsService = e.pivotResultColsService;
  }
  applyColumnState(e, t) {
    const r = this.columnModel.getColDefCols() || [];
    if (Dn(r))
      return !1;
    if (e && e.state && !e.state.forEach)
      return Se(
        "applyColumnState() - the state attribute should be an array, however an array was not found. Please provide an array of items (one for each col you want to change) for state."
      ), !1;
    const n = this.funcColsService.getModifyColumnsNoEventsCallbacks(), i = (s, l, u) => {
      const c = this.compareColumnStatesAndDispatchEvents(t), d = l.slice(), h = {}, f = {}, p = [], g = [];
      let v = 0;
      const m = this.funcColsService.getRowGroupColumns().slice(), y = this.funcColsService.getPivotColumns().slice();
      s.forEach((w) => {
        const x = w.colId || "";
        if (x.startsWith(Uv)) {
          p.push(w), g.push(w);
          return;
        }
        const R = u(x);
        R ? (this.syncColumnWithStateItem(
          R,
          w,
          e.defaultState,
          h,
          f,
          !1,
          t,
          n
        ), gi(d, R)) : (g.push(w), v += 1);
      });
      const C = (w) => this.syncColumnWithStateItem(
        w,
        null,
        e.defaultState,
        h,
        f,
        !1,
        t,
        n
      );
      d.forEach(C), this.funcColsService.sortRowGroupColumns(
        MG.bind(this, h, m)
      ), this.funcColsService.sortPivotColumns(MG.bind(this, f, y)), this.columnModel.refreshCols();
      const b = (this.columnModel.getAutoCols() || []).slice();
      return p.forEach((w) => {
        const x = this.columnModel.getAutoCol(w.colId);
        gi(b, x), this.syncColumnWithStateItem(
          x,
          w,
          e.defaultState,
          null,
          null,
          !0,
          t,
          n
        );
      }), b.forEach(C), this.orderLiveColsLikeState(e), this.visibleColsService.refresh(t), this.eventDispatcher.everythingChanged(t), c(), { unmatchedAndAutoStates: g, unmatchedCount: v };
    };
    this.columnAnimationService.start();
    let { unmatchedAndAutoStates: o, unmatchedCount: a } = i(
      e.state || [],
      r,
      (s) => this.columnModel.getColDefCol(s)
    );
    if (o.length > 0 || Me(e.defaultState)) {
      const s = this.pivotResultColsService.getPivotResultCols(), l = s == null ? void 0 : s.list;
      a = i(
        o,
        l || [],
        (u) => this.pivotResultColsService.getPivotResultCol(u)
      ).unmatchedCount;
    }
    return this.columnAnimationService.finish(), a === 0;
  }
  resetColumnState(e) {
    const t = this.columnModel.getColDefCols();
    if (Dn(t))
      return;
    const r = this.columnModel.getColDefColTree(), n = mA(r), i = [];
    let o = 1e3, a = 1e3, s = [];
    const l = this.columnModel.getAutoCols();
    l && (s = s.concat(l)), n && (s = s.concat(n)), s.forEach((u) => {
      const c = this.getColumnStateFromColDef(u);
      Zt(c.rowGroupIndex) && c.rowGroup && (c.rowGroupIndex = o++), Zt(c.pivotIndex) && c.pivot && (c.pivotIndex = a++), i.push(c);
    }), this.applyColumnState({ state: i, applyOrder: !0 }, e);
  }
  getColumnStateFromColDef(e) {
    const t = (p, g) => p ?? g ?? null, r = e.getColDef(), n = t(r.sort, r.initialSort), i = t(r.sortIndex, r.initialSortIndex), o = t(r.hide, r.initialHide), a = t(r.pinned, r.initialPinned), s = t(r.width, r.initialWidth), l = t(r.flex, r.initialFlex);
    let u = t(
      r.rowGroupIndex,
      r.initialRowGroupIndex
    ), c = t(r.rowGroup, r.initialRowGroup);
    u == null && (c == null || c == !1) && (u = null, c = null);
    let d = t(r.pivotIndex, r.initialPivotIndex), h = t(r.pivot, r.initialPivot);
    d == null && (h == null || h == !1) && (d = null, h = null);
    const f = t(r.aggFunc, r.initialAggFunc);
    return {
      colId: e.getColId(),
      sort: n,
      sortIndex: i,
      hide: o,
      pinned: a,
      width: s,
      flex: l,
      rowGroup: c,
      rowGroupIndex: u,
      pivot: h,
      pivotIndex: d,
      aggFunc: f
    };
  }
  syncColumnWithStateItem(e, t, r, n, i, o, a, s) {
    if (!e)
      return;
    const l = (S, b) => {
      const w = {
        value1: void 0,
        value2: void 0
      };
      let x = !1;
      return t && (t[S] !== void 0 && (w.value1 = t[S], x = !0), Me(b) && t[b] !== void 0 && (w.value2 = t[b], x = !0)), !x && r && (r[S] !== void 0 && (w.value1 = r[S]), Me(b) && r[b] !== void 0 && (w.value2 = r[b])), w;
    }, u = l("hide").value1;
    u !== void 0 && e.setVisible(!u, a);
    const c = l("pinned").value1;
    c !== void 0 && e.setPinned(c);
    const d = e.getColDef().minWidth ?? QU, h = l("flex").value1;
    if (h !== void 0 && e.setFlex(h), h == null) {
      const S = l("width").value1;
      S != null && d != null && S >= d && e.setActualWidth(S, a);
    }
    const f = l("sort").value1;
    f !== void 0 && (f === "desc" || f === "asc" ? e.setSort(f, a) : e.setSort(void 0, a));
    const p = l("sortIndex").value1;
    if (p !== void 0 && e.setSortIndex(p), o || !e.isPrimary())
      return;
    const g = l("aggFunc").value1;
    g !== void 0 && (typeof g == "string" ? (e.setAggFunc(g), e.isValueActive() || (e.setValueActive(!0, a), s.addValueCol(e))) : (Me(g) && Se(
      "stateItem.aggFunc must be a string. if using your own aggregation functions, register the functions first before using them in get/set state. This is because it is intended for the column state to be stored and retrieved as simple JSON."
    ), e.isValueActive() && (e.setValueActive(!1, a), s.removeValueCol(e))));
    const { value1: v, value2: m } = l("rowGroup", "rowGroupIndex");
    (v !== void 0 || m !== void 0) && (typeof m == "number" || v ? (e.isRowGroupActive() || (e.setRowGroupActive(!0, a), s.addGroupCol(e)), n && typeof m == "number" && (n[e.getId()] = m)) : e.isRowGroupActive() && (e.setRowGroupActive(!1, a), s.removeGroupCol(e)));
    const { value1: y, value2: C } = l("pivot", "pivotIndex");
    (y !== void 0 || C !== void 0) && (typeof C == "number" || y ? (e.isPivotActive() || (e.setPivotActive(!0, a), s.addPivotCol(e)), i && typeof C == "number" && (i[e.getId()] = C)) : e.isPivotActive() && (e.setPivotActive(!1, a), s.removePivotCol(e)));
  }
  orderLiveColsLikeState(e) {
    if (!e.applyOrder || !e.state)
      return;
    const t = [];
    e.state.forEach((r) => {
      r.colId != null && t.push(r.colId);
    }), this.columnModel.sortColsLikeKeys(t);
  }
  // calculates what events to fire between column state changes. gets used when:
  // a) apply column state
  // b) apply new column definitions (so changes from old cols)
  compareColumnStatesAndDispatchEvents(e) {
    const t = {
      rowGroupColumns: this.funcColsService.getRowGroupColumns().slice(),
      pivotColumns: this.funcColsService.getPivotColumns().slice(),
      valueColumns: this.funcColsService.getValueColumns().slice()
    }, r = this.columnGetStateService.getColumnState(), n = {};
    return r.forEach((i) => {
      n[i.colId] = i;
    }), () => {
      const i = this.columnModel.getAllCols(), o = (g, v, m, y) => {
        const C = v.map(y), S = m.map(y);
        if (Jc(C, S))
          return;
        const w = new Set(v);
        m.forEach((R) => {
          w.delete(R) || w.add(R);
        });
        const x = [...w], E = {
          type: g,
          columns: x,
          column: x.length === 1 ? x[0] : null,
          source: e
        };
        this.eventService.dispatchEvent(E);
      }, a = (g) => {
        const v = [];
        return i.forEach((m) => {
          const y = n[m.getColId()];
          y && g(y, m) && v.push(m);
        }), v;
      }, s = (g) => g.getColId();
      o(
        "columnRowGroupChanged",
        t.rowGroupColumns,
        this.funcColsService.getRowGroupColumns(),
        s
      ), o(
        "columnPivotChanged",
        t.pivotColumns,
        this.funcColsService.getPivotColumns(),
        s
      );
      const u = a((g, v) => {
        const m = g.aggFunc != null, y = m != v.isValueActive(), C = m && g.aggFunc != v.getAggFunc();
        return y || C;
      });
      u.length > 0 && this.eventDispatcher.columnChanged("columnValueChanged", u, e);
      const c = (g, v) => g.width != v.getActualWidth();
      this.eventDispatcher.columnResized(a(c), !0, e);
      const d = (g, v) => g.pinned != v.getPinned();
      this.eventDispatcher.columnPinned(a(d), e);
      const h = (g, v) => g.hide == v.isVisible();
      this.eventDispatcher.columnVisible(a(h), e);
      const p = a((g, v) => g.sort != v.getSort() || g.sortIndex != v.getSortIndex());
      p.length > 0 && this.sortController.dispatchSortChangedEvents(e, p), this.normaliseColumnMovedEventForColumnState(r, e);
    };
  }
  normaliseColumnMovedEventForColumnState(e, t) {
    const r = this.columnGetStateService.getColumnState(), n = {};
    r.forEach((l) => n[l.colId] = l);
    const i = {};
    e.forEach((l) => {
      n[l.colId] && (i[l.colId] = !0);
    });
    const o = e.filter((l) => i[l.colId]), a = r.filter((l) => i[l.colId]), s = [];
    a.forEach((l, u) => {
      const c = o && o[u];
      if (c && c.colId !== l.colId) {
        const d = this.columnModel.getCol(c.colId);
        d && s.push(d);
      }
    }), s.length && this.eventDispatcher.columnMoved({ movedColumns: s, source: t, finished: !0 });
  }
}, MG = (e, t, r, n) => {
  const i = e[r.getId()], o = e[n.getId()], a = i != null, s = o != null;
  if (a && s)
    return i - o;
  if (a)
    return -1;
  if (s)
    return 1;
  const l = t.indexOf(r), u = t.indexOf(n), c = l >= 0, d = u >= 0;
  return c && d ? l - u : c ? -1 : 1;
}, qLe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnMoveService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnAnimationService = e.columnAnimationService, this.eventDispatcher = e.columnEventDispatcher;
  }
  moveColumnByIndex(e, t, r) {
    const n = this.columnModel.getCols();
    if (!n)
      return;
    const i = n[e];
    this.moveColumns([i], t, r);
  }
  moveColumns(e, t, r, n = !0) {
    const i = this.columnModel.getCols();
    if (!i)
      return;
    if (this.columnAnimationService.start(), t > i.length - e.length) {
      Se("tried to insert columns in invalid location, toIndex = ", t), Se("remember that you should not count the moving columns when calculating the new index");
      return;
    }
    const o = this.columnModel.getColsForKeys(e);
    this.doesMovePassRules(o, t) && (this.columnModel.moveInCols(o, t, r), this.eventDispatcher.columnMoved({ movedColumns: o, source: r, toIndex: t, finished: n }), this.columnAnimationService.finish());
  }
  doesMovePassRules(e, t) {
    const r = this.getProposedColumnOrder(e, t);
    return this.doesOrderPassRules(r);
  }
  doesOrderPassRules(e) {
    return !(!this.doesMovePassMarryChildren(e) || !this.doesMovePassLockedPositions(e));
  }
  getProposedColumnOrder(e, t) {
    const n = this.columnModel.getCols().slice();
    return KU(n, e, t), n;
  }
  doesMovePassLockedPositions(e) {
    const t = (o) => o ? o === "left" || o === !0 ? -1 : 1 : 0, r = this.gos.get("enableRtl");
    let n = r ? 1 : -1, i = !0;
    return e.forEach((o) => {
      const a = t(o.getColDef().lockPosition);
      r ? a > n && (i = !1) : a < n && (i = !1), n = a;
    }), i;
  }
  doesMovePassMarryChildren(e) {
    let t = !0;
    const r = this.columnModel.getColTree();
    return qs(null, r, (n) => {
      if (!pi(n))
        return;
      const i = n, o = i.getColGroupDef();
      if (!(o && o.marryChildren))
        return;
      const s = [];
      i.getLeafColumns().forEach((h) => {
        const f = e.indexOf(h);
        s.push(f);
      });
      const l = Math.max.apply(Math, s), u = Math.min.apply(Math, s), c = l - u, d = i.getLeafColumns().length - 1;
      c > d && (t = !1);
    }), t;
  }
  placeLockedColumns(e) {
    const t = [], r = [], n = [];
    return e.forEach((o) => {
      const a = o.getColDef().lockPosition;
      a === "right" ? n.push(o) : a === "left" || a === !0 ? t.push(o) : r.push(o);
    }), this.gos.get("enableRtl") ? [...n, ...r, ...t] : [...t, ...r, ...n];
  }
}, ZLe = /[&<>"']/g, XLe = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Za(e, t) {
  if (e == null)
    return null;
  const r = e.toString().toString();
  return t ? r : r.replace(ZLe, (n) => XLe[n]);
}
function QLe(e) {
  if (!e || e == null)
    return null;
  const t = /([a-z])([A-Z])/g, r = /([A-Z]+)([A-Z])([a-z])/g;
  return e.replace(t, "$1 $2").replace(r, "$1 $2$3").replace(/\./g, " ").split(" ").map((i) => i.substring(0, 1).toUpperCase() + (i.length > 1 ? i.substring(1, i.length) : "")).join(" ");
}
var JLe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnNameService";
  }
  wireBeans(e) {
    this.expressionService = e.expressionService, this.funcColsService = e.funcColsService, this.columnModel = e.columnModel;
  }
  getDisplayNameForColumn(e, t, r = !1) {
    if (!e)
      return null;
    const n = this.getHeaderName(e.getColDef(), e, null, null, t);
    return r ? this.wrapHeaderNameWithAggFunc(e, n) : n;
  }
  getDisplayNameForProvidedColumnGroup(e, t, r) {
    const n = t ? t.getColGroupDef() : null;
    return n ? this.getHeaderName(n, null, e, t, r) : null;
  }
  getDisplayNameForColumnGroup(e, t) {
    return this.getDisplayNameForProvidedColumnGroup(e, e.getProvidedColumnGroup(), t);
  }
  // location is where the column is going to appear, ie who is calling us
  getHeaderName(e, t, r, n, i) {
    const o = e.headerValueGetter;
    if (o) {
      const a = this.gos.addGridCommonParams({
        colDef: e,
        column: t,
        columnGroup: r,
        providedColumnGroup: n,
        location: i
      });
      return typeof o == "function" ? o(a) : typeof o == "string" ? this.expressionService.evaluate(o, a) : (Se("headerValueGetter must be a function or a string"), "");
    } else {
      if (e.headerName != null)
        return e.headerName;
      if (e.field)
        return QLe(e.field);
    }
    return "";
  }
  wrapHeaderNameWithAggFunc(e, t) {
    if (this.gos.get("suppressAggFuncInHeader"))
      return t;
    const r = e.getColDef().pivotValueColumn, n = Me(r);
    let i = null, o;
    if (n) {
      const a = this.funcColsService.getValueColumns(), s = this.gos.get("removePivotHeaderRowWhenSingleValueColumn") && a.length === 1, l = e.getColDef().pivotTotalColumnIds !== void 0;
      if (s && !l)
        return t;
      i = r ? r.getAggFunc() : null, o = !0;
    } else {
      const a = e.isValueActive(), s = this.columnModel.isPivotMode() || !this.funcColsService.isRowGroupEmpty();
      a && s ? (i = e.getAggFunc(), o = !0) : o = !1;
    }
    if (o) {
      const a = typeof i == "string" ? i : "func";
      return `${this.localeService.getLocaleTextFunc()(a, a)}(${t})`;
    }
    return t;
  }
}, eOe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "pivotResultColsService";
  }
  wireBeans(e) {
    this.context = e.context, this.columnModel = e.columnModel, this.columnFactory = e.columnFactory, this.visibleColsService = e.visibleColsService;
  }
  destroy() {
    var e;
    oh(this.context, (e = this.pivotResultCols) == null ? void 0 : e.tree), super.destroy();
  }
  isPivotResultColsPresent() {
    return this.pivotResultCols != null;
  }
  lookupPivotResultCol(e, t) {
    if (this.pivotResultCols == null)
      return null;
    const r = this.columnModel.getColDefCol(t);
    let n = null;
    return this.pivotResultCols.list.forEach((i) => {
      const o = i.getColDef().pivotKeys, a = i.getColDef().pivotValueColumn;
      Jc(o, e) && a === r && (n = i);
    }), n;
  }
  getPivotResultCols() {
    return this.pivotResultCols;
  }
  getPivotResultCol(e) {
    return this.pivotResultCols ? this.columnModel.getColFromCollection(e, this.pivotResultCols) : null;
  }
  setPivotResultCols(e, t) {
    var r, n;
    if (this.columnModel.isReady() && !(e == null && this.pivotResultCols == null)) {
      if (e) {
        this.processPivotResultColDef(e);
        const i = this.columnFactory.createColumnTree(
          e,
          !1,
          ((r = this.pivotResultCols) == null ? void 0 : r.tree) || this.previousPivotResultCols || void 0,
          t
        );
        oh(this.context, (n = this.pivotResultCols) == null ? void 0 : n.tree, i.columnTree);
        const o = i.columnTree, a = i.treeDept, s = mA(o), l = {};
        this.pivotResultCols = { tree: o, treeDepth: a, list: s, map: l }, this.pivotResultCols.list.forEach((u) => this.pivotResultCols.map[u.getId()] = u), this.previousPivotResultCols = null;
      } else
        this.previousPivotResultCols = this.pivotResultCols ? this.pivotResultCols.tree : null, this.pivotResultCols = null;
      this.columnModel.refreshCols(), this.visibleColsService.refresh(t);
    }
  }
  processPivotResultColDef(e) {
    const t = this.gos.get("processPivotResultColDef"), r = this.gos.get("processPivotResultColGroupDef");
    if (!t && !r)
      return;
    const n = (i) => {
      i.forEach((o) => {
        if (Me(o.children)) {
          const s = o;
          r && r(s), n(s.children);
        } else
          t && t(o);
      });
    };
    e && n(e);
  }
}, tOe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnSizeService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnViewportService = e.columnViewportService, this.eventDispatcher = e.columnEventDispatcher, this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService;
  }
  setColumnWidths(e, t, r, n) {
    const i = [];
    e.forEach((o) => {
      const a = this.columnModel.getColDefCol(o.key) || this.columnModel.getCol(o.key);
      if (!a)
        return;
      if (i.push({
        width: o.newWidth,
        ratios: [1],
        columns: [a]
      }), this.gos.get("colResizeDefault") === "shift" && (t = !t), t) {
        const l = this.visibleColsService.getColAfter(a);
        if (!l)
          return;
        const u = a.getActualWidth() - o.newWidth, c = l.getActualWidth() + u;
        i.push({
          width: c,
          ratios: [1],
          columns: [l]
        });
      }
    }), i.length !== 0 && this.resizeColumnSets({
      resizeSets: i,
      finished: r,
      source: n
    });
  }
  // method takes sets of columns and resizes them. either all sets will be resized, or nothing
  // be resized. this is used for example when user tries to resize a group and holds shift key,
  // then both the current group (grows), and the adjacent group (shrinks), will get resized,
  // so that's two sets for this method.
  resizeColumnSets(e) {
    const { resizeSets: t, finished: r, source: n } = e;
    if (!(!t || t.every((c) => this.checkMinAndMaxWidthsForSet(c)))) {
      if (r) {
        const c = t && t.length > 0 ? t[0].columns : null;
        this.eventDispatcher.columnResized(c, r, n);
      }
      return;
    }
    const o = [], a = [];
    t.forEach((c) => {
      const { width: d, columns: h, ratios: f } = c, p = {}, g = {};
      h.forEach((y) => a.push(y));
      let v = !0, m = 0;
      for (; v; ) {
        if (m++, m > 1e3) {
          sr("infinite loop in resizeColumnSets");
          break;
        }
        v = !1;
        const y = [];
        let C = 0, S = d;
        h.forEach((w, x) => {
          if (g[w.getId()])
            S -= p[w.getId()];
          else {
            y.push(w);
            const R = f[x];
            C += R;
          }
        });
        const b = 1 / C;
        y.forEach((w, x) => {
          const E = x === y.length - 1;
          let R;
          E ? R = S : (R = Math.round(f[x] * d * b), S -= R);
          const _ = w.getMinWidth(), P = w.getMaxWidth();
          R < _ ? (R = _, g[w.getId()] = !0, v = !0) : P > 0 && R > P && (R = P, g[w.getId()] = !0, v = !0), p[w.getId()] = R;
        });
      }
      h.forEach((y) => {
        const C = p[y.getId()];
        y.getActualWidth() !== C && (y.setActualWidth(C, n), o.push(y));
      });
    });
    const s = o.length > 0;
    let l = [];
    s && (l = this.refreshFlexedColumns({ resizingCols: a, skipSetLeft: !0 }), this.visibleColsService.setLeftValues(n), this.visibleColsService.updateBodyWidths(), this.columnViewportService.checkViewportColumns());
    const u = a.concat(l);
    (s || r) && this.eventDispatcher.columnResized(u, r, n, l);
  }
  checkMinAndMaxWidthsForSet(e) {
    const { columns: t, width: r } = e;
    let n = 0, i = 0, o = !0;
    t.forEach((l) => {
      const u = l.getMinWidth();
      n += u || 0;
      const c = l.getMaxWidth();
      c > 0 ? i += c : o = !1;
    });
    const a = r >= n, s = !o || r <= i;
    return a && s;
  }
  refreshFlexedColumns(e = {}) {
    const t = e.source ? e.source : "flex";
    if (e.viewportWidth != null && (this.flexViewportWidth = e.viewportWidth), !this.flexViewportWidth)
      return [];
    const r = this.visibleColsService.getCenterCols();
    let n = -1;
    if (e.resizingCols) {
      const h = new Set(e.resizingCols);
      for (let f = r.length - 1; f >= 0; f--)
        if (h.has(r[f])) {
          n = f;
          break;
        }
    }
    let i = 0, o = [], a = 0, s = 0;
    for (let h = 0; h < r.length; h++)
      r[h].getFlex() && h > n ? (o.push(r[h]), s += r[h].getFlex(), a += r[h].getMinWidth()) : i += r[h].getActualWidth();
    if (!o.length)
      return [];
    let l = [];
    i + a > this.flexViewportWidth && (o.forEach((h) => h.setActualWidth(h.getMinWidth(), t)), l = o, o = []);
    const u = [];
    let c;
    e:
      for (; ; ) {
        c = this.flexViewportWidth - i;
        const h = c / s;
        for (let f = 0; f < o.length; f++) {
          const p = o[f], g = h * p.getFlex();
          let v = 0;
          const m = p.getMinWidth(), y = p.getMaxWidth();
          if (g < m ? v = m : g > y && (v = y), v) {
            p.setActualWidth(v, t), UU(o, p), s -= p.getFlex(), l.push(p), i += p.getActualWidth();
            continue e;
          }
          u[f] = Math.round(g);
        }
        break;
      }
    let d = c;
    return o.forEach((h, f) => {
      h.setActualWidth(Math.min(u[f], d), t), l.push(h), d -= u[f];
    }), e.skipSetLeft || this.visibleColsService.setLeftValues(t), e.updateBodyWidths && this.visibleColsService.updateBodyWidths(), e.fireResizedEvent && this.eventDispatcher.columnResized(l, !0, t, o), o;
  }
  // called from api
  sizeColumnsToFit(e, t = "sizeColumnsToFit", r, n) {
    var h;
    if (this.columnModel.isShouldQueueResizeOperations()) {
      this.columnModel.pushResizeOperation(() => this.sizeColumnsToFit(e, t, r, n));
      return;
    }
    const i = {};
    n && ((h = n == null ? void 0 : n.columnLimits) == null || h.forEach(({ key: f, ...p }) => {
      i[typeof f == "string" ? f : f.getColId()] = p;
    }));
    const o = this.visibleColsService.getAllCols(), a = e === bs(o);
    if (e <= 0 || !o.length || a)
      return;
    const s = [], l = [];
    o.forEach((f) => {
      f.getColDef().suppressSizeToFit === !0 ? l.push(f) : s.push(f);
    });
    const u = s.slice(0);
    let c = !1;
    const d = (f) => {
      gi(s, f), l.push(f);
    };
    for (s.forEach((f) => {
      f.resetActualWidth(t);
      const p = i == null ? void 0 : i[f.getId()], g = (p == null ? void 0 : p.minWidth) ?? (n == null ? void 0 : n.defaultMinWidth), v = (p == null ? void 0 : p.maxWidth) ?? (n == null ? void 0 : n.defaultMaxWidth), m = f.getActualWidth();
      typeof g == "number" && m < g ? f.setActualWidth(g, t, !0) : typeof v == "number" && m > v && f.setActualWidth(v, t, !0);
    }); !c; ) {
      c = !0;
      const f = e - bs(l);
      if (f <= 0)
        s.forEach((p) => {
          var v;
          const g = ((v = i == null ? void 0 : i[p.getId()]) == null ? void 0 : v.minWidth) ?? (n == null ? void 0 : n.defaultMinWidth);
          if (typeof g == "number") {
            p.setActualWidth(g, t, !0);
            return;
          }
          p.setMinimum(t);
        });
      else {
        const p = f / bs(s);
        let g = f;
        for (let v = s.length - 1; v >= 0; v--) {
          const m = s[v], y = i == null ? void 0 : i[m.getId()], C = (y == null ? void 0 : y.minWidth) ?? (n == null ? void 0 : n.defaultMinWidth), S = (y == null ? void 0 : y.maxWidth) ?? (n == null ? void 0 : n.defaultMaxWidth), b = m.getMinWidth(), w = m.getMaxWidth(), x = typeof C == "number" && C > b ? C : b, E = typeof S == "number" && S < w ? S : w;
          let R = Math.round(m.getActualWidth() * p);
          R < x ? (R = x, d(m), c = !1) : R > E ? (R = E, d(m), c = !1) : v === 0 && (R = g), m.setActualWidth(R, t, !0), g -= R;
        }
      }
    }
    u.forEach((f) => {
      f.fireColumnWidthChangedEvent(t);
    }), this.visibleColsService.setLeftValues(t), this.visibleColsService.updateBodyWidths(), !r && this.eventDispatcher.columnResized(u, !0, t);
  }
  applyAutosizeStrategy() {
    const e = this.gos.get("autoSizeStrategy");
    if (!e)
      return;
    const { type: t } = e;
    setTimeout(() => {
      if (t === "fitGridWidth") {
        const { columnLimits: r, defaultMinWidth: n, defaultMaxWidth: i } = e, o = r == null ? void 0 : r.map(({ colId: a, minWidth: s, maxWidth: l }) => ({
          key: a,
          minWidth: s,
          maxWidth: l
        }));
        this.ctrlsService.getGridBodyCtrl().sizeColumnsToFit({
          defaultMinWidth: n,
          defaultMaxWidth: i,
          columnLimits: o
        });
      } else t === "fitProvidedWidth" && this.sizeColumnsToFit(e.width, "sizeColumnsToFit");
    });
  }
};
function eK(e, t) {
  return e + "_" + t;
}
function an(e) {
  return e instanceof tK;
}
var tK = class extends he {
  constructor(e, t, r, n) {
    super(), this.isColumn = !1, this.displayedChildren = [], this.parent = null, this.groupId = t, this.partId = r, this.providedColumnGroup = e, this.pinned = n;
  }
  // as the user is adding and removing columns, the groups are recalculated.
  // this reset clears out all children, ready for children to be added again
  reset() {
    this.parent = null, this.children = null, this.displayedChildren = null;
  }
  getParent() {
    return this.parent;
  }
  setParent(e) {
    this.parent = e;
  }
  getUniqueId() {
    return eK(this.groupId, this.partId);
  }
  isEmptyGroup() {
    return this.displayedChildren.length === 0;
  }
  isMoving() {
    const e = this.getProvidedColumnGroup().getLeafColumns();
    return !e || e.length === 0 ? !1 : e.every((t) => t.isMoving());
  }
  checkLeft() {
    if (this.displayedChildren.forEach((e) => {
      an(e) && e.checkLeft();
    }), this.displayedChildren.length > 0)
      if (this.gos.get("enableRtl")) {
        const t = Jt(this.displayedChildren).getLeft();
        this.setLeft(t);
      } else {
        const e = this.displayedChildren[0].getLeft();
        this.setLeft(e);
      }
    else
      this.setLeft(null);
  }
  getLeft() {
    return this.left;
  }
  getOldLeft() {
    return this.oldLeft;
  }
  setLeft(e) {
    this.oldLeft = this.left, this.left !== e && (this.left = e, this.dispatchLocalEvent({ type: "leftChanged" }));
  }
  getPinned() {
    return this.pinned;
  }
  getGroupId() {
    return this.groupId;
  }
  getPartId() {
    return this.partId;
  }
  getActualWidth() {
    let e = 0;
    return this.displayedChildren && this.displayedChildren.forEach((t) => {
      e += t.getActualWidth();
    }), e;
  }
  isResizable() {
    if (!this.displayedChildren)
      return !1;
    let e = !1;
    return this.displayedChildren.forEach((t) => {
      t.isResizable() && (e = !0);
    }), e;
  }
  getMinWidth() {
    let e = 0;
    return this.displayedChildren.forEach((t) => {
      e += t.getMinWidth();
    }), e;
  }
  addChild(e) {
    this.children || (this.children = []), this.children.push(e);
  }
  getDisplayedChildren() {
    return this.displayedChildren;
  }
  getLeafColumns() {
    const e = [];
    return this.addLeafColumns(e), e;
  }
  getDisplayedLeafColumns() {
    const e = [];
    return this.addDisplayedLeafColumns(e), e;
  }
  getDefinition() {
    return this.providedColumnGroup.getColGroupDef();
  }
  getColGroupDef() {
    return this.providedColumnGroup.getColGroupDef();
  }
  isPadding() {
    return this.providedColumnGroup.isPadding();
  }
  isExpandable() {
    return this.providedColumnGroup.isExpandable();
  }
  isExpanded() {
    return this.providedColumnGroup.isExpanded();
  }
  setExpanded(e) {
    this.providedColumnGroup.setExpanded(e);
  }
  addDisplayedLeafColumns(e) {
    this.displayedChildren.forEach((t) => {
      Zl(t) ? e.push(t) : an(t) && t.addDisplayedLeafColumns(e);
    });
  }
  addLeafColumns(e) {
    this.children.forEach((t) => {
      Zl(t) ? e.push(t) : an(t) && t.addLeafColumns(e);
    });
  }
  getChildren() {
    return this.children;
  }
  getColumnGroupShow() {
    return this.providedColumnGroup.getColumnGroupShow();
  }
  getProvidedColumnGroup() {
    return this.providedColumnGroup;
  }
  getPaddingLevel() {
    const e = this.getParent();
    return !this.isPadding() || !e || !e.isPadding() ? 0 : 1 + e.getPaddingLevel();
  }
  calculateDisplayedColumns() {
    this.displayedChildren = [];
    let e = this;
    for (; e != null && e.isPadding(); )
      e = e.getParent();
    if (!(e ? e.getProvidedColumnGroup().isExpandable() : !1)) {
      this.displayedChildren = this.children, this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
      return;
    }
    this.children.forEach((r) => {
      if (an(r) && (!r.displayedChildren || !r.displayedChildren.length))
        return;
      switch (r.getColumnGroupShow()) {
        case "open":
          e.getProvidedColumnGroup().isExpanded() && this.displayedChildren.push(r);
          break;
        case "closed":
          e.getProvidedColumnGroup().isExpanded() || this.displayedChildren.push(r);
          break;
        default:
          this.displayedChildren.push(r);
          break;
      }
    }), this.dispatchLocalEvent({ type: "displayedChildrenChanged" });
  }
}, rK = class {
  constructor() {
    this.existingIds = {};
  }
  getInstanceIdForKey(e) {
    const t = this.existingIds[e];
    let r;
    return typeof t != "number" ? r = 0 : r = t + 1, this.existingIds[e] = r, r;
  }
}, rOe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "visibleColsService", this.colsAndGroupsMap = {}, this.columnsLeft = [], this.columnsRight = [], this.columnsCenter = [], this.columns = [], this.bodyWidth = 0, this.leftWidth = 0, this.rightWidth = 0, this.bodyWidthDirty = !0;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.columnViewportService = e.columnViewportService, this.eventDispatcher = e.columnEventDispatcher;
  }
  refresh(e, t = !1) {
    t || this.buildTrees(), this.updateOpenClosedVisibilityInColumnGroups(), this.columnsLeft = Ux(this.treeLeft), this.columnsCenter = Ux(this.treeCenter), this.columnsRight = Ux(this.treeRight), this.joinColsAriaOrder(), this.joinCols(), this.setLeftValues(e), this.autoHeightCols = this.columns.filter((r) => r.isAutoHeight()), this.columnSizeService.refreshFlexedColumns(), this.updateBodyWidths(), this.columnViewportService.checkViewportColumns(!1), this.setFirstRightAndLastLeftPinned(e), this.eventDispatcher.visibleCols();
  }
  // after setColumnWidth or updateGroupsAndPresentedCols
  updateBodyWidths() {
    const e = bs(this.columnsCenter), t = bs(this.columnsLeft), r = bs(this.columnsRight);
    if (this.bodyWidthDirty = this.bodyWidth !== e, this.bodyWidth !== e || this.leftWidth !== t || this.rightWidth !== r) {
      this.bodyWidth = e, this.leftWidth = t, this.rightWidth = r;
      const i = {
        type: "columnContainerWidthChanged"
      };
      this.eventService.dispatchEvent(i);
      const o = {
        type: "displayedColumnsWidthChanged"
      };
      this.eventService.dispatchEvent(o);
    }
  }
  // sets the left pixel position of each column
  setLeftValues(e) {
    this.setLeftValuesOfCols(e), this.setLeftValuesOfGroups();
  }
  setFirstRightAndLastLeftPinned(e) {
    let t, r;
    this.gos.get("enableRtl") ? (t = this.columnsLeft ? this.columnsLeft[0] : null, r = this.columnsRight ? Jt(this.columnsRight) : null) : (t = this.columnsLeft ? Jt(this.columnsLeft) : null, r = this.columnsRight ? this.columnsRight[0] : null), this.columnModel.getCols().forEach((n) => {
      n.setLastLeftPinned(n === t, e), n.setFirstRightPinned(n === r, e);
    });
  }
  buildTrees() {
    const e = this.columnModel.getColsToShow(), t = e.filter((o) => o.getPinned() == "left"), r = e.filter((o) => o.getPinned() == "right"), n = e.filter((o) => o.getPinned() != "left" && o.getPinned() != "right"), i = new rK();
    this.treeLeft = this.createGroups({
      columns: t,
      idCreator: i,
      pinned: "left",
      oldDisplayedGroups: this.treeLeft
    }), this.treeRight = this.createGroups({
      columns: r,
      idCreator: i,
      pinned: "right",
      oldDisplayedGroups: this.treeRight
    }), this.treeCenter = this.createGroups({
      columns: n,
      idCreator: i,
      pinned: null,
      oldDisplayedGroups: this.treeCenter
    }), this.updateColsAndGroupsMap();
  }
  clear() {
    this.columnsLeft = [], this.columnsRight = [], this.columnsCenter = [], this.columns = [], this.ariaOrderColumns = [];
  }
  joinColsAriaOrder() {
    const e = this.columnModel.getCols(), t = [], r = [], n = [];
    for (const i of e) {
      const o = i.getPinned();
      o ? o === !0 || o === "left" ? t.push(i) : n.push(i) : r.push(i);
    }
    this.ariaOrderColumns = t.concat(r).concat(n);
  }
  getAriaColIndex(e) {
    let t;
    return an(e) ? t = e.getLeafColumns()[0] : t = e, this.ariaOrderColumns.indexOf(t) + 1;
  }
  getAllAutoHeightCols() {
    return this.autoHeightCols;
  }
  setLeftValuesOfGroups() {
    [this.treeLeft, this.treeRight, this.treeCenter].forEach((e) => {
      e.forEach((t) => {
        an(t) && t.checkLeft();
      });
    });
  }
  setLeftValuesOfCols(e) {
    if (!this.columnModel.getColDefCols())
      return;
    const r = this.columnModel.getCols().slice(0), n = this.gos.get("enableRtl");
    [this.columnsLeft, this.columnsRight, this.columnsCenter].forEach((i) => {
      if (n) {
        let o = bs(i);
        i.forEach((a) => {
          o -= a.getActualWidth(), a.setLeft(o, e);
        });
      } else {
        let o = 0;
        i.forEach((a) => {
          a.setLeft(o, e), o += a.getActualWidth();
        });
      }
      RLe(r, i);
    }), r.forEach((i) => {
      i.setLeft(null, e);
    });
  }
  joinCols() {
    this.gos.get("enableRtl") ? this.columns = this.columnsRight.concat(this.columnsCenter).concat(this.columnsLeft) : this.columns = this.columnsLeft.concat(this.columnsCenter).concat(this.columnsRight);
  }
  getColsCenter() {
    return this.columnsCenter;
  }
  getAllTrees() {
    return this.treeLeft && this.treeRight && this.treeCenter ? this.treeLeft.concat(this.treeCenter).concat(this.treeRight) : null;
  }
  // + headerRenderer -> setting pinned body width
  getTreeLeft() {
    return this.treeLeft;
  }
  // + headerRenderer -> setting pinned body width
  getTreeRight() {
    return this.treeRight;
  }
  // + headerRenderer -> setting pinned body width
  getTreeCenter() {
    return this.treeCenter;
  }
  // + csvCreator
  getAllCols() {
    return this.columns;
  }
  // gridPanel -> ensureColumnVisible
  isColDisplayed(e) {
    return this.getAllCols().indexOf(e) >= 0;
  }
  getLeftColsForRow(e) {
    return this.columnModel.isColSpanActive() ? this.getColsForRow(e, this.columnsLeft) : this.columnsLeft;
  }
  getRightColsForRow(e) {
    return this.columnModel.isColSpanActive() ? this.getColsForRow(e, this.columnsRight) : this.columnsRight;
  }
  getColsForRow(e, t, r, n) {
    const i = [];
    let o = null;
    for (let a = 0; a < t.length; a++) {
      const s = t[a], l = t.length - a, u = Math.min(s.getColSpan(e), l), c = [s];
      if (u > 1) {
        const h = u - 1;
        for (let f = 1; f <= h; f++)
          c.push(t[a + f]);
        a += h;
      }
      let d;
      r ? (d = !1, c.forEach((h) => {
        r(h) && (d = !0);
      })) : d = !0, d && (i.length === 0 && o && (n && n(s)) && i.push(o), i.push(s)), o = s;
    }
    return i;
  }
  // used by:
  // + angularGrid -> for setting body width
  // + rowController -> setting main row widths (when inserting and resizing)
  // need to cache this
  getBodyContainerWidth() {
    return this.bodyWidth;
  }
  getContainerWidth(e) {
    switch (e) {
      case "left":
        return this.leftWidth;
      case "right":
        return this.rightWidth;
      default:
        return this.bodyWidth;
    }
  }
  // + rowController -> while inserting rows
  getCenterCols() {
    return this.columnsCenter;
  }
  // + rowController -> while inserting rows
  getLeftCols() {
    return this.columnsLeft;
  }
  getRightCols() {
    return this.columnsRight;
  }
  getColBefore(e) {
    const t = this.getAllCols(), r = t.indexOf(e);
    return r > 0 ? t[r - 1] : null;
  }
  getGroupAtDirection(e, t) {
    const r = e.getProvidedColumnGroup().getLevel() + e.getPaddingLevel(), n = e.getDisplayedLeafColumns(), i = t === "After" ? Jt(n) : n[0], o = `getCol${t}`;
    for (; ; ) {
      const a = this[o](i);
      if (!a)
        return null;
      const s = this.getColGroupAtLevel(a, r);
      if (s !== e)
        return s;
    }
  }
  getColGroupAtLevel(e, t) {
    let r = e.getParent(), n, i;
    for (; n = r.getProvidedColumnGroup().getLevel(), i = r.getPaddingLevel(), !(n + i <= t); )
      r = r.getParent();
    return r;
  }
  isPinningLeft() {
    return this.columnsLeft.length > 0;
  }
  isPinningRight() {
    return this.columnsRight.length > 0;
  }
  updateColsAndGroupsMap() {
    this.colsAndGroupsMap = {};
    const e = (t) => {
      this.colsAndGroupsMap[t.getUniqueId()] = t;
    };
    Zu(this.treeCenter, !1, e), Zu(this.treeLeft, !1, e), Zu(this.treeRight, !1, e);
  }
  isVisible(e) {
    return this.colsAndGroupsMap[e.getUniqueId()] === e;
  }
  updateOpenClosedVisibilityInColumnGroups() {
    const e = this.getAllTrees();
    Zu(e, !1, (t) => {
      an(t) && t.calculateDisplayedColumns();
    });
  }
  getFirstColumn() {
    const e = this.gos.get("enableRtl"), t = [
      "getLeftCols",
      "getCenterCols",
      "getRightCols"
    ];
    e && t.reverse();
    for (let r = 0; r < t.length; r++) {
      const n = this[t[r]]();
      if (n.length)
        return e ? Jt(n) : n[0];
    }
    return null;
  }
  // returns the group with matching colId and instanceId. If instanceId is missing,
  // matches only on the colId.
  getColumnGroup(e, t) {
    if (!e)
      return null;
    if (an(e))
      return e;
    const r = this.getAllTrees(), n = typeof t == "number";
    let i = null;
    return Zu(r, !1, (o) => {
      if (an(o)) {
        const a = o;
        let s;
        n ? s = e === a.getGroupId() && t === a.getPartId() : s = e === a.getGroupId(), s && (i = a);
      }
    }), i;
  }
  // used by:
  // + rowRenderer -> for navigation
  getColAfter(e) {
    const t = this.getAllCols(), r = t.indexOf(e);
    return r < t.length - 1 ? t[r + 1] : null;
  }
  isBodyWidthDirty() {
    return this.bodyWidthDirty;
  }
  setBodyWidthDirty() {
    this.bodyWidthDirty = !0;
  }
  // used by:
  // + angularGrid -> setting pinned body width
  // note: this should be cached
  getColsLeftWidth() {
    return bs(this.columnsLeft);
  }
  // note: this should be cached
  getDisplayedColumnsRightWidth() {
    return bs(this.columnsRight);
  }
  isColAtEdge(e, t) {
    const r = this.getAllCols();
    if (!r.length)
      return !1;
    const n = t === "first";
    let i;
    if (an(e)) {
      const o = e.getDisplayedLeafColumns();
      if (!o.length)
        return !1;
      i = n ? o[0] : Jt(o);
    } else
      i = e;
    return (n ? r[0] : Jt(r)) === i;
  }
  createGroups(e) {
    const { columns: t, idCreator: r, pinned: n, oldDisplayedGroups: i, isStandaloneStructure: o } = e, a = this.mapOldGroupsById(i), s = [];
    let l = t;
    for (; l.length; ) {
      const u = l;
      l = [];
      let c = 0;
      const d = (h) => {
        const f = c;
        c = h;
        const p = u[f], v = (an(p) ? p.getProvidedColumnGroup() : p).getOriginalParent();
        if (v == null) {
          for (let y = f; y < h; y++)
            s.push(u[y]);
          return;
        }
        const m = this.createColGroup(
          v,
          r,
          a,
          n,
          o
        );
        for (let y = f; y < h; y++)
          m.addChild(u[y]);
        l.push(m);
      };
      for (let h = 1; h < u.length; h++) {
        const f = u[h], g = (an(f) ? f.getProvidedColumnGroup() : f).getOriginalParent(), v = u[c], y = (an(v) ? v.getProvidedColumnGroup() : v).getOriginalParent();
        g !== y && d(h);
      }
      c < u.length && d(u.length);
    }
    return o || this.setupParentsIntoCols(s, null), s;
  }
  createColGroup(e, t, r, n, i) {
    const o = e.getGroupId(), a = t.getInstanceIdForKey(o), s = eK(o, a);
    let l = r[s];
    return l && l.getProvidedColumnGroup() !== e && (l = null), Me(l) ? l.reset() : (l = new tK(e, o, a, n), i || this.createBean(l)), l;
  }
  // returns back a 2d map of ColumnGroup as follows: groupId -> instanceId -> ColumnGroup
  mapOldGroupsById(e) {
    const t = {}, r = (n) => {
      n.forEach((i) => {
        if (an(i)) {
          const o = i;
          t[i.getUniqueId()] = o, r(o.getChildren());
        }
      });
    };
    return e && r(e), t;
  }
  setupParentsIntoCols(e, t) {
    e.forEach((r) => {
      if (r.setParent(t), an(r)) {
        const n = r;
        this.setupParentsIntoCols(n.getChildren(), n);
      }
    });
  }
};
function Zu(e, t, r) {
  if (e)
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (an(i)) {
        const o = t ? i.getDisplayedChildren() : i.getChildren();
        Zu(o, t, r);
      }
      r(i);
    }
}
function Ux(e) {
  const t = [];
  return Zu(e, !0, (r) => {
    Zl(r) && t.push(r);
  }), t;
}
var nK = [
  "columnEverythingChanged",
  "newColumnsLoaded",
  "columnPivotModeChanged",
  "pivotMaxColumnsExceeded",
  "columnRowGroupChanged",
  "expandOrCollapseAll",
  "columnPivotChanged",
  "gridColumnsChanged",
  "columnValueChanged",
  "columnMoved",
  "columnVisible",
  "columnPinned",
  "columnGroupOpened",
  "columnResized",
  "displayedColumnsChanged",
  "virtualColumnsChanged",
  "columnHeaderMouseOver",
  "columnHeaderMouseLeave",
  "columnHeaderClicked",
  "columnHeaderContextMenu",
  "asyncTransactionsFlushed",
  "rowGroupOpened",
  "rowDataUpdated",
  "pinnedRowDataChanged",
  "rangeSelectionChanged",
  "chartCreated",
  "chartRangeSelectionChanged",
  "chartOptionsChanged",
  "chartDestroyed",
  "toolPanelVisibleChanged",
  "toolPanelSizeChanged",
  "modelUpdated",
  "cutStart",
  "cutEnd",
  "pasteStart",
  "pasteEnd",
  "fillStart",
  "fillEnd",
  "rangeDeleteStart",
  "rangeDeleteEnd",
  "undoStarted",
  "undoEnded",
  "redoStarted",
  "redoEnded",
  "cellClicked",
  "cellDoubleClicked",
  "cellMouseDown",
  "cellContextMenu",
  "cellValueChanged",
  "cellEditRequest",
  "rowValueChanged",
  "headerFocused",
  "cellFocused",
  "rowSelected",
  "selectionChanged",
  "tooltipShow",
  "tooltipHide",
  "cellKeyDown",
  "cellMouseOver",
  "cellMouseOut",
  "filterChanged",
  "filterModified",
  "filterOpened",
  "advancedFilterBuilderVisibleChanged",
  "sortChanged",
  "virtualRowRemoved",
  "rowClicked",
  "rowDoubleClicked",
  "gridReady",
  "gridPreDestroyed",
  "gridSizeChanged",
  "viewportChanged",
  "firstDataRendered",
  "dragStarted",
  "dragStopped",
  "rowEditingStarted",
  "rowEditingStopped",
  "cellEditingStarted",
  "cellEditingStopped",
  "bodyScroll",
  "bodyScrollEnd",
  "paginationChanged",
  "componentStateChanged",
  "storeRefreshed",
  "stateUpdated",
  "columnMenuVisibleChanged",
  "contextMenuVisibleChanged",
  "rowDragEnter",
  "rowDragMove",
  "rowDragLeave",
  "rowDragEnd"
], nOe = [
  "scrollbarWidthChanged",
  "keyShortcutChangedCellStart",
  "keyShortcutChangedCellEnd",
  "pinnedHeightChanged",
  "cellFocusCleared",
  "fullWidthRowFocused",
  "checkboxChanged",
  "heightScaleChanged",
  "suppressMovableColumns",
  "suppressMenuHide",
  "suppressFieldDotNotation",
  "columnPanelItemDragStart",
  "columnPanelItemDragEnd",
  "bodyHeightChanged",
  "columnContainerWidthChanged",
  "displayedColumnsWidthChanged",
  "scrollVisibilityChanged",
  "columnHoverChanged",
  "flashCells",
  "paginationPixelOffsetChanged",
  "displayedRowsChanged",
  "leftPinnedWidthChanged",
  "rightPinnedWidthChanged",
  "rowContainerHeightChanged",
  "headerHeightChanged",
  "columnHeaderHeightChanged",
  "gridStylesChanged",
  "storeUpdated",
  "filterDestroyed",
  "rowDataUpdateStarted",
  "rowCountReady",
  "advancedFilterEnabledChanged",
  "dataTypesInferred",
  "fieldValueChanged",
  "fieldPickerValueSelected",
  "richSelectListRowSelected",
  "sideBarUpdated",
  "alignedGridScroll",
  "alignedGridColumn",
  "gridOptionsChanged",
  "chartTitleEdit",
  "recalculateRowBounds",
  "stickyTopOffsetChanged"
], iOe = [...nK, ...nOe], oOe = {
  enableBrowserTooltips: !0,
  tooltipTrigger: !0,
  tooltipMouseTrack: !0,
  tooltipShowMode: !0,
  tooltipInteraction: !0,
  defaultColGroupDef: !0,
  suppressAutoSize: !0,
  skipHeaderOnAutoSize: !0,
  autoSizeStrategy: !0,
  components: !0,
  stopEditingWhenCellsLoseFocus: !0,
  undoRedoCellEditing: !0,
  undoRedoCellEditingLimit: !0,
  excelStyles: !0,
  cacheQuickFilter: !0,
  advancedFilterModel: !0,
  customChartThemes: !0,
  chartThemeOverrides: !0,
  chartToolPanelsDef: !0,
  loadingCellRendererSelector: !0,
  localeText: !0,
  keepDetailRows: !0,
  keepDetailRowsCount: !0,
  detailRowHeight: !0,
  detailRowAutoHeight: !0,
  tabIndex: !0,
  valueCache: !0,
  valueCacheNeverExpires: !0,
  enableCellExpressions: !0,
  suppressTouch: !0,
  suppressAsyncEvents: !0,
  suppressBrowserResizeObserver: !0,
  suppressPropertyNamesCheck: !0,
  debug: !0,
  loadingOverlayComponent: !0,
  suppressLoadingOverlay: !0,
  noRowsOverlayComponent: !0,
  paginationPageSizeSelector: !0,
  paginateChildRows: !0,
  pivotPanelShow: !0,
  pivotSuppressAutoColumn: !0,
  suppressExpandablePivotGroups: !0,
  aggFuncs: !0,
  suppressAggFuncInHeader: !0,
  removePivotHeaderRowWhenSingleValueColumn: !0,
  allowShowChangeAfterFilter: !0,
  ensureDomOrder: !0,
  enableRtl: !0,
  suppressColumnVirtualisation: !0,
  suppressMaxRenderedRowRestriction: !0,
  suppressRowVirtualisation: !0,
  rowDragText: !0,
  suppressGroupMaintainValueType: !0,
  groupLockGroupColumns: !0,
  rowGroupPanelSuppressSort: !0,
  suppressGroupRowsSticky: !0,
  rowModelType: !0,
  cacheOverflowSize: !0,
  infiniteInitialRowCount: !0,
  serverSideInitialRowCount: !0,
  suppressServerSideInfiniteScroll: !0,
  maxBlocksInCache: !0,
  maxConcurrentDatasourceRequests: !0,
  blockLoadDebounceMillis: !0,
  serverSideOnlyRefreshFilteredGroups: !0,
  serverSidePivotResultFieldSeparator: !0,
  viewportRowModelPageSize: !0,
  viewportRowModelBufferSize: !0,
  debounceVerticalScrollbar: !0,
  suppressAnimationFrame: !0,
  suppressPreventDefaultOnMouseWheel: !0,
  scrollbarWidth: !0,
  icons: !0,
  suppressRowTransform: !0,
  gridId: !0,
  enableGroupEdit: !0,
  initialState: !0,
  processUnpinnedColumns: !0,
  createChartContainer: !0,
  getLocaleText: !0,
  getRowId: !0,
  reactiveCustomComponents: !0,
  columnMenu: !0
}, Zn = class {
};
Zn.STRING_PROPERTIES = [
  "rowSelection",
  "overlayLoadingTemplate",
  "overlayNoRowsTemplate",
  "gridId",
  "quickFilterText",
  "rowModelType",
  "editType",
  "domLayout",
  "clipboardDelimiter",
  "rowGroupPanelShow",
  "multiSortKey",
  "pivotColumnGroupTotals",
  "pivotRowTotals",
  "pivotPanelShow",
  "fillHandleDirection",
  "groupDisplayType",
  "treeDataDisplayType",
  "colResizeDefault",
  "tooltipTrigger",
  "serverSidePivotResultFieldSeparator",
  "columnMenu",
  "tooltipShowMode",
  "grandTotalRow"
];
Zn.OBJECT_PROPERTIES = [
  "components",
  "rowStyle",
  "context",
  "autoGroupColumnDef",
  "localeText",
  "icons",
  "datasource",
  "serverSideDatasource",
  "viewportDatasource",
  "groupRowRendererParams",
  "aggFuncs",
  "fullWidthCellRendererParams",
  "defaultColGroupDef",
  "defaultColDef",
  "defaultCsvExportParams",
  "defaultExcelExportParams",
  "columnTypes",
  "rowClassRules",
  "detailCellRendererParams",
  "loadingCellRendererParams",
  "loadingOverlayComponentParams",
  "noRowsOverlayComponentParams",
  "popupParent",
  "statusBar",
  "sideBar",
  "chartThemeOverrides",
  "customChartThemes",
  "chartToolPanelsDef",
  "dataTypeDefinitions",
  "advancedFilterModel",
  "advancedFilterParent",
  "advancedFilterBuilderParams",
  "initialState",
  "autoSizeStrategy"
];
Zn.ARRAY_PROPERTIES = [
  "sortingOrder",
  "alignedGrids",
  "rowData",
  "columnDefs",
  "excelStyles",
  "pinnedTopRowData",
  "pinnedBottomRowData",
  "chartThemes",
  "rowClass",
  "paginationPageSizeSelector"
];
Zn.NUMBER_PROPERTIES = [
  "rowHeight",
  "detailRowHeight",
  "rowBuffer",
  "headerHeight",
  "groupHeaderHeight",
  "groupLockGroupColumns",
  "floatingFiltersHeight",
  "pivotHeaderHeight",
  "pivotGroupHeaderHeight",
  "groupDefaultExpanded",
  "pivotDefaultExpanded",
  "viewportRowModelPageSize",
  "viewportRowModelBufferSize",
  "autoSizePadding",
  "maxBlocksInCache",
  "maxConcurrentDatasourceRequests",
  "tooltipShowDelay",
  "tooltipHideDelay",
  "cacheOverflowSize",
  "paginationPageSize",
  "cacheBlockSize",
  "infiniteInitialRowCount",
  "serverSideInitialRowCount",
  "scrollbarWidth",
  "asyncTransactionWaitMillis",
  "blockLoadDebounceMillis",
  "keepDetailRowsCount",
  "undoRedoCellEditingLimit",
  "cellFlashDelay",
  "cellFadeDelay",
  "cellFlashDuration",
  "cellFadeDuration",
  "tabIndex",
  "pivotMaxGeneratedColumns"
];
Zn.BOOLEAN_PROPERTIES = [
  "suppressMakeColumnVisibleAfterUnGroup",
  "suppressRowClickSelection",
  "suppressCellFocus",
  "suppressHeaderFocus",
  "suppressHorizontalScroll",
  "groupSelectsChildren",
  "alwaysShowHorizontalScroll",
  "alwaysShowVerticalScroll",
  "debug",
  "enableBrowserTooltips",
  "enableCellExpressions",
  "groupIncludeTotalFooter",
  "groupSuppressBlankHeader",
  "suppressMenuHide",
  "suppressRowDeselection",
  "unSortIcon",
  "suppressMultiSort",
  "alwaysMultiSort",
  "singleClickEdit",
  "suppressLoadingOverlay",
  "suppressNoRowsOverlay",
  "suppressAutoSize",
  "skipHeaderOnAutoSize",
  "suppressColumnMoveAnimation",
  "suppressMovableColumns",
  "suppressFieldDotNotation",
  "enableRangeSelection",
  "enableRangeHandle",
  "enableFillHandle",
  "suppressClearOnFillReduction",
  "deltaSort",
  "suppressTouch",
  "suppressAsyncEvents",
  "allowContextMenuWithControlKey",
  "suppressContextMenu",
  "enableCellChangeFlash",
  "suppressDragLeaveHidesColumns",
  "suppressRowGroupHidesColumns",
  "suppressMiddleClickScrolls",
  "suppressPreventDefaultOnMouseWheel",
  "suppressCopyRowsToClipboard",
  "copyHeadersToClipboard",
  "copyGroupHeadersToClipboard",
  "pivotMode",
  "suppressAggFuncInHeader",
  "suppressColumnVirtualisation",
  "alwaysAggregateAtRootLevel",
  "suppressFocusAfterRefresh",
  "functionsReadOnly",
  "animateRows",
  "groupSelectsFiltered",
  "groupRemoveSingleChildren",
  "groupRemoveLowestSingleChildren",
  "enableRtl",
  "suppressClickEdit",
  "rowDragEntireRow",
  "rowDragManaged",
  "suppressRowDrag",
  "suppressMoveWhenRowDragging",
  "rowDragMultiRow",
  "enableGroupEdit",
  "embedFullWidthRows",
  "suppressPaginationPanel",
  "groupHideOpenParents",
  "groupAllowUnbalanced",
  "pagination",
  "paginationAutoPageSize",
  "suppressScrollOnNewData",
  "suppressScrollWhenPopupsAreOpen",
  "purgeClosedRowNodes",
  "cacheQuickFilter",
  "includeHiddenColumnsInQuickFilter",
  "ensureDomOrder",
  "accentedSort",
  "suppressChangeDetection",
  "valueCache",
  "valueCacheNeverExpires",
  "aggregateOnlyChangedColumns",
  "suppressAnimationFrame",
  "suppressExcelExport",
  "suppressCsvExport",
  "includeHiddenColumnsInAdvancedFilter",
  "suppressMultiRangeSelection",
  "enterNavigatesVerticallyAfterEdit",
  "enterNavigatesVertically",
  "suppressPropertyNamesCheck",
  "rowMultiSelectWithClick",
  "suppressRowHoverHighlight",
  "suppressRowTransform",
  "suppressClipboardPaste",
  "suppressLastEmptyLineOnPaste",
  "enableCharts",
  "suppressMaintainUnsortedOrder",
  "enableCellTextSelection",
  "suppressBrowserResizeObserver",
  "suppressMaxRenderedRowRestriction",
  "excludeChildrenWhenTreeDataFiltering",
  "tooltipMouseTrack",
  "tooltipInteraction",
  "keepDetailRows",
  "paginateChildRows",
  "preventDefaultOnContextMenu",
  "undoRedoCellEditing",
  "allowDragFromColumnsToolPanel",
  "pivotSuppressAutoColumn",
  "suppressExpandablePivotGroups",
  "debounceVerticalScrollbar",
  "detailRowAutoHeight",
  "serverSideSortAllLevels",
  "serverSideEnableClientSideSort",
  "serverSideOnlyRefreshFilteredGroups",
  "serverSideSortOnServer",
  "serverSideFilterOnServer",
  "suppressAggFilteredOnly",
  "showOpenedGroup",
  "suppressClipboardApi",
  "suppressModelUpdateAfterUpdateTransaction",
  "stopEditingWhenCellsLoseFocus",
  "maintainColumnOrder",
  "groupMaintainOrder",
  "columnHoverHighlight",
  "readOnlyEdit",
  "suppressRowVirtualisation",
  "enableCellEditingOnBackspace",
  "resetRowDataOnUpdate",
  "removePivotHeaderRowWhenSingleValueColumn",
  "suppressCopySingleCellRanges",
  "suppressGroupRowsSticky",
  "suppressCutToClipboard",
  "suppressServerSideInfiniteScroll",
  "rowGroupPanelSuppressSort",
  "allowShowChangeAfterFilter",
  "enableAdvancedFilter",
  "masterDetail",
  "treeData",
  "suppressGroupMaintainValueType",
  "reactiveCustomComponents",
  "applyQuickFilterBeforePivotOrAgg",
  "suppressServerSideFullWidthLoadingRow",
  "suppressAdvancedFilterEval",
  "loading"
];
Zn.OTHER_PROPERTIES = ["suppressStickyTotalRow"];
Zn.FUNCTION_PROPERTIES = [
  "doesExternalFilterPass",
  "processPivotResultColDef",
  "processPivotResultColGroupDef",
  "getBusinessKeyForNode",
  "isRowSelectable",
  "rowDragText",
  "groupRowRenderer",
  "fullWidthCellRenderer",
  "loadingCellRenderer",
  "loadingOverlayComponent",
  "noRowsOverlayComponent",
  "detailCellRenderer",
  "quickFilterParser",
  "quickFilterMatcher",
  "getLocaleText",
  "isExternalFilterPresent",
  "getRowHeight",
  "getRowClass",
  "getRowStyle",
  "getContextMenuItems",
  "getMainMenuItems",
  "processRowPostCreate",
  "processCellForClipboard",
  "getGroupRowAgg",
  "isFullWidthRow",
  "sendToClipboard",
  "focusGridInnerElement",
  "navigateToNextHeader",
  "tabToNextHeader",
  "navigateToNextCell",
  "tabToNextCell",
  "processCellFromClipboard",
  "getDocument",
  "postProcessPopup",
  "getChildCount",
  "getDataPath",
  "isRowMaster",
  "postSortRows",
  "processHeaderForClipboard",
  "processUnpinnedColumns",
  "processGroupHeaderForClipboard",
  "paginationNumberFormatter",
  "processDataFromClipboard",
  "getServerSideGroupKey",
  "isServerSideGroup",
  "createChartContainer",
  "getChartToolbarItems",
  "fillOperation",
  "isApplyServerSideTransaction",
  "getServerSideGroupLevelParams",
  "isServerSideGroupOpenByDefault",
  "isGroupOpenByDefault",
  "initialGroupOrderComparator",
  "groupIncludeFooter",
  "loadingCellRendererSelector",
  "getRowId",
  "groupAggFiltering",
  "chartMenuItems",
  "groupTotalRow"
];
Zn.ALL_PROPERTIES = [
  ...Zn.ARRAY_PROPERTIES,
  ...Zn.OBJECT_PROPERTIES,
  ...Zn.STRING_PROPERTIES,
  ...Zn.NUMBER_PROPERTIES,
  ...Zn.FUNCTION_PROPERTIES,
  ...Zn.BOOLEAN_PROPERTIES,
  ...Zn.OTHER_PROPERTIES
];
var iv = Zn, Ao = class {
  static getCallbackForEvent(t) {
    return !t || t.length < 2 ? t : "on" + t[0].toUpperCase() + t.substring(1);
  }
};
Ao.VUE_OMITTED_PROPERTY = "AG-VUE-OMITTED-PROPERTY";
Ao.PUBLIC_EVENTS = nK;
Ao.EVENT_CALLBACKS = iOe.map((e) => Ao.getCallbackForEvent(e));
Ao.BOOLEAN_PROPERTIES = iv.BOOLEAN_PROPERTIES;
Ao.ALL_PROPERTIES = iv.ALL_PROPERTIES;
Ao.ALL_PROPERTIES_AND_CALLBACKS = [...Ao.ALL_PROPERTIES, ...Ao.EVENT_CALLBACKS];
Ao.ALL_PROPERTIES_AND_CALLBACKS_SET = new Set(Ao.ALL_PROPERTIES_AND_CALLBACKS);
var ov = Ao;
function aOe(e, t) {
  typeof e != "object" && (e = {});
  const r = { ...e };
  return ov.ALL_PROPERTIES_AND_CALLBACKS.forEach((i) => {
    const o = t[i];
    typeof o < "u" && o !== ov.VUE_OMITTED_PROPERTY && (r[i] = o);
  }), r;
}
function sOe(e, t) {
  if (!e)
    return;
  const r = {};
  let n = !1;
  if (Object.keys(e).filter((a) => ov.ALL_PROPERTIES_AND_CALLBACKS_SET.has(a)).forEach((a) => {
    r[a] = e[a], n = !0;
  }), !n)
    return;
  const i = {
    type: "gridOptionsChanged",
    options: r
  };
  t.dispatchEvent(i);
  const o = {
    type: "componentStateChanged"
  };
  ia(r, (a, s) => {
    o[a] = s;
  }), t.dispatchEvent(o);
}
var Kv = class {
  constructor(e) {
    this.cssClassStates = {}, this.getGui = e;
  }
  addCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((n) => this.addCssClass(n));
      return;
    }
    if (this.cssClassStates[e] !== !0 && e.length) {
      const n = this.getGui();
      n && n.classList.add(e), this.cssClassStates[e] = !0;
    }
  }
  removeCssClass(e) {
    const t = (e || "").split(" ");
    if (t.length > 1) {
      t.forEach((n) => this.removeCssClass(n));
      return;
    }
    if (this.cssClassStates[e] !== !1 && e.length) {
      const n = this.getGui();
      n && n.classList.remove(e), this.cssClassStates[e] = !1;
    }
  }
  containsCssClass(e) {
    const t = this.getGui();
    return t ? t.classList.contains(e) : !1;
  }
  addOrRemoveCssClass(e, t) {
    if (!e)
      return;
    if (e.indexOf(" ") >= 0) {
      const n = (e || "").split(" ");
      if (n.length > 1) {
        n.forEach((i) => this.addOrRemoveCssClass(i, t));
        return;
      }
    }
    if (this.cssClassStates[e] !== t && e.length) {
      const n = this.getGui();
      n && n.classList.toggle(e, t), this.cssClassStates[e] = t;
    }
  }
};
function el(e, t, r) {
  r == null || typeof r == "string" && r == "" ? iK(e, t) : ss(e, t, r);
}
function ss(e, t, r) {
  e.setAttribute(oK(t), r.toString());
}
function iK(e, t) {
  e.removeAttribute(oK(t));
}
function oK(e) {
  return `aria-${e}`;
}
function Sa(e, t) {
  t ? e.setAttribute("role", t) : e.removeAttribute("role");
}
function lOe(e) {
  let t;
  return e === "asc" ? t = "ascending" : e === "desc" ? t = "descending" : e === "mixed" ? t = "other" : t = "none", t;
}
function uOe(e) {
  return e.getAttribute("aria-label");
}
function $h(e, t) {
  el(e, "label", t);
}
function av(e, t) {
  el(e, "labelledby", t);
}
function aK(e, t) {
  el(e, "live", t);
}
function cOe(e, t) {
  el(e, "atomic", t);
}
function dOe(e, t) {
  el(e, "relevant", t);
}
function hOe(e, t) {
  el(e, "disabled", t);
}
function yA(e, t) {
  el(e, "hidden", t);
}
function HC(e, t) {
  ss(e, "expanded", t);
}
function fOe(e, t) {
  ss(e, "setsize", t);
}
function pOe(e, t) {
  ss(e, "posinset", t);
}
function gOe(e, t) {
  ss(e, "rowcount", t);
}
function vOe(e, t) {
  ss(e, "rowindex", t);
}
function mOe(e, t) {
  ss(e, "colcount", t);
}
function sK(e, t) {
  ss(e, "colindex", t);
}
function yOe(e, t) {
  ss(e, "colspan", t);
}
function COe(e, t) {
  ss(e, "sort", t);
}
function SOe(e) {
  iK(e, "sort");
}
function zC(e, t) {
  el(e, "selected", t);
}
function wOe(e, t) {
  el(e, "controls", t.id), av(t, e.id);
}
function CA(e, t) {
  return t === void 0 ? e("ariaIndeterminate", "indeterminate") : t === !0 ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked");
}
var Kx, Ry, Yx, qx, Zx, Xx, RT, _T;
function Zs() {
  return Kx === void 0 && (Kx = /^((?!chrome|android).)*safari/i.test(navigator.userAgent)), Kx;
}
function lK() {
  if (Ry === void 0)
    if (Zs()) {
      const e = navigator.userAgent.match(/version\/(\d+)/i);
      e && (Ry = e[1] != null ? parseFloat(e[1]) : 0);
    } else
      Ry = 0;
  return Ry;
}
function SA() {
  if (Yx === void 0) {
    const e = window;
    Yx = !!e.chrome && (!!e.chrome.webstore || !!e.chrome.runtime) || /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
  }
  return Yx;
}
function uK() {
  return qx === void 0 && (qx = /(firefox)/i.test(navigator.userAgent)), qx;
}
function cK() {
  return Zx === void 0 && (Zx = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform)), Zx;
}
function su() {
  return Xx === void 0 && (Xx = /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1), Xx;
}
function DG() {
  return !Zs() || lK() >= 15;
}
function TT(e) {
  if (!e)
    return null;
  const t = e.tabIndex, r = e.getAttribute("tabIndex");
  return t === -1 && (r === null || r === "" && !uK()) ? null : t.toString();
}
function bOe() {
  if (!document.body)
    return -1;
  let e = 1e6;
  const t = navigator.userAgent.toLowerCase().match(/firefox/) ? 6e6 : 1e9, r = document.createElement("div");
  for (document.body.appendChild(r); ; ) {
    const n = e * 2;
    if (r.style.height = n + "px", n > t || r.clientHeight !== n)
      break;
    e = n;
  }
  return document.body.removeChild(r), e;
}
function xOe() {
  var e, t;
  return ((e = document.body) == null ? void 0 : e.clientWidth) ?? (window.innerHeight || ((t = document.documentElement) == null ? void 0 : t.clientWidth) || -1);
}
function EOe() {
  var e, t;
  return ((e = document.body) == null ? void 0 : e.clientHeight) ?? (window.innerHeight || ((t = document.documentElement) == null ? void 0 : t.clientHeight) || -1);
}
function ROe() {
  return _T == null && dK(), _T;
}
function dK() {
  const e = document.body, t = document.createElement("div");
  t.style.width = t.style.height = "100px", t.style.opacity = "0", t.style.overflow = "scroll", t.style.msOverflowStyle = "scrollbar", t.style.position = "absolute", e.appendChild(t);
  let r = t.offsetWidth - t.clientWidth;
  r === 0 && t.clientWidth === 0 && (r = null), t.parentNode && t.parentNode.removeChild(t), r != null && (_T = r, RT = r === 0);
}
function hK() {
  return RT == null && dK(), RT;
}
var _y, _Oe = "[tabindex], input, select, button, textarea, [href]", fK = "[disabled], .ag-disabled:not(.ag-button), .ag-disabled *";
function wA(e) {
  const t = Element.prototype.matches || Element.prototype.msMatchesSelector, n = t.call(e, "input, select, button, textarea"), i = t.call(e, fK), o = ts(e);
  return n && !i && o;
}
function jr(e, t, r = {}) {
  const { skipAriaHidden: n } = r;
  e.classList.toggle("ag-hidden", !t), n || yA(e, !t);
}
function TOe(e, t, r = {}) {
  const { skipAriaHidden: n } = r;
  e.classList.toggle("ag-invisible", !t), n || yA(e, !t);
}
function sv(e, t) {
  const r = "disabled", n = t ? (i) => i.setAttribute(r, "") : (i) => i.removeAttribute(r);
  n(e), mK(e.querySelectorAll("input"), (i) => n(i));
}
function wh(e, t, r) {
  let n = 0;
  for (; e; ) {
    if (e.classList.contains(t))
      return !0;
    if (e = e.parentElement, typeof r == "number") {
      if (++n > r)
        break;
    } else if (e === r)
      break;
  }
  return !1;
}
function ed(e) {
  const {
    height: t,
    width: r,
    borderTopWidth: n,
    borderRightWidth: i,
    borderBottomWidth: o,
    borderLeftWidth: a,
    paddingTop: s,
    paddingRight: l,
    paddingBottom: u,
    paddingLeft: c,
    marginTop: d,
    marginRight: h,
    marginBottom: f,
    marginLeft: p,
    boxSizing: g
  } = window.getComputedStyle(e);
  return {
    height: parseFloat(t || "0"),
    width: parseFloat(r || "0"),
    borderTopWidth: parseFloat(n || "0"),
    borderRightWidth: parseFloat(i || "0"),
    borderBottomWidth: parseFloat(o || "0"),
    borderLeftWidth: parseFloat(a || "0"),
    paddingTop: parseFloat(s || "0"),
    paddingRight: parseFloat(l || "0"),
    paddingBottom: parseFloat(u || "0"),
    paddingLeft: parseFloat(c || "0"),
    marginTop: parseFloat(d || "0"),
    marginRight: parseFloat(h || "0"),
    marginBottom: parseFloat(f || "0"),
    marginLeft: parseFloat(p || "0"),
    boxSizing: g
  };
}
function bA(e) {
  const t = ed(e);
  return t.boxSizing === "border-box" ? t.height - t.paddingTop - t.paddingBottom : t.height;
}
function Yv(e) {
  const t = ed(e);
  return t.boxSizing === "border-box" ? t.width - t.paddingLeft - t.paddingRight : t.width;
}
function pK(e) {
  const { height: t, marginBottom: r, marginTop: n } = ed(e);
  return Math.floor(t + r + n);
}
function $C(e) {
  const { width: t, marginLeft: r, marginRight: n } = ed(e);
  return Math.floor(t + r + n);
}
function gK(e) {
  const t = e.getBoundingClientRect(), { borderTopWidth: r, borderLeftWidth: n, borderRightWidth: i, borderBottomWidth: o } = ed(e);
  return {
    top: t.top + (r || 0),
    left: t.left + (n || 0),
    right: t.right + (i || 0),
    bottom: t.bottom + (o || 0)
  };
}
function WC() {
  if (typeof _y == "boolean")
    return _y;
  const e = document.createElement("div");
  return e.style.direction = "rtl", e.style.width = "1px", e.style.height = "1px", e.style.position = "fixed", e.style.top = "0px", e.style.overflow = "hidden", e.dir = "rtl", e.innerHTML = /* html */
  `<div style="width: 2px">
            <span style="display: inline-block; width: 1px"></span>
            <span style="display: inline-block; width: 1px"></span>
        </div>`, document.body.appendChild(e), e.scrollLeft = 1, _y = Math.floor(e.scrollLeft) === 0, document.body.removeChild(e), _y;
}
function jC(e, t) {
  let r = e.scrollLeft;
  return t && (r = Math.abs(r), SA() && !WC() && (r = e.scrollWidth - e.clientWidth - r)), r;
}
function UC(e, t, r) {
  r && (WC() ? t *= -1 : (Zs() || SA()) && (t = e.scrollWidth - e.clientWidth - t)), e.scrollLeft = t;
}
function oo(e) {
  for (; e && e.firstChild; )
    e.removeChild(e.firstChild);
}
function Oc(e) {
  e && e.parentNode && e.parentNode.removeChild(e);
}
function vK(e) {
  return !!e.offsetParent;
}
function ts(e) {
  const t = e;
  return t.checkVisibility ? t.checkVisibility({ checkVisibilityCSS: !0 }) : !(!vK(e) || window.getComputedStyle(e).visibility !== "visible");
}
function Wh(e) {
  const t = document.createElement("div");
  return t.innerHTML = (e || "").trim(), t.firstChild;
}
function POe(e) {
  return e.clientWidth < e.scrollWidth;
}
function MOe(e) {
  return e.clientHeight < e.scrollHeight;
}
function KC(e, t) {
  t === "flex" ? (e.style.removeProperty("width"), e.style.removeProperty("minWidth"), e.style.removeProperty("maxWidth"), e.style.flex = "1 1 auto") : pa(e, t);
}
function pa(e, t) {
  t = xA(t), e.style.width = t.toString(), e.style.maxWidth = t.toString(), e.style.minWidth = t.toString();
}
function cg(e, t) {
  t = xA(t), e.style.height = t.toString(), e.style.maxHeight = t.toString(), e.style.minHeight = t.toString();
}
function xA(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function EA(e) {
  return e instanceof Node || e instanceof HTMLElement;
}
function DOe(e) {
  if (e == null)
    return [];
  const t = [];
  return mK(e, (r) => t.push(r)), t;
}
function AOe(e, t) {
  if (e)
    for (let r = 0; r < e.length; r++) {
      const n = e[r];
      t(n.name, n.value);
    }
}
function Ls(e, t, r) {
  r == null ? e.removeAttribute(t) : e.setAttribute(t, r.toString());
}
function mK(e, t) {
  if (e != null)
    for (let r = 0; r < e.length; r++)
      t(e[r]);
}
var jh = class {
  constructor(e = 0, t = 1) {
    this.nextValue = e, this.step = t;
  }
  next() {
    const e = this.nextValue;
    return this.nextValue += this.step, e;
  }
  peek() {
    return this.nextValue;
  }
  skip(e) {
    this.nextValue += e;
  }
}, IOe = 1e3, FOe = 1e3, AG = 100, yK = class $u extends he {
  constructor(t, r, n, i) {
    super(), this.parentComp = t, this.tooltipShowDelayOverride = r, this.tooltipHideDelayOverride = n, this.shouldDisplayTooltip = i, this.interactionEnabled = !1, this.isInteractingWithTooltip = !1, this.state = 0, this.tooltipInstanceCount = 0, this.tooltipMouseTrack = !1;
  }
  wireBeans(t) {
    this.popupService = t.popupService, this.userComponentFactory = t.userComponentFactory;
  }
  postConstruct() {
    this.gos.get("tooltipInteraction") && (this.interactionEnabled = !0), this.tooltipTrigger = this.getTooltipTrigger(), this.tooltipMouseTrack = this.gos.get("tooltipMouseTrack");
    const t = this.parentComp.getGui();
    this.tooltipTrigger === 0 && this.addManagedListeners(t, {
      mouseenter: this.onMouseEnter.bind(this),
      mouseleave: this.onMouseLeave.bind(this)
    }), this.tooltipTrigger === 1 && this.addManagedListeners(t, {
      focusin: this.onFocusIn.bind(this),
      focusout: this.onFocusOut.bind(this)
    }), this.addManagedListeners(t, { mousemove: this.onMouseMove.bind(this) }), this.interactionEnabled || this.addManagedListeners(t, {
      mousedown: this.onMouseDown.bind(this),
      keydown: this.onKeyDown.bind(this)
    });
  }
  getGridOptionsTooltipDelay(t) {
    const r = this.gos.get(t);
    return r < 0 && Se(`${t} should not be lower than 0`), Math.max(200, r);
  }
  getTooltipDelay(t) {
    return t === "show" ? this.tooltipShowDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipShowDelay") : this.tooltipHideDelayOverride ?? this.getGridOptionsTooltipDelay("tooltipHideDelay");
  }
  destroy() {
    this.setToDoNothing(), super.destroy();
  }
  getTooltipTrigger() {
    const t = this.gos.get("tooltipTrigger");
    return !t || t === "hover" ? 0 : 1;
  }
  onMouseEnter(t) {
    this.interactionEnabled && this.interactiveTooltipTimeoutId && (this.unlockService(), this.startHideTimeout()), !su() && ($u.isLocked ? this.showTooltipTimeoutId = window.setTimeout(() => {
      this.prepareToShowTooltip(t);
    }, AG) : this.prepareToShowTooltip(t));
  }
  onMouseMove(t) {
    this.lastMouseEvent && (this.lastMouseEvent = t), this.tooltipMouseTrack && this.state === 2 && this.tooltipComp && this.positionTooltip();
  }
  onMouseDown() {
    this.setToDoNothing();
  }
  onMouseLeave() {
    this.interactionEnabled ? this.lockService() : this.setToDoNothing();
  }
  onFocusIn() {
    this.prepareToShowTooltip();
  }
  onFocusOut(t) {
    var o;
    const r = t.relatedTarget, n = this.parentComp.getGui(), i = (o = this.tooltipComp) == null ? void 0 : o.getGui();
    this.isInteractingWithTooltip || n.contains(r) || this.interactionEnabled && (i != null && i.contains(r)) || this.setToDoNothing();
  }
  onKeyDown() {
    this.setToDoNothing();
  }
  prepareToShowTooltip(t) {
    if (this.state != 0 || $u.isLocked)
      return;
    let r = 0;
    t && (r = this.isLastTooltipHiddenRecently() ? 200 : this.getTooltipDelay("show")), this.lastMouseEvent = t || null, this.showTooltipTimeoutId = window.setTimeout(this.showTooltip.bind(this), r), this.state = 1;
  }
  isLastTooltipHiddenRecently() {
    const t = (/* @__PURE__ */ new Date()).getTime(), r = $u.lastTooltipHideTime;
    return t - r < IOe;
  }
  setToDoNothing() {
    this.state === 2 && this.hideTooltip(), this.onBodyScrollEventCallback && (this.onBodyScrollEventCallback(), this.onBodyScrollEventCallback = void 0), this.onColumnMovedEventCallback && (this.onColumnMovedEventCallback(), this.onColumnMovedEventCallback = void 0), this.clearTimeouts(), this.state = 0, this.lastMouseEvent = null;
  }
  showTooltip() {
    const t = {
      ...this.parentComp.getTooltipParams()
    };
    if (!Me(t.value) || this.shouldDisplayTooltip && !this.shouldDisplayTooltip()) {
      this.setToDoNothing();
      return;
    }
    this.state = 2, this.tooltipInstanceCount++;
    const r = this.newTooltipComponentCallback.bind(this, this.tooltipInstanceCount);
    this.userComponentFactory.getTooltipCompDetails(t).newAgStackInstance().then(r);
  }
  hideTooltip(t) {
    if (!t && this.isInteractingWithTooltip)
      return;
    this.tooltipComp && (this.destroyTooltipComp(), $u.lastTooltipHideTime = (/* @__PURE__ */ new Date()).getTime());
    const r = {
      type: "tooltipHide",
      parentGui: this.parentComp.getGui()
    };
    this.eventService.dispatchEvent(r), t && (this.isInteractingWithTooltip = !1), this.state = 0;
  }
  newTooltipComponentCallback(t, r) {
    if (this.state !== 2 || this.tooltipInstanceCount !== t) {
      this.destroyBean(r);
      return;
    }
    const i = r.getGui();
    this.tooltipComp = r, i.classList.contains("ag-tooltip") || i.classList.add("ag-tooltip-custom"), this.tooltipTrigger === 0 && i.classList.add("ag-tooltip-animate"), this.interactionEnabled && i.classList.add("ag-tooltip-interactive");
    const o = this.localeService.getLocaleTextFunc(), a = this.popupService.addPopup({
      eChild: i,
      ariaLabel: o("ariaLabelTooltip", "Tooltip")
    });
    if (a && (this.tooltipPopupDestroyFunc = a.hideFunc), this.positionTooltip(), this.tooltipTrigger === 1) {
      const l = this.setToDoNothing.bind(this);
      [this.onBodyScrollEventCallback, this.onColumnMovedEventCallback] = this.addManagedEventListeners({
        bodyScroll: l,
        columnMoved: l
      });
    }
    this.interactionEnabled && (this.tooltipTrigger === 0 ? [this.tooltipMouseEnterListener, this.tooltipMouseLeaveListener] = this.addManagedElementListeners(
      i,
      {
        mouseenter: this.onTooltipMouseEnter.bind(this),
        mouseleave: this.onTooltipMouseLeave.bind(this)
      }
    ) : [this.tooltipFocusInListener, this.tooltipFocusOutListener] = this.addManagedElementListeners(i, {
      focusin: this.onTooltipFocusIn.bind(this),
      focusout: this.onTooltipFocusOut.bind(this)
    }));
    const s = {
      type: "tooltipShow",
      tooltipGui: i,
      parentGui: this.parentComp.getGui()
    };
    this.eventService.dispatchEvent(s), this.startHideTimeout();
  }
  onTooltipMouseEnter() {
    this.isInteractingWithTooltip = !0, this.unlockService();
  }
  onTooltipMouseLeave() {
    this.isInteractingWithTooltip = !1, this.lockService();
  }
  onTooltipFocusIn() {
    this.isInteractingWithTooltip = !0;
  }
  onTooltipFocusOut(t) {
    var o;
    const r = this.parentComp.getGui(), n = (o = this.tooltipComp) == null ? void 0 : o.getGui(), i = t.relatedTarget;
    n != null && n.contains(i) || (this.isInteractingWithTooltip = !1, r.contains(i) ? this.startHideTimeout() : this.hideTooltip());
  }
  positionTooltip() {
    const t = {
      type: "tooltip",
      ePopup: this.tooltipComp.getGui(),
      nudgeY: 18,
      skipObserver: this.tooltipMouseTrack
    };
    this.lastMouseEvent ? this.popupService.positionPopupUnderMouseEvent({
      ...t,
      mouseEvent: this.lastMouseEvent
    }) : this.popupService.positionPopupByComponent({
      ...t,
      eventSource: this.parentComp.getGui(),
      position: "under",
      keepWithinBounds: !0,
      nudgeY: 5
    });
  }
  destroyTooltipComp() {
    this.tooltipComp.getGui().classList.add("ag-tooltip-hiding");
    const t = this.tooltipPopupDestroyFunc, r = this.tooltipComp, n = this.tooltipTrigger === 0 ? FOe : 0;
    window.setTimeout(() => {
      t(), this.destroyBean(r);
    }, n), this.clearTooltipListeners(), this.tooltipPopupDestroyFunc = void 0, this.tooltipComp = void 0;
  }
  clearTooltipListeners() {
    [
      this.tooltipMouseEnterListener,
      this.tooltipMouseLeaveListener,
      this.tooltipFocusInListener,
      this.tooltipFocusOutListener
    ].forEach((t) => {
      t && t();
    }), this.tooltipMouseEnterListener = this.tooltipMouseLeaveListener = this.tooltipFocusInListener = this.tooltipFocusOutListener = null;
  }
  lockService() {
    $u.isLocked = !0, this.interactiveTooltipTimeoutId = window.setTimeout(() => {
      this.unlockService(), this.setToDoNothing();
    }, AG);
  }
  unlockService() {
    $u.isLocked = !1, this.clearInteractiveTimeout();
  }
  startHideTimeout() {
    this.clearHideTimeout(), this.hideTooltipTimeoutId = window.setTimeout(this.hideTooltip.bind(this), this.getTooltipDelay("hide"));
  }
  clearShowTimeout() {
    this.showTooltipTimeoutId && (window.clearTimeout(this.showTooltipTimeoutId), this.showTooltipTimeoutId = void 0);
  }
  clearHideTimeout() {
    this.hideTooltipTimeoutId && (window.clearTimeout(this.hideTooltipTimeoutId), this.hideTooltipTimeoutId = void 0);
  }
  clearInteractiveTimeout() {
    this.interactiveTooltipTimeoutId && (window.clearTimeout(this.interactiveTooltipTimeoutId), this.interactiveTooltipTimeoutId = void 0);
  }
  clearTimeouts() {
    this.clearShowTimeout(), this.clearHideTimeout(), this.clearInteractiveTimeout();
  }
};
yK.isLocked = !1;
var LOe = yK, bf = class extends he {
  constructor(e, t) {
    super(), this.ctrl = e, t && (this.beans = t);
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.refreshToolTip();
  }
  setBrowserTooltip(e) {
    const t = "title", r = this.ctrl.getGui();
    r && (e != null && e != "" ? r.setAttribute(t, e) : r.removeAttribute(t));
  }
  updateTooltipText() {
    this.tooltip = this.ctrl.getTooltipValue();
  }
  createTooltipFeatureIfNeeded() {
    var t, r, n, i;
    if (this.tooltipManager != null)
      return;
    const e = {
      getTooltipParams: () => this.getTooltipParams(),
      getGui: () => this.ctrl.getGui()
    };
    this.tooltipManager = this.createBean(
      new LOe(
        e,
        (r = (t = this.ctrl).getTooltipShowDelayOverride) == null ? void 0 : r.call(t),
        (i = (n = this.ctrl).getTooltipHideDelayOverride) == null ? void 0 : i.call(n),
        this.ctrl.shouldDisplayTooltip
      ),
      this.beans.context
    );
  }
  refreshToolTip() {
    this.browserTooltips = this.beans.gos.get("enableBrowserTooltips"), this.updateTooltipText(), this.browserTooltips ? (this.setBrowserTooltip(this.tooltip), this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context))) : (this.setBrowserTooltip(null), this.createTooltipFeatureIfNeeded());
  }
  getTooltipParams() {
    const e = this.ctrl, t = e.getColumn ? e.getColumn() : void 0, r = e.getColDef ? e.getColDef() : void 0, n = e.getRowNode ? e.getRowNode() : void 0;
    return {
      location: e.getLocation(),
      //'cell',
      colDef: r,
      column: t,
      rowIndex: e.getRowIndex ? e.getRowIndex() : void 0,
      node: n,
      data: n ? n.data : void 0,
      value: this.getTooltipText(),
      valueFormatted: e.getValueFormatted ? e.getValueFormatted() : void 0,
      hideTooltipCallback: () => {
        var i;
        return (i = this.tooltipManager) == null ? void 0 : i.hideTooltip(!0);
      }
    };
  }
  getTooltipText() {
    return this.tooltip;
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    this.tooltipManager && (this.tooltipManager = this.destroyBean(this.tooltipManager, this.beans.context)), super.destroy();
  }
}, OOe = new jh(), ft = null, Nr = class CK extends he {
  constructor(t, r) {
    super(), this.suppressDataRefValidation = !1, this.displayed = !0, this.visible = !0, this.compId = OOe.next(), this.cssClassManager = new Kv(() => this.eGui), this.componentSelectors = new Map((r ?? []).map((n) => [n.selector, n])), t && this.setTemplate(t);
  }
  preWireBeans(t) {
    super.preWireBeans(t);
  }
  preConstruct() {
    this.usingBrowserTooltips = this.gos.get("enableBrowserTooltips"), this.wireTemplate(this.getGui());
  }
  wireTemplate(t, r) {
    t && this.gos && (this.applyElementsToComponent(t), this.createChildComponentsFromTags(t, r));
  }
  getCompId() {
    return this.compId;
  }
  getTooltipParams() {
    return {
      value: this.tooltipText,
      location: "UNKNOWN"
    };
  }
  setTooltip(t) {
    const { newTooltipText: r, showDelayOverride: n, hideDelayOverride: i, location: o, shouldDisplayTooltip: a } = t || {};
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), this.tooltipText !== r && (this.tooltipText = r);
    const s = () => this.tooltipText;
    r != null && (this.tooltipFeature = this.createBean(
      new bf({
        getTooltipValue: s,
        getGui: () => this.getGui(),
        getLocation: () => o ?? "UNKNOWN",
        getColDef: t == null ? void 0 : t.getColDef,
        getColumn: t == null ? void 0 : t.getColumn,
        getTooltipShowDelayOverride: n != null ? () => n : void 0,
        getTooltipHideDelayOverride: i != null ? () => i : void 0,
        shouldDisplayTooltip: a
      })
    ));
  }
  getDataRefAttribute(t) {
    return t.getAttribute ? t.getAttribute("data-ref") : null;
  }
  applyElementsToComponent(t, r, n, i = null) {
    if (r === void 0 && (r = this.getDataRefAttribute(t)), r) {
      const o = this[r];
      if (o === ft)
        this[r] = i ?? t;
      else {
        const a = n && n[r];
        !this.suppressDataRefValidation && !a && Se(`Issue with data-ref: ${r} on ${this.constructor.name} with ${o}`);
      }
    }
  }
  // for registered components only, eg creates AgCheckbox instance from ag-checkbox HTML tag
  createChildComponentsFromTags(t, r) {
    DOe(t.childNodes).forEach((i) => {
      if (!(i instanceof HTMLElement))
        return;
      const o = this.createComponentFromElement(
        i,
        (a) => {
          a.getGui() && this.copyAttributesFromNode(i, a.getGui());
        },
        r
      );
      if (o) {
        if (o.addItems && i.children.length) {
          this.createChildComponentsFromTags(i, r);
          const a = Array.prototype.slice.call(i.children);
          o.addItems(a);
        }
        this.swapComponentForNode(o, t, i);
      } else i.childNodes && this.createChildComponentsFromTags(i, r);
    });
  }
  createComponentFromElement(t, r, n) {
    const i = t.nodeName, o = this.getDataRefAttribute(t), a = i.indexOf("AG-") === 0, s = a ? this.componentSelectors.get(i) : null;
    let l = null;
    if (s) {
      CK.elementGettingCreated = t;
      const u = n && o ? n[o] : void 0;
      l = new s.component(u), l.setParentComponent(this), this.createBean(l, null, r);
    } else a && Se(`Missing selector: ${i}`);
    return this.applyElementsToComponent(t, o, n, l), l;
  }
  copyAttributesFromNode(t, r) {
    AOe(t.attributes, (n, i) => r.setAttribute(n, i));
  }
  swapComponentForNode(t, r, n) {
    const i = t.getGui();
    r.replaceChild(i, n), r.insertBefore(document.createComment(n.nodeName), i), this.addDestroyFunc(this.destroyBean.bind(this, t));
  }
  activateTabIndex(t) {
    const r = this.gos.get("tabIndex");
    t || (t = []), t.length || t.push(this.getGui()), t.forEach((n) => n.setAttribute("tabindex", r.toString()));
  }
  setTemplate(t, r, n) {
    const i = Wh(t);
    this.setTemplateFromElement(i, r, n);
  }
  setTemplateFromElement(t, r, n, i = !1) {
    if (this.eGui = t, this.suppressDataRefValidation = i, r)
      for (let o = 0; o < r.length; o++) {
        const a = r[o];
        this.componentSelectors.set(a.selector, a);
      }
    this.wireTemplate(t, n);
  }
  getGui() {
    return this.eGui;
  }
  getFocusableElement() {
    return this.eGui;
  }
  getAriaElement() {
    return this.getFocusableElement();
  }
  setParentComponent(t) {
    this.parentComponent = t;
  }
  getParentComponent() {
    return this.parentComponent;
  }
  // this method is for older code, that wants to provide the gui element,
  // it is not intended for this to be in ag-Stack
  setGui(t) {
    this.eGui = t;
  }
  queryForHtmlElement(t) {
    return this.eGui.querySelector(t);
  }
  getContainerAndElement(t, r) {
    let n = r;
    return t == null ? null : (n || (n = this.eGui), EA(t) ? {
      element: t,
      parent: n
    } : {
      element: t.getGui(),
      parent: n
    });
  }
  prependChild(t, r) {
    const { element: n, parent: i } = this.getContainerAndElement(t, r) || {};
    !n || !i || i.insertAdjacentElement("afterbegin", n);
  }
  appendChild(t, r) {
    const { element: n, parent: i } = this.getContainerAndElement(t, r) || {};
    !n || !i || i.appendChild(n);
  }
  isDisplayed() {
    return this.displayed;
  }
  setVisible(t, r = {}) {
    if (t !== this.visible) {
      this.visible = t;
      const { skipAriaHidden: n } = r;
      TOe(this.eGui, t, { skipAriaHidden: n });
    }
  }
  setDisplayed(t, r = {}) {
    if (t !== this.displayed) {
      this.displayed = t;
      const { skipAriaHidden: n } = r;
      jr(this.eGui, t, { skipAriaHidden: n });
      const i = {
        type: "displayChanged",
        visible: this.displayed
      };
      this.dispatchLocalEvent(i);
    }
  }
  destroy() {
    this.parentComponent && (this.parentComponent = void 0), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature)), super.destroy();
  }
  addGuiEventListener(t, r, n) {
    this.eGui.addEventListener(t, r, n), this.addDestroyFunc(() => this.eGui.removeEventListener(t, r));
  }
  addCssClass(t) {
    this.cssClassManager.addCssClass(t);
  }
  removeCssClass(t) {
    this.cssClassManager.removeCssClass(t);
  }
  containsCssClass(t) {
    return this.cssClassManager.containsCssClass(t);
  }
  addOrRemoveCssClass(t, r) {
    this.cssClassManager.addOrRemoveCssClass(t, r);
  }
}, NOe = {
  // header column group shown when expanded (click to contract)
  columnGroupOpened: "expanded",
  // header column group shown when contracted (click to expand)
  columnGroupClosed: "contracted",
  // tool panel column group contracted (click to expand)
  columnSelectClosed: "tree-closed",
  // tool panel column group expanded (click to contract)
  columnSelectOpen: "tree-open",
  // column tool panel header expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  columnSelectIndeterminate: "tree-indeterminate",
  // shown on ghost icon while dragging column to the side of the grid to pin
  columnMovePin: "pin",
  // shown on ghost icon while dragging over part of the page that is not a drop zone
  columnMoveHide: "eye-slash",
  // shown on ghost icon while dragging columns to reorder
  columnMoveMove: "arrows",
  // animating icon shown when dragging a column to the right of the grid causes horizontal scrolling
  columnMoveLeft: "left",
  // animating icon shown when dragging a column to the left of the grid causes horizontal scrolling
  columnMoveRight: "right",
  // shown on ghost icon while dragging over Row Groups drop zone
  columnMoveGroup: "group",
  // shown on ghost icon while dragging over Values drop zone
  columnMoveValue: "aggregation",
  // shown on ghost icon while dragging over pivot drop zone
  columnMovePivot: "pivot",
  // shown on ghost icon while dragging over drop zone that doesn't support it, e.g.
  //     string column over aggregation drop zone
  dropNotAllowed: "not-allowed",
  // shown on row group when contracted (click to expand)
  groupContracted: "tree-closed",
  // shown on row group when expanded (click to contract)
  groupExpanded: "tree-open",
  // set filter tree list group contracted (click to expand)
  setFilterGroupClosed: "tree-closed",
  // set filter tree list group expanded (click to contract)
  setFilterGroupOpen: "tree-open",
  // set filter tree list expand/collapse all button, shown when some children are expanded and
  //     others are collapsed
  setFilterGroupIndeterminate: "tree-indeterminate",
  // context menu chart item
  chart: "chart",
  // chart window title bar
  close: "cross",
  // X (remove) on column 'pill' after adding it to a drop zone list
  cancel: "cancel",
  // indicates the currently active pin state in the "Pin column" sub-menu of the column menu
  check: "tick",
  // "go to first" button in pagination controls
  first: "first",
  // "go to previous" button in pagination controls
  previous: "previous",
  // "go to next" button in pagination controls
  next: "next",
  // "go to last" button in pagination controls
  last: "last",
  // shown on top right of chart when chart is linked to range data (click to unlink)
  linked: "linked",
  // shown on top right of chart when chart is not linked to range data (click to link)
  unlinked: "unlinked",
  // "Choose colour" button on chart settings tab
  colorPicker: "color-picker",
  // rotating spinner shown by the loading cell renderer
  groupLoading: "loading",
  // button to launch enterprise column menu
  menu: "menu",
  menuAlt: "menu-alt",
  // filter tool panel tab
  filter: "filter",
  // column tool panel tab
  columns: "columns",
  // button in chart regular size window title bar (click to maximise)
  maximize: "maximize",
  // button in chart maximised window title bar (click to make regular size)
  minimize: "minimize",
  // "Pin column" item in column header menu
  menuPin: "pin",
  // "Value aggregation" column menu item (shown on numeric columns when grouping is active)"
  menuValue: "aggregation",
  // "Group by {column-name}" item in column header menu
  menuAddRowGroup: "group",
  // "Un-Group by {column-name}" item in column header menu
  menuRemoveRowGroup: "group",
  // context menu copy item
  clipboardCopy: "copy",
  // context menu cut item
  clipboardCut: "cut",
  // context menu paste item
  clipboardPaste: "paste",
  // identifies the pivot drop zone
  pivotPanel: "pivot",
  // "Row groups" drop zone in column tool panel
  rowGroupPanel: "group",
  // columns tool panel Values drop zone
  valuePanel: "aggregation",
  // drag handle used to pick up draggable columns
  columnDrag: "grip",
  // drag handle used to pick up draggable rows
  rowDrag: "grip",
  // context menu export item
  save: "save",
  // csv export
  csvExport: "csv",
  // excel export,
  excelExport: "excel",
  // icon on dropdown editors
  smallDown: "small-down",
  // version of small-right used in RTL mode
  smallLeft: "small-left",
  // separater between column 'pills' when you add multiple columns to the header drop zone
  smallRight: "small-right",
  smallUp: "small-up",
  // show on column header when column is sorted ascending
  sortAscending: "asc",
  // show on column header when column is sorted descending
  sortDescending: "desc",
  // show on column header when column has no sort, only when enabled with gridOptions.unSortIcon=true
  sortUnSort: "none",
  // Builder button in Advanced Filter
  advancedFilterBuilder: "group",
  // drag handle used to pick up Advanced Filter Builder rows
  advancedFilterBuilderDrag: "grip",
  // Advanced Filter Builder row validation error
  advancedFilterBuilderInvalid: "not-allowed",
  // shown on Advanced Filter Builder rows to move them up
  advancedFilterBuilderMoveUp: "up",
  // shown on Advanced Filter Builder rows to move them down
  advancedFilterBuilderMoveDown: "down",
  // shown on Advanced Filter Builder rows to add new rows
  advancedFilterBuilderAdd: "plus",
  // shown on Advanced Filter Builder rows to remove row
  advancedFilterBuilderRemove: "minus",
  // Edit Chart menu item shown in Integrated Charts menu
  chartsMenuEdit: "chart",
  // Advanced Settings menu item shown in Integrated Charts menu
  chartsMenuAdvancedSettings: "settings",
  // shown in Integrated Charts menu add fields
  chartsMenuAdd: "plus",
  // checked checkbox
  checkboxChecked: "checkbox-checked",
  // indeterminate checkbox
  checkboxIndeterminate: "checkbox-indeterminate",
  // unchecked checkbox
  checkboxUnchecked: "checkbox-unchecked",
  // radio button on
  radioButtonOn: "radio-button-on",
  // radio button off
  radioButtonOff: "radio-button-off"
};
function vs(e, t, r) {
  const n = to(e, t, r);
  if (n) {
    const { className: o } = n;
    if (typeof o == "string" && o.indexOf("ag-icon") > -1 || typeof o == "object" && o["ag-icon"])
      return n;
  }
  const i = document.createElement("span");
  return i.appendChild(n), i;
}
function to(e, t, r, n) {
  let i = null;
  const o = r && r.getColDef().icons;
  if (o && (i = o[e]), t && !i) {
    const a = t.get("icons");
    a && (i = a[e]);
  }
  if (i) {
    let a;
    if (typeof i == "function")
      a = i();
    else if (typeof i == "string")
      a = i;
    else
      throw new Error("icon from grid options needs to be a string or a function");
    if (typeof a == "string")
      return Wh(a);
    if (EA(a))
      return a;
    Se("iconRenderer should return back a string or a dom object");
  } else {
    const a = document.createElement("span");
    let s = NOe[e];
    return s || (Se(`Did not find icon ${e}`), s = ""), a.setAttribute("class", `ag-icon ag-icon-${s}`), a.setAttribute("unselectable", "on"), Sa(a, "presentation"), a;
  }
}
function SK(e, t, r) {
  if (r === 0)
    return !1;
  const n = Math.abs(e.clientX - t.clientX), i = Math.abs(e.clientY - t.clientY);
  return Math.max(n, i) <= r;
}
var Bl = class {
  constructor(e, t = !1) {
    this.DOUBLE_TAP_MILLIS = 500, this.destroyFuncs = [], this.touching = !1, this.localEventService = new wf(), this.eElement = e, this.preventMouseClick = t;
    const r = this.onTouchStart.bind(this), n = this.onTouchMove.bind(this), i = this.onTouchEnd.bind(this);
    this.eElement.addEventListener("touchstart", r, { passive: !0 }), this.eElement.addEventListener("touchmove", n, { passive: !0 }), this.eElement.addEventListener("touchend", i, { passive: !1 }), this.destroyFuncs.push(() => {
      this.eElement.removeEventListener("touchstart", r, { passive: !0 }), this.eElement.removeEventListener("touchmove", n, { passive: !0 }), this.eElement.removeEventListener("touchend", i, { passive: !1 });
    });
  }
  getActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  addEventListener(e, t) {
    this.localEventService.addEventListener(e, t);
  }
  removeEventListener(e, t) {
    this.localEventService.removeEventListener(e, t);
  }
  onTouchStart(e) {
    if (this.touching)
      return;
    this.touchStart = e.touches[0], this.touching = !0, this.moved = !1;
    const t = this.touchStart;
    window.setTimeout(() => {
      const r = this.touchStart === t;
      if (this.touching && r && !this.moved) {
        this.moved = !0;
        const n = {
          type: "longTap",
          touchStart: this.touchStart,
          touchEvent: e
        };
        this.localEventService.dispatchEvent(n);
      }
    }, 500);
  }
  onTouchMove(e) {
    if (!this.touching)
      return;
    const t = this.getActiveTouch(e.touches);
    if (!t)
      return;
    !SK(t, this.touchStart, 4) && (this.moved = !0);
  }
  onTouchEnd(e) {
    if (this.touching) {
      if (!this.moved) {
        const t = {
          type: "tap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(t), this.checkForDoubleTap();
      }
      this.preventMouseClick && e.cancelable && e.preventDefault(), this.touching = !1;
    }
  }
  checkForDoubleTap() {
    const e = (/* @__PURE__ */ new Date()).getTime();
    if (this.lastTapTime && this.lastTapTime > 0)
      if (e - this.lastTapTime > this.DOUBLE_TAP_MILLIS) {
        const r = {
          type: "doubleTap",
          touchStart: this.touchStart
        };
        this.localEventService.dispatchEvent(r), this.lastTapTime = null;
      } else
        this.lastTapTime = e;
    else
      this.lastTapTime = e;
  }
  destroy() {
    this.destroyFuncs.forEach((e) => e());
  }
}, kOe = (
  /* html */
  `<span class="ag-sort-indicator-container">
        <span data-ref="eSortOrder" class="ag-sort-indicator-icon ag-sort-order ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortAsc" class="ag-sort-indicator-icon ag-sort-ascending-icon ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortDesc" class="ag-sort-indicator-icon ag-sort-descending-icon ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortMixed" class="ag-sort-indicator-icon ag-sort-mixed-icon ag-hidden" aria-hidden="true"></span>
        <span data-ref="eSortNone" class="ag-sort-indicator-icon ag-sort-none-icon ag-hidden" aria-hidden="true"></span>
    </span>`
), RA = class extends Nr {
  constructor(e) {
    super(), this.eSortOrder = ft, this.eSortAsc = ft, this.eSortDesc = ft, this.eSortMixed = ft, this.eSortNone = ft, e || this.setTemplate(kOe);
  }
  wireBeans(e) {
    this.sortController = e.sortController;
  }
  attachCustomElements(e, t, r, n, i) {
    this.eSortOrder = e, this.eSortAsc = t, this.eSortDesc = r, this.eSortMixed = n, this.eSortNone = i;
  }
  setupSort(e, t = !1) {
    this.column = e, this.suppressOrder = t, this.setupMultiSortIndicator(), !(!this.column.isSortable() && !this.column.getColDef().showRowGroup) && (this.addInIcon("sortAscending", this.eSortAsc, e), this.addInIcon("sortDescending", this.eSortDesc, e), this.addInIcon("sortUnSort", this.eSortNone, e), this.addManagedPropertyListener("unSortIcon", () => this.updateIcons()), this.addManagedEventListeners({
      newColumnsLoaded: this.updateIcons.bind(this),
      // Watch global events, as row group columns can effect their display column.
      sortChanged: this.onSortChanged.bind(this),
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: this.onSortChanged.bind(this)
    }), this.onSortChanged());
  }
  addInIcon(e, t, r) {
    if (t == null)
      return;
    const n = to(e, this.gos, r);
    n && t.appendChild(n);
  }
  onSortChanged() {
    this.updateIcons(), this.suppressOrder || this.updateSortOrder();
  }
  updateIcons() {
    const e = this.sortController.getDisplaySortForColumn(this.column);
    if (this.eSortAsc) {
      const t = e === "asc";
      jr(this.eSortAsc, t, { skipAriaHidden: !0 });
    }
    if (this.eSortDesc) {
      const t = e === "desc";
      jr(this.eSortDesc, t, { skipAriaHidden: !0 });
    }
    if (this.eSortNone) {
      const t = !this.column.getColDef().unSortIcon && !this.gos.get("unSortIcon"), r = e == null;
      jr(this.eSortNone, !t && r, { skipAriaHidden: !0 });
    }
  }
  setupMultiSortIndicator() {
    this.addInIcon("sortUnSort", this.eSortMixed, this.column);
    const e = this.column.getColDef().showRowGroup;
    this.gos.isColumnsSortingCoupledToGroup() && e && (this.addManagedEventListeners({
      // Watch global events, as row group columns can effect their display column.
      sortChanged: this.updateMultiSortIndicator.bind(this),
      // when grouping changes so can sort indexes and icons
      columnRowGroupChanged: this.updateMultiSortIndicator.bind(this)
    }), this.updateMultiSortIndicator());
  }
  updateMultiSortIndicator() {
    if (this.eSortMixed) {
      const e = this.sortController.getDisplaySortForColumn(this.column) === "mixed";
      jr(this.eSortMixed, e, { skipAriaHidden: !0 });
    }
  }
  // we listen here for global sort events, NOT column sort events, as we want to do this
  // when sorting has been set on all column (if we listened just for our col (where we
  // set the asc / desc icons) then it's possible other cols are yet to get their sorting state.
  updateSortOrder() {
    if (!this.eSortOrder)
      return;
    const e = this.sortController.getColumnsWithSortingOrdered(), t = this.sortController.getDisplaySortIndexForColumn(this.column) ?? -1, r = e.some(
      (i) => this.sortController.getDisplaySortIndexForColumn(i) ?? !1
    ), n = t >= 0 && r;
    jr(this.eSortOrder, n, { skipAriaHidden: !0 }), t >= 0 ? this.eSortOrder.textContent = (t + 1).toString() : oo(this.eSortOrder);
  }
}, VOe = {
  selector: "AG-SORT-INDICATOR",
  component: RA
}, BOe = (
  /* html */
  `<div class="ag-cell-label-container" role="presentation">
        <span data-ref="eMenu" class="ag-header-icon ag-header-cell-menu-button" aria-hidden="true"></span>
        <span data-ref="eFilterButton" class="ag-header-icon ag-header-cell-filter-button" aria-hidden="true"></span>
        <div data-ref="eLabel" class="ag-header-cell-label" role="presentation">
            <span data-ref="eText" class="ag-header-cell-text"></span>
            <span data-ref="eFilter" class="ag-header-icon ag-header-label-icon ag-filter-icon" aria-hidden="true"></span>
            <ag-sort-indicator data-ref="eSortIndicator"></ag-sort-indicator>
        </div>
    </div>`
), PT = class extends Nr {
  constructor() {
    super(...arguments), this.eFilter = ft, this.eFilterButton = ft, this.eSortIndicator = ft, this.eMenu = ft, this.eLabel = ft, this.eText = ft, this.eSortOrder = ft, this.eSortAsc = ft, this.eSortDesc = ft, this.eSortMixed = ft, this.eSortNone = ft, this.lastMovingChanged = 0;
  }
  wireBeans(e) {
    this.sortController = e.sortController, this.menuService = e.menuService, this.funcColsService = e.funcColsService;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  refresh(e) {
    const t = this.params;
    return this.params = e, this.workOutTemplate() != this.currentTemplate || this.workOutShowMenu() != this.currentShowMenu || this.workOutSort() != this.currentSort || this.shouldSuppressMenuHide() != this.currentSuppressMenuHide || t.enableFilterButton != e.enableFilterButton || t.enableFilterIcon != e.enableFilterIcon ? !1 : (this.setDisplayName(e), !0);
  }
  workOutTemplate() {
    let e = this.params.template ?? BOe;
    return e = e && e.trim ? e.trim() : e, e;
  }
  init(e) {
    this.params = e, this.currentTemplate = this.workOutTemplate(), this.setTemplate(this.currentTemplate, [VOe]), this.setupTap(), this.setMenu(), this.setupSort(), this.setupFilterIcon(), this.setupFilterButton(), this.setDisplayName(e);
  }
  setDisplayName(e) {
    if (this.currentDisplayName != e.displayName) {
      this.currentDisplayName = e.displayName;
      const t = Za(this.currentDisplayName, !0);
      this.eText && (this.eText.textContent = t);
    }
  }
  addInIcon(e, t, r) {
    if (t == null)
      return;
    const n = to(e, this.gos, r);
    n && t.appendChild(n);
  }
  setupTap() {
    const { gos: e } = this;
    if (e.get("suppressTouch"))
      return;
    const t = new Bl(this.getGui(), !0), r = this.shouldSuppressMenuHide(), n = r && Me(this.eMenu), i = n ? new Bl(this.eMenu, !0) : t;
    if (this.params.enableMenu) {
      const o = n ? "tap" : "longTap", a = (s) => this.params.showColumnMenuAfterMouseClick(s.touchStart);
      this.addManagedListeners(i, { [o]: a });
    }
    if (this.params.enableSorting) {
      const o = (a) => {
        var l, u;
        const s = a.touchStart.target;
        r && ((l = this.eMenu) != null && l.contains(s) || (u = this.eFilterButton) != null && u.contains(s)) || this.sortController.progressSort(this.params.column, !1, "uiColumnSorted");
      };
      this.addManagedListeners(t, { tap: o });
    }
    if (this.params.enableFilterButton) {
      const o = new Bl(this.eFilterButton, !0);
      this.addManagedListeners(o, {
        tap: () => this.params.showFilter(this.eFilterButton)
      }), this.addDestroyFunc(() => o.destroy());
    }
    this.addDestroyFunc(() => t.destroy()), n && this.addDestroyFunc(() => i.destroy());
  }
  workOutShowMenu() {
    return this.params.enableMenu && this.menuService.isHeaderMenuButtonEnabled();
  }
  shouldSuppressMenuHide() {
    return this.menuService.isHeaderMenuButtonAlwaysShowEnabled();
  }
  setMenu() {
    if (!this.eMenu)
      return;
    if (this.currentShowMenu = this.workOutShowMenu(), !this.currentShowMenu) {
      Oc(this.eMenu), this.eMenu = void 0;
      return;
    }
    const e = this.menuService.isLegacyMenuEnabled();
    this.addInIcon(e ? "menu" : "menuAlt", this.eMenu, this.params.column), this.eMenu.classList.toggle("ag-header-menu-icon", !e), this.currentSuppressMenuHide = this.shouldSuppressMenuHide(), this.addManagedElementListeners(this.eMenu, { click: () => this.params.showColumnMenu(this.eMenu) }), this.eMenu.classList.toggle("ag-header-menu-always-show", this.currentSuppressMenuHide);
  }
  onMenuKeyboardShortcut(e) {
    const t = this.params.column, r = this.menuService.isLegacyMenuEnabled();
    if (e && !r) {
      if (this.menuService.isFilterMenuInHeaderEnabled(t))
        return this.params.showFilter(this.eFilterButton ?? this.eMenu ?? this.getGui()), !0;
    } else if (this.params.enableMenu)
      return this.params.showColumnMenu(this.eMenu ?? this.eFilterButton ?? this.getGui()), !0;
    return !1;
  }
  workOutSort() {
    return this.params.enableSorting;
  }
  setupSort() {
    if (this.currentSort = this.params.enableSorting, this.eSortIndicator || (this.eSortIndicator = this.createBean(new RA(!0)), this.eSortIndicator.attachCustomElements(
      this.eSortOrder,
      this.eSortAsc,
      this.eSortDesc,
      this.eSortMixed,
      this.eSortNone
    )), this.eSortIndicator.setupSort(this.params.column), !this.currentSort)
      return;
    this.addManagedListeners(this.params.column, {
      movingChanged: () => {
        this.lastMovingChanged = (/* @__PURE__ */ new Date()).getTime();
      }
    }), this.eLabel && this.addManagedElementListeners(this.eLabel, {
      click: (t) => {
        const r = this.params.column.isMoving(), i = (/* @__PURE__ */ new Date()).getTime() - this.lastMovingChanged < 50;
        if (!(r || i)) {
          const s = this.gos.get("multiSortKey") === "ctrl" ? t.ctrlKey || t.metaKey : t.shiftKey;
          this.params.progressSort(s);
        }
      }
    });
    const e = () => {
      const t = this.params.column.getSort();
      if (this.addOrRemoveCssClass("ag-header-cell-sorted-asc", t === "asc"), this.addOrRemoveCssClass("ag-header-cell-sorted-desc", t === "desc"), this.addOrRemoveCssClass("ag-header-cell-sorted-none", !t), this.params.column.getColDef().showRowGroup) {
        const r = this.funcColsService.getSourceColumnsForGroupColumn(
          this.params.column
        ), i = !(r == null ? void 0 : r.every(
          (o) => this.params.column.getSort() == o.getSort()
        ));
        this.addOrRemoveCssClass("ag-header-cell-sorted-mixed", i);
      }
    };
    this.addManagedEventListeners({
      sortChanged: e,
      columnRowGroupChanged: e
    });
  }
  setupFilterIcon() {
    this.eFilter && this.configureFilter(this.params.enableFilterIcon, this.eFilter, this.onFilterChangedIcon.bind(this));
  }
  setupFilterButton() {
    if (!this.eFilterButton)
      return;
    this.configureFilter(
      this.params.enableFilterButton,
      this.eFilterButton,
      this.onFilterChangedButton.bind(this)
    ) ? this.addManagedElementListeners(this.eFilterButton, {
      click: () => this.params.showFilter(this.eFilterButton)
    }) : this.eFilterButton = void 0;
  }
  configureFilter(e, t, r) {
    if (!e)
      return Oc(t), !1;
    const n = this.params.column;
    return this.addInIcon("filter", t, n), this.addManagedListeners(n, { filterChanged: r }), r(), !0;
  }
  onFilterChangedIcon() {
    const e = this.params.column.isFilterActive();
    jr(this.eFilter, e, { skipAriaHidden: !0 });
  }
  onFilterChangedButton() {
    const e = this.params.column.isFilterActive();
    this.eFilterButton.classList.toggle("ag-filter-active", e);
  }
  getAnchorElementForMenu(e) {
    return e ? this.eFilterButton ?? this.eMenu ?? this.getGui() : this.eMenu ?? this.eFilterButton ?? this.getGui();
  }
}, GOe = class extends Nr {
  constructor() {
    super(
      /* html */
      `<div class="ag-header-group-cell-label" role="presentation">
            <span data-ref="agLabel" class="ag-header-group-text" role="presentation"></span>
            <span data-ref="agOpened" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-expanded"></span>
            <span data-ref="agClosed" class="ag-header-icon ag-header-expand-icon ag-header-expand-icon-collapsed"></span>
        </div>`
    ), this.agOpened = ft, this.agClosed = ft, this.agLabel = ft;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.checkWarnings(), this.setupLabel(), this.addGroupExpandIcon(), this.setupExpandIcons();
  }
  checkWarnings() {
    this.params.template && Se(
      "A template was provided for Header Group Comp - templates are only supported for Header Comps (not groups)"
    );
  }
  setupExpandIcons() {
    this.addInIcon("columnGroupOpened", this.agOpened), this.addInIcon("columnGroupClosed", this.agClosed);
    const e = (i) => {
      if (Vl(i))
        return;
      const o = !this.params.columnGroup.isExpanded();
      this.columnModel.setColumnGroupOpened(
        this.params.columnGroup.getProvidedColumnGroup(),
        o,
        "uiColumnExpanded"
      );
    };
    this.addTouchAndClickListeners(this.agClosed, e), this.addTouchAndClickListeners(this.agOpened, e);
    const t = (i) => {
      zh(i);
    };
    this.addManagedElementListeners(this.agClosed, { dblclick: t }), this.addManagedElementListeners(this.agOpened, { dblclick: t }), this.addManagedElementListeners(this.getGui(), { dblclick: e }), this.updateIconVisibility();
    const r = this.params.columnGroup.getProvidedColumnGroup(), n = this.updateIconVisibility.bind(this);
    this.addManagedListeners(r, {
      expandedChanged: n,
      expandableChanged: n
    });
  }
  addTouchAndClickListeners(e, t) {
    const r = new Bl(e, !0);
    this.addManagedListeners(r, { tap: t }), this.addDestroyFunc(() => r.destroy()), this.addManagedElementListeners(e, { click: t });
  }
  updateIconVisibility() {
    if (this.params.columnGroup.isExpandable()) {
      const t = this.params.columnGroup.isExpanded();
      jr(this.agOpened, t), jr(this.agClosed, !t);
    } else
      jr(this.agOpened, !1), jr(this.agClosed, !1);
  }
  addInIcon(e, t) {
    const r = to(e, this.gos, null);
    r && t.appendChild(r);
  }
  addGroupExpandIcon() {
    if (!this.params.columnGroup.isExpandable()) {
      jr(this.agOpened, !1), jr(this.agClosed, !1);
      return;
    }
  }
  setupLabel() {
    var r;
    const { displayName: e, columnGroup: t } = this.params;
    if (Me(e)) {
      const n = Za(e, !0);
      this.agLabel.textContent = n;
    }
    this.addOrRemoveCssClass("ag-sticky-label", !((r = t.getColGroupDef()) != null && r.suppressStickyLabel));
  }
}, wK = /* @__PURE__ */ ((e) => (e.CommunityCoreModule = "@ag-grid-community/core", e.InfiniteRowModelModule = "@ag-grid-community/infinite-row-model", e.ClientSideRowModelModule = "@ag-grid-community/client-side-row-model", e.CsvExportModule = "@ag-grid-community/csv-export", e.EnterpriseCoreModule = "@ag-grid-enterprise/core", e.RowGroupingModule = "@ag-grid-enterprise/row-grouping", e.ColumnsToolPanelModule = "@ag-grid-enterprise/column-tool-panel", e.FiltersToolPanelModule = "@ag-grid-enterprise/filter-tool-panel", e.MenuModule = "@ag-grid-enterprise/menu", e.SetFilterModule = "@ag-grid-enterprise/set-filter", e.MultiFilterModule = "@ag-grid-enterprise/multi-filter", e.StatusBarModule = "@ag-grid-enterprise/status-bar", e.SideBarModule = "@ag-grid-enterprise/side-bar", e.RangeSelectionModule = "@ag-grid-enterprise/range-selection", e.MasterDetailModule = "@ag-grid-enterprise/master-detail", e.RichSelectModule = "@ag-grid-enterprise/rich-select", e.GridChartsModule = "@ag-grid-enterprise/charts", e.ViewportRowModelModule = "@ag-grid-enterprise/viewport-row-model", e.ServerSideRowModelModule = "@ag-grid-enterprise/server-side-row-model", e.ExcelExportModule = "@ag-grid-enterprise/excel-export", e.ClipboardModule = "@ag-grid-enterprise/clipboard", e.SparklinesModule = "@ag-grid-enterprise/sparklines", e.AdvancedFilterModule = "@ag-grid-enterprise/advanced-filter", e.AngularModule = "@ag-grid-community/angular", e.ReactModule = "@ag-grid-community/react", e.VueModule = "@ag-grid-community/vue", e))(wK || {}), gw = class ur {
  /**
   * Globally register the given module for all grids.
   * @param module - module to register
   */
  static register(t) {
    ur.__register(t, !0, void 0);
  }
  /**
   * Globally register the given modules for all grids.
   * @param modules - modules to register
   */
  static registerModules(t) {
    ur.__registerModules(t, !0, void 0);
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __register(t, r, n) {
    ur.runVersionChecks(t), n !== void 0 ? (ur.areGridScopedModules = !0, ur.gridModulesMap[n] === void 0 && (ur.gridModulesMap[n] = {}), ur.gridModulesMap[n][t.moduleName] = t) : ur.globalModulesMap[t.moduleName] = t, ur.setModuleBased(r);
  }
  /** AG GRID INTERNAL - Unregister grid scoped module. */
  static __unRegisterGridModules(t) {
    delete ur.gridModulesMap[t];
  }
  /** AG GRID INTERNAL - Module registration helper. */
  static __registerModules(t, r, n) {
    ur.setModuleBased(r), t && t.forEach((i) => ur.__register(i, r, n));
  }
  static isValidModuleVersion(t) {
    const [r, n] = t.version.split(".") || [], [i, o] = ur.currentModuleVersion.split(".") || [];
    return r === i && n === o;
  }
  static runVersionChecks(t) {
    ur.currentModuleVersion || (ur.currentModuleVersion = t.version);
    const r = (n) => `You are using incompatible versions of AG Grid modules. Major and minor versions should always match across modules. ${n} Please update all modules to the same version.`;
    if (t.version ? ur.isValidModuleVersion(t) || sr(
      r(
        `'${t.moduleName}' is version ${t.version} but the other modules are version ${ur.currentModuleVersion}.`
      )
    ) : sr(r(`'${t.moduleName}' is incompatible.`)), t.validate) {
      const n = t.validate();
      n.isValid || sr(`${n.message}`);
    }
  }
  static setModuleBased(t) {
    ur.moduleBased === void 0 ? ur.moduleBased = t : ur.moduleBased !== t && (sr(
      "AG Grid: You are mixing modules (i.e. @ag-grid-community/core) and packages (ag-grid-community) - you can only use one or the other of these mechanisms."
    ), sr("Please see https://www.ag-grid.com/javascript-grid/modules/ for more information."));
  }
  /**
   * AG GRID INTERNAL - Set if files are being served from a single UMD bundle to provide accurate enterprise upgrade steps.
   */
  static __setIsBundled() {
    ur.isBundled = !0;
  }
  /** AG GRID INTERNAL - Assert a given module has been register, globally or individually with this grid. */
  static __assertRegistered(t, r, n) {
    var o;
    if (this.__isRegistered(t, n))
      return !0;
    let i;
    if (ur.isBundled)
      i = `AG Grid: unable to use ${r} as 'ag-grid-enterprise' has not been loaded. Check you are using the Enterprise bundle:
        
        <script src="https://cdn.jsdelivr.net/npm/ag-grid-enterprise@AG_GRID_VERSION/dist/ag-grid-enterprise.min.js"><\/script>
        
For more info see: https://ag-grid.com/javascript-data-grid/getting-started/#getting-started-with-ag-grid-enterprise`;
    else if (ur.moduleBased || ur.moduleBased === void 0) {
      const a = (o = Object.entries(wK).find(([s, l]) => l === t)) == null ? void 0 : o[0];
      i = `AG Grid: unable to use ${r} as the ${a} is not registered${ur.areGridScopedModules ? ` for gridId: ${n}` : ""}. Check if you have registered the module:
           
    import { ModuleRegistry } from '@ag-grid-community/core';
    import { ${a} } from '${t}';
    
    ModuleRegistry.registerModules([ ${a} ]);

For more info see: https://www.ag-grid.com/javascript-grid/modules/`;
    } else
      i = `AG Grid: unable to use ${r} as package 'ag-grid-enterprise' has not been imported. Check that you have imported the package:
            
    import 'ag-grid-enterprise';`;
    return sr(i), !1;
  }
  /** AG GRID INTERNAL - Is the given module registered, globally or individually with this grid. */
  static __isRegistered(t, r) {
    var n;
    return !!ur.globalModulesMap[t] || !!((n = ur.gridModulesMap[r]) != null && n[t]);
  }
  /** AG GRID INTERNAL - Get all registered modules globally / individually for this grid. */
  static __getRegisteredModules(t) {
    return [...p0(ur.globalModulesMap), ...p0(ur.gridModulesMap[t] || {})];
  }
  /** AG GRID INTERNAL - Get the list of modules registered individually for this grid. */
  static __getGridRegisteredModules(t) {
    return p0(ur.gridModulesMap[t] ?? {}) || [];
  }
  /** INTERNAL */
  static __isPackageBased() {
    return !ur.moduleBased;
  }
};
gw.globalModulesMap = {};
gw.gridModulesMap = {};
gw.areGridScopedModules = !1;
var Xn = gw, HOe = "↑", zOe = "↓", $Oe = class extends Nr {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-change-delta");
    const r = document.createElement("span");
    r.setAttribute("class", "ag-value-change-value"), e.appendChild(t), e.appendChild(r), this.setTemplateFromElement(e);
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  init(e) {
    this.eValue = this.queryForHtmlElement(".ag-value-change-value"), this.eDelta = this.queryForHtmlElement(".ag-value-change-delta"), this.refresh(e, !0);
  }
  showDelta(e, t) {
    const r = Math.abs(t), n = e.formatValue(r), i = Me(n) ? n : r, o = t >= 0;
    o ? this.eDelta.textContent = HOe + i : this.eDelta.textContent = zOe + i, this.eDelta.classList.toggle("ag-value-change-delta-up", o), this.eDelta.classList.toggle("ag-value-change-delta-down", !o);
  }
  setTimerToRemoveDelta() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.hideDeltaValue();
      }, 2e3);
    });
  }
  hideDeltaValue() {
    this.eValue.classList.remove("ag-value-change-value-highlight"), oo(this.eDelta);
  }
  refresh(e, t = !1) {
    var n;
    const r = e.value;
    if (r === this.lastValue || (Me(e.valueFormatted) ? this.eValue.textContent = e.valueFormatted : Me(e.value) ? this.eValue.textContent = r : oo(this.eValue), (n = this.filterManager) != null && n.isSuppressFlashingCellsBecauseFiltering()))
      return !1;
    if (typeof r == "number" && typeof this.lastValue == "number") {
      const i = r - this.lastValue;
      this.showDelta(e, i);
    }
    return this.lastValue && this.eValue.classList.add("ag-value-change-value-highlight"), t || this.setTimerToRemoveDelta(), this.lastValue = r, !0;
  }
}, WOe = class extends Nr {
  constructor() {
    super(), this.refreshCount = 0;
    const e = document.createElement("span"), t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-current"), e.appendChild(t), this.setTemplateFromElement(e), this.eCurrent = this.queryForHtmlElement(".ag-value-slide-current");
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  init(e) {
    this.refresh(e, !0);
  }
  addSlideAnimation() {
    this.refreshCount++;
    const e = this.refreshCount;
    this.ePrevious && this.getGui().removeChild(this.ePrevious);
    const t = document.createElement("span");
    t.setAttribute("class", "ag-value-slide-previous ag-value-slide-out"), this.ePrevious = t, this.ePrevious.textContent = this.eCurrent.textContent, this.getGui().insertBefore(this.ePrevious, this.eCurrent), this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => {
        e === this.refreshCount && this.ePrevious.classList.add("ag-value-slide-out-end");
      }, 50), window.setTimeout(() => {
        e === this.refreshCount && (this.getGui().removeChild(this.ePrevious), this.ePrevious = null);
      }, 3e3);
    });
  }
  refresh(e, t = !1) {
    var n;
    let r = e.value;
    return Zt(r) && (r = ""), r === this.lastValue || (n = this.filterManager) != null && n.isSuppressFlashingCellsBecauseFiltering() ? !1 : (t || this.addSlideAnimation(), this.lastValue = r, Me(e.valueFormatted) ? this.eCurrent.textContent = e.valueFormatted : Me(e.value) ? this.eCurrent.textContent = r : oo(this.eCurrent), !0);
  }
}, ae = class {
};
ae.BACKSPACE = "Backspace";
ae.TAB = "Tab";
ae.ENTER = "Enter";
ae.ESCAPE = "Escape";
ae.SPACE = " ";
ae.LEFT = "ArrowLeft";
ae.UP = "ArrowUp";
ae.RIGHT = "ArrowRight";
ae.DOWN = "ArrowDown";
ae.DELETE = "Delete";
ae.F2 = "F2";
ae.PAGE_UP = "PageUp";
ae.PAGE_DOWN = "PageDown";
ae.PAGE_HOME = "Home";
ae.PAGE_END = "End";
ae.A = "KeyA";
ae.C = "KeyC";
ae.D = "KeyD";
ae.V = "KeyV";
ae.X = "KeyX";
ae.Y = "KeyY";
ae.Z = "KeyZ";
var jOe = class extends Nr {
  constructor(e, t, r) {
    super(t, r), this.labelSeparator = "", this.labelAlignment = "left", this.disabled = !1, this.label = "", this.config = e || {};
  }
  postConstruct() {
    this.addCssClass("ag-labeled"), this.eLabel.classList.add("ag-label");
    const { labelSeparator: e, label: t, labelWidth: r, labelAlignment: n, disabled: i } = this.config;
    i != null && this.setDisabled(i), e != null && this.setLabelSeparator(e), t != null && this.setLabel(t), r != null && this.setLabelWidth(r), this.setLabelAlignment(n || this.labelAlignment), this.refreshLabel();
  }
  refreshLabel() {
    oo(this.eLabel), typeof this.label == "string" ? this.eLabel.innerText = this.label + this.labelSeparator : this.label && this.eLabel.appendChild(this.label), this.label === "" ? (jr(this.eLabel, !1), Sa(this.eLabel, "presentation")) : (jr(this.eLabel, !0), Sa(this.eLabel, null));
  }
  setLabelSeparator(e) {
    return this.labelSeparator === e ? this : (this.labelSeparator = e, this.label != null && this.refreshLabel(), this);
  }
  getLabelId() {
    return this.eLabel.id = this.eLabel.id || `ag-${this.getCompId()}-label`, this.eLabel.id;
  }
  getLabel() {
    return this.label;
  }
  setLabel(e) {
    return this.label === e ? this : (this.label = e, this.refreshLabel(), this);
  }
  setLabelAlignment(e) {
    const r = this.getGui().classList;
    return r.toggle("ag-label-align-left", e === "left"), r.toggle("ag-label-align-right", e === "right"), r.toggle("ag-label-align-top", e === "top"), this;
  }
  setLabelEllipsis(e) {
    return this.eLabel.classList.toggle("ag-label-ellipsis", e), this;
  }
  setLabelWidth(e) {
    return this.label == null ? this : (KC(this.eLabel, e), this);
  }
  setDisabled(e) {
    e = !!e;
    const t = this.getGui();
    return sv(t, e), t.classList.toggle("ag-disabled", e), this.disabled = e, this;
  }
  isDisabled() {
    return !!this.disabled;
  }
}, bK = class extends jOe {
  constructor(e, t, r, n) {
    super(e, t, r), this.className = n;
  }
  postConstruct() {
    super.postConstruct();
    const { width: e, value: t, onValueChange: r } = this.config;
    e != null && this.setWidth(e), t != null && this.setValue(t), r != null && this.onValueChange(r), this.className && this.addCssClass(this.className), this.refreshAriaLabelledBy();
  }
  setLabel(e) {
    return super.setLabel(e), this.refreshAriaLabelledBy(), this;
  }
  refreshAriaLabelledBy() {
    const e = this.getAriaElement(), t = this.getLabelId(), r = this.getLabel();
    r == null || r == "" || uOe(e) !== null ? av(e, "") : av(e, t ?? "");
  }
  setAriaLabel(e) {
    return $h(this.getAriaElement(), e), this.refreshAriaLabelledBy(), this;
  }
  onValueChange(e) {
    return this.addManagedListeners(this, { fieldValueChanged: () => e(this.getValue()) }), this;
  }
  getWidth() {
    return this.getGui().clientWidth;
  }
  setWidth(e) {
    return pa(this.getGui(), e), this;
  }
  getPreviousValue() {
    return this.previousValue;
  }
  getValue() {
    return this.value;
  }
  setValue(e, t) {
    return this.value === e ? this : (this.previousValue = this.value, this.value = e, t || this.dispatchLocalEvent({ type: "fieldValueChanged" }), this);
  }
}, lc = class extends bK {
  constructor(e, t, r = "text", n = "input") {
    super(
      e,
      (e == null ? void 0 : e.template) ?? /* html */
      `
            <div role="presentation">
                <div data-ref="eLabel" class="ag-input-field-label"></div>
                <div data-ref="eWrapper" class="ag-wrapper ag-input-wrapper" role="presentation">
                    <${n} data-ref="eInput" class="ag-input-field-input"></${n}>
                </div>
            </div>`,
      [],
      t
    ), this.inputType = r, this.displayFieldTag = n, this.eLabel = ft, this.eWrapper = ft, this.eInput = ft;
  }
  postConstruct() {
    super.postConstruct(), this.setInputType(), this.eLabel.classList.add(`${this.className}-label`), this.eWrapper.classList.add(`${this.className}-input-wrapper`), this.eInput.classList.add(`${this.className}-input`), this.addCssClass("ag-input-field"), this.eInput.id = this.eInput.id || `ag-${this.getCompId()}-input`;
    const { inputName: e, inputWidth: t } = this.config;
    e != null && this.setInputName(e), t != null && this.setInputWidth(t), this.addInputListeners(), this.activateTabIndex([this.eInput]);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { input: (e) => this.setValue(e.target.value) });
  }
  setInputType() {
    this.displayFieldTag === "input" && this.eInput.setAttribute("type", this.inputType);
  }
  getInputElement() {
    return this.eInput;
  }
  setInputWidth(e) {
    return KC(this.eWrapper, e), this;
  }
  setInputName(e) {
    return this.getInputElement().setAttribute("name", e), this;
  }
  getFocusableElement() {
    return this.eInput;
  }
  setMaxLength(e) {
    const t = this.eInput;
    return t.maxLength = e, this;
  }
  setInputPlaceholder(e) {
    return Ls(this.eInput, "placeholder", e), this;
  }
  setInputAriaLabel(e) {
    return $h(this.eInput, e), this.refreshAriaLabelledBy(), this;
  }
  setDisabled(e) {
    return sv(this.eInput, e), super.setDisabled(e);
  }
  setAutoComplete(e) {
    if (e === !0)
      Ls(this.eInput, "autocomplete", null);
    else {
      const t = typeof e == "string" ? e : "off";
      Ls(this.eInput, "autocomplete", t);
    }
    return this;
  }
}, _A = class extends lc {
  constructor(e, t = "ag-checkbox", r = "checkbox") {
    super(e, t, r), this.labelAlignment = "right", this.selected = !1, this.readOnly = !1, this.passive = !1;
  }
  postConstruct() {
    super.postConstruct();
    const { readOnly: e, passive: t } = this.config;
    typeof e == "boolean" && this.setReadOnly(e), typeof t == "boolean" && this.setPassive(t);
  }
  addInputListeners() {
    this.addManagedElementListeners(this.eInput, { click: this.onCheckboxClick.bind(this) }), this.addManagedElementListeners(this.eLabel, { click: this.toggle.bind(this) });
  }
  getNextValue() {
    return this.selected === void 0 ? !0 : !this.selected;
  }
  setPassive(e) {
    this.passive = e;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setReadOnly(e) {
    this.eWrapper.classList.toggle("ag-disabled", e), this.eInput.disabled = e, this.readOnly = e;
  }
  setDisabled(e) {
    return this.eWrapper.classList.toggle("ag-disabled", e), super.setDisabled(e);
  }
  toggle() {
    if (this.eInput.disabled)
      return;
    const e = this.isSelected(), t = this.getNextValue();
    this.passive ? this.dispatchChange(t, e) : this.setValue(t);
  }
  getValue() {
    return this.isSelected();
  }
  setValue(e, t) {
    return this.refreshSelectedClass(e), this.setSelected(e, t), this;
  }
  setName(e) {
    const t = this.getInputElement();
    return t.name = e, this;
  }
  isSelected() {
    return this.selected;
  }
  setSelected(e, t) {
    this.isSelected() !== e && (this.previousValue = this.isSelected(), e = this.selected = typeof e == "boolean" ? e : void 0, this.eInput.checked = e, this.eInput.indeterminate = e === void 0, t || this.dispatchChange(this.selected, this.previousValue));
  }
  dispatchChange(e, t, r) {
    this.dispatchLocalEvent({ type: "fieldValueChanged", selected: e, previousValue: t, event: r });
    const n = this.getInputElement(), i = {
      type: "checkboxChanged",
      id: n.id,
      name: n.name,
      selected: e,
      previousValue: t
    };
    this.eventService.dispatchEvent(i);
  }
  onCheckboxClick(e) {
    if (this.passive || this.eInput.disabled)
      return;
    const t = this.isSelected(), r = this.selected = e.target.checked;
    this.refreshSelectedClass(r), this.dispatchChange(r, t, e);
  }
  refreshSelectedClass(e) {
    this.eWrapper.classList.toggle("ag-checked", e === !0), this.eWrapper.classList.toggle("ag-indeterminate", e == null);
  }
}, TA = {
  selector: "AG-CHECKBOX",
  component: _A
}, UOe = class extends Nr {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-cell-wrapper ag-checkbox-cell" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [TA]
    ), this.eCheckbox = ft;
  }
  init(e) {
    this.params = e, this.updateCheckbox(e);
    const t = this.eCheckbox.getInputElement();
    t.setAttribute("tabindex", "-1"), aK(t, "polite"), this.addManagedListeners(t, {
      click: (r) => {
        if (zh(r), this.eCheckbox.isDisabled())
          return;
        const n = this.eCheckbox.getValue();
        this.onCheckboxChanged(n);
      },
      dblclick: (r) => {
        zh(r);
      }
    }), this.addManagedElementListeners(this.params.eGridCell, {
      keydown: (r) => {
        if (r.key === ae.SPACE && !this.eCheckbox.isDisabled()) {
          this.params.eGridCell === this.gos.getActiveDomElement() && this.eCheckbox.toggle();
          const n = this.eCheckbox.getValue();
          this.onCheckboxChanged(n), r.preventDefault();
        }
      }
    });
  }
  refresh(e) {
    return this.params = e, this.updateCheckbox(e), !0;
  }
  updateCheckbox(e) {
    var s;
    let t, r = !0;
    if (e.node.group && e.column) {
      const l = e.column.getColId();
      l.startsWith(Uv) ? t = e.value == null || e.value === "" ? void 0 : e.value === "true" : e.node.aggData && e.node.aggData[l] !== void 0 ? t = e.value ?? void 0 : r = !1;
    } else
      t = e.value ?? void 0;
    if (!r) {
      this.eCheckbox.setDisplayed(!1);
      return;
    }
    this.eCheckbox.setValue(t);
    const n = e.disabled != null ? e.disabled : !((s = e.column) != null && s.isCellEditable(e.node));
    this.eCheckbox.setDisabled(n);
    const i = this.localeService.getLocaleTextFunc(), o = CA(i, t), a = n ? o : `${i("ariaToggleCellValue", "Press SPACE to toggle cell value")} (${o})`;
    this.eCheckbox.setInputAriaLabel(a);
  }
  onCheckboxChanged(e) {
    const { column: t, node: r, value: n } = this.params, i = {
      type: "cellEditingStarted",
      column: t,
      colDef: t == null ? void 0 : t.getColDef(),
      data: r.data,
      node: r,
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      value: n
    };
    this.eventService.dispatchEvent(i);
    const o = this.params.node.setDataValue(this.params.column, e, "edit"), a = {
      type: "cellEditingStopped",
      column: t,
      colDef: t == null ? void 0 : t.getColDef(),
      data: r.data,
      node: r,
      rowIndex: r.rowIndex,
      rowPinned: r.rowPinned,
      value: n,
      oldValue: n,
      newValue: e,
      valueChanged: o
    };
    this.eventService.dispatchEvent(a);
  }
}, KOe = class extends Nr {
  constructor() {
    super(
      /* html */
      `<div class="ag-loading">
            <span class="ag-loading-icon" data-ref="eLoadingIcon"></span>
            <span class="ag-loading-text" data-ref="eLoadingText"></span>
        </div>`
    ), this.eLoadingIcon = ft, this.eLoadingText = ft;
  }
  init(e) {
    e.node.failedLoad ? this.setupFailed() : this.setupLoading();
  }
  setupFailed() {
    const e = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = e("loadingError", "ERR");
  }
  setupLoading() {
    const e = to("groupLoading", this.gos, null);
    e && this.eLoadingIcon.appendChild(e);
    const t = this.localeService.getLocaleTextFunc();
    this.eLoadingText.innerText = t("loadingOoo", "Loading");
  }
  refresh(e) {
    return !1;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}, YOe = class extends Nr {
  constructor() {
    super(
      /* html */
      '<div class="ag-skeleton-container"></div>'
    );
  }
  init(e) {
    const t = `ag-cell-skeleton-renderer-${this.getCompId()}`;
    this.getGui().setAttribute("id", t), this.addDestroyFunc(() => av(e.eParentOfValue)), av(e.eParentOfValue, t), e.node.failedLoad ? this.setupFailed() : this.setupLoading(e);
  }
  setupFailed() {
    const e = this.localeService.getLocaleTextFunc();
    this.getGui().innerText = e("loadingError", "ERR");
    const t = e("ariaSkeletonCellLoadingFailed", "Row failed to load");
    $h(this.getGui(), t);
  }
  setupLoading(e) {
    const r = this.gos.getDocument().createElement("div");
    r.classList.add("ag-skeleton-effect");
    const n = e.node.rowIndex;
    if (n != null) {
      const a = 75 + 25 * (n % 2 === 0 ? Math.sin(n) : Math.cos(n));
      r.style.width = `${a}%`;
    }
    this.getGui().appendChild(r);
    const o = this.localeService.getLocaleTextFunc()("ariaSkeletonCellLoading", "Row data is loading");
    $h(this.getGui(), o);
  }
  refresh(e) {
    return !1;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}, xK = class extends Nr {
  constructor() {
    super();
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
}, qOe = class extends xK {
  init() {
    const e = this.gos.get("overlayLoadingTemplate");
    if (this.setTemplate(
      e ?? /* html */
      '<span aria-live="polite" aria-atomic="true" class="ag-overlay-loading-center"></span>'
    ), !e) {
      const t = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = t("loadingOoo", "Loading...");
      });
    }
  }
}, ZOe = class extends xK {
  init() {
    const e = this.gos.get("overlayNoRowsTemplate");
    if (this.setTemplate(e ?? /* html */
    '<span class="ag-overlay-no-rows-center"></span>'), !e) {
      const t = this.localeService.getLocaleTextFunc();
      setTimeout(() => {
        this.getGui().textContent = t("noRowsToShow", "No Rows To Show");
      });
    }
  }
}, xf = class extends Nr {
  isPopup() {
    return !0;
  }
  setParentComponent(e) {
    e.addCssClass("ag-has-popup"), super.setParentComponent(e);
  }
  destroy() {
    const e = this.parentComponent;
    e && e.isAlive() && e.getGui().classList.remove("ag-has-popup"), super.destroy();
  }
}, XOe = class extends xf {
  constructor() {
    super(
      /* html */
      '<div class="ag-tooltip"></div>'
    );
  }
  // will need to type params
  init(e) {
    const { value: t } = e;
    this.getGui().textContent = Za(t, !0);
  }
};
function QOe(e, t, r) {
  const n = {}, i = e.filter(
    (o) => !t.some((a) => a === o)
  );
  return i.length > 0 && i.forEach(
    (o) => n[o] = EK(o, r).values
  ), n;
}
function EK(e, t, r, n) {
  let i = t.map((s, l) => ({
    value: s,
    relevance: JOe(e.toLowerCase(), s.toLocaleLowerCase()),
    idx: l
  }));
  if (i.sort((s, l) => l.relevance - s.relevance), r && (i = i.filter((s) => s.relevance !== 0)), i.length > 0 && n && n > 0) {
    const l = i[0].relevance * n;
    i = i.filter((u) => l - u.relevance < 0);
  }
  const o = [], a = [];
  for (const s of i)
    o.push(s.value), a.push(s.idx);
  return { values: o, indices: a };
}
function JOe(e, t) {
  const r = e.replace(/\s/g, ""), n = t.replace(/\s/g, "");
  let i = 0, o = -1;
  for (let a = 0; a < r.length; a++) {
    const s = n.indexOf(r[a], o + 1);
    s !== -1 && (o = s, i += 100 - o * 100 / 1e4 * 100);
  }
  return i;
}
var eNe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "userComponentRegistry", this.agGridDefaults = {
      //header
      agColumnHeader: PT,
      agColumnGroupHeader: GOe,
      agSortIndicator: RA,
      // renderers
      agAnimateShowChangeCellRenderer: $Oe,
      agAnimateSlideCellRenderer: WOe,
      agLoadingCellRenderer: KOe,
      agSkeletonCellRenderer: YOe,
      agCheckboxCellRenderer: UOe,
      //overlays
      agLoadingOverlay: qOe,
      agNoRowsOverlay: ZOe,
      // tooltips
      agTooltipComponent: XOe
    }, this.enterpriseAgDefaultCompsModule = {
      agSetColumnFilter: "@ag-grid-enterprise/set-filter",
      agSetColumnFloatingFilter: "@ag-grid-enterprise/set-filter",
      agMultiColumnFilter: "@ag-grid-enterprise/multi-filter",
      agMultiColumnFloatingFilter: "@ag-grid-enterprise/multi-filter",
      agGroupColumnFilter: "@ag-grid-enterprise/row-grouping",
      agGroupColumnFloatingFilter: "@ag-grid-enterprise/row-grouping",
      agGroupCellRenderer: "@ag-grid-enterprise/row-grouping",
      // Actually in enterprise core as used by MasterDetail too but best guess is they are grouping
      agGroupRowRenderer: "@ag-grid-enterprise/row-grouping",
      // Actually in enterprise core as used by MasterDetail but best guess is they are grouping
      agRichSelect: "@ag-grid-enterprise/rich-select",
      agRichSelectCellEditor: "@ag-grid-enterprise/rich-select",
      agDetailCellRenderer: "@ag-grid-enterprise/master-detail",
      agSparklineCellRenderer: "@ag-grid-enterprise/sparklines"
      /* SparklinesModule */
    }, this.jsComps = {};
  }
  postConstruct() {
    const e = this.gos.get("components");
    e != null && ia(e, (t, r) => this.registerJsComponent(t, r));
  }
  registerDefaultComponent(e, t) {
    this.agGridDefaults[e] = t;
  }
  registerJsComponent(e, t) {
    this.jsComps[e] = t;
  }
  retrieve(e, t) {
    const r = (s, l) => ({
      componentFromFramework: l,
      component: s
    }), n = this.getFrameworkOverrides().frameworkComponent(
      t,
      this.gos.get("components")
    );
    if (n != null)
      return r(n, !0);
    const i = this.jsComps[t];
    if (i) {
      const s = this.getFrameworkOverrides().isFrameworkComponent(i);
      return r(i, s);
    }
    const o = this.agGridDefaults[t];
    if (o)
      return r(o, !1);
    const a = this.enterpriseAgDefaultCompsModule[t];
    return a ? Xn.__assertRegistered(
      a,
      `AG Grid '${e}' component: ${t}`,
      this.gridId
    ) : gA(() => {
      this.warnAboutMissingComponent(e, t);
    }, "MissingComp" + t), null;
  }
  warnAboutMissingComponent(e, t) {
    const r = [
      // Don't include the old names / internals in potential suggestions
      ...Object.keys(this.agGridDefaults).filter(
        (i) => !["agCellEditor", "agGroupRowRenderer", "agSortIndicator"].includes(i)
      ),
      ...Object.keys(this.jsComps)
    ], n = EK(t, r, !0, 0.8).values;
    Se(
      `Could not find '${t}' component. It was configured as "${e}: '${t}'" but it wasn't found in the list of registered components.`
    ), n.length > 0 && Se(`         Did you mean: [${n.slice(0, 3)}]?`), Se(
      `If using a custom component check it has been registered as described in: ${this.getFrameworkOverrides().getDocLink("components/")}`
    );
  }
}, en = class kp {
  constructor(t) {
    this.status = 0, this.resolution = null, this.waiters = [], t(
      (r) => this.onDone(r),
      (r) => this.onReject(r)
    );
  }
  static all(t) {
    return t.length ? new kp((r) => {
      let n = t.length;
      const i = new Array(n);
      t.forEach((o, a) => {
        o.then((s) => {
          i[a] = s, n--, n === 0 && r(i);
        });
      });
    }) : kp.resolve();
  }
  static resolve(t = null) {
    return new kp((r) => r(t));
  }
  then(t) {
    return new kp((r) => {
      this.status === 1 ? r(t(this.resolution)) : this.waiters.push((n) => r(t(n)));
    });
  }
  onDone(t) {
    this.status = 1, this.resolution = t, this.waiters.forEach((r) => r(t));
  }
  onReject(t) {
  }
}, tNe = {
  propertyName: "dateComponent",
  cellRenderer: !1
}, rNe = {
  propertyName: "headerComponent",
  cellRenderer: !1
}, nNe = {
  propertyName: "headerGroupComponent",
  cellRenderer: !1
}, IG = {
  propertyName: "cellRenderer",
  cellRenderer: !0
}, iNe = {
  propertyName: "cellRenderer",
  cellRenderer: !1
}, oNe = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, aNe = {
  propertyName: "cellEditor",
  cellRenderer: !1
}, FG = {
  propertyName: "innerRenderer",
  cellRenderer: !0
}, sNe = {
  propertyName: "loadingOverlayComponent",
  cellRenderer: !1
}, lNe = {
  propertyName: "noRowsOverlayComponent",
  cellRenderer: !1
}, uNe = {
  propertyName: "tooltipComponent",
  cellRenderer: !1
}, PA = {
  propertyName: "filter",
  cellRenderer: !1
}, cNe = {
  propertyName: "floatingFilterComponent",
  cellRenderer: !1
}, dNe = {
  propertyName: "toolPanel",
  cellRenderer: !1
}, hNe = {
  propertyName: "statusPanel",
  cellRenderer: !1
}, fNe = {
  propertyName: "fullWidthCellRenderer",
  cellRenderer: !0
}, pNe = {
  propertyName: "loadingCellRenderer",
  cellRenderer: !0
}, gNe = {
  propertyName: "groupRowRenderer",
  cellRenderer: !0
}, vNe = {
  propertyName: "detailCellRenderer",
  cellRenderer: !0
}, mNe = {
  propertyName: "menuItem",
  cellRenderer: !1
}, RK = class _K extends he {
  constructor() {
    super(...arguments), this.beanName = "userComponentFactory";
  }
  wireBeans(t) {
    this.agComponentUtils = t.agComponentUtils, this.componentMetadataProvider = t.componentMetadataProvider, this.userComponentRegistry = t.userComponentRegistry, this.frameworkComponentWrapper = t.frameworkComponentWrapper, this.gridOptions = t.gridOptions;
  }
  getHeaderCompDetails(t, r) {
    return this.getCompDetails(t, rNe, "agColumnHeader", r);
  }
  getHeaderGroupCompDetails(t) {
    const r = t.columnGroup.getColGroupDef();
    return this.getCompDetails(r, nNe, "agColumnGroupHeader", t);
  }
  // this one is unusual, as it can be LoadingCellRenderer, DetailCellRenderer, FullWidthCellRenderer or GroupRowRenderer.
  // so we have to pass the type in.
  getFullWidthCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, fNe, null, t, !0);
  }
  getFullWidthLoadingCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, pNe, "agLoadingCellRenderer", t, !0);
  }
  getFullWidthGroupCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, gNe, "agGroupRowRenderer", t, !0);
  }
  getFullWidthDetailCellRendererDetails(t) {
    return this.getCompDetails(this.gridOptions, vNe, "agDetailCellRenderer", t, !0);
  }
  // CELL RENDERER
  getInnerRendererDetails(t, r) {
    return this.getCompDetails(t, FG, null, r);
  }
  getFullWidthGroupRowInnerCellRenderer(t, r) {
    return this.getCompDetails(t, FG, null, r);
  }
  getCellRendererDetails(t, r) {
    return this.getCompDetails(t, IG, null, r);
  }
  getEditorRendererDetails(t, r) {
    return this.getCompDetails(t, iNe, null, r);
  }
  getLoadingCellRendererDetails(t, r) {
    return this.getCompDetails(t, oNe, "agSkeletonCellRenderer", r, !0);
  }
  // CELL EDITOR
  getCellEditorDetails(t, r) {
    return this.getCompDetails(t, aNe, "agCellEditor", r, !0);
  }
  // FILTER
  getFilterDetails(t, r, n) {
    return this.getCompDetails(t, PA, n, r, !0);
  }
  getDateCompDetails(t) {
    return this.getCompDetails(this.gridOptions, tNe, "agDateInput", t, !0);
  }
  getLoadingOverlayCompDetails(t) {
    return this.getCompDetails(this.gridOptions, sNe, "agLoadingOverlay", t, !0);
  }
  getNoRowsOverlayCompDetails(t) {
    return this.getCompDetails(this.gridOptions, lNe, "agNoRowsOverlay", t, !0);
  }
  getTooltipCompDetails(t) {
    return this.getCompDetails(t.colDef, uNe, "agTooltipComponent", t, !0);
  }
  getSetFilterCellRendererDetails(t, r) {
    return this.getCompDetails(t, IG, null, r);
  }
  getFloatingFilterCompDetails(t, r, n) {
    return this.getCompDetails(t, cNe, n, r);
  }
  getToolPanelCompDetails(t, r) {
    return this.getCompDetails(t, dNe, null, r, !0);
  }
  getStatusPanelCompDetails(t, r) {
    return this.getCompDetails(t, hNe, null, r, !0);
  }
  getMenuItemCompDetails(t, r) {
    return this.getCompDetails(t, mNe, "agMenuItem", r, !0);
  }
  getCompDetails(t, r, n, i, o = !1) {
    const { propertyName: a, cellRenderer: s } = r;
    let { compName: l, jsComp: u, fwComp: c, paramsFromSelector: d, popupFromSelector: h, popupPositionFromSelector: f } = _K.getCompKeys(this.frameworkOverrides, t, r, i);
    const p = (y) => {
      const C = this.userComponentRegistry.retrieve(a, y);
      C && (u = C.componentFromFramework ? void 0 : C.component, c = C.componentFromFramework ? C.component : void 0);
    };
    if (l != null && p(l), u == null && c == null && n != null && p(n), u && s && !this.agComponentUtils.doesImplementIComponent(u) && (u = this.agComponentUtils.adaptFunction(a, u)), !u && !c) {
      o && sr(`Could not find component ${l}, did you forget to configure this component?`);
      return;
    }
    const g = this.mergeParamsWithApplicationProvidedParams(t, r, i, d), v = u == null, m = u || c;
    return {
      componentFromFramework: v,
      componentClass: m,
      params: g,
      type: r,
      popupFromSelector: h,
      popupPositionFromSelector: f,
      newAgStackInstance: () => this.newAgStackInstance(m, v, g, r)
    };
  }
  static getCompKeys(t, r, n, i) {
    const { propertyName: o } = n;
    let a, s, l, u, c, d;
    if (r) {
      const h = r, f = h[o + "Selector"], p = f ? f(i) : null, g = (v) => {
        typeof v == "string" ? a = v : v != null && v !== !0 && (t.isFrameworkComponent(v) ? l = v : s = v);
      };
      p ? (g(p.component), u = p.params, c = p.popup, d = p.popupPosition) : g(h[o]);
    }
    return { compName: a, jsComp: s, fwComp: l, paramsFromSelector: u, popupFromSelector: c, popupPositionFromSelector: d };
  }
  newAgStackInstance(t, r, n, i) {
    const o = i.propertyName, a = !r;
    let s;
    if (a)
      s = new t();
    else {
      const u = this.componentMetadataProvider.retrieve(o);
      s = this.frameworkComponentWrapper.wrap(
        t,
        u.mandatoryMethodList,
        u.optionalMethodList,
        i
      );
    }
    const l = this.initComponent(s, n);
    return l == null ? en.resolve(s) : l.then(() => s);
  }
  // used by Floating Filter
  mergeParamsWithApplicationProvidedParams(t, r, n, i = null) {
    const o = this.gos.getGridCommonParams();
    To(o, n);
    const a = t, s = a && a[r.propertyName + "Params"];
    if (typeof s == "function") {
      const l = s(n);
      To(o, l);
    } else typeof s == "object" && To(o, s);
    return To(o, i), o;
  }
  initComponent(t, r) {
    if (this.createBean(t), t.init != null)
      return t.init(r);
  }
};
function dg(e) {
  const t = e;
  return t != null && t.getFrameworkComponentInstance != null ? t.getFrameworkComponentInstance() : e;
}
var yNe = class {
  constructor(e) {
    this.beans = {}, this.createdBeans = [], this.destroyed = !1, !(!e || !e.beanClasses) && (this.beanDestroyComparator = e.beanDestroyComparator, this.init(e));
  }
  init(e) {
    var t;
    Object.entries(e.providedBeanInstances).forEach(([r, n]) => {
      this.beans[r] = n;
    }), e.beanClasses.forEach((r) => {
      const n = new r();
      n.beanName ? this.beans[n.beanName] = n : console.error(`Bean ${r.name} is missing beanName`), this.createdBeans.push(n);
    }), (t = e.derivedBeans) == null || t.forEach((r) => {
      const { beanName: n, bean: i } = r(this);
      this.beans[n] = i, this.createdBeans.push(i);
    }), e.beanInitComparator && this.createdBeans.sort(e.beanInitComparator), this.initBeans(this.createdBeans);
  }
  getBeanInstances() {
    return Object.values(this.beans);
  }
  createBean(e, t) {
    if (!e)
      throw Error("Can't wire to bean since it is null");
    return this.initBeans([e], t), e;
  }
  initBeans(e, t) {
    e.forEach((r) => {
      var n, i;
      (n = r.preWireBeans) == null || n.call(r, this.beans), (i = r.wireBeans) == null || i.call(r, this.beans);
    }), e.forEach((r) => {
      var n;
      return (n = r.preConstruct) == null ? void 0 : n.call(r);
    }), t && e.forEach(t), e.forEach((r) => {
      var n;
      return (n = r.postConstruct) == null ? void 0 : n.call(r);
    });
  }
  getBeans() {
    return this.beans;
  }
  getBean(e) {
    return this.beans[e];
  }
  destroy() {
    if (this.destroyed)
      return;
    this.destroyed = !0;
    const e = this.getBeanInstances();
    this.beanDestroyComparator && e.sort(this.beanDestroyComparator), this.destroyBeans(e), this.beans = {}, this.createdBeans = [];
  }
  /**
   * Destroys a bean and returns undefined to support destruction and clean up in a single line.
   * this.dateComp = this.context.destroyBean(this.dateComp);
   */
  destroyBean(e) {
    var t;
    (t = e == null ? void 0 : e.destroy) == null || t.call(e);
  }
  /**
   * Destroys an array of beans and returns an empty array to support destruction and clean up in a single line.
   * this.dateComps = this.context.destroyBeans(this.dateComps);
   */
  destroyBeans(e) {
    if (e)
      for (let t = 0; t < e.length; t++)
        this.destroyBean(e[t]);
    return [];
  }
  isDestroyed() {
    return this.destroyed;
  }
}, CNe = class extends yNe {
  init(e) {
    this.gridId = e.gridId, this.beans.context = this, super.init(e);
  }
  destroy() {
    super.destroy(), Xn.__unRegisterGridModules(this.gridId);
  }
  getGridId() {
    return this.gridId;
  }
}, TK = /* @__PURE__ */ ((e) => (e[e.Left = 0] = "Left", e[e.Right = 1] = "Right", e))(TK || {}), SNe = (
  /* html */
  `<div class="ag-dnd-ghost ag-unselectable">
<span class="ag-dnd-ghost-icon ag-shake-left-to-right"></span>
<div class="ag-dnd-ghost-label"></div>
</div>`
), wNe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "dragAndDropService", this.dragSourceAndParamsList = [], this.dropTargets = [];
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.mouseEventService = e.mouseEventService, this.environment = e.environment;
  }
  postConstruct() {
    this.dropIconMap = {
      pinned: vs("columnMovePin", this.gos, null),
      hide: vs("columnMoveHide", this.gos, null),
      move: vs("columnMoveMove", this.gos, null),
      left: vs("columnMoveLeft", this.gos, null),
      right: vs("columnMoveRight", this.gos, null),
      group: vs("columnMoveGroup", this.gos, null),
      aggregate: vs("columnMoveValue", this.gos, null),
      pivot: vs("columnMovePivot", this.gos, null),
      notAllowed: vs("dropNotAllowed", this.gos, null)
    };
  }
  addDragSource(e, t = !1) {
    const r = {
      eElement: e.eElement,
      dragStartPixels: e.dragStartPixels,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this),
      onDragging: this.onDragging.bind(this),
      includeTouch: t
    };
    this.dragSourceAndParamsList.push({ params: r, dragSource: e }), this.dragService.addDragSource(r);
  }
  removeDragSource(e) {
    const t = this.dragSourceAndParamsList.find((r) => r.dragSource === e);
    t && (this.dragService.removeDragSource(t.params), gi(this.dragSourceAndParamsList, t));
  }
  destroy() {
    this.dragSourceAndParamsList.forEach(
      (e) => this.dragService.removeDragSource(e.params)
    ), this.dragSourceAndParamsList.length = 0, this.dropTargets.length = 0, super.destroy();
  }
  nudge() {
    this.dragging && this.onDragging(this.eventLastTime, !0);
  }
  onDragStart(e, t) {
    this.dragging = !0, this.dragSource = e, this.eventLastTime = t, this.dragItem = this.dragSource.getDragItem(), this.dragSource.onDragStarted && this.dragSource.onDragStarted(), this.createGhost();
  }
  onDragStop(e) {
    if (this.eventLastTime = null, this.dragging = !1, this.dragSource.onDragStopped && this.dragSource.onDragStopped(), this.lastDropTarget && this.lastDropTarget.onDragStop) {
      const t = this.createDropTargetEvent(this.lastDropTarget, e, null, null, !1);
      this.lastDropTarget.onDragStop(t);
    }
    this.lastDropTarget = void 0, this.dragItem = null, this.removeGhost();
  }
  onDragging(e, t) {
    var a, s, l, u;
    const r = this.getHorizontalDirection(e), n = this.getVerticalDirection(e);
    this.eventLastTime = e, this.positionGhost(e);
    const i = this.dropTargets.filter((c) => this.isMouseOnDropTarget(e, c)), o = this.findCurrentDropTarget(e, i);
    if (o !== this.lastDropTarget)
      this.leaveLastTargetIfExists(e, r, n, t), this.lastDropTarget !== null && o === null && ((s = (a = this.dragSource).onGridExit) == null || s.call(a, this.dragItem)), this.lastDropTarget === null && o !== null && ((u = (l = this.dragSource).onGridEnter) == null || u.call(l, this.dragItem)), this.enterDragTargetIfExists(o, e, r, n, t), this.lastDropTarget = o;
    else if (o && o.onDragging) {
      const c = this.createDropTargetEvent(o, e, r, n, t);
      o.onDragging(c);
    }
  }
  getAllContainersFromDropTarget(e) {
    const t = e.getSecondaryContainers ? e.getSecondaryContainers() : null, r = [[e.getContainer()]];
    return t ? r.concat(t) : r;
  }
  allContainersIntersect(e, t) {
    for (const r of t) {
      const n = r.getBoundingClientRect();
      if (n.width === 0 || n.height === 0)
        return !1;
      const i = e.clientX >= n.left && e.clientX < n.right, o = e.clientY >= n.top && e.clientY < n.bottom;
      if (!i || !o)
        return !1;
    }
    return !0;
  }
  // checks if the mouse is on the drop target. it checks eContainer and eSecondaryContainers
  isMouseOnDropTarget(e, t) {
    const r = this.getAllContainersFromDropTarget(t);
    let n = !1;
    for (const i of r)
      if (this.allContainersIntersect(e, i)) {
        n = !0;
        break;
      }
    return t.targetContainsSource && !t.getContainer().contains(this.dragSource.eElement) ? !1 : n && t.isInterestedIn(this.dragSource.type, this.dragSource.eElement);
  }
  findCurrentDropTarget(e, t) {
    const r = t.length;
    if (r === 0)
      return null;
    if (r === 1)
      return t[0];
    const i = this.gos.getRootNode().elementsFromPoint(e.clientX, e.clientY);
    for (const o of i)
      for (const a of t)
        if (TLe(this.getAllContainersFromDropTarget(a)).indexOf(o) !== -1)
          return a;
    return null;
  }
  enterDragTargetIfExists(e, t, r, n, i) {
    if (e) {
      if (e.onDragEnter) {
        const o = this.createDropTargetEvent(
          e,
          t,
          r,
          n,
          i
        );
        e.onDragEnter(o);
      }
      this.setGhostIcon(e.getIconName ? e.getIconName() : null);
    }
  }
  leaveLastTargetIfExists(e, t, r, n) {
    if (this.lastDropTarget) {
      if (this.lastDropTarget.onDragLeave) {
        const i = this.createDropTargetEvent(
          this.lastDropTarget,
          e,
          t,
          r,
          n
        );
        this.lastDropTarget.onDragLeave(i);
      }
      this.setGhostIcon(null);
    }
  }
  addDropTarget(e) {
    this.dropTargets.push(e);
  }
  removeDropTarget(e) {
    this.dropTargets = this.dropTargets.filter((t) => t.getContainer() !== e.getContainer());
  }
  hasExternalDropZones() {
    return this.dropTargets.some((e) => e.external);
  }
  findExternalZone(e) {
    return this.dropTargets.filter((r) => r.external).find((r) => r.getContainer() === e.getContainer()) || null;
  }
  getHorizontalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientX, r = e.clientX;
    return t === r ? null : t > r ? 0 : 1;
  }
  getVerticalDirection(e) {
    const t = this.eventLastTime && this.eventLastTime.clientY, r = e.clientY;
    return t === r ? null : t > r ? 0 : 1;
  }
  createDropTargetEvent(e, t, r, n, i) {
    const o = e.getContainer(), a = o.getBoundingClientRect(), { dragItem: s, dragSource: l } = this, u = t.clientX - a.left, c = t.clientY - a.top;
    return this.gos.addGridCommonParams({
      event: t,
      x: u,
      y: c,
      vDirection: n,
      hDirection: r,
      dragSource: l,
      fromNudge: i,
      dragItem: s,
      dropZoneTarget: o
    });
  }
  positionGhost(e) {
    const t = this.eGhost;
    if (!t)
      return;
    const n = t.getBoundingClientRect().height, i = xOe() - 2, o = EOe() - 2, a = gK(t.offsetParent), { clientY: s, clientX: l } = e;
    let u = s - a.top - n / 2, c = l - a.left - 10;
    const d = this.gos.getDocument(), h = d.defaultView || window, f = h.pageYOffset || d.documentElement.scrollTop, p = h.pageXOffset || d.documentElement.scrollLeft;
    i > 0 && c + t.clientWidth > i + p && (c = i + p - t.clientWidth), c < 0 && (c = 0), o > 0 && u + t.clientHeight > o + f && (u = o + f - t.clientHeight), u < 0 && (u = 0), t.style.left = `${c}px`, t.style.top = `${u}px`;
  }
  removeGhost() {
    this.eGhost && this.eGhostParent && this.eGhostParent.removeChild(this.eGhost), this.eGhost = null;
  }
  createGhost() {
    this.eGhost = Wh(SNe), this.mouseEventService.stampTopLevelGridCompWithGridInstance(this.eGhost), this.environment.applyThemeClasses(this.eGhost), this.eGhostIcon = this.eGhost.querySelector(".ag-dnd-ghost-icon"), this.setGhostIcon(null);
    const e = this.eGhost.querySelector(".ag-dnd-ghost-label");
    let t = this.dragSource.dragItemName;
    vA(t) && (t = t()), e.innerHTML = Za(t) || "", this.eGhost.style.height = "25px", this.eGhost.style.top = "20px", this.eGhost.style.left = "20px";
    const r = this.gos.getDocument();
    let n = null, i = null;
    try {
      n = r.fullscreenElement;
    } catch {
    } finally {
      n || (n = this.gos.getRootNode());
      const o = n.querySelector("body");
      o ? i = o : n instanceof ShadowRoot ? i = n : n instanceof Document ? i = n == null ? void 0 : n.documentElement : i = n;
    }
    this.eGhostParent = i, this.eGhostParent ? this.eGhostParent.appendChild(this.eGhost) : Se("Could not find document body, it is needed for dragging columns");
  }
  setGhostIcon(e, t = !1) {
    oo(this.eGhostIcon);
    let r = null;
    e || (e = this.dragSource.getDefaultIconName ? this.dragSource.getDefaultIconName() : "notAllowed"), r = this.dropIconMap[e], this.eGhostIcon.classList.toggle("ag-shake-left-to-right", t), !(r === this.dropIconMap.hide && this.gos.get("suppressDragLeaveHidesColumns")) && r && this.eGhostIcon.appendChild(r);
  }
}, bNe = class {
  constructor(e) {
    this.tickingInterval = null, this.onScrollCallback = null, this.scrollContainer = e.scrollContainer, this.scrollHorizontally = e.scrollAxis.indexOf("x") !== -1, this.scrollVertically = e.scrollAxis.indexOf("y") !== -1, this.scrollByTick = e.scrollByTick != null ? e.scrollByTick : 20, e.onScrollCallback && (this.onScrollCallback = e.onScrollCallback), this.scrollVertically && (this.getVerticalPosition = e.getVerticalPosition, this.setVerticalPosition = e.setVerticalPosition), this.scrollHorizontally && (this.getHorizontalPosition = e.getHorizontalPosition, this.setHorizontalPosition = e.setHorizontalPosition), this.shouldSkipVerticalScroll = e.shouldSkipVerticalScroll || (() => !1), this.shouldSkipHorizontalScroll = e.shouldSkipHorizontalScroll || (() => !1);
  }
  check(e, t = !1) {
    const r = t || this.shouldSkipVerticalScroll();
    if (r && this.shouldSkipHorizontalScroll())
      return;
    const n = this.scrollContainer.getBoundingClientRect(), i = this.scrollByTick;
    this.tickLeft = e.clientX < n.left + i, this.tickRight = e.clientX > n.right - i, this.tickUp = e.clientY < n.top + i && !r, this.tickDown = e.clientY > n.bottom - i && !r, this.tickLeft || this.tickRight || this.tickUp || this.tickDown ? this.ensureTickingStarted() : this.ensureCleared();
  }
  ensureTickingStarted() {
    this.tickingInterval === null && (this.tickingInterval = window.setInterval(this.doTick.bind(this), 100), this.tickCount = 0);
  }
  doTick() {
    this.tickCount++;
    const e = this.tickCount > 20 ? 200 : this.tickCount > 10 ? 80 : 40;
    if (this.scrollVertically) {
      const t = this.getVerticalPosition();
      this.tickUp && this.setVerticalPosition(t - e), this.tickDown && this.setVerticalPosition(t + e);
    }
    if (this.scrollHorizontally) {
      const t = this.getHorizontalPosition();
      this.tickLeft && this.setHorizontalPosition(t - e), this.tickRight && this.setHorizontalPosition(t + e);
    }
    this.onScrollCallback && this.onScrollCallback();
  }
  ensureCleared() {
    this.tickingInterval && (window.clearInterval(this.tickingInterval), this.tickingInterval = null);
  }
}, xNe = class extends he {
  wireBeans(e) {
    this.dragAndDropService = e.dragAndDropService, this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService, this.focusService = e.focusService, this.sortController = e.sortController, this.filterManager = e.filterManager, this.selectionService = e.selectionService, this.mouseEventService = e.mouseEventService, this.ctrlsService = e.ctrlsService, this.funcColsService = e.funcColsService, this.rangeService = e.rangeService;
  }
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    this.gos.isRowModelType("clientSide") && (this.clientSideRowModel = this.rowModel), this.ctrlsService.whenReady((e) => {
      const t = e.gridBodyCtrl;
      this.autoScrollService = new bNe({
        scrollContainer: t.getBodyViewportElement(),
        scrollAxis: "y",
        getVerticalPosition: () => t.getScrollFeature().getVScrollPosition().top,
        setVerticalPosition: (r) => t.getScrollFeature().setVerticalScrollPosition(r),
        onScrollCallback: () => {
          this.onDragging(this.lastDraggingEvent);
        }
      });
    });
  }
  getContainer() {
    return this.eContainer;
  }
  isInterestedIn(e) {
    return e === 2;
  }
  getIconName() {
    return this.gos.get("rowDragManaged") && this.shouldPreventRowMove() ? "notAllowed" : "move";
  }
  shouldPreventRowMove() {
    var n;
    return !!(this.funcColsService.getRowGroupColumns().length || ((n = this.filterManager) == null ? void 0 : n.isAnyFilterPresent()) || this.sortController.isSortActive());
  }
  getRowNodes(e) {
    if (!this.isFromThisGrid(e))
      return e.dragItem.rowNodes || [];
    const t = e.dragItem.rowNode;
    if (this.gos.get("rowDragMultiRow")) {
      const n = [...this.selectionService.getSelectedNodes()].sort((i, o) => i.rowIndex == null || o.rowIndex == null ? 0 : this.getRowIndexNumber(i) - this.getRowIndexNumber(o));
      if (n.indexOf(t) !== -1)
        return n;
    }
    return [t];
  }
  onDragEnter(e) {
    e.dragItem.rowNodes = this.getRowNodes(e), this.dispatchGridEvent("rowDragEnter", e), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!0);
    }), this.onEnterOrDragging(e);
  }
  onDragging(e) {
    this.onEnterOrDragging(e);
  }
  isFromThisGrid(e) {
    const { dragSourceDomDataKey: t } = e.dragSource;
    return t === this.gos.getDomDataKey();
  }
  isDropZoneWithinThisGrid(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getGui(), { dropZoneTarget: n } = e;
    return !r.contains(n);
  }
  onEnterOrDragging(e) {
    this.dispatchGridEvent("rowDragMove", e), this.lastDraggingEvent = e;
    const t = this.mouseEventService.getNormalisedPosition(e).y;
    this.gos.get("rowDragManaged") && this.doManagedDrag(e, t), this.autoScrollService.check(e.event);
  }
  doManagedDrag(e, t) {
    const r = this.isFromThisGrid(e), n = this.gos.get("rowDragManaged"), i = e.dragItem.rowNodes;
    n && this.shouldPreventRowMove() || (this.gos.get("suppressMoveWhenRowDragging") || !r ? this.isDropZoneWithinThisGrid(e) || this.clientSideRowModel.highlightRowAtPixel(i[0], t) : this.moveRows(i, t));
  }
  getRowIndexNumber(e) {
    const t = e.getRowIndexString();
    return parseInt(Jt(t.split("-")), 10);
  }
  moveRowAndClearHighlight(e) {
    const t = this.clientSideRowModel.getLastHighlightedRowNode(), r = t && t.highlighted === 1, n = this.mouseEventService.getNormalisedPosition(e).y, i = e.dragItem.rowNodes;
    let o = r ? 1 : 0;
    if (this.isFromThisGrid(e))
      i.forEach((a) => {
        a.rowTop < n && (o -= 1);
      }), this.moveRows(i, n, o);
    else {
      const a = this.gos.getRowIdCallback();
      let s = this.clientSideRowModel.getRowIndexAtPixel(n) + 1;
      this.clientSideRowModel.getHighlightPosition(n) === 0 && s--, this.clientSideRowModel.updateRowData({
        add: i.filter(
          (l) => !this.clientSideRowModel.getRowNode(
            (a == null ? void 0 : a({ data: l.data, level: 0, rowPinned: l.rowPinned })) ?? l.data.id
          )
        ).map((l) => l.data),
        addIndex: s
      });
    }
    this.clearRowHighlight();
  }
  clearRowHighlight() {
    this.clientSideRowModel.highlightRowAtPixel(null);
  }
  moveRows(e, t, r = 0) {
    var i;
    this.clientSideRowModel.ensureRowsAtPixel(e, t, r) && (this.focusService.clearFocusedCell(), (i = this.rangeService) == null || i.removeAllCellRanges());
  }
  addRowDropZone(e) {
    if (!e.getContainer()) {
      Se("addRowDropZone - A container target needs to be provided");
      return;
    }
    if (this.dragAndDropService.findExternalZone(e)) {
      Se(
        "addRowDropZone - target already exists in the list of DropZones. Use `removeRowDropZone` before adding it again."
      );
      return;
    }
    let t = {
      getContainer: e.getContainer
    };
    e.fromGrid ? t = e : (e.onDragEnter && (t.onDragEnter = (r) => {
      e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", r));
    }), e.onDragLeave && (t.onDragLeave = (r) => {
      e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", r));
    }), e.onDragging && (t.onDragging = (r) => {
      e.onDragging(this.draggingToRowDragEvent("rowDragMove", r));
    }), e.onDragStop && (t.onDragStop = (r) => {
      e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", r));
    })), this.dragAndDropService.addDropTarget({
      isInterestedIn: (r) => r === 2,
      getIconName: () => "move",
      external: !0,
      ...t
    });
  }
  getRowDropZone(e) {
    const t = this.getContainer.bind(this), r = this.onDragEnter.bind(this), n = this.onDragLeave.bind(this), i = this.onDragging.bind(this), o = this.onDragStop.bind(this);
    return e ? {
      getContainer: t,
      onDragEnter: e.onDragEnter ? (a) => {
        r(a), e.onDragEnter(this.draggingToRowDragEvent("rowDragEnter", a));
      } : r,
      onDragLeave: e.onDragLeave ? (a) => {
        n(a), e.onDragLeave(this.draggingToRowDragEvent("rowDragLeave", a));
      } : n,
      onDragging: e.onDragging ? (a) => {
        i(a), e.onDragging(this.draggingToRowDragEvent("rowDragMove", a));
      } : i,
      onDragStop: e.onDragStop ? (a) => {
        o(a), e.onDragStop(this.draggingToRowDragEvent("rowDragEnd", a));
      } : o,
      fromGrid: !0
    } : {
      getContainer: t,
      onDragEnter: r,
      onDragLeave: n,
      onDragging: i,
      onDragStop: o,
      /* @private */
      fromGrid: !0
    };
  }
  draggingToRowDragEvent(e, t) {
    const r = this.mouseEventService.getNormalisedPosition(t).y, n = r > this.pageBoundsService.getCurrentPageHeight();
    let i = -1, o;
    n || (i = this.rowModel.getRowIndexAtPixel(r), o = this.rowModel.getRow(i));
    let a;
    switch (t.vDirection) {
      case 1:
        a = "down";
        break;
      case 0:
        a = "up";
        break;
      default:
        a = null;
        break;
    }
    return this.gos.addGridCommonParams({
      type: e,
      event: t.event,
      node: t.dragItem.rowNode,
      nodes: t.dragItem.rowNodes,
      overIndex: i,
      overNode: o,
      y: r,
      vDirection: a
    });
  }
  dispatchGridEvent(e, t) {
    const r = this.draggingToRowDragEvent(e, t);
    this.eventService.dispatchEvent(r);
  }
  onDragLeave(e) {
    this.dispatchGridEvent("rowDragLeave", e), this.stopDragging(e), this.gos.get("rowDragManaged") && this.clearRowHighlight();
  }
  onDragStop(e) {
    this.dispatchGridEvent("rowDragEnd", e), this.stopDragging(e), this.gos.get("rowDragManaged") && (this.gos.get("suppressMoveWhenRowDragging") || !this.isFromThisGrid(e)) && !this.isDropZoneWithinThisGrid(e) && this.moveRowAndClearHighlight(e);
  }
  stopDragging(e) {
    this.autoScrollService.ensureCleared(), this.getRowNodes(e).forEach((t) => {
      t.setDragging(!1);
    });
  }
}, ENe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "dragService", this.dragEndFunctions = [], this.dragSources = [];
  }
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService;
  }
  destroy() {
    this.dragSources.forEach(this.removeListener.bind(this)), this.dragSources.length = 0, super.destroy();
  }
  removeListener(e) {
    const t = e.dragSource.eElement, r = e.mouseDownListener;
    if (t.removeEventListener("mousedown", r), e.touchEnabled) {
      const n = e.touchStartListener;
      t.removeEventListener("touchstart", n, { passive: !0 });
    }
  }
  removeDragSource(e) {
    const t = this.dragSources.find((r) => r.dragSource === e);
    t && (this.removeListener(t), gi(this.dragSources, t));
  }
  isDragging() {
    return this.dragging;
  }
  addDragSource(e) {
    const t = this.onMouseDown.bind(this, e), { eElement: r, includeTouch: n, stopPropagationForTouch: i } = e;
    r.addEventListener("mousedown", t);
    let o = null;
    const a = this.gos.get("suppressTouch");
    n && !a && (o = (s) => {
      wA(s.target) || (s.cancelable && (s.preventDefault(), i && s.stopPropagation()), this.onTouchStart(e, s));
    }, r.addEventListener("touchstart", o, { passive: !1 })), this.dragSources.push({
      dragSource: e,
      mouseDownListener: t,
      touchStartListener: o,
      touchEnabled: !!n
    });
  }
  getStartTarget() {
    return this.startTarget;
  }
  // gets called whenever mouse down on any drag source
  onTouchStart(e, t) {
    this.currentDragParams = e, this.dragging = !1;
    const r = t.touches[0];
    this.touchLastTime = r, this.touchStart = r;
    const n = (l) => this.onTouchMove(l, e.eElement), i = (l) => this.onTouchUp(l, e.eElement), o = (l) => {
      l.cancelable && l.preventDefault();
    }, a = t.target, s = [
      // Prevents the page document from moving while we are dragging items around.
      // preventDefault needs to be called in the touchmove listener and never inside the
      // touchstart, because using touchstart causes the click event to be cancelled on touch devices.
      {
        target: this.gos.getRootNode(),
        type: "touchmove",
        listener: o,
        options: { passive: !1 }
      },
      { target: a, type: "touchmove", listener: n, options: { passive: !0 } },
      { target: a, type: "touchend", listener: i, options: { passive: !0 } },
      { target: a, type: "touchcancel", listener: i, options: { passive: !0 } }
    ];
    this.addTemporaryEvents(s), e.dragStartPixels === 0 && this.onCommonMove(r, this.touchStart, e.eElement);
  }
  // gets called whenever mouse down on any drag source
  onMouseDown(e, t) {
    const r = t;
    if (e.skipMouseEvent && e.skipMouseEvent(t) || r._alreadyProcessedByDragService || (r._alreadyProcessedByDragService = !0, t.button !== 0))
      return;
    this.shouldPreventMouseEvent(t) && t.preventDefault(), this.currentDragParams = e, this.dragging = !1, this.mouseStartEvent = t, this.startTarget = t.target;
    const n = (l) => this.onMouseMove(l, e.eElement), i = (l) => this.onMouseUp(l, e.eElement), o = (l) => l.preventDefault(), a = this.gos.getRootNode(), s = [
      { target: a, type: "mousemove", listener: n },
      { target: a, type: "mouseup", listener: i },
      { target: a, type: "contextmenu", listener: o }
    ];
    this.addTemporaryEvents(s), e.dragStartPixels === 0 && this.onMouseMove(t, e.eElement);
  }
  addTemporaryEvents(e) {
    e.forEach((t) => {
      const { target: r, type: n, listener: i, options: o } = t;
      r.addEventListener(n, i, o);
    }), this.dragEndFunctions.push(() => {
      e.forEach((t) => {
        const { target: r, type: n, listener: i, options: o } = t;
        r.removeEventListener(n, i, o);
      });
    });
  }
  // returns true if the event is close to the original event by X pixels either vertically or horizontally.
  // we only start dragging after X pixels so this allows us to know if we should start dragging yet.
  isEventNearStartEvent(e, t) {
    const { dragStartPixels: r } = this.currentDragParams, n = Me(r) ? r : 4;
    return SK(e, t, n);
  }
  getFirstActiveTouch(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].identifier === this.touchStart.identifier)
        return e[t];
    return null;
  }
  onCommonMove(e, t, r) {
    if (!this.dragging) {
      if (!this.dragging && this.isEventNearStartEvent(e, t))
        return;
      this.dragging = !0;
      const n = {
        type: "dragStarted",
        target: r
      };
      this.eventService.dispatchEvent(n), this.currentDragParams.onDragStart(t), this.currentDragParams.onDragging(t);
    }
    this.currentDragParams.onDragging(e);
  }
  onTouchMove(e, t) {
    const r = this.getFirstActiveTouch(e.touches);
    r && this.onCommonMove(r, this.touchStart, t);
  }
  // only gets called after a mouse down - as this is only added after mouseDown
  // and is removed when mouseUp happens
  onMouseMove(e, t) {
    var r;
    Zs() && ((r = this.gos.getDocument().getSelection()) == null || r.removeAllRanges()), this.shouldPreventMouseEvent(e) && e.preventDefault(), this.onCommonMove(e, this.mouseStartEvent, t);
  }
  shouldPreventMouseEvent(e) {
    const t = this.gos.get("enableCellTextSelection"), r = e.type === "mousemove";
    return (
      // when `isEnableCellTextSelect` is `true`, we need to preventDefault on mouseMove
      // to avoid the grid text being selected while dragging components.
      t && r && e.cancelable && this.mouseEventService.isEventFromThisGrid(e) && !this.isOverFormFieldElement(e)
    );
  }
  isOverFormFieldElement(e) {
    const t = e.target, r = t == null ? void 0 : t.tagName.toLocaleLowerCase();
    return !!(r != null && r.match("^a$|textarea|input|select|button"));
  }
  onTouchUp(e, t) {
    let r = this.getFirstActiveTouch(e.changedTouches);
    r || (r = this.touchLastTime), this.onUpCommon(r, t);
  }
  onMouseUp(e, t) {
    this.onUpCommon(e, t);
  }
  onUpCommon(e, t) {
    if (this.dragging) {
      this.dragging = !1, this.currentDragParams.onDragStop(e);
      const r = {
        type: "dragStopped",
        target: t
      };
      this.eventService.dispatchEvent(r);
    }
    this.mouseStartEvent = null, this.startTarget = null, this.touchStart = null, this.touchLastTime = null, this.currentDragParams = null, this.dragEndFunctions.forEach((r) => r()), this.dragEndFunctions.length = 0;
  }
}, MT = class extends Nr {
  constructor(e, t, r, n, i, o) {
    super(), this.cellValueFn = e, this.rowNode = t, this.column = r, this.customGui = n, this.dragStartPixels = i, this.suppressVisibilityChange = o, this.dragSource = null;
  }
  wireBeans(e) {
    this.beans = e;
  }
  isCustomGui() {
    return this.customGui != null;
  }
  postConstruct() {
    if (this.customGui ? this.setDragElement(this.customGui, this.dragStartPixels) : (this.setTemplate(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" aria-hidden="true"></div>'
    ), this.getGui().appendChild(to("rowDrag", this.gos, null)), this.addDragSource()), this.checkCompatibility(), !this.suppressVisibilityChange) {
      const e = this.gos.get("rowDragManaged") ? new _Ne(this, this.beans, this.rowNode, this.column) : new RNe(this, this.beans, this.rowNode, this.column);
      this.createManagedBean(e, this.beans.context);
    }
  }
  setDragElement(e, t) {
    this.setTemplateFromElement(e), this.addDragSource(t);
  }
  getSelectedNodes() {
    if (!this.gos.get("rowDragMultiRow"))
      return [this.rowNode];
    const t = this.beans.selectionService.getSelectedNodes();
    return t.indexOf(this.rowNode) !== -1 ? t : [this.rowNode];
  }
  // returns true if all compatibility items work out
  checkCompatibility() {
    const e = this.gos.get("rowDragManaged");
    this.gos.get("treeData") && e && Se("If using row drag with tree data, you cannot have rowDragManaged=true");
  }
  getDragItem() {
    return {
      rowNode: this.rowNode,
      rowNodes: this.getSelectedNodes(),
      columns: this.column ? [this.column] : void 0,
      defaultTextValue: this.cellValueFn()
    };
  }
  getRowDragText(e) {
    if (e) {
      const t = e.getColDef();
      if (t.rowDragText)
        return t.rowDragText;
    }
    return this.gos.get("rowDragText");
  }
  addDragSource(e = 4) {
    this.dragSource && this.removeDragSource();
    const t = this.getGui();
    this.gos.get("enableCellTextSelection") && (this.removeMouseDownListener(), this.mouseDownListener = this.addManagedElementListeners(t, {
      mousedown: (n) => {
        n == null || n.preventDefault();
      }
    })[0]);
    const r = this.localeService.getLocaleTextFunc();
    this.dragSource = {
      type: 2,
      eElement: t,
      dragItemName: () => {
        var a;
        const n = this.getDragItem(), i = ((a = n.rowNodes) == null ? void 0 : a.length) || 1, o = this.getRowDragText(this.column);
        return o ? o(n, i) : i === 1 ? this.cellValueFn() : `${i} ${r("rowDragRows", "rows")}`;
      },
      getDragItem: () => this.getDragItem(),
      dragStartPixels: e,
      dragSourceDomDataKey: this.gos.getDomDataKey()
    }, this.beans.dragAndDropService.addDragSource(this.dragSource, !0);
  }
  destroy() {
    this.removeDragSource(), this.removeMouseDownListener(), super.destroy();
  }
  removeDragSource() {
    this.dragSource && (this.beans.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null);
  }
  removeMouseDownListener() {
    this.mouseDownListener && (this.mouseDownListener(), this.mouseDownListener = void 0);
  }
}, PK = class extends he {
  constructor(e, t, r) {
    super(), this.parent = e, this.rowNode = t, this.column = r;
  }
  setDisplayedOrVisible(e) {
    const t = { skipAriaHidden: !0 };
    if (e)
      this.parent.setDisplayed(!1, t);
    else {
      let r = !0, n = !1;
      this.column && (r = this.column.isRowDrag(this.rowNode) || this.parent.isCustomGui(), n = vA(this.column.getColDef().rowDrag)), n ? (this.parent.setDisplayed(!0, t), this.parent.setVisible(r, t)) : (this.parent.setDisplayed(r, t), this.parent.setVisible(!0, t));
    }
  }
}, RNe = class extends PK {
  constructor(e, t, r, n) {
    super(e, r, n), this.beans = t;
  }
  postConstruct() {
    this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this));
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.rowNode, {
      dataChanged: e,
      cellChanged: e
    }), this.addManagedListeners(this.beans.eventService, { newColumnsLoaded: e }), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const e = this.gos.get("suppressRowDrag");
    this.setDisplayedOrVisible(e);
  }
}, _Ne = class extends PK {
  constructor(e, t, r, n) {
    super(e, r, n), this.beans = t;
  }
  postConstruct() {
    const e = this.workOutVisibility.bind(this);
    this.addManagedListeners(this.beans.eventService, {
      sortChanged: e,
      filterChanged: e,
      columnRowGroupChanged: e,
      newColumnsLoaded: e
    }), this.addManagedListeners(this.rowNode, {
      dataChanged: e,
      cellChanged: e
    }), this.addManagedPropertyListener("suppressRowDrag", this.onSuppressRowDrag.bind(this)), this.workOutVisibility();
  }
  onSuppressRowDrag() {
    this.workOutVisibility();
  }
  workOutVisibility() {
    const t = this.beans.ctrlsService.getGridBodyCtrl().getRowDragFeature(), r = t && t.shouldPreventRowMove(), n = this.gos.get("suppressRowDrag"), i = this.beans.dragAndDropService.hasExternalDropZones(), o = r && !i || n;
    this.setDisplayedOrVisible(o);
  }
}, qv = class qd {
  constructor(t) {
    this.rowIndex = null, this.key = null, this.childrenMapped = {}, this.displayed = !1, this.rowTop = null, this.oldRowTop = null, this.selectable = !0, this.__objectId = qd.OBJECT_ID_SEQUENCE++, this.__autoHeights = {}, this.alreadyRendered = !1, this.highlighted = null, this.hovered = !1, this.selected = !1, this.beans = t;
  }
  /**
   * Replaces the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  setData(t) {
    this.setDataCommon(t, !1);
  }
  // similar to setRowData, however it is expected that the data is the same data item. this
  // is intended to be used with Redux type stores, where the whole data can be changed. we are
  // guaranteed that the data is the same entity (so grid doesn't need to worry about the id of the
  // underlying data changing, hence doesn't need to worry about selection). the grid, upon receiving
  // dataChanged event, will refresh the cells rather than rip them all out (so user can show transitions).
  /**
   * Updates the data on the `rowNode`. When this method is called, the grid will refresh the entire rendered row if it is displayed.
   */
  updateData(t) {
    this.setDataCommon(t, !0);
  }
  setDataCommon(t, r) {
    var o;
    const n = this.data;
    this.data = t, this.beans.valueCache.onDataChanged(), this.updateDataOnDetailNode(), this.checkRowSelectable(), this.resetQuickFilterAggregateText();
    const i = this.createDataChangedEvent(t, n, r);
    (o = this.localEventService) == null || o.dispatchEvent(i);
  }
  // when we are doing master / detail, the detail node is lazy created, but then kept around.
  // so if we show / hide the detail, the same detail rowNode is used. so we need to keep the data
  // in sync, otherwise expand/collapse of the detail would still show the old values.
  updateDataOnDetailNode() {
    this.detailNode && (this.detailNode.data = this.data);
  }
  createDataChangedEvent(t, r, n) {
    return {
      type: "dataChanged",
      node: this,
      oldData: r,
      newData: t,
      update: n
    };
  }
  getRowIndexString() {
    return this.rowIndex == null ? (sr(
      "Could not find rowIndex, this means tasks are being executed on a rowNode that has been removed from the grid."
    ), null) : this.rowPinned === "top" ? "t-" + this.rowIndex : this.rowPinned === "bottom" ? "b-" + this.rowIndex : this.rowIndex.toString();
  }
  createDaemonNode() {
    const t = new qd(this.beans);
    return t.id = this.id, t.data = this.data, t.__daemon = !0, t.selected = this.selected, t.level = this.level, t;
  }
  setDataAndId(t, r) {
    var a;
    const n = Me(this.id) ? this.createDaemonNode() : null, i = this.data;
    this.data = t, this.updateDataOnDetailNode(), this.setId(r), this.checkRowSelectable(), this.beans.selectionService.syncInRowNode(this, n);
    const o = this.createDataChangedEvent(t, i, !1);
    (a = this.localEventService) == null || a.dispatchEvent(o);
  }
  checkRowSelectable() {
    const t = this.beans.gos.get("isRowSelectable");
    this.setRowSelectable(t ? t(this) : !0);
  }
  setRowSelectable(t, r) {
    if (this.selectable !== t) {
      if (this.selectable = t, this.dispatchRowEvent("selectableChanged"), r)
        return;
      if (this.beans.gos.get("groupSelectsChildren")) {
        const i = this.calculateSelectedFromChildren();
        this.setSelectedParams({
          newValue: i ?? !1,
          source: "selectableChanged"
        });
        return;
      }
      this.isSelected() && !this.selectable && this.setSelectedParams({
        newValue: !1,
        source: "selectableChanged"
      });
    }
  }
  setId(t) {
    const r = this.beans.gos.getRowIdCallback();
    if (r)
      if (this.data) {
        const n = this.getGroupKeys(!0);
        this.id = r({
          data: this.data,
          parentKeys: n.length > 0 ? n : void 0,
          level: this.level,
          rowPinned: this.rowPinned
        }), this.id.startsWith(qd.ID_PREFIX_ROW_GROUP) && sr(
          `Row IDs cannot start with ${qd.ID_PREFIX_ROW_GROUP}, this is a reserved prefix for AG Grid's row grouping feature.`
        );
      } else
        this.id = void 0;
    else
      this.id = t;
  }
  getGroupKeys(t = !1) {
    const r = [];
    let n = this;
    for (t && (n = n.parent); n && n.level >= 0; )
      r.push(n.key), n = n.parent;
    return r.reverse(), r;
  }
  isPixelInRange(t) {
    return !Me(this.rowTop) || !Me(this.rowHeight) ? !1 : t >= this.rowTop && t < this.rowTop + this.rowHeight;
  }
  updateIfDifferent(t, r, n) {
    this[t] !== r && (this[t] = r, this.dispatchRowEvent(n));
  }
  setFirstChild(t) {
    this.updateIfDifferent("firstChild", t, "firstChildChanged");
  }
  setLastChild(t) {
    this.updateIfDifferent("lastChild", t, "lastChildChanged");
  }
  setChildIndex(t) {
    this.updateIfDifferent("childIndex", t, "childIndexChanged");
  }
  setRowTop(t) {
    this.oldRowTop = this.rowTop, this.rowTop !== t && (this.rowTop = t, this.dispatchRowEvent("topChanged"), this.setDisplayed(t !== null));
  }
  clearRowTopAndRowIndex() {
    this.oldRowTop = null, this.setRowTop(null), this.setRowIndex(null);
  }
  setDisplayed(t) {
    this.updateIfDifferent("displayed", t, "displayedChanged");
  }
  setDragging(t) {
    this.updateIfDifferent("dragging", t, "draggingChanged");
  }
  setHighlighted(t) {
    this.updateIfDifferent("highlighted", t, "rowHighlightChanged");
  }
  setHovered(t) {
    this.hovered !== t && (this.hovered = t);
  }
  isHovered() {
    return this.hovered;
  }
  setAllChildrenCount(t) {
    this.updateIfDifferent("allChildrenCount", t, "allChildrenCountChanged");
  }
  setMaster(t) {
    this.master !== t && (this.master && !t && (this.expanded = !1), this.master = t, this.dispatchRowEvent("masterChanged"));
  }
  setGroup(t) {
    this.group !== t && (this.group && !t && (this.expanded = !1), this.group = t, this.updateHasChildren(), this.checkRowSelectable(), this.dispatchRowEvent("groupChanged"));
  }
  /**
   * Sets the row height.
   * Call if you want to change the height initially assigned to the row.
   * After calling, you must call `api.onRowHeightChanged()` so the grid knows it needs to work out the placement of the rows. */
  setRowHeight(t, r = !1) {
    this.rowHeight = t, this.rowHeightEstimated = r, this.dispatchRowEvent("heightChanged");
  }
  setRowAutoHeight(t, r) {
    this.__autoHeights || (this.__autoHeights = {}), this.__autoHeights[r.getId()] = t, t != null && (this.checkAutoHeightsDebounced == null && (this.checkAutoHeightsDebounced = vi(this.checkAutoHeights.bind(this), 1)), this.checkAutoHeightsDebounced());
  }
  checkAutoHeights() {
    let t = !1, r = !0, n = 0;
    const i = this.__autoHeights;
    if (i == null || (this.beans.visibleColsService.getAllAutoHeightCols().forEach((s) => {
      let l = i[s.getId()];
      if (l == null)
        if (this.beans.columnModel.isColSpanActive()) {
          let u = [];
          switch (s.getPinned()) {
            case "left":
              u = this.beans.visibleColsService.getLeftColsForRow(this);
              break;
            case "right":
              u = this.beans.visibleColsService.getRightColsForRow(this);
              break;
            case null:
              u = this.beans.columnViewportService.getColsWithinViewport(this);
              break;
          }
          if (u.includes(s)) {
            t = !0;
            return;
          }
          l = -1;
        } else {
          t = !0;
          return;
        }
      else
        r = !1;
      l > n && (n = l);
    }), t) || ((r || n < 10) && (n = this.beans.gos.getRowHeightForNode(this).height), n == this.rowHeight))
      return;
    this.setRowHeight(n);
    const a = this.beans.rowModel;
    a.onRowHeightChangedDebounced && a.onRowHeightChangedDebounced();
  }
  setRowIndex(t) {
    this.updateIfDifferent("rowIndex", t, "rowIndexChanged");
  }
  setUiLevel(t) {
    this.updateIfDifferent("uiLevel", t, "uiLevelChanged");
  }
  /**
   * Set the expanded state of this rowNode. Pass `true` to expand and `false` to collapse.
   */
  setExpanded(t, r, n) {
    if (this.expanded === t)
      return;
    this.expanded = t, this.dispatchRowEvent("expandedChanged");
    const i = { ...this.createGlobalRowEvent("rowGroupOpened"), expanded: t, event: r || null };
    this.beans.rowNodeEventThrottle.dispatchExpanded(i, n), this.beans.rowRenderer.refreshCells({ rowNodes: [this] });
  }
  createGlobalRowEvent(t) {
    return this.beans.gos.addGridCommonParams({
      type: t,
      node: this,
      data: this.data,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned
    });
  }
  /**
   * Replaces the value on the `rowNode` for the specified column. When complete,
   * the grid will refresh the rendered cell on the required row only.
   * **Note**: This method only fires `onCellEditRequest` when the Grid is in **Read Only** mode.
   *
   * @param colKey The column where the value should be updated
   * @param newValue The new value
   * @param eventSource The source of the event
   * @returns `true` if the value was changed, otherwise `false`.
   */
  setDataValue(t, r, n) {
    const o = typeof t != "string" ? t : this.beans.columnModel.getCol(t) ?? this.beans.columnModel.getColDefCol(t), a = this.getValueFromValueService(o);
    if (this.beans.gos.get("readOnlyEdit"))
      return this.dispatchEventForSaveValueReadOnly(o, a, r, n), !1;
    const s = this.beans.valueService.setValue(this, o, r, n);
    return this.dispatchCellChangedEvent(o, r, a), this.checkRowSelectable(), s;
  }
  getValueFromValueService(t) {
    const r = this.leafGroup && this.beans.columnModel.isPivotMode(), n = this.group && this.expanded && !this.footer && !r;
    let i = !1;
    const o = this.beans.gos.get("groupTotalRow") ?? this.beans.gos.get("groupIncludeFooter");
    typeof o != "function" ? i = !!o : i = !!(this.beans.gos.getCallback("groupTotalRow") ?? this.beans.gos.getCallback("groupIncludeFooter"))({ node: this });
    const a = this.beans.gos.get("groupSuppressBlankHeader"), s = n && i && !a;
    return this.beans.valueService.getValue(t, this, !1, s);
  }
  dispatchEventForSaveValueReadOnly(t, r, n, i) {
    const o = this.beans.gos.addGridCommonParams({
      type: "cellEditRequest",
      event: null,
      rowIndex: this.rowIndex,
      rowPinned: this.rowPinned,
      column: t,
      colDef: t.getColDef(),
      data: this.data,
      node: this,
      oldValue: r,
      newValue: n,
      value: n,
      source: i
    });
    this.beans.eventService.dispatchEvent(o);
  }
  setGroupValue(t, r) {
    const n = this.beans.columnModel.getCol(t);
    Zt(this.groupData) && (this.groupData = {});
    const i = n.getColId(), o = this.groupData[i];
    o !== r && (this.groupData[i] = r, this.dispatchCellChangedEvent(n, r, o));
  }
  // sets the data for an aggregation
  setAggData(t) {
    const r = this.aggData;
    if (this.aggData = t, this.localEventService) {
      const n = (i) => {
        const o = this.aggData ? this.aggData[i] : void 0, a = r ? r[i] : void 0;
        if (o === a)
          return;
        const s = this.beans.columnModel.getCol(i);
        s && this.dispatchCellChangedEvent(s, o, a);
      };
      for (const i in this.aggData)
        n(i);
      for (const i in t)
        i in this.aggData || n(i);
    }
  }
  updateHasChildren() {
    let t = this.group && !this.footer || this.childrenAfterGroup && this.childrenAfterGroup.length > 0;
    if (this.beans.gos.isRowModelType("serverSide")) {
      const n = this.beans.gos.get("treeData"), i = this.beans.gos.get("isServerSideGroup");
      t = !this.stub && !this.footer && (n ? !!i && i(this.data) : !!this.group);
    }
    t !== this.__hasChildren && (this.__hasChildren = !!t, this.dispatchRowEvent("hasChildrenChanged"));
  }
  hasChildren() {
    return this.__hasChildren == null && this.updateHasChildren(), this.__hasChildren;
  }
  isEmptyRowGroupNode() {
    return (this.group && Dn(this.childrenAfterGroup)) ?? !1;
  }
  dispatchCellChangedEvent(t, r, n) {
    var o;
    const i = {
      type: "cellChanged",
      node: this,
      column: t,
      newValue: r,
      oldValue: n
    };
    (o = this.localEventService) == null || o.dispatchEvent(i);
  }
  /**
   * The first time `quickFilter` runs, the grid creates a one-off string representation of the row.
   * This string is then used for the quick filter instead of hitting each column separately.
   * When you edit, using grid editing, this string gets cleared down.
   * However if you edit without using grid editing, you will need to clear this string down for the row to be updated with the new values.
   * Otherwise new values will not work with the `quickFilter`. */
  resetQuickFilterAggregateText() {
    this.quickFilterAggregateText = null;
  }
  /** Returns:
   * - `true` if the node can be expanded, i.e it is a group or master row.
   * - `false` if the node cannot be expanded
   */
  isExpandable() {
    return this.footer ? !1 : this.beans.columnModel.isPivotMode() ? this.hasChildren() && !this.leafGroup : this.hasChildren() || !!this.master;
  }
  /** Returns:
   * - `true` if node is selected,
   * - `false` if the node isn't selected
   * - `undefined` if it's partially selected (group where not all children are selected). */
  isSelected() {
    return this.footer ? this.sibling.isSelected() : this.selected;
  }
  /** Perform a depth-first search of this node and its children. */
  depthFirstSearch(t) {
    this.childrenAfterGroup && this.childrenAfterGroup.forEach((r) => r.depthFirstSearch(t)), t(this);
  }
  // + selectionController.calculatedSelectedForAllGroupNodes()
  calculateSelectedFromChildren() {
    var i;
    let t = !1, r = !1, n = !1;
    if (!((i = this.childrenAfterGroup) != null && i.length))
      return this.selectable ? this.selected : null;
    for (let o = 0; o < this.childrenAfterGroup.length; o++) {
      const a = this.childrenAfterGroup[o];
      let s = a.isSelected();
      if (!a.selectable) {
        const l = a.calculateSelectedFromChildren();
        if (l === null)
          continue;
        s = l;
      }
      switch (s) {
        case !0:
          t = !0;
          break;
        case !1:
          r = !0;
          break;
        default:
          n = !0;
          break;
      }
    }
    if (!(n || t && r))
      return t ? !0 : r ? !1 : this.selectable ? this.selected : null;
  }
  setSelectedInitialValue(t) {
    this.selected = t;
  }
  dispatchRowEvent(t) {
    var n;
    const r = {
      type: t,
      node: this
    };
    (n = this.localEventService) == null || n.dispatchEvent(r);
  }
  selectThisNode(t, r, n = "api") {
    const i = !this.selectable && t, o = this.selected === t;
    if (i || o)
      return !1;
    this.selected = t, this.dispatchRowEvent("rowSelected");
    const a = this.sibling;
    a && a.footer && a.localEventService && a.dispatchRowEvent("rowSelected");
    const s = {
      ...this.createGlobalRowEvent("rowSelected"),
      event: r || null,
      source: n
    };
    return this.beans.eventService.dispatchEvent(s), !0;
  }
  /**
   * Select (or deselect) the node.
   * @param newValue -`true` for selection, `false` for deselection.
   * @param clearSelection - If selecting, then passing `true` will select the node exclusively (i.e. NOT do multi select). If doing deselection, `clearSelection` has no impact.
   * @param source - Source property that will appear in the `selectionChanged` event.
   */
  setSelected(t, r = !1, n = "api") {
    if (typeof n == "boolean") {
      Se(
        "since version v30, rowNode.setSelected() property `suppressFinishActions` has been removed, please use `gridApi.setNodesSelected()` for bulk actions, and the event `source` property for ignoring events instead."
      );
      return;
    }
    this.setSelectedParams({
      newValue: t,
      clearSelection: r,
      rangeSelect: !1,
      source: n
    });
  }
  // this is for internal use only. To make calling code more readable, this is the same method as setSelected except it takes names parameters
  setSelectedParams(t) {
    return this.rowPinned ? (Se("cannot select pinned rows"), 0) : this.id === void 0 ? (Se("cannot select node until id for node is known"), 0) : this.beans.selectionService.setNodesSelected({ ...t, nodes: [this.footer ? this.sibling : this] });
  }
  /**
   * Returns:
   * - `true` if node is either pinned to the `top` or `bottom`
   * - `false` if the node isn't pinned
   */
  isRowPinned() {
    return this.rowPinned === "top" || this.rowPinned === "bottom";
  }
  isParentOfNode(t) {
    let r = this.parent;
    for (; r; ) {
      if (r === t)
        return !0;
      r = r.parent;
    }
    return !1;
  }
  /** Add an event listener. */
  addEventListener(t, r) {
    var i;
    this.localEventService || (this.localEventService = new wf()), this.beans.frameworkOverrides.shouldWrapOutgoing && !this.frameworkEventListenerService && (this.localEventService.setFrameworkOverrides(this.beans.frameworkOverrides), this.frameworkEventListenerService = new fA(this.beans.frameworkOverrides));
    const n = ((i = this.frameworkEventListenerService) == null ? void 0 : i.wrap(r)) ?? r;
    this.localEventService.addEventListener(t, n);
  }
  /** Remove event listener. */
  removeEventListener(t, r) {
    var i;
    if (!this.localEventService)
      return;
    const n = ((i = this.frameworkEventListenerService) == null ? void 0 : i.unwrap(r)) ?? r;
    this.localEventService.removeEventListener(t, n), this.localEventService.noRegisteredListenersExist() && (this.localEventService = null);
  }
  onMouseEnter() {
    this.dispatchRowEvent("mouseEnter");
  }
  onMouseLeave() {
    this.dispatchRowEvent("mouseLeave");
  }
  getFirstChildOfFirstChild(t) {
    let r = this, n = !0, i = !1, o = null;
    for (; n && !i; ) {
      const a = r.parent;
      Me(a) && r.firstChild ? a.rowGroupColumn === t && (i = !0, o = a) : n = !1, r = a;
    }
    return i ? o : null;
  }
  /**
   * Returns:
   * - `true` if the node is a full width cell
   * - `false` if the node is not a full width cell
   */
  isFullWidthCell() {
    if (this.detail)
      return !0;
    const t = this.beans.gos.getCallback("isFullWidthRow");
    return t ? t({ rowNode: this }) : !1;
  }
  /**
   * Returns the route of the row node. If the Row Node is a group, it returns the route to that Row Node.
   * If the Row Node is not a group, it returns `undefined`.
   */
  getRoute() {
    if (this.key == null)
      return;
    const t = [];
    let r = this;
    for (; r && r.key != null; )
      t.push(r.key), r = r.parent;
    return t.reverse();
  }
  createFooter() {
    if (this.sibling)
      return;
    const t = /* @__PURE__ */ new Set(["eventService", "__objectId", "sticky"]), r = new qd(this.beans);
    Object.keys(this).forEach((n) => {
      t.has(n) || (r[n] = this[n]);
    }), r.footer = !0, r.setRowTop(null), r.setRowIndex(null), r.oldRowTop = null, r.id = "rowGroupFooter_" + this.id, r.sibling = this, this.sibling = r;
  }
  // Only used by SSRM. In CSRM this is never used as footers should always be present for
  // the purpose of exporting collapsed groups. In SSRM it is not possible to export collapsed
  // groups anyway, so can destroy footers.
  destroyFooter() {
    this.sibling && (this.sibling.setRowTop(null), this.sibling.setRowIndex(null), this.sibling = void 0);
  }
};
qv.ID_PREFIX_ROW_GROUP = "row-group-";
qv.ID_PREFIX_TOP_PINNED = "t-";
qv.ID_PREFIX_BOTTOM_PINNED = "b-";
qv.OBJECT_ID_SEQUENCE = 0;
var Os = qv, TNe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "filterManager", this.advancedFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.dataTypeService = e.dataTypeService, this.quickFilterService = e.quickFilterService, this.advancedFilterService = e.advancedFilterService, this.columnFilterService = e.columnFilterService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      columnValueChanged: this.refreshFiltersForAggregations.bind(this),
      columnPivotChanged: this.refreshFiltersForAggregations.bind(this),
      columnPivotModeChanged: this.refreshFiltersForAggregations.bind(this),
      newColumnsLoaded: this.updateAdvancedFilterColumns.bind(this),
      columnVisible: this.updateAdvancedFilterColumns.bind(this),
      advancedFilterEnabledChanged: ({ enabled: e }) => this.onAdvancedFilterEnabledChanged(e),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.externalFilterPresent = this.isExternalFilterPresentCallback(), this.addManagedPropertyListeners(["isExternalFilterPresent", "doesExternalFilterPass"], () => {
      this.onFilterChanged({ source: "api" });
    }), this.updateAggFiltering(), this.addManagedPropertyListener("groupAggFiltering", () => {
      this.updateAggFiltering(), this.onFilterChanged();
    }), this.addManagedPropertyListener(
      "advancedFilterModel",
      (e) => this.setAdvancedFilterModel(e.currentValue)
    ), this.quickFilterService && this.addManagedListeners(this.quickFilterService, {
      quickFilterChanged: () => this.onFilterChanged({ source: "quickFilter" })
    });
  }
  isExternalFilterPresentCallback() {
    const e = this.gos.getCallback("isExternalFilterPresent");
    return typeof e == "function" ? e({}) : !1;
  }
  doesExternalFilterPass(e) {
    const t = this.gos.get("doesExternalFilterPass");
    return typeof t == "function" ? t(e) : !1;
  }
  setFilterModel(e, t = "api") {
    var r;
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    (r = this.columnFilterService) == null || r.setFilterModel(e, t);
  }
  getFilterModel() {
    var e;
    return ((e = this.columnFilterService) == null ? void 0 : e.getFilterModel()) ?? {};
  }
  isColumnFilterPresent() {
    var e;
    return !!((e = this.columnFilterService) != null && e.isColumnFilterPresent());
  }
  isAggregateFilterPresent() {
    var e;
    return !!((e = this.columnFilterService) != null && e.isAggregateFilterPresent());
  }
  isExternalFilterPresent() {
    return this.externalFilterPresent;
  }
  isChildFilterPresent() {
    return this.isColumnFilterPresent() || this.isQuickFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  isAdvancedFilterPresent() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isFilterPresent();
  }
  onAdvancedFilterEnabledChanged(e) {
    var t, r;
    e ? (t = this.columnFilterService) != null && t.disableColumnFilters() && this.onFilterChanged({ source: "advancedFilter" }) : (r = this.advancedFilterService) != null && r.isFilterPresent() && (this.advancedFilterService.setModel(null), this.onFilterChanged({ source: "advancedFilter" }));
  }
  isAdvancedFilterEnabled() {
    var e;
    return !!((e = this.advancedFilterService) != null && e.isEnabled());
  }
  isAdvancedFilterHeaderActive() {
    return this.isAdvancedFilterEnabled() && this.advancedFilterService.isHeaderActive();
  }
  isAnyFilterPresent() {
    return this.isQuickFilterPresent() || this.isColumnFilterPresent() || this.isAggregateFilterPresent() || this.isExternalFilterPresent() || this.isAdvancedFilterPresent();
  }
  resetQuickFilterCache() {
    var e;
    (e = this.quickFilterService) == null || e.resetQuickFilterCache();
  }
  refreshFiltersForAggregations() {
    this.gos.getGroupAggFiltering() && this.onFilterChanged();
  }
  onFilterChanged(e = {}) {
    const { source: t, additionalEventAttributes: r, columns: n = [] } = e;
    this.externalFilterPresent = this.isExternalFilterPresentCallback(), (this.columnFilterService ? this.columnFilterService.updateBeforeFilterChanged(e) : en.resolve()).then(() => {
      var o;
      const i = {
        source: t,
        type: "filterChanged",
        columns: n
      };
      r && To(i, r), this.eventService.dispatchEvent(i), (o = this.columnFilterService) == null || o.updateAfterFilterChanged();
    });
  }
  isSuppressFlashingCellsBecauseFiltering() {
    var e;
    return !!((e = this.columnFilterService) != null && e.isSuppressFlashingCellsBecauseFiltering());
  }
  isQuickFilterPresent() {
    var e;
    return !!((e = this.quickFilterService) != null && e.isQuickFilterPresent());
  }
  updateAggFiltering() {
    this.aggFiltering = !!this.gos.getGroupAggFiltering();
  }
  isAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && this.shouldApplyQuickFilterAfterAgg();
  }
  isNonAggregateQuickFilterPresent() {
    return this.isQuickFilterPresent() && !this.shouldApplyQuickFilterAfterAgg();
  }
  shouldApplyQuickFilterAfterAgg() {
    return (this.aggFiltering || this.columnModel.isPivotMode()) && !this.gos.get("applyQuickFilterBeforePivotOrAgg");
  }
  doesRowPassOtherFilters(e, t) {
    return this.doesRowPassFilter({ rowNode: t, filterInstanceToSkip: e });
  }
  doesRowPassAggregateFilters(e) {
    return !(this.isAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isAggregateFilterPresent() && !this.columnFilterService.doAggregateFiltersPass(e.rowNode, e.filterInstanceToSkip));
  }
  doesRowPassFilter(e) {
    return !(this.isNonAggregateQuickFilterPresent() && !this.quickFilterService.doesRowPassQuickFilter(e.rowNode) || this.isExternalFilterPresent() && !this.doesExternalFilterPass(e.rowNode) || this.isColumnFilterPresent() && !this.columnFilterService.doColumnFiltersPass(e.rowNode, e.filterInstanceToSkip) || this.isAdvancedFilterPresent() && !this.advancedFilterService.doesFilterPass(e.rowNode));
  }
  isFilterActive(e) {
    var t;
    return !!((t = this.columnFilterService) != null && t.isFilterActive(e));
  }
  getOrCreateFilterWrapper(e) {
    var t;
    return ((t = this.columnFilterService) == null ? void 0 : t.getOrCreateFilterWrapper(e)) ?? null;
  }
  getDefaultFloatingFilter(e) {
    return this.columnFilterService.getDefaultFloatingFilter(e);
  }
  createFilterParams(e, t) {
    return this.columnFilterService.createFilterParams(e, t);
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    var t;
    return this.isAdvancedFilterEnabled() ? !1 : !!((t = this.columnFilterService) != null && t.isFilterAllowed(e));
  }
  getFloatingFilterCompDetails(e, t) {
    var r;
    return (r = this.columnFilterService) == null ? void 0 : r.getFloatingFilterCompDetails(e, t);
  }
  getCurrentFloatingFilterParentModel(e) {
    var t;
    return (t = this.columnFilterService) == null ? void 0 : t.getCurrentFloatingFilterParentModel(e);
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    var r;
    (r = this.columnFilterService) == null || r.destroyFilter(e, t);
  }
  areFilterCompsDifferent(e, t) {
    var r;
    return !!((r = this.columnFilterService) != null && r.areFilterCompsDifferent(e, t));
  }
  getAdvancedFilterModel() {
    return this.isAdvancedFilterEnabled() ? this.advancedFilterService.getModel() : null;
  }
  setAdvancedFilterModel(e) {
    var t;
    if (this.isAdvancedFilterEnabled()) {
      if ((t = this.dataTypeService) != null && t.isPendingInference()) {
        this.advancedFilterModelUpdateQueue.push(e);
        return;
      }
      this.advancedFilterService.setModel(e ?? null), this.onFilterChanged({ source: "advancedFilter" });
    }
  }
  toggleAdvancedFilterBuilder(e, t) {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.getCtrl().toggleFilterBuilder(t, e);
  }
  updateAdvancedFilterColumns() {
    this.isAdvancedFilterEnabled() && this.advancedFilterService.updateValidity() && this.onFilterChanged({ source: "advancedFilter" });
  }
  hasFloatingFilters() {
    var e;
    return this.isAdvancedFilterEnabled() ? !1 : !!((e = this.columnFilterService) != null && e.hasFloatingFilters());
  }
  getFilterInstance(e, t) {
    var r;
    if (this.isAdvancedFilterEnabled()) {
      this.warnAdvancedFilters();
      return;
    }
    return (r = this.columnFilterService) == null ? void 0 : r.getFilterInstance(e, t);
  }
  getColumnFilterInstance(e) {
    var t;
    return this.isAdvancedFilterEnabled() ? (this.warnAdvancedFilters(), Promise.resolve(void 0)) : ((t = this.columnFilterService) == null ? void 0 : t.getColumnFilterInstance(e)) ?? Promise.resolve(void 0);
  }
  warnAdvancedFilters() {
    Se("Column Filter API methods have been disabled as Advanced Filters are enabled.");
  }
  setupAdvancedFilterHeaderComp(e) {
    var t;
    (t = this.advancedFilterService) == null || t.getCtrl().setupHeaderComp(e);
  }
  getHeaderRowCount() {
    return this.isAdvancedFilterHeaderActive() ? 1 : 0;
  }
  getHeaderHeight() {
    return this.isAdvancedFilterHeaderActive() ? this.advancedFilterService.getCtrl().getHeaderHeight() : 0;
  }
  processFilterModelUpdateQueue() {
    this.advancedFilterModelUpdateQueue.forEach((e) => this.setAdvancedFilterModel(e)), this.advancedFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    var t;
    return (t = this.columnFilterService) == null ? void 0 : t.getColumnFilterModel(e);
  }
  setColumnFilterModel(e, t) {
    var r;
    return this.isAdvancedFilterEnabled() ? (this.warnAdvancedFilters(), Promise.resolve()) : ((r = this.columnFilterService) == null ? void 0 : r.setColumnFilterModel(e, t)) ?? Promise.resolve();
  }
}, PNe = class extends Nr {
  constructor(e, t) {
    super(
      /* html */
      '<div class="ag-filter"></div>'
    ), this.column = e, this.source = t, this.filterWrapper = null;
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.columnModel = e.columnModel;
  }
  postConstruct() {
    this.createFilter(!0), this.addManagedEventListeners({ filterDestroyed: this.onFilterDestroyed.bind(this) });
  }
  hasFilter() {
    return !!this.filterWrapper;
  }
  getFilter() {
    var e;
    return ((e = this.filterWrapper) == null ? void 0 : e.filterPromise) ?? null;
  }
  afterInit() {
    var e, t;
    return ((t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null ? void 0 : t.then(() => {
    })) ?? en.resolve();
  }
  afterGuiAttached(e) {
    var t, r;
    (r = (t = this.filterWrapper) == null ? void 0 : t.filterPromise) == null || r.then((n) => {
      var i;
      (i = n == null ? void 0 : n.afterGuiAttached) == null || i.call(n, e);
    });
  }
  afterGuiDetached() {
    var e, t;
    (t = (e = this.filterWrapper) == null ? void 0 : e.filterPromise) == null || t.then((r) => {
      var n;
      (n = r == null ? void 0 : r.afterGuiDetached) == null || n.call(r);
    });
  }
  createFilter(e) {
    var n, i;
    const { column: t, source: r } = this;
    this.filterWrapper = ((n = this.filterManager) == null ? void 0 : n.getOrCreateFilterWrapper(t)) ?? null, (i = this.filterWrapper) != null && i.filterPromise && this.filterWrapper.filterPromise.then((o) => {
      const a = o.getGui();
      if (Me(a) || Se(`getGui method from filter returned ${a}; it should be a DOM element.`), this.appendChild(a), e) {
        const s = {
          type: "filterOpened",
          column: t,
          source: r,
          eGui: this.getGui()
        };
        this.eventService.dispatchEvent(s);
      }
    });
  }
  onFilterDestroyed(e) {
    (e.source === "api" || e.source === "paramsUpdated") && e.column.getId() === this.column.getId() && this.columnModel.getColDefCol(this.column) && (oo(this.getGui()), this.createFilter());
  }
  destroy() {
    this.filterWrapper = null, super.destroy();
  }
}, MK = "ag-resizer-wrapper", MNe = (
  /* html */
  `<div class="${MK}">
        <div data-ref="eTopLeftResizer" class="ag-resizer ag-resizer-topLeft"></div>
        <div data-ref="eTopResizer" class="ag-resizer ag-resizer-top"></div>
        <div data-ref="eTopRightResizer" class="ag-resizer ag-resizer-topRight"></div>
        <div data-ref="eRightResizer" class="ag-resizer ag-resizer-right"></div>
        <div data-ref="eBottomRightResizer" class="ag-resizer ag-resizer-bottomRight"></div>
        <div data-ref="eBottomResizer" class="ag-resizer ag-resizer-bottom"></div>
        <div data-ref="eBottomLeftResizer" class="ag-resizer ag-resizer-bottomLeft"></div>
        <div data-ref="eLeftResizer" class="ag-resizer ag-resizer-left"></div>
    </div>`
), DNe = class extends he {
  constructor(e, t) {
    super(), this.element = e, this.dragStartPosition = {
      x: 0,
      y: 0
    }, this.position = {
      x: 0,
      y: 0
    }, this.lastSize = {
      width: -1,
      height: -1
    }, this.positioned = !1, this.resizersAdded = !1, this.resizeListeners = [], this.boundaryEl = null, this.isResizing = !1, this.isMoving = !1, this.resizable = {}, this.movable = !1, this.currentResizer = null, this.config = Object.assign({}, { popup: !1 }, t);
  }
  wireBeans(e) {
    this.popupService = e.popupService, this.resizeObserverService = e.resizeObserverService, this.dragService = e.dragService;
  }
  center() {
    const { clientHeight: e, clientWidth: t } = this.offsetParent, r = t / 2 - this.getWidth() / 2, n = e / 2 - this.getHeight() / 2;
    this.offsetElement(r, n);
  }
  initialisePosition() {
    if (this.positioned)
      return;
    const { centered: e, forcePopupParentAsOffsetParent: t, minWidth: r, width: n, minHeight: i, height: o, x: a, y: s } = this.config;
    this.offsetParent || this.setOffsetParent();
    let l = 0, u = 0;
    const c = ts(this.element);
    if (c) {
      const d = this.findBoundaryElement(), h = window.getComputedStyle(d);
      if (h.minWidth != null) {
        const f = d.offsetWidth - this.element.offsetWidth;
        u = parseInt(h.minWidth, 10) - f;
      }
      if (h.minHeight != null) {
        const f = d.offsetHeight - this.element.offsetHeight;
        l = parseInt(h.minHeight, 10) - f;
      }
    }
    if (this.minHeight = i || l, this.minWidth = r || u, n && this.setWidth(n), o && this.setHeight(o), (!n || !o) && this.refreshSize(), e)
      this.center();
    else if (a || s)
      this.offsetElement(a, s);
    else if (c && t) {
      let d = this.boundaryEl, h = !0;
      if (d || (d = this.findBoundaryElement(), h = !1), d) {
        const f = parseFloat(d.style.top), p = parseFloat(d.style.left);
        h ? this.offsetElement(isNaN(p) ? 0 : p, isNaN(f) ? 0 : f) : this.setPosition(p, f);
      }
    }
    this.positioned = !!this.offsetParent;
  }
  isPositioned() {
    return this.positioned;
  }
  getPosition() {
    return this.position;
  }
  setMovable(e, t) {
    if (!this.config.popup || e === this.movable)
      return;
    this.movable = e;
    const r = this.moveElementDragListener || {
      eElement: t,
      onDragStart: this.onMoveStart.bind(this),
      onDragging: this.onMove.bind(this),
      onDragStop: this.onMoveEnd.bind(this)
    };
    e ? (this.dragService.addDragSource(r), this.moveElementDragListener = r) : (this.dragService.removeDragSource(r), this.moveElementDragListener = void 0);
  }
  setResizable(e) {
    if (this.clearResizeListeners(), e ? this.addResizers() : this.removeResizers(), typeof e == "boolean") {
      if (e === !1)
        return;
      e = {
        topLeft: e,
        top: e,
        topRight: e,
        right: e,
        bottomRight: e,
        bottom: e,
        bottomLeft: e,
        left: e
      };
    }
    Object.keys(e).forEach((t) => {
      const n = !!e[t], i = this.getResizerElement(t), o = {
        dragStartPixels: 0,
        eElement: i,
        onDragStart: (a) => this.onResizeStart(a, t),
        onDragging: this.onResize.bind(this),
        onDragStop: (a) => this.onResizeEnd(a, t)
      };
      (n || !this.isAlive() && !n) && (n ? (this.dragService.addDragSource(o), this.resizeListeners.push(o), i.style.pointerEvents = "all") : i.style.pointerEvents = "none", this.resizable[t] = n);
    });
  }
  removeSizeFromEl() {
    this.element.style.removeProperty("height"), this.element.style.removeProperty("width"), this.element.style.removeProperty("flex");
  }
  restoreLastSize() {
    this.element.style.flex = "0 0 auto";
    const { height: e, width: t } = this.lastSize;
    t !== -1 && (this.element.style.width = `${t}px`), e !== -1 && (this.element.style.height = `${e}px`);
  }
  getHeight() {
    return this.element.offsetHeight;
  }
  setHeight(e) {
    const { popup: t } = this.config, r = this.element;
    let n = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      cg(r, e), e = pK(r), n = !0;
    else if (e = Math.max(this.minHeight, e), this.positioned) {
      const i = this.getAvailableHeight();
      i && e > i && (e = i);
    }
    this.getHeight() !== e && (n ? (r.style.maxHeight = "unset", r.style.minHeight = "unset") : t ? cg(r, e) : (r.style.height = `${e}px`, r.style.flex = "0 0 auto", this.lastSize.height = typeof e == "number" ? e : parseFloat(e)));
  }
  getAvailableHeight() {
    const { popup: e, forcePopupParentAsOffsetParent: t } = this.config;
    this.positioned || this.initialisePosition();
    const { clientHeight: r } = this.offsetParent;
    if (!r)
      return null;
    const n = this.element.getBoundingClientRect(), i = this.offsetParent.getBoundingClientRect(), o = e ? this.position.y : n.top, a = e ? 0 : i.top;
    let s = 0;
    if (t) {
      const u = this.element.parentElement;
      if (u) {
        const { bottom: c } = u.getBoundingClientRect();
        s = c - n.bottom;
      }
    }
    return r + a - o - s;
  }
  getWidth() {
    return this.element.offsetWidth;
  }
  setWidth(e) {
    const t = this.element, { popup: r } = this.config;
    let n = !1;
    if (typeof e == "string" && e.indexOf("%") !== -1)
      pa(t, e), e = $C(t), n = !0;
    else if (this.positioned) {
      e = Math.max(this.minWidth, e);
      const { clientWidth: i } = this.offsetParent, o = r ? this.position.x : this.element.getBoundingClientRect().left;
      i && e + o > i && (e = i - o);
    }
    this.getWidth() !== e && (n ? (t.style.maxWidth = "unset", t.style.minWidth = "unset") : this.config.popup ? pa(t, e) : (t.style.width = `${e}px`, t.style.flex = " unset", this.lastSize.width = typeof e == "number" ? e : parseFloat(e)));
  }
  offsetElement(e = 0, t = 0) {
    const { forcePopupParentAsOffsetParent: r } = this.config, n = r ? this.boundaryEl : this.element;
    n && (this.popupService.positionPopup({
      ePopup: n,
      keepWithinBounds: !0,
      skipObserver: this.movable || this.isResizable(),
      updatePosition: () => ({ x: e, y: t })
    }), this.setPosition(parseFloat(n.style.left), parseFloat(n.style.top)));
  }
  constrainSizeToAvailableHeight(e) {
    if (!this.config.forcePopupParentAsOffsetParent)
      return;
    const t = () => {
      const r = this.getAvailableHeight();
      this.element.style.setProperty("max-height", `${r}px`);
    };
    e ? this.resizeObserverSubscriber = this.resizeObserverService.observeResize(
      this.popupService.getPopupParent(),
      t
    ) : (this.element.style.removeProperty("max-height"), this.resizeObserverSubscriber && (this.resizeObserverSubscriber(), this.resizeObserverSubscriber = void 0));
  }
  setPosition(e, t) {
    this.position.x = e, this.position.y = t;
  }
  updateDragStartPosition(e, t) {
    this.dragStartPosition = { x: e, y: t };
  }
  calculateMouseMovement(e) {
    const { e: t, isLeft: r, isTop: n, anywhereWithin: i, topBuffer: o } = e, a = t.clientX - this.dragStartPosition.x, s = t.clientY - this.dragStartPosition.y, l = this.shouldSkipX(t, !!r, !!i, a) ? 0 : a, u = this.shouldSkipY(t, !!n, o, s) ? 0 : s;
    return { movementX: l, movementY: u };
  }
  shouldSkipX(e, t, r, n) {
    const i = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), a = this.boundaryEl.getBoundingClientRect(), s = this.config.popup ? this.position.x : i.left;
    let l = s <= 0 && o.left >= e.clientX || o.right <= e.clientX && o.right <= a.right;
    return l ? !0 : (t ? l = // skip if we are moving to the left and the cursor
    // is positioned to the right of the left side anchor
    n < 0 && e.clientX > s + o.left || // skip if we are moving to the right and the cursor
    // is positioned to the left of the dialog
    n > 0 && e.clientX < s + o.left : r ? l = n < 0 && e.clientX > a.right || n > 0 && e.clientX < s + o.left : l = // if the movement is bound to the right side of the dialog
    // we skip if we are moving to the left and the cursor
    // is to the right of the dialog
    n < 0 && e.clientX > a.right || // or skip if we are moving to the right and the cursor
    // is to the left of the right side anchor
    n > 0 && e.clientX < a.right, l);
  }
  shouldSkipY(e, t, r = 0, n) {
    const i = this.element.getBoundingClientRect(), o = this.offsetParent.getBoundingClientRect(), a = this.boundaryEl.getBoundingClientRect(), s = this.config.popup ? this.position.y : i.top;
    let l = s <= 0 && o.top >= e.clientY || o.bottom <= e.clientY && o.bottom <= a.bottom;
    return l ? !0 : (t ? l = // skip if we are moving to towards top and the cursor is
    // below the top anchor + topBuffer
    // note: topBuffer is used when moving the dialog using the title bar
    n < 0 && e.clientY > s + o.top + r || // skip if we are moving to the bottom and the cursor is
    // above the top anchor
    n > 0 && e.clientY < s + o.top : l = // skip if we are moving towards the top and the cursor
    // is below the bottom anchor
    n < 0 && e.clientY > a.bottom || // skip if we are moving towards the bottom and the cursor
    // is above the bottom anchor
    n > 0 && e.clientY < a.bottom, l);
  }
  createResizeMap() {
    const e = this.element;
    this.resizerMap = {
      topLeft: { element: e.querySelector("[data-ref=eTopLeftResizer]") },
      top: { element: e.querySelector("[data-ref=eTopResizer]") },
      topRight: { element: e.querySelector("[data-ref=eTopRightResizer]") },
      right: { element: e.querySelector("[data-ref=eRightResizer]") },
      bottomRight: { element: e.querySelector("[data-ref=eBottomRightResizer]") },
      bottom: { element: e.querySelector("[data-ref=eBottomResizer]") },
      bottomLeft: { element: e.querySelector("[data-ref=eBottomLeftResizer]") },
      left: { element: e.querySelector("[data-ref=eLeftResizer]") }
    };
  }
  addResizers() {
    if (this.resizersAdded)
      return;
    const e = this.element;
    if (!e)
      return;
    const r = new DOMParser().parseFromString(MNe, "text/html").body;
    e.appendChild(r.firstChild), this.createResizeMap(), this.resizersAdded = !0;
  }
  removeResizers() {
    this.resizerMap = void 0;
    const e = this.element.querySelector(`.${MK}`);
    e && this.element.removeChild(e), this.resizersAdded = !1;
  }
  getResizerElement(e) {
    return this.resizerMap[e].element;
  }
  onResizeStart(e, t) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.currentResizer = {
      isTop: !!t.match(/top/i),
      isRight: !!t.match(/right/i),
      isBottom: !!t.match(/bottom/i),
      isLeft: !!t.match(/left/i)
    }, this.element.classList.add("ag-resizing"), this.resizerMap[t].element.classList.add("ag-active");
    const { popup: r, forcePopupParentAsOffsetParent: n } = this.config;
    !r && !n && this.applySizeToSiblings(this.currentResizer.isBottom || this.currentResizer.isTop), this.isResizing = !0, this.updateDragStartPosition(e.clientX, e.clientY);
  }
  getSiblings() {
    const t = this.element.parentElement;
    return t ? Array.prototype.slice.call(t.children).filter((r) => !r.classList.contains("ag-hidden")) : null;
  }
  getMinSizeOfSiblings() {
    const e = this.getSiblings() || [];
    let t = 0, r = 0;
    for (let n = 0; n < e.length; n++) {
      const i = e[n], o = !!i.style.flex && i.style.flex !== "0 0 auto";
      if (i === this.element)
        continue;
      let a = this.minHeight || 0, s = this.minWidth || 0;
      if (o) {
        const l = window.getComputedStyle(i);
        l.minHeight && (a = parseInt(l.minHeight, 10)), l.minWidth && (s = parseInt(l.minWidth, 10));
      } else
        a = i.offsetHeight, s = i.offsetWidth;
      t += a, r += s;
    }
    return { height: t, width: r };
  }
  applySizeToSiblings(e) {
    let t = null;
    const r = this.getSiblings();
    if (r) {
      for (let n = 0; n < r.length; n++) {
        const i = r[n];
        i !== t && (e ? i.style.height = `${i.offsetHeight}px` : i.style.width = `${i.offsetWidth}px`, i.style.flex = "0 0 auto", i === this.element && (t = r[n + 1]));
      }
      t && (t.style.removeProperty("height"), t.style.removeProperty("min-height"), t.style.removeProperty("max-height"), t.style.flex = "1 1 auto");
    }
  }
  isResizable() {
    return Object.values(this.resizable).some((e) => e);
  }
  onResize(e) {
    if (!this.isResizing || !this.currentResizer)
      return;
    const { popup: t, forcePopupParentAsOffsetParent: r } = this.config, { isTop: n, isRight: i, isBottom: o, isLeft: a } = this.currentResizer, s = i || a, l = o || n, { movementX: u, movementY: c } = this.calculateMouseMovement({ e, isLeft: a, isTop: n }), d = this.position.x, h = this.position.y;
    let f = 0, p = 0;
    if (s && u) {
      const g = a ? -1 : 1, v = this.getWidth(), m = v + u * g;
      let y = !1;
      a && (f = v - m, (d + f <= 0 || m <= this.minWidth) && (y = !0, f = 0)), y || this.setWidth(m);
    }
    if (l && c) {
      const g = n ? -1 : 1, v = this.getHeight(), m = v + c * g;
      let y = !1;
      n ? (p = v - m, (h + p <= 0 || m <= this.minHeight) && (y = !0, p = 0)) : !this.config.popup && !this.config.forcePopupParentAsOffsetParent && v < m && this.getMinSizeOfSiblings().height + m > this.element.parentElement.offsetHeight && (y = !0), y || this.setHeight(m);
    }
    this.updateDragStartPosition(e.clientX, e.clientY), ((t || r) && f || p) && this.offsetElement(d + f, h + p);
  }
  onResizeEnd(e, t) {
    this.isResizing = !1, this.currentResizer = null, this.boundaryEl = null, this.element.classList.remove("ag-resizing"), this.resizerMap[t].element.classList.remove("ag-active"), this.dispatchLocalEvent({ type: "resize" });
  }
  refreshSize() {
    const e = this.element;
    this.config.popup && (this.config.width || this.setWidth(e.offsetWidth), this.config.height || this.setHeight(e.offsetHeight));
  }
  onMoveStart(e) {
    this.boundaryEl = this.findBoundaryElement(), this.positioned || this.initialisePosition(), this.isMoving = !0, this.element.classList.add("ag-moving"), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMove(e) {
    if (!this.isMoving)
      return;
    const { x: t, y: r } = this.position;
    let n;
    this.config.calculateTopBuffer && (n = this.config.calculateTopBuffer());
    const { movementX: i, movementY: o } = this.calculateMouseMovement({
      e,
      isTop: !0,
      anywhereWithin: !0,
      topBuffer: n
    });
    this.offsetElement(t + i, r + o), this.updateDragStartPosition(e.clientX, e.clientY);
  }
  onMoveEnd() {
    this.isMoving = !1, this.boundaryEl = null, this.element.classList.remove("ag-moving");
  }
  setOffsetParent() {
    this.config.forcePopupParentAsOffsetParent ? this.offsetParent = this.popupService.getPopupParent() : this.offsetParent = this.element.offsetParent;
  }
  findBoundaryElement() {
    let e = this.element;
    for (; e; ) {
      if (window.getComputedStyle(e).position !== "static")
        return e;
      e = e.parentElement;
    }
    return this.element;
  }
  clearResizeListeners() {
    for (; this.resizeListeners.length; ) {
      const e = this.resizeListeners.pop();
      this.dragService.removeDragSource(e);
    }
  }
  destroy() {
    super.destroy(), this.moveElementDragListener && this.dragService.removeDragSource(this.moveElementDragListener), this.constrainSizeToAvailableHeight(!1), this.clearResizeListeners(), this.removeResizers();
  }
}, DK = class AK extends he {
  constructor(t, r = {}) {
    super(), this.eFocusableElement = t, this.callbacks = r, this.callbacks = {
      shouldStopEventPropagation: () => !1,
      onTabKeyDown: (n) => {
        if (n.defaultPrevented)
          return;
        const i = this.focusService.findNextFocusableElement(this.eFocusableElement, !1, n.shiftKey);
        i && (i.focus(), n.preventDefault());
      },
      ...r
    };
  }
  wireBeans(t) {
    this.focusService = t.focusService;
  }
  postConstruct() {
    this.eFocusableElement.classList.add(AK.FOCUS_MANAGED_CLASS), this.addKeyDownListeners(this.eFocusableElement), this.callbacks.onFocusIn && this.addManagedElementListeners(this.eFocusableElement, { focusin: this.callbacks.onFocusIn }), this.callbacks.onFocusOut && this.addManagedElementListeners(this.eFocusableElement, { focusout: this.callbacks.onFocusOut });
  }
  addKeyDownListeners(t) {
    this.addManagedElementListeners(t, {
      keydown: (r) => {
        if (!(r.defaultPrevented || Vl(r))) {
          if (this.callbacks.shouldStopEventPropagation(r)) {
            zh(r);
            return;
          }
          r.key === ae.TAB ? this.callbacks.onTabKeyDown(r) : this.callbacks.handleKeyDown && this.callbacks.handleKeyDown(r);
        }
      }
    });
  }
};
DK.FOCUS_MANAGED_CLASS = "ag-focus-managed";
var td = DK, IK = {
  applyFilter: "Apply",
  clearFilter: "Clear",
  resetFilter: "Reset",
  cancelFilter: "Cancel",
  textFilter: "Text Filter",
  numberFilter: "Number Filter",
  dateFilter: "Date Filter",
  setFilter: "Set Filter",
  filterOoo: "Filter...",
  empty: "Choose one",
  equals: "Equals",
  notEqual: "Does not equal",
  lessThan: "Less than",
  greaterThan: "Greater than",
  inRange: "Between",
  inRangeStart: "From",
  inRangeEnd: "To",
  lessThanOrEqual: "Less than or equal to",
  greaterThanOrEqual: "Greater than or equal to",
  contains: "Contains",
  notContains: "Does not contain",
  startsWith: "Begins with",
  endsWith: "Ends with",
  blank: "Blank",
  notBlank: "Not blank",
  before: "Before",
  after: "After",
  andCondition: "AND",
  orCondition: "OR",
  dateFormatOoo: "yyyy-mm-dd"
};
function MA(e, t) {
  return YC(e) ? (e.debounceMs != null && Se("debounceMs is ignored when apply button is present"), 0) : e.debounceMs != null ? e.debounceMs : t;
}
function YC(e) {
  return !!e.buttons && e.buttons.indexOf("apply") >= 0;
}
var ANe = class extends Nr {
  constructor(e) {
    super(), this.filterNameKey = e, this.applyActive = !1, this.hidePopup = null, this.debouncePending = !1, this.appliedModel = null, this.eFilterBody = ft, this.buttonListeners = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.resetTemplate(), this.createManagedBean(
      new td(this.getFocusableElement(), {
        handleKeyDown: this.handleKeyDown.bind(this)
      })
    ), this.positionableFeature = new DNe(this.getPositionableElement(), {
      forcePopupParentAsOffsetParent: !0
    }), this.createBean(this.positionableFeature);
  }
  // override
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  handleKeyDown(e) {
  }
  getFilterTitle() {
    return this.translate(this.filterNameKey);
  }
  isFilterActive() {
    return !!this.appliedModel;
  }
  resetTemplate(e) {
    let t = this.getGui();
    t && t.removeEventListener("submit", this.onFormSubmit);
    const r = (
      /* html */
      `
            <form class="ag-filter-wrapper">
                <div class="ag-filter-body-wrapper ag-${this.getCssIdentifier()}-body-wrapper" data-ref="eFilterBody">
                    ${this.createBodyTemplate()}
                </div>
            </form>`
    );
    this.setTemplate(r, this.getAgComponents(), e), t = this.getGui(), t && t.addEventListener("submit", this.onFormSubmit);
  }
  isReadOnly() {
    return !!this.providedFilterParams.readOnly;
  }
  init(e) {
    this.setParams(e), this.resetUiToDefaults(!0).then(() => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  setParams(e) {
    this.providedFilterParams = e, this.applyActive = YC(e), this.resetButtonsPanel();
  }
  updateParams(e) {
    this.providedFilterParams = e, this.applyActive = YC(e), this.resetUiToActiveModel(this.getModel(), () => {
      this.updateUiVisibility(), this.setupOnBtApplyDebounce();
    });
  }
  resetButtonsPanel() {
    const { buttons: e } = this.providedFilterParams, t = e && e.length > 0 && !this.isReadOnly();
    if (this.eButtonsPanel ? (oo(this.eButtonsPanel), this.buttonListeners.forEach((i) => i()), this.buttonListeners = []) : t && (this.eButtonsPanel = document.createElement("div"), this.eButtonsPanel.classList.add("ag-filter-apply-panel")), !t) {
      this.eButtonsPanel && Oc(this.eButtonsPanel);
      return;
    }
    const r = document.createDocumentFragment(), n = (i) => {
      let o, a;
      switch (i) {
        case "apply":
          o = this.translate("applyFilter"), a = (u) => this.onBtApply(!1, !1, u);
          break;
        case "clear":
          o = this.translate("clearFilter"), a = () => this.onBtClear();
          break;
        case "reset":
          o = this.translate("resetFilter"), a = () => this.onBtReset();
          break;
        case "cancel":
          o = this.translate("cancelFilter"), a = (u) => {
            this.onBtCancel(u);
          };
          break;
        default:
          Se("Unknown button type specified");
          return;
      }
      const l = Wh(
        /* html */
        `<button
                    type="${i === "apply" ? "submit" : "button"}"
                    data-ref="${i}FilterButton"
                    class="ag-button ag-standard-button ag-filter-apply-panel-button"
                >${o}
                </button>`
      );
      this.buttonListeners.push(...this.addManagedElementListeners(l, { click: a })), r.append(l);
    };
    e.forEach((i) => n(i)), this.eButtonsPanel.append(r), this.getGui().appendChild(this.eButtonsPanel);
  }
  // subclasses can override this to provide alternative debounce defaults
  getDefaultDebounceMs() {
    return 0;
  }
  setupOnBtApplyDebounce() {
    const e = MA(this.providedFilterParams, this.getDefaultDebounceMs()), t = vi(this.checkApplyDebounce.bind(this), e);
    this.onBtApplyDebounce = () => {
      this.debouncePending = !0, t();
    };
  }
  checkApplyDebounce() {
    this.debouncePending && (this.debouncePending = !1, this.onBtApply());
  }
  getModel() {
    return this.appliedModel ? this.appliedModel : null;
  }
  setModel(e) {
    return (e != null ? this.setModelIntoUi(e) : this.resetUiToDefaults()).then(() => {
      this.updateUiVisibility(), this.applyModel("api");
    });
  }
  onBtCancel(e) {
    this.resetUiToActiveModel(this.getModel(), () => {
      this.handleCancelEnd(e);
    });
  }
  handleCancelEnd(e) {
    this.providedFilterParams.closeOnApply && this.close(e);
  }
  resetUiToActiveModel(e, t) {
    const r = () => {
      this.onUiChanged(!1, "prevent"), t == null || t();
    };
    e != null ? this.setModelIntoUi(e).then(r) : this.resetUiToDefaults().then(r);
  }
  onBtClear() {
    this.resetUiToDefaults().then(() => this.onUiChanged());
  }
  onBtReset() {
    this.onBtClear(), this.onBtApply();
  }
  /**
   * Applies changes made in the UI to the filter, and returns true if the model has changed.
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  applyModel(e = "api") {
    const t = this.getModelFromUi();
    if (!this.isModelValid(t))
      return !1;
    const r = this.appliedModel;
    return this.appliedModel = t, !this.areModelsEqual(r, t);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  isModelValid(e) {
    return !0;
  }
  onFormSubmit(e) {
    e.preventDefault();
  }
  onBtApply(e = !1, t = !1, r) {
    r && r.preventDefault(), this.applyModel(t ? "rowDataUpdated" : "ui") && this.providedFilterParams.filterChangedCallback({ afterFloatingFilter: e, afterDataChange: t, source: "columnFilter" });
    const { closeOnApply: n } = this.providedFilterParams;
    n && this.applyActive && !e && !t && this.close(r);
  }
  onNewRowsLoaded() {
  }
  close(e) {
    if (!this.hidePopup)
      return;
    const t = e, r = t && t.key;
    let n;
    (r === "Enter" || r === "Space") && (n = { keyboardEvent: t }), this.hidePopup(n), this.hidePopup = null;
  }
  /**
   * By default, if the change came from a floating filter it will be applied immediately, otherwise if there is no
   * apply button it will be applied after a debounce, otherwise it will not be applied at all. This behaviour can
   * be adjusted by using the apply parameter.
   */
  onUiChanged(e = !1, t) {
    if (this.updateUiVisibility(), this.providedFilterParams.filterModifiedCallback(), this.applyActive && !this.isReadOnly()) {
      const r = this.isModelValid(this.getModelFromUi()), n = this.queryForHtmlElement('[data-ref="applyFilterButton"]');
      n && sv(n, !r);
    }
    e && !t || t === "immediately" ? this.onBtApply(e) : (!this.applyActive && !t || t === "debounce") && this.onBtApplyDebounce();
  }
  afterGuiAttached(e) {
    e && (this.hidePopup = e.hidePopup), this.refreshFilterResizer(e == null ? void 0 : e.container);
  }
  refreshFilterResizer(e) {
    if (!this.positionableFeature || e === "toolPanel")
      return;
    const t = e === "floatingFilter" || e === "columnFilter", { positionableFeature: r, gos: n } = this;
    t ? (r.restoreLastSize(), r.setResizable(
      n.get("enableRtl") ? { bottom: !0, bottomLeft: !0, left: !0 } : { bottom: !0, bottomRight: !0, right: !0 }
    )) : (this.positionableFeature.removeSizeFromEl(), this.positionableFeature.setResizable(!1)), this.positionableFeature.constrainSizeToAvailableHeight(!0);
  }
  afterGuiDetached() {
    this.checkApplyDebounce(), this.positionableFeature && this.positionableFeature.constrainSizeToAvailableHeight(!1);
  }
  refresh(e) {
    return this.providedFilterParams = e, !0;
  }
  destroy() {
    const e = this.getGui();
    e && e.removeEventListener("submit", this.onFormSubmit), this.hidePopup = null, this.positionableFeature && (this.positionableFeature = this.destroyBean(this.positionableFeature)), this.appliedModel = null, super.destroy();
  }
  translate(e) {
    return this.localeService.getLocaleTextFunc()(e, IK[e]);
  }
  getCellValue(e) {
    return this.providedFilterParams.getValue(e);
  }
  // override to control positionable feature
  getPositionableElement() {
    return this.eFilterBody;
  }
}, INe = class extends _A {
  constructor(e) {
    super(e, "ag-radio-button", "radio");
  }
  isSelected() {
    return this.eInput.checked;
  }
  toggle() {
    this.eInput.disabled || this.isSelected() || this.setValue(!0);
  }
  addInputListeners() {
    super.addInputListeners(), this.addManagedEventListeners({ checkboxChanged: this.onChange.bind(this) });
  }
  /**
   * This ensures that if another radio button in the same named group is selected, we deselect this radio button.
   * By default the browser does this for you, but we are managing classes ourselves in order to ensure input
   * elements are styled correctly in IE11, and the DOM 'changed' event is only fired when a button is selected,
   * not deselected, so we need to use our own event.
   */
  onChange(e) {
    e.selected && e.name && this.eInput.name && this.eInput.name === e.name && e.id && this.eInput.id !== e.id && this.setValue(!1, !0);
  }
}, FNe = class extends Nr {
  constructor(e = "default", t = !1) {
    super(
      /* html */
      `<div class="ag-list ag-${e}-list" role="listbox"></div>`
    ), this.cssIdentifier = e, this.unFocusable = t, this.activeClass = "ag-active-item", this.options = [], this.itemEls = [];
  }
  postConstruct() {
    const e = this.getGui();
    this.addManagedElementListeners(e, { mouseleave: () => this.clearHighlighted() }), !this.unFocusable && this.addManagedElementListeners(e, { keydown: this.handleKeyDown.bind(this) });
  }
  handleKeyDown(e) {
    const t = e.key;
    switch (t) {
      case ae.ENTER:
        if (!this.highlightedEl)
          this.setValue(this.getValue());
        else {
          const r = this.itemEls.indexOf(this.highlightedEl);
          this.setValueByIndex(r);
        }
        break;
      case ae.DOWN:
      case ae.UP:
        e.preventDefault(), this.navigate(t);
        break;
      case ae.PAGE_DOWN:
      case ae.PAGE_UP:
      case ae.PAGE_HOME:
      case ae.PAGE_END:
        e.preventDefault(), this.navigateToPage(t);
        break;
    }
  }
  navigate(e) {
    const t = e === ae.DOWN;
    let r;
    if (!this.highlightedEl)
      r = this.itemEls[t ? 0 : this.itemEls.length - 1];
    else {
      let i = this.itemEls.indexOf(this.highlightedEl) + (t ? 1 : -1);
      i = Math.min(Math.max(i, 0), this.itemEls.length - 1), r = this.itemEls[i];
    }
    this.highlightItem(r);
  }
  navigateToPage(e) {
    if (!this.highlightedEl || this.itemEls.length === 0)
      return;
    const t = this.itemEls.indexOf(this.highlightedEl), r = this.options.length - 1, n = this.itemEls[0].clientHeight, i = Math.floor(this.getGui().clientHeight / n);
    let o = -1;
    e === ae.PAGE_HOME ? o = 0 : e === ae.PAGE_END ? o = r : e === ae.PAGE_DOWN ? o = Math.min(t + i, r) : e === ae.PAGE_UP && (o = Math.max(t - i, 0)), o !== -1 && this.highlightItem(this.itemEls[o]);
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    const { value: t, text: r } = e, n = r || t;
    return this.options.push({ value: t, text: n }), this.renderOption(t, n), this.updateIndices(), this;
  }
  clearOptions() {
    this.options = [], this.reset(!0), this.itemEls.forEach((e) => {
      Oc(e);
    }), this.itemEls = [];
  }
  updateIndices() {
    const e = this.getGui().querySelectorAll(".ag-list-item");
    e.forEach((t, r) => {
      pOe(t, r + 1), fOe(t, e.length);
    });
  }
  renderOption(e, t) {
    const r = this.gos.getDocument(), n = r.createElement("div");
    Sa(n, "option"), n.classList.add("ag-list-item", `ag-${this.cssIdentifier}-list-item`);
    const i = r.createElement("span");
    n.appendChild(i), i.textContent = t, this.unFocusable || (n.tabIndex = -1), this.itemEls.push(n), this.addManagedListeners(n, {
      mouseover: () => this.highlightItem(n),
      mousedown: (o) => {
        o.preventDefault(), o.stopPropagation(), this.setValue(e);
      }
    }), this.createManagedBean(
      new bf({
        getTooltipValue: () => t,
        getGui: () => n,
        getLocation: () => "UNKNOWN",
        // only show tooltips for items where the text cannot be fully displayed
        shouldDisplayTooltip: () => i.scrollWidth > i.clientWidth
      })
    ), this.getGui().appendChild(n);
  }
  setValue(e, t) {
    if (this.value === e)
      return this.fireItemSelected(), this;
    if (e == null)
      return this.reset(t), this;
    const r = this.options.findIndex((n) => n.value === e);
    if (r !== -1) {
      const n = this.options[r];
      this.value = n.value, this.displayValue = n.text, this.highlightItem(this.itemEls[r]), t || this.fireChangeEvent();
    }
    return this;
  }
  setValueByIndex(e) {
    return this.setValue(this.options[e].value);
  }
  getValue() {
    return this.value;
  }
  getDisplayValue() {
    return this.displayValue;
  }
  refreshHighlighted() {
    this.clearHighlighted();
    const e = this.options.findIndex((t) => t.value === this.value);
    e !== -1 && this.highlightItem(this.itemEls[e]);
  }
  reset(e) {
    this.value = null, this.displayValue = null, this.clearHighlighted(), e || this.fireChangeEvent();
  }
  highlightItem(e) {
    if (!ts(e))
      return;
    this.clearHighlighted(), this.highlightedEl = e, this.highlightedEl.classList.add(this.activeClass), zC(this.highlightedEl, !0);
    const t = this.getGui(), { scrollTop: r, clientHeight: n } = t, { offsetTop: i, offsetHeight: o } = e;
    (i + o > r + n || i < r) && this.highlightedEl.scrollIntoView({ block: "nearest" }), this.unFocusable || this.highlightedEl.focus();
  }
  clearHighlighted() {
    !this.highlightedEl || !ts(this.highlightedEl) || (this.highlightedEl.classList.remove(this.activeClass), zC(this.highlightedEl, !1), this.highlightedEl = null);
  }
  fireChangeEvent() {
    this.dispatchLocalEvent({ type: "fieldValueChanged" }), this.fireItemSelected();
  }
  fireItemSelected() {
    this.dispatchLocalEvent({ type: "selectedItem" });
  }
}, LNe = class extends bK {
  constructor(e) {
    if (super(
      e,
      (e == null ? void 0 : e.template) || /* html */
      `
            <div class="ag-picker-field" role="presentation">
                <div data-ref="eLabel"></div>
                    <div data-ref="eWrapper" class="ag-wrapper ag-picker-field-wrapper ag-picker-collapsed">
                    <div data-ref="eDisplayField" class="ag-picker-field-display"></div>
                    <div data-ref="eIcon" class="ag-picker-field-icon" aria-hidden="true"></div>
                </div>
            </div>`,
      (e == null ? void 0 : e.agComponents) || [],
      e == null ? void 0 : e.className
    ), this.isPickerDisplayed = !1, this.skipClick = !1, this.pickerGap = 4, this.hideCurrentPicker = null, this.eLabel = ft, this.eWrapper = ft, this.eDisplayField = ft, this.eIcon = ft, this.ariaRole = e == null ? void 0 : e.ariaRole, this.onPickerFocusIn = this.onPickerFocusIn.bind(this), this.onPickerFocusOut = this.onPickerFocusOut.bind(this), !e)
      return;
    const { pickerGap: t, maxPickerHeight: r, variableWidth: n, minPickerWidth: i, maxPickerWidth: o } = e;
    t != null && (this.pickerGap = t), this.variableWidth = !!n, r != null && this.setPickerMaxHeight(r), i != null && this.setPickerMinWidth(i), o != null && this.setPickerMaxWidth(o);
  }
  wireBeans(e) {
    this.popupService = e.popupService;
  }
  postConstruct() {
    super.postConstruct(), this.setupAria();
    const e = `ag-${this.getCompId()}-display`;
    this.eDisplayField.setAttribute("id", e);
    const t = this.getAriaElement();
    this.addManagedElementListeners(t, { keydown: this.onKeyDown.bind(this) }), this.addManagedElementListeners(this.eLabel, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) }), this.addManagedElementListeners(this.eWrapper, { mousedown: this.onLabelOrWrapperMouseDown.bind(this) });
    const { pickerIcon: r, inputWidth: n } = this.config;
    if (r) {
      const i = to(r, this.gos);
      i && this.eIcon.appendChild(i);
    }
    n != null && this.setInputWidth(n);
  }
  setupAria() {
    const e = this.getAriaElement();
    e.setAttribute("tabindex", this.gos.get("tabIndex").toString()), HC(e, !1), this.ariaRole && Sa(e, this.ariaRole);
  }
  onLabelOrWrapperMouseDown(e) {
    if (e) {
      const t = this.getFocusableElement();
      if (t !== this.eWrapper && (e == null ? void 0 : e.target) === t)
        return;
      e.preventDefault(), this.getFocusableElement().focus();
    }
    if (this.skipClick) {
      this.skipClick = !1;
      return;
    }
    this.isDisabled() || (this.isPickerDisplayed ? this.hidePicker() : this.showPicker());
  }
  onKeyDown(e) {
    switch (e.key) {
      case ae.UP:
      case ae.DOWN:
      case ae.ENTER:
      case ae.SPACE:
        e.preventDefault(), this.onLabelOrWrapperMouseDown();
        break;
      case ae.ESCAPE:
        this.isPickerDisplayed && (e.preventDefault(), e.stopPropagation(), this.hideCurrentPicker && this.hideCurrentPicker());
        break;
    }
  }
  showPicker() {
    this.isPickerDisplayed = !0, this.pickerComponent || (this.pickerComponent = this.createPickerComponent());
    const e = this.pickerComponent.getGui();
    e.addEventListener("focusin", this.onPickerFocusIn), e.addEventListener("focusout", this.onPickerFocusOut), this.hideCurrentPicker = this.renderAndPositionPicker(), this.toggleExpandedStyles(!0);
  }
  renderAndPositionPicker() {
    const e = this.gos.getDocument(), t = this.pickerComponent.getGui();
    this.gos.get("suppressScrollWhenPopupsAreOpen") || ([this.destroyMouseWheelFunc] = this.addManagedEventListeners({
      bodyScroll: () => {
        this.hidePicker();
      }
    }));
    const r = this.localeService.getLocaleTextFunc(), { pickerAriaLabelKey: n, pickerAriaLabelValue: i, modalPicker: o = !0 } = this.config, a = {
      modal: o,
      eChild: t,
      closeOnEsc: !0,
      closedCallback: () => {
        const f = this.gos.getActiveDomElement(), p = !f || f === e.body;
        this.beforeHidePicker(), p && this.isAlive() && this.getFocusableElement().focus();
      },
      ariaLabel: r(n, i)
    }, s = this.popupService.addPopup(a), { maxPickerHeight: l, minPickerWidth: u, maxPickerWidth: c, variableWidth: d } = this;
    d ? (u && (t.style.minWidth = u), t.style.width = xA($C(this.eWrapper)), c && (t.style.maxWidth = c)) : KC(t, c ?? $C(this.eWrapper));
    const h = l ?? `${bA(this.popupService.getPopupParent())}px`;
    return t.style.setProperty("max-height", h), t.style.position = "absolute", this.alignPickerToComponent(), s.hideFunc;
  }
  alignPickerToComponent() {
    if (!this.pickerComponent)
      return;
    const { pickerType: e } = this.config, { pickerGap: t } = this, r = this.gos.get("enableRtl") ? "right" : "left";
    this.popupService.positionPopupByComponent({
      type: e,
      eventSource: this.eWrapper,
      ePopup: this.pickerComponent.getGui(),
      position: "under",
      alignSide: r,
      keepWithinBounds: !0,
      nudgeY: t
    });
  }
  beforeHidePicker() {
    this.destroyMouseWheelFunc && (this.destroyMouseWheelFunc(), this.destroyMouseWheelFunc = void 0), this.toggleExpandedStyles(!1);
    const e = this.pickerComponent.getGui();
    e.removeEventListener("focusin", this.onPickerFocusIn), e.removeEventListener("focusout", this.onPickerFocusOut), this.isPickerDisplayed = !1, this.pickerComponent = void 0, this.hideCurrentPicker = null;
  }
  toggleExpandedStyles(e) {
    if (!this.isAlive())
      return;
    const t = this.getAriaElement();
    HC(t, e), this.eWrapper.classList.toggle("ag-picker-expanded", e), this.eWrapper.classList.toggle("ag-picker-collapsed", !e);
  }
  onPickerFocusIn() {
    this.togglePickerHasFocus(!0);
  }
  onPickerFocusOut(e) {
    var t;
    (t = this.pickerComponent) != null && t.getGui().contains(e.relatedTarget) || this.togglePickerHasFocus(!1);
  }
  togglePickerHasFocus(e) {
    this.pickerComponent && this.eWrapper.classList.toggle("ag-picker-has-focus", e);
  }
  hidePicker() {
    this.hideCurrentPicker && this.hideCurrentPicker();
  }
  setInputWidth(e) {
    return KC(this.eWrapper, e), this;
  }
  getFocusableElement() {
    return this.eWrapper;
  }
  setPickerGap(e) {
    return this.pickerGap = e, this;
  }
  setPickerMinWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.minPickerWidth = e ?? void 0, this;
  }
  setPickerMaxWidth(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerWidth = e ?? void 0, this;
  }
  setPickerMaxHeight(e) {
    return typeof e == "number" && (e = `${e}px`), this.maxPickerHeight = e ?? void 0, this;
  }
  destroy() {
    this.hidePicker(), super.destroy();
  }
}, DA = class extends LNe {
  constructor(e) {
    super({
      pickerAriaLabelKey: "ariaLabelSelectField",
      pickerAriaLabelValue: "Select Field",
      pickerType: "ag-list",
      className: "ag-select",
      pickerIcon: "smallDown",
      ariaRole: "combobox",
      ...e
    });
  }
  postConstruct() {
    super.postConstruct(), this.createListComponent(), this.eWrapper.tabIndex = this.gos.get("tabIndex");
    const { options: e, value: t, placeholder: r } = this.config;
    e != null && this.addOptions(e), t != null && this.setValue(t, !0), r && t == null && (this.eDisplayField.textContent = r), this.addManagedElementListeners(this.eWrapper, { focusout: this.onWrapperFocusOut.bind(this) });
  }
  onWrapperFocusOut(e) {
    this.eWrapper.contains(e.relatedTarget) || this.hidePicker();
  }
  createListComponent() {
    this.listComponent = this.createBean(new FNe("select", !0)), this.listComponent.setParentComponent(this);
    const e = this.listComponent.getAriaElement(), t = `ag-select-list-${this.listComponent.getCompId()}`;
    e.setAttribute("id", t), wOe(this.getAriaElement(), e), this.listComponent.addManagedListeners(this.listComponent, {
      selectedItem: () => {
        this.hidePicker(), this.dispatchLocalEvent({ type: "selectedItem" });
      }
    }), this.listComponent.addManagedListeners(this.listComponent, {
      fieldValueChanged: () => {
        this.listComponent && (this.setValue(this.listComponent.getValue(), !1, !0), this.hidePicker());
      }
    });
  }
  createPickerComponent() {
    return this.listComponent;
  }
  onKeyDown(e) {
    var r;
    const { key: t } = e;
    switch (t === ae.TAB && this.hidePicker(), t) {
      case ae.ENTER:
      case ae.UP:
      case ae.DOWN:
      case ae.PAGE_UP:
      case ae.PAGE_DOWN:
      case ae.PAGE_HOME:
      case ae.PAGE_END:
        e.preventDefault(), this.isPickerDisplayed ? (r = this.listComponent) == null || r.handleKeyDown(e) : super.onKeyDown(e);
        break;
      case ae.ESCAPE:
        super.onKeyDown(e);
        break;
    }
  }
  showPicker() {
    this.listComponent && (super.showPicker(), this.listComponent.refreshHighlighted());
  }
  addOptions(e) {
    return e.forEach((t) => this.addOption(t)), this;
  }
  addOption(e) {
    return this.listComponent.addOption(e), this;
  }
  clearOptions() {
    var e;
    return (e = this.listComponent) == null || e.clearOptions(), this;
  }
  setValue(e, t, r) {
    if (this.value === e || !this.listComponent)
      return this;
    if (r || this.listComponent.setValue(e, !0), this.listComponent.getValue() === this.getValue())
      return this;
    let i = this.listComponent.getDisplayValue();
    return i == null && this.config.placeholder && (i = this.config.placeholder), this.eDisplayField.textContent = i, this.setTooltip({
      newTooltipText: i ?? null,
      shouldDisplayTooltip: () => this.eDisplayField.scrollWidth > this.eDisplayField.clientWidth
    }), super.setValue(e, t);
  }
  destroy() {
    this.listComponent && (this.listComponent = this.destroyBean(this.listComponent)), super.destroy();
  }
}, ONe = {
  selector: "AG-SELECT",
  component: DA
}, FK = class {
  constructor() {
    this.customFilterOptions = {};
  }
  init(e, t) {
    this.filterOptions = e.filterOptions || t, this.mapCustomOptions(), this.selectDefaultItem(e);
  }
  getFilterOptions() {
    return this.filterOptions;
  }
  mapCustomOptions() {
    this.filterOptions && this.filterOptions.forEach((e) => {
      if (typeof e == "string")
        return;
      const t = [["displayKey"], ["displayName"], ["predicate", "test"]], r = (n) => n.some((i) => e[i] != null) ? !0 : (Se(`ignoring FilterOptionDef as it doesn't contain one of '${n}'`), !1);
      if (!t.every(r)) {
        this.filterOptions = this.filterOptions.filter((n) => n === e) || [];
        return;
      }
      this.customFilterOptions[e.displayKey] = e;
    });
  }
  selectDefaultItem(e) {
    if (e.defaultOption)
      this.defaultOption = e.defaultOption;
    else if (this.filterOptions.length >= 1) {
      const t = this.filterOptions[0];
      typeof t == "string" ? this.defaultOption = t : t.displayKey ? this.defaultOption = t.displayKey : Se("invalid FilterOptionDef supplied as it doesn't contain a 'displayKey'");
    } else
      Se("no filter options for filter");
  }
  getDefaultOption() {
    return this.defaultOption;
  }
  getCustomOption(e) {
    return this.customFilterOptions[e];
  }
}, LK = class extends ANe {
  constructor() {
    super(...arguments), this.eTypes = [], this.eJoinOperatorPanels = [], this.eJoinOperatorsAnd = [], this.eJoinOperatorsOr = [], this.eConditionBodies = [], this.listener = () => this.onUiChanged(), this.lastUiCompletePosition = null, this.joinOperatorId = 0;
  }
  getNumberOfInputs(e) {
    const t = this.optionsFactory.getCustomOption(e);
    if (t) {
      const { numberOfInputs: n } = t;
      return n ?? 1;
    }
    return e && ["empty", "notBlank", "blank"].indexOf(e) >= 0 ? 0 : e === "inRange" ? 2 : 1;
  }
  // floating filter calls this when user applies filter from floating filter
  onFloatingFilterChanged(e, t) {
    this.setTypeFromFloatingFilter(e), this.setValueFromFloatingFilter(t), this.onUiChanged(!0);
  }
  setTypeFromFloatingFilter(e) {
    this.eTypes.forEach((t, r) => {
      r === 0 ? t.setValue(e, !0) : t.setValue(this.optionsFactory.getDefaultOption(), !0);
    });
  }
  getModelFromUi() {
    const e = this.getUiCompleteConditions();
    return e.length === 0 ? null : this.maxNumConditions > 1 && e.length > 1 ? {
      filterType: this.getFilterType(),
      operator: this.getJoinOperator(),
      conditions: e
    } : e[0];
  }
  getConditionTypes() {
    return this.eTypes.map((e) => e.getValue());
  }
  getConditionType(e) {
    return this.eTypes[e].getValue();
  }
  getJoinOperator() {
    return this.eJoinOperatorsOr.length === 0 ? this.defaultJoinOperator : this.eJoinOperatorsOr[0].getValue() === !0 ? "OR" : "AND";
  }
  areModelsEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e && t || e && !t)
      return !1;
    const r = !e.operator, n = !t.operator;
    if (!r && n || r && !n)
      return !1;
    let o;
    if (r) {
      const a = e, s = t;
      o = this.areSimpleModelsEqual(a, s);
    } else {
      const a = e, s = t;
      o = a.operator === s.operator && Jc(
        a.conditions,
        s.conditions,
        (l, u) => this.areSimpleModelsEqual(l, u)
      );
    }
    return o;
  }
  shouldRefresh(e) {
    var o;
    const t = this.getModel(), r = t ? t.conditions ?? [t] : null, n = ((o = e.filterOptions) == null ? void 0 : o.map((a) => typeof a == "string" ? a : a.displayKey)) ?? this.getDefaultFilterOptions();
    return !(!(!r || r.every((a) => n.find((s) => s === a.type) !== void 0)) || typeof e.maxNumConditions == "number" && r && r.length > e.maxNumConditions);
  }
  refresh(e) {
    return !this.shouldRefresh(e) || !super.refresh(e) ? !1 : (this.setParams(e), this.removeConditionsAndOperators(0), this.createOption(), this.setModel(this.getModel()), !0);
  }
  setModelIntoUi(e) {
    if (e.operator) {
      const r = e;
      let n = r.conditions;
      n == null && (n = [], Se("Filter model is missing 'conditions'"));
      const i = this.validateAndUpdateConditions(n), o = this.getNumConditions();
      if (i < o)
        this.removeConditionsAndOperators(i);
      else if (i > o)
        for (let s = o; s < i; s++)
          this.createJoinOperatorPanel(), this.createOption();
      const a = r.operator === "OR";
      this.eJoinOperatorsAnd.forEach((s) => s.setValue(!a, !0)), this.eJoinOperatorsOr.forEach((s) => s.setValue(a, !0)), n.forEach((s, l) => {
        this.eTypes[l].setValue(s.type, !0), this.setConditionIntoUi(s, l);
      });
    } else {
      const r = e;
      this.getNumConditions() > 1 && this.removeConditionsAndOperators(1), this.eTypes[0].setValue(r.type, !0), this.setConditionIntoUi(r, 0);
    }
    return this.lastUiCompletePosition = this.getNumConditions() - 1, this.createMissingConditionsAndOperators(), this.onUiChanged(), en.resolve();
  }
  validateAndUpdateConditions(e) {
    let t = e.length;
    return t > this.maxNumConditions && (e.splice(this.maxNumConditions), Se(
      'Filter Model contains more conditions than "filterParams.maxNumConditions". Additional conditions have been ignored.'
    ), t = this.maxNumConditions), t;
  }
  doesFilterPass(e) {
    const t = this.getModel();
    if (t == null)
      return !0;
    const { operator: r } = t, n = [];
    if (r) {
      const o = t;
      n.push(...o.conditions ?? []);
    } else
      n.push(t);
    return n[r && r === "OR" ? "some" : "every"]((o) => this.individualConditionPasses(e, o));
  }
  setParams(e) {
    super.setParams(e), this.setNumConditions(e), this.defaultJoinOperator = this.getDefaultJoinOperator(e.defaultJoinOperator), this.filterPlaceholder = e.filterPlaceholder, this.optionsFactory = new FK(), this.optionsFactory.init(e, this.getDefaultFilterOptions()), this.createFilterListOptions(), this.createOption(), this.createMissingConditionsAndOperators(), this.isReadOnly() && this.eFilterBody.setAttribute("tabindex", "-1");
  }
  setNumConditions(e) {
    this.maxNumConditions = e.maxNumConditions ?? 2, this.maxNumConditions < 1 && (Se('"filterParams.maxNumConditions" must be greater than or equal to zero.'), this.maxNumConditions = 1), this.numAlwaysVisibleConditions = e.numAlwaysVisibleConditions ?? 1, this.numAlwaysVisibleConditions < 1 && (Se('"filterParams.numAlwaysVisibleConditions" must be greater than or equal to zero.'), this.numAlwaysVisibleConditions = 1), this.numAlwaysVisibleConditions > this.maxNumConditions && (Se(
      '"filterParams.numAlwaysVisibleConditions" cannot be greater than "filterParams.maxNumConditions".'
    ), this.numAlwaysVisibleConditions = this.maxNumConditions);
  }
  createOption() {
    const e = this.createManagedBean(new DA());
    this.eTypes.push(e), e.addCssClass("ag-filter-select"), this.eFilterBody.appendChild(e.getGui());
    const t = this.createValueElement();
    this.eConditionBodies.push(t), this.eFilterBody.appendChild(t), this.putOptionsIntoDropdown(e), this.resetType(e);
    const r = this.getNumConditions() - 1;
    this.forEachPositionInput(r, (n) => this.resetInput(n)), this.addChangedListeners(e, r);
  }
  createJoinOperatorPanel() {
    const e = document.createElement("div");
    this.eJoinOperatorPanels.push(e), e.classList.add("ag-filter-condition");
    const t = this.createJoinOperator(this.eJoinOperatorsAnd, e, "and"), r = this.createJoinOperator(this.eJoinOperatorsOr, e, "or");
    this.eFilterBody.appendChild(e);
    const n = this.eJoinOperatorPanels.length - 1, i = this.joinOperatorId++;
    this.resetJoinOperatorAnd(t, n, i), this.resetJoinOperatorOr(r, n, i), this.isReadOnly() || (t.onValueChange(this.listener), r.onValueChange(this.listener));
  }
  createJoinOperator(e, t, r) {
    const n = this.createManagedBean(new INe());
    return e.push(n), n.addCssClass("ag-filter-condition-operator"), n.addCssClass(`ag-filter-condition-operator-${r}`), t.appendChild(n.getGui()), n;
  }
  getDefaultJoinOperator(e) {
    return e === "AND" || e === "OR" ? e : "AND";
  }
  createFilterListOptions() {
    const e = this.optionsFactory.getFilterOptions();
    this.filterListOptions = e.map(
      (t) => typeof t == "string" ? this.createBoilerplateListOption(t) : this.createCustomListOption(t)
    );
  }
  putOptionsIntoDropdown(e) {
    this.filterListOptions.forEach((t) => {
      e.addOption(t);
    }), e.setDisabled(this.filterListOptions.length <= 1);
  }
  createBoilerplateListOption(e) {
    return { value: e, text: this.translate(e) };
  }
  createCustomListOption(e) {
    const { displayKey: t } = e, r = this.optionsFactory.getCustomOption(e.displayKey);
    return {
      value: t,
      text: r ? this.localeService.getLocaleTextFunc()(r.displayKey, r.displayName) : this.translate(t)
    };
  }
  createBodyTemplate() {
    return "";
  }
  getAgComponents() {
    return [];
  }
  getCssIdentifier() {
    return "simple-filter";
  }
  updateUiVisibility() {
    const e = this.getJoinOperator();
    this.updateNumConditions(), this.updateConditionStatusesAndValues(this.lastUiCompletePosition, e);
  }
  updateNumConditions() {
    let e = -1, t = !0;
    for (let r = 0; r < this.getNumConditions(); r++)
      this.isConditionUiComplete(r) ? e = r : t = !1;
    if (this.shouldAddNewConditionAtEnd(t))
      this.createJoinOperatorPanel(), this.createOption();
    else {
      const r = this.lastUiCompletePosition ?? this.getNumConditions() - 2;
      if (e < r) {
        this.removeConditionsAndOperators(r + 1);
        const n = e + 1, i = r - n;
        i > 0 && this.removeConditionsAndOperators(n, i), this.createMissingConditionsAndOperators();
      }
    }
    this.lastUiCompletePosition = e;
  }
  updateConditionStatusesAndValues(e, t) {
    this.eTypes.forEach((n, i) => {
      const o = this.isConditionDisabled(i, e);
      n.setDisabled(o || this.filterListOptions.length <= 1), i === 1 && (sv(this.eJoinOperatorPanels[0], o), this.eJoinOperatorsAnd[0].setDisabled(o), this.eJoinOperatorsOr[0].setDisabled(o));
    }), this.eConditionBodies.forEach((n, i) => {
      jr(n, this.isConditionBodyVisible(i));
    });
    const r = (t ?? this.getJoinOperator()) === "OR";
    this.eJoinOperatorsAnd.forEach((n) => {
      n.setValue(!r, !0);
    }), this.eJoinOperatorsOr.forEach((n) => {
      n.setValue(r, !0);
    }), this.forEachInput((n, i, o, a) => {
      this.setElementDisplayed(n, i < a), this.setElementDisabled(n, this.isConditionDisabled(o, e));
    }), this.resetPlaceholder();
  }
  shouldAddNewConditionAtEnd(e) {
    return e && this.getNumConditions() < this.maxNumConditions && !this.isReadOnly();
  }
  removeConditionsAndOperators(e, t) {
    if (e >= this.getNumConditions())
      return;
    this.removeComponents(this.eTypes, e, t), this.removeElements(this.eConditionBodies, e, t), this.removeValueElements(e, t);
    const r = Math.max(e - 1, 0);
    this.removeElements(this.eJoinOperatorPanels, r, t), this.removeComponents(this.eJoinOperatorsAnd, r, t), this.removeComponents(this.eJoinOperatorsOr, r, t);
  }
  removeElements(e, t, r) {
    this.removeItems(e, t, r).forEach((i) => Oc(i));
  }
  removeComponents(e, t, r) {
    this.removeItems(e, t, r).forEach((i) => {
      Oc(i.getGui()), this.destroyBean(i);
    });
  }
  removeItems(e, t, r) {
    return r == null ? e.splice(t) : e.splice(t, r);
  }
  afterGuiAttached(e) {
    if (super.afterGuiAttached(e), this.resetPlaceholder(), !(e != null && e.suppressFocus))
      if (this.isReadOnly())
        this.eFilterBody.focus();
      else {
        const t = this.getInputs(0)[0];
        if (!t)
          return;
        t instanceof lc && t.getInputElement().focus();
      }
  }
  afterGuiDetached() {
    super.afterGuiDetached();
    const e = this.getModel();
    this.resetUiToActiveModel(e);
    let t = -1, r = -1, n = !1;
    const i = this.getJoinOperator();
    for (let a = this.getNumConditions() - 1; a >= 0; a--)
      if (this.isConditionUiComplete(a))
        t === -1 && (t = a, r = a);
      else {
        const s = a >= this.numAlwaysVisibleConditions && !this.isConditionUiComplete(a - 1), l = a < t;
        (s || l) && (this.removeConditionsAndOperators(a, 1), n = !0, l && r--);
      }
    let o = !1;
    this.getNumConditions() < this.numAlwaysVisibleConditions && (this.createMissingConditionsAndOperators(), o = !0), this.shouldAddNewConditionAtEnd(r === this.getNumConditions() - 1) && (this.createJoinOperatorPanel(), this.createOption(), o = !0), o && this.updateConditionStatusesAndValues(r, i), n && this.updateJoinOperatorsDisabled(), this.lastUiCompletePosition = r;
  }
  getPlaceholderText(e, t) {
    let r = this.translate(e);
    if (vA(this.filterPlaceholder)) {
      const n = this.filterPlaceholder, i = this.eTypes[t].getValue(), o = this.translate(i);
      r = n({
        filterOptionKey: i,
        filterOption: o,
        placeholder: r
      });
    } else typeof this.filterPlaceholder == "string" && (r = this.filterPlaceholder);
    return r;
  }
  // allow sub-classes to reset HTML placeholders after UI update.
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc();
    this.forEachInput((t, r, n, i) => {
      if (!(t instanceof lc))
        return;
      const o = r === 0 && i > 1 ? "inRangeStart" : r === 0 ? "filterOoo" : "inRangeEnd", a = r === 0 && i > 1 ? e("ariaFilterFromValue", "Filter from value") : r === 0 ? e("ariaFilterValue", "Filter Value") : e("ariaFilterToValue", "Filter to Value");
      t.setInputPlaceholder(this.getPlaceholderText(o, n)), t.setInputAriaLabel(a);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  setElementValue(e, t, r) {
    e instanceof lc && e.setValue(t != null ? String(t) : null, !0);
  }
  setElementDisplayed(e, t) {
    e instanceof Nr && jr(e.getGui(), t);
  }
  setElementDisabled(e, t) {
    e instanceof Nr && sv(e.getGui(), t);
  }
  attachElementOnChange(e, t) {
    e instanceof lc && e.onValueChange(t);
  }
  forEachInput(e) {
    this.getConditionTypes().forEach((t, r) => {
      this.forEachPositionTypeInput(r, t, e);
    });
  }
  forEachPositionInput(e, t) {
    const r = this.getConditionType(e);
    this.forEachPositionTypeInput(e, r, t);
  }
  forEachPositionTypeInput(e, t, r) {
    const n = this.getNumberOfInputs(t), i = this.getInputs(e);
    for (let o = 0; o < i.length; o++) {
      const a = i[o];
      a != null && r(a, o, e, n);
    }
  }
  isConditionDisabled(e, t) {
    return this.isReadOnly() ? !0 : e === 0 ? !1 : e > t + 1;
  }
  isConditionBodyVisible(e) {
    const t = this.getConditionType(e);
    return this.getNumberOfInputs(t) > 0;
  }
  // returns true if the UI represents a working filter, eg all parts are filled out.
  // eg if text filter and textfield blank then returns false.
  isConditionUiComplete(e) {
    return !(e >= this.getNumConditions() || this.getConditionType(e) === "empty" || this.getValues(e).some((r) => r == null));
  }
  getNumConditions() {
    return this.eTypes.length;
  }
  getUiCompleteConditions() {
    const e = [];
    for (let t = 0; t < this.getNumConditions(); t++)
      this.isConditionUiComplete(t) && e.push(this.createCondition(t));
    return e;
  }
  createMissingConditionsAndOperators() {
    if (!this.isReadOnly())
      for (let e = this.getNumConditions(); e < this.numAlwaysVisibleConditions; e++)
        this.createJoinOperatorPanel(), this.createOption();
  }
  resetUiToDefaults(e) {
    return this.removeConditionsAndOperators(this.isReadOnly() ? 1 : this.numAlwaysVisibleConditions), this.eTypes.forEach((t) => this.resetType(t)), this.eJoinOperatorsAnd.forEach(
      (t, r) => this.resetJoinOperatorAnd(t, r, this.joinOperatorId + r)
    ), this.eJoinOperatorsOr.forEach(
      (t, r) => this.resetJoinOperatorOr(t, r, this.joinOperatorId + r)
    ), this.joinOperatorId++, this.forEachInput((t) => this.resetInput(t)), this.resetPlaceholder(), this.createMissingConditionsAndOperators(), this.lastUiCompletePosition = null, e || this.onUiChanged(), en.resolve();
  }
  resetType(e) {
    const r = this.localeService.getLocaleTextFunc()("ariaFilteringOperator", "Filtering operator");
    e.setValue(this.optionsFactory.getDefaultOption(), !0).setAriaLabel(r).setDisabled(this.isReadOnly() || this.filterListOptions.length <= 1);
  }
  resetJoinOperatorAnd(e, t, r) {
    this.resetJoinOperator(
      e,
      t,
      this.isDefaultOperator("AND"),
      this.translate("andCondition"),
      r
    );
  }
  resetJoinOperatorOr(e, t, r) {
    this.resetJoinOperator(
      e,
      t,
      this.isDefaultOperator("OR"),
      this.translate("orCondition"),
      r
    );
  }
  resetJoinOperator(e, t, r, n, i) {
    this.updateJoinOperatorDisabled(
      e.setValue(r, !0).setName(`ag-simple-filter-and-or-${this.getCompId()}-${i}`).setLabel(n),
      t
    );
  }
  updateJoinOperatorsDisabled() {
    this.eJoinOperatorsAnd.forEach((e, t) => this.updateJoinOperatorDisabled(e, t)), this.eJoinOperatorsOr.forEach((e, t) => this.updateJoinOperatorDisabled(e, t));
  }
  updateJoinOperatorDisabled(e, t) {
    e.setDisabled(this.isReadOnly() || t > 0);
  }
  resetInput(e) {
    this.setElementValue(e, null), this.setElementDisabled(e, this.isReadOnly());
  }
  // puts model values into the UI
  setConditionIntoUi(e, t) {
    const r = this.mapValuesFromModel(e);
    this.forEachInput((n, i, o) => {
      o === t && this.setElementValue(n, r[i] != null ? r[i] : null);
    });
  }
  // after floating filter changes, this sets the 'value' section. this is implemented by the base class
  // (as that's where value is controlled), the 'type' part from the floating filter is dealt with in this class.
  setValueFromFloatingFilter(e) {
    this.forEachInput((t, r, n) => {
      this.setElementValue(t, r === 0 && n === 0 ? e : null, !0);
    });
  }
  isDefaultOperator(e) {
    return e === this.defaultJoinOperator;
  }
  addChangedListeners(e, t) {
    this.isReadOnly() || (e.onValueChange(this.listener), this.forEachPositionInput(t, (r) => {
      this.attachElementOnChange(r, this.listener);
    }));
  }
  /** returns true if the row passes the said condition */
  individualConditionPasses(e, t) {
    const r = this.getCellValue(e.node), n = this.mapValuesFromModel(t), i = this.optionsFactory.getCustomOption(t.type), o = this.evaluateCustomFilter(i, n, r);
    return o ?? (r == null ? this.evaluateNullValue(t.type) : this.evaluateNonNullValue(n, r, t, e));
  }
  evaluateCustomFilter(e, t, r) {
    if (e == null)
      return;
    const { predicate: n } = e;
    if (n != null && !t.some((i) => i == null))
      return n(t, r);
  }
  isBlank(e) {
    return e == null || typeof e == "string" && e.trim().length === 0;
  }
  hasInvalidInputs() {
    return !1;
  }
}, OK = class extends LK {
  setParams(e) {
    super.setParams(e), this.scalarFilterParams = e;
  }
  evaluateNullValue(e) {
    switch (e) {
      case "equals":
      case "notEqual":
        if (this.scalarFilterParams.includeBlanksInEquals)
          return !0;
        break;
      case "greaterThan":
      case "greaterThanOrEqual":
        if (this.scalarFilterParams.includeBlanksInGreaterThan)
          return !0;
        break;
      case "lessThan":
      case "lessThanOrEqual":
        if (this.scalarFilterParams.includeBlanksInLessThan)
          return !0;
        break;
      case "inRange":
        if (this.scalarFilterParams.includeBlanksInRange)
          return !0;
        break;
      case "blank":
        return !0;
      case "notBlank":
        return !1;
    }
    return !1;
  }
  evaluateNonNullValue(e, t, r) {
    const n = this.comparator(), i = e[0] != null ? n(e[0], t) : 0;
    switch (r.type) {
      case "equals":
        return i === 0;
      case "notEqual":
        return i !== 0;
      case "greaterThan":
        return i > 0;
      case "greaterThanOrEqual":
        return i >= 0;
      case "lessThan":
        return i < 0;
      case "lessThanOrEqual":
        return i <= 0;
      case "inRange": {
        const o = n(e[1], t);
        return this.scalarFilterParams.inRangeInclusive ? i >= 0 && o <= 0 : i > 0 && o < 0;
      }
      case "blank":
        return this.isBlank(t);
      case "notBlank":
        return !this.isBlank(t);
      default:
        return Se(
          'Unexpected type of filter "' + r.type + '", it looks like the filter was configured with incorrect Filter Options'
        ), !0;
    }
  }
}, NNe = 65, kNe = 67, VNe = 86, BNe = 68, GNe = 90, HNe = 89;
function NK(e) {
  return e.altKey || e.ctrlKey || e.metaKey ? !1 : e.key.length === 1;
}
function DT(e, t, r, n, i) {
  const o = n ? n.getColDef().suppressKeyboardEvent : void 0;
  if (!o)
    return !1;
  const a = e.addGridCommonParams({
    event: t,
    editing: i,
    column: n,
    node: r,
    data: r.data,
    colDef: n.getColDef()
  });
  return !!(o && o(a));
}
function zNe(e, t, r, n) {
  const i = n.getDefinition(), o = i && i.suppressHeaderKeyboardEvent;
  if (!Me(o))
    return !1;
  const a = e.addGridCommonParams({
    colDef: i,
    column: n,
    headerRowIndex: r,
    event: t
  });
  return !!o(a);
}
function $Ne(e) {
  const { keyCode: t } = e;
  let r;
  switch (t) {
    case NNe:
      r = ae.A;
      break;
    case kNe:
      r = ae.C;
      break;
    case VNe:
      r = ae.V;
      break;
    case BNe:
      r = ae.D;
      break;
    case GNe:
      r = ae.Z;
      break;
    case HNe:
      r = ae.Y;
      break;
    default:
      r = e.code;
  }
  return r;
}
function WNe(e, t = !1) {
  return e === ae.DELETE ? !0 : !t && e === ae.BACKSPACE ? cK() : !1;
}
var rd = class extends lc {
  constructor(e, t = "ag-text-field", r = "text") {
    super(e, t, r);
  }
  postConstruct() {
    super.postConstruct(), this.config.allowedCharPattern && this.preventDisallowedCharacters();
  }
  setValue(e, t) {
    return this.eInput.value !== e && (this.eInput.value = Me(e) ? e : ""), super.setValue(e, t);
  }
  /** Used to set an initial value into the input without necessarily setting `this.value` or triggering events (e.g. to set an invalid value) */
  setStartValue(e) {
    this.setValue(e, !0);
  }
  preventDisallowedCharacters() {
    const e = new RegExp(`[${this.config.allowedCharPattern}]`), t = (r) => {
      NK(r) && r.key && !e.test(r.key) && r.preventDefault();
    };
    this.addManagedListeners(this.eInput, {
      keydown: t,
      paste: (r) => {
        var i;
        const n = (i = r.clipboardData) == null ? void 0 : i.getData("text");
        n && n.split("").some((o) => !e.test(o)) && r.preventDefault();
      }
    });
  }
}, vw = {
  selector: "AG-INPUT-TEXT-FIELD",
  component: rd
}, AA = class extends rd {
  constructor(e) {
    super(e, "ag-number-field", "number");
  }
  postConstruct() {
    super.postConstruct(), this.addManagedListeners(this.eInput, {
      blur: () => {
        const i = parseFloat(this.eInput.value), o = isNaN(i) ? "" : this.normalizeValue(i.toString());
        this.value !== o && this.setValue(o);
      },
      wheel: this.onWheel.bind(this)
    }), this.eInput.step = "any";
    const { precision: e, min: t, max: r, step: n } = this.config;
    typeof e == "number" && this.setPrecision(e), typeof t == "number" && this.setMin(t), typeof r == "number" && this.setMax(r), typeof n == "number" && this.setStep(n);
  }
  onWheel(e) {
    this.gos.getActiveDomElement() === this.eInput && e.preventDefault();
  }
  normalizeValue(e) {
    if (e === "")
      return "";
    this.precision != null && (e = this.adjustPrecision(e));
    const t = parseFloat(e);
    return this.min != null && t < this.min ? e = this.min.toString() : this.max != null && t > this.max && (e = this.max.toString()), e;
  }
  adjustPrecision(e, t) {
    if (this.precision == null)
      return e;
    if (t) {
      const n = parseFloat(e).toFixed(this.precision);
      return parseFloat(n).toString();
    }
    const r = String(e).split(".");
    if (r.length > 1) {
      if (r[1].length <= this.precision)
        return e;
      if (this.precision > 0)
        return `${r[0]}.${r[1].slice(0, this.precision)}`;
    }
    return r[0];
  }
  setMin(e) {
    return this.min === e ? this : (this.min = e, Ls(this.eInput, "min", e), this);
  }
  setMax(e) {
    return this.max === e ? this : (this.max = e, Ls(this.eInput, "max", e), this);
  }
  setPrecision(e) {
    return this.precision = e, this;
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Ls(this.eInput, "step", e), this);
  }
  setValue(e, t) {
    return this.setValueOrInputValue(
      (r) => super.setValue(r, t),
      () => this,
      e
    );
  }
  setStartValue(e) {
    return this.setValueOrInputValue(
      (t) => super.setValue(t, !0),
      (t) => {
        this.eInput.value = t;
      },
      e
    );
  }
  setValueOrInputValue(e, t, r) {
    if (Me(r)) {
      let n = this.isScientificNotation(r);
      if (n && this.eInput.validity.valid)
        return e(r);
      if (!n) {
        r = this.adjustPrecision(r);
        const i = this.normalizeValue(r);
        n = r != i;
      }
      if (n)
        return t(r);
    }
    return e(r);
  }
  getValue() {
    if (!this.eInput.validity.valid)
      return;
    const e = this.eInput.value;
    return this.isScientificNotation(e) ? this.adjustPrecision(e, !0) : super.getValue();
  }
  isScientificNotation(e) {
    return typeof e == "string" && e.includes("e");
  }
}, jNe = {
  selector: "AG-INPUT-NUMBER-FIELD",
  component: AA
}, kK = [
  "equals",
  "notEqual",
  "greaterThan",
  "greaterThanOrEqual",
  "lessThan",
  "lessThanOrEqual",
  "inRange",
  "blank",
  "notBlank"
], IA = class {
  constructor(e, t, r) {
    this.localeService = e, this.optionsFactory = t, this.valueFormatter = r;
  }
  // used by:
  // 1) NumberFloatingFilter & TextFloatingFilter: Always, for both when editable and read only.
  // 2) DateFloatingFilter: Only when read only (as we show text rather than a date picker when read only)
  getModelAsString(e) {
    if (!e)
      return null;
    const t = e.operator != null, r = this.localeService.getLocaleTextFunc();
    if (t) {
      const n = e, o = (n.conditions ?? []).map((s) => this.getModelAsString(s)), a = n.operator === "AND" ? "andCondition" : "orCondition";
      return o.join(
        ` ${r(a, IK[a])} `
      );
    } else {
      if (e.type === "blank" || e.type === "notBlank")
        return r(e.type, e.type);
      {
        const n = e, i = this.optionsFactory.getCustomOption(n.type), { displayKey: o, displayName: a, numberOfInputs: s } = i || {};
        return o && a && s === 0 ? (r(o, a), a) : this.conditionToString(n, i);
      }
    }
  }
  updateParams(e) {
    this.optionsFactory = e.optionsFactory;
  }
  formatValue(e) {
    return this.valueFormatter ? this.valueFormatter(e ?? null) ?? "" : String(e);
  }
}, VK = class extends IA {
  conditionToString(e, t) {
    const { numberOfInputs: r } = t || {};
    return e.type == "inRange" || r === 2 ? `${this.formatValue(e.filter)}-${this.formatValue(e.filterTo)}` : e.filter != null ? this.formatValue(e.filter) : `${e.type}`;
  }
};
function AT(e) {
  const { allowedCharPattern: t } = e ?? {};
  return t ?? null;
}
var UNe = class extends OK {
  constructor() {
    super("numberFilter"), this.eValuesFrom = [], this.eValuesTo = [];
  }
  refresh(e) {
    return this.numberFilterParams.allowedCharPattern !== e.allowedCharPattern ? !1 : super.refresh(e);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: r, type: n } = e || {};
    return [this.processValue(t), this.processValue(r)].slice(0, this.getNumberOfInputs(n));
  }
  getDefaultDebounceMs() {
    return 500;
  }
  comparator() {
    return (e, t) => e === t ? 0 : e < t ? 1 : -1;
  }
  setParams(e) {
    this.numberFilterParams = e, super.setParams(e), this.filterModelFormatter = new VK(
      this.localeService,
      this.optionsFactory,
      this.numberFilterParams.numberFormatter
    );
  }
  getDefaultFilterOptions() {
    return kK;
  }
  setElementValue(e, t, r) {
    const n = !r && this.numberFilterParams.numberFormatter ? this.numberFilterParams.numberFormatter(t ?? null) : t;
    super.setElementValue(e, n);
  }
  createValueElement() {
    const e = AT(this.numberFilterParams), t = document.createElement("div");
    return t.classList.add("ag-filter-body"), Sa(t, "presentation"), this.createFromToElement(t, this.eValuesFrom, "from", e), this.createFromToElement(t, this.eValuesTo, "to", e), t;
  }
  createFromToElement(e, t, r, n) {
    const i = this.createManagedBean(
      n ? new rd({ allowedCharPattern: n }) : new AA()
    );
    i.addCssClass(`ag-filter-${r}`), i.addCssClass("ag-filter-filter"), t.push(i), e.appendChild(i.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (r, n, i, o) => {
      n < o && t.push(this.processValue(this.stringToFloat(r.getValue())));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getFilterType() {
    return "number";
  }
  processValue(e) {
    return e == null || isNaN(e) ? null : e;
  }
  stringToFloat(e) {
    if (typeof e == "number")
      return e;
    let t = Sc(e);
    return t != null && t.trim() === "" && (t = null), this.numberFilterParams.numberParser ? this.numberFilterParams.numberParser(t) : t == null || t.trim() === "-" ? null : parseFloat(t);
  }
  createCondition(e) {
    const t = this.getConditionType(e), r = {
      filterType: this.getFilterType(),
      type: t
    }, n = this.getValues(e);
    return n.length > 0 && (r.filter = n[0]), n.length > 1 && (r.filterTo = n[1]), r;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
  hasInvalidInputs() {
    let e = !1;
    return this.forEachInput((t) => {
      if (!t.getInputElement().validity.valid) {
        e = !0;
        return;
      }
    }), e;
  }
}, BK = [
  "contains",
  "notContains",
  "equals",
  "notEqual",
  "startsWith",
  "endsWith",
  "blank",
  "notBlank"
], GK = class extends IA {
  conditionToString(e, t) {
    const { numberOfInputs: r } = t || {};
    return e.type == "inRange" || r === 2 ? `${e.filter}-${e.filterTo}` : e.filter != null ? `${e.filter}` : `${e.type}`;
  }
};
function HK(e) {
  const t = e && e.trim();
  return t === "" ? e : t;
}
var KNe = class extends LK {
  constructor() {
    super("textFilter"), this.defaultFormatter = (e) => e, this.defaultLowercaseFormatter = (e) => e == null ? null : e.toString().toLowerCase(), this.defaultMatcher = ({ filterOption: e, value: t, filterText: r }) => {
      if (r == null)
        return !1;
      switch (e) {
        case "contains":
          return t.indexOf(r) >= 0;
        case "notContains":
          return t.indexOf(r) < 0;
        case "equals":
          return t === r;
        case "notEqual":
          return t != r;
        case "startsWith":
          return t.indexOf(r) === 0;
        case "endsWith": {
          const n = t.lastIndexOf(r);
          return n >= 0 && n === t.length - r.length;
        }
        default:
          return !1;
      }
    }, this.eValuesFrom = [], this.eValuesTo = [];
  }
  getDefaultDebounceMs() {
    return 500;
  }
  setParams(e) {
    this.textFilterParams = e, super.setParams(e), this.matcher = this.getTextMatcher(), this.formatter = this.textFilterParams.textFormatter || (this.textFilterParams.caseSensitive ? this.defaultFormatter : this.defaultLowercaseFormatter), this.filterModelFormatter = new GK(this.localeService, this.optionsFactory);
  }
  getTextMatcher() {
    const e = this.textFilterParams.textCustomComparator;
    return e ? (Se("textCustomComparator is deprecated, use textMatcher instead."), ({ filterOption: t, value: r, filterText: n }) => e(t, r, n)) : this.textFilterParams.textMatcher || this.defaultMatcher;
  }
  createCondition(e) {
    const t = this.getConditionType(e), r = {
      filterType: this.getFilterType(),
      type: t
    }, n = this.getValuesWithSideEffects(e, !0);
    return n.length > 0 && (r.filter = n[0]), n.length > 1 && (r.filterTo = n[1]), r;
  }
  getFilterType() {
    return "text";
  }
  areSimpleModelsEqual(e, t) {
    return e.filter === t.filter && e.filterTo === t.filterTo && e.type === t.type;
  }
  getInputs(e) {
    return e >= this.eValuesFrom.length ? [null, null] : [this.eValuesFrom[e], this.eValuesTo[e]];
  }
  getValues(e) {
    return this.getValuesWithSideEffects(e, !1);
  }
  getValuesWithSideEffects(e, t) {
    const r = [];
    return this.forEachPositionInput(e, (n, i, o, a) => {
      if (i < a) {
        let s = Sc(n.getValue());
        t && this.textFilterParams.trimInput && (s = HK(s) ?? null, n.setValue(s, !0)), r.push(s);
      }
    }), r;
  }
  getDefaultFilterOptions() {
    return BK;
  }
  createValueElement() {
    const e = document.createElement("div");
    return e.classList.add("ag-filter-body"), Sa(e, "presentation"), this.createFromToElement(e, this.eValuesFrom, "from"), this.createFromToElement(e, this.eValuesTo, "to"), e;
  }
  createFromToElement(e, t, r) {
    const n = this.createManagedBean(new rd());
    n.addCssClass(`ag-filter-${r}`), n.addCssClass("ag-filter-filter"), t.push(n), e.appendChild(n.getGui());
  }
  removeValueElements(e, t) {
    this.removeComponents(this.eValuesFrom, e, t), this.removeComponents(this.eValuesTo, e, t);
  }
  mapValuesFromModel(e) {
    const { filter: t, filterTo: r, type: n } = e || {};
    return [t || null, r || null].slice(0, this.getNumberOfInputs(n));
  }
  evaluateNullValue(e) {
    return e ? ["notEqual", "notContains", "blank"].indexOf(e) >= 0 : !1;
  }
  evaluateNonNullValue(e, t, r, n) {
    const i = e.map((h) => this.formatter(h)) || [], o = this.formatter(t), { api: a, colDef: s, column: l, context: u, textFormatter: c } = this.textFilterParams;
    if (r.type === "blank")
      return this.isBlank(t);
    if (r.type === "notBlank")
      return !this.isBlank(t);
    const d = {
      api: a,
      colDef: s,
      column: l,
      context: u,
      node: n.node,
      data: n.data,
      filterOption: r.type,
      value: o,
      textFormatter: c
    };
    return i.some((h) => this.matcher({ ...d, filterText: h }));
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
};
function zK(e) {
  if (typeof e == "number")
    return e;
  if (typeof e == "string") {
    const t = parseInt(e);
    return isNaN(t) ? void 0 : t;
  }
}
function Aa(e, t = Number.MAX_VALUE) {
  return (r) => {
    const n = zK(r);
    if (!(n == null || n < e || n > t))
      return n;
  };
}
function hg(e, t) {
  return e.toString().padStart(t, "0");
}
function YNe(e, t) {
  const r = [];
  for (let n = e; n <= t; n++)
    r.push(n);
  return r;
}
function qNe(e, t, r) {
  return typeof e != "number" ? "" : e.toString().replace(".", r).replace(/(\d)(?=(\d{3})+(?!\d))/g, `$1${t}`);
}
function Io(e, t = !0, r = "-") {
  if (!e)
    return null;
  let n = [e.getFullYear(), e.getMonth() + 1, e.getDate()].map((i) => hg(i, 2)).join(r);
  return t && (n += " " + [e.getHours(), e.getMinutes(), e.getSeconds()].map((i) => hg(i, 2)).join(":")), n;
}
var Qx = (e) => {
  if (e > 3 && e < 21)
    return "th";
  switch (e % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
  }
  return "th";
};
function fg(e, t = "YYYY-MM-DD") {
  const r = hg(e.getFullYear(), 4), n = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ], i = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], o = {
    YYYY: () => r.slice(r.length - 4, r.length),
    YY: () => r.slice(r.length - 2, r.length),
    Y: () => `${e.getFullYear()}`,
    MMMM: () => n[e.getMonth()],
    MMM: () => n[e.getMonth()].slice(0, 3),
    MM: () => hg(e.getMonth() + 1, 2),
    Mo: () => `${e.getMonth() + 1}${Qx(e.getMonth() + 1)}`,
    M: () => `${e.getMonth() + 1}`,
    Do: () => `${e.getDate()}${Qx(e.getDate())}`,
    DD: () => hg(e.getDate(), 2),
    D: () => `${e.getDate()}`,
    dddd: () => i[e.getDay()],
    ddd: () => i[e.getDay()].slice(0, 3),
    dd: () => i[e.getDay()].slice(0, 2),
    do: () => `${e.getDay()}${Qx(e.getDay())}`,
    d: () => `${e.getDay()}`
  }, a = new RegExp(Object.keys(o).join("|"), "g");
  return t.replace(a, (s) => s in o ? o[s]() : s);
}
function Oi(e) {
  if (!e)
    return null;
  const [t, r] = e.split(" ");
  if (!t)
    return null;
  const n = t.split("-").map((d) => parseInt(d, 10));
  if (n.filter((d) => !isNaN(d)).length !== 3)
    return null;
  const [i, o, a] = n, s = new Date(i, o - 1, a);
  if (s.getFullYear() !== i || s.getMonth() !== o - 1 || s.getDate() !== a)
    return null;
  if (!r || r === "00:00:00")
    return s;
  const [l, u, c] = r.split(":").map((d) => parseInt(d, 10));
  return l >= 0 && l < 24 && s.setHours(l), u >= 0 && u < 60 && s.setMinutes(u), c >= 0 && c < 60 && s.setSeconds(c), s;
}
var $K = class {
  constructor(e, t, r, n, i) {
    this.alive = !0, this.context = e, this.eParent = n, t.getDateCompDetails(r).newAgStackInstance().then((s) => {
      if (!this.alive) {
        e.destroyBean(s);
        return;
      }
      this.dateComp = s, s && (n.appendChild(s.getGui()), s.afterGuiAttached && s.afterGuiAttached(), this.tempValue && s.setDate(this.tempValue), this.disabled != null && this.setDateCompDisabled(this.disabled), i == null || i(this));
    });
  }
  destroy() {
    this.alive = !1, this.dateComp = this.context.destroyBean(this.dateComp);
  }
  getDate() {
    return this.dateComp ? this.dateComp.getDate() : this.tempValue;
  }
  setDate(e) {
    this.dateComp ? this.dateComp.setDate(e) : this.tempValue = e;
  }
  setDisabled(e) {
    this.dateComp ? this.setDateCompDisabled(e) : this.disabled = e;
  }
  setDisplayed(e) {
    jr(this.eParent, e);
  }
  setInputPlaceholder(e) {
    this.dateComp && this.dateComp.setInputPlaceholder && this.dateComp.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.dateComp && this.dateComp.setInputAriaLabel && this.dateComp.setInputAriaLabel(e);
  }
  afterGuiAttached(e) {
    this.dateComp && typeof this.dateComp.afterGuiAttached == "function" && this.dateComp.afterGuiAttached(e);
  }
  updateParams(e) {
    var r, n;
    let t = !1;
    (r = this.dateComp) != null && r.refresh && typeof this.dateComp.refresh == "function" && this.dateComp.refresh(e) !== null && (t = !0), !t && ((n = this.dateComp) != null && n.onParamsUpdated) && typeof this.dateComp.onParamsUpdated == "function" && this.dateComp.onParamsUpdated(e) !== null && Se("Custom date component method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
  }
  setDateCompDisabled(e) {
    this.dateComp != null && this.dateComp.setDisabled != null && this.dateComp.setDisabled(e);
  }
}, WK = [
  "equals",
  "notEqual",
  "lessThan",
  "greaterThan",
  "inRange",
  "blank",
  "notBlank"
], jK = class extends IA {
  constructor(e, t, r) {
    super(t, r), this.dateFilterParams = e;
  }
  conditionToString(e, t) {
    const { type: r } = e, { numberOfInputs: n } = t || {}, i = r == "inRange" || n === 2, o = Oi(e.dateFrom), a = Oi(e.dateTo), s = this.dateFilterParams.inRangeFloatingFilterDateFormat;
    if (i) {
      const l = o !== null ? fg(o, s) : "null", u = a !== null ? fg(a, s) : "null";
      return `${l}-${u}`;
    }
    return o != null ? fg(o, s) : `${r}`;
  }
  updateParams(e) {
    super.updateParams(e), this.dateFilterParams = e.dateFilterParams;
  }
}, LG = 1e3, OG = 1 / 0, ZNe = class extends OK {
  constructor() {
    super("dateFilter"), this.eConditionPanelsFrom = [], this.eConditionPanelsTo = [], this.dateConditionFromComps = [], this.dateConditionToComps = [], this.minValidYear = LG, this.maxValidYear = OG, this.minValidDate = null, this.maxValidDate = null;
  }
  wireBeans(e) {
    super.wireBeans(e), this.context = e.context, this.userComponentFactory = e.userComponentFactory;
  }
  afterGuiAttached(e) {
    super.afterGuiAttached(e), this.dateConditionFromComps[0].afterGuiAttached(e);
  }
  mapValuesFromModel(e) {
    const { dateFrom: t, dateTo: r, type: n } = e || {};
    return [
      t && Oi(t) || null,
      r && Oi(r) || null
    ].slice(0, this.getNumberOfInputs(n));
  }
  comparator() {
    return this.dateFilterParams.comparator ? this.dateFilterParams.comparator : this.defaultComparator.bind(this);
  }
  defaultComparator(e, t) {
    const r = t;
    return t == null || r < e ? -1 : r > e ? 1 : 0;
  }
  setParams(e) {
    this.dateFilterParams = e, super.setParams(e);
    const t = (r, n) => {
      if (e[r] != null)
        if (isNaN(e[r]))
          Se(`DateFilter ${r} is not a number`);
        else
          return e[r] == null ? n : Number(e[r]);
      return n;
    };
    this.minValidYear = t("minValidYear", LG), this.maxValidYear = t("maxValidYear", OG), this.minValidYear > this.maxValidYear && Se("DateFilter minValidYear should be <= maxValidYear"), e.minValidDate ? this.minValidDate = e.minValidDate instanceof Date ? e.minValidDate : Oi(e.minValidDate) : this.minValidDate = null, e.maxValidDate ? this.maxValidDate = e.maxValidDate instanceof Date ? e.maxValidDate : Oi(e.maxValidDate) : this.maxValidDate = null, this.minValidDate && this.maxValidDate && this.minValidDate > this.maxValidDate && Se("DateFilter minValidDate should be <= maxValidDate"), this.filterModelFormatter = new jK(
      this.dateFilterParams,
      this.localeService,
      this.optionsFactory
    );
  }
  createDateCompWrapper(e) {
    const t = new $K(
      this.context,
      this.userComponentFactory,
      {
        onDateChanged: () => this.onUiChanged(),
        filterParams: this.dateFilterParams
      },
      e
    );
    return this.addDestroyFunc(() => t.destroy()), t;
  }
  setElementValue(e, t) {
    e.setDate(t);
  }
  setElementDisplayed(e, t) {
    e.setDisplayed(t);
  }
  setElementDisabled(e, t) {
    e.setDisabled(t);
  }
  getDefaultFilterOptions() {
    return WK;
  }
  createValueElement() {
    const t = this.gos.getDocument().createElement("div");
    return t.classList.add("ag-filter-body"), this.createFromToElement(t, this.eConditionPanelsFrom, this.dateConditionFromComps, "from"), this.createFromToElement(t, this.eConditionPanelsTo, this.dateConditionToComps, "to"), t;
  }
  createFromToElement(e, t, r, n) {
    const o = this.gos.getDocument().createElement("div");
    o.classList.add(`ag-filter-${n}`), o.classList.add(`ag-filter-date-${n}`), t.push(o), e.appendChild(o), r.push(this.createDateCompWrapper(o));
  }
  removeValueElements(e, t) {
    this.removeDateComps(this.dateConditionFromComps, e, t), this.removeDateComps(this.dateConditionToComps, e, t), this.removeItems(this.eConditionPanelsFrom, e, t), this.removeItems(this.eConditionPanelsTo, e, t);
  }
  removeDateComps(e, t, r) {
    this.removeItems(e, t, r).forEach((i) => i.destroy());
  }
  isValidDateValue(e) {
    if (e === null)
      return !1;
    if (this.minValidDate) {
      if (e < this.minValidDate)
        return !1;
    } else if (e.getUTCFullYear() < this.minValidYear)
      return !1;
    if (this.maxValidDate) {
      if (e > this.maxValidDate)
        return !1;
    } else if (e.getUTCFullYear() > this.maxValidYear)
      return !1;
    return !0;
  }
  isConditionUiComplete(e) {
    if (!super.isConditionUiComplete(e))
      return !1;
    let t = !0;
    return this.forEachInput((r, n, i, o) => {
      i !== e || !t || n >= o || (t = t && this.isValidDateValue(r.getDate()));
    }), t;
  }
  areSimpleModelsEqual(e, t) {
    return e.dateFrom === t.dateFrom && e.dateTo === t.dateTo && e.type === t.type;
  }
  getFilterType() {
    return "date";
  }
  createCondition(e) {
    const t = this.getConditionType(e), r = {}, n = this.getValues(e);
    return n.length > 0 && (r.dateFrom = Io(n[0])), n.length > 1 && (r.dateTo = Io(n[1])), {
      dateFrom: null,
      dateTo: null,
      filterType: this.getFilterType(),
      type: t,
      ...r
    };
  }
  resetPlaceholder() {
    const e = this.localeService.getLocaleTextFunc(), t = this.translate("dateFormatOoo"), r = e("ariaFilterValue", "Filter Value");
    this.forEachInput((n) => {
      n.setInputPlaceholder(t), n.setInputAriaLabel(r);
    });
  }
  getInputs(e) {
    return e >= this.dateConditionFromComps.length ? [null, null] : [this.dateConditionFromComps[e], this.dateConditionToComps[e]];
  }
  getValues(e) {
    const t = [];
    return this.forEachPositionInput(e, (r, n, i, o) => {
      n < o && t.push(r.getDate());
    }), t;
  }
  translate(e) {
    return e === "lessThan" ? super.translate("before") : e === "greaterThan" ? super.translate("after") : super.translate(e);
  }
  getModelAsString(e) {
    return this.filterModelFormatter.getModelAsString(e) ?? "";
  }
}, FA = class extends he {
  constructor(e, t, r, n) {
    super(), this.columnOrGroup = e, this.columnOrGroup = e, this.eCell = t, this.ariaEl = this.eCell.querySelector("[role=columnheader]") || this.eCell, this.colsSpanning = n, this.beans = r;
  }
  setColsSpanning(e) {
    this.colsSpanning = e, this.onLeftChanged();
  }
  getColumnOrGroup() {
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? Jt(this.colsSpanning) : this.columnOrGroup;
  }
  postConstruct() {
    const e = this.onLeftChanged.bind(this);
    this.addManagedListeners(this.columnOrGroup, { leftChanged: e }), this.setLeftFirstTime(), this.addManagedEventListeners({ displayedColumnsWidthChanged: e }), this.addManagedPropertyListener("domLayout", e);
  }
  setLeftFirstTime() {
    const e = this.beans.gos.get("suppressColumnMoveAnimation"), t = Me(this.columnOrGroup.getOldLeft());
    this.beans.columnAnimationService.isActive() && t && !e ? this.animateInLeft() : this.onLeftChanged();
  }
  animateInLeft() {
    const e = this.getColumnOrGroup(), t = e.getLeft(), r = e.getOldLeft(), n = this.modifyLeftForPrintLayout(e, r), i = this.modifyLeftForPrintLayout(e, t);
    this.setLeft(n), this.actualLeft = i, this.beans.columnAnimationService.executeNextVMTurn(() => {
      this.actualLeft === i && this.setLeft(i);
    });
  }
  onLeftChanged() {
    const e = this.getColumnOrGroup(), t = e.getLeft();
    this.actualLeft = this.modifyLeftForPrintLayout(e, t), this.setLeft(this.actualLeft);
  }
  modifyLeftForPrintLayout(e, t) {
    if (!this.beans.gos.isDomLayout("print") || e.getPinned() === "left")
      return t;
    const n = this.beans.visibleColsService.getColsLeftWidth();
    if (e.getPinned() === "right") {
      const i = this.beans.visibleColsService.getBodyContainerWidth();
      return n + i + t;
    }
    return n + t;
  }
  setLeft(e) {
    if (Me(e) && (this.eCell.style.left = `${e}px`), an(this.columnOrGroup)) {
      const t = this.columnOrGroup.getLeafColumns();
      if (!t.length)
        return;
      t.length > 1 && yOe(this.ariaEl, t.length);
    }
  }
}, XNe = "ag-column-first", QNe = "ag-column-last";
function UK(e, t, r, n) {
  return Zt(e) ? [] : eke(e.headerClass, e, t, r, n);
}
function KK(e, t, r) {
  e.addOrRemoveCssClass(XNe, r.isColAtEdge(t, "first")), e.addOrRemoveCssClass(QNe, r.isColAtEdge(t, "last"));
}
function JNe(e, t, r, n) {
  return t.addGridCommonParams({
    // bad naming, as colDef here can be a group or a column,
    // however most people won't appreciate the difference,
    // so keeping it as colDef to avoid confusion.
    colDef: e,
    column: r,
    columnGroup: n
  });
}
function eke(e, t, r, n, i) {
  if (Zt(e))
    return [];
  let o;
  if (typeof e == "function") {
    const a = JNe(t, r, n, i);
    o = e(a);
  } else
    o = e;
  return typeof o == "string" ? [o] : Array.isArray(o) ? [...o] : [];
}
var tke = 0, YK = class qK extends he {
  constructor(t, r, n) {
    super(), this.resizeToggleTimeout = 0, this.resizeMultiplier = 1, this.resizeFeature = null, this.lastFocusEvent = null, this.dragSource = null, this.columnGroupChild = t, this.parentRowCtrl = n, this.beans = r, this.instanceId = t.getUniqueId() + "-" + tke++;
  }
  wireBeans(t) {
    this.pinnedWidthService = t.pinnedWidthService, this.focusService = t.focusService, this.userComponentFactory = t.userComponentFactory, this.ctrlsService = t.ctrlsService, this.dragAndDropService = t.dragAndDropService, this.menuService = t.menuService;
  }
  postConstruct() {
    this.addManagedPropertyListeners(["suppressHeaderFocus"], () => this.refreshTabIndex());
  }
  shouldStopEventPropagation(t) {
    const { headerRowIndex: r, column: n } = this.focusService.getFocusedHeader();
    return zNe(this.gos, t, r, n);
  }
  getWrapperHasFocus() {
    return this.gos.getActiveDomElement() === this.eGui;
  }
  setGui(t) {
    this.eGui = t, this.addDomData(), this.addManagedListeners(this.beans.eventService, {
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    }), this.addManagedElementListeners(this.eGui, {
      focus: this.onGuiFocus.bind(this)
    }), this.onDisplayedColumnsChanged(), this.refreshTabIndex();
  }
  onGuiFocus() {
    const t = {
      type: "headerFocused",
      column: this.column
    };
    this.eventService.dispatchEvent(t);
  }
  onDisplayedColumnsChanged() {
    !this.comp || !this.column || (this.refreshFirstAndLastStyles(), this.refreshAriaColIndex());
  }
  refreshFirstAndLastStyles() {
    const { comp: t, column: r, beans: n } = this;
    KK(t, r, n.visibleColsService);
  }
  refreshAriaColIndex() {
    const { beans: t, column: r } = this, n = t.visibleColsService.getAriaColIndex(r);
    sK(this.eGui, n);
  }
  addResizeAndMoveKeyboardListeners() {
    this.resizeFeature && this.addManagedListeners(this.eGui, {
      keydown: this.onGuiKeyDown.bind(this),
      keyup: this.onGuiKeyUp.bind(this)
    });
  }
  refreshTabIndex() {
    this.gos.get("suppressHeaderFocus") ? this.eGui.removeAttribute("tabindex") : this.eGui.setAttribute("tabindex", "-1");
  }
  onGuiKeyDown(t) {
    var a;
    const r = this.gos.getActiveDomElement(), n = t.key === ae.LEFT || t.key === ae.RIGHT;
    if (this.isResizing && (t.preventDefault(), t.stopImmediatePropagation()), // if elements within the header are focused, we don't process the event
    r !== this.eGui || // if shiftKey and altKey are not pressed, it's cell navigation so we don't process the event
    !t.shiftKey && !t.altKey || ((this.isResizing || n) && (t.preventDefault(), t.stopImmediatePropagation()), !n))
      return;
    const i = t.key === ae.LEFT !== this.gos.get("enableRtl"), o = TK[i ? "Left" : "Right"];
    if (t.altKey) {
      this.isResizing = !0, this.resizeMultiplier += 1;
      const s = this.getViewportAdjustedResizeDiff(t);
      this.resizeHeader(s, t.shiftKey), (a = this.resizeFeature) == null || a.toggleColumnResizing(!0);
    } else
      this.moveHeader(o);
  }
  getViewportAdjustedResizeDiff(t) {
    let r = this.getResizeDiff(t);
    if (this.column.getPinned()) {
      const i = this.pinnedWidthService.getPinnedLeftWidth(), o = this.pinnedWidthService.getPinnedRightWidth(), a = Yv(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (i + o + r > a)
        if (a > i + o)
          r = a - i - o;
        else
          return 0;
    }
    return r;
  }
  getResizeDiff(t) {
    let r = t.key === ae.LEFT !== this.gos.get("enableRtl");
    const n = this.column.getPinned(), i = this.gos.get("enableRtl");
    return n && i !== (n === "right") && (r = !r), (r ? -1 : 1) * this.resizeMultiplier;
  }
  onGuiKeyUp() {
    this.isResizing && (this.resizeToggleTimeout && (window.clearTimeout(this.resizeToggleTimeout), this.resizeToggleTimeout = 0), this.isResizing = !1, this.resizeMultiplier = 1, this.resizeToggleTimeout = window.setTimeout(() => {
      var t;
      (t = this.resizeFeature) == null || t.toggleColumnResizing(!1);
    }, 150));
  }
  handleKeyDown(t) {
    const r = this.getWrapperHasFocus();
    switch (t.key) {
      case ae.PAGE_DOWN:
      case ae.PAGE_UP:
      case ae.PAGE_HOME:
      case ae.PAGE_END:
        r && t.preventDefault();
    }
  }
  addDomData() {
    const t = qK.DOM_DATA_KEY_HEADER_CTRL;
    this.gos.setDomData(this.eGui, t, this), this.addDestroyFunc(() => this.gos.setDomData(this.eGui, t, null));
  }
  getGui() {
    return this.eGui;
  }
  focus(t) {
    return this.eGui ? (this.lastFocusEvent = t || null, this.eGui.focus(), !0) : !1;
  }
  getRowIndex() {
    return this.parentRowCtrl.getRowIndex();
  }
  getParentRowCtrl() {
    return this.parentRowCtrl;
  }
  getPinned() {
    return this.parentRowCtrl.getPinned();
  }
  getInstanceId() {
    return this.instanceId;
  }
  getColumnGroupChild() {
    return this.columnGroupChild;
  }
  removeDragSource() {
    this.dragSource && (this.dragAndDropService.removeDragSource(this.dragSource), this.dragSource = null);
  }
  handleContextMenuMouseEvent(t, r, n) {
    const i = t ?? r;
    this.gos.get("preventDefaultOnContextMenu") && i.preventDefault();
    const o = Zl(n) ? n : void 0;
    this.menuService.isHeaderContextMenuEnabled(o) && this.menuService.showHeaderContextMenu(o, t, r), this.dispatchColumnMouseEvent("columnHeaderContextMenu", n);
  }
  dispatchColumnMouseEvent(t, r) {
    const n = {
      type: t,
      column: r
    };
    this.eventService.dispatchEvent(n);
  }
  destroy() {
    super.destroy(), this.removeDragSource(), this.comp = null, this.column = null, this.resizeFeature = null, this.lastFocusEvent = null, this.columnGroupChild = null, this.parentRowCtrl = null, this.eGui = null;
  }
};
YK.DOM_DATA_KEY_HEADER_CTRL = "headerCtrl";
var mw = YK, LA = class extends he {
  wireBeans(e) {
    this.columnHoverService = e.columnHoverService;
  }
  constructor(e, t) {
    super(), this.columns = e, this.element = t;
  }
  postConstruct() {
    this.gos.get("columnHoverHighlight") && this.addMouseHoverListeners();
  }
  addMouseHoverListeners() {
    this.addManagedListeners(this.element, {
      mouseout: this.onMouseOut.bind(this),
      mouseover: this.onMouseOver.bind(this)
    });
  }
  onMouseOut() {
    this.columnHoverService.clearMouseOver();
  }
  onMouseOver() {
    this.columnHoverService.setMouseOver(this.columns);
  }
}, rke = class extends mw {
  constructor(e, t, r) {
    super(e, t, r), this.iconCreated = !1, this.column = e;
  }
  setComp(e, t, r, n) {
    this.comp = e, this.eButtonShowMainFilter = r, this.eFloatingFilterBody = n, this.setGui(t), this.setupActive(), this.setupWidth(), this.setupLeft(), this.setupHover(), this.setupFocus(), this.setupAria(), this.setupFilterButton(), this.setupUserComp(), this.setupSyncWithFilter(), this.setupUi(), this.addManagedElementListeners(this.eButtonShowMainFilter, { click: this.showParentFilter.bind(this) }), this.setupFilterChangedListener(), this.addManagedListeners(this.column, { colDefChanged: this.onColDefChanged.bind(this) });
  }
  // empty abstract method
  resizeHeader() {
  }
  // empty abstract method
  moveHeader() {
  }
  setupActive() {
    const e = this.column.getColDef(), t = !!e.filter, r = !!e.floatingFilter;
    this.active = t && r;
  }
  setupUi() {
    if (this.comp.setButtonWrapperDisplayed(!this.suppressFilterButton && this.active), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-full-body", this.suppressFilterButton), this.comp.addOrRemoveBodyCssClass("ag-floating-filter-body", !this.suppressFilterButton), !this.active || this.iconCreated)
      return;
    const e = to("filter", this.gos, this.column);
    e && (this.iconCreated = !0, this.eButtonShowMainFilter.appendChild(e));
  }
  setupFocus() {
    this.createManagedBean(
      new td(this.eGui, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    );
  }
  setupAria() {
    const e = this.localeService.getLocaleTextFunc();
    $h(this.eButtonShowMainFilter, e("ariaFilterMenuOpen", "Open Filter Menu"));
  }
  onTabKeyDown(e) {
    if (this.gos.getActiveDomElement() === this.eGui)
      return;
    const n = this.focusService.findNextFocusableElement(this.eGui, null, e.shiftKey);
    if (n) {
      this.beans.headerNavigationService.scrollToColumn(this.column), e.preventDefault(), n.focus();
      return;
    }
    const i = this.findNextColumnWithFloatingFilter(e.shiftKey);
    i && this.focusService.focusHeaderPosition({
      headerPosition: {
        headerRowIndex: this.getParentRowCtrl().getRowIndex(),
        column: i
      },
      event: e
    }) && e.preventDefault();
  }
  findNextColumnWithFloatingFilter(e) {
    const t = this.beans.visibleColsService;
    let r = this.column;
    do
      if (r = e ? t.getColBefore(r) : t.getColAfter(r), !r)
        break;
    while (!r.getColDef().filter || !r.getColDef().floatingFilter);
    return r;
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    switch (e.key) {
      case ae.UP:
      case ae.DOWN:
        t || e.preventDefault();
      case ae.LEFT:
      case ae.RIGHT:
        if (t)
          return;
        e.stopPropagation();
      case ae.ENTER:
        t && this.focusService.focusInto(this.eGui) && e.preventDefault();
        break;
      case ae.ESCAPE:
        t || this.eGui.focus();
    }
  }
  onFocusIn(e) {
    if (this.eGui.contains(e.relatedTarget))
      return;
    const r = !!e.relatedTarget && !e.relatedTarget.classList.contains("ag-floating-filter"), n = !!e.relatedTarget && wh(e.relatedTarget, "ag-floating-filter");
    if (r && n && e.target === this.eGui) {
      const o = this.lastFocusEvent, a = !!(o && o.key === ae.TAB);
      if (o && a) {
        const s = o.shiftKey;
        this.focusService.focusInto(this.eGui, s);
      }
    }
    const i = this.getRowIndex();
    this.beans.focusService.setFocusedHeader(i, this.column);
  }
  setupHover() {
    this.createManagedBean(new LA([this.column], this.eGui));
    const e = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const t = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", t);
    };
    this.addManagedEventListeners({ columnHoverChanged: e }), e();
  }
  setupLeft() {
    const e = new FA(this.column, this.eGui, this.beans);
    this.createManagedBean(e);
  }
  setupFilterButton() {
    this.suppressFilterButton = !this.menuService.isFloatingFilterButtonEnabled(this.column), this.highlightFilterButtonWhenActive = !this.menuService.isLegacyMenuEnabled();
  }
  setupUserComp() {
    var t;
    if (!this.active)
      return;
    const e = (t = this.beans.filterManager) == null ? void 0 : t.getFloatingFilterCompDetails(
      this.column,
      () => this.showParentFilter()
    );
    e && this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setCompDetails(e);
  }
  showParentFilter() {
    const e = this.suppressFilterButton ? this.eFloatingFilterBody : this.eButtonShowMainFilter;
    this.menuService.showFilterMenu({
      column: this.column,
      buttonElement: e,
      containerType: "floatingFilter",
      positionBy: "button"
    });
  }
  setupSyncWithFilter() {
    if (!this.active)
      return;
    const { filterManager: e } = this.beans, t = (r) => {
      if ((r == null ? void 0 : r.source) === "filterDestroyed" && !this.isAlive())
        return;
      const n = this.comp.getFloatingFilterComp();
      n && n.then((i) => {
        if (i) {
          const o = e == null ? void 0 : e.getCurrentFloatingFilterParentModel(this.column), a = r ? {
            // event can have additional params like `afterDataChange` which need to be passed through
            ...r,
            columns: r.columns ?? [],
            source: r.source === "api" ? "api" : "columnFilter"
          } : null;
          i.onParentModelChanged(o, a);
        }
      });
    };
    [this.destroySyncListener] = this.addManagedListeners(this.column, { filterChanged: t }), e != null && e.isFilterActive(this.column) && t(null);
  }
  setupWidth() {
    const e = () => {
      const t = `${this.column.getActualWidth()}px`;
      this.comp.setWidth(t);
    };
    this.addManagedListeners(this.column, { widthChanged: e }), e();
  }
  setupFilterChangedListener() {
    this.active && ([this.destroyFilterChangedListener] = this.addManagedListeners(this.column, {
      filterChanged: this.updateFilterButton.bind(this)
    }), this.updateFilterButton());
  }
  updateFilterButton() {
    var e;
    if (!this.suppressFilterButton && this.comp) {
      const t = !!((e = this.beans.filterManager) != null && e.isFilterAllowed(this.column));
      this.comp.setButtonWrapperDisplayed(t), this.highlightFilterButtonWhenActive && t && this.eButtonShowMainFilter.classList.toggle("ag-filter-active", this.column.isFilterActive());
    }
  }
  onColDefChanged() {
    var i;
    const e = this.active;
    this.setupActive();
    const t = !e && this.active;
    e && !this.active && (this.destroySyncListener(), this.destroyFilterChangedListener());
    const r = this.active ? (i = this.beans.filterManager) == null ? void 0 : i.getFloatingFilterCompDetails(this.column, () => this.showParentFilter()) : null, n = this.comp.getFloatingFilterComp();
    !n || !r ? this.updateCompDetails(r, t) : n.then((o) => {
      var a;
      !o || (a = this.beans.filterManager) != null && a.areFilterCompsDifferent(this.userCompDetails ?? null, r) ? this.updateCompDetails(r, t) : this.updateFloatingFilterParams(r);
    });
  }
  updateCompDetails(e, t) {
    this.isAlive() && (this.setCompDetails(e), this.setupFilterButton(), this.setupUi(), t && (this.setupSyncWithFilter(), this.setupFilterChangedListener()));
  }
  updateFloatingFilterParams(e) {
    var r;
    if (!e)
      return;
    const t = e.params;
    (r = this.comp.getFloatingFilterComp()) == null || r.then((n) => {
      let i = !1;
      n != null && n.refresh && typeof n.refresh == "function" && n.refresh(t) !== null && (i = !0), !i && (n != null && n.onParamsUpdated) && typeof n.onParamsUpdated == "function" && n.onParamsUpdated(t) !== null && Se("Custom floating filter method 'onParamsUpdated' is deprecated. Use 'refresh' instead.");
    });
  }
  destroy() {
    super.destroy(), this.eButtonShowMainFilter = null, this.eFloatingFilterBody = null, this.userCompDetails = null, this.destroySyncListener = null, this.destroyFilterChangedListener = null;
  }
}, Et = "32.0.1";
function nke(e) {
  var t, r;
  return !!((t = e.filterManager) != null && t.isColumnFilterPresent()) || !!((r = e.filterManager) != null && r.isAggregateFilterPresent());
}
function ike(e, t, r) {
  var n;
  return (n = e.filterManager) == null ? void 0 : n.getFilterInstance(t, r);
}
function oke(e, t) {
  var r;
  return ((r = e.filterManager) == null ? void 0 : r.getColumnFilterInstance(t)) ?? Promise.resolve(void 0);
}
function ake(e, t) {
  var n;
  const r = e.columnModel.getColDefCol(t);
  if (r)
    return (n = e.filterManager) == null ? void 0 : n.destroyFilter(r, "api");
}
function ske(e, t) {
  e.frameworkOverrides.wrapIncoming(() => {
    var r;
    return (r = e.filterManager) == null ? void 0 : r.setFilterModel(t);
  });
}
function lke(e) {
  var t;
  return ((t = e.filterManager) == null ? void 0 : t.getFilterModel()) ?? {};
}
function uke(e, t) {
  var r;
  return ((r = e.filterManager) == null ? void 0 : r.getColumnFilterModel(t)) ?? null;
}
function cke(e, t, r) {
  var n;
  return ((n = e.filterManager) == null ? void 0 : n.setColumnFilterModel(t, r)) ?? Promise.resolve();
}
function dke(e, t) {
  const r = e.columnModel.getCol(t);
  if (!r) {
    sr(`column '${t}' not found`);
    return;
  }
  e.menuService.showFilterMenu({
    column: r,
    containerType: "columnFilter",
    positionBy: "auto"
  });
}
function hke(e, t, r) {
  if (t == null)
    return null;
  let n = null;
  const { compName: i, jsComp: o, fwComp: a } = RK.getCompKeys(e, t, PA);
  return i ? n = {
    set: "agSetColumnFloatingFilter",
    agSetColumnFilter: "agSetColumnFloatingFilter",
    multi: "agMultiColumnFloatingFilter",
    agMultiColumnFilter: "agMultiColumnFloatingFilter",
    group: "agGroupColumnFloatingFilter",
    agGroupColumnFilter: "agGroupColumnFloatingFilter",
    number: "agNumberColumnFloatingFilter",
    agNumberColumnFilter: "agNumberColumnFloatingFilter",
    date: "agDateColumnFloatingFilter",
    agDateColumnFilter: "agDateColumnFloatingFilter",
    text: "agTextColumnFloatingFilter",
    agTextColumnFilter: "agTextColumnFloatingFilter"
  }[i] : o == null && a == null && t.filter === !0 && (n = r()), n;
}
var fke = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnFilterService", this.allColumnFilters = /* @__PURE__ */ new Map(), this.allColumnListeners = /* @__PURE__ */ new Map(), this.activeAggregateFilters = [], this.activeColumnFilters = [], this.processingFilterChange = !1, this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue = [];
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.rowModel = e.rowModel, this.userComponentFactory = e.userComponentFactory, this.rowRenderer = e.rowRenderer, this.dataTypeService = e.dataTypeService, this.filterManager = e.filterManager;
  }
  postConstruct() {
    var e, t;
    this.addManagedEventListeners({
      gridColumnsChanged: this.onColumnsChanged.bind(this),
      rowDataUpdated: () => this.onNewRowsLoaded("rowDataUpdated"),
      dataTypesInferred: this.processFilterModelUpdateQueue.bind(this)
    }), this.initialFilterModel = {
      ...((t = (e = this.gos.get("initialState")) == null ? void 0 : e.filter) == null ? void 0 : t.filterModel) ?? {}
    };
  }
  setFilterModel(e, t = "api") {
    var i;
    if ((i = this.dataTypeService) != null && i.isPendingInference()) {
      this.filterModelUpdateQueue.push({ model: e, source: t });
      return;
    }
    const r = [], n = this.getFilterModel();
    if (e) {
      const o = new Set(Object.keys(e));
      this.allColumnFilters.forEach((a, s) => {
        const l = e[s];
        r.push(this.setModelOnFilterWrapper(a.filterPromise, l)), o.delete(s);
      }), o.forEach((a) => {
        const s = this.columnModel.getColDefCol(a) || this.columnModel.getCol(a);
        if (!s) {
          Se("setFilterModel() - no column found for colId: " + a);
          return;
        }
        if (!s.isFilterAllowed()) {
          Se("setFilterModel() - unable to fully apply model, filtering disabled for colId: " + a);
          return;
        }
        const l = this.getOrCreateFilterWrapper(s);
        if (!l) {
          Se(
            "setFilterModel() - unable to fully apply model, unable to create filter for colId: " + a
          );
          return;
        }
        r.push(this.setModelOnFilterWrapper(l.filterPromise, e[a]));
      });
    } else
      this.allColumnFilters.forEach((o) => {
        r.push(this.setModelOnFilterWrapper(o.filterPromise, null));
      });
    en.all(r).then(() => {
      var s;
      const o = this.getFilterModel(), a = [];
      this.allColumnFilters.forEach((l, u) => {
        const c = n ? n[u] : null, d = o ? o[u] : null;
        GC(c, d) || a.push(l.column);
      }), a.length > 0 && ((s = this.filterManager) == null || s.onFilterChanged({ columns: a, source: t }));
    });
  }
  setModelOnFilterWrapper(e, t) {
    return new en((r) => {
      e.then((n) => {
        typeof n.setModel != "function" && (Se("filter missing setModel method, which is needed for setFilterModel"), r()), (n.setModel(t) || en.resolve()).then(() => r());
      });
    });
  }
  getFilterModel() {
    const e = {};
    return this.allColumnFilters.forEach((t, r) => {
      const n = this.getModelFromFilterWrapper(t);
      Me(n) && (e[r] = n);
    }), e;
  }
  getModelFromFilterWrapper(e) {
    const { filter: t } = e;
    return t ? typeof t.getModel != "function" ? (Se("filter API missing getModel method, which is needed for getFilterModel"), null) : t.getModel() : this.getModelFromInitialState(e.column);
  }
  getModelFromInitialState(e) {
    return this.initialFilterModel[e.getColId()] ?? null;
  }
  isColumnFilterPresent() {
    return this.activeColumnFilters.length > 0;
  }
  isAggregateFilterPresent() {
    return !!this.activeAggregateFilters.length;
  }
  disableColumnFilters() {
    return this.allColumnFilters.size ? (this.allColumnFilters.forEach(
      (e) => this.disposeFilterWrapper(e, "advancedFilterEnabled")
    ), !0) : !1;
  }
  doAggregateFiltersPass(e, t) {
    return this.doColumnFiltersPass(e, t, !0);
  }
  updateActiveFilters() {
    const e = (o) => o ? o.isFilterActive ? o.isFilterActive() : (Se("Filter is missing isFilterActive() method"), !1) : !1, t = !!this.gos.getGroupAggFiltering(), r = (o) => {
      if (!o.isPrimary())
        return !0;
      const s = !this.columnModel.isPivotActive();
      return !o.isValueActive() || !s ? !1 : this.columnModel.isPivotMode() ? !0 : t;
    }, n = [], i = [];
    return this.forEachColumnFilter((o, a) => {
      e(o) && (r(a.column) ? n.push(o) : i.push(o));
    }).then(() => {
      this.activeAggregateFilters = n, this.activeColumnFilters = i;
    });
  }
  updateFilterFlagInColumns(e, t) {
    return this.forEachColumnFilter(
      (r, n) => n.column.setFilterActive(r.isFilterActive(), e, t)
    );
  }
  forEachColumnFilter(e) {
    return en.all(
      Array.from(this.allColumnFilters.values()).map(
        (t) => t.filterPromise.then((r) => e(r, t))
      )
    );
  }
  doColumnFiltersPass(e, t, r) {
    const { data: n, aggData: i } = e, o = r ? this.activeAggregateFilters : this.activeColumnFilters, a = r ? i : n;
    for (let s = 0; s < o.length; s++) {
      const l = o[s];
      if (!(l == null || l === t)) {
        if (typeof l.doesFilterPass != "function")
          throw new Error("Filter is missing method doesFilterPass");
        if (!l.doesFilterPass({ node: e, data: a }))
          return !1;
      }
    }
    return !0;
  }
  // sometimes (especially in React) the filter can call onFilterChanged when we are in the middle
  // of a render cycle. this would be bad, so we wait for render cycle to complete when this happens.
  // this happens in react when we change React State in the grid (eg setting RowCtrl's in RowContainer)
  // which results in React State getting applied in the main application, triggering a useEffect() to
  // be kicked off adn then the application calling the grid's API. in AG-6554, the custom filter was
  // getting it's useEffect() triggered in this way.
  callOnFilterChangedOutsideRenderCycle(e) {
    const t = () => {
      var r;
      return (r = this.filterManager) == null ? void 0 : r.onFilterChanged(e);
    };
    this.rowRenderer.isRefreshInProgress() ? setTimeout(t, 0) : t();
  }
  updateBeforeFilterChanged(e = {}) {
    const { filterInstance: t, additionalEventAttributes: r } = e;
    return this.updateDependentFilters(), this.updateActiveFilters().then(
      () => this.updateFilterFlagInColumns("filterChanged", r).then(() => {
        this.allColumnFilters.forEach((n) => {
          n.filterPromise && n.filterPromise.then((i) => {
            i && i !== t && i.onAnyFilterChanged && i.onAnyFilterChanged();
          });
        }), this.processingFilterChange = !0;
      })
    );
  }
  updateAfterFilterChanged() {
    this.processingFilterChange = !1;
  }
  isSuppressFlashingCellsBecauseFiltering() {
    return !(this.gos.get("allowShowChangeAfterFilter") ?? !1) && this.processingFilterChange;
  }
  onNewRowsLoaded(e) {
    this.forEachColumnFilter((t) => {
      t.onNewRowsLoaded && t.onNewRowsLoaded();
    }).then(() => this.updateFilterFlagInColumns(e, { afterDataChange: !0 })).then(() => this.updateActiveFilters());
  }
  createValueGetter(e) {
    return ({ node: t }) => this.valueService.getValue(e, t, !0);
  }
  createGetValue(e) {
    return (t, r) => {
      const n = r ? this.columnModel.getCol(r) : e;
      return n ? this.valueService.getValue(n, t, !0) : void 0;
    };
  }
  isFilterActive(e) {
    const { filter: t } = this.cachedFilter(e) ?? {};
    return t ? t.isFilterActive() : this.getModelFromInitialState(e) != null;
  }
  getOrCreateFilterWrapper(e) {
    if (!e.isFilterAllowed())
      return null;
    let t = this.cachedFilter(e);
    return t || (t = this.createFilterWrapper(e), this.setColumnFilterWrapper(e, t)), t;
  }
  cachedFilter(e) {
    return this.allColumnFilters.get(e.getColId());
  }
  getDefaultFilter(e) {
    var r;
    let t;
    if (Xn.__isRegistered("@ag-grid-enterprise/set-filter", this.gridId))
      t = "agSetColumnFilter";
    else {
      const n = (r = this.dataTypeService) == null ? void 0 : r.getBaseDataType(e);
      n === "number" ? t = "agNumberColumnFilter" : n === "date" || n === "dateString" ? t = "agDateColumnFilter" : t = "agTextColumnFilter";
    }
    return t;
  }
  getDefaultFloatingFilter(e) {
    var r;
    let t;
    if (Xn.__isRegistered("@ag-grid-enterprise/set-filter", this.gridId))
      t = "agSetColumnFloatingFilter";
    else {
      const n = (r = this.dataTypeService) == null ? void 0 : r.getBaseDataType(e);
      n === "number" ? t = "agNumberColumnFloatingFilter" : n === "date" || n === "dateString" ? t = "agDateColumnFloatingFilter" : t = "agTextColumnFloatingFilter";
    }
    return t;
  }
  createFilterInstance(e, t) {
    const r = this.getDefaultFilter(e), n = e.getColDef();
    let i;
    const o = {
      ...this.createFilterParams(e, n),
      filterModifiedCallback: () => this.filterModifiedCallbackFactory(i, e)(),
      filterChangedCallback: (s) => this.filterChangedCallbackFactory(i, e)(s),
      doesRowPassOtherFilter: (s) => this.filterManager ? this.filterManager.doesRowPassOtherFilters(i, s) : !0
    }, a = this.userComponentFactory.getFilterDetails(n, o, r);
    return a ? {
      filterPromise: () => {
        const s = a.newAgStackInstance();
        return s != null && s.then((l) => {
          i = l, t && (t.filter = l);
        }), s;
      },
      compDetails: a
    } : { filterPromise: null, compDetails: null };
  }
  createFilterParams(e, t) {
    return this.gos.addGridCommonParams({
      column: e,
      colDef: ZU(t),
      rowModel: this.rowModel,
      filterChangedCallback: () => {
      },
      filterModifiedCallback: () => {
      },
      valueGetter: this.createValueGetter(e),
      getValue: this.createGetValue(e),
      doesRowPassOtherFilter: () => !0
    });
  }
  createFilterWrapper(e) {
    const t = {
      column: e,
      filterPromise: null,
      compiledElement: null,
      compDetails: null
    }, { filterPromise: r, compDetails: n } = this.createFilterInstance(e, t);
    return t.filterPromise = (r == null ? void 0 : r()) ?? null, t.compDetails = n, t;
  }
  onColumnsChanged() {
    var t;
    const e = [];
    this.allColumnFilters.forEach((r, n) => {
      let i;
      r.column.isPrimary() ? i = this.columnModel.getColDefCol(n) : i = this.columnModel.getCol(n), !(i && i === r.column) && (e.push(r.column), this.disposeFilterWrapper(r, "columnChanged"), this.disposeColumnListener(n));
    }), e.length > 0 ? (t = this.filterManager) == null || t.onFilterChanged({ columns: e, source: "api" }) : this.updateDependentFilters();
  }
  updateDependentFilters() {
    const e = this.columnModel.getAutoCols();
    e == null || e.forEach((t) => {
      t.getColDef().filter === "agGroupColumnFilter" && this.getOrCreateFilterWrapper(t);
    });
  }
  // for group filters, can change dynamically whether they are allowed or not
  isFilterAllowed(e) {
    if (!e.isFilterAllowed())
      return !1;
    const { filter: r } = this.allColumnFilters.get(e.getColId()) ?? {};
    return r && typeof (r == null ? void 0 : r.isFilterAllowed) == "function" ? r.isFilterAllowed() : !0;
  }
  getFloatingFilterCompDetails(e, t) {
    const r = (l) => {
      var c;
      const u = (c = this.getOrCreateFilterWrapper(e)) == null ? void 0 : c.filterPromise;
      u != null && u.then((d) => {
        l(dg(d));
      });
    }, n = e.getColDef(), i = {
      ...this.createFilterParams(e, n),
      filterChangedCallback: () => r(
        (l) => this.filterChangedCallbackFactory(l, e)()
      )
    }, o = this.userComponentFactory.mergeParamsWithApplicationProvidedParams(
      n,
      PA,
      i
    );
    let a = hke(
      this.frameworkOverrides,
      n,
      () => this.getDefaultFloatingFilter(e)
    );
    a == null && (a = "agReadOnlyFloatingFilter");
    const s = {
      column: e,
      filterParams: o,
      currentParentModel: () => this.getCurrentFloatingFilterParentModel(e),
      parentFilterInstance: r,
      showParentFilter: t,
      suppressFilterButton: !1
      // This one might be overridden from the colDef
    };
    return this.userComponentFactory.getFloatingFilterCompDetails(n, s, a);
  }
  getCurrentFloatingFilterParentModel(e) {
    return this.getModelFromFilterWrapper(this.cachedFilter(e) ?? { column: e });
  }
  // destroys the filter, so it no longer takes part
  destroyFilter(e, t = "api") {
    var i;
    const r = e.getColId(), n = this.allColumnFilters.get(r);
    this.disposeColumnListener(r), delete this.initialFilterModel[r], n && (this.disposeFilterWrapper(n, t), (i = this.filterManager) == null || i.onFilterChanged({
      columns: [e],
      source: "api"
    }));
  }
  disposeColumnListener(e) {
    const t = this.allColumnListeners.get(e);
    t && (this.allColumnListeners.delete(e), t());
  }
  disposeFilterWrapper(e, t) {
    e.filterPromise.then((r) => {
      this.destroyBean(r), e.column.setFilterActive(!1, "filterDestroyed"), this.allColumnFilters.delete(e.column.getColId());
      const n = {
        type: "filterDestroyed",
        source: t,
        column: e.column
      };
      this.eventService.dispatchEvent(n);
    });
  }
  filterModifiedCallbackFactory(e, t) {
    return () => {
      const r = {
        type: "filterModified",
        column: t,
        filterInstance: e
      };
      this.eventService.dispatchEvent(r);
    };
  }
  filterChangedCallbackFactory(e, t) {
    return (r) => {
      const n = (r == null ? void 0 : r.source) ?? "columnFilter", i = {
        filter: e,
        additionalEventAttributes: r,
        columns: [t],
        source: n
      };
      this.callOnFilterChangedOutsideRenderCycle(i);
    };
  }
  checkDestroyFilter(e) {
    const t = this.allColumnFilters.get(e);
    if (!t)
      return;
    const r = t.column, { compDetails: n } = r.isFilterAllowed() ? this.createFilterInstance(r) : { compDetails: null };
    if (this.areFilterCompsDifferent(t.compDetails, n)) {
      this.destroyFilter(r, "paramsUpdated");
      return;
    }
    const i = r.getColDef().filterParams;
    if (!t.filterPromise) {
      this.destroyFilter(r, "paramsUpdated");
      return;
    }
    t.filterPromise.then((o) => {
      (o != null && o.refresh ? o.refresh({
        ...this.createFilterParams(r, r.getColDef()),
        filterModifiedCallback: this.filterModifiedCallbackFactory(o, r),
        filterChangedCallback: this.filterChangedCallbackFactory(o, r),
        doesRowPassOtherFilter: (s) => this.filterManager ? this.filterManager.doesRowPassOtherFilters(o, s) : !0,
        ...i
      }) : !0) === !1 && this.destroyFilter(r, "paramsUpdated");
    });
  }
  setColumnFilterWrapper(e, t) {
    const r = e.getColId();
    this.allColumnFilters.set(r, t), this.allColumnListeners.set(
      r,
      this.addManagedListeners(e, { colDefChanged: () => this.checkDestroyFilter(r) })[0]
    );
  }
  areFilterCompsDifferent(e, t) {
    if (!t || !e)
      return !0;
    const { componentClass: r } = e, { componentClass: n } = t;
    return !(r === n || // react hooks returns new wrappers, so check nested render method
    (r == null ? void 0 : r.render) && (n == null ? void 0 : n.render) && r.render === n.render);
  }
  hasFloatingFilters() {
    return this.columnModel.getCols().some((t) => t.getColDef().floatingFilter);
  }
  getFilterInstance(e, t) {
    t && this.getFilterInstanceImpl(e).then((r) => {
      const n = dg(r);
      t(n);
    });
  }
  getColumnFilterInstance(e) {
    return new Promise((t) => {
      this.getFilterInstanceImpl(e).then((r) => {
        t(dg(r));
      });
    });
  }
  getFilterInstanceImpl(e) {
    var n;
    const t = this.columnModel.getColDefCol(e);
    return t ? ((n = this.getOrCreateFilterWrapper(t)) == null ? void 0 : n.filterPromise) ?? en.resolve(null) : en.resolve(void 0);
  }
  processFilterModelUpdateQueue() {
    this.filterModelUpdateQueue.forEach(({ model: e, source: t }) => this.setFilterModel(e, t)), this.filterModelUpdateQueue = [], this.columnFilterModelUpdateQueue.forEach(({ key: e, model: t, resolve: r }) => {
      this.setColumnFilterModel(e, t).then(() => r());
    }), this.columnFilterModelUpdateQueue = [];
  }
  getColumnFilterModel(e) {
    const t = this.getFilterWrapper(e);
    return t ? this.getModelFromFilterWrapper(t) : null;
  }
  setColumnFilterModel(e, t) {
    var o;
    if ((o = this.dataTypeService) != null && o.isPendingInference()) {
      let a = () => {
      };
      const s = new Promise((l) => {
        a = l;
      });
      return this.columnFilterModelUpdateQueue.push({ key: e, model: t, resolve: a }), s;
    }
    const r = this.columnModel.getColDefCol(e), n = r ? this.getOrCreateFilterWrapper(r) : null;
    return n ? ((a) => new Promise((s) => {
      a.then((l) => s(l));
    }))(this.setModelOnFilterWrapper(n.filterPromise, t)) : Promise.resolve();
  }
  getFilterWrapper(e) {
    const t = this.columnModel.getColDefCol(e);
    return t ? this.cachedFilter(t) ?? null : null;
  }
  destroy() {
    super.destroy(), this.allColumnFilters.forEach((e) => this.disposeFilterWrapper(e, "gridDestroyed")), this.allColumnListeners.clear();
  }
};
function pke(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isAnyFilterPresent());
}
function gke(e, t = "api") {
  var r;
  (r = e.filterManager) == null || r.onFilterChanged({ source: t });
}
var vke = class extends Nr {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eFloatingFilterText"></ag-input-text-field>
            </div>`,
      [vw]
    ), this.eFloatingFilterText = ft;
  }
  wireBeans(e) {
    this.columnNameService = e.columnNameService;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e;
    const t = this.columnNameService.getDisplayNameForColumn(e.column, "header", !0), r = this.localeService.getLocaleTextFunc();
    this.eFloatingFilterText.setDisabled(!0).setInputAriaLabel(`${t} ${r("ariaFilterInput", "Filter Input")}`);
  }
  onParentModelChanged(e) {
    if (e == null) {
      this.eFloatingFilterText.setValue("");
      return;
    }
    this.params.parentFilterInstance((t) => {
      if (t.getModelAsString) {
        const r = t.getModelAsString(e);
        this.eFloatingFilterText.setValue(r);
      }
    });
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.init(e);
  }
}, ZK = class extends Nr {
  wireBeans(e) {
    this.columnNameService = e.columnNameService;
  }
  getDefaultDebounceMs() {
    return 0;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  isEventFromFloatingFilter(e) {
    return e && e.afterFloatingFilter;
  }
  isEventFromDataChange(e) {
    return e == null ? void 0 : e.afterDataChange;
  }
  getLastType() {
    return this.lastType;
  }
  isReadOnly() {
    return this.readOnly;
  }
  setLastTypeFromModel(e) {
    if (!e) {
      this.lastType = this.optionsFactory.getDefaultOption();
      return;
    }
    const t = e.operator;
    let r;
    t ? r = e.conditions[0] : r = e, this.lastType = r.type;
  }
  canWeEditAfterModelFromParentFilter(e) {
    if (!e)
      return this.isTypeEditable(this.lastType);
    if (e.operator)
      return !1;
    const r = e;
    return this.isTypeEditable(r.type);
  }
  init(e) {
    this.setSimpleParams(e, !1);
  }
  setSimpleParams(e, t = !0) {
    this.optionsFactory = new FK(), this.optionsFactory.init(e.filterParams, this.getDefaultFilterOptions()), t || (this.lastType = this.optionsFactory.getDefaultOption()), this.readOnly = !!e.filterParams.readOnly;
    const r = this.isTypeEditable(this.optionsFactory.getDefaultOption());
    this.setEditable(r);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.setSimpleParams(e);
  }
  doesFilterHaveSingleInput(e) {
    const t = this.optionsFactory.getCustomOption(e), { numberOfInputs: r } = t || {};
    return r == null || r == 1;
  }
  isTypeEditable(e) {
    const t = ["inRange", "empty", "blank", "notBlank"];
    return !!e && !this.isReadOnly() && this.doesFilterHaveSingleInput(e) && t.indexOf(e) < 0;
  }
  getAriaLabel(e) {
    const t = this.columnNameService.getDisplayNameForColumn(e.column, "header", !0), r = this.localeService.getLocaleTextFunc();
    return `${t} ${r("ariaFilterInput", "Filter Input")}`;
  }
}, mke = class extends ZK {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation">
                <ag-input-text-field data-ref="eReadOnlyText"></ag-input-text-field>
                <div data-ref="eDateWrapper" style="display: flex;"></div>
            </div>`,
      [vw]
    ), this.eReadOnlyText = ft, this.eDateWrapper = ft;
  }
  wireBeans(e) {
    super.wireBeans(e), this.context = e.context, this.userComponentFactory = e.userComponentFactory;
  }
  getDefaultFilterOptions() {
    return WK;
  }
  init(e) {
    super.init(e), this.params = e, this.filterParams = e.filterParams, this.createDateComponent(), this.filterModelFormatter = new jK(
      this.filterParams,
      this.localeService,
      this.optionsFactory
    );
    const t = this.localeService.getLocaleTextFunc();
    this.eReadOnlyText.setDisabled(!0).setInputAriaLabel(t("ariaDateFilterInput", "Date Filter Input"));
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.params = e, this.filterParams = e.filterParams, this.updateDateComponent(), this.filterModelFormatter.updateParams({
      optionsFactory: this.optionsFactory,
      dateFilterParams: this.filterParams
    }), this.updateCompOnModelChange(e.currentParentModel());
  }
  updateCompOnModelChange(e) {
    const t = !this.isReadOnly() && this.canWeEditAfterModelFromParentFilter(e);
    if (this.setEditable(t), t) {
      if (e) {
        const r = e;
        this.dateComp.setDate(Oi(r.dateFrom));
      } else
        this.dateComp.setDate(null);
      this.eReadOnlyText.setValue("");
    } else
      this.eReadOnlyText.setValue(this.filterModelFormatter.getModelAsString(e)), this.dateComp.setDate(null);
  }
  setEditable(e) {
    jr(this.eDateWrapper, e), jr(this.eReadOnlyText.getGui(), !e);
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (super.setLastTypeFromModel(e), this.updateCompOnModelChange(e));
  }
  onDateChanged() {
    const e = this.dateComp.getDate(), t = Io(e);
    this.params.parentFilterInstance((r) => {
      if (r) {
        const n = Oi(t);
        r.onFloatingFilterChanged(this.getLastType() || null, n);
      }
    });
  }
  getDateComponentParams() {
    const e = MA(this.params.filterParams, this.getDefaultDebounceMs());
    return {
      onDateChanged: vi(this.onDateChanged.bind(this), e),
      filterParams: this.params.column.getColDef().filterParams
    };
  }
  createDateComponent() {
    this.dateComp = new $K(
      this.context,
      this.userComponentFactory,
      this.getDateComponentParams(),
      this.eDateWrapper,
      (e) => {
        e.setInputAriaLabel(this.getAriaLabel(this.params));
      }
    ), this.addDestroyFunc(() => this.dateComp.destroy());
  }
  updateDateComponent() {
    const e = this.gos.addGridCommonParams(this.getDateComponentParams());
    this.dateComp.updateParams(e);
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
}, yke = class extends Nr {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-filter-filter">
                <ag-input-text-field class="ag-date-filter" data-ref="eDateInput"></ag-input-text-field>
            </div>`,
      [vw]
    ), this.eDateInput = ft;
  }
  // this is a user component, and IComponent has "public destroy()" as part of the interface.
  // so we need to override destroy() just to make the method public.
  destroy() {
    super.destroy();
  }
  init(e) {
    this.params = e, this.setParams(e);
    const t = this.eDateInput.getInputElement();
    this.addManagedListeners(t, {
      // ensures that the input element is focussed when a clear button is clicked,
      // unless using safari as there is no clear button and focus does not work properly
      mouseDown: () => {
        this.eDateInput.isDisabled() || this.usingSafariDatePicker || t.focus();
      },
      input: (r) => {
        r.target === this.gos.getActiveDomElement() && (this.eDateInput.isDisabled() || this.params.onDateChanged());
      }
    });
  }
  setParams(e) {
    const t = this.eDateInput.getInputElement(), r = this.shouldUseBrowserDatePicker(e);
    this.usingSafariDatePicker = r && Zs(), t.type = r ? "date" : "text";
    const { minValidYear: n, maxValidYear: i, minValidDate: o, maxValidDate: a } = e.filterParams || {};
    if (o && n && Se(
      "DateFilter should not have both minValidDate and minValidYear parameters set at the same time! minValidYear will be ignored."
    ), a && i && Se(
      "DateFilter should not have both maxValidDate and maxValidYear parameters set at the same time! maxValidYear will be ignored."
    ), o && a) {
      const [s, l] = [o, a].map(
        (u) => u instanceof Date ? u : Oi(u)
      );
      s && l && s.getTime() > l.getTime() && Se(
        "DateFilter parameter minValidDate should always be lower than or equal to parameter maxValidDate."
      );
    }
    o ? o instanceof Date ? t.min = fg(o) : t.min = o : n && (t.min = `${n}-01-01`), a ? a instanceof Date ? t.max = fg(a) : t.max = a : i && (t.max = `${i}-12-31`);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    this.params = e, this.setParams(e);
  }
  getDate() {
    return Oi(this.eDateInput.getValue());
  }
  setDate(e) {
    this.eDateInput.setValue(Io(e, !1));
  }
  setInputPlaceholder(e) {
    this.eDateInput.setInputPlaceholder(e);
  }
  setInputAriaLabel(e) {
    this.eDateInput.setAriaLabel(e);
  }
  setDisabled(e) {
    this.eDateInput.setDisabled(e);
  }
  afterGuiAttached(e) {
    (!e || !e.suppressFocus) && this.eDateInput.getInputElement().focus();
  }
  shouldUseBrowserDatePicker(e) {
    return e.filterParams && e.filterParams.browserDatePicker != null ? e.filterParams.browserDatePicker : SA() || uK() || Zs() && lK() >= 14.1;
  }
}, XK = class extends he {
  constructor(e) {
    super(), this.params = e, this.eFloatingFilterTextInput = ft, this.valueChangedListener = () => {
    };
  }
  setupGui(e) {
    var n;
    this.eFloatingFilterTextInput = this.createManagedBean(new rd((n = this.params) == null ? void 0 : n.config));
    const t = this.eFloatingFilterTextInput.getGui();
    e.appendChild(t);
    const r = (i) => this.valueChangedListener(i);
    this.addManagedListeners(t, {
      input: r,
      keydown: r
    });
  }
  setEditable(e) {
    this.eFloatingFilterTextInput.setDisabled(!e);
  }
  setAutoComplete(e) {
    this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.eFloatingFilterTextInput.getValue();
  }
  setValue(e, t) {
    this.eFloatingFilterTextInput.setValue(e, t);
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, QK = class extends ZK {
  constructor() {
    super(...arguments), this.eFloatingFilterInputContainer = ft;
  }
  postConstruct() {
    this.setTemplate(
      /* html */
      `
            <div class="ag-floating-filter-input" role="presentation" data-ref="eFloatingFilterInputContainer"></div>
        `
    );
  }
  getDefaultDebounceMs() {
    return 500;
  }
  onParentModelChanged(e, t) {
    this.isEventFromFloatingFilter(t) || this.isEventFromDataChange(t) || (this.setLastTypeFromModel(e), this.setEditable(this.canWeEditAfterModelFromParentFilter(e)), this.floatingFilterInputService.setValue(this.getFilterModelFormatter().getModelAsString(e)));
  }
  init(e) {
    this.setupFloatingFilterInputService(e), super.init(e), this.setTextInputParams(e);
  }
  setupFloatingFilterInputService(e) {
    this.floatingFilterInputService = this.createFloatingFilterInputService(e), this.floatingFilterInputService.setupGui(this.eFloatingFilterInputContainer);
  }
  setTextInputParams(e) {
    this.params = e;
    const t = e.browserAutoComplete ?? !1;
    if (this.floatingFilterInputService.setParams({
      ariaLabel: this.getAriaLabel(e),
      autoComplete: t
    }), this.applyActive = YC(this.params.filterParams), !this.isReadOnly()) {
      const r = MA(this.params.filterParams, this.getDefaultDebounceMs()), n = vi(
        this.syncUpWithParentFilter.bind(this),
        r
      );
      this.floatingFilterInputService.setValueChangedListener(n);
    }
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.setTextInputParams(e);
  }
  recreateFloatingFilterInputService(e) {
    const t = this.floatingFilterInputService.getValue();
    oo(this.eFloatingFilterInputContainer), this.destroyBean(this.floatingFilterInputService), this.setupFloatingFilterInputService(e), this.floatingFilterInputService.setValue(t, !0);
  }
  syncUpWithParentFilter(e) {
    const t = e.key === ae.ENTER;
    if (this.applyActive && !t)
      return;
    let r = this.floatingFilterInputService.getValue();
    this.params.filterParams.trimInput && (r = HK(r), this.floatingFilterInputService.setValue(r, !0)), this.params.parentFilterInstance((n) => {
      n && n.onFloatingFilterChanged(this.getLastType() || null, r || null);
    });
  }
  setEditable(e) {
    this.floatingFilterInputService.setEditable(e);
  }
}, Cke = class extends he {
  constructor() {
    super(...arguments), this.valueChangedListener = () => {
    }, this.numberInputActive = !0;
  }
  setupGui(e) {
    this.eFloatingFilterNumberInput = this.createManagedBean(new AA()), this.eFloatingFilterTextInput = this.createManagedBean(new rd()), this.eFloatingFilterTextInput.setDisabled(!0);
    const t = this.eFloatingFilterNumberInput.getGui(), r = this.eFloatingFilterTextInput.getGui();
    e.appendChild(t), e.appendChild(r), this.setupListeners(t, (n) => this.valueChangedListener(n)), this.setupListeners(r, (n) => this.valueChangedListener(n));
  }
  setEditable(e) {
    this.numberInputActive = e, this.eFloatingFilterNumberInput.setDisplayed(this.numberInputActive), this.eFloatingFilterTextInput.setDisplayed(!this.numberInputActive);
  }
  setAutoComplete(e) {
    this.eFloatingFilterNumberInput.setAutoComplete(e), this.eFloatingFilterTextInput.setAutoComplete(e);
  }
  getValue() {
    return this.getActiveInputElement().getValue();
  }
  setValue(e, t) {
    this.getActiveInputElement().setValue(e, t);
  }
  getActiveInputElement() {
    return this.numberInputActive ? this.eFloatingFilterNumberInput : this.eFloatingFilterTextInput;
  }
  setValueChangedListener(e) {
    this.valueChangedListener = e;
  }
  setupListeners(e, t) {
    this.addManagedListeners(e, {
      input: t,
      keydown: t
    });
  }
  setParams(e) {
    this.setAriaLabel(e.ariaLabel), e.autoComplete !== void 0 && this.setAutoComplete(e.autoComplete);
  }
  setAriaLabel(e) {
    this.eFloatingFilterNumberInput.setInputAriaLabel(e), this.eFloatingFilterTextInput.setInputAriaLabel(e);
  }
}, Ske = class extends QK {
  init(e) {
    var t;
    super.init(e), this.filterModelFormatter = new VK(
      this.localeService,
      this.optionsFactory,
      (t = e.filterParams) == null ? void 0 : t.numberFormatter
    );
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    AT(e.filterParams) !== this.allowedCharPattern && this.recreateFloatingFilterInputService(e), super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return kK;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService(e) {
    return this.allowedCharPattern = AT(e.filterParams), this.allowedCharPattern ? this.createManagedBean(
      new XK({
        config: { allowedCharPattern: this.allowedCharPattern }
      })
    ) : this.createManagedBean(new Cke());
  }
}, wke = class extends QK {
  init(e) {
    super.init(e), this.filterModelFormatter = new GK(this.localeService, this.optionsFactory);
  }
  onParamsUpdated(e) {
    this.refresh(e);
  }
  refresh(e) {
    super.refresh(e), this.filterModelFormatter.updateParams({ optionsFactory: this.optionsFactory });
  }
  getDefaultFilterOptions() {
    return BK;
  }
  getFilterModelFormatter() {
    return this.filterModelFormatter;
  }
  createFloatingFilterInputService() {
    return this.createManagedBean(new XK());
  }
};
function bke(e) {
  var t;
  return !!((t = e.filterManager) != null && t.isQuickFilterPresent());
}
function xke(e) {
  return e.gos.get("quickFilterText");
}
function Eke(e) {
  var t;
  (t = e.filterManager) == null || t.resetQuickFilterCache();
}
var Rke = class extends he {
  constructor() {
    super(...arguments), this.beanName = "quickFilterService", this.quickFilter = null, this.quickFilterParts = null;
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.rowModel = e.rowModel, this.pivotResultColsService = e.pivotResultColsService;
  }
  postConstruct() {
    const e = this.resetQuickFilterCache.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: e,
      newColumnsLoaded: e,
      columnRowGroupChanged: e,
      columnVisible: () => {
        this.gos.get("includeHiddenColumnsInQuickFilter") || this.resetQuickFilterCache();
      }
    }), this.addManagedPropertyListener("quickFilterText", (t) => this.setQuickFilter(t.currentValue)), this.addManagedPropertyListeners(
      ["includeHiddenColumnsInQuickFilter", "applyQuickFilterBeforePivotOrAgg"],
      () => this.onQuickFilterColumnConfigChanged()
    ), this.quickFilter = this.parseQuickFilter(this.gos.get("quickFilterText")), this.parser = this.gos.get("quickFilterParser"), this.matcher = this.gos.get("quickFilterMatcher"), this.setQuickFilterParts(), this.addManagedPropertyListeners(
      ["quickFilterMatcher", "quickFilterParser"],
      () => this.setQuickFilterParserAndMatcher()
    );
  }
  // if we are using autoGroupCols, then they should be included for quick filter. this covers the
  // following scenarios:
  // a) user provides 'field' into autoGroupCol of normal grid, so now because a valid col to filter leafs on
  // b) using tree data and user depends on autoGroupCol for first col, and we also want to filter on this
  //    (tree data is a bit different, as parent rows can be filtered on, unlike row grouping)
  refreshQuickFilterCols() {
    var i;
    const e = this.columnModel.isPivotMode(), t = this.columnModel.getAutoCols(), r = this.columnModel.getColDefCols();
    let n = (e && !this.gos.get("applyQuickFilterBeforePivotOrAgg") ? (i = this.pivotResultColsService.getPivotResultCols()) == null ? void 0 : i.list : r) ?? [];
    t && (n = n.concat(t)), this.colsForQuickFilter = this.gos.get("includeHiddenColumnsInQuickFilter") ? n : n.filter((o) => o.isVisible() || o.isRowGroupActive());
  }
  isQuickFilterPresent() {
    return this.quickFilter !== null;
  }
  doesRowPassQuickFilter(e) {
    const t = this.gos.get("cacheQuickFilter");
    return this.matcher ? this.doesRowPassQuickFilterMatcher(t, e) : this.quickFilterParts.every(
      (r) => t ? this.doesRowPassQuickFilterCache(e, r) : this.doesRowPassQuickFilterNoCache(e, r)
    );
  }
  resetQuickFilterCache() {
    this.rowModel.forEachNode((e) => e.quickFilterAggregateText = null);
  }
  setQuickFilterParts() {
    const { quickFilter: e, parser: t } = this;
    e ? this.quickFilterParts = t ? t(e) : e.split(" ") : this.quickFilterParts = null;
  }
  parseQuickFilter(e) {
    return Me(e) ? this.gos.isRowModelType("clientSide") ? e.toUpperCase() : (Se("Quick filtering only works with the Client-Side Row Model"), null) : null;
  }
  setQuickFilter(e) {
    if (e != null && typeof e != "string") {
      Se(`Grid option quickFilterText only supports string inputs, received: ${typeof e}`);
      return;
    }
    const t = this.parseQuickFilter(e);
    this.quickFilter !== t && (this.quickFilter = t, this.setQuickFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  setQuickFilterParserAndMatcher() {
    const e = this.gos.get("quickFilterParser"), t = this.gos.get("quickFilterMatcher"), r = e !== this.parser || t !== this.matcher;
    this.parser = e, this.matcher = t, r && (this.setQuickFilterParts(), this.dispatchLocalEvent({ type: "quickFilterChanged" }));
  }
  onQuickFilterColumnConfigChanged() {
    this.refreshQuickFilterCols(), this.resetQuickFilterCache(), this.isQuickFilterPresent() && this.dispatchLocalEvent({ type: "quickFilterChanged" });
  }
  doesRowPassQuickFilterNoCache(e, t) {
    return this.colsForQuickFilter.some((r) => {
      const n = this.getQuickFilterTextForColumn(r, e);
      return Me(n) && n.indexOf(t) >= 0;
    });
  }
  doesRowPassQuickFilterCache(e, t) {
    return this.checkGenerateQuickFilterAggregateText(e), e.quickFilterAggregateText.indexOf(t) >= 0;
  }
  doesRowPassQuickFilterMatcher(e, t) {
    let r;
    e ? (this.checkGenerateQuickFilterAggregateText(t), r = t.quickFilterAggregateText) : r = this.getQuickFilterAggregateText(t);
    const { quickFilterParts: n, matcher: i } = this;
    return i(n, r);
  }
  checkGenerateQuickFilterAggregateText(e) {
    e.quickFilterAggregateText || (e.quickFilterAggregateText = this.getQuickFilterAggregateText(e));
  }
  getQuickFilterTextForColumn(e, t) {
    let r = this.valueService.getValue(e, t, !0);
    const n = e.getColDef();
    if (n.getQuickFilterText) {
      const i = this.gos.addGridCommonParams({
        value: r,
        node: t,
        data: t.data,
        column: e,
        colDef: n
      });
      r = n.getQuickFilterText(i);
    }
    return Me(r) ? r.toString().toUpperCase() : null;
  }
  getQuickFilterAggregateText(e) {
    const t = [];
    return this.colsForQuickFilter.forEach((r) => {
      const n = this.getQuickFilterTextForColumn(r, e);
      Me(n) && t.push(n);
    }), t.join(`
`);
  }
}, OA = {
  version: Et,
  moduleName: "@ag-grid-community/filter-core",
  beans: [TNe]
}, _ke = {
  version: Et,
  moduleName: "@ag-grid-community/filter-api",
  apiFunctions: {
    isAnyFilterPresent: pke,
    onFilterChanged: gke
  },
  dependantModules: [OA]
}, NA = {
  version: Et,
  moduleName: "@ag-grid-community/column-filter",
  beans: [fke],
  dependantModules: [OA]
}, Tke = {
  version: Et,
  moduleName: "@ag-grid-community/column-filter-api",
  apiFunctions: {
    isColumnFilterPresent: nke,
    getFilterInstance: ike,
    getColumnFilterInstance: oke,
    destroyFilter: ake,
    setFilterModel: ske,
    getFilterModel: lke,
    getColumnFilterModel: uke,
    setColumnFilterModel: cke,
    showColumnFilter: dke
  },
  dependantModules: [NA, _ke]
}, JK = {
  version: Et,
  moduleName: "@ag-grid-community/floating-filter-core",
  controllers: [{ name: "headerFilterCell", classImp: rke }],
  dependantModules: [NA]
}, Pke = {
  version: Et,
  moduleName: "@ag-grid-community/read-only-floating-filter",
  userComponents: [{ name: "agReadOnlyFloatingFilter", classImp: vke }],
  dependantModules: [JK]
}, Mke = {
  version: Et,
  moduleName: "@ag-grid-community/simple-filter",
  dependantModules: [NA],
  userComponents: [
    { name: "agTextColumnFilter", classImp: KNe },
    { name: "agNumberColumnFilter", classImp: UNe },
    { name: "agDateColumnFilter", classImp: ZNe },
    { name: "agDateInput", classImp: yke }
  ]
}, Dke = {
  version: Et,
  moduleName: "@ag-grid-community/simple-floating-filter",
  dependantModules: [Mke, JK],
  userComponents: [
    { name: "agTextColumnFloatingFilter", classImp: wke },
    { name: "agNumberColumnFloatingFilter", classImp: Ske },
    { name: "agDateColumnFloatingFilter", classImp: mke }
  ]
}, eY = {
  version: Et,
  moduleName: "@ag-grid-community/quick-filter-core",
  beans: [Rke],
  dependantModules: [OA]
}, Ake = {
  version: Et,
  moduleName: "@ag-grid-community/quick-filter-api",
  apiFunctions: {
    isQuickFilterPresent: bke,
    getQuickFilter: xke,
    resetQuickFilter: Eke
  },
  dependantModules: [eY]
}, Ike = {
  version: Et,
  moduleName: "@ag-grid-community/quick-filter",
  dependantModules: [eY, Ake]
}, Fke = {
  version: Et,
  moduleName: "@ag-grid-community/filter",
  dependantModules: [
    Dke,
    Pke,
    Ike,
    Tke
  ]
}, IT = /* @__PURE__ */ ((e) => (e.COLUMN_GROUP = "group", e.COLUMN = "column", e.FLOATING_FILTER = "filter", e))(IT || {}), Lke = class extends he {
  constructor() {
    super(...arguments), this.beanName = "headerNavigationService", this.currentHeaderRowWithoutSpan = -1;
  }
  wireBeans(e) {
    this.focusService = e.focusService, this.headerPositionUtils = e.headerPositionUtils, this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.visibleColService = e.visibleColsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((t) => {
      this.gridBodyCon = t.gridBodyCtrl;
    });
    const e = this.gos.getDocument();
    this.addManagedElementListeners(e, { mousedown: () => this.setCurrentHeaderRowWithoutSpan(-1) });
  }
  getHeaderRowCount() {
    const e = this.ctrlsService.getHeaderRowContainerCtrl();
    return e ? e.getRowCount() : 0;
  }
  getHeaderPositionForColumn(e, t) {
    let r;
    if (typeof e == "string" ? (r = this.columnModel.getCol(e), r || (r = this.visibleColService.getColumnGroup(e))) : r = e, !r)
      return null;
    const i = this.ctrlsService.getHeaderRowContainerCtrl().getAllCtrls(), o = Jt(i).getType() === "filter", a = this.getHeaderRowCount() - 1;
    let s = -1, l = r;
    for (; l; )
      s++, l = l.getParent();
    let u = s;
    return t && o && u === a - 1 && u++, u === -1 ? null : {
      headerRowIndex: u,
      column: r
    };
  }
  /*
   * This method navigates grid header vertically
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateVertically(e, t, r) {
    if (t || (t = this.focusService.getFocusedHeader()), !t)
      return !1;
    const { headerRowIndex: n } = t, i = t.column, o = this.getHeaderRowCount(), a = e === 0;
    let {
      headerRowIndex: s,
      column: l,
      // eslint-disable-next-line prefer-const
      headerRowIndexWithoutSpan: u
    } = a ? this.headerPositionUtils.getColumnVisibleParent(i, n) : this.headerPositionUtils.getColumnVisibleChild(i, n), c = !1;
    return s < 0 && (s = 0, l = i, c = !0), s >= o ? (s = -1, this.setCurrentHeaderRowWithoutSpan(-1)) : u !== void 0 && (this.currentHeaderRowWithoutSpan = u), !c && !l ? !1 : this.focusService.focusHeaderPosition({
      headerPosition: { headerRowIndex: s, column: l },
      allowUserOverride: !0,
      event: r
    });
  }
  setCurrentHeaderRowWithoutSpan(e) {
    this.currentHeaderRowWithoutSpan = e;
  }
  /*
   * This method navigates grid header horizontally
   * @return {boolean} true to preventDefault on the event that caused this navigation.
   */
  navigateHorizontally(e, t = !1, r) {
    const n = this.focusService.getFocusedHeader(), i = e === 2, o = this.gos.get("enableRtl");
    let a, s;
    if (this.currentHeaderRowWithoutSpan !== -1 ? n.headerRowIndex = this.currentHeaderRowWithoutSpan : this.currentHeaderRowWithoutSpan = n.headerRowIndex, i !== o ? (s = "Before", a = this.headerPositionUtils.findHeader(n, s)) : (s = "After", a = this.headerPositionUtils.findHeader(n, s)), a || !t)
      return this.focusService.focusHeaderPosition({
        headerPosition: a,
        direction: s,
        fromTab: t,
        allowUserOverride: !0,
        event: r
      });
    if (t) {
      const l = this.gos.getCallback("tabToNextHeader");
      if (l)
        return this.focusService.focusHeaderPositionFromUserFunc({
          userFunc: l,
          headerPosition: a,
          direction: s
        });
    }
    return this.focusNextHeaderRow(n, s, r);
  }
  focusNextHeaderRow(e, t, r) {
    const n = e.headerRowIndex;
    let i = null, o;
    if (t === "Before" ? n > 0 && (o = n - 1, this.currentHeaderRowWithoutSpan -= 1, i = this.headerPositionUtils.findColAtEdgeForHeaderRow(o, "end")) : (o = n + 1, this.currentHeaderRowWithoutSpan < this.getHeaderRowCount() ? this.currentHeaderRowWithoutSpan += 1 : this.setCurrentHeaderRowWithoutSpan(-1), i = this.headerPositionUtils.findColAtEdgeForHeaderRow(o, "start")), !i)
      return !1;
    const { column: a, headerRowIndex: s } = this.headerPositionUtils.getHeaderIndexToFocus(
      i.column,
      i == null ? void 0 : i.headerRowIndex
    );
    return this.focusService.focusHeaderPosition({
      headerPosition: { column: a, headerRowIndex: s },
      direction: t,
      fromTab: !0,
      allowUserOverride: !0,
      event: r
    });
  }
  scrollToColumn(e, t = "After") {
    if (e.getPinned())
      return;
    let r;
    if (an(e)) {
      const n = e.getDisplayedLeafColumns();
      r = t === "Before" ? Jt(n) : n[0];
    } else
      r = e;
    this.gridBodyCon.getScrollFeature().ensureColumnVisible(r);
  }
}, Oke = class extends he {
  wireBeans(e) {
    this.headerNavigationService = e.headerNavigationService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService, this.filterManager = e.filterManager, this.menuService = e.menuService;
  }
  setComp(e, t, r) {
    this.comp = e, this.eGui = t, this.createManagedBean(
      new td(r, {
        onTabKeyDown: this.onTabKeyDown.bind(this),
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addManagedEventListeners({
      columnPivotModeChanged: this.onPivotModeChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this)
    }), this.onPivotModeChanged(), this.setupHeaderHeight();
    const n = this.onHeaderContextMenu.bind(this);
    this.addManagedElementListeners(this.eGui, { contextmenu: n }), this.mockContextMenuForIPad(n), this.ctrlsService.register("gridHeaderCtrl", this);
  }
  setupHeaderHeight() {
    const e = this.setHeaderHeight.bind(this);
    e(), this.addManagedPropertyListener("headerHeight", e), this.addManagedPropertyListener("pivotHeaderHeight", e), this.addManagedPropertyListener("groupHeaderHeight", e), this.addManagedPropertyListener("pivotGroupHeaderHeight", e), this.addManagedPropertyListener("floatingFiltersHeight", e), this.addManagedEventListeners({
      displayedColumnsChanged: e,
      columnHeaderHeightChanged: e,
      gridStylesChanged: e,
      advancedFilterEnabledChanged: e
    });
  }
  getHeaderHeight() {
    return this.headerHeight;
  }
  setHeaderHeight() {
    var c;
    const { columnModel: e } = this;
    let t = 0, r = e.getHeaderRowCount(), n;
    ((c = this.filterManager) == null ? void 0 : c.hasFloatingFilters()) && (r++, t = 1);
    const o = this.columnModel.getColumnGroupHeaderRowHeight(), a = this.columnModel.getColumnHeaderRowHeight(), s = 1 + t, l = r - s;
    if (n = t * e.getFloatingFiltersHeight(), n += l * o, n += a, this.headerHeight === n)
      return;
    this.headerHeight = n;
    const u = `${n + 1}px`;
    this.comp.setHeightAndMinHeight(u), this.eventService.dispatchEvent({
      type: "headerHeightChanged"
    });
  }
  onPivotModeChanged() {
    const e = this.columnModel.isPivotMode();
    this.comp.addOrRemoveCssClass("ag-pivot-on", e), this.comp.addOrRemoveCssClass("ag-pivot-off", !e);
  }
  onDisplayedColumnsChanged() {
    const t = this.visibleColsService.getAllCols().some((r) => r.isSpanHeaderHeight());
    this.comp.addOrRemoveCssClass("ag-header-allow-overflow", t);
  }
  onTabKeyDown(e) {
    const t = this.gos.get("enableRtl"), r = e.shiftKey !== t ? 2 : 3;
    (this.headerNavigationService.navigateHorizontally(r, !0, e) || this.focusService.focusNextGridCoreContainer(e.shiftKey)) && e.preventDefault();
  }
  handleKeyDown(e) {
    let t = null;
    switch (e.key) {
      case ae.LEFT:
        t = 2;
      case ae.RIGHT: {
        Me(t) || (t = 3), this.headerNavigationService.navigateHorizontally(t, !1, e);
        break;
      }
      case ae.UP:
        t = 0;
      case ae.DOWN: {
        Me(t) || (t = 1), this.headerNavigationService.navigateVertically(t, null, e) && e.preventDefault();
        break;
      }
      default:
        return;
    }
  }
  onFocusOut(e) {
    const { relatedTarget: t } = e;
    !t && this.eGui.contains(this.gos.getActiveDomElement()) || this.eGui.contains(t) || this.focusService.clearFocusedHeader();
  }
  onHeaderContextMenu(e, t, r) {
    if (!e && !r || !this.menuService.isHeaderContextMenuEnabled())
      return;
    const { target: n } = e ?? t;
    (n === this.eGui || n === this.ctrlsService.getHeaderRowContainerCtrl().getViewport()) && this.menuService.showHeaderContextMenu(void 0, e, r);
  }
  mockContextMenuForIPad(e) {
    if (!su())
      return;
    const t = new Bl(this.eGui), r = (n) => {
      e(void 0, n.touchStart, n.touchEvent);
    };
    this.addManagedListeners(t, { longTap: r }), this.addDestroyFunc(() => t.destroy());
  }
}, kA = class extends he {
  constructor(e, t = !1) {
    super(), this.callback = e, this.addSpacer = t;
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  postConstruct() {
    const e = this.setWidth.bind(this);
    this.addManagedPropertyListener("domLayout", e), this.addManagedEventListeners({
      columnContainerWidthChanged: e,
      displayedColumnsChanged: e,
      leftPinnedWidthChanged: e
    }), this.addSpacer && this.addManagedEventListeners({
      rightPinnedWidthChanged: e,
      scrollVisibilityChanged: e,
      scrollbarWidthChanged: e
    }), this.setWidth();
  }
  setWidth() {
    const e = this.gos.isDomLayout("print"), t = this.visibleColsService.getBodyContainerWidth(), r = this.visibleColsService.getColsLeftWidth(), n = this.visibleColsService.getDisplayedColumnsRightWidth();
    let i;
    e ? i = t + r + n : (i = t, this.addSpacer && (this.gos.get("enableRtl") ? r : n) === 0 && this.scrollVisibleService.isVerticalScrollShowing() && (i += this.gos.getScrollbarWidth())), this.callback(i);
  }
}, Nke = class extends he {
  constructor(e) {
    super(), this.columnsToAggregate = [], this.columnsToGroup = [], this.columnsToPivot = [], this.pinned = e;
  }
  wireBeans(e) {
    this.funcColsService = e.funcColsService;
  }
  /** Callback for when drag enters */
  onDragEnter(e) {
    if (this.clearColumnsList(), this.gos.get("functionsReadOnly"))
      return;
    const t = e.dragItem.columns;
    t && t.forEach((r) => {
      r.isPrimary() && (r.isAnyFunctionActive() || (r.isAllowValue() ? this.columnsToAggregate.push(r) : r.isAllowRowGroup() ? this.columnsToGroup.push(r) : r.isAllowPivot() && this.columnsToPivot.push(r)));
    });
  }
  getIconName() {
    return this.columnsToAggregate.length + this.columnsToGroup.length + this.columnsToPivot.length > 0 ? this.pinned ? "pinned" : "move" : null;
  }
  /** Callback for when drag leaves */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragLeave(e) {
    this.clearColumnsList();
  }
  clearColumnsList() {
    this.columnsToAggregate.length = 0, this.columnsToGroup.length = 0, this.columnsToPivot.length = 0;
  }
  /** Callback for when dragging */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragging(e) {
  }
  /** Callback for when drag stops */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onDragStop(e) {
    this.columnsToAggregate.length > 0 && this.funcColsService.addValueColumns(this.columnsToAggregate, "toolPanelDragAndDrop"), this.columnsToGroup.length > 0 && this.funcColsService.addRowGroupColumns(this.columnsToGroup, "toolPanelDragAndDrop"), this.columnsToPivot.length > 0 && this.funcColsService.addPivotColumns(this.columnsToPivot, "toolPanelDragAndDrop");
  }
};
function VA(e) {
  const {
    isFromHeader: t,
    hDirection: r,
    xPosition: n,
    fromEnter: i,
    fakeEvent: o,
    pinned: a,
    gos: s,
    columnModel: l,
    columnMoveService: u,
    presentedColsService: c
  } = e, d = r === 0, h = r === 1;
  let { allMovingColumns: f } = e;
  if (t) {
    const w = [];
    f.forEach((x) => {
      var _;
      let E = null, R = x.getParent();
      for (; R != null && R.getDisplayedLeafColumns().length === 1; )
        E = R, R = R.getParent();
      E != null ? (!!((_ = E.getColGroupDef()) != null && _.marryChildren) ? (
        // when marry children is true, we also have to move hidden
        // columns within the group, so grab them from the `providedColumnGroup`
        E.getProvidedColumnGroup().getLeafColumns()
      ) : E.getLeafColumns()).forEach((I) => {
        w.includes(I) || w.push(I);
      }) : w.includes(x) || w.push(x);
    }), f = w;
  }
  const p = f.slice();
  l.sortColsLikeCols(p);
  const g = Gke({
    movingCols: p,
    draggingRight: h,
    xPosition: n,
    pinned: a,
    gos: s,
    columnModel: l,
    presentedColsService: c
  }), v = kke(p, l);
  if (g.length === 0)
    return;
  const m = g[0];
  let y = v !== null && !i;
  if (t && (y = v !== null), y && !o && (d && m >= v || h && m <= v))
    return;
  const C = c.getAllCols(), S = [];
  let b = null;
  for (let w = 0; w < g.length; w++) {
    const x = g[w], E = u.getProposedColumnOrder(p, x);
    if (!u.doesOrderPassRules(E))
      continue;
    const R = E.filter((P) => C.includes(P));
    if (b === null)
      b = R;
    else if (!Jc(R, b))
      break;
    const _ = Vke(E);
    S.push({ move: x, fragCount: _ });
  }
  if (S.length !== 0)
    return S.sort((w, x) => w.fragCount - x.fragCount), tY(f, S[0].move, "uiColumnMoved", !1, u);
}
function tY(e, t, r, n, i) {
  return i.moveColumns(e, t, r, n), n ? null : { columns: e, toIndex: t };
}
function kke(e, t) {
  const r = t.getCols(), n = ELe(e.map((l) => r.indexOf(l))), i = n[0];
  return Jt(n) - i !== n.length - 1 ? null : i;
}
function Vke(e) {
  function t(n) {
    const i = [];
    let o = n.getOriginalParent();
    for (; o != null; )
      i.push(o), o = o.getOriginalParent();
    return i;
  }
  let r = 0;
  for (let n = 0; n < e.length - 1; n++) {
    let i = t(e[n]), o = t(e[n + 1]);
    [i, o] = i.length > o.length ? [i, o] : [o, i], i.forEach((a) => {
      o.indexOf(a) === -1 && r++;
    });
  }
  return r;
}
function Bke(e, t) {
  switch (t) {
    case "left":
      return e.getLeftCols();
    case "right":
      return e.getRightCols();
    default:
      return e.getCenterCols();
  }
}
function Gke(e) {
  const { movingCols: t, draggingRight: r, xPosition: n, pinned: i, gos: o, columnModel: a, presentedColsService: s } = e;
  if (o.get("suppressMovableColumns") || t.some((C) => C.getColDef().suppressMovable))
    return [];
  const u = Bke(s, i), c = a.getCols(), d = u.filter((C) => Cc(t, C)), h = u.filter((C) => !Cc(t, C)), f = c.filter((C) => !Cc(t, C));
  let p = 0, g = n;
  if (r) {
    let C = 0;
    d.forEach((S) => C += S.getActualWidth()), g -= C;
  }
  if (g > 0) {
    for (let C = 0; C < h.length; C++) {
      const S = h[C];
      if (g -= S.getActualWidth(), g < 0)
        break;
      p++;
    }
    r && p++;
  }
  let v;
  if (p > 0) {
    const C = h[p - 1];
    v = f.indexOf(C) + 1;
  } else
    v = f.indexOf(h[0]), v === -1 && (v = 0);
  const m = [v], y = (C, S) => C - S;
  if (r) {
    let C = v + 1;
    const S = c.length - 1;
    for (; C <= S; )
      m.push(C), C++;
    m.sort(y);
  } else {
    let C = v;
    const S = c.length - 1;
    let b = c[C];
    for (; C <= S && u.indexOf(b) < 0; )
      C++, m.push(C), b = c[C];
    C = v - 1;
    const w = 0;
    for (; C >= w; )
      m.push(C), C--;
    m.sort(y).reverse();
  }
  return m;
}
function BA(e, t, r, n, i) {
  const o = i.getHeaderRowContainerCtrl(t).getViewport();
  return r && (e -= o.getBoundingClientRect().left), n.get("enableRtl") && (e = o.clientWidth - e), t == null && (e += i.get("center").getCenterViewportScrollLeft()), e;
}
var Hke = class extends he {
  constructor(e) {
    super(), this.needToMoveLeft = !1, this.needToMoveRight = !1, this.lastMovedInfo = null, this.pinned = e, this.isCenterContainer = !Me(e);
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnMoveService = e.columnMoveService, this.dragAndDropService = e.dragAndDropService, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  getIconName() {
    return this.pinned ? "pinned" : "move";
  }
  onDragEnter(e) {
    const t = e.dragItem.columns;
    if (e.dragSource.type === 0)
      this.setColumnsVisible(t, !0, "uiColumnDragged");
    else {
      const n = e.dragItem.visibleState, i = (t || []).filter((o) => n[o.getId()]);
      this.setColumnsVisible(i, !0, "uiColumnDragged");
    }
    this.setColumnsPinned(t, this.pinned, "uiColumnDragged"), this.onDragging(e, !0, !0);
  }
  onDragLeave() {
    this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  setColumnsVisible(e, t, r) {
    if (e) {
      const n = e.filter((i) => !i.getColDef().lockVisible);
      this.columnModel.setColsVisible(n, t, r);
    }
  }
  setColumnsPinned(e, t, r) {
    if (e) {
      const n = e.filter((i) => !i.getColDef().lockPinned);
      this.columnModel.setColsPinned(n, t, r);
    }
  }
  onDragStop() {
    this.onDragging(this.lastDraggingEvent, !1, !0, !0), this.ensureIntervalCleared(), this.lastMovedInfo = null;
  }
  checkCenterForScrolling(e) {
    if (this.isCenterContainer) {
      const t = this.ctrlsService.get("center"), r = t.getCenterViewportScrollLeft(), n = r + t.getCenterWidth();
      this.gos.get("enableRtl") ? (this.needToMoveRight = e < r + 50, this.needToMoveLeft = e > n - 50) : (this.needToMoveLeft = e < r + 50, this.needToMoveRight = e > n - 50), this.needToMoveLeft || this.needToMoveRight ? this.ensureIntervalStarted() : this.ensureIntervalCleared();
    }
  }
  onDragging(e = this.lastDraggingEvent, t = !1, r = !1, n = !1) {
    var u;
    if (n) {
      if (this.lastMovedInfo) {
        const { columns: c, toIndex: d } = this.lastMovedInfo;
        tY(c, d, "uiColumnMoved", !0, this.columnMoveService);
      }
      return;
    }
    if (this.lastDraggingEvent = e, Zt(e.hDirection))
      return;
    const i = BA(e.x, this.pinned, !1, this.gos, this.ctrlsService);
    t || this.checkCenterForScrolling(i);
    const o = this.normaliseDirection(e.hDirection), a = e.dragSource.type, s = ((u = e.dragSource.getDragItem().columns) == null ? void 0 : u.filter((c) => c.getColDef().lockPinned ? c.getPinned() == this.pinned : !0)) || [], l = VA({
      allMovingColumns: s,
      isFromHeader: a === 1,
      hDirection: o,
      xPosition: i,
      pinned: this.pinned,
      fromEnter: t,
      fakeEvent: r,
      gos: this.gos,
      columnModel: this.columnModel,
      columnMoveService: this.columnMoveService,
      presentedColsService: this.visibleColsService
    });
    l && (this.lastMovedInfo = l);
  }
  normaliseDirection(e) {
    if (this.gos.get("enableRtl"))
      switch (e) {
        case 0:
          return 1;
        case 1:
          return 0;
        default:
          sr(`Unknown direction ${e}`);
      }
    else
      return e;
  }
  ensureIntervalStarted() {
    this.movingIntervalId || (this.intervalCount = 0, this.failedMoveAttempts = 0, this.movingIntervalId = window.setInterval(this.moveInterval.bind(this), 100), this.dragAndDropService.setGhostIcon(this.needToMoveLeft ? "left" : "right", !0));
  }
  ensureIntervalCleared() {
    this.movingIntervalId && (window.clearInterval(this.movingIntervalId), this.movingIntervalId = null, this.dragAndDropService.setGhostIcon("move"));
  }
  moveInterval() {
    let e;
    this.intervalCount++, e = 10 + this.intervalCount * 5, e > 100 && (e = 100);
    let t = null;
    const r = this.gridBodyCon.getScrollFeature();
    if (this.needToMoveLeft ? t = r.scrollHorizontally(-e) : this.needToMoveRight && (t = r.scrollHorizontally(e)), t !== 0)
      this.onDragging(this.lastDraggingEvent), this.failedMoveAttempts = 0;
    else {
      this.failedMoveAttempts++;
      const i = this.lastDraggingEvent.dragItem.columns.filter((o) => !o.getColDef().lockPinned);
      if (i.length > 0 && (this.dragAndDropService.setGhostIcon("pinned"), this.failedMoveAttempts > 7)) {
        const o = this.needToMoveLeft ? "left" : "right";
        this.setColumnsPinned(i, o, "uiColumnDragged"), this.dragAndDropService.nudge();
      }
    }
  }
}, zke = class extends he {
  wireBeans(e) {
    this.dragAndDropService = e.dragAndDropService, this.columnModel = e.columnModel, this.ctrlsService = e.ctrlsService;
  }
  constructor(e, t) {
    super(), this.pinned = e, this.eContainer = t;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      switch (this.pinned) {
        case "left":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.left.getContainerElement()],
            [e.bottomLeft.getContainerElement()],
            [e.topLeft.getContainerElement()]
          ];
          break;
        case "right":
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.right.getContainerElement()],
            [e.bottomRight.getContainerElement()],
            [e.topRight.getContainerElement()]
          ];
          break;
        default:
          this.eSecondaryContainers = [
            [e.gridBodyCtrl.getBodyViewportElement(), e.center.getViewportElement()],
            [e.bottomCenter.getViewportElement()],
            [e.topCenter.getViewportElement()]
          ];
          break;
      }
    }), this.moveColumnFeature = this.createManagedBean(new Hke(this.pinned)), this.bodyDropPivotTarget = this.createManagedBean(new Nke(this.pinned)), this.dragAndDropService.addDropTarget(this);
  }
  isInterestedIn(e) {
    return e === 1 || e === 0 && this.gos.get("allowDragFromColumnsToolPanel");
  }
  getSecondaryContainers() {
    return this.eSecondaryContainers;
  }
  getContainer() {
    return this.eContainer;
  }
  getIconName() {
    return this.currentDropListener.getIconName();
  }
  // we want to use the bodyPivotTarget if the user is dragging columns in from the toolPanel
  // and we are in pivot mode, as it has to logic to set pivot/value/group on the columns when
  // dropped into the grid's body.
  isDropColumnInPivotMode(e) {
    return this.columnModel.isPivotMode() && e.dragSource.type === 0;
  }
  onDragEnter(e) {
    this.currentDropListener = this.isDropColumnInPivotMode(e) ? this.bodyDropPivotTarget : this.moveColumnFeature, this.currentDropListener.onDragEnter(e);
  }
  onDragLeave(e) {
    this.currentDropListener.onDragLeave(e);
  }
  onDragging(e) {
    this.currentDropListener.onDragging(e);
  }
  onDragStop(e) {
    this.currentDropListener.onDragStop(e);
  }
}, $ke = class extends he {
  wireBeans(e) {
    this.horizontalResizeService = e.horizontalResizeService, this.pinnedWidthService = e.pinnedWidthService, this.ctrlsService = e.ctrlsService, this.columnSizeService = e.columnSizeService, this.columnAutosizeService = e.columnAutosizeService;
  }
  constructor(e, t, r, n, i) {
    super(), this.pinned = e, this.column = t, this.eResize = r, this.comp = n, this.ctrl = i;
  }
  postConstruct() {
    const e = [];
    let t, r;
    const n = () => {
      if (jr(this.eResize, t), !t)
        return;
      const a = this.horizontalResizeService.addResizeBar({
        eResizeBar: this.eResize,
        onResizeStart: this.onResizeStart.bind(this),
        onResizing: this.onResizing.bind(this, !1),
        onResizeEnd: this.onResizing.bind(this, !0)
      });
      if (e.push(a), r) {
        const s = this.gos.get("skipHeaderOnAutoSize"), l = () => {
          this.columnAutosizeService.autoSizeColumn(this.column, "uiColumnResized", s);
        };
        this.eResize.addEventListener("dblclick", l);
        const u = new Bl(this.eResize);
        u.addEventListener("doubleTap", l), e.push(() => {
          this.eResize.removeEventListener("dblclick", l), u.removeEventListener("doubleTap", l), u.destroy();
        });
      }
    }, i = () => {
      e.forEach((a) => a()), e.length = 0;
    }, o = () => {
      const a = this.column.isResizable(), s = !this.gos.get("suppressAutoSize") && !this.column.getColDef().suppressAutoSize;
      (a !== t || s !== r) && (t = a, r = s, i(), n());
    };
    o(), this.addDestroyFunc(i), this.ctrl.addRefreshFunction(o);
  }
  onResizing(e, t) {
    const { column: r, lastResizeAmount: n, resizeStartWidth: i } = this, o = this.normaliseResizeAmount(t), a = i + o, s = [{ key: r, newWidth: a }];
    if (this.column.getPinned()) {
      const l = this.pinnedWidthService.getPinnedLeftWidth(), u = this.pinnedWidthService.getPinnedRightWidth(), c = Yv(this.ctrlsService.getGridBodyCtrl().getBodyViewportElement()) - 50;
      if (l + u + (o - n) > c)
        return;
    }
    this.lastResizeAmount = o, this.columnSizeService.setColumnWidths(s, this.resizeWithShiftKey, e, "uiColumnResized"), e && this.toggleColumnResizing(!1);
  }
  onResizeStart(e) {
    this.resizeStartWidth = this.column.getActualWidth(), this.lastResizeAmount = 0, this.resizeWithShiftKey = e, this.toggleColumnResizing(!0);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderGroupCell - should refactor out?
  normaliseResizeAmount(e) {
    let t = e;
    const r = this.pinned !== "left", n = this.pinned === "right";
    return this.gos.get("enableRtl") ? r && (t *= -1) : n && (t *= -1), t;
  }
}, Wke = class extends he {
  constructor(e) {
    super(), this.cbSelectAllVisible = !1, this.processingEventFromCheckbox = !1, this.column = e;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  onSpaceKeyDown(e) {
    const t = this.cbSelectAll;
    t.isDisplayed() && !t.getGui().contains(this.gos.getActiveDomElement()) && (e.preventDefault(), t.setValue(!t.getValue()));
  }
  getCheckboxGui() {
    return this.cbSelectAll.getGui();
  }
  setComp(e) {
    this.headerCellCtrl = e, this.cbSelectAll = this.createManagedBean(new _A()), this.cbSelectAll.addCssClass("ag-header-select-all"), Sa(this.cbSelectAll.getGui(), "presentation"), this.showOrHideSelectAll(), this.addManagedEventListeners({
      newColumnsLoaded: this.onNewColumnsLoaded.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      selectionChanged: this.onSelectionChanged.bind(this),
      paginationChanged: this.onSelectionChanged.bind(this),
      modelUpdated: this.onModelChanged.bind(this)
    }), this.addManagedListeners(this.cbSelectAll, { fieldValueChanged: this.onCbSelectAll.bind(this) }), yA(this.cbSelectAll.getGui(), !0), this.cbSelectAll.getInputElement().setAttribute("tabindex", "-1"), this.refreshSelectAllLabel();
  }
  onNewColumnsLoaded() {
    this.showOrHideSelectAll();
  }
  onDisplayedColumnsChanged() {
    this.isAlive() && this.showOrHideSelectAll();
  }
  showOrHideSelectAll() {
    this.cbSelectAllVisible = this.isCheckboxSelection(), this.cbSelectAll.setDisplayed(this.cbSelectAllVisible, { skipAriaHidden: !0 }), this.cbSelectAllVisible && (this.checkRightRowModelType("selectAllCheckbox"), this.checkSelectionType("selectAllCheckbox"), this.updateStateOfCheckbox()), this.refreshSelectAllLabel();
  }
  onModelChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  onSelectionChanged() {
    this.cbSelectAllVisible && this.updateStateOfCheckbox();
  }
  updateStateOfCheckbox() {
    if (this.processingEventFromCheckbox)
      return;
    this.processingEventFromCheckbox = !0;
    const e = this.selectionService.getSelectAllState(this.isFilteredOnly(), this.isCurrentPageOnly());
    this.cbSelectAll.setValue(e);
    const t = this.selectionService.hasNodesToSelect(
      this.isFilteredOnly(),
      this.isCurrentPageOnly()
    );
    this.cbSelectAll.setDisabled(!t), this.refreshSelectAllLabel(), this.processingEventFromCheckbox = !1;
  }
  refreshSelectAllLabel() {
    const e = this.localeService.getLocaleTextFunc(), r = this.cbSelectAll.getValue() ? e("ariaChecked", "checked") : e("ariaUnchecked", "unchecked"), n = e("ariaRowSelectAll", "Press Space to toggle all rows selection");
    this.cbSelectAllVisible ? this.headerCellCtrl.setAriaDescriptionProperty("selectAll", `${n} (${r})`) : this.headerCellCtrl.setAriaDescriptionProperty("selectAll", null), this.cbSelectAll.setInputAriaLabel(`${n} (${r})`), this.headerCellCtrl.announceAriaDescription();
  }
  checkSelectionType(e) {
    return this.gos.get("rowSelection") === "multiple" ? !0 : (Se(`${e} is only available if using 'multiple' rowSelection.`), !1);
  }
  checkRightRowModelType(e) {
    const t = this.rowModel.getType();
    return t === "clientSide" || t === "serverSide" ? !0 : (Se(
      `${e} is only available if using 'clientSide' or 'serverSide' rowModelType, you are using ${t}.`
    ), !1);
  }
  onCbSelectAll() {
    if (this.processingEventFromCheckbox || !this.cbSelectAllVisible)
      return;
    const e = this.cbSelectAll.getValue(), t = this.isFilteredOnly(), r = this.isCurrentPageOnly();
    let n = "uiSelectAll";
    r ? n = "uiSelectAllCurrentPage" : t && (n = "uiSelectAllFiltered");
    const i = {
      source: n,
      justFiltered: t,
      justCurrentPage: r
    };
    e ? this.selectionService.selectAllRowNodes(i) : this.selectionService.deselectAllRowNodes(i);
  }
  isCheckboxSelection() {
    let e = this.column.getColDef().headerCheckboxSelection;
    if (typeof e == "function") {
      const t = e, r = this.gos.addGridCommonParams({
        column: this.column,
        colDef: this.column.getColDef()
      });
      e = t(r);
    }
    return e ? this.checkRightRowModelType("headerCheckboxSelection") && this.checkSelectionType("headerCheckboxSelection") : !1;
  }
  isFilteredOnly() {
    return !!this.column.getColDef().headerCheckboxSelectionFilteredOnly;
  }
  isCurrentPageOnly() {
    return !!this.column.getColDef().headerCheckboxSelectionCurrentPageOnly;
  }
}, jke = class extends mw {
  constructor(e, t, r) {
    super(e, t, r), this.refreshFunctions = [], this.userHeaderClasses = /* @__PURE__ */ new Set(), this.ariaDescriptionProperties = /* @__PURE__ */ new Map(), this.column = e;
  }
  setComp(e, t, r, n) {
    this.comp = e, this.setGui(t), this.updateState(), this.setupWidth(), this.setupMovingCss(), this.setupMenuClass(), this.setupSortableClass(), this.setupWrapTextClass(), this.refreshSpanHeaderHeight(), this.setupAutoHeight(n), this.addColumnHoverListener(), this.setupFilterClass(), this.setupClassesFromColDef(), this.setupTooltip(), this.addActiveHeaderMouseListeners(), this.setupSelectAll(), this.setupUserComp(), this.refreshAria(), this.resizeFeature = this.createManagedBean(
      new $ke(this.getPinned(), this.column, r, e, this)
    ), this.createManagedBean(new LA([this.column], t)), this.createManagedBean(new FA(this.column, t, this.beans)), this.createManagedBean(
      new td(t, {
        shouldStopEventPropagation: (i) => this.shouldStopEventPropagation(i),
        onTabKeyDown: () => null,
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this),
        onFocusOut: this.onFocusOut.bind(this)
      })
    ), this.addResizeAndMoveKeyboardListeners(), this.addManagedPropertyListeners(
      ["suppressMovableColumns", "suppressMenuHide", "suppressAggFuncInHeader"],
      this.refresh.bind(this)
    ), this.addManagedListeners(this.column, { colDefChanged: this.refresh.bind(this) }), this.addManagedEventListeners({
      columnValueChanged: this.onColumnValueChanged.bind(this),
      columnRowGroupChanged: this.onColumnRowGroupChanged.bind(this),
      columnPivotChanged: this.onColumnPivotChanged.bind(this),
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    });
  }
  resizeHeader(e, t) {
    if (!this.column.isResizable())
      return;
    const r = this.column.getActualWidth(), n = this.column.getMinWidth(), i = this.column.getMaxWidth(), o = Math.min(Math.max(r + e, n), i);
    this.beans.columnSizeService.setColumnWidths(
      [{ key: this.column, newWidth: o }],
      t,
      !0,
      "uiColumnResized"
    );
  }
  moveHeader(e) {
    const { eGui: t, column: r, gos: n, ctrlsService: i } = this, o = this.getPinned(), a = t.getBoundingClientRect().left, s = r.getActualWidth(), l = n.get("enableRtl"), c = BA(e === 0 !== l ? a - 20 : a + s + 20, o, !0, n, i);
    VA({
      allMovingColumns: [r],
      isFromHeader: !0,
      hDirection: e,
      xPosition: c,
      pinned: o,
      fromEnter: !1,
      fakeEvent: !1,
      gos: n,
      columnModel: this.beans.columnModel,
      columnMoveService: this.beans.columnMoveService,
      presentedColsService: this.beans.visibleColsService
    }), i.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(r, "auto");
  }
  setupUserComp() {
    const e = this.lookupUserCompDetails();
    this.setCompDetails(e);
  }
  setCompDetails(e) {
    this.userCompDetails = e, this.comp.setUserCompDetails(e);
  }
  lookupUserCompDetails() {
    const e = this.createParams(), t = this.column.getColDef();
    return this.userComponentFactory.getHeaderCompDetails(t, e);
  }
  createParams() {
    return this.gos.addGridCommonParams({
      column: this.column,
      displayName: this.displayName,
      enableSorting: this.column.isSortable(),
      enableMenu: this.menuEnabled,
      enableFilterButton: this.openFilterEnabled && this.menuService.isHeaderFilterButtonEnabled(this.column),
      enableFilterIcon: !this.openFilterEnabled || this.menuService.isLegacyMenuEnabled(),
      showColumnMenu: (t) => {
        this.menuService.showColumnMenu({
          column: this.column,
          buttonElement: t,
          positionBy: "button"
        });
      },
      showColumnMenuAfterMouseClick: (t) => {
        this.menuService.showColumnMenu({
          column: this.column,
          mouseEvent: t,
          positionBy: "mouse"
        });
      },
      showFilter: (t) => {
        this.menuService.showFilterMenu({
          column: this.column,
          buttonElement: t,
          containerType: "columnFilter",
          positionBy: "button"
        });
      },
      progressSort: (t) => {
        this.beans.sortController.progressSort(this.column, !!t, "uiColumnSorted");
      },
      setSort: (t, r) => {
        this.beans.sortController.setSortForColumn(this.column, t, !!r, "uiColumnSorted");
      },
      eGridHeader: this.getGui(),
      setTooltip: (t, r) => {
        this.setupTooltip(t, r);
      }
    });
  }
  setupSelectAll() {
    this.selectAllFeature = this.createManagedBean(new Wke(this.column)), this.selectAllFeature.setComp(this);
  }
  getSelectAllGui() {
    return this.selectAllFeature.getCheckboxGui();
  }
  handleKeyDown(e) {
    super.handleKeyDown(e), e.key === ae.SPACE && this.selectAllFeature.onSpaceKeyDown(e), e.key === ae.ENTER && this.onEnterKeyDown(e), e.key === ae.DOWN && e.altKey && this.showMenuOnKeyPress(e, !1);
  }
  onEnterKeyDown(e) {
    if (e.ctrlKey || e.metaKey)
      this.showMenuOnKeyPress(e, !0);
    else if (this.sortable) {
      const t = e.shiftKey;
      this.beans.sortController.progressSort(this.column, t, "uiColumnSorted");
    }
  }
  showMenuOnKeyPress(e, t) {
    const r = this.comp.getUserCompInstance();
    !r || !(r instanceof PT) || r.onMenuKeyboardShortcut(t) && e.preventDefault();
  }
  onFocusIn(e) {
    if (!this.getGui().contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.focusService.setFocusedHeader(t, this.column), this.announceAriaDescription();
    }
    this.focusService.isKeyboardMode() && this.setActiveHeader(!0);
  }
  onFocusOut(e) {
    this.getGui().contains(e.relatedTarget) || this.setActiveHeader(!1);
  }
  setupTooltip(e, t) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const r = this.gos.get("tooltipShowMode") === "whenTruncated", n = this.eGui, i = this.column.getColDef();
    !t && r && !i.headerComponent && (t = () => {
      const s = n.querySelector(".ag-header-cell-text");
      return s ? s.scrollWidth > s.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getGui: () => n,
      getLocation: () => "header",
      getTooltipValue: () => e ?? this.column.getColDef().headerTooltip,
      shouldDisplayTooltip: t
    }, a = this.createManagedBean(new bf(o));
    this.refreshFunctions.push(() => a.refreshToolTip());
  }
  setupClassesFromColDef() {
    const e = () => {
      const t = this.column.getColDef(), r = UK(t, this.gos, this.column, null), n = this.userHeaderClasses;
      this.userHeaderClasses = new Set(r), r.forEach((i) => {
        n.has(i) ? n.delete(i) : this.comp.addOrRemoveCssClass(i, !0);
      }), n.forEach((i) => this.comp.addOrRemoveCssClass(i, !1));
    };
    this.refreshFunctions.push(e), e();
  }
  setDragSource(e) {
    if (this.dragSourceElement = e, this.removeDragSource(), !e || !this.draggable)
      return;
    const { column: t, beans: r, displayName: n, dragAndDropService: i, gos: o } = this, { columnModel: a } = r;
    let s = !this.gos.get("suppressDragLeaveHidesColumns");
    const l = this.dragSource = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => s ? "hide" : "notAllowed",
      getDragItem: () => this.createDragItem(t),
      dragItemName: n,
      onDragStarted: () => {
        s = !o.get("suppressDragLeaveHidesColumns"), t.setMoving(!0, "uiColumnMoved");
      },
      onDragStopped: () => t.setMoving(!1, "uiColumnMoved"),
      onGridEnter: (u) => {
        var c;
        if (s) {
          const d = ((c = u == null ? void 0 : u.columns) == null ? void 0 : c.filter((h) => !h.getColDef().lockVisible)) || [];
          a.setColsVisible(d, !0, "uiColumnMoved");
        }
      },
      onGridExit: (u) => {
        var c;
        if (s) {
          const d = ((c = u == null ? void 0 : u.columns) == null ? void 0 : c.filter((h) => !h.getColDef().lockVisible)) || [];
          a.setColsVisible(d, !1, "uiColumnMoved");
        }
      }
    };
    i.addDragSource(l, !0);
  }
  createDragItem(e) {
    const t = {};
    return t[e.getId()] = e.isVisible(), {
      columns: [e],
      visibleState: t
    };
  }
  updateState() {
    this.menuEnabled = this.menuService.isColumnMenuInHeaderEnabled(this.column), this.openFilterEnabled = this.menuService.isFilterMenuInHeaderEnabled(this.column), this.sortable = this.column.isSortable(), this.displayName = this.calculateDisplayName(), this.draggable = this.workOutDraggable();
  }
  addRefreshFunction(e) {
    this.refreshFunctions.push(e);
  }
  refresh() {
    this.updateState(), this.refreshHeaderComp(), this.refreshAria(), this.refreshFunctions.forEach((e) => e());
  }
  refreshHeaderComp() {
    const e = this.lookupUserCompDetails();
    (this.comp.getUserCompInstance() != null && this.userCompDetails.componentClass == e.componentClass ? this.attemptHeaderCompRefresh(e.params) : !1) ? this.setDragSource(this.dragSourceElement) : this.setCompDetails(e);
  }
  attemptHeaderCompRefresh(e) {
    const t = this.comp.getUserCompInstance();
    return !t || !t.refresh ? !1 : t.refresh(e);
  }
  calculateDisplayName() {
    return this.beans.columnNameService.getDisplayNameForColumn(this.column, "header", !0);
  }
  checkDisplayName() {
    this.displayName !== this.calculateDisplayName() && this.refresh();
  }
  workOutDraggable() {
    const e = this.column.getColDef();
    return !!(!this.gos.get("suppressMovableColumns") && !e.suppressMovable && !e.lockPosition) || !!e.enableRowGroup || !!e.enablePivot;
  }
  onColumnRowGroupChanged() {
    this.checkDisplayName();
  }
  onColumnPivotChanged() {
    this.checkDisplayName();
  }
  onColumnValueChanged() {
    this.checkDisplayName();
  }
  setupWidth() {
    const e = () => {
      const t = this.column.getActualWidth();
      this.comp.setWidth(`${t}px`);
    };
    this.addManagedListeners(this.column, { widthChanged: e }), e();
  }
  setupMovingCss() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    };
    this.addManagedListeners(this.column, { movingChanged: e }), e();
  }
  setupMenuClass() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-column-menu-visible", this.column.isMenuVisible());
    };
    this.addManagedListeners(this.column, { menuVisibleChanged: e }), e();
  }
  setupSortableClass() {
    const e = () => {
      this.comp.addOrRemoveCssClass("ag-header-cell-sortable", !!this.sortable);
    };
    e(), this.addRefreshFunction(e), this.addManagedEventListeners({ sortChanged: this.refreshAriaSort.bind(this) });
  }
  setupFilterClass() {
    const e = () => {
      const t = this.column.isFilterActive();
      this.comp.addOrRemoveCssClass("ag-header-cell-filtered", t), this.refreshAria();
    };
    this.addManagedListeners(this.column, { filterActiveChanged: e }), e();
  }
  setupWrapTextClass() {
    const e = () => {
      const t = !!this.column.getColDef().wrapHeaderText;
      this.comp.addOrRemoveCssClass("ag-header-cell-wrap-text", t);
    };
    e(), this.addRefreshFunction(e);
  }
  onDisplayedColumnsChanged() {
    super.onDisplayedColumnsChanged(), this.isAlive() && this.onHeaderHeightChanged();
  }
  onHeaderHeightChanged() {
    this.refreshSpanHeaderHeight();
  }
  refreshSpanHeaderHeight() {
    const { eGui: e, column: t, comp: r, beans: n } = this;
    if (!t.isSpanHeaderHeight()) {
      e.style.removeProperty("top"), e.style.removeProperty("height"), r.addOrRemoveCssClass("ag-header-span-height", !1), r.addOrRemoveCssClass("ag-header-span-total", !1);
      return;
    }
    const { numberOfParents: i, isSpanningTotal: o } = this.column.getColumnGroupPaddingInfo();
    r.addOrRemoveCssClass("ag-header-span-height", i > 0);
    const { columnModel: a } = n, s = a.getColumnHeaderRowHeight();
    if (i === 0) {
      r.addOrRemoveCssClass("ag-header-span-total", !1), e.style.setProperty("top", "0px"), e.style.setProperty("height", `${s}px`);
      return;
    }
    r.addOrRemoveCssClass("ag-header-span-total", o);
    const u = a.isPivotMode() ? a.getPivotGroupHeaderHeight() : a.getGroupHeaderHeight(), c = i * u;
    e.style.setProperty("top", `${-c}px`), e.style.setProperty("height", `${s + c}px`);
  }
  setupAutoHeight(e) {
    const { columnModel: t, resizeObserverService: r } = this.beans, n = (u) => {
      if (!this.isAlive())
        return;
      const { paddingTop: c, paddingBottom: d, borderBottomWidth: h, borderTopWidth: f } = ed(this.getGui()), p = c + d + h + f, v = e.offsetHeight + p;
      if (u < 5) {
        const m = this.beans.gos.getDocument(), y = !m || !m.contains(e), C = v == 0;
        if (y || C) {
          window.setTimeout(() => n(u + 1), 0);
          return;
        }
      }
      t.setColHeaderHeight(this.column, v);
    };
    let i = !1, o;
    const a = () => {
      const u = this.column.isAutoHeaderHeight();
      u && !i && s(), !u && i && l();
    }, s = () => {
      i = !0, n(0), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !0), o = r.observeResize(e, () => n(0));
    }, l = () => {
      i = !1, o && o(), this.comp.addOrRemoveCssClass("ag-header-cell-auto-height", !1), o = void 0;
    };
    a(), this.addDestroyFunc(() => l()), this.addManagedListeners(this.column, { widthChanged: () => i && n(0) }), this.addManagedEventListeners({
      sortChanged: () => {
        i && window.setTimeout(() => n(0));
      }
    }), this.addRefreshFunction(a);
  }
  refreshAriaSort() {
    if (this.sortable) {
      const e = this.localeService.getLocaleTextFunc(), t = this.beans.sortController.getDisplaySortForColumn(this.column) || null;
      this.comp.setAriaSort(lOe(t)), this.setAriaDescriptionProperty("sort", e("ariaSortableColumn", "Press ENTER to sort"));
    } else
      this.comp.setAriaSort(), this.setAriaDescriptionProperty("sort", null);
  }
  refreshAriaMenu() {
    if (this.menuEnabled) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty("menu", e("ariaMenuColumn", "Press ALT DOWN to open column menu"));
    } else
      this.setAriaDescriptionProperty("menu", null);
  }
  refreshAriaFilterButton() {
    if (this.openFilterEnabled && !this.menuService.isLegacyMenuEnabled()) {
      const e = this.localeService.getLocaleTextFunc();
      this.setAriaDescriptionProperty(
        "filterButton",
        e("ariaFilterColumn", "Press CTRL ENTER to open filter")
      );
    } else
      this.setAriaDescriptionProperty("filterButton", null);
  }
  refreshAriaFiltered() {
    const e = this.localeService.getLocaleTextFunc();
    this.column.isFilterActive() ? this.setAriaDescriptionProperty("filter", e("ariaColumnFiltered", "Column Filtered")) : this.setAriaDescriptionProperty("filter", null);
  }
  setAriaDescriptionProperty(e, t) {
    t != null ? this.ariaDescriptionProperties.set(e, t) : this.ariaDescriptionProperties.delete(e);
  }
  announceAriaDescription() {
    if (!this.eGui.contains(this.beans.gos.getActiveDomElement()))
      return;
    const e = Array.from(this.ariaDescriptionProperties.keys()).sort((t, r) => t === "filter" ? -1 : r.charCodeAt(0) - t.charCodeAt(0)).map((t) => this.ariaDescriptionProperties.get(t)).join(". ");
    this.beans.ariaAnnouncementService.announceValue(e);
  }
  refreshAria() {
    this.refreshAriaSort(), this.refreshAriaMenu(), this.refreshAriaFilterButton(), this.refreshAriaFiltered();
  }
  addColumnHoverListener() {
    const e = () => {
      if (!this.gos.get("columnHoverHighlight"))
        return;
      const t = this.beans.columnHoverService.isHovered(this.column);
      this.comp.addOrRemoveCssClass("ag-column-hover", t);
    };
    this.addManagedEventListeners({ columnHoverChanged: e }), e();
  }
  getColId() {
    return this.column.getColId();
  }
  addActiveHeaderMouseListeners() {
    const e = (n) => this.handleMouseOverChange(n.type === "mouseenter"), t = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column), r = (n) => this.handleContextMenuMouseEvent(n, void 0, this.column);
    this.addManagedListeners(this.getGui(), {
      mouseenter: e,
      mouseleave: e,
      click: t,
      contextmenu: r
    });
  }
  handleMouseOverChange(e) {
    this.setActiveHeader(e);
    const r = {
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column
    };
    this.eventService.dispatchEvent(r);
  }
  setActiveHeader(e) {
    this.comp.addOrRemoveCssClass("ag-header-active", e);
  }
  getAnchorElementForMenu(e) {
    const t = this.comp.getUserCompInstance();
    return t instanceof PT ? t.getAnchorElementForMenu(e) : this.getGui();
  }
  destroy() {
    super.destroy(), this.refreshFunctions = null, this.selectAllFeature = null, this.dragSourceElement = null, this.userCompDetails = null, this.userHeaderClasses = null, this.ariaDescriptionProperties = null;
  }
}, Uke = class extends he {
  wireBeans(e) {
    this.horizontalResizeService = e.horizontalResizeService, this.autoWidthCalculator = e.autoWidthCalculator, this.visibleColsService = e.visibleColsService, this.columnSizeService = e.columnSizeService, this.columnAutosizeService = e.columnAutosizeService;
  }
  constructor(e, t, r, n) {
    super(), this.eResize = t, this.comp = e, this.pinned = r, this.columnGroup = n;
  }
  postConstruct() {
    if (!this.columnGroup.isResizable()) {
      this.comp.setResizableDisplayed(!1);
      return;
    }
    const e = this.horizontalResizeService.addResizeBar({
      eResizeBar: this.eResize,
      onResizeStart: this.onResizeStart.bind(this),
      onResizing: this.onResizing.bind(this, !1),
      onResizeEnd: this.onResizing.bind(this, !0)
    });
    if (this.addDestroyFunc(e), !this.gos.get("suppressAutoSize")) {
      const t = this.gos.get("skipHeaderOnAutoSize");
      this.eResize.addEventListener("dblclick", () => {
        const r = [];
        this.columnGroup.getDisplayedLeafColumns().forEach((i) => {
          i.getColDef().suppressAutoSize || r.push(i.getColId());
        }), r.length > 0 && this.columnAutosizeService.autoSizeCols({
          colKeys: r,
          skipHeader: t,
          stopAtGroup: this.columnGroup,
          source: "uiColumnResized"
        }), this.resizeLeafColumnsToFit("uiColumnResized");
      });
    }
  }
  onResizeStart(e) {
    const t = this.getInitialValues(e);
    this.storeLocalValues(t), this.toggleColumnResizing(!0);
  }
  onResizing(e, t, r = "uiColumnResized") {
    const n = this.normaliseDragChange(t), i = this.resizeStartWidth + n;
    this.resizeColumnsFromLocalValues(i, r, e);
  }
  getInitialValues(e) {
    const t = this.getColumnsToResize(), r = this.getInitialSizeOfColumns(t), n = this.getSizeRatiosOfColumns(t, r), i = {
      columnsToResize: t,
      resizeStartWidth: r,
      resizeRatios: n
    };
    let o = null;
    if (e && (o = this.visibleColsService.getGroupAtDirection(this.columnGroup, "After")), o) {
      const a = o.getDisplayedLeafColumns(), s = i.groupAfterColumns = a.filter(
        (u) => u.isResizable()
      ), l = i.groupAfterStartWidth = this.getInitialSizeOfColumns(s);
      i.groupAfterRatios = this.getSizeRatiosOfColumns(s, l);
    } else
      i.groupAfterColumns = void 0, i.groupAfterStartWidth = void 0, i.groupAfterRatios = void 0;
    return i;
  }
  storeLocalValues(e) {
    const {
      columnsToResize: t,
      resizeStartWidth: r,
      resizeRatios: n,
      groupAfterColumns: i,
      groupAfterStartWidth: o,
      groupAfterRatios: a
    } = e;
    this.resizeCols = t, this.resizeStartWidth = r, this.resizeRatios = n, this.resizeTakeFromCols = i, this.resizeTakeFromStartWidth = o, this.resizeTakeFromRatios = a;
  }
  clearLocalValues() {
    this.resizeCols = void 0, this.resizeRatios = void 0, this.resizeTakeFromCols = void 0, this.resizeTakeFromRatios = void 0;
  }
  resizeLeafColumnsToFit(e) {
    const t = this.autoWidthCalculator.getPreferredWidthForColumnGroup(this.columnGroup), r = this.getInitialValues();
    t > r.resizeStartWidth && this.resizeColumns(r, t, e, !0);
  }
  resizeColumnsFromLocalValues(e, t, r = !0) {
    if (!this.resizeCols || !this.resizeRatios)
      return;
    const n = {
      columnsToResize: this.resizeCols,
      resizeStartWidth: this.resizeStartWidth,
      resizeRatios: this.resizeRatios,
      groupAfterColumns: this.resizeTakeFromCols ?? void 0,
      groupAfterStartWidth: this.resizeTakeFromStartWidth ?? void 0,
      groupAfterRatios: this.resizeTakeFromRatios ?? void 0
    };
    this.resizeColumns(n, e, t, r);
  }
  resizeColumns(e, t, r, n = !0) {
    const {
      columnsToResize: i,
      resizeStartWidth: o,
      resizeRatios: a,
      groupAfterColumns: s,
      groupAfterStartWidth: l,
      groupAfterRatios: u
    } = e, c = [];
    if (c.push({
      columns: i,
      ratios: a,
      width: t
    }), s) {
      const d = t - o;
      c.push({
        columns: s,
        ratios: u,
        width: l - d
      });
    }
    this.columnSizeService.resizeColumnSets({
      resizeSets: c,
      finished: n,
      source: r
    }), n && this.toggleColumnResizing(!1);
  }
  toggleColumnResizing(e) {
    this.comp.addOrRemoveCssClass("ag-column-resizing", e);
  }
  getColumnsToResize() {
    return this.columnGroup.getDisplayedLeafColumns().filter((t) => t.isResizable());
  }
  getInitialSizeOfColumns(e) {
    return e.reduce((t, r) => t + r.getActualWidth(), 0);
  }
  getSizeRatiosOfColumns(e, t) {
    return e.map((r) => r.getActualWidth() / t);
  }
  // optionally inverts the drag, depending on pinned and RTL
  // note - this method is duplicated in RenderedHeaderCell - should refactor out?
  normaliseDragChange(e) {
    let t = e;
    return this.gos.get("enableRtl") ? this.pinned !== "left" && (t *= -1) : this.pinned === "right" && (t *= -1), t;
  }
  destroy() {
    super.destroy(), this.clearLocalValues();
  }
}, Kke = class extends he {
  constructor(e, t) {
    super(), this.removeChildListenersFuncs = [], this.columnGroup = t, this.comp = e;
  }
  postConstruct() {
    this.addListenersToChildrenColumns(), this.addManagedListeners(this.columnGroup, {
      displayedChildrenChanged: this.onDisplayedChildrenChanged.bind(this)
    }), this.onWidthChanged(), this.addDestroyFunc(this.removeListenersOnChildrenColumns.bind(this));
  }
  addListenersToChildrenColumns() {
    this.removeListenersOnChildrenColumns();
    const e = this.onWidthChanged.bind(this);
    this.columnGroup.getLeafColumns().forEach((t) => {
      t.addEventListener("widthChanged", e), t.addEventListener("visibleChanged", e), this.removeChildListenersFuncs.push(() => {
        t.removeEventListener("widthChanged", e), t.removeEventListener("visibleChanged", e);
      });
    });
  }
  removeListenersOnChildrenColumns() {
    this.removeChildListenersFuncs.forEach((e) => e()), this.removeChildListenersFuncs = [];
  }
  onDisplayedChildrenChanged() {
    this.addListenersToChildrenColumns(), this.onWidthChanged();
  }
  onWidthChanged() {
    const e = this.columnGroup.getActualWidth();
    this.comp.setWidth(`${e}px`), this.comp.addOrRemoveCssClass("ag-hidden", e === 0);
  }
}, Yke = class extends mw {
  constructor(e, t, r) {
    super(e, t, r), this.onSuppressColMoveChange = () => {
      if (!this.isAlive() || this.isSuppressMoving())
        this.removeDragSource();
      else if (!this.dragSource) {
        const n = this.getGui();
        this.setDragSource(n);
      }
    }, this.column = e;
  }
  setComp(e, t, r) {
    this.comp = e, this.setGui(t), this.displayName = this.beans.columnNameService.getDisplayNameForColumnGroup(this.column, "header"), this.addClasses(), this.setupMovingCss(), this.setupExpandable(), this.setupTooltip(), this.addDestroyFunc(() => {
      this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    }), this.setupUserComp(), this.addHeaderMouseListeners();
    const n = this.getParentRowCtrl().getPinned(), i = this.column.getProvidedColumnGroup().getLeafColumns();
    this.createManagedBean(new LA(i, t)), this.createManagedBean(new FA(this.column, t, this.beans)), this.createManagedBean(new Kke(e, this.column)), this.resizeFeature = this.createManagedBean(new Uke(e, r, n, this.column)), this.createManagedBean(
      new td(t, {
        shouldStopEventPropagation: this.shouldStopEventPropagation.bind(this),
        onTabKeyDown: () => {
        },
        handleKeyDown: this.handleKeyDown.bind(this),
        onFocusIn: this.onFocusIn.bind(this)
      })
    ), this.addManagedPropertyListener("suppressMovableColumns", this.onSuppressColMoveChange), this.addResizeAndMoveKeyboardListeners();
  }
  resizeHeader(e, t) {
    if (!this.resizeFeature)
      return;
    const r = this.resizeFeature.getInitialValues(t);
    this.resizeFeature.resizeColumns(
      r,
      r.resizeStartWidth + e,
      "uiColumnResized",
      !0
    );
  }
  moveHeader(e) {
    const { beans: t, eGui: r, column: n, gos: i, ctrlsService: o } = this, a = i.get("enableRtl"), s = e === 0, l = this.getPinned(), u = r.getBoundingClientRect(), c = u.left, d = u.width, h = BA(s !== a ? c - 20 : c + d + 20, l, !0, i, o), f = n.getGroupId(), p = this.focusService.getFocusedHeader();
    VA({
      allMovingColumns: this.column.getLeafColumns(),
      isFromHeader: !0,
      hDirection: e,
      xPosition: h,
      pinned: l,
      fromEnter: !1,
      fakeEvent: !1,
      gos: i,
      columnModel: t.columnModel,
      columnMoveService: t.columnMoveService,
      presentedColsService: t.visibleColsService
    });
    const g = n.getDisplayedLeafColumns(), v = s ? g[0] : Jt(g);
    this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(v, "auto"), !this.isAlive() && p && this.restoreFocus(f, n, p);
  }
  restoreFocus(e, t, r) {
    const n = t.getLeafColumns();
    if (!n.length)
      return;
    const i = n[0].getParent();
    if (!i)
      return;
    const o = this.findGroupWidthId(i, e);
    o && this.focusService.focusHeaderPosition({
      headerPosition: {
        ...r,
        column: o
      }
    });
  }
  findGroupWidthId(e, t) {
    for (; e; ) {
      if (e.getGroupId() === t)
        return e;
      e = e.getParent();
    }
    return null;
  }
  resizeLeafColumnsToFit(e) {
    this.resizeFeature && this.resizeFeature.resizeLeafColumnsToFit(e);
  }
  setupUserComp() {
    const e = this.gos.addGridCommonParams({
      displayName: this.displayName,
      columnGroup: this.column,
      setExpanded: (r) => {
        this.beans.columnModel.setColumnGroupOpened(
          this.column.getProvidedColumnGroup(),
          r,
          "gridInitializing"
        );
      },
      setTooltip: (r, n) => {
        this.setupTooltip(r, n);
      }
    }), t = this.userComponentFactory.getHeaderGroupCompDetails(e);
    this.comp.setUserCompDetails(t);
  }
  addHeaderMouseListeners() {
    const e = (n) => this.handleMouseOverChange(n.type === "mouseenter"), t = () => this.dispatchColumnMouseEvent("columnHeaderClicked", this.column.getProvidedColumnGroup()), r = (n) => this.handleContextMenuMouseEvent(n, void 0, this.column.getProvidedColumnGroup());
    this.addManagedListeners(this.getGui(), {
      mouseenter: e,
      mouseleave: e,
      click: t,
      contextmenu: r
    });
  }
  handleMouseOverChange(e) {
    const r = {
      type: e ? "columnHeaderMouseOver" : "columnHeaderMouseLeave",
      column: this.column.getProvidedColumnGroup()
    };
    this.eventService.dispatchEvent(r);
  }
  setupTooltip(e, t) {
    this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature));
    const r = this.column.getColGroupDef(), n = this.gos.get("tooltipShowMode") === "whenTruncated", i = this.eGui;
    !t && n && !(r != null && r.headerGroupComponent) && (t = () => {
      const a = i.querySelector(".ag-header-group-text");
      return a ? a.scrollWidth > a.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getGui: () => i,
      getLocation: () => "headerGroup",
      getTooltipValue: () => e ?? (r && r.headerTooltip),
      shouldDisplayTooltip: t
    };
    r && (o.getColDef = () => r), this.createManagedBean(new bf(o));
  }
  setupExpandable() {
    const e = this.column.getProvidedColumnGroup();
    this.refreshExpanded();
    const t = this.refreshExpanded.bind(this);
    this.addManagedListeners(e, {
      expandedChanged: t,
      expandableChanged: t
    });
  }
  refreshExpanded() {
    const { column: e } = this;
    this.expandable = e.isExpandable();
    const t = e.isExpanded();
    this.expandable ? this.comp.setAriaExpanded(t ? "true" : "false") : this.comp.setAriaExpanded(void 0);
  }
  getColId() {
    return this.column.getUniqueId();
  }
  addClasses() {
    const e = this.column.getColGroupDef(), t = UK(e, this.gos, null, this.column);
    this.column.isPadding() ? (t.push("ag-header-group-cell-no-group"), this.column.getLeafColumns().every((n) => n.isSpanHeaderHeight()) && t.push("ag-header-span-height")) : t.push("ag-header-group-cell-with-group"), t.forEach((r) => this.comp.addOrRemoveCssClass(r, !0));
  }
  setupMovingCss() {
    const t = this.column.getProvidedColumnGroup().getLeafColumns(), r = () => this.comp.addOrRemoveCssClass("ag-header-cell-moving", this.column.isMoving());
    t.forEach((n) => {
      this.addManagedListeners(n, { movingChanged: r });
    }), r();
  }
  onFocusIn(e) {
    if (!this.eGui.contains(e.relatedTarget)) {
      const t = this.getRowIndex();
      this.beans.focusService.setFocusedHeader(t, this.column);
    }
  }
  handleKeyDown(e) {
    super.handleKeyDown(e);
    const t = this.getWrapperHasFocus();
    if (!(!this.expandable || !t) && e.key === ae.ENTER) {
      const r = this.column, n = !r.isExpanded();
      this.beans.columnModel.setColumnGroupOpened(
        r.getProvidedColumnGroup(),
        n,
        "uiColumnExpanded"
      );
    }
  }
  // unlike columns, this will only get called once, as we don't react on props on column groups
  // (we will always destroy and recreate this comp if something changes)
  setDragSource(e) {
    if (!this.isAlive() || this.isSuppressMoving() || (this.removeDragSource(), !e))
      return;
    const { beans: t, column: r, displayName: n, gos: i, dragAndDropService: o } = this, { columnModel: a } = t, s = r.getProvidedColumnGroup().getLeafColumns();
    let l = !i.get("suppressDragLeaveHidesColumns");
    const u = this.dragSource = {
      type: 1,
      eElement: e,
      getDefaultIconName: () => l ? "hide" : "notAllowed",
      dragItemName: n,
      // we add in the original group leaf columns, so we move both visible and non-visible items
      getDragItem: () => this.getDragItemForGroup(r),
      onDragStarted: () => {
        l = !i.get("suppressDragLeaveHidesColumns"), s.forEach((c) => c.setMoving(!0, "uiColumnDragged"));
      },
      onDragStopped: () => s.forEach((c) => c.setMoving(!1, "uiColumnDragged")),
      onGridEnter: (c) => {
        var d;
        if (l) {
          const h = ((d = c == null ? void 0 : c.columns) == null ? void 0 : d.filter((f) => !f.getColDef().lockVisible)) || [];
          a.setColsVisible(h, !0, "uiColumnMoved");
        }
      },
      onGridExit: (c) => {
        var d;
        if (l) {
          const h = ((d = c == null ? void 0 : c.columns) == null ? void 0 : d.filter((f) => !f.getColDef().lockVisible)) || [];
          a.setColsVisible(h, !1, "uiColumnMoved");
        }
      }
    };
    o.addDragSource(u, !0);
  }
  // when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,
  // and in the order they are currently in the screen.
  getDragItemForGroup(e) {
    const t = e.getProvidedColumnGroup().getLeafColumns(), r = {};
    t.forEach((i) => r[i.getId()] = i.isVisible());
    const n = [];
    return this.beans.visibleColsService.getAllCols().forEach((i) => {
      t.indexOf(i) >= 0 && (n.push(i), gi(t, i));
    }), t.forEach((i) => n.push(i)), {
      columns: n,
      visibleState: r
    };
  }
  isSuppressMoving() {
    let e = !1;
    return this.column.getLeafColumns().forEach((r) => {
      (r.getColDef().suppressMovable || r.getColDef().lockPosition) && (e = !0);
    }), e || this.gos.get("suppressMovableColumns");
  }
}, qke = 0, Jx = class extends he {
  constructor(e, t, r) {
    super(), this.instanceId = qke++, this.rowIndex = e, this.pinned = t, this.type = r;
    const n = r == "group" ? "ag-header-row-column-group" : r == "filter" ? "ag-header-row-column-filter" : "ag-header-row-column";
    this.headerRowClass = `ag-header-row ${n}`;
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.isPrintLayout = this.gos.isDomLayout("print"), this.isEnsureDomOrder = this.gos.get("ensureDomOrder");
  }
  getInstanceId() {
    return this.instanceId;
  }
  /** Checks that every header cell that is currently visible has been rendered.
   * Can only be false under some circumstances when using React
   */
  areCellsRendered() {
    return this.comp ? this.getHeaderCellCtrls().every((e) => e.getGui() != null) : !1;
  }
  /**
   *
   * @param comp Proxy to the actual component
   * @param initCompState Should the component be initialised with the current state of the controller. Default: true
   */
  setComp(e, t = !0) {
    this.comp = e, t && (this.onRowHeightChanged(), this.onVirtualColumnsChanged()), this.setWidth(), this.addEventListeners();
  }
  getHeaderRowClass() {
    return this.headerRowClass;
  }
  getAriaRowIndex() {
    return this.rowIndex + 1;
  }
  addEventListeners() {
    const e = this.onRowHeightChanged.bind(this);
    this.addManagedEventListeners({
      columnResized: this.onColumnResized.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: (t) => this.onVirtualColumnsChanged(t.afterScroll),
      columnHeaderHeightChanged: e,
      gridStylesChanged: e,
      advancedFilterEnabledChanged: e
    }), this.addManagedPropertyListener("domLayout", this.onDisplayedColumnsChanged.bind(this)), this.addManagedPropertyListener("ensureDomOrder", (t) => this.isEnsureDomOrder = t.currentValue), this.addManagedPropertyListeners(
      [
        "headerHeight",
        "pivotHeaderHeight",
        "groupHeaderHeight",
        "pivotGroupHeaderHeight",
        "floatingFiltersHeight"
      ],
      e
    );
  }
  getHeaderCellCtrl(e) {
    if (this.headerCellCtrls)
      return p0(this.headerCellCtrls).find((t) => t.getColumnGroupChild() === e);
  }
  onDisplayedColumnsChanged() {
    this.isPrintLayout = this.gos.isDomLayout("print"), this.onVirtualColumnsChanged(), this.setWidth(), this.onRowHeightChanged();
  }
  getType() {
    return this.type;
  }
  onColumnResized() {
    this.setWidth();
  }
  setWidth() {
    const e = this.getWidthForRow();
    this.comp.setWidth(`${e}px`);
  }
  getWidthForRow() {
    const { visibleColsService: e } = this.beans;
    return this.isPrintLayout ? this.pinned != null ? 0 : e.getContainerWidth("right") + e.getContainerWidth("left") + e.getContainerWidth(null) : e.getContainerWidth(this.pinned);
  }
  onRowHeightChanged() {
    const { topOffset: e, rowHeight: t } = this.getTopAndHeight();
    this.comp.setTop(e + "px"), this.comp.setHeight(t + "px");
  }
  getTopAndHeight() {
    const { columnModel: e, filterManager: t } = this.beans;
    let r = e.getHeaderRowCount();
    const n = [];
    let i = 0;
    t != null && t.hasFloatingFilters() && (r++, i = 1);
    const o = e.getColumnGroupHeaderRowHeight(), a = e.getColumnHeaderRowHeight(), s = 1 + i, l = r - s;
    for (let d = 0; d < l; d++)
      n.push(o);
    n.push(a);
    for (let d = 0; d < i; d++)
      n.push(e.getFloatingFiltersHeight());
    let u = 0;
    for (let d = 0; d < this.rowIndex; d++)
      u += n[d];
    const c = n[this.rowIndex];
    return { topOffset: u, rowHeight: c };
  }
  getPinned() {
    return this.pinned;
  }
  getRowIndex() {
    return this.rowIndex;
  }
  onVirtualColumnsChanged(e = !1) {
    const t = this.getHeaderCtrls(), r = this.isEnsureDomOrder || this.isPrintLayout;
    this.comp.setHeaderCtrls(t, r, e);
  }
  getHeaderCtrls() {
    const e = this.headerCellCtrls;
    this.headerCellCtrls = /* @__PURE__ */ new Map();
    const t = this.getColumnsInViewport();
    for (const n of t)
      this.recycleAndCreateHeaderCtrls(n, e);
    const r = (n) => {
      const { focusService: i, visibleColsService: o } = this.beans;
      return i.isHeaderWrapperFocused(n) ? o.isVisible(n.getColumnGroupChild()) : !1;
    };
    if (e)
      for (const [n, i] of e)
        r(i) ? this.headerCellCtrls.set(n, i) : this.destroyBean(i);
    return this.getHeaderCellCtrls();
  }
  getHeaderCellCtrls() {
    var e;
    return Array.from(((e = this.headerCellCtrls) == null ? void 0 : e.values()) ?? []);
  }
  recycleAndCreateHeaderCtrls(e, t) {
    if (!this.headerCellCtrls || e.isEmptyGroup())
      return;
    const r = e.getUniqueId();
    let n;
    if (t && (n = t.get(r), t.delete(r)), n && n.getColumnGroupChild() != e && (this.destroyBean(n), n = void 0), n == null)
      switch (this.type) {
        case "filter": {
          n = this.createBean(
            this.beans.ctrlsFactory.getInstance(
              "headerFilterCell",
              e,
              this.beans,
              this
            )
          );
          break;
        }
        case "group":
          n = this.createBean(
            new Yke(e, this.beans, this)
          );
          break;
        default:
          n = this.createBean(new jke(e, this.beans, this));
          break;
      }
    this.headerCellCtrls.set(r, n);
  }
  getColumnsInViewport() {
    return this.isPrintLayout ? this.getColumnsInViewportPrintLayout() : this.getColumnsInViewportNormalLayout();
  }
  getColumnsInViewportPrintLayout() {
    if (this.pinned != null)
      return [];
    let e = [];
    const t = this.getActualDepth(), { columnViewportService: r } = this.beans;
    return ["left", null, "right"].forEach((n) => {
      const i = r.getHeadersToRender(n, t);
      e = e.concat(i);
    }), e;
  }
  getActualDepth() {
    return this.type == "filter" ? this.rowIndex - 1 : this.rowIndex;
  }
  getColumnsInViewportNormalLayout() {
    return this.beans.columnViewportService.getHeadersToRender(this.pinned, this.getActualDepth());
  }
  findHeaderCellCtrl(e) {
    return this.headerCellCtrls ? this.getHeaderCellCtrls().find((n) => n.getColumnGroupChild() == e) : void 0;
  }
  focusHeader(e, t) {
    const r = this.findHeaderCellCtrl(e);
    return r ? r.focus(t) : !1;
  }
  destroy() {
    this.headerCellCtrls && this.headerCellCtrls.forEach((e) => {
      this.destroyBean(e);
    }), this.headerCellCtrls = void 0, super.destroy();
  }
}, Zke = class extends he {
  constructor(e) {
    super(), this.hidden = !1, this.includeFloatingFilter = !1, this.groupsRowCtrls = [], this.pinned = e;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService, this.pinnedWidthService = e.pinnedWidthService, this.columnModel = e.columnModel, this.focusService = e.focusService, this.filterManager = e.filterManager;
  }
  setComp(e, t) {
    this.comp = e, this.eViewport = t, this.setupCenterWidth(), this.setupPinnedWidth(), this.setupDragAndDrop(this.eViewport);
    const r = this.onDisplayedColumnsChanged.bind(this);
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      displayedColumnsChanged: r,
      advancedFilterEnabledChanged: r
    }), this.ctrlsService.registerHeaderContainer(this, this.pinned), this.columnModel.isReady() && this.refresh();
  }
  getAllCtrls() {
    const e = [...this.groupsRowCtrls];
    return this.columnsRowCtrl && e.push(this.columnsRowCtrl), this.filtersRowCtrl && e.push(this.filtersRowCtrl), e;
  }
  refresh(e = !1) {
    const t = new jh(), r = this.focusService.getFocusHeaderToUseAfterRefresh(), n = () => {
      const s = this.columnModel.getHeaderRowCount() - 1;
      this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls);
      for (let l = 0; l < s; l++) {
        const u = this.createBean(
          new Jx(
            t.next(),
            this.pinned,
            "group"
            /* COLUMN_GROUP */
          )
        );
        this.groupsRowCtrls.push(u);
      }
    }, i = () => {
      const s = t.next(), l = !this.hidden && (this.columnsRowCtrl == null || !e || this.columnsRowCtrl.getRowIndex() !== s);
      (l || this.hidden) && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), l && (this.columnsRowCtrl = this.createBean(new Jx(
        s,
        this.pinned,
        "column"
        /* COLUMN */
      )));
    }, o = () => {
      var u;
      this.includeFloatingFilter = !!((u = this.filterManager) != null && u.hasFloatingFilters()) && !this.hidden;
      const s = () => {
        this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl);
      };
      if (!this.includeFloatingFilter) {
        s();
        return;
      }
      const l = t.next();
      if (this.filtersRowCtrl) {
        const c = this.filtersRowCtrl.getRowIndex() !== l;
        (!e || c) && s();
      }
      this.filtersRowCtrl || (this.filtersRowCtrl = this.createBean(
        new Jx(
          l,
          this.pinned,
          "filter"
          /* FLOATING_FILTER */
        )
      ));
    };
    n(), i(), o();
    const a = this.getAllCtrls();
    this.comp.setCtrls(a), this.restoreFocusOnHeader(r);
  }
  getHeaderCtrlForColumn(e) {
    if (Zl(e))
      return this.columnsRowCtrl ? this.columnsRowCtrl.getHeaderCellCtrl(e) : void 0;
    if (this.groupsRowCtrls.length !== 0)
      for (let t = 0; t < this.groupsRowCtrls.length; t++) {
        const r = this.groupsRowCtrls[t].getHeaderCellCtrl(e);
        if (r)
          return r;
      }
  }
  getHtmlElementForColumnHeader(e) {
    const t = this.getHeaderCtrlForColumn(e);
    return t ? t.getGui() : null;
  }
  getRowType(e) {
    const r = this.getAllCtrls()[e];
    return r ? r.getType() : void 0;
  }
  focusHeader(e, t, r) {
    const i = this.getAllCtrls()[e];
    return i ? i.focusHeader(t, r) : !1;
  }
  getViewport() {
    return this.eViewport;
  }
  getRowCount() {
    return this.groupsRowCtrls.length + (this.columnsRowCtrl ? 1 : 0) + (this.filtersRowCtrl ? 1 : 0);
  }
  setHorizontalScroll(e) {
    this.comp.setViewportScrollLeft(e);
  }
  destroy() {
    this.filtersRowCtrl && (this.filtersRowCtrl = this.destroyBean(this.filtersRowCtrl)), this.columnsRowCtrl && (this.columnsRowCtrl = this.destroyBean(this.columnsRowCtrl)), this.groupsRowCtrls && this.groupsRowCtrls.length && (this.groupsRowCtrls = this.destroyBeans(this.groupsRowCtrls)), super.destroy();
  }
  setupDragAndDrop(e) {
    const t = new zke(this.pinned, e);
    this.createManagedBean(t);
  }
  restoreFocusOnHeader(e) {
    if (!e)
      return;
    const { column: t } = e;
    t.getPinned() == this.pinned && this.focusService.focusHeaderPosition({ headerPosition: e });
  }
  // grid cols have changed - this also means the number of rows in the header can have
  // changed. so we remove all the old rows and insert new ones for a complete refresh
  onGridColumnsChanged() {
    this.refresh(!0);
  }
  onDisplayedColumnsChanged() {
    var t;
    const e = ((t = this.filterManager) == null ? void 0 : t.hasFloatingFilters()) && !this.hidden;
    this.includeFloatingFilter !== e && this.refresh(!0);
  }
  setupCenterWidth() {
    this.pinned == null && this.createManagedBean(new kA((e) => this.comp.setCenterWidth(`${e}px`), !0));
  }
  setupPinnedWidth() {
    if (this.pinned == null)
      return;
    const e = this.pinned === "left", t = this.pinned === "right";
    this.hidden = !0;
    const r = () => {
      const n = e ? this.pinnedWidthService.getPinnedLeftWidth() : this.pinnedWidthService.getPinnedRightWidth();
      if (n == null)
        return;
      const i = n == 0, o = this.hidden !== i, a = this.gos.get("enableRtl"), s = this.gos.getScrollbarWidth(), u = this.scrollVisibleService.isVerticalScrollShowing() && (a && e || !a && t) ? n + s : n;
      this.comp.setPinnedContainerWidth(`${u}px`), this.comp.setDisplayed(!i), o && (this.hidden = i, this.refresh());
    };
    this.addManagedEventListeners({
      leftPinnedWidthChanged: r,
      rightPinnedWidthChanged: r,
      scrollVisibilityChanged: r,
      scrollbarWidthChanged: r
    });
  }
}, GA = class extends he {
  constructor(e) {
    super(), this.view = e;
  }
  postConstruct() {
    this.addManagedPropertyListener("domLayout", this.updateLayoutClasses.bind(this)), this.updateLayoutClasses();
  }
  updateLayoutClasses() {
    const e = this.getDomLayout(), t = {
      autoHeight: e === "autoHeight",
      normal: e === "normal",
      print: e === "print"
    }, r = t.autoHeight ? "ag-layout-auto-height" : t.print ? "ag-layout-print" : "ag-layout-normal";
    this.view.updateLayoutClasses(r, t);
  }
  // returns either 'print', 'autoHeight' or 'normal' (normal is the default)
  getDomLayout() {
    const e = this.gos.get("domLayout") ?? "normal";
    return ["normal", "print", "autoHeight"].indexOf(e) === -1 ? (Se(`${e} is not valid for DOM Layout, valid values are 'normal', 'autoHeight', 'print'.`), "normal") : e;
  }
}, Xke = class extends Nr {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-overlay" role="presentation">
                <div class="ag-overlay-panel" role="presentation">
                    <div class="ag-overlay-wrapper" data-ref="eOverlayWrapper" role="presentation"></div>
                </div>
            </div>`
    ), this.eOverlayWrapper = ft, this.activePromise = null, this.activeOverlay = null, this.updateListenerDestroyFunc = null, this.activeOverlayWrapperCssClass = null;
  }
  wireBeans(e) {
    this.overlayService = e.overlayService;
  }
  updateLayoutClasses(e, t) {
    const r = this.eOverlayWrapper.classList;
    r.toggle("ag-layout-auto-height", t.autoHeight), r.toggle("ag-layout-normal", t.normal), r.toggle("ag-layout-print", t.print);
  }
  postConstruct() {
    this.createManagedBean(new GA(this)), this.setDisplayed(!1, { skipAriaHidden: !0 }), this.overlayService.registerOverlayWrapperComp(this);
  }
  setWrapperTypeClass(e) {
    const t = this.eOverlayWrapper.classList;
    this.activeOverlayWrapperCssClass && t.toggle(this.activeOverlayWrapperCssClass, !1), this.activeOverlayWrapperCssClass = e, t.toggle(e, !0);
  }
  showOverlay(e, t, r) {
    this.setWrapperTypeClass(t), this.destroyActiveOverlay(), this.activePromise = e, e == null || e.then((n) => {
      if (this.activePromise !== e) {
        this.activeOverlay !== n && (this.destroyBean(n), n = null);
        return;
      }
      if (this.activePromise = null, !!n && this.activeOverlay != n && (this.eOverlayWrapper.appendChild(n.getGui()), this.activeOverlay = n, r)) {
        const i = n;
        this.updateListenerDestroyFunc = this.addManagedPropertyListener(r, ({ currentValue: o }) => {
          var a;
          (a = i.refresh) == null || a.call(i, this.gos.addGridCommonParams({ ...o ?? {} }));
        });
      }
    }), this.setDisplayed(!0, { skipAriaHidden: !0 });
  }
  destroyActiveOverlay() {
    this.activePromise = null;
    const e = this.activeOverlay;
    if (!e)
      return;
    this.activeOverlay = null;
    const t = this.updateListenerDestroyFunc;
    t && (t(), this.updateListenerDestroyFunc = null), this.destroyBean(e), oo(this.eOverlayWrapper);
  }
  hideOverlay() {
    this.destroyActiveOverlay(), this.setDisplayed(!1, { skipAriaHidden: !0 });
  }
  destroy() {
    this.destroyActiveOverlay(), super.destroy();
  }
}, rY = class extends Nr {
  constructor(e, t) {
    super(), this.direction = t, this.eViewport = ft, this.eContainer = ft, this.hideTimeout = null, this.setTemplate(e);
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this)
    }), this.onScrollVisibilityChanged(), this.addOrRemoveCssClass("ag-apple-scrollbar", cK() || su());
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.invisibleScrollbar = hK(), this.invisibleScrollbar && (this.hideAndShowInvisibleScrollAsNeeded(), this.addActiveListenerToggles()));
  }
  addActiveListenerToggles() {
    const e = this.getGui(), t = () => this.addOrRemoveCssClass("ag-scrollbar-active", !0), r = () => this.addOrRemoveCssClass("ag-scrollbar-active", !1);
    this.addManagedListeners(e, {
      mouseenter: t,
      mousedown: t,
      touchstart: t,
      mouseleave: r,
      touchend: r
    });
  }
  onScrollVisibilityChanged() {
    this.invisibleScrollbar === void 0 && this.initialiseInvisibleScrollbar(), this.animationFrameService.requestAnimationFrame(() => this.setScrollVisible());
  }
  hideAndShowInvisibleScrollAsNeeded() {
    this.addManagedEventListeners({
      bodyScroll: (e) => {
        e.direction === this.direction && (this.hideTimeout !== null && (window.clearTimeout(this.hideTimeout), this.hideTimeout = null), this.addOrRemoveCssClass("ag-scrollbar-scrolling", !0));
      },
      bodyScrollEnd: () => {
        this.hideTimeout = window.setTimeout(() => {
          this.addOrRemoveCssClass("ag-scrollbar-scrolling", !1), this.hideTimeout = null;
        }, 400);
      }
    });
  }
  attemptSettingScrollPosition(e) {
    const t = this.getViewport();
    BLe(
      () => ts(t),
      () => this.setScrollPosition(e),
      100
    );
  }
  getViewport() {
    return this.eViewport;
  }
  getContainer() {
    return this.eContainer;
  }
  onScrollCallback(e) {
    this.addManagedElementListeners(this.getViewport(), { scroll: e });
  }
}, Qke = class extends rY {
  constructor() {
    super(
      /* html */
      `<div class="ag-body-horizontal-scroll" aria-hidden="true">
            <div class="ag-horizontal-left-spacer" data-ref="eLeftSpacer"></div>
            <div class="ag-body-horizontal-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-horizontal-scroll-container" data-ref="eContainer"></div>
            </div>
            <div class="ag-horizontal-right-spacer" data-ref="eRightSpacer"></div>
        </div>`,
      "horizontal"
    ), this.eLeftSpacer = ft, this.eRightSpacer = ft;
  }
  wireBeans(e) {
    super.wireBeans(e), this.visibleColsService = e.visibleColsService, this.pinnedRowModel = e.pinnedRowModel, this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  postConstruct() {
    super.postConstruct();
    const e = this.setFakeHScrollSpacerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e,
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this)
    }), this.addManagedPropertyListener("domLayout", e), this.ctrlsService.register("fakeHScrollComp", this), this.createManagedBean(new kA((t) => this.eContainer.style.width = `${t}px`)), this.addManagedPropertyListeners(["suppressHorizontalScroll"], this.onScrollVisibilityChanged.bind(this));
  }
  initialiseInvisibleScrollbar() {
    this.invisibleScrollbar === void 0 && (this.enableRtl = this.gos.get("enableRtl"), super.initialiseInvisibleScrollbar(), this.invisibleScrollbar && this.refreshCompBottom());
  }
  onPinnedRowDataChanged() {
    this.refreshCompBottom();
  }
  refreshCompBottom() {
    if (!this.invisibleScrollbar)
      return;
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight();
    this.getGui().style.bottom = `${e}px`;
  }
  onScrollVisibilityChanged() {
    super.onScrollVisibilityChanged(), this.setFakeHScrollSpacerWidths();
  }
  setFakeHScrollSpacerWidths() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    let t = this.visibleColsService.getDisplayedColumnsRightWidth();
    const r = !this.enableRtl && e, n = this.gos.getScrollbarWidth();
    r && (t += n), pa(this.eRightSpacer, t), this.eRightSpacer.classList.toggle("ag-scroller-corner", t <= n);
    let i = this.visibleColsService.getColsLeftWidth();
    this.enableRtl && e && (i += n), pa(this.eLeftSpacer, i), this.eLeftSpacer.classList.toggle("ag-scroller-corner", i <= n);
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isHorizontalScrollShowing(), t = this.invisibleScrollbar, r = this.gos.get("suppressHorizontalScroll"), n = e && this.gos.getScrollbarWidth() || 0, o = r ? 0 : n === 0 && t ? 16 : n;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), cg(this.getGui(), o), cg(this.eViewport, o), cg(this.eContainer, o), this.setDisplayed(e, { skipAriaHidden: !0 });
  }
  getScrollPosition() {
    return jC(this.getViewport(), this.enableRtl);
  }
  setScrollPosition(e) {
    ts(this.getViewport()) || this.attemptSettingScrollPosition(e), UC(this.getViewport(), e, this.enableRtl);
  }
}, nY = class extends he {
  wireBeans(e) {
    this.maxDivHeightScaler = e.rowContainerHeightService;
  }
  constructor(e, t) {
    super(), this.eContainer = e, this.eViewport = t;
  }
  postConstruct() {
    this.addManagedEventListeners({ rowContainerHeightChanged: this.onHeightChanged.bind(this) });
  }
  onHeightChanged() {
    const e = this.maxDivHeightScaler.getUiContainerHeight(), t = e != null ? `${e}px` : "";
    this.eContainer.style.height = t, this.eViewport && (this.eViewport.style.height = t);
  }
}, Jke = class extends rY {
  wireBeans(e) {
    super.wireBeans(e), this.ctrlsService = e.ctrlsService, this.scrollVisibleService = e.scrollVisibleService;
  }
  constructor() {
    super(
      /* html */
      `<div class="ag-body-vertical-scroll" aria-hidden="true">
            <div class="ag-body-vertical-scroll-viewport" data-ref="eViewport">
                <div class="ag-body-vertical-scroll-container" data-ref="eContainer"></div>
            </div>
        </div>`,
      "vertical"
    );
  }
  postConstruct() {
    super.postConstruct(), this.createManagedBean(new nY(this.eContainer)), this.ctrlsService.register("fakeVScrollComp", this), this.addManagedEventListeners({ rowContainerHeightChanged: this.onRowContainerHeightChanged.bind(this) });
  }
  setScrollVisible() {
    const e = this.scrollVisibleService.isVerticalScrollShowing(), t = this.invisibleScrollbar, r = e && this.gos.getScrollbarWidth() || 0, n = r === 0 && t ? 16 : r;
    this.addOrRemoveCssClass("ag-scrollbar-invisible", t), pa(this.getGui(), n), pa(this.eViewport, n), pa(this.eContainer, n), this.setDisplayed(e, { skipAriaHidden: !0 });
  }
  onRowContainerHeightChanged() {
    const { ctrlsService: e } = this, r = e.getGridBodyCtrl().getBodyViewportElement(), n = this.getScrollPosition(), i = r.scrollTop;
    n != i && this.setScrollPosition(i, !0);
  }
  getScrollPosition() {
    return this.getViewport().scrollTop;
  }
  setScrollPosition(e, t) {
    !t && !ts(this.getViewport()) && this.attemptSettingScrollPosition(e), this.getViewport().scrollTop = e;
  }
}, eVe = class extends he {
  constructor(e) {
    super(), this.lastScrollSource = [null, null], this.scrollLeft = -1, this.nextScrollTop = -1, this.scrollTop = -1, this.lastOffsetHeight = -1, this.lastScrollTop = -1, this.eBodyViewport = e, this.resetLastHScrollDebounced = vi(
      () => this.lastScrollSource[
        1
        /* Horizontal */
      ] = null,
      500
    ), this.resetLastVScrollDebounced = vi(() => this.lastScrollSource[
      0
      /* Vertical */
    ] = null, 500);
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.animationFrameService = e.animationFrameService, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService, this.rowModel = e.rowModel, this.heightScaler = e.rowContainerHeightService, this.rowRenderer = e.rowRenderer, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService;
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.addManagedEventListeners({
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this)
    }), this.ctrlsService.whenReady((e) => {
      this.centerRowsCtrl = e.center, this.onDisplayedColumnsWidthChanged(), this.addScrollListener();
    });
  }
  addScrollListener() {
    const { fakeHScrollComp: e, fakeVScrollComp: t } = this.ctrlsService.getParams();
    this.addManagedElementListeners(this.centerRowsCtrl.getViewportElement(), {
      scroll: this.onHScroll.bind(this)
    }), e.onScrollCallback(this.onFakeHScroll.bind(this));
    const r = this.gos.get("debounceVerticalScrollbar"), n = r ? vi(this.onVScroll.bind(this), 100) : this.onVScroll.bind(this), i = r ? vi(this.onFakeVScroll.bind(this), 100) : this.onFakeVScroll.bind(this);
    this.addManagedElementListeners(this.eBodyViewport, { scroll: n }), t.onScrollCallback(i);
  }
  onDisplayedColumnsWidthChanged() {
    this.enableRtl && this.horizontallyScrollHeaderCenterAndFloatingCenter();
  }
  horizontallyScrollHeaderCenterAndFloatingCenter(e) {
    if (this.centerRowsCtrl == null)
      return;
    e === void 0 && (e = this.centerRowsCtrl.getCenterViewportScrollLeft());
    const r = this.enableRtl ? e : -e, { topCenter: n, stickyTopCenter: i, stickyBottomCenter: o, centerHeader: a, bottomCenter: s, fakeHScrollComp: l } = this.ctrlsService.getParams();
    a.setHorizontalScroll(-r), s.setContainerTranslateX(r), n.setContainerTranslateX(r), i.setContainerTranslateX(r), o.setContainerTranslateX(r);
    const u = this.centerRowsCtrl.getViewportElement(), c = this.lastScrollSource[
      1
      /* Horizontal */
    ] === 0;
    e = Math.abs(e), c ? l.setScrollPosition(e) : UC(u, e, this.enableRtl);
  }
  isControllingScroll(e, t) {
    return this.lastScrollSource[t] == null ? (this.lastScrollSource[t] = e, !0) : this.lastScrollSource[t] === e;
  }
  onFakeHScroll() {
    this.isControllingScroll(
      1,
      1
      /* Horizontal */
    ) && this.onHScrollCommon(
      1
      /* FakeContainer */
    );
  }
  onHScroll() {
    this.isControllingScroll(
      0,
      1
      /* Horizontal */
    ) && this.onHScrollCommon(
      0
      /* Container */
    );
  }
  onHScrollCommon(e) {
    const t = this.centerRowsCtrl.getViewportElement(), { scrollLeft: r } = t;
    if (this.shouldBlockScrollUpdate(1, r, !0))
      return;
    let n;
    e === 0 ? n = jC(t, this.enableRtl) : n = this.ctrlsService.get("fakeHScrollComp").getScrollPosition(), this.doHorizontalScroll(Math.round(n)), this.resetLastHScrollDebounced();
  }
  onFakeVScroll() {
    this.isControllingScroll(
      1,
      0
      /* Vertical */
    ) && this.onVScrollCommon(
      1
      /* FakeContainer */
    );
  }
  onVScroll() {
    this.isControllingScroll(
      0,
      0
      /* Vertical */
    ) && this.onVScrollCommon(
      0
      /* Container */
    );
  }
  onVScrollCommon(e) {
    let t;
    e === 0 ? t = this.eBodyViewport.scrollTop : t = this.ctrlsService.get("fakeVScrollComp").getScrollPosition(), !this.shouldBlockScrollUpdate(0, t, !0) && (this.animationFrameService.setScrollTop(t), this.nextScrollTop = t, e === 0 ? this.ctrlsService.get("fakeVScrollComp").setScrollPosition(t) : this.eBodyViewport.scrollTop = t, this.gos.get("suppressAnimationFrame") ? this.scrollGridIfNeeded() : this.animationFrameService.schedule(), this.resetLastVScrollDebounced());
  }
  doHorizontalScroll(e) {
    const t = this.ctrlsService.get("fakeHScrollComp").getScrollPosition();
    this.scrollLeft === e && e === t || (this.scrollLeft = e, this.fireScrollEvent(
      1
      /* Horizontal */
    ), this.horizontallyScrollHeaderCenterAndFloatingCenter(e), this.centerRowsCtrl.onHorizontalViewportChanged(!0));
  }
  fireScrollEvent(e) {
    const t = {
      type: "bodyScroll",
      direction: e === 1 ? "horizontal" : "vertical",
      left: this.scrollLeft,
      top: this.scrollTop
    };
    this.eventService.dispatchEvent(t), window.clearTimeout(this.scrollTimer), this.scrollTimer = void 0, this.scrollTimer = window.setTimeout(() => {
      const r = {
        ...t,
        type: "bodyScrollEnd"
      };
      this.eventService.dispatchEvent(r);
    }, 100);
  }
  shouldBlockScrollUpdate(e, t, r = !1) {
    return r && !su() ? !1 : e === 0 ? this.shouldBlockVerticalScroll(t) : this.shouldBlockHorizontalScroll(t);
  }
  shouldBlockVerticalScroll(e) {
    const t = bA(this.eBodyViewport), { scrollHeight: r } = this.eBodyViewport;
    return e < 0 || e + t > r;
  }
  shouldBlockHorizontalScroll(e) {
    const t = this.centerRowsCtrl.getCenterWidth(), { scrollWidth: r } = this.centerRowsCtrl.getViewportElement();
    if (this.enableRtl && WC()) {
      if (e > 0)
        return !0;
    } else if (e < 0)
      return !0;
    return Math.abs(e) + t > r;
  }
  redrawRowsAfterScroll() {
    this.fireScrollEvent(
      0
      /* Vertical */
    );
  }
  // this is to cater for AG-3274, where grid is removed from the dom and then inserted back in again.
  // (which happens with some implementations of tabbing). this can result in horizontal scroll getting
  // reset back to the left, however no scroll event is fired. so we need to get header to also scroll
  // back to the left to be kept in sync.
  // adding and removing the grid from the DOM both resets the scroll position and
  // triggers a resize event, so notify listeners if the scroll position has changed
  checkScrollLeft() {
    this.scrollLeft !== this.centerRowsCtrl.getCenterViewportScrollLeft() && this.onHScrollCommon(
      0
      /* Container */
    );
  }
  scrollGridIfNeeded() {
    const e = this.scrollTop != this.nextScrollTop;
    return e && (this.scrollTop = this.nextScrollTop, this.redrawRowsAfterScroll()), e;
  }
  // called by scrollHorizontally method and alignedGridsService
  setHorizontalScrollPosition(e, t = !1) {
    const n = this.centerRowsCtrl.getViewportElement().scrollWidth - this.centerRowsCtrl.getCenterWidth();
    !t && this.shouldBlockScrollUpdate(1, e) && (this.enableRtl && WC() ? e = e > 0 ? 0 : n : e = Math.min(Math.max(e, 0), n)), UC(this.centerRowsCtrl.getViewportElement(), Math.abs(e), this.enableRtl), this.doHorizontalScroll(e);
  }
  setVerticalScrollPosition(e) {
    this.eBodyViewport.scrollTop = e;
  }
  getVScrollPosition() {
    return this.lastScrollTop = this.eBodyViewport.scrollTop, this.lastOffsetHeight = this.eBodyViewport.offsetHeight, {
      top: this.lastScrollTop,
      bottom: this.lastScrollTop + this.lastOffsetHeight
    };
  }
  /** Get an approximate scroll position that returns the last real value read.
   * This is useful for avoiding repeated DOM reads that force the browser to recalculate styles.
   * This can have big performance improvements but may not be 100% accurate so only use if this is acceptable.
   */
  getApproximateVScollPosition() {
    return this.lastScrollTop >= 0 && this.lastOffsetHeight >= 0 ? {
      top: this.scrollTop,
      bottom: this.scrollTop + this.lastOffsetHeight
    } : this.getVScrollPosition();
  }
  getHScrollPosition() {
    return this.centerRowsCtrl.getHScrollPosition();
  }
  isHorizontalScrollShowing() {
    return this.centerRowsCtrl.isHorizontalScrollShowing();
  }
  // called by the headerRootComp and moveColumnController
  scrollHorizontally(e) {
    const t = this.centerRowsCtrl.getViewportElement().scrollLeft;
    return this.setHorizontalScrollPosition(t + e), this.centerRowsCtrl.getViewportElement().scrollLeft - t;
  }
  // gets called by rowRenderer when new data loaded, as it will want to scroll to the top
  scrollToTop() {
    this.eBodyViewport.scrollTop = 0;
  }
  // Valid values for position are bottom, middle and top
  ensureNodeVisible(e, t = null) {
    const r = this.rowModel.getRowCount();
    let n = -1;
    for (let i = 0; i < r; i++) {
      const o = this.rowModel.getRow(i);
      if (typeof e == "function") {
        if (o && e(o)) {
          n = i;
          break;
        }
      } else if (e === o || e === o.data) {
        n = i;
        break;
      }
    }
    n >= 0 && this.ensureIndexVisible(n, t);
  }
  // Valid values for position are bottom, middle and top
  // position should be {'top','middle','bottom', or undefined/null}.
  // if undefined/null, then the grid will to the minimal amount of scrolling,
  // eg if grid needs to scroll up, it scrolls until row is on top,
  //    if grid needs to scroll down, it scrolls until row is on bottom,
  //    if row is already in view, grid does not scroll
  ensureIndexVisible(e, t) {
    if (this.gos.isDomLayout("print"))
      return;
    const r = this.rowModel.getRowCount();
    if (typeof e != "number" || e < 0 || e >= r) {
      Se("Invalid row index for ensureIndexVisible: " + e);
      return;
    }
    const i = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.getFrameworkOverrides().wrapIncoming(() => {
      var c;
      i || (c = this.paginationService) == null || c.goToPageWithIndex(e);
      const o = this.ctrlsService.getGridBodyCtrl(), a = o.getStickyTopHeight(), s = o.getStickyBottomHeight(), l = this.rowModel.getRow(e);
      let u;
      do {
        const d = l.rowTop, h = l.rowHeight, f = this.pageBoundsService.getPixelOffset(), p = l.rowTop - f, g = p + l.rowHeight, v = this.getVScrollPosition(), m = this.heightScaler.getDivStretchOffset(), y = v.top + m, C = v.bottom + m, S = C - y, b = this.heightScaler.getScrollPositionForPixel(p), w = this.heightScaler.getScrollPositionForPixel(g - S), x = Math.min((b + w) / 2, p), E = y + a > p, R = C - s < g;
        let _ = null;
        t === "top" ? _ = b : t === "bottom" ? _ = w : t === "middle" ? _ = x : E ? _ = b - a : R && (_ = w + s), _ !== null && (this.setVerticalScrollPosition(_), this.rowRenderer.redraw({ afterScroll: !0 })), u = d !== l.rowTop || h !== l.rowHeight;
      } while (u);
      this.animationFrameService.flushAllFrames();
    });
  }
  ensureColumnVisible(e, t = "auto") {
    const r = this.columnModel.getCol(e);
    if (!r || r.isPinned() || !this.visibleColsService.isColDisplayed(r))
      return;
    const n = this.getPositionedHorizontalScroll(r, t);
    this.getFrameworkOverrides().wrapIncoming(() => {
      n !== null && this.centerRowsCtrl.setCenterViewportScrollLeft(n), this.centerRowsCtrl.onHorizontalViewportChanged(), this.animationFrameService.flushAllFrames();
    });
  }
  setScrollPosition(e, t) {
    this.getFrameworkOverrides().wrapIncoming(() => {
      this.centerRowsCtrl.setCenterViewportScrollLeft(t), this.setVerticalScrollPosition(e), this.rowRenderer.redraw({ afterScroll: !0 }), this.animationFrameService.flushAllFrames();
    });
  }
  getPositionedHorizontalScroll(e, t) {
    const { columnBeforeStart: r, columnAfterEnd: n } = this.isColumnOutsideViewport(e), i = this.centerRowsCtrl.getCenterWidth() < e.getActualWidth(), o = this.centerRowsCtrl.getCenterWidth(), a = this.enableRtl;
    let s = (a ? r : n) || i, l = a ? n : r;
    t !== "auto" && (s = t === "start", l = t === "end");
    const u = t === "middle";
    if (s || l || u) {
      const { colLeft: c, colMiddle: d, colRight: h } = this.getColumnBounds(e);
      return u ? d - o / 2 : s ? a ? h : c : a ? c - o : h - o;
    }
    return null;
  }
  isColumnOutsideViewport(e) {
    const { start: t, end: r } = this.getViewportBounds(), { colLeft: n, colRight: i } = this.getColumnBounds(e), o = this.enableRtl, a = o ? t > i : r < i, s = o ? r < n : t > n;
    return { columnBeforeStart: a, columnAfterEnd: s };
  }
  getColumnBounds(e) {
    const t = this.enableRtl, r = this.visibleColsService.getBodyContainerWidth(), n = e.getActualWidth(), i = e.getLeft(), o = t ? -1 : 1, a = t ? r - i : i, s = a + n * o, l = a + n / 2 * o;
    return { colLeft: a, colMiddle: l, colRight: s };
  }
  getViewportBounds() {
    const e = this.centerRowsCtrl.getCenterWidth(), t = this.centerRowsCtrl.getCenterViewportScrollLeft(), r = t, n = e + t;
    return { start: r, end: n, width: e };
  }
}, tVe = "ag-force-vertical-scroll", rVe = "ag-selectable", nVe = "ag-column-moving", iVe = class extends he {
  constructor() {
    super(...arguments), this.stickyTopHeight = 0, this.stickyBottomHeight = 0;
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.rowContainerHeightService = e.rowContainerHeightService, this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.scrollVisibleService = e.scrollVisibleService, this.menuService = e.menuService, this.headerNavigationService = e.headerNavigationService, this.dragAndDropService = e.dragAndDropService, this.pinnedRowModel = e.pinnedRowModel, this.rowRenderer = e.rowRenderer, this.popupService = e.popupService, this.mouseEventService = e.mouseEventService, this.rowModel = e.rowModel, this.filterManager = e.filterManager, this.environment = e.environment;
  }
  getScrollFeature() {
    return this.bodyScrollFeature;
  }
  getBodyViewportElement() {
    return this.eBodyViewport;
  }
  setComp(e, t, r, n, i, o, a) {
    var s;
    this.comp = e, this.eGridBody = t, this.eBodyViewport = r, this.eTop = n, this.eBottom = i, this.eStickyTop = o, this.eStickyBottom = a, this.setCellTextSelection(this.gos.get("enableCellTextSelection")), this.addManagedPropertyListener(
      "enableCellTextSelection",
      (l) => this.setCellTextSelection(l.currentValue)
    ), this.createManagedBean(new GA(this.comp)), this.bodyScrollFeature = this.createManagedBean(new eVe(this.eBodyViewport)), this.addRowDragListener(), this.setupRowAnimationCssClass(), this.addEventListeners(), this.addFocusListeners([n, r, i, o, a]), this.onGridColumnsChanged(), this.addBodyViewportListener(), this.setFloatingHeights(), this.disableBrowserDragging(), this.addStopEditingWhenGridLosesFocus(), (s = this.filterManager) == null || s.setupAdvancedFilterHeaderComp(n), this.ctrlsService.register("gridBodyCtrl", this);
  }
  getComp() {
    return this.comp;
  }
  addEventListeners() {
    this.addManagedEventListeners({
      gridColumnsChanged: this.onGridColumnsChanged.bind(this),
      scrollVisibilityChanged: this.onScrollVisibilityChanged.bind(this),
      pinnedRowDataChanged: this.setFloatingHeights.bind(this),
      pinnedHeightChanged: this.setFloatingHeights.bind(this),
      headerHeightChanged: this.onHeaderHeightChanged.bind(this)
    });
  }
  addFocusListeners(e) {
    e.forEach((t) => {
      this.addManagedElementListeners(t, {
        focusin: (r) => {
          const { target: n } = r, i = wh(n, "ag-root", t);
          t.classList.toggle("ag-has-focus", !i);
        },
        focusout: (r) => {
          const { target: n, relatedTarget: i } = r, o = t.contains(i), a = wh(
            i,
            "ag-root",
            t
          );
          wh(n, "ag-root", t) || (!o || a) && t.classList.remove("ag-has-focus");
        }
      });
    });
  }
  // used by ColumnAnimationService
  setColumnMovingCss(e) {
    this.comp.setColumnMovingCss(nVe, e);
  }
  setCellTextSelection(e = !1) {
    this.comp.setCellSelectableCss(rVe, e);
  }
  onScrollVisibilityChanged() {
    const e = this.scrollVisibleService.isVerticalScrollShowing();
    this.setVerticalScrollPaddingVisible(e), this.setStickyWidth(e), this.setStickyBottomOffsetBottom();
    const t = e && this.gos.getScrollbarWidth() || 0, r = hK() ? 16 : 0, n = `calc(100% + ${t + r}px)`;
    this.animationFrameService.requestAnimationFrame(() => this.comp.setBodyViewportWidth(n));
  }
  onGridColumnsChanged() {
    const e = this.columnModel.getCols();
    this.comp.setColumnCount(e.length);
  }
  // if we do not do this, then the user can select a pic in the grid (eg an image in a custom cell renderer)
  // and then that will start the browser native drag n' drop, which messes up with our own drag and drop.
  disableBrowserDragging() {
    this.addManagedElementListeners(this.eGridBody, {
      dragstart: (e) => {
        if (e.target instanceof HTMLImageElement)
          return e.preventDefault(), !1;
      }
    });
  }
  addStopEditingWhenGridLosesFocus() {
    if (!this.gos.get("stopEditingWhenCellsLoseFocus"))
      return;
    const e = (r) => {
      const n = r.relatedTarget;
      if (TT(n) === null) {
        this.rowRenderer.stopEditing();
        return;
      }
      let i = (
        // see if click came from inside the viewports
        t.some((o) => o.contains(n)) && // and also that it's not from a detail grid
        this.mouseEventService.isElementInThisGrid(n)
      );
      if (!i) {
        const o = this.popupService;
        i = o.getActivePopups().some((a) => a.contains(n)) || o.isElementWithinCustomPopup(n);
      }
      i || this.rowRenderer.stopEditing();
    }, t = [this.eBodyViewport, this.eBottom, this.eTop, this.eStickyTop, this.eStickyBottom];
    t.forEach((r) => this.addManagedElementListeners(r, { focusout: e }));
  }
  updateRowCount() {
    var n;
    const e = this.headerNavigationService.getHeaderRowCount() + (((n = this.filterManager) == null ? void 0 : n.getHeaderRowCount()) ?? 0), t = this.rowModel.isLastRowIndexKnown() ? this.rowModel.getRowCount() : -1, r = t === -1 ? -1 : e + t;
    this.comp.setRowCount(r);
  }
  registerBodyViewportResizeListener(e) {
    this.comp.registerBodyViewportResizeListener(e);
  }
  setVerticalScrollPaddingVisible(e) {
    const t = e ? "scroll" : "hidden";
    this.comp.setPinnedTopBottomOverflowY(t);
  }
  isVerticalScrollShowing() {
    const e = this.gos.get("alwaysShowVerticalScroll"), t = e ? tVe : null, r = this.gos.isDomLayout("normal");
    return this.comp.setAlwaysVerticalScrollClass(t, e), e || r && MOe(this.eBodyViewport);
  }
  setupRowAnimationCssClass() {
    let e = this.environment.hasMeasuredSizes();
    const t = () => {
      const r = e && this.gos.isAnimateRows() && !this.rowContainerHeightService.isStretching(), n = r ? "ag-row-animation" : "ag-row-no-animation";
      this.comp.setRowAnimationCssOnBodyViewport(n, r);
    };
    t(), this.addManagedEventListeners({ heightScaleChanged: t }), this.addManagedPropertyListener("animateRows", t), this.addManagedEventListeners({
      gridStylesChanged: () => {
        !e && this.environment.hasMeasuredSizes() && (e = !0, t());
      }
    });
  }
  getGridBodyElement() {
    return this.eGridBody;
  }
  addBodyViewportListener() {
    const e = this.onBodyViewportContextMenu.bind(this);
    this.addManagedElementListeners(this.eBodyViewport, { contextmenu: e }), this.mockContextMenuForIPad(e), this.addManagedElementListeners(this.eBodyViewport, { wheel: this.onBodyViewportWheel.bind(this) }), this.addManagedElementListeners(this.eStickyTop, { wheel: this.onStickyWheel.bind(this) }), this.addManagedElementListeners(this.eStickyBottom, { wheel: this.onStickyWheel.bind(this) }), this.addFullWidthContainerWheelListener();
  }
  addFullWidthContainerWheelListener() {
    const e = this.eBodyViewport.querySelector(".ag-full-width-container"), t = this.eBodyViewport.querySelector(".ag-center-cols-viewport");
    e && t && this.addManagedElementListeners(e, {
      wheel: (r) => this.onFullWidthContainerWheel(r, t)
    });
  }
  onFullWidthContainerWheel(e, t) {
    !e.deltaX || Math.abs(e.deltaY) > Math.abs(e.deltaX) || !this.mouseEventService.isEventFromThisGrid(e) || (e.preventDefault(), t.scrollBy({ left: e.deltaX }));
  }
  onBodyViewportContextMenu(e, t, r) {
    if (!e && !r)
      return;
    this.gos.get("preventDefaultOnContextMenu") && (e || r).preventDefault();
    const { target: n } = e || t;
    (n === this.eBodyViewport || n === this.ctrlsService.get("center").getViewportElement()) && this.menuService.showContextMenu({
      mouseEvent: e,
      touchEvent: r,
      value: null,
      anchorToElement: this.eGridBody
    });
  }
  mockContextMenuForIPad(e) {
    if (!su())
      return;
    const t = new Bl(this.eBodyViewport), r = (n) => {
      e(void 0, n.touchStart, n.touchEvent);
    };
    this.addManagedListeners(t, { longTap: r }), this.addDestroyFunc(() => t.destroy());
  }
  onBodyViewportWheel(e) {
    this.gos.get("suppressScrollWhenPopupsAreOpen") && this.popupService.hasAnchoredPopup() && e.preventDefault();
  }
  onStickyWheel(e) {
    e.preventDefault(), e.offsetY && this.scrollVertically(e.deltaY);
  }
  getGui() {
    return this.eGridBody;
  }
  // called by rowDragFeature
  scrollVertically(e) {
    const t = this.eBodyViewport.scrollTop;
    return this.bodyScrollFeature.setVerticalScrollPosition(t + e), this.eBodyViewport.scrollTop - t;
  }
  addRowDragListener() {
    this.rowDragFeature = this.createManagedBean(new xNe(this.eBodyViewport)), this.dragAndDropService.addDropTarget(this.rowDragFeature);
  }
  getRowDragFeature() {
    return this.rowDragFeature;
  }
  setFloatingHeights() {
    const { pinnedRowModel: e } = this, t = e.getPinnedTopTotalHeight(), r = e.getPinnedBottomTotalHeight();
    this.comp.setTopHeight(t), this.comp.setBottomHeight(r), this.comp.setTopDisplay(t ? "inherit" : "none"), this.comp.setBottomDisplay(r ? "inherit" : "none"), this.setStickyTopOffsetTop(), this.setStickyBottomOffsetBottom();
  }
  setStickyTopHeight(e = 0) {
    this.comp.setStickyTopHeight(`${e}px`), this.stickyTopHeight = e;
  }
  getStickyTopHeight() {
    return this.stickyTopHeight;
  }
  setStickyBottomHeight(e = 0) {
    this.comp.setStickyBottomHeight(`${e}px`), this.stickyBottomHeight = e;
  }
  getStickyBottomHeight() {
    return this.stickyBottomHeight;
  }
  setStickyWidth(e) {
    if (!e)
      this.comp.setStickyTopWidth("100%"), this.comp.setStickyBottomWidth("100%");
    else {
      const t = this.gos.getScrollbarWidth();
      this.comp.setStickyTopWidth(`calc(100% - ${t}px)`), this.comp.setStickyBottomWidth(`calc(100% - ${t}px)`);
    }
  }
  onHeaderHeightChanged() {
    this.setStickyTopOffsetTop();
  }
  setStickyTopOffsetTop() {
    var i;
    const t = this.ctrlsService.get("gridHeaderCtrl").getHeaderHeight() + (((i = this.filterManager) == null ? void 0 : i.getHeaderHeight()) ?? 0), r = this.pinnedRowModel.getPinnedTopTotalHeight();
    let n = 0;
    t > 0 && (n += t), r > 0 && (n += r), n > 0 && (n += 1), this.comp.setStickyTopTop(`${n}px`);
  }
  setStickyBottomOffsetBottom() {
    const e = this.pinnedRowModel.getPinnedBottomTotalHeight(), r = this.scrollVisibleService.isHorizontalScrollShowing() && this.gos.getScrollbarWidth() || 0, n = e + r;
    this.comp.setStickyBottomBottom(`${n}px`);
  }
  // method will call itself if no available width. this covers if the grid
  // isn't visible, but is just about to be visible.
  sizeColumnsToFit(e, t) {
    const n = this.isVerticalScrollShowing() ? this.gos.getScrollbarWidth() : 0, o = Yv(this.eGridBody) - n;
    if (o > 0) {
      this.columnSizeService.sizeColumnsToFit(o, "sizeColumnsToFit", !1, e);
      return;
    }
    t === void 0 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 100);
    }, 0) : t === 100 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, 500);
    }, 100) : t === 500 ? window.setTimeout(() => {
      this.sizeColumnsToFit(e, -1);
    }, 500) : Se(
      "tried to call sizeColumnsToFit() but the grid is coming back with zero width, maybe the grid is not visible yet on the screen?"
    );
  }
  // + rangeService
  addScrollEventListener(e) {
    this.eBodyViewport.addEventListener("scroll", e, { passive: !0 });
  }
  // + focusService
  removeScrollEventListener(e) {
    this.eBodyViewport.removeEventListener("scroll", e);
  }
}, oVe = class extends he {
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.pinnedWidthService = e.pinnedWidthService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnSizeService = e.columnSizeService, this.scrollVisibleService = e.scrollVisibleService, this.columnViewportService = e.columnViewportService;
  }
  constructor(e) {
    super(), this.centerContainerCtrl = e;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.listenForResize();
    }), this.addManagedEventListeners({ scrollbarWidthChanged: this.onScrollbarWidthChanged.bind(this) }), this.addManagedPropertyListeners(["alwaysShowHorizontalScroll", "alwaysShowVerticalScroll"], () => {
      this.checkViewportAndScrolls();
    });
  }
  listenForResize() {
    const e = () => this.onCenterViewportResized();
    this.centerContainerCtrl.registerViewportResizeListener(e), this.gridBodyCtrl.registerBodyViewportResizeListener(e);
  }
  onScrollbarWidthChanged() {
    this.checkViewportAndScrolls();
  }
  onCenterViewportResized() {
    if (this.centerContainerCtrl.isViewportInTheDOMTree()) {
      this.keepPinnedColumnsNarrowerThanViewport(), this.checkViewportAndScrolls();
      const e = this.centerContainerCtrl.getCenterWidth();
      e !== this.centerWidth && (this.centerWidth = e, this.columnSizeService.refreshFlexedColumns({
        viewportWidth: this.centerWidth,
        updateBodyWidths: !0,
        fireResizedEvent: !0
      }));
    } else
      this.bodyHeight = 0;
  }
  keepPinnedColumnsNarrowerThanViewport() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = Yv(e);
    if (t <= 50)
      return;
    let r = this.getPinnedColumnsOverflowingViewport(t - 50);
    const n = this.gos.getCallback("processUnpinnedColumns");
    r.length && (n && (r = n({
      columns: r,
      viewportWidth: t
    })), this.columnModel.setColsPinned(r, null, "viewportSizeFeature"));
  }
  getPinnedColumnsOverflowingViewport(e) {
    const t = this.pinnedWidthService.getPinnedRightWidth(), r = this.pinnedWidthService.getPinnedLeftWidth(), n = t + r;
    if (n < e)
      return [];
    const i = [...this.visibleColsService.getLeftCols()], o = [...this.visibleColsService.getRightCols()];
    let a = 0, s = 0;
    const l = 0, u = [];
    let c = n - l - e;
    for (; (s < i.length || a < o.length) && c > 0; ) {
      if (a < o.length) {
        const d = o[a++];
        c -= d.getActualWidth(), u.push(d);
      }
      if (s < i.length && c > 0) {
        const d = i[s++];
        c -= d.getActualWidth(), u.push(d);
      }
    }
    return u;
  }
  // gets called every time the viewport size changes. we use this to check visibility of scrollbars
  // in the grid panel, and also to check size and position of viewport for row and column virtualisation.
  checkViewportAndScrolls() {
    this.updateScrollVisibleService(), this.checkBodyHeight(), this.onHorizontalViewportChanged(), this.gridBodyCtrl.getScrollFeature().checkScrollLeft();
  }
  getBodyHeight() {
    return this.bodyHeight;
  }
  checkBodyHeight() {
    const e = this.gridBodyCtrl.getBodyViewportElement(), t = bA(e);
    if (this.bodyHeight !== t) {
      this.bodyHeight = t;
      const r = {
        type: "bodyHeightChanged"
      };
      this.eventService.dispatchEvent(r);
    }
  }
  updateScrollVisibleService() {
    this.updateScrollVisibleServiceImpl(), setTimeout(this.updateScrollVisibleServiceImpl.bind(this), 500);
  }
  updateScrollVisibleServiceImpl() {
    const e = {
      horizontalScrollShowing: this.isHorizontalScrollShowing(),
      verticalScrollShowing: this.gridBodyCtrl.isVerticalScrollShowing()
    };
    this.scrollVisibleService.setScrollsVisible(e);
  }
  isHorizontalScrollShowing() {
    return this.centerContainerCtrl.isHorizontalScrollShowing();
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged() {
    const e = this.centerContainerCtrl.getCenterWidth(), t = this.centerContainerCtrl.getViewportScrollLeft();
    this.columnViewportService.setScrollPosition(e, t);
  }
}, aVe = class extends he {
  wireBeans(e) {
    this.dragService = e.dragService, this.rangeService = e.rangeService;
  }
  constructor(e) {
    super(), this.eContainer = e;
  }
  postConstruct() {
    if (!this.rangeService)
      return;
    this.params = {
      eElement: this.eContainer,
      onDragStart: this.rangeService.onDragStart.bind(this.rangeService),
      onDragStop: this.rangeService.onDragStop.bind(this.rangeService),
      onDragging: this.rangeService.onDragging.bind(this.rangeService)
    }, this.addManagedPropertyListener("enableRangeSelection", (t) => {
      if (t.currentValue) {
        this.enableFeature();
        return;
      }
      this.disableFeature();
    }), this.addDestroyFunc(() => this.disableFeature()), this.gos.get("enableRangeSelection") && this.enableFeature();
  }
  enableFeature() {
    this.dragService.addDragSource(this.params);
  }
  disableFeature() {
    this.dragService.removeDragSource(this.params);
  }
}, sVe = class extends Nr {
  constructor() {
    super(
      /* html*/
      `
            <div class="ag-selection-checkbox" role="presentation">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [TA]
    ), this.eCheckbox = ft;
  }
  postConstruct() {
    this.eCheckbox.setPassive(!0);
  }
  getCheckboxId() {
    return this.eCheckbox.getInputElement().id;
  }
  onDataChanged() {
    this.onSelectionChanged();
  }
  onSelectableChanged() {
    this.showOrHideSelect();
  }
  onSelectionChanged() {
    const e = this.localeService.getLocaleTextFunc(), t = this.rowNode.isSelected(), r = CA(e, t), [n, i] = this.rowNode.selectable ? ["ariaRowToggleSelection", "Press Space to toggle row selection"] : ["ariaRowSelectionDisabled", "Row Selection is disabled for this row"], o = e(n, i);
    this.eCheckbox.setValue(t, !0), this.eCheckbox.setInputAriaLabel(`${o} (${r})`);
  }
  onClicked(e, t, r) {
    return this.rowNode.setSelectedParams({
      newValue: e,
      rangeSelect: r.shiftKey,
      groupSelectsFiltered: t,
      event: r,
      source: "checkboxSelected"
    });
  }
  init(e) {
    if (this.rowNode = e.rowNode, this.column = e.column, this.overrides = e.overrides, this.onSelectionChanged(), this.addManagedListeners(this.eCheckbox.getInputElement(), {
      // we don't want double click on this icon to open a group
      dblclick: (n) => zh(n),
      click: (n) => {
        zh(n);
        const i = this.gos.get("groupSelectsFiltered"), o = this.eCheckbox.getValue();
        this.shouldHandleIndeterminateState(o, i) ? this.onClicked(!0, i, n || {}) === 0 && this.onClicked(!1, i, n) : o ? this.onClicked(!1, i, n) : this.onClicked(!0, i, n || {});
      }
    }), this.addManagedListeners(this.rowNode, {
      rowSelected: this.onSelectionChanged.bind(this),
      dataChanged: this.onDataChanged.bind(this),
      selectableChanged: this.onSelectableChanged.bind(this)
    }), this.gos.get("isRowSelectable") || typeof this.getIsVisible() == "function") {
      const n = this.showOrHideSelect.bind(this);
      this.addManagedEventListeners({ displayedColumnsChanged: n }), this.addManagedListeners(this.rowNode, {
        dataChanged: n,
        cellChanged: n
      }), this.showOrHideSelect();
    }
    this.eCheckbox.getInputElement().setAttribute("tabindex", "-1");
  }
  shouldHandleIndeterminateState(e, t) {
    return t && (this.eCheckbox.getPreviousValue() === void 0 || e === void 0) && this.gos.isRowModelType("clientSide");
  }
  showOrHideSelect() {
    var n, i, o;
    let e = this.rowNode.selectable;
    const t = this.getIsVisible();
    if (e)
      if (typeof t == "function") {
        const a = (n = this.overrides) == null ? void 0 : n.callbackParams;
        if (!this.column)
          e = t({ ...a, node: this.rowNode, data: this.rowNode.data });
        else {
          const s = this.column.createColumnFunctionCallbackParams(this.rowNode);
          e = t({ ...a, ...s });
        }
      } else
        e = t ?? !1;
    if ((i = this.column) == null ? void 0 : i.getColDef().showDisabledCheckboxes) {
      this.eCheckbox.setDisabled(!e), this.setVisible(!0), this.setDisplayed(!0);
      return;
    }
    if ((o = this.overrides) != null && o.removeHidden) {
      this.setDisplayed(e);
      return;
    }
    this.setVisible(e);
  }
  getIsVisible() {
    var e, t;
    return this.overrides ? this.overrides.isVisible : (t = (e = this.column) == null ? void 0 : e.getColDef()) == null ? void 0 : t.checkboxSelection;
  }
}, lVe = class extends Nr {
  constructor(e, t, r) {
    super(
      /* html */
      '<div class="ag-drag-handle ag-row-drag" draggable="true"></div>'
    ), this.rowNode = e, this.column = t, this.eCell = r;
  }
  postConstruct() {
    this.getGui().appendChild(to("rowDrag", this.gos, null)), this.addGuiEventListener("mousedown", (t) => {
      t.stopPropagation();
    }), this.addDragSource(), this.checkVisibility();
  }
  addDragSource() {
    this.addGuiEventListener("dragstart", this.onDragStart.bind(this));
  }
  onDragStart(e) {
    const t = this.column.getColDef().dndSourceOnRowDrag;
    e.dataTransfer.setDragImage(this.eCell, 0, 0);
    const r = () => {
      try {
        const n = JSON.stringify(this.rowNode.data);
        e.dataTransfer.setData("application/json", n), e.dataTransfer.setData("text/plain", n);
      } catch {
      }
    };
    if (t) {
      const n = this.gos.addGridCommonParams({
        rowNode: this.rowNode,
        dragEvent: e
      });
      t(n);
    } else
      r();
  }
  checkVisibility() {
    const e = this.column.isDndSource(this.rowNode);
    this.setDisplayed(e);
  }
}, uVe = class extends he {
  constructor(e, t) {
    super(), this.staticClasses = [], this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setComp(e) {
    this.cellComp = e, this.applyUserStyles(), this.applyCellClassRules(), this.applyClassesFromColDef();
  }
  applyCellClassRules() {
    const e = this.column.getColDef(), { cellClassRules: t } = e, r = this.beans.gos.addGridCommonParams({
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      colDef: e,
      column: this.column,
      rowIndex: this.rowNode.rowIndex
    });
    this.beans.stylingService.processClassRules(
      // if current was previous, skip
      t === this.cellClassRules ? void 0 : this.cellClassRules,
      t,
      r,
      (n) => this.cellComp.addOrRemoveCssClass(n, !0),
      (n) => this.cellComp.addOrRemoveCssClass(n, !1)
    ), this.cellClassRules = t;
  }
  applyUserStyles() {
    const e = this.column.getColDef();
    if (!e.cellStyle)
      return;
    let t;
    if (typeof e.cellStyle == "function") {
      const r = this.beans.gos.addGridCommonParams({
        column: this.column,
        value: this.cellCtrl.getValue(),
        colDef: e,
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      }), n = e.cellStyle;
      t = n(r);
    } else
      t = e.cellStyle;
    t && this.cellComp.setUserStyles(t);
  }
  applyClassesFromColDef() {
    const e = this.column.getColDef(), t = this.beans.gos.addGridCommonParams({
      value: this.cellCtrl.getValue(),
      data: this.rowNode.data,
      node: this.rowNode,
      column: this.column,
      colDef: e,
      rowIndex: this.rowNode.rowIndex
    });
    this.staticClasses.length && this.staticClasses.forEach((r) => this.cellComp.addOrRemoveCssClass(r, !1)), this.staticClasses = this.beans.stylingService.getStaticCellClasses(e, t), this.staticClasses.length && this.staticClasses.forEach((r) => this.cellComp.addOrRemoveCssClass(r, !0));
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, cVe = class extends he {
  constructor(e, t, r, n, i) {
    super(), this.cellCtrl = e, this.beans = t, this.rowNode = n, this.rowCtrl = i;
  }
  setComp(e) {
    this.eGui = e;
  }
  onKeyDown(e) {
    const t = e.key;
    switch (t) {
      case ae.ENTER:
        this.onEnterKeyDown(e);
        break;
      case ae.F2:
        this.onF2KeyDown(e);
        break;
      case ae.ESCAPE:
        this.onEscapeKeyDown(e);
        break;
      case ae.TAB:
        this.onTabKeyDown(e);
        break;
      case ae.BACKSPACE:
      case ae.DELETE:
        this.onBackspaceOrDeleteKeyDown(t, e);
        break;
      case ae.DOWN:
      case ae.UP:
      case ae.RIGHT:
      case ae.LEFT:
        this.onNavigationKeyDown(e, t);
        break;
    }
  }
  onNavigationKeyDown(e, t) {
    this.cellCtrl.isEditing() || (e.shiftKey && this.cellCtrl.isRangeSelectionEnabled() ? this.onShiftRangeSelect(e) : this.beans.navigationService.navigateToNextCell(e, t, this.cellCtrl.getCellPosition(), !0), e.preventDefault());
  }
  onShiftRangeSelect(e) {
    if (!this.beans.rangeService)
      return;
    const t = this.beans.rangeService.extendLatestRangeInDirection(e);
    t && this.beans.navigationService.ensureCellVisible(t);
  }
  onTabKeyDown(e) {
    this.beans.navigationService.onTabKeyDown(this.cellCtrl, e);
  }
  onBackspaceOrDeleteKeyDown(e, t) {
    const { cellCtrl: r, beans: n, rowNode: i } = this, { gos: o, rangeService: a, eventService: s } = n;
    if (!r.isEditing()) {
      if (s.dispatchEvent({ type: "keyShortcutChangedCellStart" }), WNe(e, o.get("enableCellEditingOnBackspace"))) {
        if (a && o.get("enableRangeSelection"))
          a.clearCellRangeCellValues({ dispatchWrapperEvents: !0, wrapperEventSource: "deleteKey" });
        else if (r.isCellEditable()) {
          const l = r.getColumn(), u = this.beans.valueService.parseValue(l, i, "", i.getValueFromValueService(l)) ?? null;
          i.setDataValue(l, u, "cellClear");
        }
      } else
        r.startRowOrCellEdit(e, t);
      s.dispatchEvent({ type: "keyShortcutChangedCellEnd" });
    }
  }
  onEnterKeyDown(e) {
    if (this.cellCtrl.isEditing() || this.rowCtrl.isEditing())
      this.cellCtrl.stopEditingAndFocus(!1, e.shiftKey);
    else if (this.beans.gos.get("enterNavigatesVertically")) {
      const t = e.shiftKey ? ae.UP : ae.DOWN;
      this.beans.navigationService.navigateToNextCell(null, t, this.cellCtrl.getCellPosition(), !1);
    } else
      this.cellCtrl.startRowOrCellEdit(ae.ENTER, e), this.cellCtrl.isEditing() && e.preventDefault();
  }
  onF2KeyDown(e) {
    this.cellCtrl.isEditing() || this.cellCtrl.startRowOrCellEdit(ae.F2, e);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onEscapeKeyDown(e) {
    this.cellCtrl.isEditing() && (this.cellCtrl.stopRowOrCellEdit(!0), this.cellCtrl.focusCell(!0));
  }
  processCharacter(e) {
    if (e.target !== this.eGui || this.cellCtrl.isEditing())
      return;
    const n = e.key;
    n === " " ? this.onSpaceKeyDown(e) : (this.cellCtrl.startRowOrCellEdit(n, e), e.preventDefault());
  }
  onSpaceKeyDown(e) {
    const { gos: t } = this.beans;
    if (!this.cellCtrl.isEditing() && t.isRowSelection()) {
      const r = this.rowNode.isSelected(), n = !r;
      if (n || !t.get("suppressRowDeselection")) {
        const i = this.beans.gos.get("groupSelectsFiltered"), o = this.rowNode.setSelectedParams({
          newValue: n,
          rangeSelect: e.shiftKey,
          groupSelectsFiltered: i,
          event: e,
          source: "spaceKey"
        });
        r === void 0 && o === 0 && this.rowNode.setSelectedParams({
          newValue: !1,
          rangeSelect: e.shiftKey,
          groupSelectsFiltered: i,
          event: e,
          source: "spaceKey"
        });
      }
    }
    e.preventDefault();
  }
  destroy() {
    super.destroy();
  }
}, dVe = class extends he {
  constructor(e, t, r) {
    super(), this.cellCtrl = e, this.beans = t, this.column = r;
  }
  onMouseEvent(e, t) {
    if (!Vl(t))
      switch (e) {
        case "click":
          this.onCellClicked(t);
          break;
        case "mousedown":
        case "touchstart":
          this.onMouseDown(t);
          break;
        case "dblclick":
          this.onCellDoubleClicked(t);
          break;
        case "mouseout":
          this.onMouseOut(t);
          break;
        case "mouseover":
          this.onMouseOver(t);
          break;
      }
  }
  onCellClicked(e) {
    if (this.isDoubleClickOnIPad()) {
      this.onCellDoubleClicked(e), e.preventDefault();
      return;
    }
    const { eventService: t, rangeService: r, gos: n } = this.beans, i = e.ctrlKey || e.metaKey;
    r && i && r.getCellRangeCount(this.cellCtrl.getCellPosition()) > 1 && r.intersectLastRange(!0);
    const o = this.cellCtrl.createEvent(e, "cellClicked");
    t.dispatchEvent(o);
    const a = this.column.getColDef();
    a.onCellClicked && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        a.onCellClicked(o);
      });
    }, 0), (n.get("singleClickEdit") || a.singleClickEdit) && !n.get("suppressClickEdit") && !(e.shiftKey && (r == null ? void 0 : r.getCellRanges().length) != 0) && this.cellCtrl.startRowOrCellEdit();
  }
  // returns true if on iPad and this is second 'click' event in 200ms
  isDoubleClickOnIPad() {
    if (!su() || qU("dblclick"))
      return !1;
    const e = (/* @__PURE__ */ new Date()).getTime(), t = e - this.lastIPadMouseClickEvent < 200;
    return this.lastIPadMouseClickEvent = e, t;
  }
  onCellDoubleClicked(e) {
    const { column: t, beans: r, cellCtrl: n } = this, { eventService: i, frameworkOverrides: o, gos: a } = r, s = t.getColDef(), l = n.createEvent(e, "cellDoubleClicked");
    i.dispatchEvent(l), typeof s.onCellDoubleClicked == "function" && window.setTimeout(() => {
      o.wrapOutgoing(() => {
        s.onCellDoubleClicked(l);
      });
    }, 0), !a.get("singleClickEdit") && !a.get("suppressClickEdit") && n.startRowOrCellEdit(null, e);
  }
  onMouseDown(e) {
    const { ctrlKey: t, metaKey: r, shiftKey: n } = e, i = e.target, { cellCtrl: o, beans: a } = this, { eventService: s, rangeService: l, focusService: u, gos: c } = a;
    if (this.isRightClickInExistingRange(e))
      return;
    const d = l && l.getCellRanges().length != 0;
    if (!n || !d) {
      const f = c.get("enableCellTextSelection") && e.defaultPrevented, p = (Zs() || f) && !o.isEditing() && !wA(i);
      o.focusCell(p);
    }
    if (n && d && !u.isCellFocused(o.getCellPosition())) {
      e.preventDefault();
      const h = u.getFocusedCell();
      if (h) {
        const { column: f, rowIndex: p, rowPinned: g } = h, v = a.rowRenderer.getRowByPosition({ rowIndex: p, rowPinned: g }), m = v == null ? void 0 : v.getCellCtrl(f);
        m != null && m.isEditing() && m.stopEditing(), u.setFocusedCell({
          column: f,
          rowIndex: p,
          rowPinned: g,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0
        });
      }
    }
    if (!this.containsWidget(i)) {
      if (l) {
        const h = this.cellCtrl.getCellPosition();
        if (n)
          l.extendLatestRangeToCell(h);
        else {
          const f = t || r;
          l.setRangeToCell(h, f);
        }
      }
      s.dispatchEvent(this.cellCtrl.createEvent(e, "cellMouseDown"));
    }
  }
  isRightClickInExistingRange(e) {
    const { rangeService: t } = this.beans;
    if (t) {
      const r = t.isCellInAnyRange(this.cellCtrl.getCellPosition()), n = e.button === 2 || e.ctrlKey && this.beans.gos.get("allowContextMenuWithControlKey");
      if (r && n)
        return !0;
    }
    return !1;
  }
  containsWidget(e) {
    return wh(e, "ag-selection-checkbox", 3);
  }
  onMouseOut(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const t = this.cellCtrl.createEvent(e, "cellMouseOut");
    this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.clearMouseOver();
  }
  onMouseOver(e) {
    if (this.mouseStayingInsideCell(e))
      return;
    const t = this.cellCtrl.createEvent(e, "cellMouseOver");
    this.beans.eventService.dispatchEvent(t), this.beans.columnHoverService.setMouseOver([this.column]);
  }
  mouseStayingInsideCell(e) {
    if (!e.target || !e.relatedTarget)
      return !1;
    const t = this.cellCtrl.getGui(), r = t.contains(e.target), n = t.contains(e.relatedTarget);
    return r && n;
  }
  destroy() {
    super.destroy();
  }
}, hVe = class extends he {
  constructor(e, t) {
    super(), this.cellCtrl = e, this.beans = t, this.column = e.getColumn(), this.rowNode = e.getRowNode();
  }
  setupRowSpan() {
    this.rowSpan = this.column.getRowSpan(this.rowNode), this.addManagedListeners(this.beans.eventService, { newColumnsLoaded: () => this.onNewColumnsLoaded() });
  }
  setComp(e) {
    this.eGui = e, this.setupColSpan(), this.setupRowSpan(), this.onLeftChanged(), this.onWidthChanged(), this.applyRowSpan();
  }
  onNewColumnsLoaded() {
    const e = this.column.getRowSpan(this.rowNode);
    this.rowSpan !== e && (this.rowSpan = e, this.applyRowSpan(!0));
  }
  onDisplayColumnsChanged() {
    const e = this.getColSpanningList();
    Jc(this.colsSpanning, e) || (this.colsSpanning = e, this.onWidthChanged(), this.onLeftChanged());
  }
  setupColSpan() {
    this.column.getColDef().colSpan != null && (this.colsSpanning = this.getColSpanningList(), this.addManagedListeners(this.beans.eventService, {
      // because we are col spanning, a reorder of the cols can change what cols we are spanning over
      displayedColumnsChanged: this.onDisplayColumnsChanged.bind(this),
      // because we are spanning over multiple cols, we check for width any time any cols width changes.
      // this is expensive - really we should be explicitly checking only the cols we are spanning over
      // instead of every col, however it would be tricky code to track the cols we are spanning over, so
      // because hardly anyone will be using colSpan, am favouring this easier way for more maintainable code.
      displayedColumnsWidthChanged: this.onWidthChanged.bind(this)
    }));
  }
  onWidthChanged() {
    if (!this.eGui)
      return;
    const e = this.getCellWidth();
    this.eGui.style.width = `${e}px`;
  }
  getCellWidth() {
    return this.colsSpanning ? this.colsSpanning.reduce((e, t) => e + t.getActualWidth(), 0) : this.column.getActualWidth();
  }
  getColSpanningList() {
    const e = this.column.getColSpan(this.rowNode), t = [];
    if (e === 1)
      t.push(this.column);
    else {
      let r = this.column;
      const n = this.column.getPinned();
      for (let i = 0; r && i < e && (t.push(r), r = this.beans.visibleColsService.getColAfter(r), !(!r || Zt(r) || n !== r.getPinned())); i++)
        ;
    }
    return t;
  }
  onLeftChanged() {
    if (!this.eGui)
      return;
    const e = this.modifyLeftForPrintLayout(this.getCellLeft());
    this.eGui.style.left = e + "px";
  }
  getCellLeft() {
    let e;
    return this.beans.gos.get("enableRtl") && this.colsSpanning ? e = Jt(this.colsSpanning) : e = this.column, e.getLeft();
  }
  modifyLeftForPrintLayout(e) {
    if (!this.cellCtrl.isPrintLayout() || this.column.getPinned() === "left")
      return e;
    const t = this.beans.visibleColsService.getColsLeftWidth();
    if (this.column.getPinned() === "right") {
      const r = this.beans.visibleColsService.getBodyContainerWidth();
      return t + r + (e || 0);
    }
    return t + (e || 0);
  }
  applyRowSpan(e) {
    if (this.rowSpan === 1 && !e)
      return;
    const r = this.beans.gos.getRowHeightAsNumber() * this.rowSpan;
    this.eGui.style.height = `${r}px`, this.eGui.style.zIndex = "1";
  }
  // overriding to make public, as we don't dispose this bean via context
  destroy() {
    super.destroy();
  }
}, yp = "ag-cell-range-selected", fVe = "ag-cell-range-chart", pVe = "ag-cell-range-single-cell", gVe = "ag-cell-range-chart-category", vVe = "ag-cell-range-handle", mVe = "ag-cell-range-top", yVe = "ag-cell-range-right", CVe = "ag-cell-range-bottom", SVe = "ag-cell-range-left", wVe = class {
  constructor(e, t) {
    this.beans = e, this.rangeService = e.rangeService, this.selectionHandleFactory = e.selectionHandleFactory, this.cellCtrl = t;
  }
  setComp(e, t) {
    this.cellComp = e, this.eGui = t, this.onRangeSelectionChanged();
  }
  onRangeSelectionChanged() {
    this.cellComp && (this.rangeCount = this.rangeService.getCellRangeCount(this.cellCtrl.getCellPosition()), this.hasChartRange = this.getHasChartRange(), this.cellComp.addOrRemoveCssClass(yp, this.rangeCount !== 0), this.cellComp.addOrRemoveCssClass(`${yp}-1`, this.rangeCount === 1), this.cellComp.addOrRemoveCssClass(`${yp}-2`, this.rangeCount === 2), this.cellComp.addOrRemoveCssClass(`${yp}-3`, this.rangeCount === 3), this.cellComp.addOrRemoveCssClass(`${yp}-4`, this.rangeCount >= 4), this.cellComp.addOrRemoveCssClass(fVe, this.hasChartRange), zC(this.eGui, this.rangeCount > 0 ? !0 : void 0), this.cellComp.addOrRemoveCssClass(pVe, this.isSingleCell()), this.updateRangeBorders(), this.refreshHandle());
  }
  updateRangeBorders() {
    const e = this.getRangeBorders(), t = this.isSingleCell(), r = !t && e.top, n = !t && e.right, i = !t && e.bottom, o = !t && e.left;
    this.cellComp.addOrRemoveCssClass(mVe, r), this.cellComp.addOrRemoveCssClass(yVe, n), this.cellComp.addOrRemoveCssClass(CVe, i), this.cellComp.addOrRemoveCssClass(SVe, o);
  }
  isSingleCell() {
    const { rangeService: e } = this.beans;
    return this.rangeCount === 1 && !!e && !e.isMoreThanOneCell();
  }
  getHasChartRange() {
    const { rangeService: e } = this.beans;
    if (!this.rangeCount || !e)
      return !1;
    const t = e.getCellRanges();
    return t.length > 0 && t.every((r) => Cc([
      1,
      0
      /* VALUE */
    ], r.type));
  }
  updateRangeBordersIfRangeCount() {
    this.rangeCount > 0 && (this.updateRangeBorders(), this.refreshHandle());
  }
  getRangeBorders() {
    const e = this.beans.gos.get("enableRtl");
    let t = !1, r = !1, n = !1, i = !1;
    const o = this.cellCtrl.getCellPosition().column, a = this.beans.visibleColsService;
    let s, l;
    e ? (s = a.getColAfter(o), l = a.getColBefore(o)) : (s = a.getColBefore(o), l = a.getColAfter(o));
    const u = this.rangeService.getCellRanges().filter((c) => this.rangeService.isCellInSpecificRange(this.cellCtrl.getCellPosition(), c));
    s || (i = !0), l || (r = !0);
    for (let c = 0; c < u.length && !(t && r && n && i); c++) {
      const d = u[c], h = this.rangeService.getRangeStartRow(d), f = this.rangeService.getRangeEndRow(d);
      !t && this.beans.rowPositionUtils.sameRow(h, this.cellCtrl.getCellPosition()) && (t = !0), !n && this.beans.rowPositionUtils.sameRow(f, this.cellCtrl.getCellPosition()) && (n = !0), !i && s && d.columns.indexOf(s) < 0 && (i = !0), !r && l && d.columns.indexOf(l) < 0 && (r = !0);
    }
    return { top: t, right: r, bottom: n, left: i };
  }
  refreshHandle() {
    if (this.beans.context.isDestroyed())
      return;
    const e = this.shouldHaveSelectionHandle();
    this.selectionHandle && !e && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), e && this.addSelectionHandle(), this.cellComp.addOrRemoveCssClass(vVe, !!this.selectionHandle);
  }
  shouldHaveSelectionHandle() {
    const e = this.beans.gos, t = this.rangeService.getCellRanges(), r = t.length;
    if (this.rangeCount < 1 || r < 1)
      return !1;
    const n = Jt(t), i = this.cellCtrl.getCellPosition(), o = e.get("enableFillHandle") && !this.cellCtrl.isSuppressFillHandle(), a = e.get("enableRangeHandle");
    let s = r === 1 && !this.cellCtrl.isEditing() && (o || a);
    if (this.hasChartRange) {
      const u = t[0].type === 1 && this.rangeService.isCellInSpecificRange(i, t[0]);
      this.cellComp.addOrRemoveCssClass(gVe, u), s = n.type === 0;
    }
    return s && n.endRow != null && this.rangeService.isContiguousRange(n) && this.rangeService.isBottomRightCell(n, i);
  }
  addSelectionHandle() {
    const e = this.beans.gos, t = Jt(this.rangeService.getCellRanges()).type, n = e.get("enableFillHandle") && Zt(t) ? 0 : 1;
    this.selectionHandle && this.selectionHandle.getType() !== n && (this.selectionHandle = this.beans.context.destroyBean(this.selectionHandle)), this.selectionHandle || (this.selectionHandle = this.selectionHandleFactory.createSelectionHandle(n)), this.selectionHandle.refresh(this.cellCtrl);
  }
  destroy() {
    this.beans.context.destroyBean(this.selectionHandle);
  }
}, bVe = "ag-cell", xVe = "ag-cell-auto-height", EVe = "ag-cell-normal-height", RVe = "ag-cell-focus", _Ve = "ag-cell-first-right-pinned", TVe = "ag-cell-last-left-pinned", PVe = "ag-cell-not-inline-editing", MVe = "ag-column-hover", DVe = "ag-cell-wrap-text", AVe = 0, iY = class FT extends he {
  constructor(t, r, n, i) {
    super(), this.column = t, this.rowNode = r, this.beans = n, this.rowCtrl = i, this.cellRangeFeature = null, this.cellPositionFeature = null, this.cellCustomStyleFeature = null, this.tooltipFeature = null, this.cellMouseListenerFeature = null, this.cellKeyboardListenerFeature = null, this.suppressRefreshCell = !1, this.onCellCompAttachedFuncs = [], this.instanceId = t.getId() + "-" + AVe++, this.colIdSanitised = Za(this.column.getId()), n.gos.get("suppressCellFocus") || (this.tabIndex = -1), this.createCellPosition(), this.addFeatures(), this.updateAndFormatValue(!1);
  }
  shouldRestoreFocus() {
    return this.beans.focusService.shouldRestoreFocus(this.cellPosition);
  }
  addFeatures() {
    this.cellPositionFeature = new hVe(this, this.beans), this.addDestroyFunc(() => {
      var r;
      (r = this.cellPositionFeature) == null || r.destroy(), this.cellPositionFeature = null;
    }), this.cellCustomStyleFeature = new uVe(this, this.beans), this.addDestroyFunc(() => {
      var r;
      (r = this.cellCustomStyleFeature) == null || r.destroy(), this.cellCustomStyleFeature = null;
    }), this.cellMouseListenerFeature = new dVe(this, this.beans, this.column), this.addDestroyFunc(() => {
      var r;
      (r = this.cellMouseListenerFeature) == null || r.destroy(), this.cellMouseListenerFeature = null;
    }), this.cellKeyboardListenerFeature = new cVe(
      this,
      this.beans,
      this.column,
      this.rowNode,
      this.rowCtrl
    ), this.addDestroyFunc(() => {
      var r;
      (r = this.cellKeyboardListenerFeature) == null || r.destroy(), this.cellKeyboardListenerFeature = null;
    }), this.column.isTooltipEnabled() && (this.enableTooltipFeature(), this.addDestroyFunc(() => {
      this.disableTooltipFeature();
    })), this.beans.rangeService && this.beans.gos.get("enableRangeSelection") && (this.cellRangeFeature = new wVe(this.beans, this), this.addDestroyFunc(() => {
      var r;
      (r = this.cellRangeFeature) == null || r.destroy(), this.cellRangeFeature = null;
    }));
  }
  enableTooltipFeature(t, r) {
    const n = () => {
      const a = this.column.getColDef(), s = this.rowNode.data;
      if (a.tooltipField && Me(s))
        return ug(s, a.tooltipField, this.column.isTooltipFieldContainsDots());
      const l = a.tooltipValueGetter;
      return l ? l(
        this.beans.gos.addGridCommonParams({
          location: "cell",
          colDef: this.column.getColDef(),
          column: this.column,
          rowIndex: this.cellPosition.rowIndex,
          node: this.rowNode,
          data: this.rowNode.data,
          value: this.value,
          valueFormatted: this.valueFormatted
        })
      ) : null;
    }, i = this.beans.gos.get("tooltipShowMode") === "whenTruncated";
    !r && i && !this.isCellRenderer() && (r = () => {
      const a = this.getGui(), s = a.children.length === 0 ? a : a.querySelector(".ag-cell-value");
      return s ? s.scrollWidth > s.clientWidth : !0;
    });
    const o = {
      getColumn: () => this.column,
      getColDef: () => this.column.getColDef(),
      getRowIndex: () => this.cellPosition.rowIndex,
      getRowNode: () => this.rowNode,
      getGui: () => this.getGui(),
      getLocation: () => "cell",
      getTooltipValue: t != null ? () => t : n,
      // this makes no sense, why is the cell formatted value passed to the tooltip???
      getValueFormatted: () => this.valueFormatted,
      shouldDisplayTooltip: r
    };
    this.tooltipFeature = new bf(o, this.beans);
  }
  disableTooltipFeature() {
    this.tooltipFeature && (this.tooltipFeature.destroy(), this.tooltipFeature = null);
  }
  setComp(t, r, n, i, o) {
    var a, s, l, u;
    this.cellComp = t, this.eGui = r, this.printLayout = i, this.addDomData(), this.onCellFocused(this.focusEventToRestore), this.applyStaticCssClasses(), this.setWrapText(), this.onFirstRightPinnedChanged(), this.onLastLeftPinnedChanged(), this.onColumnHover(), this.setupControlComps(), this.setupAutoHeight(n), this.refreshFirstAndLastStyles(), this.refreshAriaColIndex(), (a = this.cellPositionFeature) == null || a.setComp(r), (s = this.cellCustomStyleFeature) == null || s.setComp(t), (l = this.tooltipFeature) == null || l.refreshToolTip(), (u = this.cellKeyboardListenerFeature) == null || u.setComp(this.eGui), this.cellRangeFeature && this.cellRangeFeature.setComp(t, r), o && this.isCellEditable() ? this.startEditing() : this.showValue(), this.onCellCompAttachedFuncs.length && (this.onCellCompAttachedFuncs.forEach((c) => c()), this.onCellCompAttachedFuncs = []);
  }
  setupAutoHeight(t) {
    if (this.isAutoHeight = this.column.isAutoHeight(), !this.isAutoHeight || !t)
      return;
    const r = t.parentElement, n = this.beans.gos.getRowHeightForNode(this.rowNode).height, i = (s) => {
      if (this.editing || !this.isAlive())
        return;
      const { paddingTop: l, paddingBottom: u, borderBottomWidth: c, borderTopWidth: d } = ed(r), h = l + u + c + d, p = t.offsetHeight + h;
      if (s < 5) {
        const v = this.beans.gos.getDocument(), m = !v || !v.contains(t), y = p == 0;
        if (m || y) {
          window.setTimeout(() => i(s + 1), 0);
          return;
        }
      }
      const g = Math.max(p, n);
      this.rowNode.setRowAutoHeight(g, this.column);
    }, o = () => i(0);
    o();
    const a = this.beans.resizeObserverService.observeResize(t, o);
    this.addDestroyFunc(() => {
      a(), this.rowNode.setRowAutoHeight(void 0, this.column);
    });
  }
  getCellAriaRole() {
    return this.column.getColDef().cellAriaRole ?? "gridcell";
  }
  getInstanceId() {
    return this.instanceId;
  }
  getColumnIdSanitised() {
    return this.colIdSanitised;
  }
  getTabIndex() {
    return this.tabIndex;
  }
  isCellRenderer() {
    const t = this.column.getColDef();
    return t.cellRenderer != null || t.cellRendererSelector != null;
  }
  getValueToDisplay() {
    return this.valueFormatted ?? this.value;
  }
  showValue(t = !1) {
    var i;
    const r = this.getValueToDisplay();
    let n;
    if (this.rowNode.stub) {
      const o = this.createCellRendererParams();
      n = this.beans.userComponentFactory.getLoadingCellRendererDetails(
        this.column.getColDef(),
        o
      );
    } else if (this.isCellRenderer()) {
      const o = this.createCellRendererParams();
      n = this.beans.userComponentFactory.getCellRendererDetails(this.column.getColDef(), o);
    }
    this.cellComp.setRenderDetails(n, r, t), (i = this.cellRangeFeature) == null || i.refreshHandle();
  }
  setupControlComps() {
    const t = this.column.getColDef();
    this.includeSelection = this.isIncludeControl(t.checkboxSelection), this.includeRowDrag = this.isIncludeControl(t.rowDrag), this.includeDndSource = this.isIncludeControl(t.dndSource), this.cellComp.setIncludeSelection(this.includeSelection), this.cellComp.setIncludeDndSource(this.includeDndSource), this.cellComp.setIncludeRowDrag(this.includeRowDrag);
  }
  isForceWrapper() {
    return this.beans.gos.get("enableCellTextSelection") || this.column.isAutoHeight();
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  isIncludeControl(t) {
    return this.rowNode.rowPinned != null ? !1 : typeof t == "function" || t === !0;
  }
  refreshShouldDestroy() {
    const t = this.column.getColDef(), r = this.includeSelection != this.isIncludeControl(t.checkboxSelection), n = this.includeRowDrag != this.isIncludeControl(t.rowDrag), i = this.includeDndSource != this.isIncludeControl(t.dndSource), o = this.isAutoHeight != this.column.isAutoHeight();
    return r || n || i || o;
  }
  // either called internally if single cell editing, or called by rowRenderer if row editing
  startEditing(t = null, r = !1, n = null) {
    const { editService: i } = this.beans;
    if (!(!this.isCellEditable() || this.editing || !i)) {
      if (!this.cellComp) {
        this.onCellCompAttachedFuncs.push(() => {
          this.startEditing(t, r, n);
        });
        return;
      }
      i.startEditing(this, t, r, n);
    }
  }
  setEditing(t, r) {
    var n;
    this.editCompDetails = r, this.editing !== t && (this.editing = t, (n = this.cellRangeFeature) == null || n.refreshHandle());
  }
  // pass in 'true' to cancel the editing.
  stopRowOrCellEdit(t = !1) {
    this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.stopEditing(t) : this.stopEditing(t);
  }
  onPopupEditorClosed() {
    this.editing && this.stopEditingAndFocus();
  }
  /**
   * Ends the Cell Editing
   * @param cancel `True` if the edit process is being canceled.
   * @returns `True` if the value of the `GridCell` has been updated, otherwise `False`.
   */
  stopEditing(t = !1) {
    const { editService: r } = this.beans;
    return !this.editing || !r ? !1 : r.stopEditing(this, t);
  }
  createCellRendererParams() {
    return this.beans.gos.addGridCommonParams({
      value: this.value,
      valueFormatted: this.valueFormatted,
      getValue: () => this.rowNode.getValueFromValueService(this.column),
      setValue: (r) => this.beans.valueService.setValue(this.rowNode, this.column, r),
      formatValue: this.formatValue.bind(this),
      data: this.rowNode.data,
      node: this.rowNode,
      pinned: this.column.getPinned(),
      colDef: this.column.getColDef(),
      column: this.column,
      refreshCell: this.refreshCell.bind(this),
      eGridCell: this.getGui(),
      eParentOfValue: this.cellComp.getParentOfValue(),
      registerRowDragger: (r, n, i, o) => this.registerRowDragger(r, n, o),
      setTooltip: (r, n) => {
        var i;
        this.tooltipFeature && this.disableTooltipFeature(), this.enableTooltipFeature(r, n), (i = this.tooltipFeature) == null || i.refreshToolTip();
      }
    });
  }
  setFocusOutOnEditor() {
    var t;
    this.editing && ((t = this.beans.editService) == null || t.setFocusOutOnEditor(this));
  }
  setFocusInOnEditor() {
    var t;
    this.editing && ((t = this.beans.editService) == null || t.setFocusInOnEditor(this));
  }
  onCellChanged(t) {
    t.column === this.column && this.refreshCell({});
  }
  refreshOrDestroyCell(t) {
    var r;
    this.refreshShouldDestroy() ? (r = this.rowCtrl) == null || r.recreateCell(this) : this.refreshCell(t);
  }
  // + stop editing {forceRefresh: true, suppressFlash: true}
  // + event cellChanged {}
  // + cellRenderer.params.refresh() {} -> method passes 'as is' to the cellRenderer, so params could be anything
  // + rowCtrl: event dataChanged {suppressFlash: !update, newData: !update}
  // + rowCtrl: api refreshCells() {animate: true/false}
  // + rowRenderer: api softRefreshView() {}
  refreshCell(t) {
    var c, d, h, f, p;
    if (this.suppressRefreshCell || this.editing)
      return;
    const r = this.column.getColDef(), n = t != null && !!t.newData, i = t != null && !!t.suppressFlash || !!r.suppressCellFlash, o = r.field == null && r.valueGetter == null && r.showRowGroup == null, a = t && t.forceRefresh || o || n, s = !!this.cellComp, l = this.updateAndFormatValue(s), u = a || l;
    if (s) {
      if (u) {
        this.showValue(n);
        const g = (c = this.beans.filterManager) == null ? void 0 : c.isSuppressFlashingCellsBecauseFiltering();
        !i && !g && (this.beans.gos.get("enableCellChangeFlash") || r.enableCellChangeFlash) && this.flashCell(), (d = this.cellCustomStyleFeature) == null || d.applyUserStyles(), (h = this.cellCustomStyleFeature) == null || h.applyClassesFromColDef();
      }
      (f = this.tooltipFeature) == null || f.refreshToolTip(), (p = this.cellCustomStyleFeature) == null || p.applyCellClassRules();
    }
  }
  // cell editors call this, when they want to stop for reasons other
  // than what we pick up on. eg selecting from a dropdown ends editing.
  stopEditingAndFocus(t = !1, r = !1) {
    var n;
    (n = this.beans.editService) == null || n.stopEditingAndFocus(this, t, r);
  }
  // user can also call this via API
  flashCell(t) {
    const r = (t == null ? void 0 : t.flashDuration) ?? (t == null ? void 0 : t.flashDelay), n = (t == null ? void 0 : t.fadeDuration) ?? (t == null ? void 0 : t.fadeDelay);
    this.animateCell("data-changed", r, n);
  }
  animateCell(t, r, n) {
    if (!this.cellComp)
      return;
    const i = `ag-cell-${t}`, o = `ag-cell-${t}-animation`, { gos: a } = this.beans;
    r || (r = a.get("cellFlashDuration")), Me(n) || (n = a.get("cellFadeDuration")), this.cellComp.addOrRemoveCssClass(i, !0), this.cellComp.addOrRemoveCssClass(o, !1), this.beans.frameworkOverrides.wrapIncoming(() => {
      window.setTimeout(() => {
        this.isAlive() && (this.cellComp.addOrRemoveCssClass(i, !1), this.cellComp.addOrRemoveCssClass(o, !0), this.eGui.style.transition = `background-color ${n}ms`, window.setTimeout(() => {
          this.isAlive() && (this.cellComp.addOrRemoveCssClass(o, !1), this.eGui.style.transition = "");
        }, n));
      }, r);
    });
  }
  onFlashCells(t) {
    if (!this.cellComp)
      return;
    const r = this.beans.cellPositionUtils.createId(this.getCellPosition());
    t.cells[r] && this.animateCell("highlight");
  }
  isCellEditable() {
    return this.column.isCellEditable(this.rowNode);
  }
  isSuppressFillHandle() {
    return this.column.isSuppressFillHandle();
  }
  formatValue(t) {
    return this.callValueFormatter(t) ?? t;
  }
  callValueFormatter(t) {
    return this.beans.valueService.formatValue(this.column, this.rowNode, t);
  }
  updateAndFormatValue(t) {
    const r = this.value, n = this.valueFormatted;
    return this.value = this.rowNode.getValueFromValueService(this.column), this.valueFormatted = this.callValueFormatter(this.value), t ? !this.valuesAreEqual(r, this.value) || this.valueFormatted != n : !0;
  }
  valuesAreEqual(t, r) {
    const n = this.column.getColDef();
    return n.equals ? n.equals(t, r) : t === r;
  }
  getComp() {
    return this.cellComp;
  }
  getValue() {
    return this.value;
  }
  addDomData() {
    const t = this.getGui();
    this.beans.gos.setDomData(t, FT.DOM_DATA_KEY_CELL_CTRL, this), this.addDestroyFunc(() => this.beans.gos.setDomData(t, FT.DOM_DATA_KEY_CELL_CTRL, null));
  }
  createEvent(t, r) {
    return this.beans.gos.addGridCommonParams({
      type: r,
      node: this.rowNode,
      data: this.rowNode.data,
      value: this.value,
      column: this.column,
      colDef: this.column.getColDef(),
      rowPinned: this.rowNode.rowPinned,
      event: t,
      rowIndex: this.rowNode.rowIndex
    });
  }
  processCharacter(t) {
    var r;
    (r = this.cellKeyboardListenerFeature) == null || r.processCharacter(t);
  }
  onKeyDown(t) {
    var r;
    (r = this.cellKeyboardListenerFeature) == null || r.onKeyDown(t);
  }
  onMouseEvent(t, r) {
    var n;
    (n = this.cellMouseListenerFeature) == null || n.onMouseEvent(t, r);
  }
  getGui() {
    return this.eGui;
  }
  getColSpanningList() {
    return this.cellPositionFeature.getColSpanningList();
  }
  onLeftChanged() {
    var t;
    this.cellComp && ((t = this.cellPositionFeature) == null || t.onLeftChanged());
  }
  onDisplayedColumnsChanged() {
    this.eGui && (this.refreshAriaColIndex(), this.refreshFirstAndLastStyles());
  }
  refreshFirstAndLastStyles() {
    const { cellComp: t, column: r, beans: n } = this;
    KK(t, r, n.visibleColsService);
  }
  refreshAriaColIndex() {
    const t = this.beans.visibleColsService.getAriaColIndex(this.column);
    sK(this.getGui(), t);
  }
  isSuppressNavigable() {
    return this.column.isSuppressNavigable(this.rowNode);
  }
  onWidthChanged() {
    var t;
    return (t = this.cellPositionFeature) == null ? void 0 : t.onWidthChanged();
  }
  getColumn() {
    return this.column;
  }
  getRowNode() {
    return this.rowNode;
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getCellPosition() {
    return this.cellPosition;
  }
  isEditing() {
    return this.editing;
  }
  // called by rowRenderer when user navigates via tab key
  startRowOrCellEdit(t, r = null) {
    if (!this.cellComp) {
      this.onCellCompAttachedFuncs.push(() => {
        this.startRowOrCellEdit(t, r);
      });
      return;
    }
    this.beans.gos.get("editType") === "fullRow" ? this.rowCtrl.startRowEditing(t, this) : this.startEditing(t, !0, r);
  }
  getRowCtrl() {
    return this.rowCtrl;
  }
  getRowPosition() {
    return {
      rowIndex: this.cellPosition.rowIndex,
      rowPinned: this.cellPosition.rowPinned
    };
  }
  updateRangeBordersIfRangeCount() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.updateRangeBordersIfRangeCount();
  }
  onRangeSelectionChanged() {
    this.cellComp && this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
  }
  isRangeSelectionEnabled() {
    return this.cellRangeFeature != null;
  }
  focusCell(t = !1) {
    this.beans.focusService.setFocusedCell({
      rowIndex: this.getCellPosition().rowIndex,
      column: this.column,
      rowPinned: this.rowNode.rowPinned,
      forceBrowserFocus: t
    });
  }
  onRowIndexChanged() {
    this.createCellPosition(), this.onCellFocused(), this.cellRangeFeature && this.cellRangeFeature.onRangeSelectionChanged();
  }
  onFirstRightPinnedChanged() {
    if (!this.cellComp)
      return;
    const t = this.column.isFirstRightPinned();
    this.cellComp.addOrRemoveCssClass(_Ve, t);
  }
  onLastLeftPinnedChanged() {
    if (!this.cellComp)
      return;
    const t = this.column.isLastLeftPinned();
    this.cellComp.addOrRemoveCssClass(TVe, t);
  }
  onCellFocused(t) {
    if (this.beans.gos.get("suppressCellFocus"))
      return;
    const r = this.beans.focusService.isCellFocused(this.cellPosition);
    if (!this.cellComp) {
      r && (t != null && t.forceBrowserFocus) && (this.focusEventToRestore = t);
      return;
    }
    if (this.focusEventToRestore = void 0, this.cellComp.addOrRemoveCssClass(RVe, r), r && t && t.forceBrowserFocus) {
      let i = this.cellComp.getFocusableElement();
      if (this.editing) {
        const o = this.beans.focusService.findFocusableElements(i, null, !0);
        o.length && (i = o[0]);
      }
      i.focus({ preventScroll: !!t.preventScrollOnBrowserFocus });
    }
    const n = this.beans.gos.get("editType") === "fullRow";
    !r && !n && this.editing && this.stopRowOrCellEdit(), r && this.rowCtrl.announceDescription();
  }
  createCellPosition() {
    this.cellPosition = {
      rowIndex: this.rowNode.rowIndex,
      rowPinned: Sc(this.rowNode.rowPinned),
      column: this.column
    };
  }
  // CSS Classes that only get applied once, they never change
  applyStaticCssClasses() {
    this.cellComp.addOrRemoveCssClass(bVe, !0), this.cellComp.addOrRemoveCssClass(PVe, !0);
    const t = this.column.isAutoHeight() == !0;
    this.cellComp.addOrRemoveCssClass(xVe, t), this.cellComp.addOrRemoveCssClass(EVe, !t);
  }
  onColumnHover() {
    if (!this.cellComp || !this.beans.gos.get("columnHoverHighlight"))
      return;
    const t = this.beans.columnHoverService.isHovered(this.column);
    this.cellComp.addOrRemoveCssClass(MVe, t);
  }
  onColDefChanged() {
    var r;
    if (!this.cellComp)
      return;
    this.column.isTooltipEnabled() ? (this.disableTooltipFeature(), this.enableTooltipFeature()) : this.disableTooltipFeature(), this.setWrapText(), this.editing ? (r = this.beans.editService) == null || r.handleColDefChanged(this) : this.refreshOrDestroyCell({ forceRefresh: !0, suppressFlash: !0 });
  }
  setWrapText() {
    const t = this.column.getColDef().wrapText == !0;
    this.cellComp.addOrRemoveCssClass(DVe, t);
  }
  dispatchCellContextMenuEvent(t) {
    const r = this.column.getColDef(), n = this.createEvent(t, "cellContextMenu");
    this.beans.eventService.dispatchEvent(n), r.onCellContextMenu && window.setTimeout(() => {
      this.beans.frameworkOverrides.wrapOutgoing(() => {
        r.onCellContextMenu(n);
      });
    }, 0);
  }
  getCellRenderer() {
    return this.cellComp ? this.cellComp.getCellRenderer() : null;
  }
  getCellEditor() {
    return this.cellComp ? this.cellComp.getCellEditor() : null;
  }
  destroy() {
    this.onCellCompAttachedFuncs = [], super.destroy();
  }
  createSelectionCheckbox() {
    const t = new sVe();
    return this.beans.context.createBean(t), t.init({ rowNode: this.rowNode, column: this.column }), t;
  }
  createDndSource() {
    const t = new lVe(this.rowNode, this.column, this.eGui);
    return this.beans.context.createBean(t), t;
  }
  registerRowDragger(t, r, n) {
    if (this.customRowDragComp) {
      this.customRowDragComp.setDragElement(t, r);
      return;
    }
    const i = this.createRowDragComp(t, r, n);
    i && (this.customRowDragComp = i, this.addDestroyFunc(() => {
      this.beans.context.destroyBean(i), this.customRowDragComp = null;
    }));
  }
  createRowDragComp(t, r, n) {
    const i = this.beans.gos.get("pagination"), o = this.beans.gos.get("rowDragManaged"), a = this.beans.gos.isRowModelType("clientSide");
    if (o) {
      if (!a) {
        Se("managed row dragging is only allowed in the Client Side Row Model");
        return;
      }
      if (i) {
        Se("managed row dragging is not possible when doing pagination");
        return;
      }
    }
    const s = new MT(
      () => this.value,
      this.rowNode,
      this.column,
      t,
      r,
      n
    );
    return this.beans.context.createBean(s), s;
  }
  setSuppressRefreshCell(t) {
    this.suppressRefreshCell = t;
  }
  getEditCompDetails() {
    return this.editCompDetails;
  }
};
iY.DOM_DATA_KEY_CELL_CTRL = "cellCtrl";
var bc = iY, IVe = 0, oY = class LT extends he {
  constructor(t, r, n, i, o) {
    var a;
    super(), this.allRowGuis = [], this.active = !0, this.centerCellCtrls = { list: [], map: {} }, this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} }, this.slideInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.fadeInAnimation = {
      left: !1,
      center: !1,
      right: !1,
      fullWidth: !1
    }, this.rowDragComps = [], this.lastMouseDownOnDragger = !1, this.emptyStyle = {}, this.updateColumnListsPending = !1, this.rowId = null, this.businessKeySanitised = null, this.beans = r, this.gos = r.gos, this.rowNode = t, this.paginationPage = ((a = r.paginationService) == null ? void 0 : a.getCurrentPage()) ?? 0, this.useAnimationFrameForCreate = i, this.printLayout = o, this.suppressRowTransform = this.gos.get("suppressRowTransform"), this.instanceId = t.id + "-" + IVe++, this.rowId = Za(t.id), this.initRowBusinessKey(), this.rowFocused = r.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned), this.rowLevel = r.rowCssClassCalculator.calculateRowLevel(this.rowNode), this.setRowType(), this.setAnimateFlags(n), this.rowStyles = this.processStylesFromGridOptions(), this.isFullWidth() && !this.gos.get("suppressCellFocus") && (this.tabIndex = -1), this.addListeners();
  }
  initRowBusinessKey() {
    this.businessKeyForNodeFunc = this.gos.get("getBusinessKeyForNode"), this.updateRowBusinessKey();
  }
  updateRowBusinessKey() {
    if (typeof this.businessKeyForNodeFunc != "function")
      return;
    const t = this.businessKeyForNodeFunc(this.rowNode);
    this.businessKeySanitised = Za(t);
  }
  getRowId() {
    return this.rowId;
  }
  getRowStyles() {
    return this.rowStyles;
  }
  getTabIndex() {
    return this.tabIndex;
  }
  isSticky() {
    return this.rowNode.sticky;
  }
  getInstanceId() {
    return this.instanceId;
  }
  updateGui(t, r) {
    t === "left" ? this.leftGui = r : t === "right" ? this.rightGui = r : t === "fullWidth" ? this.fullWidthGui = r : this.centerGui = r;
  }
  setComp(t, r, n) {
    const i = { rowComp: t, element: r, containerType: n };
    this.allRowGuis.push(i), this.updateGui(n, i), this.initialiseRowComp(i), this.rowType !== "FullWidthLoading" && !this.rowNode.rowPinned && this.beans.rowRenderer.dispatchFirstDataRenderedEvent();
  }
  unsetComp(t) {
    this.allRowGuis = this.allRowGuis.filter((r) => r.containerType !== t), this.updateGui(t, void 0);
  }
  isCacheable() {
    return this.rowType === "FullWidthDetail" && this.gos.get("keepDetailRows");
  }
  setCached(t) {
    const r = t ? "none" : "";
    this.allRowGuis.forEach((n) => n.element.style.display = r);
  }
  initialiseRowComp(t) {
    const r = this.gos;
    this.listenOnDomOrder(t), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights(), this.onRowHeightChanged(t), this.updateRowIndexes(t), this.setFocusedClasses(t), this.setStylesFromGridOptions(!1, t), r.isRowSelection() && this.rowNode.selectable && this.onRowSelected(t), this.updateColumnLists(!this.useAnimationFrameForCreate);
    const n = t.rowComp;
    this.getInitialRowClasses(t.containerType).forEach((o) => n.addOrRemoveCssClass(o, !0)), this.executeSlideAndFadeAnimations(t), this.rowNode.group && HC(t.element, this.rowNode.expanded == !0), this.setRowCompRowId(n), this.setRowCompRowBusinessKey(n), r.setDomData(t.element, LT.DOM_DATA_KEY_ROW_CTRL, this), this.addDestroyFunc(() => r.setDomData(t.element, LT.DOM_DATA_KEY_ROW_CTRL, null)), this.useAnimationFrameForCreate ? this.beans.animationFrameService.createTask(
      this.addHoverFunctionality.bind(this, t.element),
      this.rowNode.rowIndex,
      "createTasksP2"
    ) : this.addHoverFunctionality(t.element), this.isFullWidth() && this.setupFullWidth(t), r.get("rowDragEntireRow") && this.addRowDraggerToRow(t), this.useAnimationFrameForCreate && this.beans.animationFrameService.addDestroyTask(() => {
      this.isAlive() && t.rowComp.addOrRemoveCssClass("ag-after-created", !0);
    }), this.executeProcessRowPostCreateFunc();
  }
  setRowCompRowBusinessKey(t) {
    this.businessKeySanitised != null && t.setRowBusinessKey(this.businessKeySanitised);
  }
  getBusinessKey() {
    return this.businessKeySanitised;
  }
  setRowCompRowId(t) {
    this.rowId = Za(this.rowNode.id), this.rowId != null && t.setRowId(this.rowId);
  }
  executeSlideAndFadeAnimations(t) {
    const { containerType: r } = t;
    this.slideInAnimation[r] && (RG(() => {
      this.onTopChanged();
    }), this.slideInAnimation[r] = !1), this.fadeInAnimation[r] && (RG(() => {
      t.rowComp.addOrRemoveCssClass("ag-opacity-zero", !1);
    }), this.fadeInAnimation[r] = !1);
  }
  addRowDraggerToRow(t) {
    if (this.gos.get("enableRangeSelection")) {
      Se(
        "Setting `rowDragEntireRow: true` in the gridOptions doesn't work with `enableRangeSelection: true`"
      );
      return;
    }
    const r = this.beans.localeService.getLocaleTextFunc(), n = new MT(
      () => `1 ${r("rowDragRow", "row")}`,
      this.rowNode,
      void 0,
      t.element,
      void 0,
      !0
    ), i = this.createBean(n, this.beans.context);
    this.rowDragComps.push(i);
  }
  setupFullWidth(t) {
    const r = this.getPinnedForContainer(t.containerType);
    if (this.rowType == "FullWidthDetail" && !Xn.__assertRegistered(
      "@ag-grid-enterprise/master-detail",
      "cell renderer 'agDetailCellRenderer' (for master detail)",
      this.beans.context.getGridId()
    ))
      return;
    const n = this.createFullWidthCompDetails(t.element, r);
    t.rowComp.showFullWidth(n);
  }
  isPrintLayout() {
    return this.printLayout;
  }
  getFullWidthCellRenderers() {
    var t, r;
    return this.gos.get("embedFullWidthRows") ? this.allRowGuis.map((n) => {
      var i;
      return (i = n == null ? void 0 : n.rowComp) == null ? void 0 : i.getFullWidthCellRenderer();
    }) : [(r = (t = this.fullWidthGui) == null ? void 0 : t.rowComp) == null ? void 0 : r.getFullWidthCellRenderer()];
  }
  // use by autoWidthCalculator, as it clones the elements
  getCellElement(t) {
    const r = this.getCellCtrl(t);
    return r ? r.getGui() : null;
  }
  executeProcessRowPostCreateFunc() {
    const t = this.gos.getCallback("processRowPostCreate");
    if (!t || !this.areAllContainersReady())
      return;
    const r = {
      // areAllContainersReady asserts that centerGui is not null
      eRow: this.centerGui.element,
      ePinnedLeftRow: this.leftGui ? this.leftGui.element : void 0,
      ePinnedRightRow: this.rightGui ? this.rightGui.element : void 0,
      node: this.rowNode,
      rowIndex: this.rowNode.rowIndex,
      addRenderedRowListener: this.addEventListener.bind(this)
    };
    t(r);
  }
  areAllContainersReady() {
    const t = !!this.leftGui || !this.beans.visibleColsService.isPinningLeft(), r = !!this.centerGui, n = !!this.rightGui || !this.beans.visibleColsService.isPinningRight();
    return t && r && n;
  }
  setRowType() {
    const t = this.rowNode.stub && !this.gos.get("suppressServerSideFullWidthLoadingRow"), r = this.rowNode.isFullWidthCell(), n = this.gos.get("masterDetail") && this.rowNode.detail, i = this.beans.columnModel.isPivotMode(), a = !!this.rowNode.group && !this.rowNode.footer && this.gos.isGroupUseEntireRow(i);
    t ? this.rowType = "FullWidthLoading" : n ? this.rowType = "FullWidthDetail" : r ? this.rowType = "FullWidth" : a ? this.rowType = "FullWidthGroup" : this.rowType = "Normal";
  }
  updateColumnLists(t = !1, r = !1) {
    if (this.isFullWidth())
      return;
    if (t || this.gos.get("suppressAnimationFrame") || this.printLayout) {
      this.updateColumnListsImpl(r);
      return;
    }
    this.updateColumnListsPending || (this.beans.animationFrameService.createTask(
      () => {
        this.active && this.updateColumnListsImpl(!0);
      },
      this.rowNode.rowIndex,
      "createTasksP1"
    ), this.updateColumnListsPending = !0);
  }
  createCellCtrls(t, r, n = null) {
    const i = {
      list: [],
      map: {}
    }, o = (a, s) => {
      i.list.push(s), i.map[a] = s;
    };
    return r.forEach((a) => {
      const s = a.getInstanceId();
      let l = t.map[s];
      l || (l = new bc(a, this.rowNode, this.beans, this)), o(s, l);
    }), t.list.forEach((a) => {
      if (i.map[a.getColumn().getInstanceId()] != null)
        return;
      if (!this.isCellEligibleToBeRemoved(a, n)) {
        o(a.getColumn().getInstanceId(), a);
        return;
      }
      a.destroy();
    }), i;
  }
  updateColumnListsImpl(t) {
    this.updateColumnListsPending = !1, this.createAllCellCtrls(), this.setCellCtrls(t);
  }
  setCellCtrls(t) {
    this.allRowGuis.forEach((r) => {
      const n = this.getCellCtrlsForContainer(r.containerType);
      r.rowComp.setCellCtrls(n, t);
    });
  }
  getCellCtrlsForContainer(t) {
    switch (t) {
      case "left":
        return this.leftCellCtrls.list;
      case "right":
        return this.rightCellCtrls.list;
      case "fullWidth":
        return [];
      case "center":
        return this.centerCellCtrls.list;
    }
  }
  createAllCellCtrls() {
    const t = this.beans.columnViewportService, r = this.beans.visibleColsService;
    if (this.printLayout)
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, r.getAllCols()), this.leftCellCtrls = { list: [], map: {} }, this.rightCellCtrls = { list: [], map: {} };
    else {
      const n = t.getColsWithinViewport(this.rowNode);
      this.centerCellCtrls = this.createCellCtrls(this.centerCellCtrls, n);
      const i = r.getLeftColsForRow(this.rowNode);
      this.leftCellCtrls = this.createCellCtrls(this.leftCellCtrls, i, "left");
      const o = r.getRightColsForRow(this.rowNode);
      this.rightCellCtrls = this.createCellCtrls(this.rightCellCtrls, o, "right");
    }
  }
  isCellEligibleToBeRemoved(t, r) {
    if (t.getColumn().getPinned() != r)
      return !0;
    const a = t.isEditing(), s = this.beans.focusService.isCellFocused(t.getCellPosition());
    if (a || s) {
      const u = t.getColumn();
      return !(this.beans.visibleColsService.getAllCols().indexOf(u) >= 0);
    }
    return !0;
  }
  getDomOrder() {
    return this.gos.get("ensureDomOrder") || this.gos.isDomLayout("print");
  }
  listenOnDomOrder(t) {
    const r = () => {
      t.rowComp.setDomOrder(this.getDomOrder());
    };
    this.addManagedPropertyListener("domLayout", r), this.addManagedPropertyListener("ensureDomOrder", r);
  }
  setAnimateFlags(t) {
    if (this.isSticky() || !t)
      return;
    const r = Me(this.rowNode.oldRowTop), n = this.beans.visibleColsService.isPinningLeft(), i = this.beans.visibleColsService.isPinningRight();
    if (r) {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.slideInAnimation.fullWidth = !0;
        return;
      }
      this.slideInAnimation.center = !0, this.slideInAnimation.left = n, this.slideInAnimation.right = i;
    } else {
      if (this.isFullWidth() && !this.gos.get("embedFullWidthRows")) {
        this.fadeInAnimation.fullWidth = !0;
        return;
      }
      this.fadeInAnimation.center = !0, this.fadeInAnimation.left = n, this.fadeInAnimation.right = i;
    }
  }
  isEditing() {
    return this.editingRow;
  }
  isFullWidth() {
    return this.rowType !== "Normal";
  }
  refreshFullWidth() {
    const t = (s, l) => s ? s.rowComp.refreshFullWidth(() => this.createFullWidthCompDetails(s.element, l).params) : !0, r = t(this.fullWidthGui, null), n = t(this.centerGui, null), i = t(this.leftGui, "left"), o = t(this.rightGui, "right");
    return r && n && i && o;
  }
  addListeners() {
    this.addManagedListeners(this.rowNode, {
      heightChanged: () => this.onRowHeightChanged(),
      rowSelected: () => this.onRowSelected(),
      rowIndexChanged: this.onRowIndexChanged.bind(this),
      topChanged: this.onTopChanged.bind(this),
      expandedChanged: this.updateExpandedCss.bind(this),
      hasChildrenChanged: this.updateExpandedCss.bind(this)
    }), this.rowNode.detail && this.addManagedListeners(this.rowNode.parent, { dataChanged: this.onRowNodeDataChanged.bind(this) }), this.addManagedListeners(this.rowNode, {
      dataChanged: this.onRowNodeDataChanged.bind(this),
      cellChanged: this.postProcessCss.bind(this),
      rowHighlightChanged: this.onRowNodeHighlightChanged.bind(this),
      draggingChanged: this.postProcessRowDragging.bind(this),
      uiLevelChanged: this.onUiLevelChanged.bind(this)
    }), this.addManagedListeners(this.beans.eventService, {
      paginationPixelOffsetChanged: this.onPaginationPixelOffsetChanged.bind(this),
      heightScaleChanged: this.onTopChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      virtualColumnsChanged: this.onVirtualColumnsChanged.bind(this),
      cellFocused: this.onCellFocusChanged.bind(this),
      cellFocusCleared: this.onCellFocusChanged.bind(this),
      paginationChanged: this.onPaginationChanged.bind(this),
      modelUpdated: this.refreshFirstAndLastRowStyles.bind(this),
      columnMoved: () => this.updateColumnLists()
    }), this.addDestroyFunc(() => {
      this.destroyBeans(this.rowDragComps, this.beans.context), this.tooltipFeature && (this.tooltipFeature = this.destroyBean(this.tooltipFeature, this.beans.context));
    }), this.addManagedPropertyListeners(["rowDragEntireRow"], () => {
      if (this.gos.get("rowDragEntireRow")) {
        this.allRowGuis.forEach((r) => {
          this.addRowDraggerToRow(r);
        });
        return;
      }
      this.rowDragComps = this.destroyBeans(this.rowDragComps, this.beans.context);
    }), this.addListenersForCellComps();
  }
  addListenersForCellComps() {
    this.addManagedListeners(this.rowNode, {
      rowIndexChanged: () => {
        this.getAllCellCtrls().forEach((t) => t.onRowIndexChanged());
      },
      cellChanged: (t) => {
        this.getAllCellCtrls().forEach((r) => r.onCellChanged(t));
      }
    });
  }
  onRowNodeDataChanged(t) {
    if (this.isFullWidth() !== !!this.rowNode.isFullWidthCell()) {
      this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    if (this.isFullWidth()) {
      this.refreshFullWidth() || this.beans.rowRenderer.redrawRow(this.rowNode);
      return;
    }
    this.getAllCellCtrls().forEach(
      (n) => n.refreshCell({
        suppressFlash: !t.update,
        newData: !t.update
      })
    ), this.allRowGuis.forEach((n) => {
      this.setRowCompRowId(n.rowComp), this.updateRowBusinessKey(), this.setRowCompRowBusinessKey(n.rowComp);
    }), this.onRowSelected(), this.postProcessCss();
  }
  postProcessCss() {
    this.setStylesFromGridOptions(!0), this.postProcessClassesFromGridOptions(), this.postProcessRowClassRules(), this.postProcessRowDragging();
  }
  onRowNodeHighlightChanged() {
    const t = this.rowNode.highlighted;
    this.allRowGuis.forEach((r) => {
      const n = t === 0, i = t === 1;
      r.rowComp.addOrRemoveCssClass("ag-row-highlight-above", n), r.rowComp.addOrRemoveCssClass("ag-row-highlight-below", i);
    });
  }
  postProcessRowDragging() {
    const t = this.rowNode.dragging;
    this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass("ag-row-dragging", t));
  }
  updateExpandedCss() {
    const t = this.rowNode.isExpandable(), r = this.rowNode.expanded == !0;
    this.allRowGuis.forEach((n) => {
      n.rowComp.addOrRemoveCssClass("ag-row-group", t), n.rowComp.addOrRemoveCssClass("ag-row-group-expanded", t && r), n.rowComp.addOrRemoveCssClass("ag-row-group-contracted", t && !r), HC(n.element, t && r);
    });
  }
  onDisplayedColumnsChanged() {
    this.updateColumnLists(!0), this.beans.columnModel.wasAutoRowHeightEverActive() && this.rowNode.checkAutoHeights();
  }
  onVirtualColumnsChanged() {
    this.updateColumnLists(!1, !0);
  }
  getRowPosition() {
    return {
      rowPinned: Sc(this.rowNode.rowPinned),
      rowIndex: this.rowNode.rowIndex
    };
  }
  onKeyboardNavigate(t) {
    const r = this.allRowGuis.find(
      (l) => l.element.contains(t.target)
    );
    if (!((r ? r.element : null) === t.target))
      return;
    const o = this.rowNode, a = this.beans.focusService.getFocusedCell(), s = {
      rowIndex: o.rowIndex,
      rowPinned: o.rowPinned,
      column: a && a.column
    };
    this.beans.navigationService.navigateToNextCell(t, t.key, s, !0), t.preventDefault();
  }
  onTabKeyDown(t) {
    if (t.defaultPrevented || Vl(t))
      return;
    const r = this.allRowGuis.find(
      (a) => a.element.contains(t.target)
    ), n = r ? r.element : null, i = n === t.target;
    let o = null;
    i || (o = this.beans.focusService.findNextFocusableElement(
      n,
      !1,
      t.shiftKey
    )), (this.isFullWidth() && i || !o) && this.beans.navigationService.onTabKeyDown(this, t);
  }
  getFullWidthElement() {
    return this.fullWidthGui ? this.fullWidthGui.element : null;
  }
  getRowYPosition() {
    var r;
    const t = (r = this.allRowGuis.find((n) => ts(n.element))) == null ? void 0 : r.element;
    return t ? t.getBoundingClientRect().top : 0;
  }
  onFullWidthRowFocused(t) {
    var o;
    const r = this.rowNode, n = t ? this.isFullWidth() && t.rowIndex === r.rowIndex && t.rowPinned == r.rowPinned : !1, i = this.fullWidthGui ? this.fullWidthGui.element : (o = this.centerGui) == null ? void 0 : o.element;
    i && (i.classList.toggle("ag-full-width-focus", n), n && (t != null && t.forceBrowserFocus) && i.focus({ preventScroll: !0 }));
  }
  recreateCell(t) {
    this.centerCellCtrls = this.removeCellCtrl(this.centerCellCtrls, t), this.leftCellCtrls = this.removeCellCtrl(this.leftCellCtrls, t), this.rightCellCtrls = this.removeCellCtrl(this.rightCellCtrls, t), t.destroy(), this.updateColumnLists();
  }
  removeCellCtrl(t, r) {
    const n = {
      list: [],
      map: {}
    };
    return t.list.forEach((i) => {
      i !== r && (n.list.push(i), n.map[i.getColumn().getInstanceId()] = i);
    }), n;
  }
  onMouseEvent(t, r) {
    switch (t) {
      case "dblclick":
        this.onRowDblClick(r);
        break;
      case "click":
        this.onRowClick(r);
        break;
      case "touchstart":
      case "mousedown":
        this.onRowMouseDown(r);
        break;
    }
  }
  createRowEvent(t, r) {
    return this.gos.addGridCommonParams({
      type: t,
      node: this.rowNode,
      data: this.rowNode.data,
      rowIndex: this.rowNode.rowIndex,
      rowPinned: this.rowNode.rowPinned,
      event: r
    });
  }
  createRowEventWithSource(t, r) {
    const n = this.createRowEvent(t, r);
    return n.source = this, n;
  }
  onRowDblClick(t) {
    if (Vl(t))
      return;
    const r = this.createRowEventWithSource("rowDoubleClicked", t);
    this.beans.eventService.dispatchEvent(r);
  }
  onRowMouseDown(t) {
    if (this.lastMouseDownOnDragger = wh(t.target, "ag-row-drag", 3), !this.isFullWidth())
      return;
    const r = this.rowNode, n = this.beans.visibleColsService;
    this.beans.rangeService && this.beans.rangeService.removeAllCellRanges();
    const i = this.getFullWidthElement(), o = t.target;
    let a = !0;
    i && i.contains(o) && wA(o) && (a = !1), this.beans.focusService.setFocusedCell({
      rowIndex: r.rowIndex,
      column: n.getAllCols()[0],
      rowPinned: r.rowPinned,
      forceBrowserFocus: a
    });
  }
  onRowClick(t) {
    if (Vl(t) || this.lastMouseDownOnDragger)
      return;
    const n = this.createRowEventWithSource("rowClicked", t);
    this.beans.eventService.dispatchEvent(n);
    const i = t.ctrlKey || t.metaKey, o = t.shiftKey;
    if (
      // we do not allow selecting groups by clicking (as the click here expands the group), or if it's a detail row,
      // so return if it's a group row
      this.gos.get("groupSelectsChildren") && this.rowNode.group || this.isRowSelectionBlocked() || // if click selection suppressed, do nothing
      this.gos.get("suppressRowClickSelection")
    )
      return;
    const s = this.gos.get("rowMultiSelectWithClick"), l = !this.gos.get("suppressRowDeselection"), u = "rowClicked";
    if (this.rowNode.isSelected())
      s ? this.rowNode.setSelectedParams({ newValue: !1, event: t, source: u }) : i ? l && this.rowNode.setSelectedParams({ newValue: !1, event: t, source: u }) : this.rowNode.setSelectedParams({
        newValue: !0,
        clearSelection: !o,
        rangeSelect: o,
        event: t,
        source: u
      });
    else {
      const c = s ? !1 : !i;
      this.rowNode.setSelectedParams({
        newValue: !0,
        clearSelection: c,
        rangeSelect: o,
        event: t,
        source: u
      });
    }
  }
  isRowSelectionBlocked() {
    return !this.rowNode.selectable || !!this.rowNode.rowPinned || !this.gos.isRowSelection();
  }
  setupDetailRowAutoHeight(t) {
    if (this.rowType !== "FullWidthDetail" || !this.gos.get("detailRowAutoHeight"))
      return;
    const r = () => {
      const i = t.clientHeight;
      if (i != null && i > 0) {
        const o = () => {
          this.rowNode.setRowHeight(i), this.beans.rowModel.getType() === "clientSide" ? this.beans.rowModel.onRowHeightChanged() : this.beans.rowModel.getType() === "serverSide" && this.beans.rowModel.onRowHeightChanged();
        };
        window.setTimeout(o, 0);
      }
    }, n = this.beans.resizeObserverService.observeResize(t, r);
    this.addDestroyFunc(n), r();
  }
  createFullWidthCompDetails(t, r) {
    const { gos: n, rowNode: i } = this, o = n.addGridCommonParams({
      fullWidth: !0,
      data: i.data,
      node: i,
      value: i.key,
      valueFormatted: i.key,
      // these need to be taken out, as part of 'afterAttached' now
      eGridCell: t,
      eParentOfValue: t,
      pinned: r,
      addRenderedRowListener: this.addEventListener.bind(this),
      registerRowDragger: (s, l, u, c) => this.addFullWidthRowDragging(s, l, u, c),
      setTooltip: (s, l) => this.refreshRowTooltip(s, l)
    }), a = this.beans.userComponentFactory;
    switch (this.rowType) {
      case "FullWidthDetail":
        return a.getFullWidthDetailCellRendererDetails(o);
      case "FullWidthGroup":
        return a.getFullWidthGroupCellRendererDetails(o);
      case "FullWidthLoading":
        return a.getFullWidthLoadingCellRendererDetails(o);
      default:
        return a.getFullWidthCellRendererDetails(o);
    }
  }
  refreshRowTooltip(t, r) {
    if (!this.fullWidthGui)
      return;
    const n = {
      getGui: () => this.fullWidthGui.element,
      getTooltipValue: () => t,
      getLocation: () => "fullWidthRow",
      shouldDisplayTooltip: r
    };
    this.tooltipFeature && this.destroyBean(this.tooltipFeature, this.beans.context), this.tooltipFeature = this.createBean(new bf(n, this.beans));
  }
  addFullWidthRowDragging(t, r, n = "", i) {
    if (!this.isFullWidth())
      return;
    const o = new MT(
      () => n,
      this.rowNode,
      void 0,
      t,
      r,
      i
    );
    this.createBean(o, this.beans.context), this.addDestroyFunc(() => {
      this.destroyBean(o, this.beans.context);
    });
  }
  onUiLevelChanged() {
    const t = this.beans.rowCssClassCalculator.calculateRowLevel(this.rowNode);
    if (this.rowLevel != t) {
      const r = "ag-row-level-" + t, n = "ag-row-level-" + this.rowLevel;
      this.allRowGuis.forEach((i) => {
        i.rowComp.addOrRemoveCssClass(r, !0), i.rowComp.addOrRemoveCssClass(n, !1);
      });
    }
    this.rowLevel = t;
  }
  isFirstRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBoundsService.getFirstRow();
  }
  isLastRowOnPage() {
    return this.rowNode.rowIndex === this.beans.pageBoundsService.getLastRow();
  }
  refreshFirstAndLastRowStyles() {
    const t = this.isFirstRowOnPage(), r = this.isLastRowOnPage();
    this.firstRowOnPage !== t && (this.firstRowOnPage = t, this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass("ag-row-first", t))), this.lastRowOnPage !== r && (this.lastRowOnPage = r, this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass("ag-row-last", r)));
  }
  stopEditing(t = !1) {
    var r;
    this.stoppingRowEdit || (r = this.beans.rowEditService) == null || r.stopEditing(this, t);
  }
  setInlineEditingCss(t) {
    this.allRowGuis.forEach((r) => {
      r.rowComp.addOrRemoveCssClass("ag-row-inline-editing", t), r.rowComp.addOrRemoveCssClass("ag-row-not-inline-editing", !t);
    });
  }
  setEditingRow(t) {
    this.editingRow = t;
  }
  startRowEditing(t = null, r = null, n = null) {
    var i;
    this.editingRow || (i = this.beans.rowEditService) == null || i.startEditing(this, t, r, n);
  }
  getAllCellCtrls() {
    return this.leftCellCtrls.list.length === 0 && this.rightCellCtrls.list.length === 0 ? this.centerCellCtrls.list : [...this.centerCellCtrls.list, ...this.leftCellCtrls.list, ...this.rightCellCtrls.list];
  }
  postProcessClassesFromGridOptions() {
    const t = this.beans.rowCssClassCalculator.processClassesFromGridOptions(this.rowNode);
    !t || !t.length || t.forEach((r) => {
      this.allRowGuis.forEach((n) => n.rowComp.addOrRemoveCssClass(r, !0));
    });
  }
  postProcessRowClassRules() {
    this.beans.rowCssClassCalculator.processRowClassRules(
      this.rowNode,
      (t) => {
        this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass(t, !0));
      },
      (t) => {
        this.allRowGuis.forEach((r) => r.rowComp.addOrRemoveCssClass(t, !1));
      }
    );
  }
  setStylesFromGridOptions(t, r) {
    t && (this.rowStyles = this.processStylesFromGridOptions()), this.forEachGui(r, (n) => n.rowComp.setUserStyles(this.rowStyles));
  }
  getPinnedForContainer(t) {
    return t === "left" || t === "right" ? t : null;
  }
  getInitialRowClasses(t) {
    const r = this.getPinnedForContainer(t), n = {
      rowNode: this.rowNode,
      rowFocused: this.rowFocused,
      fadeRowIn: this.fadeInAnimation[t],
      rowIsEven: this.rowNode.rowIndex % 2 === 0,
      rowLevel: this.rowLevel,
      fullWidthRow: this.isFullWidth(),
      firstRowOnPage: this.isFirstRowOnPage(),
      lastRowOnPage: this.isLastRowOnPage(),
      printLayout: this.printLayout,
      expandable: this.rowNode.isExpandable(),
      pinned: r
    };
    return this.beans.rowCssClassCalculator.getInitialRowClasses(n);
  }
  processStylesFromGridOptions() {
    const t = this.gos.get("rowStyle");
    if (t && typeof t == "function") {
      Se("rowStyle should be an object of key/value styles, not be a function, use getRowStyle() instead");
      return;
    }
    const r = this.gos.getCallback("getRowStyle");
    let n;
    if (r) {
      const i = {
        data: this.rowNode.data,
        node: this.rowNode,
        rowIndex: this.rowNode.rowIndex
      };
      n = r(i);
    }
    return n || t ? Object.assign({}, t, n) : this.emptyStyle;
  }
  onRowSelected(t) {
    const r = !!this.rowNode.isSelected();
    this.forEachGui(t, (n) => {
      n.rowComp.addOrRemoveCssClass("ag-row-selected", r), zC(n.element, r), n.element.contains(this.gos.getActiveDomElement()) && (n === this.centerGui || n === this.fullWidthGui) && this.announceDescription();
    });
  }
  announceDescription() {
    if (this.isRowSelectionBlocked())
      return;
    const t = this.rowNode.isSelected();
    if (t && this.gos.get("suppressRowDeselection"))
      return;
    const n = this.beans.localeService.getLocaleTextFunc()(
      t ? "ariaRowDeselect" : "ariaRowSelect",
      `Press SPACE to ${t ? "deselect" : "select"} this row.`
    );
    this.beans.ariaAnnouncementService.announceValue(n);
  }
  addHoverFunctionality(t) {
    if (!this.active)
      return;
    const { rowNode: r, beans: n, gos: i } = this;
    this.addManagedListeners(t, {
      mouseenter: () => r.onMouseEnter(),
      mouseleave: () => r.onMouseLeave()
    }), this.addManagedListeners(r, {
      mouseEnter: () => {
        !n.dragService.isDragging() && !i.get("suppressRowHoverHighlight") && (t.classList.add("ag-row-hover"), r.setHovered(!0));
      },
      mouseLeave: () => {
        t.classList.remove("ag-row-hover"), r.setHovered(!1);
      }
    });
  }
  // for animation, we don't want to animate entry or exit to a very far away pixel,
  // otherwise the row would move so fast, it would appear to disappear. so this method
  // moves the row closer to the viewport if it is far away, so the row slide in / out
  // at a speed the user can see.
  roundRowTopToBounds(t) {
    const r = this.beans.ctrlsService.getGridBodyCtrl().getScrollFeature().getApproximateVScollPosition(), n = this.applyPaginationOffset(r.top, !0) - 100, i = this.applyPaginationOffset(r.bottom, !0) + 100;
    return Math.min(Math.max(n, t), i);
  }
  getFrameworkOverrides() {
    return this.beans.frameworkOverrides;
  }
  forEachGui(t, r) {
    t ? r(t) : this.allRowGuis.forEach(r);
  }
  onRowHeightChanged(t) {
    if (this.rowNode.rowHeight == null)
      return;
    const r = this.rowNode.rowHeight, n = this.beans.environment.getDefaultRowHeight(), o = this.gos.isGetRowHeightFunction() ? this.gos.getRowHeightForNode(this.rowNode).height : void 0, a = o ? `${Math.min(n, o) - 2}px` : void 0;
    this.forEachGui(t, (s) => {
      s.element.style.height = `${r}px`, a && s.element.style.setProperty("--ag-line-height", a);
    });
  }
  addEventListener(t, r) {
    super.addEventListener(t, r);
  }
  removeEventListener(t, r) {
    super.removeEventListener(t, r);
  }
  // note - this is NOT called by context, as we don't wire / unwire the CellComp for performance reasons.
  destroyFirstPass(t = !1) {
    if (this.active = !1, !t && this.gos.isAnimateRows() && !this.isSticky())
      if (this.rowNode.rowTop != null) {
        const i = this.roundRowTopToBounds(this.rowNode.rowTop);
        this.setRowTop(i);
      } else
        this.allRowGuis.forEach((i) => i.rowComp.addOrRemoveCssClass("ag-opacity-zero", !0));
    this.rowNode.setHovered(!1);
    const r = this.createRowEvent("virtualRowRemoved");
    this.dispatchLocalEvent(r), this.beans.eventService.dispatchEvent(r), super.destroy();
  }
  destroySecondPass() {
    this.allRowGuis.length = 0, this.stopEditing();
    const t = (r) => (r.list.forEach((n) => n.destroy()), { list: [], map: {} });
    this.centerCellCtrls = t(this.centerCellCtrls), this.leftCellCtrls = t(this.leftCellCtrls), this.rightCellCtrls = t(this.rightCellCtrls);
  }
  setFocusedClasses(t) {
    this.forEachGui(t, (r) => {
      r.rowComp.addOrRemoveCssClass("ag-row-focus", this.rowFocused), r.rowComp.addOrRemoveCssClass("ag-row-no-focus", !this.rowFocused);
    });
  }
  onCellFocusChanged() {
    const t = this.beans.focusService.isRowFocused(this.rowNode.rowIndex, this.rowNode.rowPinned);
    t !== this.rowFocused && (this.rowFocused = t, this.setFocusedClasses()), !t && this.editingRow && this.stopEditing(!1);
  }
  onPaginationChanged() {
    var r;
    const t = ((r = this.beans.paginationService) == null ? void 0 : r.getCurrentPage()) ?? 0;
    this.paginationPage !== t && (this.paginationPage = t, this.onTopChanged()), this.refreshFirstAndLastRowStyles();
  }
  onTopChanged() {
    this.setRowTop(this.rowNode.rowTop);
  }
  onPaginationPixelOffsetChanged() {
    this.onTopChanged();
  }
  // applies pagination offset, eg if on second page, and page height is 500px, then removes
  // 500px from the top position, so a row with rowTop 600px is displayed at location 100px.
  // reverse will take the offset away rather than add.
  applyPaginationOffset(t, r = !1) {
    if (this.rowNode.isRowPinned() || this.rowNode.sticky)
      return t;
    const n = this.beans.pageBoundsService.getPixelOffset();
    return t + n * (r ? 1 : -1);
  }
  setRowTop(t) {
    if (!this.printLayout && Me(t)) {
      const r = this.applyPaginationOffset(t), o = `${this.rowNode.isRowPinned() || this.rowNode.sticky ? r : this.beans.rowContainerHeightService.getRealPixelPosition(r)}px`;
      this.setRowTopStyle(o);
    }
  }
  // the top needs to be set into the DOM element when the element is created, not updated afterwards.
  // otherwise the transition would not work, as it would be transitioning from zero (the unset value).
  // for example, suppose a row that is outside the viewport, then user does a filter to remove other rows
  // and this row now appears in the viewport, and the row moves up (ie it was under the viewport and not rendered,
  // but now is in the viewport) then a new RowComp is created, however it should have it's position initialised
  // to below the viewport, so the row will appear to animate up. if we didn't set the initial position at creation
  // time, the row would animate down (ie from position zero).
  getInitialRowTop(t) {
    return this.suppressRowTransform ? this.getInitialRowTopShared(t) : void 0;
  }
  getInitialTransform(t) {
    return this.suppressRowTransform ? void 0 : `translateY(${this.getInitialRowTopShared(t)})`;
  }
  getInitialRowTopShared(t) {
    if (this.printLayout)
      return "";
    const r = this.rowNode;
    let n;
    if (this.isSticky())
      n = r.stickyRowTop;
    else {
      const i = this.slideInAnimation[t] ? this.roundRowTopToBounds(r.oldRowTop) : r.rowTop, o = this.applyPaginationOffset(i);
      n = r.isRowPinned() ? o : this.beans.rowContainerHeightService.getRealPixelPosition(o);
    }
    return n + "px";
  }
  setRowTopStyle(t) {
    this.allRowGuis.forEach(
      (r) => this.suppressRowTransform ? r.rowComp.setTop(t) : r.rowComp.setTransform(`translateY(${t})`)
    );
  }
  getRowNode() {
    return this.rowNode;
  }
  getCellCtrl(t) {
    let r = null;
    return this.getAllCellCtrls().forEach((n) => {
      n.getColumn() == t && (r = n);
    }), r != null || this.getAllCellCtrls().forEach((n) => {
      n.getColSpanningList().indexOf(t) >= 0 && (r = n);
    }), r;
  }
  onRowIndexChanged() {
    this.rowNode.rowIndex != null && (this.onCellFocusChanged(), this.updateRowIndexes(), this.postProcessCss());
  }
  getRowIndex() {
    return this.rowNode.getRowIndexString();
  }
  updateRowIndexes(t) {
    var a;
    const r = this.rowNode.getRowIndexString();
    if (r === null)
      return;
    const n = this.beans.headerNavigationService.getHeaderRowCount() + (((a = this.beans.filterManager) == null ? void 0 : a.getHeaderRowCount()) ?? 0), i = this.rowNode.rowIndex % 2 === 0, o = n + this.rowNode.rowIndex + 1;
    this.forEachGui(t, (s) => {
      s.rowComp.setRowIndex(r), s.rowComp.addOrRemoveCssClass("ag-row-even", i), s.rowComp.addOrRemoveCssClass("ag-row-odd", !i), vOe(s.element, o);
    });
  }
  setStoppingRowEdit(t) {
    this.stoppingRowEdit = t;
  }
};
oY.DOM_DATA_KEY_ROW_CTRL = "renderedRow";
var xc = oY, FVe = class extends he {
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService, this.valueService = e.valueService, this.menuService = e.menuService, this.ctrlsService = e.ctrlsService, this.navigationService = e.navigationService, this.focusService = e.focusService, this.undoRedoService = e.undoRedoService, this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.rangeService = e.rangeService, this.clipboardService = e.clipboardService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addKeyboardListeners(), this.addMouseListeners(), this.mockContextMenuForIPad();
  }
  addKeyboardListeners() {
    const e = "keydown", t = this.processKeyboardEvent.bind(this, e);
    this.addManagedElementListeners(this.element, { [e]: t });
  }
  addMouseListeners() {
    ["dblclick", "contextmenu", "mouseover", "mouseout", "click", qU("touchstart") ? "touchstart" : "mousedown"].forEach((r) => {
      const n = this.processMouseEvent.bind(this, r);
      this.addManagedElementListeners(this.element, { [r]: n });
    });
  }
  processMouseEvent(e, t) {
    if (!this.mouseEventService.isEventFromThisGrid(t) || Vl(t))
      return;
    const r = this.getRowForEvent(t), n = this.mouseEventService.getRenderedCellForEvent(t);
    e === "contextmenu" ? this.handleContextMenuMouseEvent(t, void 0, r, n) : (n && n.onMouseEvent(e, t), r && r.onMouseEvent(e, t));
  }
  mockContextMenuForIPad() {
    if (!su())
      return;
    const e = new Bl(this.element), t = (r) => {
      const n = this.getRowForEvent(r.touchEvent), i = this.mouseEventService.getRenderedCellForEvent(r.touchEvent);
      this.handleContextMenuMouseEvent(void 0, r.touchEvent, n, i);
    };
    this.addManagedListeners(e, { longTap: t }), this.addDestroyFunc(() => e.destroy());
  }
  getRowForEvent(e) {
    let t = e.target;
    for (; t; ) {
      const r = this.gos.getDomData(t, xc.DOM_DATA_KEY_ROW_CTRL);
      if (r)
        return r;
      t = t.parentElement;
    }
    return null;
  }
  handleContextMenuMouseEvent(e, t, r, n) {
    const i = r ? r.getRowNode() : null, o = n ? n.getColumn() : null;
    let a = null;
    if (o) {
      const u = e || t;
      n.dispatchCellContextMenuEvent(u ?? null), a = this.valueService.getValue(o, i);
    }
    const s = this.ctrlsService.getGridBodyCtrl(), l = n ? n.getGui() : s.getGridBodyElement();
    this.menuService.showContextMenu({
      mouseEvent: e,
      touchEvent: t,
      rowNode: i,
      column: o,
      value: a,
      anchorToElement: l
    });
  }
  getControlsForEventTarget(e) {
    return {
      cellCtrl: yT(this.gos, e, bc.DOM_DATA_KEY_CELL_CTRL),
      rowCtrl: yT(this.gos, e, xc.DOM_DATA_KEY_ROW_CTRL)
    };
  }
  processKeyboardEvent(e, t) {
    const { cellCtrl: r, rowCtrl: n } = this.getControlsForEventTarget(t.target);
    t.defaultPrevented || (r ? this.processCellKeyboardEvent(r, e, t) : n && n.isFullWidth() && this.processFullWidthRowKeyboardEvent(n, e, t));
  }
  processCellKeyboardEvent(e, t, r) {
    const n = e.getRowNode(), i = e.getColumn(), o = e.isEditing();
    if (!DT(
      this.gos,
      r,
      n,
      i,
      o
    ) && t === "keydown" && (!o && this.navigationService.handlePageScrollingKey(r) || e.onKeyDown(r), this.doGridOperations(r, e.isEditing()), NK(r) && e.processCharacter(r)), t === "keydown") {
      const s = e.createEvent(r, "cellKeyDown");
      this.eventService.dispatchEvent(s);
    }
  }
  processFullWidthRowKeyboardEvent(e, t, r) {
    const n = e.getRowNode(), i = this.focusService.getFocusedCell(), o = i && i.column;
    if (!DT(this.gos, r, n, o, !1)) {
      const s = r.key;
      if (t === "keydown")
        switch (s) {
          case ae.PAGE_HOME:
          case ae.PAGE_END:
          case ae.PAGE_UP:
          case ae.PAGE_DOWN:
            this.navigationService.handlePageScrollingKey(r, !0);
            break;
          case ae.UP:
          case ae.DOWN:
            e.onKeyboardNavigate(r);
            break;
          case ae.TAB:
            e.onTabKeyDown(r);
            break;
        }
    }
    if (t === "keydown") {
      const s = e.createRowEvent("cellKeyDown", r);
      this.eventService.dispatchEvent(s);
    }
  }
  doGridOperations(e, t) {
    if (!e.ctrlKey && !e.metaKey || t || !this.mouseEventService.isEventFromThisGrid(e))
      return;
    const r = $Ne(e);
    if (r === ae.A)
      return this.onCtrlAndA(e);
    if (r === ae.C)
      return this.onCtrlAndC(e);
    if (r === ae.D)
      return this.onCtrlAndD(e);
    if (r === ae.V)
      return this.onCtrlAndV(e);
    if (r === ae.X)
      return this.onCtrlAndX(e);
    if (r === ae.Y)
      return this.onCtrlAndY();
    if (r === ae.Z)
      return this.onCtrlAndZ(e);
  }
  onCtrlAndA(e) {
    const { pinnedRowModel: t, rowModel: r, rangeService: n } = this;
    if (n && r.isRowsToRender()) {
      const [i, o] = [
        t.isEmpty("top"),
        t.isEmpty("bottom")
      ], a = i ? null : "top";
      let s, l;
      o ? (s = null, l = r.getRowCount() - 1) : (s = "bottom", l = t.getPinnedBottomRowNodes().length - 1);
      const u = this.visibleColsService.getAllCols();
      if (Dn(u))
        return;
      n.setCellRange({
        rowStartIndex: 0,
        rowStartPinned: a,
        rowEndIndex: l,
        rowEndPinned: s,
        columnStart: u[0],
        columnEnd: Jt(u)
      });
    }
    e.preventDefault();
  }
  onCtrlAndC(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection"))
      return;
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || (e.preventDefault(), this.clipboardService.copyToClipboard());
  }
  onCtrlAndX(e) {
    if (!this.clipboardService || this.gos.get("enableCellTextSelection") || this.gos.get("suppressCutToClipboard"))
      return;
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || (e.preventDefault(), this.clipboardService.cutToClipboard(void 0, "ui"));
  }
  onCtrlAndV(e) {
    const { cellCtrl: t, rowCtrl: r } = this.getControlsForEventTarget(e.target);
    t != null && t.isEditing() || r != null && r.isEditing() || this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.pasteFromClipboard();
  }
  onCtrlAndD(e) {
    this.clipboardService && !this.gos.get("suppressClipboardPaste") && this.clipboardService.copyRangeDown(), e.preventDefault();
  }
  onCtrlAndZ(e) {
    !this.gos.get("undoRedoCellEditing") || !this.undoRedoService || (e.preventDefault(), e.shiftKey ? this.undoRedoService.redo("ui") : this.undoRedoService.undo("ui"));
  }
  onCtrlAndY() {
    var e;
    (e = this.undoRedoService) == null || e.redo("ui");
  }
}, LVe = class extends he {
  wireBeans(e) {
    this.pinnedWidthService = e.pinnedWidthService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedEventListeners({ leftPinnedWidthChanged: this.onPinnedLeftWidthChanged.bind(this) });
  }
  onPinnedLeftWidthChanged() {
    const e = this.pinnedWidthService.getPinnedLeftWidth(), t = e > 0;
    jr(this.element, t), pa(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedLeftWidth();
  }
}, OVe = class extends he {
  wireBeans(e) {
    this.pinnedWidthService = e.pinnedWidthService;
  }
  constructor(e) {
    super(), this.element = e;
  }
  postConstruct() {
    this.addManagedEventListeners({
      rightPinnedWidthChanged: this.onPinnedRightWidthChanged.bind(this)
    });
  }
  onPinnedRightWidthChanged() {
    const e = this.pinnedWidthService.getPinnedRightWidth(), t = e > 0;
    jr(this.element, t), pa(this.element, e);
  }
  getWidth() {
    return this.pinnedWidthService.getPinnedRightWidth();
  }
}, Ty = (e) => e.getTopRowCtrls(), Py = (e) => e.getStickyTopRowCtrls(), My = (e) => e.getStickyBottomRowCtrls(), Dy = (e) => e.getBottomRowCtrls(), Ay = (e) => e.getCentreRowCtrls(), NVe = {
  center: {
    type: "center",
    container: "ag-center-cols-container",
    viewport: "ag-center-cols-viewport",
    getRowCtrls: Ay
  },
  left: {
    type: "left",
    container: "ag-pinned-left-cols-container",
    pinnedType: "left",
    getRowCtrls: Ay
  },
  right: {
    type: "right",
    container: "ag-pinned-right-cols-container",
    pinnedType: "right",
    getRowCtrls: Ay
  },
  fullWidth: {
    type: "fullWidth",
    container: "ag-full-width-container",
    fullWidth: !0,
    getRowCtrls: Ay
  },
  topCenter: {
    type: "center",
    container: "ag-floating-top-container",
    viewport: "ag-floating-top-viewport",
    getRowCtrls: Ty
  },
  topLeft: {
    type: "left",
    container: "ag-pinned-left-floating-top",
    pinnedType: "left",
    getRowCtrls: Ty
  },
  topRight: {
    type: "right",
    container: "ag-pinned-right-floating-top",
    pinnedType: "right",
    getRowCtrls: Ty
  },
  topFullWidth: {
    type: "fullWidth",
    container: "ag-floating-top-full-width-container",
    fullWidth: !0,
    getRowCtrls: Ty
  },
  stickyTopCenter: {
    type: "center",
    container: "ag-sticky-top-container",
    viewport: "ag-sticky-top-viewport",
    getRowCtrls: Py
  },
  stickyTopLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-top",
    pinnedType: "left",
    getRowCtrls: Py
  },
  stickyTopRight: {
    type: "right",
    container: "ag-pinned-right-sticky-top",
    pinnedType: "right",
    getRowCtrls: Py
  },
  stickyTopFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-top-full-width-container",
    fullWidth: !0,
    getRowCtrls: Py
  },
  stickyBottomCenter: {
    type: "center",
    container: "ag-sticky-bottom-container",
    viewport: "ag-sticky-bottom-viewport",
    getRowCtrls: My
  },
  stickyBottomLeft: {
    type: "left",
    container: "ag-pinned-left-sticky-bottom",
    pinnedType: "left",
    getRowCtrls: My
  },
  stickyBottomRight: {
    type: "right",
    container: "ag-pinned-right-sticky-bottom",
    pinnedType: "right",
    getRowCtrls: My
  },
  stickyBottomFullWidth: {
    type: "fullWidth",
    container: "ag-sticky-bottom-full-width-container",
    fullWidth: !0,
    getRowCtrls: My
  },
  bottomCenter: {
    type: "center",
    container: "ag-floating-bottom-container",
    viewport: "ag-floating-bottom-viewport",
    getRowCtrls: Dy
  },
  bottomLeft: {
    type: "left",
    container: "ag-pinned-left-floating-bottom",
    pinnedType: "left",
    getRowCtrls: Dy
  },
  bottomRight: {
    type: "right",
    container: "ag-pinned-right-floating-bottom",
    pinnedType: "right",
    getRowCtrls: Dy
  },
  bottomFullWidth: {
    type: "fullWidth",
    container: "ag-floating-bottom-full-width-container",
    fullWidth: !0,
    getRowCtrls: Dy
  }
};
function aY(e) {
  return NVe[e];
}
var kVe = ["topCenter", "topLeft", "topRight"], VVe = ["bottomCenter", "bottomLeft", "bottomRight"], BVe = ["center", "left", "right"], GVe = ["center", "left", "right", "fullWidth"], HVe = ["stickyTopCenter", "stickyBottomCenter", "center", "topCenter", "bottomCenter"], zVe = ["left", "bottomLeft", "topLeft", "stickyTopLeft", "stickyBottomLeft"], $Ve = ["right", "bottomRight", "topRight", "stickyTopRight", "stickyBottomRight"], sY = ["stickyTopCenter", "stickyTopLeft", "stickyTopRight"], lY = ["stickyBottomCenter", "stickyBottomLeft", "stickyBottomRight"], WVe = [
  ...sY,
  "stickyTopFullWidth",
  ...lY,
  "stickyBottomFullWidth"
], jVe = [
  ...kVe,
  ...VVe,
  ...BVe,
  ...sY,
  ...lY
], UVe = class extends he {
  constructor(e) {
    super(), this.visible = !0, this.EMPTY_CTRLS = [], this.name = e, this.options = aY(e);
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.ctrlsService = e.ctrlsService, this.columnViewportService = e.columnViewportService, this.resizeObserverService = e.resizeObserverService, this.rowRenderer = e.rowRenderer;
  }
  postConstruct() {
    this.enableRtl = this.gos.get("enableRtl"), this.forContainers(["center"], () => {
      this.viewportSizeFeature = this.createManagedBean(new oVe(this)), this.addManagedEventListeners({
        stickyTopOffsetChanged: this.onStickyTopOffsetChanged.bind(this)
      });
    });
  }
  onStickyTopOffsetChanged(e) {
    this.comp.setOffsetTop(`${e.offset}px`);
  }
  registerWithCtrlsService() {
    this.options.fullWidth || this.ctrlsService.register(this.name, this);
  }
  forContainers(e, t) {
    e.indexOf(this.name) >= 0 && t();
  }
  getContainerElement() {
    return this.eContainer;
  }
  getViewportSizeFeature() {
    return this.viewportSizeFeature;
  }
  setComp(e, t, r) {
    this.comp = e, this.eContainer = t, this.eViewport = r, this.createManagedBean(new FVe(this.eContainer)), this.addPreventScrollWhileDragging(), this.listenOnDomOrder(), this.stopHScrollOnPinnedRows(), this.forContainers(zVe, () => {
      this.pinnedWidthFeature = this.createManagedBean(new LVe(this.eContainer)), this.addManagedEventListeners({ leftPinnedWidthChanged: () => this.onPinnedWidthChanged() });
    }), this.forContainers($Ve, () => {
      this.pinnedWidthFeature = this.createManagedBean(new OVe(this.eContainer)), this.addManagedEventListeners({ rightPinnedWidthChanged: () => this.onPinnedWidthChanged() });
    }), this.forContainers(
      GVe,
      () => this.createManagedBean(
        new nY(this.eContainer, this.name === "center" ? r : void 0)
      )
    ), this.forContainers(jVe, () => this.createManagedBean(new aVe(this.eContainer))), this.forContainers(
      HVe,
      () => this.createManagedBean(new kA((n) => this.comp.setContainerWidth(`${n}px`)))
    ), this.addListeners(), this.registerWithCtrlsService();
  }
  addListeners() {
    this.addManagedEventListeners({
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this),
      displayedRowsChanged: (e) => this.onDisplayedRowsChanged(e.afterScroll)
    }), this.onDisplayedColumnsChanged(), this.onDisplayedColumnsWidthChanged(), this.onDisplayedRowsChanged();
  }
  listenOnDomOrder() {
    if (WVe.indexOf(this.name) >= 0) {
      this.comp.setDomOrder(!0);
      return;
    }
    const t = () => {
      const r = this.gos.get("ensureDomOrder"), n = this.gos.isDomLayout("print");
      this.comp.setDomOrder(r || n);
    };
    this.addManagedPropertyListener("domLayout", t), t();
  }
  // when editing a pinned row, if the cell is half outside the scrollable area, the browser can
  // scroll the column into view. we do not want this, the pinned sections should never scroll.
  // so we listen to scrolls on these containers and reset the scroll if we find one.
  stopHScrollOnPinnedRows() {
    this.forContainers(["topCenter", "stickyTopCenter", "bottomCenter", "stickyBottomCenter"], () => {
      const e = () => this.eViewport.scrollLeft = 0;
      this.addManagedElementListeners(this.eViewport, { scroll: e });
    });
  }
  onDisplayedColumnsChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  onDisplayedColumnsWidthChanged() {
    this.forContainers(["center"], () => this.onHorizontalViewportChanged());
  }
  // this methods prevents the grid views from being scrolled while the dragService is being used
  // eg. the view should not scroll up and down while dragging rows using the rowDragComp.
  addPreventScrollWhileDragging() {
    const e = (t) => {
      this.dragService.isDragging() && t.cancelable && t.preventDefault();
    };
    this.eContainer.addEventListener("touchmove", e, { passive: !1 }), this.addDestroyFunc(() => this.eContainer.removeEventListener("touchmove", e));
  }
  // this gets called whenever a change in the viewport, so we can inform column controller it has to work
  // out the virtual columns again. gets called from following locations:
  // + ensureColVisible, scroll, init, layoutChanged, displayedColumnsChanged
  onHorizontalViewportChanged(e = !1) {
    const t = this.getCenterWidth(), r = this.getCenterViewportScrollLeft();
    this.columnViewportService.setScrollPosition(t, r, e);
  }
  getCenterWidth() {
    return Yv(this.eViewport);
  }
  getCenterViewportScrollLeft() {
    return jC(this.eViewport, this.enableRtl);
  }
  registerViewportResizeListener(e) {
    const t = this.resizeObserverService.observeResize(this.eViewport, e);
    this.addDestroyFunc(() => t());
  }
  isViewportInTheDOMTree() {
    return vK(this.eViewport);
  }
  getViewportScrollLeft() {
    return jC(this.eViewport, this.enableRtl);
  }
  isHorizontalScrollShowing() {
    return this.gos.get("alwaysShowHorizontalScroll") || POe(this.eViewport);
  }
  getViewportElement() {
    return this.eViewport;
  }
  setContainerTranslateX(e) {
    this.eContainer.style.transform = `translateX(${e}px)`;
  }
  getHScrollPosition() {
    return {
      left: this.eViewport.scrollLeft,
      right: this.eViewport.scrollLeft + this.eViewport.offsetWidth
    };
  }
  setCenterViewportScrollLeft(e) {
    UC(this.eViewport, e, this.enableRtl);
  }
  isContainerVisible() {
    return !(this.options.pinnedType != null) || !!this.pinnedWidthFeature && this.pinnedWidthFeature.getWidth() > 0;
  }
  onPinnedWidthChanged() {
    const e = this.isContainerVisible();
    this.visible != e && (this.visible = e, this.onDisplayedRowsChanged());
  }
  onDisplayedRowsChanged(e = !1) {
    const t = this.options.getRowCtrls(this.rowRenderer);
    if (!this.visible || t.length === 0) {
      this.comp.setRowCtrls({ rowCtrls: this.EMPTY_CTRLS });
      return;
    }
    const r = this.gos.isDomLayout("print"), i = this.gos.get("embedFullWidthRows") || r, o = t.filter((a) => {
      const s = a.isFullWidth();
      return this.options.fullWidth ? !i && s : i || !s;
    });
    this.comp.setRowCtrls({ rowCtrls: o, useFlushSync: e });
  }
};
function Cp(e) {
  return e.map((t) => `<ag-row-container name="${t}"></ag-row-container>`).join("");
}
`${Cp(["topLeft", "topCenter", "topRight", "topFullWidth"])}${Cp(["left", "center", "right", "fullWidth"])}${Cp(["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"])}${Cp(["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"])}${Cp(["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"])}`;
var KVe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "scrollVisibleService";
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.columnAnimationService = e.columnAnimationService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      displayedColumnsWidthChanged: this.onDisplayedColumnsWidthChanged.bind(this)
    });
  }
  onDisplayedColumnsChanged() {
    this.update();
  }
  onDisplayedColumnsWidthChanged() {
    this.update();
  }
  update() {
    this.columnAnimationService.isActive() ? this.columnAnimationService.executeLaterVMTurn(() => {
      this.columnAnimationService.executeLaterVMTurn(() => this.updateImpl());
    }) : this.updateImpl();
  }
  updateImpl() {
    const e = this.ctrlsService.get("center");
    if (!e || this.columnAnimationService.isActive())
      return;
    const t = {
      horizontalScrollShowing: e.isHorizontalScrollShowing(),
      verticalScrollShowing: this.isVerticalScrollShowing()
    };
    this.setScrollsVisible(t);
  }
  setScrollsVisible(e) {
    if (this.horizontalScrollShowing !== e.horizontalScrollShowing || this.verticalScrollShowing !== e.verticalScrollShowing) {
      this.horizontalScrollShowing = e.horizontalScrollShowing, this.verticalScrollShowing = e.verticalScrollShowing;
      const r = {
        type: "scrollVisibilityChanged"
      };
      this.eventService.dispatchEvent(r);
    }
  }
  // used by pagination service - to know page height
  isHorizontalScrollShowing() {
    return this.horizontalScrollShowing;
  }
  // used by header container
  isVerticalScrollShowing() {
    return this.verticalScrollShowing;
  }
}, NG = "__ag_grid_instance", uY = class cY extends he {
  constructor() {
    super(...arguments), this.beanName = "mouseEventService", this.gridInstanceId = cY.gridInstanceSequence.next();
  }
  wireBeans(t) {
    this.ctrlsService = t.ctrlsService;
  }
  // we put the instance id onto the main DOM element. this is used for events, when grids are inside grids,
  // so the grid can work out if the even came from this grid or a grid inside this one. see the ctrl+v logic
  // for where this is used.
  stampTopLevelGridCompWithGridInstance(t) {
    t[NG] = this.gridInstanceId;
  }
  getRenderedCellForEvent(t) {
    return yT(this.gos, t.target, bc.DOM_DATA_KEY_CELL_CTRL);
  }
  // walks the path of the event, and returns true if this grid is the first one that it finds. if doing
  // master / detail grids, and a child grid is found, then it returns false. this stops things like copy/paste
  // getting executed on many grids at the same time.
  isEventFromThisGrid(t) {
    return this.isElementInThisGrid(t.target);
  }
  isElementInThisGrid(t) {
    let r = t;
    for (; r; ) {
      const n = r[NG];
      if (Me(n))
        return n === this.gridInstanceId;
      r = r.parentElement;
    }
    return !1;
  }
  getCellPositionForEvent(t) {
    const r = this.getRenderedCellForEvent(t);
    return r ? r.getCellPosition() : null;
  }
  getNormalisedPosition(t) {
    const r = this.gos.isDomLayout("normal"), n = t;
    let i, o;
    if (n.clientX != null || n.clientY != null ? (i = n.clientX, o = n.clientY) : (i = n.x, o = n.y), r) {
      const a = this.ctrlsService.getGridBodyCtrl(), s = a.getScrollFeature().getVScrollPosition(), l = a.getScrollFeature().getHScrollPosition();
      i += l.left, o += s.top;
    }
    return { x: i, y: o };
  }
};
uY.gridInstanceSequence = new jh();
var YVe = uY, qVe = class extends he {
  constructor() {
    super(), this.beanName = "navigationService", this.onPageDown = _G(this.onPageDown, 100), this.onPageUp = _G(this.onPageUp, 100);
  }
  wireBeans(e) {
    this.mouseEventService = e.mouseEventService, this.pageBoundsService = e.pageBoundsService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.ctrlsService = e.ctrlsService, this.rowRenderer = e.rowRenderer, this.headerNavigationService = e.headerNavigationService, this.rowPositionUtils = e.rowPositionUtils, this.cellNavigationService = e.cellNavigationService, this.pinnedRowModel = e.pinnedRowModel, this.rangeService = e.rangeService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCon = e.gridBodyCtrl;
    });
  }
  handlePageScrollingKey(e, t = !1) {
    const r = e.key, n = e.altKey, i = e.ctrlKey || e.metaKey, o = !!this.rangeService && e.shiftKey, a = this.mouseEventService.getCellPositionForEvent(e);
    let s = !1;
    switch (r) {
      case ae.PAGE_HOME:
      case ae.PAGE_END:
        !i && !n && (this.onHomeOrEndKey(r), s = !0);
        break;
      case ae.LEFT:
      case ae.RIGHT:
      case ae.UP:
      case ae.DOWN:
        if (!a)
          return !1;
        i && !n && !o && (this.onCtrlUpDownLeftRight(r, a), s = !0);
        break;
      case ae.PAGE_DOWN:
      case ae.PAGE_UP:
        !i && !n && (s = this.handlePageUpDown(r, a, t));
        break;
    }
    return s && e.preventDefault(), s;
  }
  handlePageUpDown(e, t, r) {
    return r && (t = this.focusService.getFocusedCell()), t ? (e === ae.PAGE_UP ? this.onPageUp(t) : this.onPageDown(t), !0) : !1;
  }
  navigateTo(e) {
    var a;
    const { scrollIndex: t, scrollType: r, scrollColumn: n, focusIndex: i, focusColumn: o } = e;
    Me(n) && !n.isPinned() && this.gridBodyCon.getScrollFeature().ensureColumnVisible(n), Me(t) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(t, r), e.isAsync || this.gridBodyCon.getScrollFeature().ensureIndexVisible(i), this.focusService.setFocusedCell({
      rowIndex: i,
      column: o,
      rowPinned: null,
      forceBrowserFocus: !0
    }), (a = this.rangeService) == null || a.setRangeToCell({ rowIndex: i, rowPinned: null, column: o });
  }
  // this method is throttled, see the `constructor`
  onPageDown(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), n = this.getViewportHeight(), i = this.pageBoundsService.getPixelOffset(), o = r.top + n, a = this.rowModel.getRowIndexAtPixel(o + i);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, a) : this.navigateToNextPage(e, a);
  }
  // this method is throttled, see the `constructor`
  onPageUp(e) {
    const r = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition(), n = this.pageBoundsService.getPixelOffset(), i = r.top, o = this.rowModel.getRowIndexAtPixel(i + n);
    this.columnModel.isAutoRowHeightActive() ? this.navigateToNextPageWithAutoHeight(e, o, !0) : this.navigateToNextPage(e, o, !0);
  }
  navigateToNextPage(e, t, r = !1) {
    const n = this.getViewportHeight(), i = this.pageBoundsService.getFirstRow(), o = this.pageBoundsService.getLastRow(), a = this.pageBoundsService.getPixelOffset(), s = this.rowModel.getRow(e.rowIndex), l = r ? (
      // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain
      (s == null ? void 0 : s.rowHeight) - n - a
    ) : n - a, u = (s == null ? void 0 : s.rowTop) + l;
    let c = this.rowModel.getRowIndexAtPixel(u + a);
    if (c === e.rowIndex) {
      const h = r ? -1 : 1;
      t = c = e.rowIndex + h;
    }
    let d;
    r ? (d = "bottom", c < i && (c = i), t < i && (t = i)) : (d = "top", c > o && (c = o), t > o && (t = o)), this.isRowTallerThanView(c) && (t = c, d = "top"), this.navigateTo({
      scrollIndex: t,
      scrollType: d,
      scrollColumn: null,
      focusIndex: c,
      focusColumn: e.column
    });
  }
  navigateToNextPageWithAutoHeight(e, t, r = !1) {
    this.navigateTo({
      scrollIndex: t,
      scrollType: r ? "bottom" : "top",
      scrollColumn: null,
      focusIndex: t,
      focusColumn: e.column
    }), setTimeout(() => {
      const n = this.getNextFocusIndexForAutoHeight(e, r);
      this.navigateTo({
        scrollIndex: t,
        scrollType: r ? "bottom" : "top",
        scrollColumn: null,
        focusIndex: n,
        focusColumn: e.column,
        isAsync: !0
      });
    }, 50);
  }
  getNextFocusIndexForAutoHeight(e, t = !1) {
    const r = t ? -1 : 1, n = this.getViewportHeight(), i = this.pageBoundsService.getLastRow();
    let o = 0, a = e.rowIndex;
    for (; a >= 0 && a <= i; ) {
      const s = this.rowModel.getRow(a);
      if (s) {
        const l = s.rowHeight ?? 0;
        if (o + l > n)
          break;
        o += l;
      }
      a += r;
    }
    return Math.max(0, Math.min(a, i));
  }
  getViewportHeight() {
    const { gridBodyCtrl: e, center: t } = this.ctrlsService.getParams(), r = e.getScrollFeature().getVScrollPosition(), n = this.gos.getScrollbarWidth();
    let i = r.bottom - r.top;
    return t.isHorizontalScrollShowing() && (i -= n), i;
  }
  isRowTallerThanView(e) {
    const t = this.rowModel.getRow(e);
    if (!t)
      return !1;
    const r = t.rowHeight;
    return typeof r != "number" ? !1 : r > this.getViewportHeight();
  }
  onCtrlUpDownLeftRight(e, t) {
    const r = this.cellNavigationService.getNextCellToFocus(e, t, !0), { rowIndex: n } = r, i = r.column;
    this.navigateTo({
      scrollIndex: n,
      scrollType: null,
      scrollColumn: i,
      focusIndex: n,
      focusColumn: i
    });
  }
  // home brings focus to top left cell, end brings focus to bottom right, grid scrolled to bring
  // same cell into view (which means either scroll all the way up, or all the way down).
  onHomeOrEndKey(e) {
    const t = e === ae.PAGE_HOME, r = this.visibleColsService.getAllCols(), n = t ? r[0] : Jt(r), i = t ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow();
    this.navigateTo({
      scrollIndex: i,
      scrollType: null,
      scrollColumn: n,
      focusIndex: i,
      focusColumn: n
    });
  }
  // result of keyboard event
  onTabKeyDown(e, t) {
    const r = t.shiftKey, n = this.tabToNextCellCommon(e, r, t);
    if (n !== !1) {
      n && t.preventDefault();
      return;
    }
    if (r) {
      const { rowIndex: i, rowPinned: o } = e.getRowPosition();
      (o ? i === 0 : i === this.pageBoundsService.getFirstRow()) && (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus") ? this.focusService.focusNextGridCoreContainer(!0, !0) : (t.preventDefault(), this.focusService.focusPreviousFromFirstCell(t)));
    } else
      e instanceof bc && e.focusCell(!0), this.focusService.focusNextGridCoreContainer(r) && t.preventDefault();
  }
  // comes from API
  tabToNextCell(e, t) {
    const r = this.focusService.getFocusedCell();
    if (!r)
      return !1;
    let n = this.getCellByPosition(r);
    return !n && (n = this.rowRenderer.getRowByPosition(r), !n || !n.isFullWidth()) ? !1 : !!this.tabToNextCellCommon(n, e, t);
  }
  tabToNextCellCommon(e, t, r) {
    let n = e.isEditing();
    if (!n && e instanceof bc) {
      const a = e.getRowCtrl();
      a && (n = a.isEditing());
    }
    let i;
    return n ? this.gos.get("editType") === "fullRow" ? i = this.moveToNextEditingRow(e, t, r) : i = this.moveToNextEditingCell(e, t, r) : i = this.moveToNextCellNotEditing(e, t), i === null ? i : i || !!this.focusService.getFocusedHeader();
  }
  // returns null if no navigation should be performed
  moveToNextEditingCell(e, t, r = null) {
    const n = e.getCellPosition();
    e.getGui().focus(), e.stopEditing();
    const i = this.findNextCellToFocusOn(n, t, !0);
    return i === !1 ? null : i == null ? !1 : (i.startEditing(null, !0, r), i.focusCell(!1), !0);
  }
  // returns null if no navigation should be performed
  moveToNextEditingRow(e, t, r = null) {
    const n = e.getCellPosition(), i = this.findNextCellToFocusOn(n, t, !0);
    if (i === !1)
      return null;
    if (i == null)
      return !1;
    const o = i.getCellPosition(), a = this.isCellEditable(n), s = this.isCellEditable(o), l = o && n.rowIndex === o.rowIndex && n.rowPinned === o.rowPinned;
    return a && e.setFocusOutOnEditor(), l || (e.getRowCtrl().stopEditing(), i.getRowCtrl().startRowEditing(void 0, void 0, r)), s ? (i.setFocusInOnEditor(), i.focusCell()) : i.focusCell(!0), !0;
  }
  // returns null if no navigation should be performed
  moveToNextCellNotEditing(e, t) {
    const r = this.visibleColsService.getAllCols();
    let n;
    e instanceof xc ? n = {
      ...e.getRowPosition(),
      column: t ? r[0] : Jt(r)
    } : n = e.getCellPosition();
    const i = this.findNextCellToFocusOn(n, t, !1);
    if (i === !1)
      return null;
    if (i instanceof bc)
      i.focusCell(!0);
    else if (i)
      return this.tryToFocusFullWidthRow(i.getRowPosition(), t);
    return Me(i);
  }
  /**
   * called by the cell, when tab is pressed while editing.
   * @return: RenderedCell when navigation successful, false if navigation should not be performed, otherwise null
   */
  findNextCellToFocusOn(e, t, r) {
    var i;
    let n = e;
    for (; ; ) {
      e !== n && (e = n), t || (n = this.getLastCellOfColSpan(n)), n = this.cellNavigationService.getNextTabbedCell(n, t);
      const o = this.gos.getCallback("tabToNextCell");
      if (Me(o)) {
        const u = o({
          backwards: t,
          editing: r,
          previousCellPosition: e,
          nextCellPosition: n || null
        });
        if (u === !0 || u === null)
          u === null && Se(
            "Returning `null` from tabToNextCell is deprecated. Return `true` to stay on the current cell, or `false` to let the browser handle the tab behaviour."
          ), n = e;
        else {
          if (u === !1)
            return !1;
          n = {
            rowIndex: u.rowIndex,
            column: u.column,
            rowPinned: u.rowPinned
          };
        }
      }
      if (!n)
        return null;
      if (n.rowIndex < 0) {
        const l = this.headerNavigationService.getHeaderRowCount();
        return this.focusService.focusHeaderPosition({
          headerPosition: {
            headerRowIndex: l + n.rowIndex,
            column: n.column
          },
          fromCell: !0
        }), null;
      }
      const a = this.gos.get("editType") === "fullRow";
      if (r && !a && !this.isCellEditable(n))
        continue;
      this.ensureCellVisible(n);
      const s = this.getCellByPosition(n);
      if (!s) {
        const l = this.rowRenderer.getRowByPosition(n);
        if (!l || !l.isFullWidth() || r)
          continue;
        return l;
      }
      if (!s.isSuppressNavigable())
        return (i = this.rangeService) == null || i.setRangeToCell(n), s;
    }
  }
  isCellEditable(e) {
    const t = this.lookupRowNodeForCell(e);
    return t ? e.column.isCellEditable(t) : !1;
  }
  getCellByPosition(e) {
    const t = this.rowRenderer.getRowByPosition(e);
    return t ? t.getCellCtrl(e.column) : null;
  }
  lookupRowNodeForCell(e) {
    return e.rowPinned === "top" ? this.pinnedRowModel.getPinnedTopRow(e.rowIndex) : e.rowPinned === "bottom" ? this.pinnedRowModel.getPinnedBottomRow(e.rowIndex) : this.rowModel.getRow(e.rowIndex);
  }
  // we use index for rows, but column object for columns, as the next column (by index) might not
  // be visible (header grouping) so it's not reliable, so using the column object instead.
  navigateToNextCell(e, t, r, n) {
    let i = r, o = !1;
    for (; i && (i === r || !this.isValidNavigateCell(i)); )
      this.gos.get("enableRtl") ? t === ae.LEFT && (i = this.getLastCellOfColSpan(i)) : t === ae.RIGHT && (i = this.getLastCellOfColSpan(i)), i = this.cellNavigationService.getNextCellToFocus(t, i), o = Zt(i);
    if (o && e && e.key === ae.UP && (i = {
      rowIndex: -1,
      rowPinned: null,
      column: r.column
    }), n) {
      const s = this.gos.getCallback("navigateToNextCell");
      if (Me(s)) {
        const u = s({
          key: t,
          previousCellPosition: r,
          nextCellPosition: i || null,
          event: e
        });
        Me(u) ? i = {
          rowPinned: u.rowPinned,
          rowIndex: u.rowIndex,
          column: u.column
        } : i = null;
      }
    }
    if (!i)
      return;
    if (i.rowIndex < 0) {
      const s = this.headerNavigationService.getHeaderRowCount();
      this.focusService.focusHeaderPosition({
        headerPosition: { headerRowIndex: s + i.rowIndex, column: r.column },
        event: e || void 0,
        fromCell: !0
      });
      return;
    }
    const a = this.getNormalisedPosition(i);
    a ? this.focusPosition(a) : this.tryToFocusFullWidthRow(i);
  }
  getNormalisedPosition(e) {
    this.ensureCellVisible(e);
    const t = this.getCellByPosition(e);
    return t ? (e = t.getCellPosition(), this.ensureCellVisible(e), e) : null;
  }
  tryToFocusFullWidthRow(e, t = !1) {
    const r = this.visibleColsService.getAllCols(), n = this.rowRenderer.getRowByPosition(e);
    if (!n || !n.isFullWidth())
      return !1;
    const i = this.focusService.getFocusedCell(), o = {
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: e.column || (t ? Jt(r) : r[0])
    };
    this.focusPosition(o);
    const a = i != null ? this.rowPositionUtils.before(o, i) : !1, s = {
      type: "fullWidthRowFocused",
      rowIndex: o.rowIndex,
      rowPinned: o.rowPinned,
      column: o.column,
      isFullWidthCell: !0,
      fromBelow: a
    };
    return this.eventService.dispatchEvent(s), !0;
  }
  focusPosition(e) {
    var t;
    this.focusService.setFocusedCell({
      rowIndex: e.rowIndex,
      column: e.column,
      rowPinned: e.rowPinned,
      forceBrowserFocus: !0
    }), (t = this.rangeService) == null || t.setRangeToCell(e);
  }
  isValidNavigateCell(e) {
    return !!this.rowPositionUtils.getRowNode(e);
  }
  getLastCellOfColSpan(e) {
    const t = this.getCellByPosition(e);
    if (!t)
      return e;
    const r = t.getColSpanningList();
    return r.length === 1 ? e : {
      rowIndex: e.rowIndex,
      column: Jt(r),
      rowPinned: e.rowPinned
    };
  }
  ensureCellVisible(e) {
    const t = this.gos.isGroupRowsSticky(), r = this.rowModel.getRow(e.rowIndex);
    !(t && (r == null ? void 0 : r.sticky)) && Zt(e.rowPinned) && this.gridBodyCon.getScrollFeature().ensureIndexVisible(e.rowIndex), e.column.isPinned() || this.gridBodyCon.getScrollFeature().ensureColumnVisible(e.column);
  }
}, ZVe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "horizontalResizeService";
  }
  wireBeans(e) {
    this.dragService = e.dragService, this.ctrlsService = e.ctrlsService;
  }
  addResizeBar(e) {
    const t = {
      dragStartPixels: e.dragStartPixels || 0,
      eElement: e.eResizeBar,
      onDragStart: this.onDragStart.bind(this, e),
      onDragStop: this.onDragStop.bind(this, e),
      onDragging: this.onDragging.bind(this, e),
      includeTouch: !0,
      stopPropagationForTouch: !0
    };
    return this.dragService.addDragSource(t), () => this.dragService.removeDragSource(t);
  }
  onDragStart(e, t) {
    this.dragStartX = t.clientX, this.setResizeIcons();
    const r = t instanceof MouseEvent && t.shiftKey === !0;
    e.onResizeStart(r);
  }
  setResizeIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(!0), e.disableUserSelect(!0);
  }
  onDragStop(e, t) {
    e.onResizeEnd(this.resizeAmount), this.resetIcons();
  }
  resetIcons() {
    const e = this.ctrlsService.get("gridCtrl");
    e.setResizeCursor(!1), e.disableUserSelect(!1);
  }
  onDragging(e, t) {
    this.resizeAmount = t.clientX - this.dragStartX, e.onResizing(this.resizeAmount);
  }
}, XVe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "filterMenuFactory";
  }
  wireBeans(e) {
    this.popupService = e.popupService, this.focusService = e.focusService, this.ctrlsService = e.ctrlsService, this.menuService = e.menuService;
  }
  hideActiveMenu() {
    this.hidePopup && this.hidePopup();
  }
  showMenuAfterMouseEvent(e, t, r) {
    this.showPopup(
      e,
      (n) => {
        this.popupService.positionPopupUnderMouseEvent({
          column: e,
          type: r,
          mouseEvent: t,
          ePopup: n
        });
      },
      r,
      t.target,
      this.menuService.isLegacyMenuEnabled()
    );
  }
  showMenuAfterButtonClick(e, t, r) {
    let n = -1, i = "left";
    const o = this.menuService.isLegacyMenuEnabled();
    !o && this.gos.get("enableRtl") && (n = 1, i = "right");
    const a = o ? void 0 : 4 * n, s = o ? void 0 : 4;
    this.showPopup(
      e,
      (l) => {
        this.popupService.positionPopupByComponent({
          type: r,
          eventSource: t,
          ePopup: l,
          nudgeX: a,
          nudgeY: s,
          alignSide: i,
          keepWithinBounds: !0,
          position: "under",
          column: e
        });
      },
      r,
      t,
      o
    );
  }
  showPopup(e, t, r, n, i) {
    const o = e ? this.createBean(new PNe(e, "COLUMN_MENU")) : void 0;
    if (this.activeMenu = o, !(o != null && o.hasFilter()) || !e)
      throw new Error("AG Grid - unable to show popup filter, filter instantiation failed");
    const a = document.createElement("div");
    Sa(a, "presentation"), a.classList.add("ag-menu"), i || a.classList.add("ag-filter-menu"), [this.tabListener] = this.addManagedElementListeners(a, {
      keydown: (p) => this.trapFocusWithin(p, a)
    }), a.appendChild(o == null ? void 0 : o.getGui());
    let s;
    const l = () => o == null ? void 0 : o.afterGuiDetached(), u = this.menuService.isColumnMenuAnchoringEnabled() ? n ?? this.ctrlsService.getGridBodyCtrl().getGui() : void 0, c = (p) => {
      e.setMenuVisible(!1, "contextMenu");
      const g = p instanceof KeyboardEvent;
      if (this.tabListener && (this.tabListener = this.tabListener()), g && n && ts(n)) {
        const v = this.focusService.findTabbableParent(n);
        v && v.focus();
      }
      l(), this.destroyBean(this.activeMenu), this.dispatchVisibleChangedEvent(!1, r, e);
    }, d = this.localeService.getLocaleTextFunc(), h = i && r !== "columnFilter" ? d("ariaLabelColumnMenu", "Column Menu") : d("ariaLabelColumnFilter", "Column Filter"), f = this.popupService.addPopup({
      modal: !0,
      eChild: a,
      closeOnEsc: !0,
      closedCallback: c,
      positionCallback: () => t(a),
      anchorToElement: u,
      ariaLabel: h
    });
    f && (this.hidePopup = s = f.hideFunc), o.afterInit().then(() => {
      t(a), o.afterGuiAttached({ container: r, hidePopup: s });
    }), e.setMenuVisible(!0, "contextMenu"), this.dispatchVisibleChangedEvent(!0, r, e);
  }
  trapFocusWithin(e, t) {
    e.key !== ae.TAB || e.defaultPrevented || this.focusService.findNextFocusableElement(t, !1, e.shiftKey) || (e.preventDefault(), this.focusService.focusInto(t, e.shiftKey));
  }
  dispatchVisibleChangedEvent(e, t, r) {
    const n = {
      type: "columnMenuVisibleChanged",
      visible: e,
      switchingTab: !1,
      key: t,
      column: r ?? null
    };
    this.eventService.dispatchEvent(n);
  }
  isMenuEnabled(e) {
    return e.isFilterAllowed() && (e.getColDef().menuTabs ?? ["filterMenuTab"]).includes("filterMenuTab");
  }
  showMenuAfterContextMenuEvent() {
  }
  destroy() {
    this.destroyBean(this.activeMenu), super.destroy();
  }
}, QVe = 50, JVe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "resizeObserverService", this.polyfillFunctions = [];
  }
  observeResize(e, t) {
    const r = this.gos.getWindow(), n = () => {
      const s = new r.ResizeObserver(t);
      return s.observe(e), () => s.disconnect();
    }, i = () => {
      let s = (e == null ? void 0 : e.clientWidth) ?? 0, l = (e == null ? void 0 : e.clientHeight) ?? 0, u = !0;
      const c = () => {
        if (u) {
          const d = (e == null ? void 0 : e.clientWidth) ?? 0, h = (e == null ? void 0 : e.clientHeight) ?? 0;
          (d !== s || h !== l) && (s = d, l = h, t()), this.doNextPolyfillTurn(c);
        }
      };
      return c(), () => u = !1;
    }, o = this.gos.get("suppressBrowserResizeObserver");
    return !!r.ResizeObserver && !o ? n() : this.getFrameworkOverrides().wrapIncoming(() => i(), "resize-observer");
  }
  doNextPolyfillTurn(e) {
    this.polyfillFunctions.push(e), this.schedulePolyfill();
  }
  schedulePolyfill() {
    if (this.polyfillScheduled)
      return;
    const e = () => {
      const t = this.polyfillFunctions;
      this.polyfillScheduled = !1, this.polyfillFunctions = [], t.forEach((r) => r());
    };
    this.polyfillScheduled = !0, window.setTimeout(e, QVe);
  }
}, eBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "animationFrameService", this.createTasksP1 = { list: [], sorted: !1 }, this.createTasksP2 = { list: [], sorted: !1 }, this.destroyTasks = [], this.ticking = !1, this.scrollGoingDown = !0, this.lastPage = 0, this.lastScrollTop = 0, this.taskCount = 0, this.cancelledTasks = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.paginationService = e.paginationService;
  }
  setScrollTop(e) {
    var r;
    const t = this.gos.get("pagination");
    if (this.scrollGoingDown = e >= this.lastScrollTop, t && e === 0) {
      const n = ((r = this.paginationService) == null ? void 0 : r.getCurrentPage()) ?? 0;
      n !== this.lastPage && (this.lastPage = n, this.scrollGoingDown = !0);
    }
    this.lastScrollTop = e;
  }
  postConstruct() {
    this.useAnimationFrame = !this.gos.get("suppressAnimationFrame");
  }
  isOn() {
    return this.useAnimationFrame;
  }
  // this method is for our AG Grid sanity only - if animation frames are turned off,
  // then no place in the code should be looking to add any work to be done in animation
  // frames. this stops bugs - where some code is asking for a frame to be executed
  // when it should not.
  verifyAnimationFrameOn(e) {
    this.useAnimationFrame === !1 && Se(`AnimationFrameService.${e} called but animation frames are off`);
  }
  createTask(e, t, r) {
    this.verifyAnimationFrameOn(r);
    const n = { task: e, index: t, createOrder: ++this.taskCount };
    this.addTaskToList(this[r], n), this.schedule();
  }
  cancelTask(e) {
    this.cancelledTasks.add(e);
  }
  addTaskToList(e, t) {
    e.list.push(t), e.sorted = !1;
  }
  sortTaskList(e) {
    if (e.sorted)
      return;
    const t = this.scrollGoingDown ? 1 : -1;
    e.list.sort(
      (r, n) => r.index !== n.index ? t * (n.index - r.index) : n.createOrder - r.createOrder
    ), e.sorted = !0;
  }
  addDestroyTask(e) {
    this.verifyAnimationFrameOn("createTasksP3"), this.destroyTasks.push(e), this.schedule();
  }
  executeFrame(e) {
    this.verifyAnimationFrameOn("executeFrame");
    const t = this.createTasksP1, r = t.list, n = this.createTasksP2, i = n.list, o = this.destroyTasks, a = (/* @__PURE__ */ new Date()).getTime();
    let s = (/* @__PURE__ */ new Date()).getTime() - a;
    const l = e <= 0, u = this.ctrlsService.getGridBodyCtrl();
    for (; l || s < e; ) {
      if (!u.getScrollFeature().scrollGridIfNeeded()) {
        let d;
        if (r.length)
          this.sortTaskList(t), d = r.pop().task;
        else if (i.length)
          this.sortTaskList(n), d = i.pop().task;
        else if (o.length)
          d = o.pop();
        else {
          this.cancelledTasks.clear();
          break;
        }
        this.cancelledTasks.has(d) || d();
      }
      s = (/* @__PURE__ */ new Date()).getTime() - a;
    }
    r.length || i.length || o.length ? this.requestFrame() : this.stopTicking();
  }
  stopTicking() {
    this.ticking = !1;
  }
  flushAllFrames() {
    this.useAnimationFrame && this.executeFrame(-1);
  }
  schedule() {
    this.useAnimationFrame && (this.ticking || (this.ticking = !0, this.requestFrame()));
  }
  requestFrame() {
    const e = this.executeFrame.bind(this, 60);
    this.requestAnimationFrame(e);
  }
  requestAnimationFrame(e) {
    const t = this.gos.getWindow();
    t.requestAnimationFrame ? t.requestAnimationFrame(e) : t.webkitRequestAnimationFrame ? t.webkitRequestAnimationFrame(e) : t.setTimeout(e, 0);
  }
  isQueueEmpty() {
    return !this.ticking;
  }
  // a debounce utility used for parts of the app involved with rendering.
  // the advantage over normal debounce is the client can call flushAllFrames()
  // to make sure all rendering is complete. we don't wait any milliseconds,
  // as this is intended to batch calls in one VM turn.
  debounce(e) {
    let t = !1;
    return () => {
      if (!this.isOn()) {
        window.setTimeout(e, 0);
        return;
      }
      t || (t = !0, this.addDestroyTask(() => {
        t = !1, e();
      }));
    };
  }
}, tBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "expansionService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.isClientSideRowModel = this.rowModel.getType() === "clientSide";
  }
  expandRows(e) {
    if (!this.isClientSideRowModel)
      return;
    const t = new Set(e);
    this.rowModel.forEachNode((r) => {
      r.id && t.has(r.id) && (r.expanded = !0);
    }), this.onGroupExpandedOrCollapsed();
  }
  getExpandedRows() {
    const e = [];
    return this.rowModel.forEachNode(({ expanded: t, id: r }) => {
      t && r && e.push(r);
    }), e;
  }
  expandAll(e) {
    this.isClientSideRowModel && this.rowModel.expandOrCollapseAll(e);
  }
  setRowNodeExpanded(e, t, r, n) {
    e && (r && e.parent && e.parent.level !== -1 && this.setRowNodeExpanded(e.parent, t, r, n), e.setExpanded(t, void 0, n));
  }
  onGroupExpandedOrCollapsed() {
    this.isClientSideRowModel && this.rowModel.refreshModel({
      step: "map"
      /* MAP */
    });
  }
}, rBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "menuService";
  }
  wireBeans(e) {
    this.filterMenuFactory = e.filterMenuFactory, this.ctrlsService = e.ctrlsService, this.animationFrameService = e.animationFrameService, this.filterManager = e.filterManager, this.rowRenderer = e.rowRenderer, this.columnChooserFactory = e.columnChooserFactory, this.contextMenuFactory = e.contextMenuFactory, this.enterpriseMenuFactory = e.enterpriseMenuFactory;
  }
  postConstruct() {
    this.activeMenuFactory = this.enterpriseMenuFactory ?? this.filterMenuFactory;
  }
  showColumnMenu(e) {
    this.showColumnMenuCommon(this.activeMenuFactory, e, "columnMenu");
  }
  showFilterMenu(e) {
    const t = this.enterpriseMenuFactory && this.isLegacyMenuEnabled() ? this.enterpriseMenuFactory : this.filterMenuFactory;
    this.showColumnMenuCommon(t, e, e.containerType, !0);
  }
  showHeaderContextMenu(e, t, r) {
    this.activeMenuFactory.showMenuAfterContextMenuEvent(e, t, r);
  }
  getContextMenuPosition(e, t) {
    const r = this.getRowCtrl(e), n = this.getCellGui(r, t);
    if (!n)
      return r ? { x: 0, y: r.getRowYPosition() } : { x: 0, y: 0 };
    const i = n.getBoundingClientRect();
    return {
      x: i.x + i.width / 2,
      y: i.y + i.height / 2
    };
  }
  showContextMenu(e) {
    var o;
    const { rowNode: t } = e, r = e.column;
    let { anchorToElement: n, value: i } = e;
    t && r && i == null && (i = t.getValueFromValueService(r)), n == null && (n = this.getContextMenuAnchorElement(t, r)), (o = this.contextMenuFactory) == null || o.onContextMenu(
      e.mouseEvent ?? null,
      e.touchEvent ?? null,
      t ?? null,
      r ?? null,
      i,
      n
    );
  }
  showColumnChooser(e) {
    var t;
    (t = this.columnChooserFactory) == null || t.showColumnChooser(e);
  }
  hidePopupMenu() {
    var e;
    (e = this.contextMenuFactory) == null || e.hideActiveMenu(), this.activeMenuFactory.hideActiveMenu();
  }
  hideColumnChooser() {
    var e;
    (e = this.columnChooserFactory) == null || e.hideActiveColumnChooser();
  }
  isColumnMenuInHeaderEnabled(e) {
    const { suppressMenu: t, suppressHeaderMenuButton: r } = e.getColDef();
    return !(r ?? t) && this.activeMenuFactory.isMenuEnabled(e) && (this.isLegacyMenuEnabled() || !!this.enterpriseMenuFactory);
  }
  isFilterMenuInHeaderEnabled(e) {
    var t;
    return !e.getColDef().suppressHeaderFilterButton && !!((t = this.filterManager) != null && t.isFilterAllowed(e));
  }
  isHeaderContextMenuEnabled(e) {
    return !(e != null && e.getColDef().suppressHeaderContextMenu) && this.getColumnMenuType() === "new";
  }
  isHeaderMenuButtonAlwaysShowEnabled() {
    return this.isSuppressMenuHide();
  }
  isHeaderMenuButtonEnabled() {
    const e = !this.isSuppressMenuHide();
    return !(su() && e);
  }
  isHeaderFilterButtonEnabled(e) {
    return this.isFilterMenuInHeaderEnabled(e) && !this.isLegacyMenuEnabled() && !this.isFloatingFilterButtonDisplayed(e);
  }
  isFilterMenuItemEnabled(e) {
    var t;
    return !!((t = this.filterManager) != null && t.isFilterAllowed(e)) && !this.isLegacyMenuEnabled() && !this.isFilterMenuInHeaderEnabled(e) && !this.isFloatingFilterButtonDisplayed(e);
  }
  isColumnMenuAnchoringEnabled() {
    return !this.isLegacyMenuEnabled();
  }
  areAdditionalColumnMenuItemsEnabled() {
    return this.getColumnMenuType() === "new";
  }
  isLegacyMenuEnabled() {
    return this.getColumnMenuType() === "legacy";
  }
  isFloatingFilterButtonEnabled(e) {
    var n;
    const t = e.getColDef(), r = (n = t.floatingFilterComponentParams) == null ? void 0 : n.suppressFilterButton;
    return r != null && Se(
      "As of v31.1, 'colDef.floatingFilterComponentParams.suppressFilterButton' is deprecated. Use 'colDef.suppressFloatingFilterButton' instead."
    ), t.suppressFloatingFilterButton == null ? !r : !t.suppressFloatingFilterButton;
  }
  getColumnMenuType() {
    return this.gos.get("columnMenu");
  }
  isFloatingFilterButtonDisplayed(e) {
    return !!e.getColDef().floatingFilter && this.isFloatingFilterButtonEnabled(e);
  }
  isSuppressMenuHide() {
    const e = this.gos.get("suppressMenuHide");
    return this.isLegacyMenuEnabled() ? this.gos.exists("suppressMenuHide") ? e : !1 : e;
  }
  showColumnMenuCommon(e, t, r, n) {
    const { positionBy: i } = t, o = t.column;
    if (i === "button") {
      const { buttonElement: a } = t;
      e.showMenuAfterButtonClick(o, a, r, n);
    } else if (i === "mouse") {
      const { mouseEvent: a } = t;
      e.showMenuAfterMouseEvent(o, a, r, n);
    } else o && (this.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(o, "auto"), this.animationFrameService.requestAnimationFrame(() => {
      const a = this.ctrlsService.getHeaderRowContainerCtrl(o.getPinned()).getHeaderCtrlForColumn(o);
      e.showMenuAfterButtonClick(
        o,
        a.getAnchorElementForMenu(n),
        r,
        !0
      );
    }));
  }
  getRowCtrl(e) {
    const { rowIndex: t, rowPinned: r } = e || {};
    if (t != null)
      return this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: r }) || void 0;
  }
  getCellGui(e, t) {
    if (!e || !t)
      return;
    const r = e.getCellCtrl(t);
    return (r == null ? void 0 : r.getGui()) || void 0;
  }
  getContextMenuAnchorElement(e, t) {
    const r = this.ctrlsService.getGridBodyCtrl().getGridBodyElement(), n = this.getRowCtrl(e);
    if (!n)
      return r;
    const i = this.getCellGui(n, t);
    return i || (n.isFullWidth() ? n.getFullWidthElement() : r);
  }
}, nBe = class extends lc {
  constructor(e) {
    super(e, "ag-text-area", null, "textarea");
  }
  setValue(e, t) {
    const r = super.setValue(e, t);
    return this.eInput.value = e, r;
  }
  setCols(e) {
    return this.eInput.cols = e, this;
  }
  setRows(e) {
    return this.eInput.rows = e, this;
  }
}, iBe = {
  selector: "AG-INPUT-TEXT-AREA",
  component: nBe
}, oBe = class extends xf {
  constructor() {
    super(
      /* html */
      `<div class="ag-large-text">
        <ag-input-text-area data-ref="eTextArea" class="ag-large-text-input"></ag-input-text-area>
        </div>`,
      [iBe]
    ), this.eTextArea = ft;
  }
  init(e) {
    this.params = e, this.focusAfterAttached = e.cellStartedEdit, this.eTextArea.setMaxLength(e.maxLength || 200).setCols(e.cols || 60).setRows(e.rows || 10), Me(e.value, !0) && this.eTextArea.setValue(e.value.toString(), !0), this.addGuiEventListener("keydown", this.onKeyDown.bind(this)), this.activateTabIndex();
  }
  onKeyDown(e) {
    const t = e.key;
    (t === ae.LEFT || t === ae.UP || t === ae.RIGHT || t === ae.DOWN || e.shiftKey && t === ae.ENTER) && e.stopPropagation();
  }
  afterGuiAttached() {
    const e = this.localeService.getLocaleTextFunc();
    this.eTextArea.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), this.focusAfterAttached && this.eTextArea.getFocusableElement().focus();
  }
  getValue() {
    const e = this.eTextArea.getValue();
    return !Me(e) && !Me(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
}, aBe = class extends xf {
  constructor(e) {
    super(
      /* html */
      '<div class="ag-popup-editor" tabindex="-1"/>'
    ), this.params = e;
  }
  postConstruct() {
    this.gos.setDomData(this.getGui(), "popupEditorWrapper", !0), this.addKeyDownListener();
  }
  addKeyDownListener() {
    const e = this.getGui(), t = this.params, r = (n) => {
      DT(this.gos, n, t.node, t.column, !0) || t.onKeyDown(n);
    };
    this.addManagedElementListeners(e, { keydown: r });
  }
}, sBe = class extends xf {
  constructor() {
    super(
      /* html */
      `<div class="ag-cell-edit-wrapper">
                <ag-select class="ag-cell-editor" data-ref="eSelect"></ag-select>
            </div>`,
      [ONe]
    ), this.eSelect = ft, this.startedByEnter = !1;
  }
  wireBeans(e) {
    this.valueService = e.valueService;
  }
  init(e) {
    this.focusAfterAttached = e.cellStartedEdit;
    const { eSelect: t, valueService: r, gos: n } = this, { values: i, value: o, eventKey: a } = e;
    if (Zt(i)) {
      Se("no values found for select cellEditor");
      return;
    }
    this.startedByEnter = a != null ? a === ae.ENTER : !1;
    let s = !1;
    i.forEach((d) => {
      const h = { value: d }, f = r.formatValue(e.column, null, d), p = f != null;
      h.text = p ? f : d, t.addOption(h), s = s || o === d;
    }), s ? t.setValue(e.value, !0) : e.values.length && t.setValue(e.values[0], !0);
    const { valueListGap: l, valueListMaxWidth: u, valueListMaxHeight: c } = e;
    l != null && t.setPickerGap(l), c != null && t.setPickerMaxHeight(c), u != null && t.setPickerMaxWidth(u), n.get("editType") !== "fullRow" && this.addManagedListeners(this.eSelect, { selectedItem: () => e.stopEditing() });
  }
  afterGuiAttached() {
    this.focusAfterAttached && this.eSelect.getFocusableElement().focus(), this.startedByEnter && setTimeout(() => {
      this.isAlive() && this.eSelect.showPicker();
    });
  }
  focusIn() {
    this.eSelect.getFocusableElement().focus();
  }
  getValue() {
    return this.eSelect.getValue();
  }
  isPopup() {
    return !1;
  }
}, yw = class extends xf {
  constructor(e) {
    super(
      /* html */
      `
            <div class="ag-cell-edit-wrapper">
                ${e.getTemplate()}
            </div>`,
      e.getAgComponents()
    ), this.cellEditorInput = e, this.eInput = ft;
  }
  init(e) {
    this.params = e;
    const t = this.eInput;
    this.cellEditorInput.init(t, e);
    let r;
    if (e.cellStartedEdit) {
      this.focusAfterAttached = !0;
      const n = e.eventKey;
      n === ae.BACKSPACE || e.eventKey === ae.DELETE ? r = "" : n && n.length === 1 ? r = n : (r = this.cellEditorInput.getStartValue(), n !== ae.F2 && (this.highlightAllOnFocus = !0));
    } else
      this.focusAfterAttached = !1, r = this.cellEditorInput.getStartValue();
    r != null && t.setStartValue(r), this.addManagedElementListeners(t.getGui(), {
      keydown: (n) => {
        const { key: i } = n;
        (i === ae.PAGE_UP || i === ae.PAGE_DOWN) && n.preventDefault();
      }
    });
  }
  afterGuiAttached() {
    var n, i;
    const e = this.localeService.getLocaleTextFunc(), t = this.eInput;
    if (t.setInputAriaLabel(e("ariaInputEditor", "Input Editor")), !this.focusAfterAttached)
      return;
    Zs() || t.getFocusableElement().focus();
    const r = t.getInputElement();
    this.highlightAllOnFocus ? r.select() : (i = (n = this.cellEditorInput).setCaret) == null || i.call(n);
  }
  // gets called when tabbing through cells and in full row edit mode
  focusIn() {
    const e = this.eInput, t = e.getFocusableElement(), r = e.getInputElement();
    t.focus(), r.select();
  }
  getValue() {
    return this.cellEditorInput.getValue();
  }
  isPopup() {
    return !1;
  }
}, lBe = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-text-field class="ag-cell-editor" data-ref="eInput"></ag-input-text-field>'
    );
  }
  getAgComponents() {
    return [vw];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.maxLength != null && e.setMaxLength(t.maxLength);
  }
  getValue() {
    const e = this.eInput.getValue();
    return !Me(e) && !Me(this.params.value) ? this.params.value : this.params.parseValue(e);
  }
  getStartValue() {
    return this.params.useFormatter || this.params.column.getColDef().refData ? this.params.formatValue(this.params.value) : this.params.value;
  }
  setCaret() {
    const e = this.eInput.getValue(), t = Me(e) && e.length || 0;
    t && this.eInput.getInputElement().setSelectionRange(t, t);
  }
}, dY = class extends yw {
  constructor() {
    super(new lBe());
  }
}, uBe = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-number-field class="ag-cell-editor" data-ref="eInput"></ag-input-number-field>'
    );
  }
  getAgComponents() {
    return [jNe];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.max != null && e.setMax(t.max), t.min != null && e.setMin(t.min), t.precision != null && e.setPrecision(t.precision), t.step != null && e.setStep(t.step);
    const r = e.getInputElement();
    t.preventStepping ? e.addManagedElementListeners(r, { keydown: this.preventStepping }) : t.showStepperButtons && r.classList.add("ag-number-field-input-stepper");
  }
  preventStepping(e) {
    (e.key === ae.UP || e.key === ae.DOWN) && e.preventDefault();
  }
  getValue() {
    const e = this.eInput.getValue();
    if (!Me(e) && !Me(this.params.value))
      return this.params.value;
    let t = this.params.parseValue(e);
    if (t == null)
      return t;
    if (typeof t == "string") {
      if (t === "")
        return null;
      t = Number(t);
    }
    return isNaN(t) ? null : t;
  }
  getStartValue() {
    return this.params.value;
  }
}, cBe = class extends yw {
  constructor() {
    super(new uBe());
  }
}, dBe = class extends rd {
  constructor(e) {
    super(e, "ag-date-field", "date");
  }
  postConstruct() {
    super.postConstruct();
    const e = Zs();
    this.addManagedListeners(this.eInput, {
      wheel: this.onWheel.bind(this),
      mousedown: () => {
        this.isDisabled() || e || this.eInput.focus();
      }
    }), this.eInput.step = "any";
  }
  onWheel(e) {
    this.gos.getActiveDomElement() === this.eInput && e.preventDefault();
  }
  setMin(e) {
    const t = e instanceof Date ? Io(e ?? null, !1) ?? void 0 : e;
    return this.min === t ? this : (this.min = t, Ls(this.eInput, "min", t), this);
  }
  setMax(e) {
    const t = e instanceof Date ? Io(e ?? null, !1) ?? void 0 : e;
    return this.max === t ? this : (this.max = t, Ls(this.eInput, "max", t), this);
  }
  setStep(e) {
    return this.step === e ? this : (this.step = e, Ls(this.eInput, "step", e), this);
  }
  getDate() {
    if (this.eInput.validity.valid)
      return Oi(this.getValue()) ?? void 0;
  }
  setDate(e, t) {
    this.setValue(Io(e ?? null, !1), t);
  }
}, hY = {
  selector: "AG-INPUT-DATE-FIELD",
  component: dBe
}, hBe = class {
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    );
  }
  getAgComponents() {
    return [hY];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.eInput.getDate();
    return !Me(e) && !Me(this.params.value) ? this.params.value : e ?? null;
  }
  getStartValue() {
    const { value: e } = this.params;
    if (e instanceof Date)
      return Io(e, !1);
  }
}, fBe = class extends yw {
  constructor() {
    super(new hBe());
  }
}, pBe = class {
  constructor(e) {
    this.getDataTypeService = e;
  }
  getTemplate() {
    return (
      /* html */
      '<ag-input-date-field class="ag-cell-editor" data-ref="eInput"></ag-input-date-field>'
    );
  }
  getAgComponents() {
    return [hY];
  }
  init(e, t) {
    this.eInput = e, this.params = t, t.min != null && e.setMin(t.min), t.max != null && e.setMax(t.max), t.step != null && e.setStep(t.step);
  }
  getValue() {
    const e = this.formatDate(this.eInput.getDate());
    return !Me(e) && !Me(this.params.value) ? this.params.value : this.params.parseValue(e ?? "");
  }
  getStartValue() {
    return Io(this.parseDate(this.params.value ?? void 0) ?? null, !1);
  }
  parseDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateParserFunction(this.params.column)(e) : Oi(e) ?? void 0;
  }
  formatDate(e) {
    const t = this.getDataTypeService();
    return t ? t.getDateFormatterFunction(this.params.column)(e) : Io(e ?? null, !1) ?? void 0;
  }
}, gBe = class extends yw {
  wireBeans(e) {
    this.dataTypeService = e.dataTypeService;
  }
  constructor() {
    super(new pBe(() => this.dataTypeService));
  }
}, vBe = class extends xf {
  constructor() {
    super(
      /* html */
      `
            <div class="ag-cell-wrapper ag-cell-edit-wrapper ag-checkbox-edit">
                <ag-checkbox role="presentation" data-ref="eCheckbox"></ag-checkbox>
            </div>`,
      [TA]
    ), this.eCheckbox = ft;
  }
  init(e) {
    this.params = e;
    const t = e.value ?? void 0;
    this.eCheckbox.setValue(t), this.eCheckbox.getInputElement().setAttribute("tabindex", "-1"), this.setAriaLabel(t), this.addManagedListeners(this.eCheckbox, {
      fieldValueChanged: (n) => this.setAriaLabel(n.selected)
    });
  }
  getValue() {
    return this.eCheckbox.getValue();
  }
  focusIn() {
    this.eCheckbox.getFocusableElement().focus();
  }
  afterGuiAttached() {
    this.params.cellStartedEdit && this.focusIn();
  }
  isPopup() {
    return !1;
  }
  setAriaLabel(e) {
    const t = this.localeService.getLocaleTextFunc(), r = CA(t, e), n = t("ariaToggleCellValue", "Press SPACE to toggle cell value");
    this.eCheckbox.setInputAriaLabel(`${n} (${r})`);
  }
}, Vp = class {
  constructor(e) {
    this.cellValueChanges = e;
  }
}, eE = class extends Vp {
  constructor(e, t, r, n) {
    super(e), this.initialRange = t, this.finalRange = r, this.ranges = n;
  }
}, mBe = 10, kG = class {
  constructor(e) {
    this.actionStack = [], this.maxStackSize = e || mBe, this.actionStack = new Array(this.maxStackSize);
  }
  pop() {
    return this.actionStack.pop();
  }
  push(e) {
    e.cellValueChanges && e.cellValueChanges.length > 0 && (this.actionStack.length === this.maxStackSize && this.actionStack.shift(), this.actionStack.push(e));
  }
  clear() {
    this.actionStack = [];
  }
  getCurrentStackSize() {
    return this.actionStack.length;
  }
}, yBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "undoRedoService", this.cellValueChanges = [], this.activeCellEdit = null, this.activeRowEdit = null, this.isPasting = !1, this.isRangeInAction = !1, this.onCellValueChanged = (e) => {
      const t = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned }, r = this.activeCellEdit !== null && this.cellPositionUtils.equals(this.activeCellEdit, t), n = this.activeRowEdit !== null && this.rowPositionUtils.sameRow(this.activeRowEdit, t);
      if (!(r || n || this.isPasting || this.isRangeInAction))
        return;
      const { rowPinned: o, rowIndex: a, column: s, oldValue: l, value: u } = e, c = {
        rowPinned: o,
        rowIndex: a,
        columnId: s.getColId(),
        newValue: u,
        oldValue: l
      };
      this.cellValueChanges.push(c);
    }, this.clearStacks = () => {
      this.undoStack.clear(), this.redoStack.clear();
    };
  }
  wireBeans(e) {
    this.focusService = e.focusService, this.ctrlsService = e.ctrlsService, this.cellPositionUtils = e.cellPositionUtils, this.rowPositionUtils = e.rowPositionUtils, this.columnModel = e.columnModel, this.rangeService = e.rangeService;
  }
  postConstruct() {
    if (!this.gos.get("undoRedoCellEditing"))
      return;
    const e = this.gos.get("undoRedoCellEditingLimit");
    if (e <= 0)
      return;
    this.undoStack = new kG(e), this.redoStack = new kG(e), this.addListeners();
    const t = this.clearStacks.bind(this);
    this.addManagedEventListeners({
      cellValueChanged: this.onCellValueChanged.bind(this),
      // undo / redo is restricted to actual editing so we clear the stacks when other operations are
      // performed that change the order of the row / cols.
      modelUpdated: (r) => {
        r.keepUndoRedoStack || this.clearStacks();
      },
      columnPivotModeChanged: t,
      newColumnsLoaded: t,
      columnGroupOpened: t,
      columnRowGroupChanged: t,
      columnMoved: t,
      columnPinned: t,
      columnVisible: t,
      rowDragEnd: t
    }), this.ctrlsService.whenReady((r) => {
      this.gridBodyCtrl = r.gridBodyCtrl;
    });
  }
  getCurrentUndoStackSize() {
    return this.undoStack ? this.undoStack.getCurrentStackSize() : 0;
  }
  getCurrentRedoStackSize() {
    return this.redoStack ? this.redoStack.getCurrentStackSize() : 0;
  }
  undo(e) {
    const t = {
      type: "undoStarted",
      source: e
    };
    this.eventService.dispatchEvent(t);
    const r = this.undoRedo(this.undoStack, this.redoStack, "initialRange", "oldValue", "undo"), n = {
      type: "undoEnded",
      source: e,
      operationPerformed: r
    };
    this.eventService.dispatchEvent(n);
  }
  redo(e) {
    const t = {
      type: "redoStarted",
      source: e
    };
    this.eventService.dispatchEvent(t);
    const r = this.undoRedo(this.redoStack, this.undoStack, "finalRange", "newValue", "redo"), n = {
      type: "redoEnded",
      source: e,
      operationPerformed: r
    };
    this.eventService.dispatchEvent(n);
  }
  undoRedo(e, t, r, n, i) {
    if (!e)
      return !1;
    const o = e.pop();
    return !o || !o.cellValueChanges ? !1 : (this.processAction(
      o,
      (a) => a[n],
      i
    ), o instanceof eE ? this.processRange(this.rangeService, o.ranges || [o[r]]) : this.processCell(o.cellValueChanges), t.push(o), !0);
  }
  processAction(e, t, r) {
    e.cellValueChanges.forEach((n) => {
      const { rowIndex: i, rowPinned: o, columnId: a } = n, s = { rowIndex: i, rowPinned: o }, l = this.rowPositionUtils.getRowNode(s);
      l.displayed && l.setDataValue(a, t(n), r);
    });
  }
  processRange(e, t) {
    let r;
    e.removeAllCellRanges(!0), t.forEach((n, i) => {
      if (!n)
        return;
      const o = n.startRow, a = n.endRow;
      i === t.length - 1 && (r = {
        rowPinned: o.rowPinned,
        rowIndex: o.rowIndex,
        columnId: n.startColumn.getColId()
      }, this.setLastFocusedCell(r));
      const s = {
        rowStartIndex: o.rowIndex,
        rowStartPinned: o.rowPinned,
        rowEndIndex: a.rowIndex,
        rowEndPinned: a.rowPinned,
        columnStart: n.startColumn,
        columns: n.columns
      };
      e.addCellRange(s);
    });
  }
  processCell(e) {
    const t = e[0], { rowIndex: r, rowPinned: n } = t, i = { rowIndex: r, rowPinned: n }, o = this.rowPositionUtils.getRowNode(i), a = {
      rowPinned: t.rowPinned,
      rowIndex: o.rowIndex,
      columnId: t.columnId
    };
    this.setLastFocusedCell(a, this.rangeService);
  }
  setLastFocusedCell(e, t) {
    const { rowIndex: r, columnId: n, rowPinned: i } = e, o = this.gridBodyCtrl.getScrollFeature(), a = this.columnModel.getCol(n);
    if (!a)
      return;
    o.ensureIndexVisible(r), o.ensureColumnVisible(a);
    const s = { rowIndex: r, column: a, rowPinned: i };
    this.focusService.setFocusedCell({ ...s, forceBrowserFocus: !0 }), t == null || t.setRangeToCell(s);
  }
  addListeners() {
    this.addManagedEventListeners({
      rowEditingStarted: (e) => {
        this.activeRowEdit = { rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      rowEditingStopped: () => {
        const e = new Vp(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.activeRowEdit = null;
      },
      cellEditingStarted: (e) => {
        this.activeCellEdit = { column: e.column, rowIndex: e.rowIndex, rowPinned: e.rowPinned };
      },
      cellEditingStopped: (e) => {
        if (this.activeCellEdit = null, e.valueChanged && !this.activeRowEdit && !this.isPasting && !this.isRangeInAction) {
          const r = new Vp(this.cellValueChanges);
          this.pushActionsToUndoStack(r);
        }
      },
      pasteStart: () => {
        this.isPasting = !0;
      },
      pasteEnd: () => {
        const e = new Vp(this.cellValueChanges);
        this.pushActionsToUndoStack(e), this.isPasting = !1;
      },
      fillStart: () => {
        this.isRangeInAction = !0;
      },
      fillEnd: (e) => {
        const t = new eE(this.cellValueChanges, e.initialRange, e.finalRange);
        this.pushActionsToUndoStack(t), this.isRangeInAction = !1;
      },
      keyShortcutChangedCellStart: () => {
        this.isRangeInAction = !0;
      },
      keyShortcutChangedCellEnd: () => {
        let e;
        this.rangeService && this.gos.get("enableRangeSelection") ? e = new eE(this.cellValueChanges, void 0, void 0, [
          ...this.rangeService.getCellRanges()
        ]) : e = new Vp(this.cellValueChanges), this.pushActionsToUndoStack(e), this.isRangeInAction = !1;
      }
    });
  }
  pushActionsToUndoStack(e) {
    this.undoStack.push(e), this.cellValueChanges = [], this.redoStack.clear();
  }
};
function CBe(e) {
  return e.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
}
function SBe(e) {
  return e.ctrlsService.getGridBodyCtrl().getScrollFeature().getHScrollPosition();
}
function fY(e, t, r = "auto") {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureColumnVisible(t, r),
    "ensureVisible"
  );
}
function pY(e, t, r) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureIndexVisible(t, r),
    "ensureVisible"
  );
}
function wBe(e, t, r = null) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getGridBodyCtrl().getScrollFeature().ensureNodeVisible(t, r),
    "ensureVisible"
  );
}
function bBe(e) {
  var t;
  (t = e.undoRedoService) == null || t.undo("api");
}
function xBe(e) {
  var t;
  (t = e.undoRedoService) == null || t.redo("api");
}
function EBe(e, t = {}) {
  return e.rowRenderer.getCellEditorInstances(t).map(dg);
}
function RBe(e) {
  return e.rowRenderer.getEditingCells();
}
function _Be(e, t = !1) {
  e.rowRenderer.stopEditing(t);
}
function TBe(e, t) {
  const r = e.columnModel.getCol(t.colKey);
  if (!r) {
    Se(`no column found for ${t.colKey}`);
    return;
  }
  const n = {
    rowIndex: t.rowIndex,
    rowPinned: t.rowPinned || null,
    column: r
  };
  t.rowPinned == null && pY(e, t.rowIndex), fY(e, t.colKey);
  const o = e.navigationService.getCellByPosition(n);
  o && (e.focusService.isCellFocused(n) || e.focusService.setFocusedCell(n), o.startRowOrCellEdit(t.key));
}
function PBe(e) {
  var t;
  return ((t = e.undoRedoService) == null ? void 0 : t.getCurrentUndoStackSize()) ?? 0;
}
function MBe(e) {
  var t;
  return ((t = e.undoRedoService) == null ? void 0 : t.getCurrentRedoStackSize()) ?? 0;
}
var DBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "editService";
  }
  wireBeans(e) {
    this.navigationService = e.navigationService, this.userComponentFactory = e.userComponentFactory, this.valueService = e.valueService;
  }
  startEditing(e, t = null, r = !1, n = null) {
    const i = this.createCellEditorParams(e, t, r), o = e.getColumn().getColDef(), a = this.userComponentFactory.getCellEditorDetails(o, i), s = (a == null ? void 0 : a.popupFromSelector) != null ? a.popupFromSelector : !!o.cellEditorPopup, l = (a == null ? void 0 : a.popupPositionFromSelector) != null ? a.popupPositionFromSelector : o.cellEditorPopupPosition;
    e.setEditing(!0, a), e.getComp().setEditDetails(a, s, l, this.gos.get("reactiveCustomComponents"));
    const u = e.createEvent(n, "cellEditingStarted");
    this.eventService.dispatchEvent(u);
  }
  stopEditing(e, t) {
    const r = e.getComp(), { newValue: n, newValueExists: i } = this.takeValueFromCellEditor(t, r), o = e.getRowNode(), a = e.getColumn(), s = o.getValueFromValueService(a);
    let l = !1;
    i && (l = this.saveNewValue(e, s, n, o, a)), e.setEditing(!1, void 0), r.setEditDetails(), e.updateAndFormatValue(!1), e.refreshCell({ forceRefresh: !0, suppressFlash: !0 });
    const u = {
      ...e.createEvent(null, "cellEditingStopped"),
      oldValue: s,
      newValue: n,
      valueChanged: l
    };
    return this.eventService.dispatchEvent(u), l;
  }
  handleColDefChanged(e) {
    const t = e.getCellEditor();
    if (t != null && t.refresh) {
      const { eventKey: r, cellStartedEdit: n } = e.getEditCompDetails().params, i = this.createCellEditorParams(e, r, n), o = e.getColumn().getColDef(), a = this.userComponentFactory.getCellEditorDetails(o, i);
      t.refresh(a.params);
    }
  }
  setFocusOutOnEditor(e) {
    const t = e.getComp().getCellEditor();
    t && t.focusOut && t.focusOut();
  }
  setFocusInOnEditor(e) {
    const t = e.getComp().getCellEditor();
    t && t.focusIn ? t.focusIn() : e.focusCell(!0);
  }
  stopEditingAndFocus(e, t = !1, r = !1) {
    e.stopRowOrCellEdit(), e.focusCell(!0), t || this.navigateAfterEdit(r, e.getCellPosition());
  }
  createPopupEditorWrapper(e) {
    return new aBe(e);
  }
  takeValueFromCellEditor(e, t) {
    const r = { newValueExists: !1 };
    if (e)
      return r;
    const n = t.getCellEditor();
    return !n || n.isCancelAfterEnd && n.isCancelAfterEnd() ? r : {
      newValue: n.getValue(),
      newValueExists: !0
    };
  }
  /**
   * @returns `True` if the value changes, otherwise `False`.
   */
  saveNewValue(e, t, r, n, i) {
    if (r === t)
      return !1;
    e.setSuppressRefreshCell(!0);
    const o = n.setDataValue(i, r, "edit");
    return e.setSuppressRefreshCell(!1), o;
  }
  createCellEditorParams(e, t, r) {
    const n = e.getColumn(), i = e.getRowNode();
    return this.gos.addGridCommonParams({
      value: i.getValueFromValueService(n),
      eventKey: t,
      column: n,
      colDef: n.getColDef(),
      rowIndex: e.getCellPosition().rowIndex,
      node: i,
      data: i.data,
      cellStartedEdit: r,
      onKeyDown: e.onKeyDown.bind(e),
      stopEditing: e.stopEditingAndFocus.bind(e),
      eGridCell: e.getGui(),
      parseValue: (o) => this.valueService.parseValue(n, i, o, e.getValue()),
      formatValue: e.formatValue.bind(e)
    });
  }
  navigateAfterEdit(e, t) {
    if (this.gos.get("enterNavigatesVerticallyAfterEdit")) {
      const n = e ? ae.UP : ae.DOWN;
      this.navigationService.navigateToNextCell(null, n, t, !1);
    }
  }
}, ABe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowEditService";
  }
  startEditing(e, t = null, r = null, n = null) {
    e.getAllCellCtrls().reduce((o, a) => {
      const s = a === r;
      return s ? a.startEditing(t, s, n) : a.startEditing(null, s, n), o ? !0 : a.isEditing();
    }, !1) && this.setEditing(e, !0);
  }
  stopEditing(e, t = !1) {
    const r = e.getAllCellCtrls(), n = e.isEditing();
    e.setStoppingRowEdit(!0);
    let i = !1;
    for (const o of r) {
      const a = o.stopEditing(t);
      n && !t && !i && a && (i = !0);
    }
    if (i) {
      const o = e.createRowEvent("rowValueChanged");
      this.eventService.dispatchEvent(o);
    }
    n && this.setEditing(e, !1), e.setStoppingRowEdit(!1);
  }
  setEditing(e, t) {
    e.setEditingRow(t), e.forEachGui(void 0, (n) => n.rowComp.addOrRemoveCssClass("ag-row-editing", t));
    const r = t ? e.createRowEvent("rowEditingStarted") : e.createRowEvent("rowEditingStopped");
    this.eventService.dispatchEvent(r);
  }
}, nd = {
  version: Et,
  moduleName: "@ag-grid-community/edit-core",
  beans: [DBe]
}, IBe = {
  version: Et,
  moduleName: "@ag-grid-community/edit-api",
  apiFunctions: {
    undoCellEditing: bBe,
    redoCellEditing: xBe,
    getCellEditorInstances: EBe,
    getEditingCells: RBe,
    stopEditing: _Be,
    startEditingCell: TBe,
    getCurrentUndoSize: PBe,
    getCurrentRedoSize: MBe
  },
  dependantModules: [nd]
}, FBe = {
  version: Et,
  moduleName: "@ag-grid-community/undo-redo-edit",
  beans: [yBe],
  dependantModules: [nd]
}, LBe = {
  version: Et,
  moduleName: "@ag-grid-community/full-row-edit",
  beans: [ABe],
  dependantModules: [nd]
}, gY = {
  version: Et,
  moduleName: "@ag-grid-community/default-editor",
  userComponents: [{ name: "agCellEditor", classImp: dY }],
  dependantModules: [nd]
}, OBe = {
  version: Et,
  moduleName: "@ag-grid-community/data-type-editors",
  userComponents: [
    { name: "agTextCellEditor", classImp: dY },
    { name: "agNumberCellEditor", classImp: cBe },
    { name: "agDateCellEditor", classImp: fBe },
    { name: "agDateStringCellEditor", classImp: gBe },
    { name: "agCheckboxCellEditor", classImp: vBe }
  ],
  dependantModules: [gY]
}, NBe = {
  version: Et,
  moduleName: "@ag-grid-community/select-editor",
  userComponents: [{ name: "agSelectCellEditor", classImp: sBe }],
  dependantModules: [nd]
}, kBe = {
  version: Et,
  moduleName: "@ag-grid-community/large-text-editor",
  userComponents: [{ name: "agLargeTextCellEditor", classImp: oBe }],
  dependantModules: [nd]
}, VBe = {
  version: Et,
  moduleName: "@ag-grid-community/all-editors",
  dependantModules: [gY, OBe, NBe, kBe]
}, BBe = {
  version: Et,
  moduleName: "@ag-grid-community/editing",
  dependantModules: [nd, FBe, LBe, VBe, IBe]
}, GBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "autoWidthCalculator";
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.centerRowContainerCtrl = e.center;
    });
  }
  // this is the trick: we create a dummy container and clone all the cells
  // into the dummy, then check the dummy's width. then destroy the dummy
  // as we don't need it any more.
  // drawback: only the cells visible on the screen are considered
  getPreferredWidthForColumn(e, t) {
    const r = this.getHeaderCellForColumn(e);
    if (!r)
      return -1;
    const n = this.rowRenderer.getAllCellsForColumn(e);
    return t || n.push(r), this.addElementsToContainerAndGetWidth(n);
  }
  getPreferredWidthForColumnGroup(e) {
    const t = this.getHeaderCellForColumn(e);
    return t ? this.addElementsToContainerAndGetWidth([t]) : -1;
  }
  addElementsToContainerAndGetWidth(e) {
    const t = document.createElement("form");
    t.style.position = "fixed";
    const r = this.centerRowContainerCtrl.getContainerElement();
    e.forEach((o) => this.cloneItemIntoDummy(o, t)), r.appendChild(t);
    const n = t.offsetWidth;
    r.removeChild(t);
    const i = this.getAutoSizePadding();
    return n + i;
  }
  getAutoSizePadding() {
    return this.gos.get("autoSizePadding");
  }
  getHeaderCellForColumn(e) {
    let t = null;
    return this.ctrlsService.getHeaderRowContainerCtrls().forEach((r) => {
      const n = r.getHtmlElementForColumnHeader(e);
      n != null && (t = n);
    }), t;
  }
  cloneItemIntoDummy(e, t) {
    const r = e.cloneNode(!0);
    r.style.width = "", r.style.position = "static", r.style.left = "";
    const n = document.createElement("div"), i = n.classList;
    ["ag-header-cell", "ag-header-group-cell"].some((s) => r.classList.contains(s)) ? (i.add("ag-header", "ag-header-row"), n.style.position = "static") : i.add("ag-row");
    let a = e.parentElement;
    for (; a; ) {
      if (["ag-header-row", "ag-row"].some((l) => a.classList.contains(l))) {
        for (let l = 0; l < a.classList.length; l++) {
          const u = a.classList[l];
          u != "ag-row-position-absolute" && i.add(u);
        }
        break;
      }
      a = a.parentElement;
    }
    n.appendChild(r), t.appendChild(n);
  }
}, HBe = class extends he {
  constructor(e, t) {
    super(), this.createRowCon = e, this.destroyRowCtrls = t, this.stickyTopRowCtrls = [], this.stickyBottomRowCtrls = [], this.topContainerHeight = 0, this.bottomContainerHeight = 0, this.extraTopHeight = 0, this.extraBottomHeight = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer, this.ctrlsService = e.ctrlsService, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.isClientSide = this.rowModel.getType() === "clientSide", this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl;
    });
  }
  getStickyTopRowCtrls() {
    return this.stickyTopRowCtrls;
  }
  getStickyBottomRowCtrls() {
    return this.stickyBottomRowCtrls;
  }
  setOffsetTop(e) {
    if (this.extraTopHeight === e)
      return;
    this.extraTopHeight = e;
    const t = {
      type: "stickyTopOffsetChanged",
      offset: e
    };
    this.eventService.dispatchEvent(t);
  }
  setOffsetBottom(e) {
    this.extraBottomHeight !== e && (this.extraBottomHeight = e);
  }
  resetOffsets() {
    this.setOffsetBottom(0), this.setOffsetTop(0);
  }
  getExtraTopHeight() {
    return this.extraTopHeight;
  }
  getExtraBottomHeight() {
    return this.extraBottomHeight;
  }
  /**
   * Get the last pixel of the group, this pixel is used to push the sticky node up out of the viewport.
   */
  getLastPixelOfGroup(e) {
    return this.isClientSide ? this.getClientSideLastPixelOfGroup(e) : this.getServerSideLastPixelOfGroup(e);
  }
  /**
   * Get the first pixel of the group, this pixel is used to push the sticky node down out of the viewport
   */
  getFirstPixelOfGroup(e) {
    return e.footer ? e.sibling.rowTop + e.sibling.rowHeight - 1 : e.hasChildren() ? e.rowTop - 1 : 0;
  }
  getServerSideLastPixelOfGroup(e) {
    var t, r;
    if (this.isClientSide)
      throw new Error("This func should only be called in server side row model.");
    if (e.isExpandable() || e.footer) {
      if (e.master)
        return e.detailNode.rowTop + e.detailNode.rowHeight;
      if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
        let i = (t = e.childStore) == null ? void 0 : t.getStoreBounds();
        return e.footer && (i = (r = e.sibling.childStore) == null ? void 0 : r.getStoreBounds()), ((i == null ? void 0 : i.heightPx) ?? 0) + ((i == null ? void 0 : i.topPx) ?? 0);
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  getClientSideLastPixelOfGroup(e) {
    if (!this.isClientSide)
      throw new Error("This func should only be called in client side row model.");
    if (e.isExpandable() || e.footer) {
      if (e.footer && e.rowIndex === 0)
        return Number.MAX_SAFE_INTEGER;
      if (!e.sibling || Math.abs(e.sibling.rowIndex - e.rowIndex) === 1) {
        let n = e.footer ? e.sibling : e;
        for (; n.isExpandable() && n.expanded; )
          if (n.master)
            n = n.detailNode;
          else if (n.childrenAfterSort) {
            if (n.childrenAfterSort.length === 0)
              break;
            n = Jt(n.childrenAfterSort);
          }
        return n.rowTop + n.rowHeight;
      }
      return e.footer ? e.rowTop + e.rowHeight : e.sibling.rowTop + e.sibling.rowHeight;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  updateStickyRows(e) {
    const t = e === "top";
    let r = 0;
    if (!this.canRowsBeSticky())
      return this.refreshNodesAndContainerHeight(e, /* @__PURE__ */ new Set(), r);
    const n = t ? this.rowRenderer.getFirstVisibleVerticalPixel() - this.extraTopHeight : this.rowRenderer.getLastVisibleVerticalPixel() - this.extraTopHeight, i = /* @__PURE__ */ new Set(), o = (u) => {
      if (i.add(u), t) {
        const c = this.getLastPixelOfGroup(u), d = n + r + u.rowHeight;
        c < d ? u.stickyRowTop = r + (c - d) : u.stickyRowTop = r;
      } else {
        const c = this.getFirstPixelOfGroup(u), d = n - (r + u.rowHeight);
        c > d ? u.stickyRowTop = r - (c - d) : u.stickyRowTop = r;
      }
      r = 0, i.forEach((c) => {
        const d = c.stickyRowTop + c.rowHeight;
        r < d && (r = d);
      });
    }, a = this.areFooterRowsStickySuppressed(), s = this.gos.get("suppressGroupRowsSticky"), l = (u) => u.displayed ? u.footer ? a === !0 || a === "grand" && u.level === -1 || a === "group" && u.level > -1 ? !1 : !i.has(u) : u.isExpandable() ? s === !0 ? !1 : !i.has(u) && u.expanded : !1 : !1;
    for (let u = 0; u < 100; u++) {
      let c = n + r;
      t || (c = n - r);
      const d = this.rowModel.getRowIndexAtPixel(c), h = this.rowModel.getRow(d);
      if (h == null)
        break;
      const p = this.getStickyAncestors(h).find(
        (v) => (t ? v.rowIndex < d : v.rowIndex > d) && l(v)
      );
      if (p) {
        o(p);
        continue;
      }
      if ((t ? h.rowTop < c : h.rowTop + h.rowHeight > c) && l(h)) {
        o(h);
        continue;
      }
      break;
    }
    return t || i.forEach((u) => {
      u.stickyRowTop = r - (u.stickyRowTop + u.rowHeight);
    }), this.refreshNodesAndContainerHeight(e, i, r);
  }
  areFooterRowsStickySuppressed() {
    const e = this.gos.get("suppressStickyTotalRow");
    if (e === !0)
      return !0;
    const t = !!this.gos.get("groupIncludeFooter") || e === "group", r = !!this.gos.get("groupIncludeTotalFooter") || e === "grand";
    return t && r ? !0 : r ? "grand" : t ? "group" : !1;
  }
  canRowsBeSticky() {
    const e = this.gos.isGroupRowsSticky(), t = this.areFooterRowsStickySuppressed(), r = this.gos.get("suppressGroupRowsSticky");
    return e && (!t || !r);
  }
  getStickyAncestors(e) {
    const t = [];
    let r = e.footer ? e.sibling : e.parent;
    for (; r; )
      r.sibling && t.push(r.sibling), t.push(r), r = r.parent;
    return t.reverse();
  }
  checkStickyRows() {
    const e = this.updateStickyRows("top"), t = this.updateStickyRows("bottom");
    return e || t;
  }
  destroyStickyCtrls() {
    this.refreshNodesAndContainerHeight("top", /* @__PURE__ */ new Set(), 0), this.refreshNodesAndContainerHeight("bottom", /* @__PURE__ */ new Set(), 0);
  }
  refreshStickyNode(e) {
    const t = /* @__PURE__ */ new Set();
    if (this.stickyTopRowCtrls.some((r) => r.getRowNode() === e)) {
      for (let r = 0; r < this.stickyTopRowCtrls.length; r++) {
        const n = this.stickyTopRowCtrls[r].getRowNode();
        n !== e && t.add(n);
      }
      this.refreshNodesAndContainerHeight("top", t, this.topContainerHeight) && this.checkStickyRows();
      return;
    }
    for (let r = 0; r < this.stickyBottomRowCtrls.length; r++) {
      const n = this.stickyBottomRowCtrls[r].getRowNode();
      n !== e && t.add(n);
    }
    this.refreshNodesAndContainerHeight("bottom", t, this.bottomContainerHeight) && this.checkStickyRows();
  }
  /**
   * Destroy old ctrls and create new ctrls where necessary.
   */
  refreshNodesAndContainerHeight(e, t, r) {
    const n = e === "top", i = n ? this.stickyTopRowCtrls : this.stickyBottomRowCtrls, o = {}, a = [];
    for (let h = 0; h < i.length; h++) {
      const f = i[h].getRowNode();
      if (!t.has(f)) {
        o[f.id] = i[h], f.sticky = !1;
        continue;
      }
      a.push(i[h]);
    }
    const s = /* @__PURE__ */ new Set();
    for (let h = 0; h < a.length; h++)
      s.add(a[h].getRowNode());
    const l = [];
    t.forEach((h) => {
      s.has(h) || (h.sticky = !0, l.push(this.createRowCon(h, !1, !1)));
    });
    let u = !!l.length || a.length !== i.length;
    n ? this.topContainerHeight !== r && (this.topContainerHeight = r, this.gridBodyCtrl.setStickyTopHeight(r), u = !0) : this.bottomContainerHeight !== r && (this.bottomContainerHeight = r, this.gridBodyCtrl.setStickyBottomHeight(r), u = !0), this.destroyRowCtrls(o, !1);
    const c = [...a, ...l];
    c.sort((h, f) => f.getRowNode().rowIndex - h.getRowNode().rowIndex), n || c.reverse(), c.forEach((h) => h.setRowTop(h.getRowNode().stickyRowTop));
    let d = 0;
    return n ? (t.forEach((h) => {
      h.rowIndex < this.pageBoundsService.getFirstRow() && (d += h.rowHeight);
    }), d > this.topContainerHeight && (d = this.topContainerHeight), this.setOffsetTop(d)) : (t.forEach((h) => {
      h.rowIndex > this.pageBoundsService.getLastRow() && (d += h.rowHeight);
    }), d > this.bottomContainerHeight && (d = this.bottomContainerHeight), this.setOffsetBottom(d)), u ? (n ? this.stickyTopRowCtrls = c : this.stickyBottomRowCtrls = c, !0) : !1;
  }
  ensureRowHeightsValid() {
    let e = !1;
    const t = (r) => {
      const n = r.getRowNode();
      if (n.rowHeightEstimated) {
        const i = this.gos.getRowHeightForNode(n);
        n.setRowHeight(i.height), e = !0;
      }
    };
    return this.stickyTopRowCtrls.forEach(t), this.stickyBottomRowCtrls.forEach(t), e;
  }
}, zBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowRenderer", this.destroyFuncsForColumnListeners = [], this.rowCtrlsByRowIndex = {}, this.zombieRowCtrls = {}, this.allRowCtrls = [], this.topRowCtrls = [], this.bottomRowCtrls = [], this.refreshInProgress = !1, this.dataFirstRenderedFired = !1, this.setupRangeSelectionListeners = () => {
      const e = () => {
        this.getAllCellCtrls().forEach((o) => o.onRangeSelectionChanged());
      }, t = () => {
        this.getAllCellCtrls().forEach((o) => o.updateRangeBordersIfRangeCount());
      }, r = () => {
        this.eventService.addEventListener("rangeSelectionChanged", e), this.eventService.addEventListener("columnMoved", t), this.eventService.addEventListener("columnPinned", t), this.eventService.addEventListener("columnVisible", t);
      }, n = () => {
        this.eventService.removeEventListener("rangeSelectionChanged", e), this.eventService.removeEventListener("columnMoved", t), this.eventService.removeEventListener("columnPinned", t), this.eventService.removeEventListener("columnVisible", t);
      };
      this.addDestroyFunc(() => n()), this.addManagedPropertyListener("enableRangeSelection", (o) => {
        o.currentValue ? r() : n();
      }), this.gos.get("enableRangeSelection") && r();
    };
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.pinnedRowModel = e.pinnedRowModel, this.rowModel = e.rowModel, this.focusService = e.focusService, this.beans = e, this.rowContainerHeightService = e.rowContainerHeightService, this.ctrlsService = e.ctrlsService, this.environment = e.environment;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridBodyCtrl = e.gridBodyCtrl, this.initialise();
    });
  }
  initialise() {
    if (this.addManagedEventListeners({
      paginationChanged: this.onPageLoaded.bind(this),
      pinnedRowDataChanged: this.onPinnedRowDataChanged.bind(this),
      displayedColumnsChanged: this.onDisplayedColumnsChanged.bind(this),
      bodyScroll: this.onBodyScroll.bind(this),
      bodyHeightChanged: this.redraw.bind(this)
    }), this.addManagedPropertyListeners(["domLayout", "embedFullWidthRows"], () => this.onDomLayoutChanged()), this.addManagedPropertyListeners(["suppressMaxRenderedRowRestriction", "rowBuffer"], () => this.redraw()), this.addManagedPropertyListeners(
      [
        "suppressCellFocus",
        "getBusinessKeyForNode",
        "fullWidthCellRenderer",
        "fullWidthCellRendererParams",
        "rowStyle",
        "getRowStyle",
        "rowClass",
        "getRowClass",
        "rowClassRules",
        "suppressStickyTotalRow",
        "groupRowRenderer",
        "groupRowRendererParams",
        // maybe only needs to refresh FW rows...
        "loadingCellRenderer",
        "loadingCellRendererParams",
        "detailCellRenderer",
        "detailCellRendererParams",
        "enableRangeSelection",
        "enableCellTextSelection"
      ],
      () => this.redrawRows()
    ), this.gos.isGroupRowsSticky()) {
      const e = this.rowModel.getType();
      (e === "clientSide" || e === "serverSide") && (this.stickyRowFeature = this.createManagedBean(
        new HBe(this.createRowCon.bind(this), this.destroyRowCtrls.bind(this))
      ));
    }
    this.registerCellEventListeners(), this.initialiseCache(), this.printLayout = this.gos.isDomLayout("print"), this.embedFullWidthRows = this.printLayout || this.gos.get("embedFullWidthRows"), this.redrawAfterModelUpdate();
  }
  initialiseCache() {
    if (this.gos.get("keepDetailRows")) {
      const e = this.getKeepDetailRowsCount(), t = e ?? 3;
      this.cachedRowCtrls = new $Be(t);
    }
  }
  getKeepDetailRowsCount() {
    return this.gos.get("keepDetailRowsCount");
  }
  getStickyTopRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyTopRowCtrls() : [];
  }
  getStickyBottomRowCtrls() {
    return this.stickyRowFeature ? this.stickyRowFeature.getStickyBottomRowCtrls() : [];
  }
  updateAllRowCtrls() {
    const e = xT(this.rowCtrlsByRowIndex), t = xT(this.zombieRowCtrls), r = this.cachedRowCtrls ? this.cachedRowCtrls.getEntries() : [];
    t.length > 0 || r.length > 0 ? this.allRowCtrls = [...e, ...t, ...r] : this.allRowCtrls = e;
  }
  onCellFocusChanged(e) {
    this.getAllCellCtrls().forEach((t) => t.onCellFocused(e)), this.getFullWidthRowCtrls().forEach((t) => t.onFullWidthRowFocused(e));
  }
  // in a clean design, each cell would register for each of these events. however when scrolling, all the cells
  // registering and de-registering for events is a performance bottleneck. so we register here once and inform
  // all active cells.
  registerCellEventListeners() {
    this.addManagedEventListeners({
      cellFocused: (e) => {
        this.onCellFocusChanged(e);
      },
      cellFocusCleared: () => this.onCellFocusChanged(),
      flashCells: (e) => {
        this.getAllCellCtrls().forEach((t) => t.onFlashCells(e));
      },
      columnHoverChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onColumnHover());
      },
      displayedColumnsChanged: () => {
        this.getAllCellCtrls().forEach((e) => e.onDisplayedColumnsChanged());
      },
      displayedColumnsWidthChanged: () => {
        this.printLayout && this.getAllCellCtrls().forEach((e) => e.onLeftChanged());
      }
    }), this.setupRangeSelectionListeners(), this.refreshListenersToColumnsForCellComps(), this.addManagedEventListeners({
      gridColumnsChanged: this.refreshListenersToColumnsForCellComps.bind(this)
    }), this.addDestroyFunc(this.removeGridColumnListeners.bind(this));
  }
  // executes all functions in destroyFuncsForColumnListeners and then clears the list
  removeGridColumnListeners() {
    this.destroyFuncsForColumnListeners.forEach((e) => e()), this.destroyFuncsForColumnListeners.length = 0;
  }
  // this function adds listeners onto all the grid columns, which are the column that we could have cellComps for.
  // when the grid columns change, we add listeners again. in an ideal design, each CellComp would just register to
  // the column it belongs to on creation, however this was a bottleneck with the number of cells, so do it here
  // once instead.
  refreshListenersToColumnsForCellComps() {
    this.removeGridColumnListeners(), this.columnModel.getCols().forEach((t) => {
      const r = (l) => {
        this.getAllCellCtrls().forEach((u) => {
          u.getColumn() === t && l(u);
        });
      }, n = () => {
        r((l) => l.onLeftChanged());
      }, i = () => {
        r((l) => l.onWidthChanged());
      }, o = () => {
        r((l) => l.onFirstRightPinnedChanged());
      }, a = () => {
        r((l) => l.onLastLeftPinnedChanged());
      }, s = () => {
        r((l) => l.onColDefChanged());
      };
      t.addEventListener("leftChanged", n), t.addEventListener("widthChanged", i), t.addEventListener("firstRightPinnedChanged", o), t.addEventListener("lastLeftPinnedChanged", a), t.addEventListener("colDefChanged", s), this.destroyFuncsForColumnListeners.push(() => {
        t.removeEventListener("leftChanged", n), t.removeEventListener("widthChanged", i), t.removeEventListener("firstRightPinnedChanged", o), t.removeEventListener("lastLeftPinnedChanged", a), t.removeEventListener("colDefChanged", s);
      });
    });
  }
  onDomLayoutChanged() {
    const e = this.gos.isDomLayout("print"), t = e || this.gos.get("embedFullWidthRows"), r = t !== this.embedFullWidthRows || this.printLayout !== e;
    this.printLayout = e, this.embedFullWidthRows = t, r && this.redrawAfterModelUpdate({ domLayoutChanged: !0 });
  }
  // for row models that have datasources, when we update the datasource, we need to force the rowRenderer
  // to redraw all rows. otherwise the old rows from the old datasource will stay displayed.
  datasourceChanged() {
    this.firstRenderedRow = 0, this.lastRenderedRow = -1;
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e);
  }
  onPageLoaded(e) {
    const t = {
      recycleRows: e.keepRenderedRows,
      animate: e.animate,
      newData: e.newData,
      newPage: e.newPage,
      // because this is a model updated event (not pinned rows), we
      // can skip updating the pinned rows. this is needed so that if user
      // is doing transaction updates, the pinned rows are not getting constantly
      // trashed - or editing cells in pinned rows are not refreshed and put into read mode
      onlyBody: !0
    };
    this.redrawAfterModelUpdate(t);
  }
  getAllCellsForColumn(e) {
    const t = [];
    return this.getAllRowCtrls().forEach((r) => {
      const n = r.getCellElement(e);
      n && t.push(n);
    }), t;
  }
  refreshFloatingRowComps() {
    this.refreshFloatingRows(this.topRowCtrls, this.pinnedRowModel.getPinnedTopRowNodes()), this.refreshFloatingRows(this.bottomRowCtrls, this.pinnedRowModel.getPinnedBottomRowNodes());
  }
  getTopRowCtrls() {
    return this.topRowCtrls;
  }
  getCentreRowCtrls() {
    return this.allRowCtrls;
  }
  getBottomRowCtrls() {
    return this.bottomRowCtrls;
  }
  /**
   * Determines which row controllers need to be destroyed and re-created vs which ones can
   * be re-used.
   *
   * This is operation is to pinned/floating rows as `this.recycleRows` is to normal/body rows.
   *
   * All `RowCtrl` instances in `rowCtrls` that don't correspond to `RowNode` instances in `rowNodes` are destroyed.
   * All `RowNode` instances in `rowNodes` that don't correspond to `RowCtrl` instances in `rowCtrls` are created.
   * All instances in `rowCtrls` must be in the same order as their corresponding nodes in `rowNodes`.
   *
   * @param rowCtrls The list of existing row controllers
   * @param rowNodes The canonical list of row nodes that should have associated controllers
   */
  refreshFloatingRows(e, t) {
    const r = Object.fromEntries(t.map((i) => [i.id, i])), n = Object.fromEntries(e.map((i) => [i.getRowNode().id, i]));
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = e[i];
      a && r[a.getRowNode().id] === void 0 && (a.destroyFirstPass(), a.destroySecondPass()), o.id in n ? (e[i] = n[o.id], delete n[o.id]) : e[i] = new xc(o, this.beans, !1, !1, this.printLayout);
    }
    e.length = t.length;
  }
  onPinnedRowDataChanged() {
    const e = {
      recycleRows: !0
    };
    this.redrawAfterModelUpdate(e);
  }
  redrawRow(e, t = !1) {
    var r;
    if (e.sticky)
      this.stickyRowFeature.refreshStickyNode(e);
    else if ((r = this.cachedRowCtrls) != null && r.has(e)) {
      this.cachedRowCtrls.removeRow(e);
      return;
    } else {
      const n = (i) => {
        const o = i[e.rowIndex];
        o && o.getRowNode() === e && (o.destroyFirstPass(), o.destroySecondPass(), i[e.rowIndex] = this.createRowCon(e, !1, !1));
      };
      switch (e.rowPinned) {
        case "top":
          n(this.topRowCtrls);
          break;
        case "bottom":
          n(this.bottomRowCtrls);
          break;
        default:
          n(this.rowCtrlsByRowIndex), this.updateAllRowCtrls();
      }
    }
    t || this.dispatchDisplayedRowsChanged(!1);
  }
  redrawRows(e) {
    if (e != null) {
      e == null || e.forEach((r) => this.redrawRow(r, !0)), this.dispatchDisplayedRowsChanged(!1);
      return;
    }
    this.redrawAfterModelUpdate();
  }
  getCellToRestoreFocusToAfterRefresh(e) {
    const t = e != null && e.suppressKeepFocus ? null : this.focusService.getFocusCellToUseAfterRefresh();
    if (t == null)
      return null;
    const r = this.gos.getActiveDomElement(), n = this.gos.getDomData(r, bc.DOM_DATA_KEY_CELL_CTRL), i = this.gos.getDomData(r, xc.DOM_DATA_KEY_ROW_CTRL);
    return n || i ? t : null;
  }
  // gets called from:
  // +) initialisation (in registerGridComp) params = null
  // +) onDomLayoutChanged, params = null
  // +) onPageLoaded, recycleRows, animate, newData, newPage from event, onlyBody=true
  // +) onPinnedRowDataChanged, recycleRows = true
  // +) redrawRows (from Grid API), recycleRows = true/false
  redrawAfterModelUpdate(e = {}) {
    this.getLockOnRefresh();
    const t = this.getCellToRestoreFocusToAfterRefresh(e);
    this.updateContainerHeights(), this.scrollToTopIfNewData(e);
    const r = !e.domLayoutChanged && !!e.recycleRows, n = e.animate && this.gos.isAnimateRows(), i = r ? this.getRowsToRecycle() : null;
    if (r || this.removeAllRowComps(), this.workOutFirstAndLastRowsToRender(), this.stickyRowFeature) {
      this.stickyRowFeature.checkStickyRows();
      const o = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
      o && this.updateContainerHeights(o);
    }
    this.recycleRows(i, n), this.gridBodyCtrl.updateRowCount(), e.onlyBody || this.refreshFloatingRowComps(), this.dispatchDisplayedRowsChanged(), t != null && this.restoreFocusedCell(t), this.releaseLockOnRefresh();
  }
  scrollToTopIfNewData(e) {
    var n;
    const t = e.newData || e.newPage, r = this.gos.get("suppressScrollOnNewData");
    t && !r && (this.gridBodyCtrl.getScrollFeature().scrollToTop(), (n = this.stickyRowFeature) == null || n.resetOffsets());
  }
  updateContainerHeights(e = 0) {
    if (this.printLayout) {
      this.rowContainerHeightService.setModelHeight(null);
      return;
    }
    let t = this.pageBoundsService.getCurrentPageHeight();
    t === 0 && (t = 1), this.rowContainerHeightService.setModelHeight(t + e);
  }
  getLockOnRefresh() {
    var e, t, r, n;
    if (this.refreshInProgress) {
      const i = ((t = (e = this.frameworkOverrides).getLockOnRefreshError) == null ? void 0 : t.call(e)) ?? "";
      throw new Error(
        "AG Grid: cannot get grid to draw rows when it is in the middle of drawing rows. Your code probably called a grid API method while the grid was in the render stage. To overcome this, put the API call into a timeout, e.g. instead of api.redrawRows(), call setTimeout(function() { api.redrawRows(); }, 0). To see what part of your code that caused the refresh check this stacktrace." + i
      );
    }
    this.refreshInProgress = !0, (n = (r = this.frameworkOverrides).getLockOnRefresh) == null || n.call(r);
  }
  releaseLockOnRefresh() {
    var e, t;
    this.refreshInProgress = !1, (t = (e = this.frameworkOverrides).releaseLockOnRefresh) == null || t.call(e);
  }
  isRefreshInProgress() {
    return this.refreshInProgress;
  }
  // sets the focus to the provided cell, if the cell is provided. this way, the user can call refresh without
  // worry about the focus been lost. this is important when the user is using keyboard navigation to do edits
  // and the cellEditor is calling 'refresh' to get other cells to update (as other cells might depend on the
  // edited cell).
  restoreFocusedCell(e) {
    e && setTimeout(() => {
      this.focusService.setRestoreFocusedCell(e), this.onCellFocusChanged(
        this.gos.addGridCommonParams({
          rowIndex: e.rowIndex,
          column: e.column,
          rowPinned: e.rowPinned,
          forceBrowserFocus: !0,
          preventScrollOnBrowserFocus: !0,
          type: "cellFocused"
        })
      );
    });
  }
  stopEditing(e = !1) {
    this.getAllRowCtrls().forEach((t) => {
      t.stopEditing(e);
    });
  }
  getAllCellCtrls() {
    const e = [], t = this.getAllRowCtrls(), r = t.length;
    for (let n = 0; n < r; n++) {
      const i = t[n].getAllCellCtrls(), o = i.length;
      for (let a = 0; a < o; a++)
        e.push(i[a]);
    }
    return e;
  }
  getAllRowCtrls() {
    const e = this.stickyRowFeature && this.stickyRowFeature.getStickyTopRowCtrls() || [], t = this.stickyRowFeature && this.stickyRowFeature.getStickyBottomRowCtrls() || [], r = [...this.topRowCtrls, ...this.bottomRowCtrls, ...e, ...t];
    for (const n in this.rowCtrlsByRowIndex)
      r.push(this.rowCtrlsByRowIndex[n]);
    return r;
  }
  addRenderedRowListener(e, t, r) {
    const n = this.rowCtrlsByRowIndex[t];
    n && n.addEventListener(e, r);
  }
  flashCells(e = {}) {
    this.getCellCtrls(e.rowNodes, e.columns).forEach(
      (t) => t.flashCell(e)
    );
  }
  refreshCells(e = {}) {
    const t = {
      forceRefresh: e.force,
      newData: !1,
      suppressFlash: e.suppressFlash
    };
    for (const r of this.getCellCtrls(e.rowNodes, e.columns))
      r.refreshOrDestroyCell(t);
    this.refreshFullWidth(e.rowNodes);
  }
  refreshFullWidth(e) {
    if (!e)
      return;
    let t = null;
    this.stickyRowFeature && DG() && (t = this.getCellToRestoreFocusToAfterRefresh() || null);
    for (const r of this.getRowCtrls(e)) {
      if (!r.isFullWidth())
        continue;
      r.refreshFullWidth() || this.redrawRow(r.getRowNode(), !0);
    }
    this.dispatchDisplayedRowsChanged(!1), t && this.restoreFocusedCell(t);
  }
  getCellRendererInstances(e) {
    var i;
    const t = this.getCellCtrls(e.rowNodes, e.columns).map((o) => o.getCellRenderer()).filter((o) => o != null);
    if ((i = e.columns) != null && i.length)
      return t;
    const r = [], n = this.mapRowNodes(e.rowNodes);
    return this.getAllRowCtrls().forEach((o) => {
      if (n && !this.isRowInMap(o.getRowNode(), n) || !o.isFullWidth())
        return;
      const a = o.getFullWidthCellRenderers();
      for (let s = 0; s < a.length; s++) {
        const l = a[s];
        l != null && r.push(l);
      }
    }), [...r, ...t];
  }
  getCellEditorInstances(e) {
    const t = [];
    return this.getCellCtrls(e.rowNodes, e.columns).forEach((r) => {
      const n = r.getCellEditor();
      n && t.push(n);
    }), t;
  }
  getEditingCells() {
    const e = [];
    return this.getAllCellCtrls().forEach((t) => {
      if (t.isEditing()) {
        const r = t.getCellPosition();
        e.push(r);
      }
    }), e;
  }
  mapRowNodes(e) {
    if (!e)
      return;
    const t = {
      top: {},
      bottom: {},
      normal: {}
    };
    return e.forEach((r) => {
      const n = r.id;
      switch (r.rowPinned) {
        case "top":
          t.top[n] = r;
          break;
        case "bottom":
          t.bottom[n] = r;
          break;
        default:
          t.normal[n] = r;
          break;
      }
    }), t;
  }
  isRowInMap(e, t) {
    const r = e.id;
    switch (e.rowPinned) {
      case "top":
        return t.top[r] != null;
      case "bottom":
        return t.bottom[r] != null;
      default:
        return t.normal[r] != null;
    }
  }
  /**
   * @param rowNodes if provided, returns the RowCtrls for the provided rowNodes. otherwise returns all RowCtrls.
   */
  getRowCtrls(e) {
    const t = this.mapRowNodes(e), r = this.getAllRowCtrls();
    return !e || !t ? r : r.filter((n) => {
      const i = n.getRowNode();
      return this.isRowInMap(i, t);
    });
  }
  // returns CellCtrl's that match the provided rowNodes and columns. eg if one row node
  // and two columns provided, that identifies 4 cells, so 4 CellCtrl's returned.
  getCellCtrls(e, t) {
    let r;
    Me(t) && (r = {}, t.forEach((i) => {
      const o = this.columnModel.getCol(i);
      Me(o) && (r[o.getId()] = !0);
    }));
    const n = [];
    return this.getRowCtrls(e).forEach((i) => {
      i.getAllCellCtrls().forEach((o) => {
        const a = o.getColumn().getId();
        r && !r[a] || n.push(o);
      });
    }), n;
  }
  destroy() {
    this.removeAllRowComps(), super.destroy();
  }
  removeAllRowComps() {
    const e = Object.keys(this.rowCtrlsByRowIndex);
    this.removeRowCtrls(e), this.stickyRowFeature && this.stickyRowFeature.destroyStickyCtrls();
  }
  getRowsToRecycle() {
    const e = [];
    ia(this.rowCtrlsByRowIndex, (r, n) => {
      n.getRowNode().id == null && e.push(r);
    }), this.removeRowCtrls(e);
    const t = {};
    return ia(this.rowCtrlsByRowIndex, (r, n) => {
      const i = n.getRowNode();
      t[i.id] = n;
    }), this.rowCtrlsByRowIndex = {}, t;
  }
  // takes array of row indexes
  removeRowCtrls(e, t = !1) {
    e.forEach((r) => {
      const n = this.rowCtrlsByRowIndex[r];
      n && (n.destroyFirstPass(t), n.destroySecondPass()), delete this.rowCtrlsByRowIndex[r];
    });
  }
  onBodyScroll(e) {
    e.direction === "vertical" && this.redraw({ afterScroll: !0 });
  }
  // gets called when rows don't change, but viewport does, so after:
  // 1) height of grid body changes, ie number of displayed rows has changed
  // 2) grid scrolled to new position
  // 3) ensure index visible (which is a scroll)
  redraw(e = {}) {
    const { afterScroll: t } = e;
    let r;
    this.stickyRowFeature && DG() && (r = this.getCellToRestoreFocusToAfterRefresh() || void 0);
    const n = this.firstRenderedRow, i = this.lastRenderedRow;
    this.workOutFirstAndLastRowsToRender();
    let o = !1;
    if (this.stickyRowFeature) {
      o = this.stickyRowFeature.checkStickyRows();
      const s = this.stickyRowFeature.getExtraTopHeight() + this.stickyRowFeature.getExtraBottomHeight();
      s && this.updateContainerHeights(s);
    }
    const a = this.firstRenderedRow !== n || this.lastRenderedRow !== i;
    if (!(t && !o && !a) && (this.getLockOnRefresh(), this.recycleRows(null, !1, t), this.releaseLockOnRefresh(), this.dispatchDisplayedRowsChanged(t && !o), r != null)) {
      const s = this.getCellToRestoreFocusToAfterRefresh();
      r != null && s == null && (this.animationFrameService.flushAllFrames(), this.restoreFocusedCell(r));
    }
  }
  removeRowCompsNotToDraw(e, t) {
    const r = {};
    e.forEach((o) => r[o] = !0);
    const i = Object.keys(this.rowCtrlsByRowIndex).filter((o) => !r[o]);
    this.removeRowCtrls(i, t);
  }
  calculateIndexesToDraw(e) {
    const t = YNe(this.firstRenderedRow, this.lastRenderedRow), r = (i, o) => {
      const a = o.getRowNode().rowIndex;
      a != null && (a < this.firstRenderedRow || a > this.lastRenderedRow) && this.doNotUnVirtualiseRow(o) && t.push(a);
    };
    ia(this.rowCtrlsByRowIndex, r), ia(e, r), t.sort((i, o) => i - o);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const o = t[i], a = this.rowModel.getRow(o);
      a && !a.sticky && n.push(o);
    }
    return n;
  }
  recycleRows(e, t = !1, r = !1) {
    const n = this.calculateIndexesToDraw(e);
    (this.printLayout || r) && (t = !1), this.removeRowCompsNotToDraw(n, !t), n.forEach((i) => {
      this.createOrUpdateRowCtrl(i, e, t, r);
    }), e && (r && !this.gos.get("suppressAnimationFrame") && !this.printLayout ? this.beans.animationFrameService.addDestroyTask(() => {
      this.destroyRowCtrls(e, t), this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }) : this.destroyRowCtrls(e, t)), this.updateAllRowCtrls();
  }
  dispatchDisplayedRowsChanged(e = !1) {
    const t = {
      type: "displayedRowsChanged",
      afterScroll: e
    };
    this.eventService.dispatchEvent(t);
  }
  onDisplayedColumnsChanged() {
    const e = this.visibleColsService.isPinningLeft(), t = this.visibleColsService.isPinningRight();
    (this.pinningLeft !== e || t !== this.pinningRight) && (this.pinningLeft = e, this.pinningRight = t, this.embedFullWidthRows && this.redrawFullWidthEmbeddedRows());
  }
  // when embedding, what gets showed in each section depends on what is pinned. eg if embedding group expand / collapse,
  // then it should go into the pinned left area if pinning left, or the center area if not pinning.
  redrawFullWidthEmbeddedRows() {
    const e = [];
    this.getFullWidthRowCtrls().forEach((t) => {
      const r = t.getRowNode().rowIndex;
      e.push(r.toString());
    }), this.refreshFloatingRowComps(), this.removeRowCtrls(e), this.redraw({ afterScroll: !0 });
  }
  getFullWidthRowCtrls(e) {
    const t = this.mapRowNodes(e);
    return this.getAllRowCtrls().filter((r) => {
      if (!r.isFullWidth())
        return !1;
      const n = r.getRowNode();
      return !(t != null && !this.isRowInMap(n, t));
    });
  }
  createOrUpdateRowCtrl(e, t, r, n) {
    let i, o = this.rowCtrlsByRowIndex[e];
    if (o || (i = this.rowModel.getRow(e), Me(i) && Me(t) && t[i.id] && i.alreadyRendered && (o = t[i.id], t[i.id] = null)), !o)
      if (i || (i = this.rowModel.getRow(e)), Me(i))
        o = this.createRowCon(i, r, n);
      else
        return;
    return i && (i.alreadyRendered = !0), this.rowCtrlsByRowIndex[e] = o, o;
  }
  destroyRowCtrls(e, t) {
    const r = [];
    ia(e, (n, i) => {
      if (i) {
        if (this.cachedRowCtrls && i.isCacheable()) {
          this.cachedRowCtrls.addRow(i);
          return;
        }
        i.destroyFirstPass(!t), t ? (this.zombieRowCtrls[i.getInstanceId()] = i, r.push(() => {
          i.destroySecondPass(), delete this.zombieRowCtrls[i.getInstanceId()];
        })) : i.destroySecondPass();
      }
    }), t && (r.push(() => {
      this.updateAllRowCtrls(), this.dispatchDisplayedRowsChanged();
    }), kLe(r));
  }
  getRowBuffer() {
    return this.gos.get("rowBuffer");
  }
  getRowBufferInPixels() {
    const e = this.getRowBuffer(), t = this.gos.getRowHeightAsNumber();
    return e * t;
  }
  workOutFirstAndLastRowsToRender() {
    this.rowContainerHeightService.updateOffset();
    let e, t;
    if (!this.rowModel.isRowsToRender())
      e = 0, t = -1;
    else if (this.printLayout)
      this.environment.refreshRowHeightVariable(), e = this.pageBoundsService.getFirstRow(), t = this.pageBoundsService.getLastRow();
    else {
      const s = this.getRowBufferInPixels(), l = this.ctrlsService.getGridBodyCtrl(), u = this.gos.get("suppressRowVirtualisation");
      let c = !1, d, h;
      do {
        const m = this.pageBoundsService.getPixelOffset(), { pageFirstPixel: y, pageLastPixel: C } = this.pageBoundsService.getCurrentPagePixelRange(), S = this.rowContainerHeightService.getDivStretchOffset(), b = l.getScrollFeature().getVScrollPosition(), w = b.top, x = b.bottom;
        u ? (d = y + S, h = C + S) : (d = Math.max(w + m - s, y) + S, h = Math.min(x + m + s, C) + S), this.firstVisibleVPixel = Math.max(w + m, y) + S, this.lastVisibleVPixel = Math.min(x + m, C) + S, c = this.ensureAllRowsInRangeHaveHeightsCalculated(d, h);
      } while (c);
      let f = this.rowModel.getRowIndexAtPixel(d), p = this.rowModel.getRowIndexAtPixel(h);
      const g = this.pageBoundsService.getFirstRow(), v = this.pageBoundsService.getLastRow();
      f < g && (f = g), p > v && (p = v), e = f, t = p;
    }
    const r = this.gos.isDomLayout("normal"), n = this.gos.get("suppressMaxRenderedRowRestriction"), i = Math.max(this.getRowBuffer(), 500);
    r && !n && t - e > i && (t = e + i);
    const o = e !== this.firstRenderedRow, a = t !== this.lastRenderedRow;
    if (o || a) {
      this.firstRenderedRow = e, this.lastRenderedRow = t;
      const s = {
        type: "viewportChanged",
        firstRow: e,
        lastRow: t
      };
      this.eventService.dispatchEvent(s);
    }
  }
  /**
   * This event will only be fired once, and is queued until after the browser next renders.
   * This allows us to fire an event during the start of the render cycle, when we first see data being rendered
   * but not execute the event until all of the data has finished being rendered to the dom.
   */
  dispatchFirstDataRenderedEvent() {
    if (this.dataFirstRenderedFired)
      return;
    this.dataFirstRenderedFired = !0;
    const e = {
      type: "firstDataRendered",
      firstRow: this.firstRenderedRow,
      lastRow: this.lastRenderedRow
    };
    window.requestAnimationFrame(() => {
      this.beans.eventService.dispatchEvent(e);
    });
  }
  ensureAllRowsInRangeHaveHeightsCalculated(e, t) {
    var o, a;
    const r = (o = this.pinnedRowModel) == null ? void 0 : o.ensureRowHeightsValid(), n = (a = this.stickyRowFeature) == null ? void 0 : a.ensureRowHeightsValid(), i = this.rowModel.ensureRowHeightsValid(
      e,
      t,
      this.pageBoundsService.getFirstRow(),
      this.pageBoundsService.getLastRow()
    );
    return (i || n) && this.eventService.dispatchEvent({
      type: "recalculateRowBounds"
    }), n || i || r ? (this.updateContainerHeights(), !0) : !1;
  }
  getFirstVisibleVerticalPixel() {
    return this.firstVisibleVPixel;
  }
  getLastVisibleVerticalPixel() {
    return this.lastVisibleVPixel;
  }
  getFirstVirtualRenderedRow() {
    return this.firstRenderedRow;
  }
  getLastVirtualRenderedRow() {
    return this.lastRenderedRow;
  }
  // check that none of the rows to remove are editing or focused as:
  // a) if editing, we want to keep them, otherwise the user will loose the context of the edit,
  //    eg user starts editing, enters some text, then scrolls down and then up, next time row rendered
  //    the edit is reset - so we want to keep it rendered.
  // b) if focused, we want ot keep keyboard focus, so if user ctrl+c, it goes to clipboard,
  //    otherwise the user can range select and drag (with focus cell going out of the viewport)
  //    and then ctrl+c, nothing will happen if cell is removed from dom.
  // c) if detail record of master detail, as users complained that the context of detail rows
  //    was getting lost when detail row out of view. eg user expands to show detail row,
  //    then manipulates the detail panel (eg sorts the detail grid), then context is lost
  //    after detail panel is scrolled out of / into view.
  doNotUnVirtualiseRow(e) {
    const n = e.getRowNode(), i = this.focusService.isRowNodeFocused(n), o = e.isEditing(), a = n.detail;
    return i || o || a ? !!this.isRowPresent(n) : !1;
  }
  isRowPresent(e) {
    return this.rowModel.isRowPresent(e) ? this.paginationService ? this.paginationService.isRowPresent(e) : !0 : !1;
  }
  createRowCon(e, t, r) {
    const n = this.cachedRowCtrls ? this.cachedRowCtrls.getRow(e) : null;
    if (n)
      return n;
    const i = this.gos.get("suppressAnimationFrame"), o = r && !i && !this.printLayout;
    return new xc(e, this.beans, t, o, this.printLayout);
  }
  getRenderedNodes() {
    const e = this.rowCtrlsByRowIndex;
    return Object.values(e).map((t) => t.getRowNode());
  }
  getRowByPosition(e) {
    let t;
    const { rowIndex: r } = e;
    switch (e.rowPinned) {
      case "top":
        t = this.topRowCtrls[r];
        break;
      case "bottom":
        t = this.bottomRowCtrls[r];
        break;
      default:
        t = this.rowCtrlsByRowIndex[r], t || (t = this.getStickyTopRowCtrls().find((n) => n.getRowNode().rowIndex === r) || null, t || (t = this.getStickyBottomRowCtrls().find((n) => n.getRowNode().rowIndex === r) || null));
        break;
    }
    return t;
  }
  // returns true if any row between startIndex and endIndex is rendered. used by
  // SSRM or IRM, as they don't want to purge visible blocks from cache.
  isRangeInRenderedViewport(e, t) {
    if (e == null || t == null)
      return !1;
    const n = e > this.lastRenderedRow;
    return !(t < this.firstRenderedRow) && !n;
  }
}, $Be = class {
  constructor(e) {
    this.entriesMap = {}, this.entriesList = [], this.maxCount = e;
  }
  addRow(e) {
    if (this.entriesMap[e.getRowNode().id] = e, this.entriesList.push(e), e.setCached(!0), this.entriesList.length > this.maxCount) {
      const t = this.entriesList[0];
      t.destroyFirstPass(), t.destroySecondPass(), this.removeFromCache(t);
    }
  }
  getRow(e) {
    if (e == null || e.id == null)
      return null;
    const t = this.entriesMap[e.id];
    return t ? (this.removeFromCache(t), t.setCached(!1), t.getRowNode() != e ? null : t) : null;
  }
  has(e) {
    return this.entriesMap[e.id] != null;
  }
  removeRow(e) {
    const t = e.id, r = this.entriesMap[t];
    delete this.entriesMap[t], gi(this.entriesList, r);
  }
  removeFromCache(e) {
    const t = e.getRowNode().id;
    delete this.entriesMap[t], gi(this.entriesList, e);
  }
  getEntries() {
    return this.entriesList;
  }
}, WBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "pinnedRowModel", this.nextId = 0;
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.setPinnedTopRowData(), this.setPinnedBottomRowData(), this.addManagedPropertyListener("pinnedTopRowData", () => this.setPinnedTopRowData()), this.addManagedPropertyListener("pinnedBottomRowData", () => this.setPinnedBottomRowData()), this.addManagedEventListeners({ gridStylesChanged: this.onGridStylesChanges.bind(this) });
  }
  isEmpty(e) {
    const t = e === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    return Dn(t);
  }
  isRowsToRender(e) {
    return !this.isEmpty(e);
  }
  getRowAtPixel(e, t) {
    const r = t === "top" ? this.pinnedTopRows : this.pinnedBottomRows;
    if (Dn(r))
      return 0;
    for (let n = 0; n < r.length; n++) {
      const i = r[n];
      if (i.rowTop + i.rowHeight - 1 >= e)
        return n;
    }
    return r.length - 1;
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      const t = (r) => {
        r.setRowHeight(r.rowHeight, !0);
      };
      this.pinnedBottomRows.forEach(t), this.pinnedTopRows.forEach(t);
    }
  }
  ensureRowHeightsValid() {
    var i, o;
    let e = !1, t = 0;
    const r = (a) => {
      if (a.rowHeightEstimated) {
        const s = this.gos.getRowHeightForNode(a);
        a.setRowTop(t), a.setRowHeight(s.height), t += s.height, e = !0;
      }
    };
    (i = this.pinnedBottomRows) == null || i.forEach(r), t = 0, (o = this.pinnedTopRows) == null || o.forEach(r);
    const n = {
      type: "pinnedHeightChanged"
    };
    return this.eventService.dispatchEvent(n), e;
  }
  setPinnedTopRowData() {
    const e = this.gos.get("pinnedTopRowData");
    this.pinnedTopRows = this.createNodesFromData(e, !0);
    const t = {
      type: "pinnedRowDataChanged"
    };
    this.eventService.dispatchEvent(t);
  }
  setPinnedBottomRowData() {
    const e = this.gos.get("pinnedBottomRowData");
    this.pinnedBottomRows = this.createNodesFromData(e, !1);
    const t = {
      type: "pinnedRowDataChanged"
    };
    this.eventService.dispatchEvent(t);
  }
  createNodesFromData(e, t) {
    const r = [];
    if (e) {
      const n = this.gos.getRowIdCallback(), i = t ? Os.ID_PREFIX_TOP_PINNED : Os.ID_PREFIX_BOTTOM_PINNED;
      let o = 0;
      const a = t ? "top" : "bottom";
      e.forEach((s, l) => {
        const u = new Os(this.beans);
        u.data = s, u.id = (n == null ? void 0 : n({ data: s, level: 0, rowPinned: a })) ?? i + this.nextId++, u.rowPinned = a, u.setRowTop(o), u.setRowHeight(this.gos.getRowHeightForNode(u).height), u.setRowIndex(l), o += u.rowHeight, r.push(u);
      });
    }
    return r;
  }
  getPinnedTopRowNodes() {
    return this.pinnedTopRows;
  }
  getPinnedBottomRowNodes() {
    return this.pinnedBottomRows;
  }
  getPinnedTopTotalHeight() {
    return this.getTotalHeight(this.pinnedTopRows);
  }
  getPinnedTopRowCount() {
    return this.pinnedTopRows ? this.pinnedTopRows.length : 0;
  }
  getPinnedBottomRowCount() {
    return this.pinnedBottomRows ? this.pinnedBottomRows.length : 0;
  }
  getPinnedTopRow(e) {
    return this.pinnedTopRows[e];
  }
  getPinnedBottomRow(e) {
    return this.pinnedBottomRows[e];
  }
  forEachPinnedTopRow(e) {
    Dn(this.pinnedTopRows) || this.pinnedTopRows.forEach(e);
  }
  forEachPinnedBottomRow(e) {
    Dn(this.pinnedBottomRows) || this.pinnedBottomRows.forEach(e);
  }
  getPinnedBottomTotalHeight() {
    return this.getTotalHeight(this.pinnedBottomRows);
  }
  getTotalHeight(e) {
    if (!e || e.length === 0)
      return 0;
    const t = Jt(e);
    return t.rowTop + t.rowHeight;
  }
}, jBe = class extends he {
  constructor(e) {
    super(), this.state = "needsLoading", this.version = 0, this.id = e;
  }
  getId() {
    return this.id;
  }
  load() {
    this.state = "loading", this.loadFromDatasource();
  }
  getVersion() {
    return this.version;
  }
  setStateWaitingToLoad() {
    this.version++, this.state = "needsLoading";
  }
  getState() {
    return this.state;
  }
  pageLoadFailed(e) {
    this.isRequestMostRecentAndLive(e) && (this.state = "failed", this.processServerFail()), this.dispatchLoadCompleted(!1);
  }
  success(e, t) {
    this.successCommon(e, t);
  }
  pageLoaded(e, t, r) {
    this.successCommon(e, { rowData: t, rowCount: r });
  }
  isRequestMostRecentAndLive(e) {
    const t = e === this.version, r = this.isAlive();
    return t && r;
  }
  successCommon(e, t) {
    this.dispatchLoadCompleted(), this.isRequestMostRecentAndLive(e) && (this.state = "loaded", this.processServerResult(t));
  }
  dispatchLoadCompleted(e = !0) {
    const t = {
      type: "loadComplete",
      success: e,
      block: this
    };
    this.dispatchLocalEvent(t);
  }
}, UBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowNodeBlockLoader", this.activeBlockLoadsCount = 0, this.blocks = [], this.active = !0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.maxConcurrentRequests = this.getMaxConcurrentDatasourceRequests();
    const e = this.gos.get("blockLoadDebounceMillis");
    e && e > 0 && (this.checkBlockToLoadDebounce = vi(
      this.performCheckBlocksToLoad.bind(this),
      e
    ));
  }
  getMaxConcurrentDatasourceRequests() {
    const e = this.gos.get("maxConcurrentDatasourceRequests");
    if (e == null)
      return 2;
    if (!(e <= 0))
      return e;
  }
  addBlock(e) {
    this.blocks.push(e), e.addEventListener("loadComplete", this.loadComplete.bind(this)), this.checkBlockToLoad();
  }
  removeBlock(e) {
    gi(this.blocks, e);
  }
  destroy() {
    super.destroy(), this.active = !1;
  }
  loadComplete() {
    this.activeBlockLoadsCount--, this.checkBlockToLoad(), this.dispatchLocalEvent({ type: "blockLoaded" }), this.activeBlockLoadsCount == 0 && this.dispatchLocalEvent({ type: "blockLoaderFinished" });
  }
  checkBlockToLoad() {
    this.checkBlockToLoadDebounce ? this.checkBlockToLoadDebounce() : this.performCheckBlocksToLoad();
  }
  performCheckBlocksToLoad() {
    if (!this.active)
      return;
    if (this.printCacheStatus(), this.maxConcurrentRequests != null && this.activeBlockLoadsCount >= this.maxConcurrentRequests) {
      this.gos.get("debug") && sa("RowNodeBlockLoader - checkBlockToLoad: max loads exceeded");
      return;
    }
    const e = this.getAvailableLoadingCount(), t = this.blocks.filter((r) => r.getState() === "needsLoading").slice(0, e);
    this.registerLoads(t.length), t.forEach((r) => r.load()), this.printCacheStatus();
  }
  getBlockState() {
    if (this.gos.isRowModelType("serverSide"))
      return this.rowModel.getBlockStates();
    const e = {};
    return this.blocks.forEach((t) => {
      const { id: r, state: n } = t.getBlockStateJson();
      e[r] = n;
    }), e;
  }
  printCacheStatus() {
    this.gos.get("debug") && sa(
      `RowNodeBlockLoader - printCacheStatus: activePageLoadsCount = ${this.activeBlockLoadsCount}, blocks = ${JSON.stringify(this.getBlockState())}`
    );
  }
  isLoading() {
    return this.activeBlockLoadsCount > 0;
  }
  registerLoads(e) {
    this.activeBlockLoadsCount += e;
  }
  getAvailableLoadingCount() {
    return this.maxConcurrentRequests !== void 0 ? this.maxConcurrentRequests - this.activeBlockLoadsCount : void 0;
  }
}, KBe = {
  version: Et,
  moduleName: "@ag-grid-community/row-node-block",
  beans: [UBe]
}, YBe = class {
  constructor() {
    this.root = null, this.end = null, this.cachedRange = [];
  }
  init(e) {
    this.rowModel = e;
  }
  reset() {
    this.root = null, this.end = null, this.cachedRange.length = 0;
  }
  setRoot(e) {
    this.root = e, this.end = null, this.cachedRange.length = 0;
  }
  setEndRange(e) {
    this.end = e, this.cachedRange.length = 0;
  }
  getRange() {
    if (this.cachedRange.length === 0) {
      const e = this.getRoot(), t = this.getEnd();
      if (e == null || t == null)
        return this.cachedRange;
      this.cachedRange = this.rowModel.getNodesInRangeForSelection(e, t);
    }
    return this.cachedRange;
  }
  isInRange(e) {
    return this.root === null ? !1 : this.getRange().some((t) => t.id === e.id);
  }
  getRoot() {
    var e;
    return this.root && ((e = this.root) == null ? void 0 : e.key) === null && (this.root = this.rowModel.getRowNode(this.root.id) ?? null), this.root;
  }
  getEnd() {
    var e;
    return this.end && ((e = this.end) == null ? void 0 : e.key) === null && (this.end = this.rowModel.getRowNode(this.end.id) ?? null), this.end;
  }
  /**
   * Truncates the range to the given node (assumed to be within the current range).
   * Returns nodes that remain in the current range and those that should be removed
   *
   * @param node - Node at which to truncate the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  truncate(e) {
    const t = this.getRange();
    if (t.length === 0)
      return { keep: [], discard: [] };
    const r = t[0].id === this.root.id, n = t.findIndex((i) => i.id === e.id);
    if (n > -1) {
      const i = t.slice(0, n), o = t.slice(n + 1);
      return this.setEndRange(e), r ? { keep: i, discard: o } : { keep: o, discard: i };
    } else
      return { keep: t, discard: [] };
  }
  /**
   * Extends the range to the given node. Returns nodes that remain in the current range
   * and those that should be removed.
   *
   * @param node - Node marking the new end of the range
   * @returns Object of nodes to either keep or discard (i.e. deselect) from the range
   */
  extend(e, t = !1) {
    const r = this.getRoot();
    if (r == null) {
      const i = this.getRange().slice();
      return t && e.depthFirstSearch((o) => !o.group && i.push(o)), i.push(e), this.setRoot(e), { keep: i, discard: [] };
    }
    if (this.rowModel.getNodesInRangeForSelection(r, e).find((i) => {
      var o;
      return i.id === ((o = this.end) == null ? void 0 : o.id);
    }))
      return this.setEndRange(e), { keep: this.getRange(), discard: [] };
    {
      const i = this.getRange().slice();
      return this.setEndRange(e), { keep: this.getRange(), discard: i };
    }
  }
}, qBe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "stylingService";
  }
  wireBeans(e) {
    this.expressionService = e.expressionService;
  }
  processAllCellClasses(e, t, r, n) {
    this.processClassRules(void 0, e.cellClassRules, t, r, n), this.processStaticCellClasses(e, t, r);
  }
  processClassRules(e, t, r, n, i) {
    if (t == null && e == null)
      return;
    const o = {}, a = {}, s = (l, u) => {
      l.split(" ").forEach((c) => {
        c.trim() != "" && u(c);
      });
    };
    if (t) {
      const l = Object.keys(t);
      for (let u = 0; u < l.length; u++) {
        const c = l[u], d = t[c];
        let h;
        typeof d == "string" ? h = this.expressionService.evaluate(d, r) : typeof d == "function" && (h = d(r)), s(c, (f) => {
          h ? o[f] = !0 : a[f] = !0;
        });
      }
    }
    e && i && Object.keys(e).forEach(
      (l) => s(l, (u) => {
        o[u] || (a[u] = !0);
      })
    ), i && Object.keys(a).forEach(i), Object.keys(o).forEach(n);
  }
  getStaticCellClasses(e, t) {
    const { cellClass: r } = e;
    if (!r)
      return [];
    let n;
    return typeof r == "function" ? n = r(t) : n = r, typeof n == "string" && (n = [n]), n || [];
  }
  processStaticCellClasses(e, t, r) {
    this.getStaticCellClasses(e, t).forEach((i) => {
      r(i);
    });
  }
}, m0 = /* @__PURE__ */ ((e) => (e.TAB_GUARD = "ag-tab-guard", e.TAB_GUARD_TOP = "ag-tab-guard-top", e.TAB_GUARD_BOTTOM = "ag-tab-guard-bottom", e))(m0 || {}), vY = class extends he {
  constructor(e) {
    super(), this.skipTabGuardFocus = !1, this.forcingFocusOut = !1, this.allowFocus = !1;
    const {
      comp: t,
      eTopGuard: r,
      eBottomGuard: n,
      focusTrapActive: i,
      forceFocusOutWhenTabGuardsAreEmpty: o,
      isFocusableContainer: a,
      focusInnerElement: s,
      onFocusIn: l,
      onFocusOut: u,
      shouldStopEventPropagation: c,
      onTabKeyDown: d,
      handleKeyDown: h,
      eFocusableElement: f
    } = e;
    this.comp = t, this.eTopGuard = r, this.eBottomGuard = n, this.providedFocusInnerElement = s, this.eFocusableElement = f, this.focusTrapActive = !!i, this.forceFocusOutWhenTabGuardsAreEmpty = !!o, this.isFocusableContainer = !!a, this.providedFocusIn = l, this.providedFocusOut = u, this.providedShouldStopEventPropagation = c, this.providedOnTabKeyDown = d, this.providedHandleKeyDown = h;
  }
  wireBeans(e) {
    this.focusService = e.focusService;
  }
  postConstruct() {
    this.createManagedBean(
      new td(this.eFocusableElement, {
        shouldStopEventPropagation: () => this.shouldStopEventPropagation(),
        onTabKeyDown: (e) => this.onTabKeyDown(e),
        handleKeyDown: (e) => this.handleKeyDown(e),
        onFocusIn: (e) => this.onFocusIn(e),
        onFocusOut: (e) => this.onFocusOut(e)
      })
    ), this.activateTabGuards(), [this.eTopGuard, this.eBottomGuard].forEach(
      (e) => this.addManagedElementListeners(e, { focus: this.onFocus.bind(this) })
    );
  }
  handleKeyDown(e) {
    this.providedHandleKeyDown && this.providedHandleKeyDown(e);
  }
  tabGuardsAreActive() {
    return !!this.eTopGuard && this.eTopGuard.hasAttribute("tabIndex");
  }
  shouldStopEventPropagation() {
    return this.providedShouldStopEventPropagation ? this.providedShouldStopEventPropagation() : !1;
  }
  activateTabGuards() {
    if (this.forcingFocusOut)
      return;
    const e = this.gos.get("tabIndex");
    this.comp.setTabIndex(e.toString());
  }
  deactivateTabGuards() {
    this.comp.setTabIndex();
  }
  onFocus(e) {
    if (this.isFocusableContainer && !this.eFocusableElement.contains(e.relatedTarget) && !this.allowFocus) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.skipTabGuardFocus) {
      this.skipTabGuardFocus = !1;
      return;
    }
    if (this.forceFocusOutWhenTabGuardsAreEmpty && this.focusService.findFocusableElements(this.eFocusableElement, ".ag-tab-guard").length === 0) {
      this.findNextElementOutsideAndFocus(e.target === this.eBottomGuard);
      return;
    }
    if (this.isFocusableContainer && this.eFocusableElement.contains(e.relatedTarget))
      return;
    const t = e.target === this.eBottomGuard;
    this.providedFocusInnerElement ? this.providedFocusInnerElement(t) : this.focusInnerElement(t);
  }
  findNextElementOutsideAndFocus(e) {
    const t = this.gos.getDocument(), r = this.focusService.findFocusableElements(t.body, null, !0), n = r.indexOf(e ? this.eTopGuard : this.eBottomGuard);
    if (n === -1)
      return;
    let i, o;
    e ? (i = 0, o = n) : (i = n + 1, o = r.length);
    const a = r.slice(i, o), s = this.gos.get("tabIndex");
    a.sort((l, u) => {
      const c = parseInt(l.getAttribute("tabindex") || "0"), d = parseInt(u.getAttribute("tabindex") || "0");
      return d === s ? 1 : c === s ? -1 : c === 0 ? 1 : d === 0 ? -1 : c - d;
    }), a[e ? a.length - 1 : 0].focus();
  }
  onFocusIn(e) {
    this.focusTrapActive || this.forcingFocusOut || (this.providedFocusIn && this.providedFocusIn(e), this.isFocusableContainer || this.deactivateTabGuards());
  }
  onFocusOut(e) {
    this.focusTrapActive || (this.providedFocusOut && this.providedFocusOut(e), this.eFocusableElement.contains(e.relatedTarget) || this.activateTabGuards());
  }
  onTabKeyDown(e) {
    if (this.providedOnTabKeyDown) {
      this.providedOnTabKeyDown(e);
      return;
    }
    if (this.focusTrapActive || e.defaultPrevented)
      return;
    const t = this.tabGuardsAreActive();
    t && this.deactivateTabGuards();
    const r = this.getNextFocusableElement(e.shiftKey);
    t && setTimeout(() => this.activateTabGuards(), 0), r && (r.focus(), e.preventDefault());
  }
  focusInnerElement(e = !1) {
    const t = this.focusService.findFocusableElements(this.eFocusableElement);
    this.tabGuardsAreActive() && (t.splice(0, 1), t.splice(t.length - 1, 1)), t.length && t[e ? t.length - 1 : 0].focus({ preventScroll: !0 });
  }
  getNextFocusableElement(e) {
    return this.focusService.findNextFocusableElement(this.eFocusableElement, !1, e);
  }
  forceFocusOutOfContainer(e = !1) {
    if (this.forcingFocusOut)
      return;
    const t = e ? this.eTopGuard : this.eBottomGuard;
    this.activateTabGuards(), this.skipTabGuardFocus = !0, this.forcingFocusOut = !0, t.focus(), window.setTimeout(() => {
      this.forcingFocusOut = !1, this.activateTabGuards();
    });
  }
  isTabGuard(e, t) {
    return e === this.eTopGuard && !t || e === this.eBottomGuard && (t ?? !0);
  }
  setAllowFocus(e) {
    this.allowFocus = e;
  }
}, ZBe = class extends he {
  constructor(e) {
    super(), this.comp = e;
  }
  initialiseTabGuard(e) {
    this.eTopGuard = this.createTabGuard("top"), this.eBottomGuard = this.createTabGuard("bottom"), this.eFocusableElement = this.comp.getFocusableElement();
    const { eTopGuard: t, eBottomGuard: r, eFocusableElement: n } = this, i = [t, r], o = {
      setTabIndex: (g) => {
        i.forEach(
          (v) => g != null ? v.setAttribute("tabindex", g) : v.removeAttribute("tabindex")
        );
      }
    };
    this.addTabGuards(t, r);
    const {
      focusTrapActive: a = !1,
      onFocusIn: s,
      onFocusOut: l,
      focusInnerElement: u,
      handleKeyDown: c,
      onTabKeyDown: d,
      shouldStopEventPropagation: h,
      forceFocusOutWhenTabGuardsAreEmpty: f,
      isFocusableContainer: p
    } = e;
    this.tabGuardCtrl = this.createManagedBean(
      new vY({
        comp: o,
        focusTrapActive: a,
        eTopGuard: t,
        eBottomGuard: r,
        eFocusableElement: n,
        onFocusIn: s,
        onFocusOut: l,
        focusInnerElement: u,
        handleKeyDown: c,
        onTabKeyDown: d,
        shouldStopEventPropagation: h,
        forceFocusOutWhenTabGuardsAreEmpty: f,
        isFocusableContainer: p
      })
    );
  }
  getTabGuardCtrl() {
    return this.tabGuardCtrl;
  }
  createTabGuard(e) {
    const t = this.gos.getDocument().createElement("div"), r = e === "top" ? "ag-tab-guard-top" : "ag-tab-guard-bottom";
    return t.classList.add("ag-tab-guard", r), Sa(t, "presentation"), t;
  }
  addTabGuards(e, t) {
    this.eFocusableElement.insertAdjacentElement("afterbegin", e), this.eFocusableElement.insertAdjacentElement("beforeend", t);
  }
  removeAllChildrenExceptTabGuards() {
    const e = [this.eTopGuard, this.eBottomGuard];
    oo(this.comp.getFocusableElement()), this.addTabGuards(...e);
  }
  forceFocusOutOfContainer(e = !1) {
    this.tabGuardCtrl.forceFocusOutOfContainer(e);
  }
  appendChild(e, t, r) {
    EA(t) || (t = t.getGui());
    const { eBottomGuard: n } = this;
    n ? n.insertAdjacentElement("beforebegin", t) : e(t, r);
  }
}, XBe = class extends Nr {
  initialiseTabGuard(t) {
    this.tabGuardFeature = this.createManagedBean(new ZBe(this)), this.tabGuardFeature.initialiseTabGuard(t);
  }
  forceFocusOutOfContainer(t = !1) {
    this.tabGuardFeature.forceFocusOutOfContainer(t);
  }
  appendChild(t, r) {
    this.tabGuardFeature.appendChild(super.appendChild.bind(this), t, r);
  }
}, QBe = 0, JBe = 200, e4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "popupService", this.popupList = [];
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.resizeObserverService = e.resizeObserverService, this.environment = e.environment;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.gridCtrl = e.gridCtrl;
    }), this.addManagedEventListeners({ gridStylesChanged: this.handleThemeChange.bind(this) });
  }
  getPopupParent() {
    const e = this.gos.get("popupParent");
    return e || this.gridCtrl.getGui();
  }
  positionPopupForMenu(e) {
    const { eventSource: t, ePopup: r } = e, n = this.getPopupIndex(r);
    if (n !== -1) {
      const f = this.popupList[n];
      f.alignedToElement = t;
    }
    const i = t.getBoundingClientRect(), o = this.getParentRect(), a = this.keepXYWithinBounds(
      r,
      i.top - o.top,
      0
      /* vertical */
    ), s = r.clientWidth > 0 ? r.clientWidth : 200;
    r.style.minWidth = `${s}px`;
    const u = o.right - o.left - s;
    let c;
    this.gos.get("enableRtl") ? (c = h(), c < 0 && (c = d(), this.setAlignedStyles(r, "left")), c > u && (c = 0, this.setAlignedStyles(r, "right"))) : (c = d(), c > u && (c = h(), this.setAlignedStyles(r, "right")), c < 0 && (c = 0, this.setAlignedStyles(r, "left"))), r.style.left = `${c}px`, r.style.top = `${a}px`;
    function d() {
      return i.right - o.left - 2;
    }
    function h() {
      return i.left - o.left - s;
    }
  }
  positionPopupUnderMouseEvent(e) {
    const { ePopup: t, nudgeX: r, nudgeY: n, skipObserver: i } = e;
    this.positionPopup({
      ePopup: t,
      nudgeX: r,
      nudgeY: n,
      keepWithinBounds: !0,
      skipObserver: i,
      updatePosition: () => this.calculatePointerAlign(e.mouseEvent),
      postProcessCallback: () => this.callPostProcessPopup(
        e.type,
        e.ePopup,
        null,
        e.mouseEvent,
        e.column,
        e.rowNode
      )
    });
  }
  calculatePointerAlign(e) {
    const t = this.getParentRect();
    return {
      x: e.clientX - t.left,
      y: e.clientY - t.top
    };
  }
  positionPopupByComponent(e) {
    const {
      ePopup: t,
      nudgeX: r,
      nudgeY: n,
      keepWithinBounds: i,
      eventSource: o,
      alignSide: a = "left",
      position: s = "over",
      column: l,
      rowNode: u,
      type: c
    } = e, d = o.getBoundingClientRect(), h = this.getParentRect(), f = this.getPopupIndex(t);
    if (f !== -1) {
      const g = this.popupList[f];
      g.alignedToElement = o;
    }
    const p = () => {
      let g = d.left - h.left;
      a === "right" && (g -= t.offsetWidth - d.width);
      let v;
      return s === "over" ? (v = d.top - h.top, this.setAlignedStyles(t, "over")) : (this.setAlignedStyles(t, "under"), this.shouldRenderUnderOrAbove(t, d, h, e.nudgeY || 0) === "under" ? v = d.top - h.top + d.height : v = d.top - t.offsetHeight - (n || 0) * 2 - h.top), { x: g, y: v };
    };
    this.positionPopup({
      ePopup: t,
      nudgeX: r,
      nudgeY: n,
      keepWithinBounds: i,
      updatePosition: p,
      postProcessCallback: () => this.callPostProcessPopup(c, t, o, null, l, u)
    });
  }
  shouldRenderUnderOrAbove(e, t, r, n) {
    const i = r.bottom - t.bottom, o = t.top - r.top, a = e.offsetHeight + n;
    return i > a ? "under" : o > a || o > i ? "above" : "under";
  }
  setAlignedStyles(e, t) {
    const r = this.getPopupIndex(e);
    if (r === -1)
      return;
    const n = this.popupList[r], { alignedToElement: i } = n;
    !i || (["right", "left", "over", "above", "under"].forEach((a) => {
      i.classList.remove(`ag-has-popup-positioned-${a}`), e.classList.remove(`ag-popup-positioned-${a}`);
    }), !t) || (i.classList.add(`ag-has-popup-positioned-${t}`), e.classList.add(`ag-popup-positioned-${t}`));
  }
  callPostProcessPopup(e, t, r, n, i, o) {
    const a = this.gos.getCallback("postProcessPopup");
    a && a({
      column: i,
      rowNode: o,
      ePopup: t,
      type: e,
      eventSource: r,
      mouseEvent: n
    });
  }
  positionPopup(e) {
    const { ePopup: t, keepWithinBounds: r, nudgeX: n, nudgeY: i, skipObserver: o, updatePosition: a } = e, s = { width: 0, height: 0 }, l = (u = !1) => {
      let { x: c, y: d } = a();
      u && t.clientWidth === s.width && t.clientHeight === s.height || (s.width = t.clientWidth, s.height = t.clientHeight, n && (c += n), i && (d += i), r && (c = this.keepXYWithinBounds(
        t,
        c,
        1
        /* horizontal */
      ), d = this.keepXYWithinBounds(
        t,
        d,
        0
        /* vertical */
      )), t.style.left = `${c}px`, t.style.top = `${d}px`, e.postProcessCallback && e.postProcessCallback());
    };
    if (l(), !o) {
      const u = this.resizeObserverService.observeResize(
        t,
        () => l(!0)
      );
      setTimeout(() => u(), JBe);
    }
  }
  getActivePopups() {
    return this.popupList.map((e) => e.element);
  }
  getPopupList() {
    return this.popupList;
  }
  getParentRect() {
    const e = this.gos.getDocument();
    let t = this.getPopupParent();
    return t === e.body ? t = e.documentElement : getComputedStyle(t).position === "static" && (t = t.offsetParent), gK(t);
  }
  keepXYWithinBounds(e, t, r) {
    const n = r === 0, i = n ? "clientHeight" : "clientWidth", o = n ? "top" : "left", a = n ? "height" : "width", s = n ? "scrollTop" : "scrollLeft", l = this.gos.getDocument(), u = l.documentElement, c = this.getPopupParent(), d = e.getBoundingClientRect(), h = c.getBoundingClientRect(), f = l.documentElement.getBoundingClientRect(), p = c === l.body, g = Math.ceil(d[a]);
    let m = p ? (n ? pK : $C)(u) + u[s] : c[i];
    p && (m -= Math.abs(f[o] - h[o]));
    const y = m - g;
    return Math.min(Math.max(t, 0), Math.abs(y));
  }
  addPopup(e) {
    const t = this.gos.getDocument(), { eChild: r, ariaLabel: n, alwaysOnTop: i, positionCallback: o, anchorToElement: a } = e;
    if (!t)
      return Se("could not find the document, document is empty"), { hideFunc: () => {
      } };
    const s = this.getPopupIndex(r);
    if (s !== -1)
      return { hideFunc: this.popupList[s].hideFunc };
    this.initialisePopupPosition(r);
    const l = this.createPopupWrapper(r, n, !!i), u = this.addEventListenersToPopup({ ...e, wrapperEl: l });
    return o && o(), this.addPopupToPopupList(r, l, u, a), {
      hideFunc: u
    };
  }
  initialisePopupPosition(e) {
    const r = this.getPopupParent().getBoundingClientRect();
    Me(e.style.top) || (e.style.top = `${r.top * -1}px`), Me(e.style.left) || (e.style.left = `${r.left * -1}px`);
  }
  createPopupWrapper(e, t, r) {
    const n = this.getPopupParent(), i = document.createElement("div");
    return this.environment.applyThemeClasses(i), i.classList.add("ag-popup"), e.classList.add(this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr", "ag-popup-child"), e.hasAttribute("role") || Sa(e, "dialog"), $h(e, t), i.appendChild(e), n.appendChild(i), r ? this.setAlwaysOnTop(e, !0) : this.bringPopupToFront(e), i;
  }
  handleThemeChange(e) {
    if (e.themeChanged)
      for (const t of this.popupList)
        this.environment.applyThemeClasses(t.wrapper);
  }
  addEventListenersToPopup(e) {
    const t = this.gos.getDocument(), r = this.getPopupParent(), { wrapperEl: n, eChild: i, closedCallback: o, afterGuiAttached: a, closeOnEsc: s, modal: l } = e;
    let u = !1;
    const c = (p) => {
      if (!n.contains(this.gos.getActiveDomElement()))
        return;
      p.key === ae.ESCAPE && !Vl(p) && f({ keyboardEvent: p });
    }, d = (p) => f({ mouseEvent: p }), h = (p) => f({ touchEvent: p }), f = (p = {}) => {
      const { mouseEvent: g, touchEvent: v, keyboardEvent: m, forceHide: y } = p;
      !y && // we don't hide popup if the event was on the child, or any
      // children of this child
      (this.isEventFromCurrentPopup({ mouseEvent: g, touchEvent: v }, i) || // this method should only be called once. the client can have different
      // paths, each one wanting to close, so this method may be called multiple times.
      u) || (u = !0, r.removeChild(n), t.removeEventListener("keydown", c), t.removeEventListener("mousedown", d), t.removeEventListener("touchstart", h), t.removeEventListener("contextmenu", d), this.eventService.removeEventListener("dragStarted", d), o && o(g || v || m), this.removePopupFromPopupList(i));
    };
    return a && a({ hidePopup: f }), window.setTimeout(() => {
      s && t.addEventListener("keydown", c), l && (t.addEventListener("mousedown", d), this.eventService.addEventListener("dragStarted", d), t.addEventListener("touchstart", h), t.addEventListener("contextmenu", d));
    }, 0), f;
  }
  addPopupToPopupList(e, t, r, n) {
    this.popupList.push({
      element: e,
      wrapper: t,
      hideFunc: r,
      instanceId: QBe++,
      isAnchored: !!n
    }), n && this.setPopupPositionRelatedToElement(e, n);
  }
  getPopupIndex(e) {
    return this.popupList.findIndex((t) => t.element === e);
  }
  setPopupPositionRelatedToElement(e, t) {
    const r = this.getPopupIndex(e);
    if (r === -1)
      return;
    const n = this.popupList[r];
    if (n.stopAnchoringPromise && n.stopAnchoringPromise.then((o) => o && o()), n.stopAnchoringPromise = void 0, n.isAnchored = !1, !t)
      return;
    const i = this.keepPopupPositionedRelativeTo({
      element: t,
      ePopup: e,
      hidePopup: n.hideFunc
    });
    return n.stopAnchoringPromise = i, n.isAnchored = !0, i;
  }
  removePopupFromPopupList(e) {
    this.setAlignedStyles(e, null), this.setPopupPositionRelatedToElement(e, null), this.popupList = this.popupList.filter((t) => t.element !== e);
  }
  keepPopupPositionedRelativeTo(e) {
    const t = this.getPopupParent(), r = t.getBoundingClientRect(), { element: n, ePopup: i } = e, o = n.getBoundingClientRect(), a = r.top - o.top, s = r.left - o.left;
    let l = a, u = s;
    const c = i.style.top, d = parseInt(c.substring(0, c.length - 1), 10), h = i.style.left, f = parseInt(h.substring(0, h.length - 1), 10), p = this.getFrameworkOverrides();
    return new en((g) => {
      p.wrapIncoming(() => {
        p.setInterval(() => {
          const v = t.getBoundingClientRect(), m = n.getBoundingClientRect();
          if (m.top == 0 && m.left == 0 && m.height == 0 && m.width == 0) {
            e.hidePopup();
            return;
          }
          const C = v.top - m.top;
          if (C != l) {
            const b = this.keepXYWithinBounds(
              i,
              d + a - C,
              0
              /* vertical */
            );
            i.style.top = `${b}px`;
          }
          l = C;
          const S = v.left - m.left;
          if (S != u) {
            const b = this.keepXYWithinBounds(
              i,
              f + s - S,
              1
              /* horizontal */
            );
            i.style.left = `${b}px`;
          }
          u = S;
        }, 200).then((v) => {
          g(() => {
            v != null && window.clearInterval(v);
          });
        });
      }, "popupPositioning");
    });
  }
  hasAnchoredPopup() {
    return this.popupList.some((e) => e.isAnchored);
  }
  isEventFromCurrentPopup(e, t) {
    const { mouseEvent: r, touchEvent: n } = e, i = r || n;
    if (!i)
      return !1;
    const o = this.getPopupIndex(t);
    if (o === -1)
      return !1;
    for (let a = o; a < this.popupList.length; a++) {
      const s = this.popupList[a];
      if (MLe(s.element, i))
        return !0;
    }
    return this.isElementWithinCustomPopup(i.target);
  }
  isElementWithinCustomPopup(e) {
    const t = this.gos.getDocument();
    for (; e && e !== t.body; ) {
      if (e.classList.contains("ag-custom-component-popup") || e.parentElement === null)
        return !0;
      e = e.parentElement;
    }
    return !1;
  }
  getWrapper(e) {
    for (; !e.classList.contains("ag-popup") && e.parentElement; )
      e = e.parentElement;
    return e.classList.contains("ag-popup") ? e : null;
  }
  setAlwaysOnTop(e, t) {
    const r = this.getWrapper(e);
    r && (r.classList.toggle("ag-always-on-top", !!t), t && this.bringPopupToFront(r));
  }
  /** @return true if moved */
  bringPopupToFront(e) {
    const t = this.getPopupParent(), r = Array.prototype.slice.call(t.querySelectorAll(".ag-popup")), n = r.length, i = Array.prototype.slice.call(
      t.querySelectorAll(".ag-popup.ag-always-on-top")
    ), o = i.length, a = this.getWrapper(e);
    if (!a || n <= 1 || !t.contains(e))
      return !1;
    const s = r.indexOf(a), l = a.querySelectorAll("div"), u = [];
    l.forEach((d) => {
      d.scrollTop !== 0 && u.push([d, d.scrollTop]);
    });
    let c = !1;
    for (o ? a.classList.contains("ag-always-on-top") ? s !== n - 1 && (Jt(i).insertAdjacentElement("afterend", a), c = !0) : s !== n - o - 1 && (i[0].insertAdjacentElement("beforebegin", a), c = !0) : s !== n - 1 && (Jt(r).insertAdjacentElement("afterend", a), c = !0); u.length; ) {
      const d = u.pop();
      d[0].scrollTop = d[1];
    }
    return c;
  }
}, t4e = ["touchstart", "touchend", "touchmove", "touchcancel"], mY = class {
  constructor(e = "javascript") {
    this.frameworkName = e, this.renderingEngine = "vanilla", this.wrapIncoming = (t) => t(), this.wrapOutgoing = (t) => t();
  }
  setInterval(e, t) {
    return new en((r) => {
      r(window.setInterval(e, t));
    });
  }
  // for Vanilla JS, we just add the event to the element
  addEventListener(e, t, r, n) {
    const i = Cc(t4e, t);
    e.addEventListener(t, r, { capture: !!n, passive: i });
  }
  get shouldWrapOutgoing() {
    return !1;
  }
  frameworkComponent(e) {
    return null;
  }
  isFrameworkComponent(e) {
    return !1;
  }
  getDocLink(e) {
    return `https://www.ag-grid.com/${this.frameworkName === "solid" ? "react" : this.frameworkName}-data-grid${e ? `/${e}` : ""}`;
  }
}, r4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "cellNavigationService";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer, this.pinnedRowModel = e.pinnedRowModel, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService;
  }
  // returns null if no cell to focus on, ie at the end of the grid
  getNextCellToFocus(e, t, r = !1) {
    return r ? this.getNextCellToFocusWithCtrlPressed(e, t) : this.getNextCellToFocusWithoutCtrlPressed(e, t);
  }
  getNextCellToFocusWithCtrlPressed(e, t) {
    const r = e === ae.UP, n = e === ae.DOWN, i = e === ae.LEFT;
    let o, a;
    if (r || n)
      a = r ? this.pageBoundsService.getFirstRow() : this.pageBoundsService.getLastRow(), o = t.column;
    else {
      const s = this.visibleColsService.getAllCols(), l = this.gos.get("enableRtl");
      a = t.rowIndex, o = i !== l ? s[0] : Jt(s);
    }
    return {
      rowIndex: a,
      rowPinned: null,
      column: o
    };
  }
  getNextCellToFocusWithoutCtrlPressed(e, t) {
    let r = t, n = !1;
    for (; !n; ) {
      switch (e) {
        case ae.UP:
          r = this.getCellAbove(r);
          break;
        case ae.DOWN:
          r = this.getCellBelow(r);
          break;
        case ae.RIGHT:
          this.gos.get("enableRtl") ? r = this.getCellToLeft(r) : r = this.getCellToRight(r);
          break;
        case ae.LEFT:
          this.gos.get("enableRtl") ? r = this.getCellToRight(r) : r = this.getCellToLeft(r);
          break;
        default:
          r = null, Se("unknown key for navigation ", e);
          break;
      }
      r ? n = this.isCellGoodToFocusOn(r) : n = !0;
    }
    return r;
  }
  isCellGoodToFocusOn(e) {
    const t = e.column;
    let r;
    switch (e.rowPinned) {
      case "top":
        r = this.pinnedRowModel.getPinnedTopRow(e.rowIndex);
        break;
      case "bottom":
        r = this.pinnedRowModel.getPinnedBottomRow(e.rowIndex);
        break;
      default:
        r = this.rowModel.getRow(e.rowIndex);
        break;
    }
    return r ? !t.isSuppressNavigable(r) : !1;
  }
  getCellToLeft(e) {
    if (!e)
      return null;
    const t = this.visibleColsService.getColBefore(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getCellToRight(e) {
    if (!e)
      return null;
    const t = this.visibleColsService.getColAfter(e.column);
    return t ? {
      rowIndex: e.rowIndex,
      column: t,
      rowPinned: e.rowPinned
    } : null;
  }
  getRowBelow(e) {
    const t = e.rowIndex, r = e.rowPinned;
    if (this.isLastRowInContainer(e))
      switch (r) {
        case "bottom":
          return null;
        case "top":
          return this.rowModel.isRowsToRender() ? { rowIndex: this.pageBoundsService.getFirstRow(), rowPinned: null } : this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
        default:
          return this.pinnedRowModel.isRowsToRender("bottom") ? { rowIndex: 0, rowPinned: "bottom" } : null;
      }
    const n = this.rowModel.getRow(e.rowIndex), i = this.getNextStickyPosition(n);
    return i || { rowIndex: t + 1, rowPinned: r };
  }
  getNextStickyPosition(e, t) {
    if (!this.gos.isGroupRowsSticky() || !e || !e.sticky)
      return;
    const r = this.rowRenderer.getStickyTopRowCtrls().some((s) => s.getRowNode().rowIndex === e.rowIndex);
    let n = [];
    r ? n = [...this.rowRenderer.getStickyTopRowCtrls()].sort(
      (s, l) => s.getRowNode().rowIndex - l.getRowNode().rowIndex
    ) : n = [...this.rowRenderer.getStickyBottomRowCtrls()].sort(
      (s, l) => l.getRowNode().rowIndex - s.getRowNode().rowIndex
    );
    const i = t ? -1 : 1, o = n.findIndex((s) => s.getRowNode().rowIndex === e.rowIndex), a = n[o + i];
    if (a)
      return { rowIndex: a.getRowNode().rowIndex, rowPinned: null };
  }
  getCellBelow(e) {
    if (!e)
      return null;
    const t = this.getRowBelow(e);
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  isLastRowInContainer(e) {
    const t = e.rowPinned, r = e.rowIndex;
    return t === "top" ? this.pinnedRowModel.getPinnedTopRowNodes().length - 1 <= r : t === "bottom" ? this.pinnedRowModel.getPinnedBottomRowNodes().length - 1 <= r : this.pageBoundsService.getLastRow() <= r;
  }
  getRowAbove(e) {
    const t = e.rowIndex, r = e.rowPinned;
    if (r ? t === 0 : t === this.pageBoundsService.getFirstRow())
      return r === "top" ? null : r ? this.rowModel.isRowsToRender() ? this.getLastBodyCell() : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null : this.pinnedRowModel.isRowsToRender("top") ? this.getLastFloatingTopRow() : null;
    const i = this.rowModel.getRow(e.rowIndex), o = this.getNextStickyPosition(i, !0);
    return o || { rowIndex: t - 1, rowPinned: r };
  }
  getCellAbove(e) {
    if (!e)
      return null;
    const t = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
    return t ? {
      rowIndex: t.rowIndex,
      column: e.column,
      rowPinned: t.rowPinned
    } : null;
  }
  getLastBodyCell() {
    return { rowIndex: this.pageBoundsService.getLastRow(), rowPinned: null };
  }
  getLastFloatingTopRow() {
    return { rowIndex: this.pinnedRowModel.getPinnedTopRowNodes().length - 1, rowPinned: "top" };
  }
  getNextTabbedCell(e, t) {
    return t ? this.getNextTabbedCellBackwards(e) : this.getNextTabbedCellForwards(e);
  }
  getNextTabbedCellForwards(e) {
    var o;
    const t = this.visibleColsService.getAllCols();
    let r = e.rowIndex, n = e.rowPinned, i = this.visibleColsService.getColAfter(e.column);
    if (!i) {
      i = t[0];
      const a = this.getRowBelow(e);
      if (Zt(a) || !a.rowPinned && !(((o = this.paginationService) == null ? void 0 : o.isRowInPage(a)) ?? !0))
        return null;
      r = a ? a.rowIndex : null, n = a ? a.rowPinned : null;
    }
    return { rowIndex: r, column: i, rowPinned: n };
  }
  getNextTabbedCellBackwards(e) {
    var o;
    const t = this.visibleColsService.getAllCols();
    let r = e.rowIndex, n = e.rowPinned, i = this.visibleColsService.getColBefore(e.column);
    if (!i) {
      i = Jt(t);
      const a = this.getRowAbove({ rowIndex: e.rowIndex, rowPinned: e.rowPinned });
      if (Zt(a) || !a.rowPinned && !(((o = this.paginationService) == null ? void 0 : o.isRowInPage(a)) ?? !0))
        return null;
      r = a ? a.rowIndex : null, n = a ? a.rowPinned : null;
    }
    return { rowIndex: r, column: i, rowPinned: n };
  }
};
function n4e(e, t) {
  e.eventService.dispatchEvent(t);
}
var i4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "apiFunctionService", this.functions = {
      // this is used by frameworks
      // also used by aligned grids to identify a grid api instance
      dispatchEvent: n4e
    }, this.isDestroyed = !1;
  }
  wireBeans(e) {
    this.beans = e;
  }
  postConstruct() {
    this.preDestroyLink = this.frameworkOverrides.getDocLink("grid-lifecycle/#grid-pre-destroyed");
  }
  callFunction(e, t) {
    var n;
    const r = this.functions[e];
    if (r)
      return r.apply(r, [this.beans, ...t]);
    if (this.isDestroyed)
      return this.destroyedHandler(e);
    this.isFrameworkMethod(e) || (n = this.beans.validationService) == null || n.warnMissingApiFunction(e);
  }
  addFunction(e, t) {
    const { validationService: r } = this.beans;
    r && (t = r.validateApiFunction(e, t)), this.functions[e] = t;
  }
  destroy() {
    this.functions = {}, this.isDestroyed = !0, super.destroy();
  }
  destroyedHandler(e) {
    if (e === "isDestroyed")
      return !0;
    e !== "destroy" && Se(
      `Grid API function ${e}() cannot be called as the grid has been destroyed.
Either clear local references to the grid api, when it is destroyed, or check gridApi.isDestroyed() to avoid calling methods against a destroyed grid.
To run logic when the grid is about to be destroyed use the gridPreDestroy event. See: ${this.preDestroyLink}`
    );
  }
  isFrameworkMethod(e) {
    return ["preWireBeans", "wireBeans", "preConstruct", "postConstruct"].includes(e);
  }
};
function o4e(e) {
  const t = e.getBean("apiFunctionService");
  return new Proxy(t, {
    get(r, n) {
      if (n !== "then")
        return (...i) => r.callFunction(n, i);
    }
  });
}
function a4e(e) {
  return {
    beanName: "gridApi",
    bean: o4e(e)
  };
}
var s4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnDefFactory";
  }
  buildColumnDefs(e, t, r) {
    const n = [], i = {};
    return e.forEach((o) => {
      const a = this.createDefFromColumn(o, t, r);
      let s = !0, l = a, u = o.getOriginalParent(), c = null;
      for (; u; ) {
        let d = null;
        if (u.isPadding()) {
          u = u.getOriginalParent();
          continue;
        }
        const h = i[u.getGroupId()];
        if (h) {
          h.children.push(l), s = !1;
          break;
        }
        if (d = this.createDefFromGroup(u), d && (d.children = [l], i[d.groupId] = d, l = d, u = u.getOriginalParent()), u != null && c === u) {
          s = !1;
          break;
        }
        c = u;
      }
      s && n.push(l);
    }), n;
  }
  createDefFromGroup(e) {
    const t = bT(e.getColGroupDef(), ["children"]);
    return t && (t.groupId = e.getGroupId()), t;
  }
  createDefFromColumn(e, t, r) {
    const n = bT(e.getColDef());
    return n.colId = e.getColId(), n.width = e.getActualWidth(), n.rowGroup = e.isRowGroupActive(), n.rowGroupIndex = e.isRowGroupActive() ? t.indexOf(e) : null, n.pivot = e.isPivotActive(), n.pivotIndex = e.isPivotActive() ? r.indexOf(e) : null, n.aggFunc = e.isValueActive() ? e.getAggFunc() : null, n.hide = e.isVisible() ? void 0 : !0, n.pinned = e.isPinned() ? e.getPinned() : null, n.sort = e.getSort() ? e.getSort() : null, n.sortIndex = e.getSortIndex() != null ? e.getSortIndex() : null, n;
  }
}, l4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnEventDispatcher";
  }
  visibleCols() {
    const e = {
      type: "displayedColumnsChanged"
    };
    this.eventService.dispatchEvent(e);
  }
  gridColumns() {
    const e = {
      type: "gridColumnsChanged"
    };
    this.eventService.dispatchEvent(e);
  }
  headerHeight(e) {
    const t = {
      type: "columnHeaderHeightChanged",
      column: e,
      columns: [e],
      source: "autosizeColumnHeaderHeight"
    };
    this.eventService.dispatchEvent(t);
  }
  groupOpened(e) {
    const t = {
      type: "columnGroupOpened",
      columnGroup: e.length === 1 ? e[0] : void 0,
      columnGroups: e
    };
    this.eventService.dispatchEvent(t);
  }
  rowGroupChanged(e, t) {
    const r = {
      type: "columnRowGroupChanged",
      columns: e,
      column: e.length === 1 ? e[0] : null,
      source: t
    };
    this.eventService.dispatchEvent(r);
  }
  genericColumnEvent(e, t, r) {
    const n = {
      type: e,
      columns: t,
      column: t.length === 1 ? t[0] : null,
      source: r
    };
    this.eventService.dispatchEvent(n);
  }
  pivotModeChanged() {
    const e = {
      type: "columnPivotModeChanged"
    };
    this.eventService.dispatchEvent(e);
  }
  virtualColumnsChanged(e) {
    const t = {
      type: "virtualColumnsChanged",
      afterScroll: e
    };
    this.eventService.dispatchEvent(t);
  }
  newColumnsLoaded(e) {
    const t = {
      type: "newColumnsLoaded",
      source: e
    };
    this.eventService.dispatchEvent(t);
  }
  everythingChanged(e) {
    const t = {
      type: "columnEverythingChanged",
      source: e
    };
    this.eventService.dispatchEvent(t);
  }
  columnMoved(e) {
    const { movedColumns: t, source: r, toIndex: n, finished: i } = e, o = {
      type: "columnMoved",
      columns: t,
      column: t && t.length === 1 ? t[0] : null,
      toIndex: n,
      finished: i,
      source: r
    };
    this.eventService.dispatchEvent(o);
  }
  columnPinned(e, t) {
    if (!e.length)
      return;
    const r = e.length === 1 ? e[0] : null, n = this.getCommonValue(e, (o) => o.getPinned()), i = {
      type: "columnPinned",
      // mistake in typing, 'undefined' should be allowed, as 'null' means 'not pinned'
      pinned: n ?? null,
      columns: e,
      column: r,
      source: t
    };
    this.eventService.dispatchEvent(i);
  }
  columnVisible(e, t) {
    if (!e.length)
      return;
    const r = e.length === 1 ? e[0] : null, i = {
      type: "columnVisible",
      visible: this.getCommonValue(e, (o) => o.isVisible()),
      columns: e,
      column: r,
      source: t
    };
    this.eventService.dispatchEvent(i);
  }
  getCommonValue(e, t) {
    if (!e || e.length == 0)
      return;
    const r = t(e[0]);
    for (let n = 1; n < e.length; n++)
      if (r !== t(e[n]))
        return;
    return r;
  }
  columnChanged(e, t, r) {
    const n = {
      type: e,
      columns: t,
      column: t && t.length == 1 ? t[0] : null,
      source: r
    };
    this.eventService.dispatchEvent(n);
  }
  columnResized(e, t, r, n = null) {
    if (e && e.length) {
      const i = {
        type: "columnResized",
        columns: e,
        column: e.length === 1 ? e[0] : null,
        flexColumns: n,
        finished: t,
        source: r
      };
      this.eventService.dispatchEvent(i);
    }
  }
}, u4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnGetStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService;
  }
  getColumnState() {
    const e = this.columnModel.getColDefCols();
    if (Zt(e) || !this.columnModel.isAlive())
      return [];
    const r = this.columnModel.getAllCols().map(this.createStateItemFromColumn.bind(this));
    return this.orderColumnStateList(r), r;
  }
  createStateItemFromColumn(e) {
    const t = this.funcColsService.getRowGroupColumns(), r = this.funcColsService.getPivotColumns(), n = e.isRowGroupActive() ? t.indexOf(e) : null, i = e.isPivotActive() ? r.indexOf(e) : null, o = e.isValueActive() ? e.getAggFunc() : null, a = e.getSort() != null ? e.getSort() : null, s = e.getSortIndex() != null ? e.getSortIndex() : null, l = e.getFlex() != null && e.getFlex() > 0 ? e.getFlex() : null;
    return {
      colId: e.getColId(),
      width: e.getActualWidth(),
      hide: !e.isVisible(),
      pinned: e.getPinned(),
      sort: a,
      sortIndex: s,
      aggFunc: o,
      rowGroup: e.isRowGroupActive(),
      rowGroupIndex: n,
      pivot: e.isPivotActive(),
      pivotIndex: i,
      flex: l
    };
  }
  orderColumnStateList(e) {
    const t = this.columnModel.getCols(), r = new Map(t.map((n, i) => [n.getColId(), i]));
    e.sort((n, i) => {
      const o = r.has(n.colId) ? r.get(n.colId) : -1, a = r.has(i.colId) ? r.get(i.colId) : -1;
      return o - a;
    });
  }
}, c4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnGroupStateService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnAnimationService = e.columnAnimationService, this.eventDispatcher = e.columnEventDispatcher, this.visibleColsService = e.visibleColsService;
  }
  getColumnGroupState() {
    const e = [], t = this.columnModel.getColTree();
    return qs(null, t, (r) => {
      pi(r) && e.push({
        groupId: r.getGroupId(),
        open: r.isExpanded()
      });
    }), e;
  }
  resetColumnGroupState(e) {
    const t = this.columnModel.getColDefColTree();
    if (!t)
      return;
    const r = [];
    qs(null, t, (n) => {
      if (pi(n)) {
        const i = n.getColGroupDef(), o = {
          groupId: n.getGroupId(),
          open: i ? i.openByDefault : void 0
        };
        r.push(o);
      }
    }), this.setColumnGroupState(r, e);
  }
  setColumnGroupState(e, t) {
    if (!this.columnModel.getColTree())
      return;
    this.columnAnimationService.start();
    const n = [];
    e.forEach((i) => {
      const o = i.groupId, a = i.open, s = this.columnModel.getProvidedColGroup(o);
      s && s.isExpanded() !== a && (s.setExpanded(a), n.push(s));
    }), this.visibleColsService.refresh(t, !0), n.length && this.eventDispatcher.groupOpened(n), this.columnAnimationService.finish();
  }
}, d4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnViewportService", this.colsWithinViewport = [], this.headerColsWithinViewport = [], this.colsWithinViewportHash = "", this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.columnModel = e.columnModel, this.eventDispatcher = e.columnEventDispatcher;
  }
  postConstruct() {
    this.suppressColumnVirtualisation = this.gos.get("suppressColumnVirtualisation");
  }
  setScrollPosition(e, t, r = !1) {
    const n = this.visibleColsService.isBodyWidthDirty();
    if (!(e === this.scrollWidth && t === this.scrollPosition && !n)) {
      if (this.scrollWidth = e, this.scrollPosition = t, this.visibleColsService.setBodyWidthDirty(), this.gos.get("enableRtl")) {
        const o = this.visibleColsService.getBodyContainerWidth();
        this.viewportLeft = o - this.scrollPosition - this.scrollWidth, this.viewportRight = o - this.scrollPosition;
      } else
        this.viewportLeft = this.scrollPosition, this.viewportRight = this.scrollWidth + this.scrollPosition;
      this.columnModel.isReady() && this.checkViewportColumns(r);
    }
  }
  getHeadersToRender(e, t) {
    let r;
    switch (e) {
      case "left":
        r = this.rowsOfHeadersToRenderLeft[t];
        break;
      case "right":
        r = this.rowsOfHeadersToRenderRight[t];
        break;
      default:
        r = this.rowsOfHeadersToRenderCenter[t];
        break;
    }
    return r || [];
  }
  extractViewportColumns() {
    const e = this.visibleColsService.getCenterCols();
    this.isColumnVirtualisationSuppressed() ? (this.colsWithinViewport = e, this.headerColsWithinViewport = e) : (this.colsWithinViewport = e.filter(this.isColumnInRowViewport.bind(this)), this.headerColsWithinViewport = e.filter(this.isColumnInHeaderViewport.bind(this)));
  }
  isColumnVirtualisationSuppressed() {
    return this.suppressColumnVirtualisation || this.viewportRight === 0;
  }
  clear() {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {}, this.colsWithinViewportHash = "";
  }
  isColumnInHeaderViewport(e) {
    return e.isAutoHeaderHeight() ? !0 : this.isColumnInRowViewport(e);
  }
  isColumnInRowViewport(e) {
    if (e.isAutoHeight())
      return !0;
    const t = e.getLeft() || 0, r = t + e.getActualWidth(), n = this.viewportLeft - 200, i = this.viewportRight + 200, o = t < n && r < n, a = t > i && r > i;
    return !o && !a;
  }
  // used by Grid API only
  getViewportColumns() {
    const e = this.visibleColsService.getLeftCols(), t = this.visibleColsService.getRightCols();
    return this.colsWithinViewport.concat(e).concat(t);
  }
  // + rowRenderer
  // if we are not column spanning, this just returns back the virtual centre columns,
  // however if we are column spanning, then different rows can have different virtual
  // columns, so we have to work out the list for each individual row.
  getColsWithinViewport(e) {
    if (!this.columnModel.isColSpanActive())
      return this.colsWithinViewport;
    const t = (i) => {
      const o = i.getLeft();
      return Me(o) && o > this.viewportLeft;
    }, r = this.isColumnVirtualisationSuppressed() ? null : this.isColumnInRowViewport.bind(this), n = this.visibleColsService.getColsCenter();
    return this.visibleColsService.getColsForRow(
      e,
      n,
      r,
      t
    );
  }
  // checks what columns are currently displayed due to column virtualisation. dispatches an event
  // if the list of columns has changed.
  // + setColumnWidth(), setViewportPosition(), setColumnDefs(), sizeColumnsToFit()
  checkViewportColumns(e = !1) {
    this.extractViewport() && this.eventDispatcher.virtualColumnsChanged(e);
  }
  calculateHeaderRows() {
    this.rowsOfHeadersToRenderLeft = {}, this.rowsOfHeadersToRenderRight = {}, this.rowsOfHeadersToRenderCenter = {};
    const e = {}, t = this.visibleColsService.getLeftCols(), r = this.visibleColsService.getRightCols();
    this.headerColsWithinViewport.concat(t).concat(r).forEach((o) => e[o.getId()] = !0);
    const i = (o, a, s) => {
      let l = !1;
      for (let u = 0; u < o.length; u++) {
        const c = o[u];
        let d = !1;
        if (Zl(c))
          d = e[c.getId()] === !0;
        else {
          const f = c.getDisplayedChildren();
          f && (d = i(f, a, s + 1));
        }
        d && (l = !0, a[s] || (a[s] = []), a[s].push(c));
      }
      return l;
    };
    i(this.visibleColsService.getTreeLeft(), this.rowsOfHeadersToRenderLeft, 0), i(this.visibleColsService.getTreeRight(), this.rowsOfHeadersToRenderRight, 0), i(this.visibleColsService.getTreeCenter(), this.rowsOfHeadersToRenderCenter, 0);
  }
  extractViewport() {
    const e = (n) => `${n.getId()}-${n.getPinned() || "normal"}`;
    this.extractViewportColumns();
    const t = this.getViewportColumns().map(e).join("#"), r = this.colsWithinViewportHash !== t;
    return r && (this.colsWithinViewportHash = t, this.calculateHeaderRows()), r;
  }
}, h4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "agComponentUtils";
  }
  wireBeans(e) {
    this.componentMetadataProvider = e.componentMetadataProvider;
  }
  adaptFunction(e, t) {
    const r = this.componentMetadataProvider.retrieve(e);
    return r && r.functionAdapter ? r.functionAdapter(t) : null;
  }
  adaptCellRendererFunction(e) {
    class t {
      refresh() {
        return !1;
      }
      getGui() {
        return this.eGui;
      }
      init(n) {
        const i = e(n), o = typeof i;
        if (o === "string" || o === "number" || o === "boolean") {
          this.eGui = Wh("<span>" + i + "</span>");
          return;
        }
        if (i == null) {
          this.eGui = Wh("<span></span>");
          return;
        }
        this.eGui = i;
      }
    }
    return t;
  }
  doesImplementIComponent(e) {
    return e ? e.prototype && "getGui" in e.prototype : !1;
  }
}, f4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "componentMetadataProvider";
  }
  wireBeans(e) {
    this.agComponentUtils = e.agComponentUtils;
  }
  postConstruct() {
    this.componentMetaData = {
      dateComponent: {
        mandatoryMethodList: ["getDate", "setDate"],
        optionalMethodList: [
          "afterGuiAttached",
          "setInputPlaceholder",
          "setInputAriaLabel",
          "setDisabled",
          "onParamsUpdated",
          "refresh"
        ]
      },
      detailCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      headerComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      headerGroupComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      loadingCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: [],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      loadingOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      noRowsOverlayComponent: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      floatingFilterComponent: {
        mandatoryMethodList: ["onParentModelChanged"],
        optionalMethodList: ["afterGuiAttached", "onParamsUpdated", "refresh"]
      },
      cellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      cellEditor: {
        mandatoryMethodList: ["getValue"],
        optionalMethodList: [
          "isPopup",
          "isCancelBeforeStart",
          "isCancelAfterEnd",
          "getPopupPosition",
          "focusIn",
          "focusOut",
          "afterGuiAttached",
          "refresh"
        ]
      },
      innerRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      fullWidthCellRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      groupRowRenderer: {
        mandatoryMethodList: [],
        optionalMethodList: ["afterGuiAttached"],
        functionAdapter: this.agComponentUtils.adaptCellRendererFunction.bind(this.agComponentUtils)
      },
      filter: {
        mandatoryMethodList: ["isFilterActive", "doesFilterPass", "getModel", "setModel"],
        optionalMethodList: [
          "afterGuiAttached",
          "afterGuiDetached",
          "onNewRowsLoaded",
          "getModelAsString",
          "onFloatingFilterChanged",
          "onAnyFilterChanged",
          "refresh"
        ]
      },
      statusPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh"]
      },
      toolPanel: {
        mandatoryMethodList: [],
        optionalMethodList: ["refresh", "getState"]
      },
      tooltipComponent: {
        mandatoryMethodList: [],
        optionalMethodList: []
      },
      menuItem: {
        mandatoryMethodList: [],
        optionalMethodList: ["setActive", "select", "setExpanded", "configureDefaults"]
      }
    };
  }
  retrieve(e) {
    return this.componentMetaData[e];
  }
}, p4e = [
  // core beans only
  "rowPositionUtils",
  "cellPositionUtils",
  "headerPositionUtils",
  "paginationAutoPageSizeService",
  "apiFunctionService",
  "gridApi",
  "userComponentRegistry",
  "agComponentUtils",
  "componentMetadataProvider",
  "resizeObserverService",
  "userComponentFactory",
  "rowContainerHeightService",
  "horizontalResizeService",
  "localeService",
  "validationService",
  "pinnedRowModel",
  "dragService",
  "visibleColsService",
  "eventService",
  "gos",
  "popupService",
  "selectionService",
  "columnFilterService",
  "quickFilterService",
  "filterManager",
  "columnModel",
  "headerNavigationService",
  "pageBoundsService",
  "paginationService",
  "pageBoundsListener",
  "rowRenderer",
  "expressionService",
  "columnFactory",
  "alignedGridsService",
  "navigationService",
  "valueCache",
  "valueService",
  "loggerFactory",
  "autoWidthCalculator",
  "filterMenuFactory",
  "dragAndDropService",
  "focusService",
  "mouseEventService",
  "environment",
  "cellNavigationService",
  "stylingService",
  "scrollVisibleService",
  "sortController",
  "columnHoverService",
  "columnAnimationService",
  "selectableService",
  "autoColService",
  "changeDetectionService",
  "animationFrameService",
  "undoRedoService",
  "columnDefFactory",
  "rowCssClassCalculator",
  "rowNodeBlockLoader",
  "rowNodeSorter",
  "ctrlsService",
  "pinnedWidthService",
  "rowNodeEventThrottle",
  "ctrlsFactory",
  "dataTypeService",
  "syncService",
  "overlayService",
  "stateService",
  "expansionService",
  "apiEventService",
  "ariaAnnouncementService",
  "menuService",
  "columnApplyStateService",
  "columnEventDispatcher",
  "columnMoveService",
  "columnAutosizeService",
  "columnGetStateService",
  "columnGroupStateService",
  "columnSizeService",
  "funcColsService",
  "columnNameService",
  "columnViewportService",
  "pivotResultColsService",
  "showRowGroupColsService"
], VG = Object.fromEntries(
  p4e.map((e, t) => [e, t])
);
function g4e(e, t) {
  const r = (e.beanName ? VG[e.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER, n = (t.beanName ? VG[t.beanName] : void 0) ?? Number.MAX_SAFE_INTEGER;
  return r - n;
}
function v4e(e, t) {
  return (e == null ? void 0 : e.beanName) === "gridDestroyService" ? -1 : 0;
}
var m4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "ctrlsFactory", this.registry = {};
  }
  register(e) {
    this.registry[e.name] = e.classImp;
  }
  getInstance(e, ...t) {
    const r = this.registry[e];
    if (r != null)
      return new r(...t);
  }
}, y4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "ctrlsService", this.params = {}, this.ready = !1, this.readyCallbacks = [];
  }
  checkReady() {
    const e = this.params;
    this.ready = e.gridCtrl != null && e.gridBodyCtrl != null && e.center != null && e.left != null && e.right != null && e.bottomCenter != null && e.bottomLeft != null && e.bottomRight != null && e.topCenter != null && e.topLeft != null && e.topRight != null && e.stickyTopCenter != null && e.stickyTopLeft != null && e.stickyTopRight != null && e.stickyBottomCenter != null && e.stickyBottomLeft != null && e.stickyBottomRight != null && e.centerHeader != null && e.leftHeader != null && e.rightHeader != null && e.fakeHScrollComp != null && e.fakeVScrollComp != null && e.gridHeaderCtrl != null, this.ready && (this.readyCallbacks.forEach((t) => t(e)), this.readyCallbacks.length = 0);
  }
  whenReady(e) {
    this.ready ? e(this.params) : this.readyCallbacks.push(e);
  }
  register(e, t) {
    this.params[e] = t, this.checkReady();
  }
  registerHeaderContainer(e, t) {
    const r = this.params;
    switch (t) {
      case "left":
        r.leftHeader = e;
        break;
      case "right":
        r.rightHeader = e;
        break;
      default:
        r.centerHeader = e;
        break;
    }
    this.checkReady();
  }
  get(e) {
    return this.params[e];
  }
  getParams() {
    return this.params;
  }
  getGridBodyCtrl() {
    return this.params.gridBodyCtrl;
  }
  getHeaderRowContainerCtrls() {
    const { leftHeader: e, centerHeader: t, rightHeader: r } = this.params;
    return [e, r, t];
  }
  getHeaderRowContainerCtrl(e) {
    const t = this.params;
    switch (e) {
      case "left":
        return t.leftHeader;
      case "right":
        return t.rightHeader;
      default:
        return t.centerHeader;
    }
  }
}, C4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "cellPositionUtils";
  }
  createId(e) {
    const { rowIndex: t, rowPinned: r, column: n } = e;
    return this.createIdFromValues({ rowIndex: t, column: n, rowPinned: r });
  }
  createIdFromValues(e) {
    const { rowIndex: t, rowPinned: r, column: n } = e;
    return `${t}.${r ?? "null"}.${n.getId()}`;
  }
  equals(e, t) {
    const r = e.column === t.column, n = e.rowPinned === t.rowPinned, i = e.rowIndex === t.rowIndex;
    return r && n && i;
  }
}, S4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowNodeEventThrottle", this.events = [];
  }
  wireBeans(e) {
    this.animationFrameService = e.animationFrameService, this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.rowModel.getType() == "clientSide" && (this.clientSideRowModel = this.rowModel);
  }
  // because the user can call rowNode.setExpanded() many times in one VM turn,
  // we throttle the calls to ClientSideRowModel using animationFrameService. this means for 100
  // row nodes getting expanded, we only update the CSRM once, and then we fire all events after
  // CSRM has updated.
  //
  // if we did not do this, then the user could call setExpanded on 100+ rows, causing the grid
  // to re-render 100+ times, which would be a performance lag.
  //
  // we use animationFrameService
  // rather than debounce() so this will get done if anyone flushes the animationFrameService
  // (eg user calls api.ensureRowVisible(), which in turn flushes ).
  dispatchExpanded(e, t) {
    if (this.clientSideRowModel == null) {
      this.eventService.dispatchEvent(e);
      return;
    }
    this.events.push(e);
    const r = () => {
      this.clientSideRowModel && this.clientSideRowModel.onRowGroupOpened(), this.events.forEach((n) => this.eventService.dispatchEvent(n)), this.events = [];
    };
    t ? r() : (this.dispatchExpandedDebounced == null && (this.dispatchExpandedDebounced = this.animationFrameService.debounce(r)), this.dispatchExpandedDebounced());
  }
}, w4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowPositionUtils";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.pageBoundsService = e.pageBoundsService;
  }
  getFirstRow() {
    let e = 0, t;
    return this.pinnedRowModel.getPinnedTopRowCount() ? t = "top" : this.rowModel.getRowCount() ? (t = null, e = this.pageBoundsService.getFirstRow()) : this.pinnedRowModel.getPinnedBottomRowCount() && (t = "bottom"), t === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getLastRow() {
    let e, t = null;
    const r = this.pinnedRowModel.getPinnedBottomRowCount(), n = this.pinnedRowModel.getPinnedTopRowCount();
    return r ? (t = "bottom", e = r - 1) : this.rowModel.getRowCount() ? (t = null, e = this.pageBoundsService.getLastRow()) : n && (t = "top", e = n - 1), e === void 0 ? null : { rowIndex: e, rowPinned: t };
  }
  getRowNode(e) {
    switch (e.rowPinned) {
      case "top":
        return this.pinnedRowModel.getPinnedTopRowNodes()[e.rowIndex];
      case "bottom":
        return this.pinnedRowModel.getPinnedBottomRowNodes()[e.rowIndex];
      default:
        return this.rowModel.getRow(e.rowIndex);
    }
  }
  sameRow(e, t) {
    return !e && !t ? !0 : e && !t || !e && t ? !1 : e.rowIndex === t.rowIndex && e.rowPinned == t.rowPinned;
  }
  // tests if this row selection is before the other row selection
  before(e, t) {
    switch (e.rowPinned) {
      case "top":
        if (t.rowPinned !== "top")
          return !0;
        break;
      case "bottom":
        if (t.rowPinned !== "bottom")
          return !1;
        break;
      default:
        if (Me(t.rowPinned))
          return t.rowPinned !== "top";
        break;
    }
    return e.rowIndex < t.rowIndex;
  }
}, BG = {
  cssName: "--ag-row-height",
  changeKey: "rowHeightChanged",
  defaultValue: 42
}, GG = {
  cssName: "--ag-header-height",
  changeKey: "headerHeightChanged",
  defaultValue: 48
}, HG = {
  cssName: "--ag-list-item-height",
  changeKey: "listItemHeightChanged",
  defaultValue: 24
}, b4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "environment", this.sizeEls = /* @__PURE__ */ new Map(), this.lastKnownValues = /* @__PURE__ */ new Map(), this.themeClasses = [], this.eThemeAncestor = null, this.eMeasurementContainer = null, this.sizesMeasured = !1;
  }
  wireBeans(e) {
    this.resizeObserverService = e.resizeObserverService, this.eGridDiv = e.eGridDiv;
  }
  postConstruct() {
    this.addManagedPropertyListener("rowHeight", () => this.refreshRowHeightVariable()), this.themeClasses = this.getAncestorThemeClasses(), this.setUpThemeClassObservers(), this.getSizeEl(BG), this.getSizeEl(GG), this.getSizeEl(HG);
  }
  getDefaultRowHeight() {
    return this.getCSSVariablePixelValue(BG);
  }
  getDefaultHeaderHeight() {
    return this.getCSSVariablePixelValue(GG);
  }
  getDefaultListItemHeight() {
    return this.getCSSVariablePixelValue(HG);
  }
  hasMeasuredSizes() {
    return this.sizesMeasured;
  }
  getThemeClasses() {
    return this.themeClasses;
  }
  applyThemeClasses(e) {
    for (const t of Array.from(e.classList))
      t.startsWith("ag-theme-") && !this.themeClasses.includes(t) && e.classList.remove(t);
    for (const t of this.themeClasses)
      e.classList.contains(t) || e.classList.add(t);
  }
  getThemeAncestorElement() {
    return this.eThemeAncestor;
  }
  refreshRowHeightVariable() {
    const e = this.eGridDiv.style.getPropertyValue("--ag-line-height").trim(), t = this.gos.get("rowHeight");
    if (t == null || isNaN(t) || !isFinite(t))
      return e !== null && this.eGridDiv.style.setProperty("--ag-line-height", null), -1;
    const r = `${t}px`;
    return e != r ? (this.eGridDiv.style.setProperty("--ag-line-height", r), t) : e != "" ? parseFloat(e) : -1;
  }
  getCSSVariablePixelValue(e) {
    const t = this.lastKnownValues.get(e);
    if (t != null)
      return t;
    const r = this.measureSizeEl(e);
    return r === "detached" || r === "no-styles" ? e.defaultValue : (this.lastKnownValues.set(e, r), r);
  }
  measureSizeEl(e) {
    const t = this.getSizeEl(e);
    if (t.offsetParent == null)
      return "detached";
    const r = t.offsetWidth;
    return r === zG ? "no-styles" : (this.sizesMeasured = !0, r);
  }
  getSizeEl(e) {
    let t = this.sizeEls.get(e);
    if (t)
      return t;
    let r = this.eMeasurementContainer;
    r || (r = this.eMeasurementContainer = document.createElement("div"), r.className = "ag-measurement-container", this.eGridDiv.appendChild(r)), t = document.createElement("div"), t.style.width = `var(${e.cssName}, ${zG}px)`, r.appendChild(t), this.sizeEls.set(e, t);
    let n = this.measureSizeEl(e);
    n === "no-styles" && Se(
      `no value for ${e.cssName}. This usually means that the grid has been initialised before styles have been loaded. The default value of ${e.defaultValue} will be used and updated when styles load.`
    );
    const i = this.resizeObserverService.observeResize(t, () => {
      const o = this.measureSizeEl(e);
      o === "detached" || o === "no-styles" || (this.lastKnownValues.set(e, o), o !== n && (n = o, this.fireGridStylesChangedEvent(e.changeKey)));
    });
    return this.addDestroyFunc(() => i()), t;
  }
  fireGridStylesChangedEvent(e) {
    const t = {
      type: "gridStylesChanged",
      [e]: !0
    };
    this.eventService.dispatchEvent(t);
  }
  setUpThemeClassObservers() {
    const e = new MutationObserver(() => {
      const r = this.getAncestorThemeClasses();
      x4e(r, this.themeClasses) || (this.themeClasses = r, this.fireGridStylesChangedEvent("themeChanged"));
    });
    let t = this.eGridDiv;
    for (; t; )
      e.observe(t || this.eGridDiv, {
        attributes: !0,
        attributeFilter: ["class"]
      }), t = t.parentElement;
  }
  getAncestorThemeClasses() {
    let e = this.eGridDiv;
    const t = [];
    for (this.eThemeAncestor = null; e; ) {
      const r = Array.from(e.classList).filter((n) => n.startsWith("ag-theme-"));
      for (const n of r)
        this.eThemeAncestor = e, t.includes(n) || t.unshift(n);
      e = e.parentElement;
    }
    return Object.freeze(t);
  }
}, x4e = (e, t) => e.length === t.length && e.findIndex((r, n) => e[n] !== t[n]) === -1, zG = 15538, E4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "eventService", this.globalEventService = new wf();
  }
  wireBeans(e) {
    this.globalEventListener = e.globalEventListener, this.globalSyncEventListener = e.globalSyncEventListener;
  }
  postConstruct() {
    if (this.globalEventListener) {
      const e = this.gos.useAsyncEvents();
      this.addGlobalListener(this.globalEventListener, e);
    }
    this.globalSyncEventListener && this.addGlobalListener(this.globalSyncEventListener, !1);
  }
  addEventListener(e, t, r) {
    this.globalEventService.addEventListener(e, t, r);
  }
  removeEventListener(e, t, r) {
    this.globalEventService.removeEventListener(e, t, r);
  }
  addGlobalListener(e, t = !1) {
    this.globalEventService.addGlobalListener(e, t);
  }
  removeGlobalListener(e, t = !1) {
    this.globalEventService.removeGlobalListener(e, t);
  }
  /** @deprecated DO NOT FIRE LOCAL EVENTS OFF THE EVENT SERVICE */
  dispatchLocalEvent() {
  }
  dispatchEvent(e) {
    this.globalEventService.dispatchEvent(this.gos.addGridCommonParams(e));
  }
  dispatchEventOnce(e) {
    this.globalEventService.dispatchEventOnce(this.gos.addGridCommonParams(e));
  }
}, HA = class Yi extends he {
  constructor() {
    super(...arguments), this.beanName = "focusService";
  }
  wireBeans(t) {
    this.eGridDiv = t.eGridDiv, this.columnModel = t.columnModel, this.visibleColsService = t.visibleColsService, this.headerNavigationService = t.headerNavigationService, this.headerPositionUtils = t.headerPositionUtils, this.rowRenderer = t.rowRenderer, this.rowPositionUtils = t.rowPositionUtils, this.cellPositionUtils = t.cellPositionUtils, this.navigationService = t.navigationService, this.ctrlsService = t.ctrlsService, this.filterManager = t.filterManager, this.rangeService = t.rangeService, this.advancedFilterService = t.advancedFilterService;
  }
  static addKeyboardModeEvents(t) {
    this.instanceCount > 0 || (t.addEventListener("keydown", Yi.toggleKeyboardMode), t.addEventListener("mousedown", Yi.toggleKeyboardMode));
  }
  static removeKeyboardModeEvents(t) {
    this.instanceCount > 0 || (t.addEventListener("keydown", Yi.toggleKeyboardMode), t.addEventListener("mousedown", Yi.toggleKeyboardMode));
  }
  static toggleKeyboardMode(t) {
    const r = Yi.keyboardModeActive, n = t.type === "keydown";
    n && (t.ctrlKey || t.metaKey || t.altKey) || r !== n && (Yi.keyboardModeActive = n);
  }
  static unregisterGridCompController(t) {
    Yi.removeKeyboardModeEvents(t);
  }
  postConstruct() {
    const t = this.clearFocusedCell.bind(this);
    this.addManagedEventListeners({
      columnPivotModeChanged: t,
      newColumnsLoaded: this.onColumnEverythingChanged.bind(this),
      columnGroupOpened: t,
      columnRowGroupChanged: t
    }), this.registerKeyboardFocusEvents(), this.ctrlsService.whenReady((r) => {
      this.gridCtrl = r.gridCtrl;
    });
  }
  registerKeyboardFocusEvents() {
    const t = this.gos.getDocument();
    Yi.addKeyboardModeEvents(t), Yi.instanceCount++, this.addDestroyFunc(() => {
      Yi.instanceCount--, Yi.unregisterGridCompController(t);
    });
  }
  onColumnEverythingChanged() {
    if (!this.focusedCellPosition)
      return;
    const t = this.focusedCellPosition.column, r = this.columnModel.getCol(t.getId());
    t !== r && this.clearFocusedCell();
  }
  isKeyboardMode() {
    return Yi.keyboardModeActive;
  }
  // we check if the browser is focusing something, and if it is, and
  // it's the cell we think is focused, then return the cell. so this
  // methods returns the cell if a) we think it has focus and b) the
  // browser thinks it has focus. this then returns nothing if we
  // first focus a cell, then second click outside the grid, as then the
  // grid cell will still be focused as far as the grid is concerned,
  // however the browser focus will have moved somewhere else.
  getFocusCellToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedCellPosition || this.isDomDataMissingInHierarchy(this.gos.getActiveDomElement(), xc.DOM_DATA_KEY_ROW_CTRL) ? null : this.focusedCellPosition;
  }
  getFocusHeaderToUseAfterRefresh() {
    return this.gos.get("suppressFocusAfterRefresh") || !this.focusedHeaderPosition || this.isDomDataMissingInHierarchy(
      this.gos.getActiveDomElement(),
      mw.DOM_DATA_KEY_HEADER_CTRL
    ) ? null : this.focusedHeaderPosition;
  }
  isDomDataMissingInHierarchy(t, r) {
    let n = t;
    for (; n; ) {
      if (this.gos.getDomData(n, r))
        return !1;
      n = n.parentNode;
    }
    return !0;
  }
  getFocusedCell() {
    return this.focusedCellPosition;
  }
  shouldRestoreFocus(t) {
    return this.isCellRestoreFocused(t) ? (setTimeout(() => {
      this.restoredFocusedCellPosition = null;
    }, 0), !0) : !1;
  }
  isCellRestoreFocused(t) {
    return this.restoredFocusedCellPosition == null ? !1 : this.cellPositionUtils.equals(t, this.restoredFocusedCellPosition);
  }
  setRestoreFocusedCell(t) {
    this.getFrameworkOverrides().renderingEngine === "react" && (this.restoredFocusedCellPosition = t);
  }
  getFocusEventParams() {
    const { rowIndex: t, rowPinned: r, column: n } = this.focusedCellPosition, i = {
      rowIndex: t,
      rowPinned: r,
      column: n,
      isFullWidthCell: !1
    }, o = this.rowRenderer.getRowByPosition({ rowIndex: t, rowPinned: r });
    return o && (i.isFullWidthCell = o.isFullWidth()), i;
  }
  clearFocusedCell() {
    if (this.restoredFocusedCellPosition = null, this.focusedCellPosition == null)
      return;
    const t = {
      type: "cellFocusCleared",
      ...this.getFocusEventParams()
    };
    this.focusedCellPosition = null, this.eventService.dispatchEvent(t);
  }
  setFocusedCell(t) {
    const { column: r, rowIndex: n, rowPinned: i, forceBrowserFocus: o = !1, preventScrollOnBrowserFocus: a = !1 } = t, s = this.columnModel.getCol(r);
    if (!s) {
      this.focusedCellPosition = null;
      return;
    }
    this.focusedCellPosition = s ? {
      rowIndex: n,
      rowPinned: Sc(i),
      column: s
    } : null;
    const l = {
      type: "cellFocused",
      ...this.getFocusEventParams(),
      forceBrowserFocus: o,
      preventScrollOnBrowserFocus: a
    };
    this.eventService.dispatchEvent(l);
  }
  isCellFocused(t) {
    return this.focusedCellPosition == null ? !1 : this.cellPositionUtils.equals(t, this.focusedCellPosition);
  }
  isRowNodeFocused(t) {
    return this.isRowFocused(t.rowIndex, t.rowPinned);
  }
  isHeaderWrapperFocused(t) {
    if (this.focusedHeaderPosition == null)
      return !1;
    const r = t.getColumnGroupChild(), n = t.getRowIndex(), i = t.getPinned(), { column: o, headerRowIndex: a } = this.focusedHeaderPosition;
    return r === o && n === a && i == o.getPinned();
  }
  clearFocusedHeader() {
    this.focusedHeaderPosition = null;
  }
  getFocusedHeader() {
    return this.focusedHeaderPosition;
  }
  setFocusedHeader(t, r) {
    this.focusedHeaderPosition = { headerRowIndex: t, column: r };
  }
  focusHeaderPosition(t) {
    var u;
    if (this.gos.get("suppressHeaderFocus"))
      return !1;
    const { direction: r, fromTab: n, allowUserOverride: i, event: o, fromCell: a, rowWithoutSpanValue: s } = t;
    let { headerPosition: l } = t;
    if (a && ((u = this.filterManager) != null && u.isAdvancedFilterHeaderActive()))
      return this.focusAdvancedFilter(l);
    if (i) {
      const c = this.getFocusedHeader(), d = this.headerNavigationService.getHeaderRowCount();
      if (n) {
        const h = this.gos.getCallback("tabToNextHeader");
        h && (l = this.getHeaderPositionFromUserFunc({
          userFunc: h,
          direction: r,
          currentPosition: c,
          headerPosition: l,
          headerRowCount: d
        }));
      } else {
        const h = this.gos.getCallback("navigateToNextHeader");
        if (h && o) {
          const f = {
            key: o.key,
            previousHeaderPosition: c,
            nextHeaderPosition: l,
            headerRowCount: d,
            event: o
          };
          l = h(f);
        }
      }
    }
    return l ? this.focusProvidedHeaderPosition({
      headerPosition: l,
      direction: r,
      event: o,
      fromCell: a,
      rowWithoutSpanValue: s
    }) : !1;
  }
  focusHeaderPositionFromUserFunc(t) {
    if (this.gos.get("suppressHeaderFocus"))
      return !1;
    const { userFunc: r, headerPosition: n, direction: i, event: o } = t, a = this.getFocusedHeader(), s = this.headerNavigationService.getHeaderRowCount(), l = this.getHeaderPositionFromUserFunc({
      userFunc: r,
      direction: i,
      currentPosition: a,
      headerPosition: n,
      headerRowCount: s
    });
    return !!l && this.focusProvidedHeaderPosition({
      headerPosition: l,
      direction: i,
      event: o
    });
  }
  getHeaderPositionFromUserFunc(t) {
    const { userFunc: r, direction: n, currentPosition: i, headerPosition: o, headerRowCount: a } = t, l = r({
      backwards: n === "Before",
      previousHeaderPosition: i,
      nextHeaderPosition: o,
      headerRowCount: a
    });
    return l === !0 || l === null ? (l === null && Se(
      "Since v31.3 Returning `null` from tabToNextHeader is deprecated. Return `true` to stay on the current header, or `false` to let the browser handle the tab behaviour."
    ), i) : l === !1 ? null : l;
  }
  focusProvidedHeaderPosition(t) {
    var d;
    const { headerPosition: r, direction: n, fromCell: i, rowWithoutSpanValue: o, event: a } = t, { column: s, headerRowIndex: l } = r;
    if (l === -1)
      return (d = this.filterManager) != null && d.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(r) : this.focusGridView(s);
    this.headerNavigationService.scrollToColumn(s, n);
    const c = this.ctrlsService.getHeaderRowContainerCtrl(s.getPinned()).focusHeader(
      r.headerRowIndex,
      s,
      a
    );
    return c && (o != null || i) && this.headerNavigationService.setCurrentHeaderRowWithoutSpan(o ?? -1), c;
  }
  focusFirstHeader() {
    let t = this.visibleColsService.getAllCols()[0];
    if (!t)
      return !1;
    t.getParent() && (t = this.visibleColsService.getColGroupAtLevel(t, 0));
    const r = this.headerPositionUtils.getHeaderIndexToFocus(t, 0);
    return this.focusHeaderPosition({
      headerPosition: r,
      rowWithoutSpanValue: 0
    });
  }
  focusLastHeader(t) {
    const r = this.headerNavigationService.getHeaderRowCount() - 1, n = Jt(this.visibleColsService.getAllCols());
    return this.focusHeaderPosition({
      headerPosition: { headerRowIndex: r, column: n },
      rowWithoutSpanValue: -1,
      event: t
    });
  }
  focusPreviousFromFirstCell(t) {
    var r;
    return (r = this.filterManager) != null && r.isAdvancedFilterHeaderActive() ? this.focusAdvancedFilter(null) : this.focusLastHeader(t);
  }
  isAnyCellFocused() {
    return !!this.focusedCellPosition;
  }
  isRowFocused(t, r) {
    return this.focusedCellPosition == null ? !1 : this.focusedCellPosition.rowIndex === t && this.focusedCellPosition.rowPinned === Sc(r);
  }
  findFocusableElements(t, r, n = !1) {
    const i = _Oe;
    let o = fK;
    r && (o += ", " + r), n && (o += ', [tabindex="-1"]');
    const a = Array.prototype.slice.apply(t.querySelectorAll(i)).filter((u) => ts(u)), s = Array.prototype.slice.apply(t.querySelectorAll(o));
    return s.length ? ((u, c) => u.filter((d) => c.indexOf(d) === -1))(a, s) : a;
  }
  focusInto(t, r = !1, n = !1) {
    const i = this.findFocusableElements(t, null, n), o = r ? Jt(i) : i[0];
    return o ? (o.focus({ preventScroll: !0 }), !0) : !1;
  }
  findFocusableElementBeforeTabGuard(t, r) {
    if (!r)
      return null;
    const n = this.findFocusableElements(t), i = n.indexOf(r);
    if (i === -1)
      return null;
    let o = -1;
    for (let a = i - 1; a >= 0; a--)
      if (n[a].classList.contains(
        "ag-tab-guard-top"
        /* TAB_GUARD_TOP */
      )) {
        o = a;
        break;
      }
    return o <= 0 ? null : n[o - 1];
  }
  findNextFocusableElement(t = this.eGridDiv, r, n) {
    const i = this.findFocusableElements(t, r ? ':not([tabindex="-1"])' : null), o = this.gos.getActiveDomElement();
    let a;
    r ? a = i.findIndex((l) => l.contains(o)) : a = i.indexOf(o);
    const s = a + (n ? -1 : 1);
    return s < 0 || s >= i.length ? null : i[s];
  }
  isTargetUnderManagedComponent(t, r) {
    if (!r)
      return !1;
    const n = t.querySelectorAll(`.${td.FOCUS_MANAGED_CLASS}`);
    if (!n.length)
      return !1;
    for (let i = 0; i < n.length; i++)
      if (n[i].contains(r))
        return !0;
    return !1;
  }
  findTabbableParent(t, r = 5) {
    let n = 0;
    for (; t && TT(t) === null && ++n <= r; )
      t = t.parentElement;
    return TT(t) === null ? null : t;
  }
  focusGridView(t, r) {
    var s;
    if (this.gos.get("suppressCellFocus"))
      return r ? this.gos.get("suppressHeaderFocus") ? this.focusNextGridCoreContainer(!0, !0) : this.focusLastHeader() : this.focusNextGridCoreContainer(!1);
    const n = r ? this.rowPositionUtils.getLastRow() : this.rowPositionUtils.getFirstRow();
    if (!n)
      return !1;
    const { rowIndex: i, rowPinned: o } = n, a = this.getFocusedHeader();
    return !t && a && (t = a.column), i == null || !t ? !1 : (this.navigationService.ensureCellVisible({ rowIndex: i, column: t, rowPinned: o }), this.setFocusedCell({
      rowIndex: i,
      column: t,
      rowPinned: Sc(o),
      forceBrowserFocus: !0
    }), (s = this.rangeService) == null || s.setRangeToCell({ rowIndex: i, rowPinned: o, column: t }), !0);
  }
  focusNextGridCoreContainer(t, r = !1) {
    return !r && this.gridCtrl.focusNextInnerContainer(t) ? !0 : ((r || !t && !this.gridCtrl.isDetailGrid()) && this.gridCtrl.forceFocusOutOfContainer(t), !1);
  }
  focusAdvancedFilter(t) {
    var r;
    return this.advancedFilterFocusColumn = t == null ? void 0 : t.column, ((r = this.advancedFilterService) == null ? void 0 : r.getCtrl().focusHeaderComp()) ?? !1;
  }
  focusNextFromAdvancedFilter(t, r) {
    var i;
    const n = (r ? void 0 : this.advancedFilterFocusColumn) ?? ((i = this.visibleColsService.getAllCols()) == null ? void 0 : i[0]);
    return t ? this.focusHeaderPosition({
      headerPosition: {
        column: n,
        headerRowIndex: this.headerNavigationService.getHeaderRowCount() - 1
      }
    }) : this.focusGridView(n);
  }
  clearAdvancedFilterColumn() {
    this.advancedFilterFocusColumn = void 0;
  }
  addFocusableContainer(t) {
    this.gridCtrl.addFocusableContainer(t);
  }
  removeFocusableContainer(t) {
    this.gridCtrl.removeFocusableContainer(t);
  }
  focusGridInnerElement(t) {
    return this.gridCtrl.focusInnerElement(t);
  }
};
HA.keyboardModeActive = !1;
HA.instanceCount = 0;
var R4e = HA, _4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "pinnedWidthService";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService;
  }
  postConstruct() {
    const e = this.checkContainerWidths.bind(this);
    this.addManagedEventListeners({
      displayedColumnsChanged: e,
      displayedColumnsWidthChanged: e
    }), this.addManagedPropertyListener("domLayout", e);
  }
  checkContainerWidths() {
    const e = this.gos.isDomLayout("print"), t = e ? 0 : this.visibleColsService.getColsLeftWidth(), r = e ? 0 : this.visibleColsService.getDisplayedColumnsRightWidth();
    t != this.leftWidth && (this.leftWidth = t, this.eventService.dispatchEvent({ type: "leftPinnedWidthChanged" })), r != this.rightWidth && (this.rightWidth = r, this.eventService.dispatchEvent({ type: "rightPinnedWidthChanged" }));
  }
  getPinnedRightWidth() {
    return this.rightWidth;
  }
  getPinnedLeftWidth() {
    return this.leftWidth;
  }
}, T4e = class extends he {
  constructor() {
    super(...arguments), this.additionalFocusableContainers = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.beans = e, this.focusService = e.focusService, this.visibleColsService = e.visibleColsService;
  }
  setComp(e, t, r) {
    this.view = e, this.eGridHostDiv = t, this.eGui = r, this.eGui.setAttribute("grid-id", this.gridId);
    const { dragAndDropService: n, mouseEventService: i, ctrlsService: o, resizeObserverService: a } = this.beans;
    n.addDropTarget({
      getContainer: () => this.eGui,
      isInterestedIn: (l) => l === 1 || l === 0,
      getIconName: () => "notAllowed"
    }), i.stampTopLevelGridCompWithGridInstance(t), this.createManagedBean(new GA(this.view)), this.addRtlSupport();
    const s = a.observeResize(
      this.eGridHostDiv,
      this.onGridSizeChanged.bind(this)
    );
    this.addDestroyFunc(() => s()), o.register("gridCtrl", this);
  }
  isDetailGrid() {
    var t;
    const e = this.focusService.findTabbableParent(this.getGui());
    return ((t = e == null ? void 0 : e.getAttribute("row-id")) == null ? void 0 : t.startsWith("detail")) || !1;
  }
  getOptionalSelectors() {
    var t, r, n, i, o;
    const e = this.beans;
    return {
      paginationSelector: (t = e.paginationService) == null ? void 0 : t.getPaginationSelector(),
      gridHeaderDropZonesSelector: (r = e.columnDropZonesService) == null ? void 0 : r.getDropZoneSelector(),
      sideBarSelector: (n = e.sideBarService) == null ? void 0 : n.getSideBarSelector(),
      statusBarSelector: (i = e.statusBarService) == null ? void 0 : i.getStatusPanelSelector(),
      watermarkSelector: (o = e.licenseManager) == null ? void 0 : o.getWatermarkSelector()
    };
  }
  onGridSizeChanged() {
    const e = {
      type: "gridSizeChanged",
      clientWidth: this.eGridHostDiv.clientWidth,
      clientHeight: this.eGridHostDiv.clientHeight
    };
    this.eventService.dispatchEvent(e);
  }
  addRtlSupport() {
    const e = this.gos.get("enableRtl") ? "ag-rtl" : "ag-ltr";
    this.view.setRtlClass(e);
  }
  destroyGridUi() {
    this.view.destroyGridUi();
  }
  getGui() {
    return this.eGui;
  }
  setResizeCursor(e) {
    this.view.setCursor(e ? "ew-resize" : null);
  }
  disableUserSelect(e) {
    this.view.setUserSelect(e ? "none" : null);
  }
  focusNextInnerContainer(e) {
    const t = this.getFocusableContainers(), r = this.gos.getActiveDomElement(), n = t.findIndex((o) => o.getGui().contains(r)), i = n + (e ? -1 : 1);
    if (i < 0 || i >= t.length)
      return !1;
    if (i === 0) {
      if (n > 0) {
        const o = this.visibleColsService.getAllCols(), a = Jt(o);
        if (this.focusService.focusGridView(a, !0))
          return !0;
      }
      return !1;
    }
    return this.focusContainer(t[i], e);
  }
  focusInnerElement(e) {
    const t = this.getFocusableContainers(), r = this.visibleColsService.getAllCols(), n = this.gos.getCallback("focusGridInnerElement");
    if (n && n({ fromBottom: !!e }))
      return !0;
    if (e) {
      if (t.length > 1)
        return this.focusContainer(Jt(t), !0);
      const i = Jt(r);
      if (this.focusService.focusGridView(i, !0))
        return !0;
    }
    if (this.gos.get("headerHeight") === 0 || this.gos.get("suppressHeaderFocus")) {
      if (this.focusService.focusGridView(r[0]))
        return !0;
      for (let i = 1; i < t.length; i++)
        if (this.focusService.focusInto(t[i].getGui()))
          return !0;
      return !1;
    }
    return this.focusService.focusFirstHeader();
  }
  forceFocusOutOfContainer(e = !1) {
    this.view.forceFocusOutOfContainer(e);
  }
  addFocusableContainer(e) {
    this.additionalFocusableContainers.add(e);
  }
  removeFocusableContainer(e) {
    this.additionalFocusableContainers.delete(e);
  }
  focusContainer(e, t) {
    var n, i;
    (n = e == null ? void 0 : e.setAllowFocus) == null || n.call(e, !0);
    const r = this.focusService.focusInto(e.getGui(), t);
    return (i = e == null ? void 0 : e.setAllowFocus) == null || i.call(e, !1), r;
  }
  getFocusableContainers() {
    return [...this.view.getFocusableContainers(), ...this.additionalFocusableContainers.values()];
  }
  destroy() {
    this.additionalFocusableContainers.clear(), super.destroy();
  }
}, P4e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "alignedGridsService", this.consuming = !1;
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnSizeService = e.columnSizeService, this.ctrlsService = e.ctrlsService, this.columnApplyStateService = e.columnApplyStateService;
  }
  getAlignedGridApis() {
    let e = this.gos.get("alignedGrids") ?? [];
    const t = typeof e == "function";
    typeof e == "function" && (e = e());
    const r = () => `See ${this.getFrameworkOverrides().getDocLink("aligned-grids")}`;
    return e.map((i) => {
      var a;
      if (!i) {
        sr("alignedGrids contains an undefined option."), t || sr(`You may want to configure via a callback to avoid setup race conditions:
                     "alignedGrids: () => [linkedGrid]"`), sr(r());
        return;
      }
      if (this.isGridApi(i))
        return i;
      const o = i;
      return "current" in o ? (a = o.current) == null ? void 0 : a.api : (o.api || sr(
        `alignedGrids - No api found on the linked grid. If you are passing gridOptions to alignedGrids since v31 this is no longer valid. ${r()}`
      ), o.api);
    }).filter((i) => !!i && !i.isDestroyed());
  }
  isGridApi(e) {
    return !!e && !!e.dispatchEvent;
  }
  postConstruct() {
    const e = this.fireColumnEvent.bind(this);
    this.addManagedEventListeners({
      columnMoved: e,
      columnVisible: e,
      columnPinned: e,
      columnGroupOpened: e,
      columnResized: e,
      bodyScroll: this.fireScrollEvent.bind(this),
      alignedGridColumn: ({ event: t }) => this.onColumnEvent(t),
      alignedGridScroll: ({ event: t }) => this.onScrollEvent(t)
    });
  }
  // common logic across all the fire methods
  fireEvent(e) {
    this.consuming || this.getAlignedGridApis().forEach((t) => {
      t.isDestroyed() || t.dispatchEvent(e);
    });
  }
  // common logic across all consume methods. very little common logic, however extracting
  // guarantees consistency across the methods.
  onEvent(e) {
    this.consuming = !0, e(), this.consuming = !1;
  }
  fireColumnEvent(e) {
    const t = {
      type: "alignedGridColumn",
      event: e
    };
    this.fireEvent(t);
  }
  fireScrollEvent(e) {
    if (e.direction !== "horizontal")
      return;
    const t = {
      type: "alignedGridScroll",
      event: e
    };
    this.fireEvent(t);
  }
  onScrollEvent(e) {
    this.onEvent(() => {
      this.ctrlsService.getGridBodyCtrl().getScrollFeature().setHorizontalScrollPosition(e.left, !0);
    });
  }
  getMasterColumns(e) {
    const t = [];
    return e.columns ? e.columns.forEach((r) => {
      t.push(r);
    }) : e.column && t.push(e.column), t;
  }
  getColumnIds(e) {
    const t = [];
    return e.columns ? e.columns.forEach((r) => {
      t.push(r.getColId());
    }) : e.column && t.push(e.column.getColId()), t;
  }
  onColumnEvent(e) {
    this.onEvent(() => {
      switch (e.type) {
        case "columnMoved":
        case "columnVisible":
        case "columnPinned":
        case "columnResized": {
          const t = e;
          this.processColumnEvent(t);
          break;
        }
        case "columnGroupOpened": {
          const t = e;
          this.processGroupOpenedEvent(t);
          break;
        }
        case "columnPivotChanged":
          Se(
            "pivoting is not supported with aligned grids. You can only use one of these features at a time in a grid."
          );
          break;
      }
    });
  }
  processGroupOpenedEvent(e) {
    e.columnGroups.forEach((t) => {
      let r = null;
      if (t) {
        const n = t.getGroupId();
        r = this.columnModel.getProvidedColGroup(n);
      }
      t && !r || this.columnModel.setColumnGroupOpened(r, t.isExpanded(), "alignedGridChanged");
    });
  }
  processColumnEvent(e) {
    var a;
    const t = e.column;
    let r = null;
    if (t && (r = this.columnModel.getColDefCol(t.getColId())), t && !r)
      return;
    const n = this.getMasterColumns(e);
    switch (e.type) {
      case "columnMoved":
        {
          const l = e.api.getColumnState().map((u) => ({ colId: u.colId }));
          this.columnApplyStateService.applyColumnState(
            { state: l, applyOrder: !0 },
            "alignedGridChanged"
          );
        }
        break;
      case "columnVisible":
        {
          const l = e.api.getColumnState().map((u) => ({ colId: u.colId, hide: u.hide }));
          this.columnApplyStateService.applyColumnState({ state: l }, "alignedGridChanged");
        }
        break;
      case "columnPinned":
        {
          const l = e.api.getColumnState().map((u) => ({ colId: u.colId, pinned: u.pinned }));
          this.columnApplyStateService.applyColumnState({ state: l }, "alignedGridChanged");
        }
        break;
      case "columnResized": {
        const s = e, l = {};
        n.forEach((u) => {
          l[u.getId()] = { key: u.getColId(), newWidth: u.getActualWidth() };
        }), (a = s.flexColumns) == null || a.forEach((u) => {
          l[u.getId()] && delete l[u.getId()];
        }), this.columnSizeService.setColumnWidths(
          Object.values(l),
          !1,
          s.finished,
          "alignedGridChanged"
        );
        break;
      }
    }
    const o = this.ctrlsService.getGridBodyCtrl().isVerticalScrollShowing();
    this.getAlignedGridApis().forEach((s) => {
      s.setGridOption("alwaysShowVerticalScroll", o);
    });
  }
}, M4e = {
  version: Et,
  moduleName: "@ag-grid-community/aligned-grid",
  beans: [P4e]
};
function D4e(e, t) {
  const r = e.columnModel.getColDefCol(t);
  return r ? r.getColDef() : null;
}
function A4e(e) {
  return e.columnModel.getColumnDefs();
}
function I4e(e, t) {
  typeof t == "number" ? e.columnSizeService.sizeColumnsToFit(t, "api") : e.ctrlsService.getGridBodyCtrl().sizeColumnsToFit(t);
}
function F4e(e, t, r) {
  e.columnModel.setColumnGroupOpened(t, r, "api");
}
function L4e(e, t, r) {
  return e.visibleColsService.getColumnGroup(t, r);
}
function O4e(e, t) {
  return e.columnModel.getProvidedColGroup(t);
}
function N4e(e, t, r) {
  return e.columnNameService.getDisplayNameForColumn(t, r) || "";
}
function k4e(e, t, r) {
  return e.columnNameService.getDisplayNameForColumnGroup(t, r) || "";
}
function V4e(e, t) {
  return e.columnModel.getColDefCol(t);
}
function B4e(e) {
  return e.columnModel.getColDefCols();
}
function G4e(e, t) {
  return e.columnApplyStateService.applyColumnState(t, "api");
}
function H4e(e) {
  return e.columnGetStateService.getColumnState();
}
function z4e(e) {
  e.columnApplyStateService.resetColumnState("api");
}
function $4e(e) {
  return e.columnGroupStateService.getColumnGroupState();
}
function W4e(e, t) {
  e.columnGroupStateService.setColumnGroupState(t, "api");
}
function j4e(e) {
  e.columnGroupStateService.resetColumnGroupState("api");
}
function U4e(e) {
  return e.visibleColsService.isPinningLeft() || e.visibleColsService.isPinningRight();
}
function K4e(e) {
  return e.visibleColsService.isPinningLeft();
}
function Y4e(e) {
  return e.visibleColsService.isPinningRight();
}
function q4e(e, t) {
  return e.visibleColsService.getColAfter(t);
}
function Z4e(e, t) {
  return e.visibleColsService.getColBefore(t);
}
function X4e(e, t, r) {
  e.columnModel.setColsVisible([t], r, "api");
}
function Q4e(e, t, r) {
  e.columnModel.setColsVisible(t, r, "api");
}
function J4e(e, t, r) {
  e.columnModel.setColsPinned([t], r, "api");
}
function eGe(e, t, r) {
  e.columnModel.setColsPinned(t, r, "api");
}
function tGe(e) {
  return e.columnModel.getCols();
}
function rGe(e) {
  return e.visibleColsService.getLeftCols();
}
function nGe(e) {
  return e.visibleColsService.getCenterCols();
}
function iGe(e) {
  return e.visibleColsService.getRightCols();
}
function oGe(e) {
  return e.visibleColsService.getAllCols();
}
function aGe(e) {
  return e.columnViewportService.getViewportColumns();
}
function sGe(e, t, r) {
  e.columnMoveService.moveColumns([t], r, "api");
}
function lGe(e, t, r) {
  e.columnMoveService.moveColumnByIndex(t, r, "api");
}
function uGe(e, t, r) {
  e.columnMoveService.moveColumns(t, r, "api");
}
function cGe(e, t, r, n = !0, i = "api") {
  e.columnSizeService.setColumnWidths([{ key: t, newWidth: r }], !1, n, i);
}
function dGe(e, t, r = !0, n = "api") {
  e.columnSizeService.setColumnWidths(t, !1, r, n);
}
function hGe(e) {
  return e.visibleColsService.getTreeLeft();
}
function fGe(e) {
  return e.visibleColsService.getTreeCenter();
}
function pGe(e) {
  return e.visibleColsService.getTreeRight();
}
function gGe(e) {
  return e.visibleColsService.getAllTrees();
}
function vGe(e, t, r) {
  return e.columnAutosizeService.autoSizeCols({ colKeys: [t], skipHeader: r, source: "api" });
}
function mGe(e, t, r) {
  e.columnAutosizeService.autoSizeCols({ colKeys: t, skipHeader: r, source: "api" });
}
function yGe(e, t) {
  e.columnAutosizeService.autoSizeAllColumns("api", t);
}
var $G = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, WG = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
], CGe = class extends he {
  constructor() {
    super(...arguments), this.beanName = "dataTypeService", this.dataTypeDefinitions = {}, this.isWaitingForRowData = !1, this.isColumnTypeOverrideInDataTypeDefinitions = !1, this.columnStateUpdatesPendingInference = {}, this.columnStateUpdateListenerDestroyFuncs = [];
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.valueService = e.valueService, this.columnApplyStateService = e.columnApplyStateService;
  }
  postConstruct() {
    this.groupHideOpenParents = this.gos.get("groupHideOpenParents"), this.addManagedPropertyListener("groupHideOpenParents", () => {
      this.groupHideOpenParents = this.gos.get("groupHideOpenParents");
    }), this.processDataTypeDefinitions(), this.addManagedPropertyListener("dataTypeDefinitions", (e) => {
      this.processDataTypeDefinitions(), this.columnModel.recreateColumnDefs(ah(e.source));
    });
  }
  processDataTypeDefinitions() {
    const e = this.getDefaultDataTypes();
    this.dataTypeDefinitions = {}, this.formatValueFuncs = {};
    const t = (n) => (i) => {
      const { column: o, node: a, value: s } = i;
      let l = o.getColDef().valueFormatter;
      return l === n.groupSafeValueFormatter && (l = n.valueFormatter), this.valueService.formatValue(o, a, s, l);
    };
    Object.entries(e).forEach(([n, i]) => {
      const o = {
        ...i,
        groupSafeValueFormatter: this.createGroupSafeValueFormatter(i)
      };
      this.dataTypeDefinitions[n] = o, this.formatValueFuncs[n] = t(o);
    });
    const r = this.gos.get("dataTypeDefinitions") ?? {};
    this.dataTypeMatchers = {}, Object.entries(r).forEach(([n, i]) => {
      const o = this.processDataTypeDefinition(
        i,
        r,
        [n],
        e
      );
      o && (this.dataTypeDefinitions[n] = o, i.dataTypeMatcher && (this.dataTypeMatchers[n] = i.dataTypeMatcher), this.formatValueFuncs[n] = t(o));
    }), this.checkObjectValueHandlers(e), ["dateString", "text", "number", "boolean", "date"].forEach((n) => {
      const i = this.dataTypeMatchers[n];
      i && delete this.dataTypeMatchers[n], this.dataTypeMatchers[n] = i ?? e[n].dataTypeMatcher;
    });
  }
  mergeDataTypeDefinitions(e, t) {
    const r = {
      ...e,
      ...t
    };
    return e.columnTypes && t.columnTypes && t.appendColumnTypes && (r.columnTypes = [
      ...v0(e.columnTypes),
      ...v0(t.columnTypes)
    ]), r;
  }
  processDataTypeDefinition(e, t, r, n) {
    let i;
    const o = e.extendsDataType;
    if (e.columnTypes && (this.isColumnTypeOverrideInDataTypeDefinitions = !0), e.extendsDataType === e.baseDataType) {
      let a = n[o];
      const s = t[o];
      if (a && s && (a = s), !this.validateDataTypeDefinition(e, a, o))
        return;
      i = this.mergeDataTypeDefinitions(a, e);
    } else {
      if (r.includes(o)) {
        Se(
          'Data type definition hierarchies (via the "extendsDataType" property) cannot contain circular references.'
        );
        return;
      }
      const a = t[o];
      if (!this.validateDataTypeDefinition(e, a, o))
        return;
      const s = this.processDataTypeDefinition(
        a,
        t,
        [...r, o],
        n
      );
      if (!s)
        return;
      i = this.mergeDataTypeDefinitions(
        s,
        e
      );
    }
    return {
      ...i,
      groupSafeValueFormatter: this.createGroupSafeValueFormatter(i)
    };
  }
  validateDataTypeDefinition(e, t, r) {
    return t ? t.baseDataType !== e.baseDataType ? (Se('The "baseDataType" property of a data type definition must match that of its parent.'), !1) : !0 : (Se(`The data type definition ${r} does not exist.`), !1);
  }
  createGroupSafeValueFormatter(e) {
    if (e.valueFormatter)
      return (t) => {
        var r, n;
        if ((r = t.node) != null && r.group) {
          const i = t.column.getAggFunc();
          if (i) {
            if (i === "first" || i === "last")
              return e.valueFormatter(t);
            if (e.baseDataType === "number" && i !== "count") {
              if (typeof t.value == "number")
                return e.valueFormatter(t);
              if (typeof t.value == "object") {
                if (!t.value)
                  return;
                if ("toNumber" in t.value)
                  return e.valueFormatter({
                    ...t,
                    value: t.value.toNumber()
                  });
                if ("value" in t.value)
                  return e.valueFormatter({
                    ...t,
                    value: t.value.value
                  });
              }
            }
          }
          if (!this.gos.get("suppressGroupMaintainValueType"))
            return;
        } else if (this.groupHideOpenParents && t.column.isRowGroupActive()) {
          if (typeof t.value != "string" || (n = e.dataTypeMatcher) != null && n.call(e, t.value))
            return e.valueFormatter(t);
          if (!this.gos.get("suppressGroupMaintainValueType"))
            return;
        }
        return e.valueFormatter(t);
      };
  }
  updateColDefAndGetColumnType(e, t, r) {
    let { cellDataType: n } = t;
    const { field: i } = t;
    if (n === void 0 && (n = e.cellDataType), (n == null || n === !0) && (n = this.canInferCellDataType(e, t) ? this.inferCellDataType(i, r) : !1), !n) {
      e.cellDataType = !1;
      return;
    }
    const o = this.dataTypeDefinitions[n];
    if (!o) {
      Se(`Missing data type definition - "${n}"`);
      return;
    }
    return e.cellDataType = n, o.groupSafeValueFormatter && (e.valueFormatter = o.groupSafeValueFormatter), o.valueParser && (e.valueParser = o.valueParser), o.suppressDefaultProperties || this.setColDefPropertiesForBaseDataType(e, n, o, r), o.columnTypes;
  }
  addColumnListeners(e) {
    if (!this.isWaitingForRowData)
      return;
    const t = this.columnStateUpdatesPendingInference[e.getColId()];
    if (!t)
      return;
    const r = (n) => {
      t.add(n.key);
    };
    e.addEventListener("columnStateUpdated", r), this.columnStateUpdateListenerDestroyFuncs.push(
      () => e.removeEventListener("columnStateUpdated", r)
    );
  }
  canInferCellDataType(e, t) {
    if (this.rowModel.getType() !== "clientSide")
      return !1;
    const r = { cellRenderer: !0, valueGetter: !0, valueParser: !0, refData: !0 };
    if (this.doColDefPropsPreventInference(t, r))
      return !1;
    const n = t.type === null ? e.type : t.type;
    if (n) {
      const i = this.gos.get("columnTypes") ?? {};
      if (v0(n).some((a) => {
        const s = i[a.trim()];
        return s && this.doColDefPropsPreventInference(s, r);
      }))
        return !1;
    }
    return !this.doColDefPropsPreventInference(e, r);
  }
  doColDefPropsPreventInference(e, t) {
    return [
      ["cellRenderer", "agSparklineCellRenderer"],
      ["valueGetter", void 0],
      ["valueParser", void 0],
      ["refData", void 0]
    ].some(
      ([r, n]) => this.doesColDefPropPreventInference(e, t, r, n)
    );
  }
  doesColDefPropPreventInference(e, t, r, n) {
    if (!t[r])
      return !1;
    const i = e[r];
    return i === null ? (t[r] = !1, !1) : n === void 0 ? !!i : i === n;
  }
  inferCellDataType(e, t) {
    if (!e)
      return;
    let r;
    const n = this.getInitialData();
    if (n) {
      const o = e.indexOf(".") >= 0 && !this.gos.get("suppressFieldDotNotation");
      r = ug(n, e, o);
    } else
      this.initWaitForRowData(t);
    if (r == null)
      return;
    const [i] = Object.entries(this.dataTypeMatchers).find(
      ([o, a]) => a(r)
    ) ?? ["object"];
    return i;
  }
  getInitialData() {
    const e = this.gos.get("rowData");
    if (e != null && e.length)
      return e[0];
    if (this.initialData)
      return this.initialData;
    {
      const t = this.rowModel.getRootNode().allLeafChildren;
      if (t != null && t.length)
        return t[0].data;
    }
    return null;
  }
  initWaitForRowData(e) {
    if (this.columnStateUpdatesPendingInference[e] = /* @__PURE__ */ new Set(), this.isWaitingForRowData)
      return;
    this.isWaitingForRowData = !0;
    const t = this.isColumnTypeOverrideInDataTypeDefinitions;
    t && this.columnModel.queueResizeOperations();
    const [r] = this.addManagedEventListeners({
      rowDataUpdateStarted: (n) => {
        const { firstRowData: i } = n;
        if (!i)
          return;
        r == null || r(), this.isWaitingForRowData = !1, this.processColumnsPendingInference(i, t), this.columnStateUpdatesPendingInference = {}, t && this.columnModel.processResizeOperations();
        const o = {
          type: "dataTypesInferred"
        };
        this.eventService.dispatchEvent(o);
      }
    });
  }
  isPendingInference() {
    return this.isWaitingForRowData;
  }
  processColumnsPendingInference(e, t) {
    this.initialData = e;
    const r = [];
    this.destroyColumnStateUpdateListeners();
    const n = {}, i = {};
    Object.entries(this.columnStateUpdatesPendingInference).forEach(([o, a]) => {
      const s = this.columnModel.getCol(o);
      if (!s)
        return;
      const l = s.getColDef();
      if (!this.columnModel.resetColDefIntoCol(s, "cellDataTypeInferred"))
        return;
      const u = s.getColDef();
      if (t && u.type && u.type !== l.type) {
        const c = this.getUpdatedColumnState(s, a);
        c.rowGroup && c.rowGroupIndex == null && (n[o] = c), c.pivot && c.pivotIndex == null && (i[o] = c), r.push(c);
      }
    }), t && r.push(
      ...this.funcColsService.generateColumnStateForRowGroupAndPivotIndexes(
        n,
        i
      )
    ), r.length && this.columnApplyStateService.applyColumnState({ state: r }, "cellDataTypeInferred"), this.initialData = null;
  }
  getUpdatedColumnState(e, t) {
    const r = this.columnApplyStateService.getColumnStateFromColDef(e);
    return t.forEach((n) => {
      delete r[n], n === "rowGroup" ? delete r.rowGroupIndex : n === "pivot" && delete r.pivotIndex;
    }), r;
  }
  checkObjectValueHandlers(e) {
    const t = this.dataTypeDefinitions.object, r = e.object;
    this.hasObjectValueParser = t.valueParser !== r.valueParser, this.hasObjectValueFormatter = t.valueFormatter !== r.valueFormatter;
  }
  getDateStringTypeDefinition(e) {
    return e ? this.getDataTypeDefinition(e) ?? this.dataTypeDefinitions.dateString : this.dataTypeDefinitions.dateString;
  }
  getDateParserFunction(e) {
    return this.getDateStringTypeDefinition(e).dateParser;
  }
  getDateFormatterFunction(e) {
    return this.getDateStringTypeDefinition(e).dateFormatter;
  }
  getDataTypeDefinition(e) {
    const t = e.getColDef();
    if (t.cellDataType)
      return this.dataTypeDefinitions[t.cellDataType];
  }
  getBaseDataType(e) {
    var t;
    return (t = this.getDataTypeDefinition(e)) == null ? void 0 : t.baseDataType;
  }
  checkType(e, t) {
    var n;
    if (t == null)
      return !0;
    const r = (n = this.getDataTypeDefinition(e)) == null ? void 0 : n.dataTypeMatcher;
    return r ? r(t) : !0;
  }
  validateColDef(e) {
    e.cellDataType === "object" && (e.valueFormatter === this.dataTypeDefinitions.object.groupSafeValueFormatter && !this.hasObjectValueFormatter && Se(
      'Cell data type is "object" but no value formatter has been provided. Please either provide an object data type definition with a value formatter, or set "colDef.valueFormatter"'
    ), e.editable && e.valueParser === this.dataTypeDefinitions.object.valueParser && !this.hasObjectValueParser && Se(
      'Cell data type is "object" but no value parser has been provided. Please either provide an object data type definition with a value parser, or set "colDef.valueParser"'
    ));
  }
  getFormatValue(e) {
    return this.formatValueFuncs[e];
  }
  setColDefPropertiesForBaseDataType(e, t, r, n) {
    const i = this.formatValueFuncs[t], o = Xn.__isRegistered("@ag-grid-enterprise/set-filter", this.gridId), a = this.localeService.getLocaleTextFunc(), s = (l) => {
      const { filterParams: u } = e;
      e.filterParams = typeof u == "object" ? {
        ...u,
        ...l
      } : l;
    };
    switch (r.baseDataType) {
      case "number": {
        e.cellEditor = "agNumberCellEditor", o && s({
          comparator: (l, u) => {
            const c = l == null ? 0 : parseInt(l), d = u == null ? 0 : parseInt(u);
            return c === d ? 0 : c > d ? 1 : -1;
          }
        });
        break;
      }
      case "boolean": {
        e.cellEditor = "agCheckboxCellEditor", e.cellRenderer = "agCheckboxCellRenderer", e.suppressKeyboardEvent = (l) => !!l.colDef.editable && l.event.key === ae.SPACE, s(o ? {
          valueFormatter: (l) => Me(l.value) ? a(String(l.value), l.value ? "True" : "False") : a("blanks", "(Blanks)")
        } : {
          maxNumConditions: 1,
          debounceMs: 0,
          filterOptions: [
            "empty",
            {
              displayKey: "true",
              displayName: "True",
              predicate: (l, u) => u,
              numberOfInputs: 0
            },
            {
              displayKey: "false",
              displayName: "False",
              predicate: (l, u) => u === !1,
              numberOfInputs: 0
            }
          ]
        });
        break;
      }
      case "date": {
        e.cellEditor = "agDateCellEditor", e.keyCreator = i, o && s({
          valueFormatter: (l) => {
            const u = i(l);
            return Me(u) ? u : a("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListFormatter: (l, u) => {
            if (u === 1 && l != null) {
              const c = WG[Number(l) - 1];
              return a(c, $G[c]);
            }
            return l ?? a("blanks", "(Blanks)");
          }
        });
        break;
      }
      case "dateString": {
        e.cellEditor = "agDateStringCellEditor", e.keyCreator = i;
        const l = r.dateParser;
        s(o ? {
          valueFormatter: (u) => {
            const c = i(u);
            return Me(c) ? c : a("blanks", "(Blanks)");
          },
          treeList: !0,
          treeListPathGetter: (u) => {
            const c = l(u ?? void 0);
            return c ? [String(c.getFullYear()), String(c.getMonth() + 1), String(c.getDate())] : null;
          },
          treeListFormatter: (u, c) => {
            if (c === 1 && u != null) {
              const d = WG[Number(u) - 1];
              return a(d, $G[d]);
            }
            return u ?? a("blanks", "(Blanks)");
          }
        } : {
          comparator: (u, c) => {
            const d = l(c);
            return c == null || d < u ? -1 : d > u ? 1 : 0;
          }
        });
        break;
      }
      case "object": {
        e.cellEditorParams = {
          useFormatter: !0
        }, e.comparator = (l, u) => {
          const c = this.columnModel.getColDefCol(n), d = c == null ? void 0 : c.getColDef();
          if (!c || !d)
            return 0;
          const h = l == null ? "" : i({ column: c, node: null, value: l }), f = u == null ? "" : i({ column: c, node: null, value: u });
          return h === f ? 0 : h > f ? 1 : -1;
        }, e.keyCreator = i, o ? s({
          valueFormatter: (l) => {
            const u = i(l);
            return Me(u) ? u : a("blanks", "(Blanks)");
          }
        }) : e.filterValueGetter = (l) => i({
          column: l.column,
          node: l.node,
          value: this.valueService.getValue(l.column, l.node)
        });
        break;
      }
    }
  }
  getDefaultDataTypes() {
    const e = (r) => !!r.match("^\\d{4}-\\d{2}-\\d{2}$"), t = this.localeService.getLocaleTextFunc();
    return {
      number: {
        baseDataType: "number",
        // can be empty space with legacy copy
        valueParser: (r) => {
          var n, i;
          return ((i = (n = r.newValue) == null ? void 0 : n.trim) == null ? void 0 : i.call(n)) === "" ? null : Number(r.newValue);
        },
        valueFormatter: (r) => r.value == null ? "" : typeof r.value != "number" || isNaN(r.value) ? t("invalidNumber", "Invalid Number") : String(r.value),
        dataTypeMatcher: (r) => typeof r == "number"
      },
      text: {
        baseDataType: "text",
        valueParser: (r) => r.newValue === "" ? null : CT(r.newValue),
        dataTypeMatcher: (r) => typeof r == "string"
      },
      boolean: {
        baseDataType: "boolean",
        valueParser: (r) => {
          var n, i;
          return r.newValue == null ? r.newValue : ((i = (n = r.newValue) == null ? void 0 : n.trim) == null ? void 0 : i.call(n)) === "" ? null : String(r.newValue).toLowerCase() === "true";
        },
        valueFormatter: (r) => r.value == null ? "" : String(r.value),
        dataTypeMatcher: (r) => typeof r == "boolean"
      },
      date: {
        baseDataType: "date",
        valueParser: (r) => Oi(r.newValue == null ? null : String(r.newValue)),
        valueFormatter: (r) => r.value == null ? "" : !(r.value instanceof Date) || isNaN(r.value.getTime()) ? t("invalidDate", "Invalid Date") : Io(r.value, !1) ?? "",
        dataTypeMatcher: (r) => r instanceof Date
      },
      dateString: {
        baseDataType: "dateString",
        dateParser: (r) => Oi(r) ?? void 0,
        dateFormatter: (r) => Io(r ?? null, !1) ?? void 0,
        valueParser: (r) => e(String(r.newValue)) ? r.newValue : null,
        valueFormatter: (r) => e(String(r.value)) ? r.value : "",
        dataTypeMatcher: (r) => typeof r == "string" && e(r)
      },
      object: {
        baseDataType: "object",
        valueParser: () => null,
        valueFormatter: (r) => CT(r.value) ?? ""
      }
    };
  }
  destroyColumnStateUpdateListeners() {
    this.columnStateUpdateListenerDestroyFuncs.forEach((e) => e()), this.columnStateUpdateListenerDestroyFuncs = [];
  }
  destroy() {
    this.dataTypeDefinitions = {}, this.dataTypeMatchers = {}, this.formatValueFuncs = {}, this.columnStateUpdatesPendingInference = {}, this.destroyColumnStateUpdateListeners(), super.destroy();
  }
}, SGe = {
  version: Et,
  moduleName: "@ag-grid-community/data-type",
  beans: [CGe]
}, wGe = {
  version: Et,
  moduleName: "@ag-grid-community/column-api",
  apiFunctions: {
    getColumnDef: D4e,
    getColumnDefs: A4e,
    sizeColumnsToFit: I4e,
    setColumnGroupOpened: F4e,
    getColumnGroup: L4e,
    getProvidedColumnGroup: O4e,
    getDisplayNameForColumn: N4e,
    getDisplayNameForColumnGroup: k4e,
    getColumn: V4e,
    getColumns: B4e,
    applyColumnState: G4e,
    getColumnState: H4e,
    resetColumnState: z4e,
    getColumnGroupState: $4e,
    setColumnGroupState: W4e,
    resetColumnGroupState: j4e,
    isPinning: U4e,
    isPinningLeft: K4e,
    isPinningRight: Y4e,
    getDisplayedColAfter: q4e,
    getDisplayedColBefore: Z4e,
    setColumnVisible: X4e,
    setColumnsVisible: Q4e,
    setColumnPinned: J4e,
    setColumnsPinned: eGe,
    getAllGridColumns: tGe,
    getDisplayedLeftColumns: rGe,
    getDisplayedCenterColumns: nGe,
    getDisplayedRightColumns: iGe,
    getAllDisplayedColumns: oGe,
    getAllDisplayedVirtualColumns: aGe,
    moveColumn: sGe,
    moveColumnByIndex: lGe,
    moveColumns: uGe,
    setColumnWidth: cGe,
    setColumnWidths: dGe,
    getLeftDisplayedColumnGroups: hGe,
    getCenterDisplayedColumnGroups: fGe,
    getRightDisplayedColumnGroups: pGe,
    getAllDisplayedColumnGroups: gGe,
    autoSizeColumn: vGe,
    autoSizeColumns: mGe,
    autoSizeAllColumns: yGe
  }
};
function bGe(e, t) {
  e.ctrlsService.getGridBodyCtrl().getRowDragFeature().addRowDropZone(t);
}
function xGe(e, t) {
  const r = e.dragAndDropService.findExternalZone(t);
  r && e.dragAndDropService.removeDropTarget(r);
}
function EGe(e, t) {
  return e.ctrlsService.getGridBodyCtrl().getRowDragFeature().getRowDropZone(t);
}
var RGe = {
  version: Et,
  moduleName: "@ag-grid-community/drag-api",
  apiFunctions: {
    addRowDropZone: bGe,
    removeRowDropZone: xGe,
    getRowDropZoneParams: EGe
  }
};
function _Ge(e) {
  return e.pinnedRowModel.getPinnedTopRowCount();
}
function TGe(e) {
  return e.pinnedRowModel.getPinnedBottomRowCount();
}
function PGe(e, t) {
  return e.pinnedRowModel.getPinnedTopRow(t);
}
function MGe(e, t) {
  return e.pinnedRowModel.getPinnedBottomRow(t);
}
var DGe = {
  version: Et,
  moduleName: "@ag-grid-community/pinned-row-api",
  apiFunctions: {
    getPinnedTopRowCount: _Ge,
    getPinnedBottomRowCount: TGe,
    getPinnedTopRow: PGe,
    getPinnedBottomRow: MGe
  }
};
function AGe(e) {
  e.overlayService.showLoadingOverlay();
}
function IGe(e) {
  e.overlayService.showNoRowsOverlay();
}
function FGe(e) {
  e.overlayService.hideOverlay();
}
var LGe = {
  version: Et,
  moduleName: "@ag-grid-community/overlay-api",
  apiFunctions: {
    showLoadingOverlay: AGe,
    showNoRowsOverlay: IGe,
    hideOverlay: FGe
  }
};
function OGe(e, t, r) {
  if (!t)
    return;
  const n = e.ctrlsService.getGridBodyCtrl().getGui(), i = `aria-${t}`;
  r === null ? n.removeAttribute(i) : n.setAttribute(i, r);
}
function NGe(e, t = {}) {
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.refreshCells(t));
}
function kGe(e, t = {}) {
  const r = (n) => Se(
    `Since v31.1 api.flashCells parameter '${n}Delay' is deprecated. Please use '${n}Duration' instead.`
  );
  Me(t.fadeDelay) && r("fade"), Me(t.flashDelay) && r("flash"), e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.flashCells(t));
}
function VGe(e) {
  e.frameworkOverrides.wrapIncoming(
    () => e.ctrlsService.getHeaderRowContainerCtrls().forEach((t) => t.refresh())
  );
}
function BGe(e) {
  return e.animationFrameService.isQueueEmpty();
}
function GGe(e) {
  e.animationFrameService.flushAllFrames();
}
function HGe(e) {
  return {
    rowHeight: e.gos.getRowHeightAsNumber(),
    headerHeight: e.columnModel.getHeaderHeight()
  };
}
function zGe(e, t = {}) {
  return e.rowRenderer.getCellRendererInstances(t).map(dg);
}
var $Ge = {
  version: Et,
  moduleName: "@ag-grid-community/render-api",
  apiFunctions: {
    setGridAriaProperty: OGe,
    refreshCells: NGe,
    flashCells: kGe,
    refreshHeader: VGe,
    isAnimationFrameQueueEmpty: BGe,
    flushAllAnimationFrames: GGe,
    getSizesForCurrentTheme: HGe,
    getCellRendererInstances: zGe
  }
};
function WGe(e) {
  e.valueCache.expire();
}
function jGe(e, t, r) {
  return yY(e, { colKey: t, rowNode: r });
}
function yY(e, t) {
  const { colKey: r, rowNode: n, useFormatter: i } = t, o = e.columnModel.getColDefCol(r) ?? e.columnModel.getCol(r);
  if (Zt(o))
    return null;
  const a = e.valueService.getValue(o, n);
  return i ? e.valueService.formatValue(o, n, a) ?? Za(a, !0) : a;
}
function UGe(e) {
  return e.context.getGridId();
}
function KGe(e) {
  e.gridDestroyService.destroy();
}
function YGe(e) {
  return e.gridDestroyService.isDestroyCalled();
}
function qGe(e, t) {
  return e.gos.get(t);
}
function ZGe(e, t, r) {
  CY(e, { [t]: r });
}
function CY(e, t) {
  e.gos.updateGridOptions({ options: t });
}
function XGe(e, t, r) {
  e.apiEventService.addEventListener(t, r);
}
function QGe(e, t, r) {
  e.apiEventService.removeEventListener(t, r);
}
function JGe(e, t) {
  e.apiEventService.addGlobalListener(t);
}
function eHe(e, t) {
  e.apiEventService.removeGlobalListener(t);
}
function tHe(e) {
  return e.focusService.getFocusedCell();
}
function rHe(e) {
  return e.focusService.clearFocusedCell();
}
function nHe(e, t, r, n) {
  e.focusService.setFocusedCell({ rowIndex: t, column: r, rowPinned: n, forceBrowserFocus: !0 });
}
function iHe(e, t) {
  return e.navigationService.tabToNextCell(!1, t);
}
function oHe(e, t) {
  return e.navigationService.tabToNextCell(!0, t);
}
function aHe(e, t, r = !1) {
  const n = e.headerNavigationService.getHeaderPositionForColumn(t, r);
  n && e.focusService.focusHeaderPosition({ headerPosition: n });
}
function sHe(e, t, r) {
  const n = e.columnModel.getCol(t);
  e.menuService.showColumnMenu({
    column: n,
    buttonElement: r,
    positionBy: "button"
  });
}
function lHe(e, t, r) {
  let n = e.columnModel.getCol(t);
  if (n || (n = e.columnModel.getColDefCol(t)), !n) {
    sr(`column '${t}' not found`);
    return;
  }
  e.menuService.showColumnMenu({
    column: n,
    mouseEvent: r,
    positionBy: "mouse"
  });
}
function uHe(e, t) {
  const r = e.columnModel.getCol(t);
  if (!r) {
    sr(`column '${t}' not found`);
    return;
  }
  e.menuService.showColumnMenu({
    column: r,
    positionBy: "auto"
  });
}
function cHe(e) {
  e.menuService.hidePopupMenu();
}
function dHe(e, t = {}) {
  const r = t ? t.rowNodes : void 0;
  e.frameworkOverrides.wrapIncoming(() => e.rowRenderer.redrawRows(r));
}
function hHe(e, t, r, n, i) {
  e.expansionService.setRowNodeExpanded(t, r, n, i);
}
function fHe(e, t) {
  return e.rowModel.getRowNode(t);
}
function pHe(e, t, r, n) {
  e.rowRenderer.addRenderedRowListener(t, r, n);
}
function gHe(e) {
  return e.rowRenderer.getRenderedNodes();
}
function vHe(e, t, r) {
  e.rowModel.forEachNode(t, r);
}
function mHe(e) {
  return SY(e);
}
function SY(e) {
  return e.rowRenderer.getFirstVirtualRenderedRow();
}
function yHe(e) {
  return wY(e);
}
function wY(e) {
  return e.rowRenderer.getLastVirtualRenderedRow();
}
function CHe(e, t) {
  return e.rowModel.getRow(t);
}
function SHe(e) {
  return e.rowModel.getRowCount();
}
function wHe(e) {
  return e.rowModel;
}
function bHe(e, t) {
  if (!t.nodes.every((s) => s.rowPinned ? (Se("cannot select pinned rows"), !1) : s.id === void 0 ? (Se("cannot select node until id for node is known"), !1) : !0))
    return;
  const { nodes: n, source: i, newValue: o } = t, a = n;
  e.selectionService.setNodesSelected({ nodes: a, source: i ?? "api", newValue: o });
}
function xHe(e, t = "apiSelectAll") {
  e.selectionService.selectAllRowNodes({ source: t });
}
function EHe(e, t = "apiSelectAll") {
  e.selectionService.deselectAllRowNodes({ source: t });
}
function RHe(e, t = "apiSelectAllFiltered") {
  e.selectionService.selectAllRowNodes({ source: t, justFiltered: !0 });
}
function _He(e, t = "apiSelectAllFiltered") {
  e.selectionService.deselectAllRowNodes({ source: t, justFiltered: !0 });
}
function THe(e, t = "apiSelectAllCurrentPage") {
  e.selectionService.selectAllRowNodes({ source: t, justCurrentPage: !0 });
}
function PHe(e, t = "apiSelectAllCurrentPage") {
  e.selectionService.deselectAllRowNodes({ source: t, justCurrentPage: !0 });
}
function MHe(e) {
  return e.selectionService.getSelectedNodes();
}
function DHe(e) {
  return e.selectionService.getSelectedRows();
}
function AHe(e) {
  e.sortController.onSortChanged("api");
}
var IHe = {
  version: Et,
  moduleName: "@ag-grid-community/core-api",
  apiFunctions: {
    getGridId: UGe,
    destroy: KGe,
    isDestroyed: YGe,
    getGridOption: qGe,
    setGridOption: ZGe,
    updateGridOptions: CY
  }
}, FHe = {
  version: Et,
  moduleName: "@ag-grid-community/row-selection-api",
  apiFunctions: {
    setNodesSelected: bHe,
    selectAll: xHe,
    deselectAll: EHe,
    selectAllFiltered: RHe,
    deselectAllFiltered: _He,
    selectAllOnCurrentPage: THe,
    deselectAllOnCurrentPage: PHe,
    getSelectedNodes: MHe,
    getSelectedRows: DHe
  }
}, LHe = {
  version: Et,
  moduleName: "@ag-grid-community/row-api",
  apiFunctions: {
    redrawRows: dHe,
    setRowNodeExpanded: hHe,
    getRowNode: fHe,
    addRenderedRowListener: pHe,
    getRenderedNodes: gHe,
    forEachNode: vHe,
    getFirstDisplayedRow: mHe,
    getFirstDisplayedRowIndex: SY,
    getLastDisplayedRow: yHe,
    getLastDisplayedRowIndex: wY,
    getDisplayedRowAtIndex: CHe,
    getDisplayedRowCount: SHe,
    getModel: wHe
  }
}, OHe = {
  version: Et,
  moduleName: "@ag-grid-community/scroll-api",
  apiFunctions: {
    getVerticalPixelRange: CBe,
    getHorizontalPixelRange: SBe,
    ensureColumnVisible: fY,
    ensureIndexVisible: pY,
    ensureNodeVisible: wBe
  }
}, NHe = {
  version: Et,
  moduleName: "@ag-grid-community/keyboard-navigation-api",
  apiFunctions: {
    getFocusedCell: tHe,
    clearFocusedCell: rHe,
    setFocusedCell: nHe,
    setFocusedHeader: aHe,
    tabToNextCell: iHe,
    tabToPreviousCell: oHe
  }
}, kHe = {
  version: Et,
  moduleName: "@ag-grid-community/event-api",
  apiFunctions: {
    addEventListener: XGe,
    addGlobalListener: JGe,
    removeEventListener: QGe,
    removeGlobalListener: eHe
  }
}, VHe = {
  version: Et,
  moduleName: "@ag-grid-community/cell-api",
  apiFunctions: {
    expireValueCache: WGe,
    getValue: jGe,
    getCellValue: yY
  }
}, BHe = {
  version: Et,
  moduleName: "@ag-grid-community/menu-api",
  apiFunctions: {
    showColumnMenuAfterButtonClick: sHe,
    showColumnMenuAfterMouseClick: lHe,
    showColumnMenu: uHe,
    hidePopupMenu: cHe
  }
}, GHe = {
  version: Et,
  moduleName: "@ag-grid-community/sort-api",
  apiFunctions: {
    onSortChanged: AHe
  }
}, HHe = {
  version: Et,
  moduleName: "@ag-grid-community/api",
  dependantModules: [
    IHe,
    DGe,
    FHe,
    wGe,
    LHe,
    RGe,
    OHe,
    LGe,
    NHe,
    kHe,
    $Ge,
    VHe,
    BHe,
    GHe
  ]
};
function zHe(e) {
  var t;
  return ((t = e.stateService) == null ? void 0 : t.getState()) ?? {};
}
var $He = class extends he {
  constructor() {
    super(...arguments), this.beanName = "stateService", this.suppressEvents = !0, this.queuedUpdateSources = /* @__PURE__ */ new Set(), this.dispatchStateUpdateEventDebounced = vi(() => this.dispatchQueuedStateUpdateEvents(), 0), this.onRowGroupOpenedDebounced = vi(
      () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()),
      0
    ), this.onRowSelectedDebounced = vi(() => {
      this.staleStateKeys.delete("rowSelection"), this.updateCachedState("rowSelection", this.getRowSelectionState());
    }, 0), this.staleStateKeys = /* @__PURE__ */ new Set();
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.ctrlsService = e.ctrlsService, this.pivotResultColsService = e.pivotResultColsService, this.focusService = e.focusService, this.columnModel = e.columnModel, this.visibleColsService = e.visibleColsService, this.columnGroupStateService = e.columnGroupStateService, this.columnGetStateService = e.columnGetStateService, this.paginationService = e.paginationService, this.rowModel = e.rowModel, this.selectionService = e.selectionService, this.expansionService = e.expansionService, this.columnAnimationService = e.columnAnimationService, this.columnApplyStateService = e.columnApplyStateService, this.sideBarService = e.sideBarService, this.rangeService = e.rangeService;
  }
  postConstruct() {
    this.isClientSideRowModel = this.rowModel.getType() === "clientSide", this.cachedState = this.gos.get("initialState") ?? {}, this.ctrlsService.whenReady(() => this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnGridReady()));
    const [e, t, r] = this.addManagedEventListeners({
      newColumnsLoaded: ({ source: n }) => {
        n === "gridInitializing" && (e(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnColumnsInitialised()));
      },
      rowCountReady: () => {
        t == null || t(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnRowCountReady());
      },
      firstDataRendered: () => {
        r == null || r(), this.suppressEventsAndDispatchInitEvent(() => this.setupStateOnFirstDataRendered());
      }
    });
  }
  getState() {
    return this.staleStateKeys.size && this.refreshStaleState(), this.cachedState;
  }
  setupStateOnGridReady() {
    this.updateCachedState("sideBar", this.getSideBarState());
    const e = () => this.updateCachedState("sideBar", this.getSideBarState());
    this.addManagedEventListeners({
      toolPanelVisibleChanged: e,
      sideBarUpdated: e
    });
  }
  setupStateOnColumnsInitialised() {
    const e = this.gos.get("initialState") ?? {};
    this.setColumnState(e), this.setColumnGroupState(e), this.updateColumnState([
      "aggregation",
      "columnOrder",
      "columnPinning",
      "columnSizing",
      "columnVisibility",
      "pivot",
      "pivot",
      "rowGroup",
      "sort"
    ]), this.updateCachedState("columnGroup", this.getColumnGroupState()), this.addManagedEventListeners({
      columnValueChanged: () => this.updateColumnState(["aggregation"]),
      columnMoved: () => this.updateColumnState(["columnOrder"]),
      columnPinned: () => this.updateColumnState(["columnPinning"]),
      columnResized: () => this.updateColumnState(["columnSizing"]),
      columnVisible: () => this.updateColumnState(["columnVisibility"]),
      columnPivotChanged: () => this.updateColumnState(["pivot"]),
      columnPivotModeChanged: () => this.updateColumnState(["pivot"]),
      columnRowGroupChanged: () => this.updateColumnState(["rowGroup"]),
      sortChanged: () => this.updateColumnState(["sort"]),
      newColumnsLoaded: () => this.updateColumnState([
        "aggregation",
        "columnOrder",
        "columnPinning",
        "columnSizing",
        "columnVisibility",
        "pivot",
        "rowGroup",
        "sort"
      ]),
      columnGroupOpened: () => this.updateCachedState("columnGroup", this.getColumnGroupState())
    });
  }
  setupStateOnRowCountReady() {
    const {
      filter: e,
      rowGroupExpansion: t,
      rowSelection: r,
      pagination: n
    } = this.gos.get("initialState") ?? {}, i = this.gos.get("advancedFilterModel");
    (e || i) && this.setFilterState(e, i), t && this.setRowGroupExpansionState(t), r && this.setRowSelectionState(r), n && this.setPaginationState(n), this.updateCachedState("filter", this.getFilterState()), this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()), this.updateCachedState("rowSelection", this.getRowSelectionState()), this.updateCachedState("pagination", this.getPaginationState()), this.addManagedEventListeners({
      filterChanged: () => this.updateCachedState("filter", this.getFilterState()),
      rowGroupOpened: () => this.onRowGroupOpenedDebounced(),
      expandOrCollapseAll: () => this.updateCachedState("rowGroupExpansion", this.getRowGroupExpansionState()),
      selectionChanged: () => {
        this.staleStateKeys.add("rowSelection"), this.onRowSelectedDebounced();
      },
      paginationChanged: (o) => {
        (o.newPage || o.newPageSize) && this.updateCachedState("pagination", this.getPaginationState());
      }
    });
  }
  setupStateOnFirstDataRendered() {
    const {
      scroll: e,
      rangeSelection: t,
      focusedCell: r,
      columnOrder: n
    } = this.gos.get("initialState") ?? {};
    r && this.setFocusedCellState(r), t && this.setRangeSelectionState(t), e && this.setScrollState(e), this.setColumnPivotState(!!(n != null && n.orderedColIds)), this.updateCachedState("sideBar", this.getSideBarState()), this.updateCachedState("focusedCell", this.getFocusedCellState()), this.updateCachedState("rangeSelection", this.getRangeSelectionState()), this.updateCachedState("scroll", this.getScrollState()), this.addManagedEventListeners({
      cellFocused: () => this.updateCachedState("focusedCell", this.getFocusedCellState()),
      rangeSelectionChanged: (i) => {
        i.finished && this.updateCachedState("rangeSelection", this.getRangeSelectionState());
      },
      bodyScrollEnd: () => this.updateCachedState("scroll", this.getScrollState())
    });
  }
  getColumnState() {
    const e = this.columnModel.isPivotMode(), t = [], r = [], n = [], i = [], o = [], a = [], s = [], l = [], u = [], c = this.columnGetStateService.getColumnState();
    for (let d = 0; d < c.length; d++) {
      const {
        colId: h,
        sort: f,
        sortIndex: p,
        rowGroup: g,
        rowGroupIndex: v,
        aggFunc: m,
        pivot: y,
        pivotIndex: C,
        pinned: S,
        hide: b,
        width: w,
        flex: x
      } = c[d];
      u.push(h), f && (t[p ?? 0] = { colId: h, sort: f }), g && (r[v ?? 0] = h), typeof m == "string" && n.push({ colId: h, aggFunc: m }), y && (i[C ?? 0] = h), S && (S === "right" ? a : o).push(h), b && s.push(h), (x || w) && l.push({ colId: h, flex: x ?? void 0, width: w });
    }
    return {
      sort: t.length ? { sortModel: t } : void 0,
      rowGroup: r.length ? { groupColIds: r } : void 0,
      aggregation: n.length ? { aggregationModel: n } : void 0,
      pivot: i.length || e ? { pivotMode: e, pivotColIds: i } : void 0,
      columnPinning: o.length || a.length ? { leftColIds: o, rightColIds: a } : void 0,
      columnVisibility: s.length ? { hiddenColIds: s } : void 0,
      columnSizing: l.length ? { columnSizingModel: l } : void 0,
      columnOrder: u.length ? { orderedColIds: u } : void 0
    };
  }
  setColumnState(e) {
    const {
      sort: t,
      rowGroup: r,
      aggregation: n,
      pivot: i,
      columnPinning: o,
      columnVisibility: a,
      columnSizing: s,
      columnOrder: l
    } = e, u = {}, c = (p) => {
      let g = u[p];
      return g || (g = { colId: p }, u[p] = g, g);
    };
    t && t.sortModel.forEach(({ colId: p, sort: g }, v) => {
      const m = c(p);
      m.sort = g, m.sortIndex = v;
    }), r && r.groupColIds.forEach((p, g) => {
      const v = c(p);
      v.rowGroup = !0, v.rowGroupIndex = g;
    }), n && n.aggregationModel.forEach(({ colId: p, aggFunc: g }) => {
      c(p).aggFunc = g;
    }), i && (i.pivotColIds.forEach((p, g) => {
      const v = c(p);
      v.pivot = !0, v.pivotIndex = g;
    }), this.gos.updateGridOptions({
      options: { pivotMode: i.pivotMode },
      source: "gridInitializing"
    })), o && (o.leftColIds.forEach((p) => {
      c(p).pinned = "left";
    }), o.rightColIds.forEach((p) => {
      c(p).pinned = "right";
    })), a && a.hiddenColIds.forEach((p) => {
      c(p).hide = !0;
    }), s && s.columnSizingModel.forEach(({ colId: p, flex: g, width: v }) => {
      const m = c(p);
      m.flex = g ?? null, m.width = v;
    });
    const d = l == null ? void 0 : l.orderedColIds, h = !!(d != null && d.length), f = h ? d.map((p) => c(p)) : Object.values(u);
    if (f.length) {
      this.columnStates = f;
      const p = {
        sort: null,
        sortIndex: null,
        rowGroup: null,
        rowGroupIndex: null,
        aggFunc: null,
        pivot: null,
        pivotIndex: null,
        pinned: null,
        hide: null,
        flex: null
      };
      this.columnApplyStateService.applyColumnState(
        {
          state: f,
          applyOrder: h,
          defaultState: p
        },
        "gridInitializing"
      );
    }
  }
  setColumnPivotState(e) {
    const t = this.columnStates;
    this.columnStates = void 0;
    const r = this.columnGroupStates;
    if (this.columnGroupStates = void 0, !!this.pivotResultColsService.isPivotResultColsPresent()) {
      if (t) {
        const n = [];
        for (const i of t)
          this.pivotResultColsService.getPivotResultCol(i.colId) && n.push(i);
        this.columnApplyStateService.applyColumnState(
          {
            state: n,
            applyOrder: e
          },
          "gridInitializing"
        );
      }
      r && this.columnGroupStateService.setColumnGroupState(r, "gridInitializing");
    }
  }
  getColumnGroupState() {
    const e = this.columnGroupStateService.getColumnGroupState(), t = [];
    return e.forEach(({ groupId: r, open: n }) => {
      n && t.push(r);
    }), t.length ? { openColumnGroupIds: t } : void 0;
  }
  setColumnGroupState(e) {
    var i;
    if (!Object.prototype.hasOwnProperty.call(e, "columnGroup"))
      return;
    const t = new Set((i = e.columnGroup) == null ? void 0 : i.openColumnGroupIds), n = this.columnGroupStateService.getColumnGroupState().map(({ groupId: o }) => {
      const a = t.has(o);
      return a && t.delete(o), {
        groupId: o,
        open: a
      };
    });
    t.forEach((o) => {
      n.push({
        groupId: o,
        open: !0
      });
    }), n.length && (this.columnGroupStates = n), this.columnGroupStateService.setColumnGroupState(n, "gridInitializing");
  }
  getFilterState() {
    var r, n;
    let e = (r = this.filterManager) == null ? void 0 : r.getFilterModel();
    e && Object.keys(e).length === 0 && (e = void 0);
    const t = ((n = this.filterManager) == null ? void 0 : n.getAdvancedFilterModel()) ?? void 0;
    return e || t ? { filterModel: e, advancedFilterModel: t } : void 0;
  }
  setFilterState(e, t) {
    var i, o;
    const { filterModel: r, advancedFilterModel: n } = e ?? {
      advancedFilterModel: t
    };
    r && ((i = this.filterManager) == null || i.setFilterModel(r, "columnFilter")), n && ((o = this.filterManager) == null || o.setAdvancedFilterModel(n));
  }
  getRangeSelectionState() {
    var t;
    const e = (t = this.rangeService) == null ? void 0 : t.getCellRanges().map((r) => {
      const { id: n, type: i, startRow: o, endRow: a, columns: s, startColumn: l } = r;
      return {
        id: n,
        type: i,
        startRow: o,
        endRow: a,
        colIds: s.map((u) => u.getColId()),
        startColId: l.getColId()
      };
    });
    return e != null && e.length ? { cellRanges: e } : void 0;
  }
  setRangeSelectionState(e) {
    if (!this.gos.get("enableRangeSelection") || !this.rangeService)
      return;
    const t = [];
    e.cellRanges.forEach((r) => {
      const n = [];
      if (r.colIds.forEach((o) => {
        const a = this.columnModel.getCol(o);
        a && n.push(a);
      }), !n.length)
        return;
      let i = this.columnModel.getCol(r.startColId);
      if (!i) {
        const o = this.visibleColsService.getAllCols(), a = new Set(n);
        i = o.find((s) => a.has(s));
      }
      t.push({
        ...r,
        columns: n,
        startColumn: i
      });
    }), this.rangeService.setCellRanges(t);
  }
  getScrollState() {
    var n;
    if (!this.isClientSideRowModel)
      return;
    const e = (n = this.ctrlsService.getGridBodyCtrl()) == null ? void 0 : n.getScrollFeature(), { left: t } = (e == null ? void 0 : e.getHScrollPosition()) ?? { left: 0 }, { top: r } = (e == null ? void 0 : e.getVScrollPosition()) ?? { top: 0 };
    return r || t ? {
      top: r,
      left: t
    } : void 0;
  }
  setScrollState(e) {
    var n;
    if (!this.isClientSideRowModel)
      return;
    const { top: t, left: r } = e;
    (n = this.ctrlsService.getGridBodyCtrl()) == null || n.getScrollFeature().setScrollPosition(t, r);
  }
  getSideBarState() {
    var e, t;
    return (t = (e = this.sideBarService) == null ? void 0 : e.getSideBarComp()) == null ? void 0 : t.getState();
  }
  getFocusedCellState() {
    if (!this.isClientSideRowModel)
      return;
    const e = this.focusService.getFocusedCell();
    if (e) {
      const { column: t, rowIndex: r, rowPinned: n } = e;
      return {
        colId: t.getColId(),
        rowIndex: r,
        rowPinned: n
      };
    }
  }
  setFocusedCellState(e) {
    if (!this.isClientSideRowModel)
      return;
    const { colId: t, rowIndex: r, rowPinned: n } = e;
    this.focusService.setFocusedCell({
      column: this.columnModel.getCol(t),
      rowIndex: r,
      rowPinned: n,
      forceBrowserFocus: !0,
      preventScrollOnBrowserFocus: !0
    });
  }
  getPaginationState() {
    if (!this.paginationService)
      return;
    const e = this.paginationService.getCurrentPage(), t = this.gos.get("paginationAutoPageSize") ? void 0 : this.paginationService.getPageSize();
    if (!(!e && !t))
      return { page: e, pageSize: t };
  }
  setPaginationState(e) {
    this.paginationService && (e.pageSize && !this.gos.get("paginationAutoPageSize") && this.paginationService.setPageSize(e.pageSize, "initialState"), typeof e.page == "number" && this.paginationService.setPage(e.page));
  }
  getRowSelectionState() {
    var r;
    const e = this.selectionService.getSelectionState();
    return !e || !Array.isArray(e) && (e.selectAll === !1 || e.selectAllChildren === !1) && !((r = e == null ? void 0 : e.toggledNodes) != null && r.length) ? void 0 : e;
  }
  setRowSelectionState(e) {
    this.selectionService.setSelectionState(e, "gridInitializing");
  }
  getRowGroupExpansionState() {
    const e = this.expansionService.getExpandedRows();
    return e.length ? {
      expandedRowGroupIds: e
    } : void 0;
  }
  setRowGroupExpansionState(e) {
    this.expansionService.expandRows(e.expandedRowGroupIds);
  }
  updateColumnState(e) {
    const t = this.getColumnState();
    let r = !1;
    Object.entries(t).forEach(([n, i]) => {
      GC(i, this.cachedState[n]) || (r = !0);
    }), this.cachedState = {
      ...this.cachedState,
      ...t
    }, r && this.dispatchStateUpdateEvent(e);
  }
  updateCachedState(e, t) {
    const r = this.cachedState[e];
    this.setCachedStateValue(e, t), GC(t, r) || this.dispatchStateUpdateEvent([e]);
  }
  setCachedStateValue(e, t) {
    this.cachedState = {
      ...this.cachedState,
      [e]: t
    };
  }
  refreshStaleState() {
    this.staleStateKeys.forEach((e) => {
      switch (e) {
        case "rowSelection":
          this.setCachedStateValue(e, this.getRowSelectionState());
          break;
      }
    }), this.staleStateKeys.clear();
  }
  dispatchStateUpdateEvent(e) {
    this.suppressEvents || (e.forEach((t) => this.queuedUpdateSources.add(t)), this.dispatchStateUpdateEventDebounced());
  }
  dispatchQueuedStateUpdateEvents() {
    const e = Array.from(this.queuedUpdateSources);
    this.queuedUpdateSources.clear();
    const t = {
      type: "stateUpdated",
      sources: e,
      state: this.cachedState
    };
    this.eventService.dispatchEvent(t);
  }
  suppressEventsAndDispatchInitEvent(e) {
    this.suppressEvents = !0, this.columnAnimationService.setSuppressAnimation(!0), e(), setTimeout(() => {
      this.suppressEvents = !1, this.queuedUpdateSources.clear(), this.isAlive() && (this.columnAnimationService.setSuppressAnimation(!1), this.dispatchStateUpdateEvent(["gridInitializing"]));
    });
  }
}, bY = {
  version: Et,
  moduleName: "@ag-grid-community/state-core",
  beans: [$He]
}, WHe = {
  version: Et,
  moduleName: "@ag-grid-community/state-api",
  apiFunctions: {
    getState: zHe
  },
  dependantModules: [bY]
}, jHe = {
  version: Et,
  moduleName: "@ag-grid-community/state",
  dependantModules: [bY, WHe]
};
function UHe(e) {
  return e.rowModel.isLastRowIndexKnown();
}
function KHe(e) {
  var t;
  return ((t = e.paginationService) == null ? void 0 : t.getPageSize()) ?? 100;
}
function YHe(e) {
  var t;
  return ((t = e.paginationService) == null ? void 0 : t.getCurrentPage()) ?? 0;
}
function qHe(e) {
  var t;
  return ((t = e.paginationService) == null ? void 0 : t.getTotalPages()) ?? 1;
}
function ZHe(e) {
  return e.paginationService ? e.paginationService.getMasterRowCount() : e.rowModel.getRowCount();
}
function XHe(e) {
  var t;
  (t = e.paginationService) == null || t.goToNextPage();
}
function QHe(e) {
  var t;
  (t = e.paginationService) == null || t.goToPreviousPage();
}
function JHe(e) {
  var t;
  (t = e.paginationService) == null || t.goToFirstPage();
}
function eze(e) {
  var t;
  (t = e.paginationService) == null || t.goToLastPage();
}
function tze(e, t) {
  var r;
  (r = e.paginationService) == null || r.goToPage(t);
}
var rze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "paginationAutoPageSizeService";
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.paginationService = e.paginationService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => {
      this.centerRowsCtrl = e.center;
      const t = this.checkPageSize.bind(this);
      this.addManagedEventListeners({
        bodyHeightChanged: t,
        scrollVisibilityChanged: t
      }), this.addManagedPropertyListener("paginationAutoPageSize", this.onPaginationAutoSizeChanged.bind(this)), this.checkPageSize();
    });
  }
  notActive() {
    return !this.gos.get("paginationAutoPageSize") || this.centerRowsCtrl == null;
  }
  onPaginationAutoSizeChanged() {
    this.notActive() ? this.paginationService.unsetAutoCalculatedPageSize() : this.checkPageSize();
  }
  checkPageSize() {
    if (this.notActive())
      return;
    const e = this.centerRowsCtrl.getViewportSizeFeature().getBodyHeight();
    if (e > 0) {
      const t = () => {
        const r = Math.max(this.gos.getRowHeightAsNumber(), 1), n = Math.floor(e / r);
        this.paginationService.setPageSize(n, "autoCalculated");
      };
      this.isBodyRendered ? vi(() => t(), 50)() : (t(), this.isBodyRendered = !0);
    } else
      this.isBodyRendered = !1;
  }
};
function nze(e, t, r) {
  e.addManagedElementListeners(t, {
    keydown: (n) => {
      if (!n.defaultPrevented && n.key === ae.TAB) {
        const i = n.shiftKey;
        r.findNextFocusableElement(t, !1, i) || r.focusNextGridCoreContainer(i) && n.preventDefault();
      }
    }
  });
}
var ize = class extends Nr {
  constructor() {
    super(
      /* html */
      '<span class="ag-paging-page-size"></span>'
    ), this.hasEmptyOption = !1, this.handlePageSizeItemSelected = () => {
      if (!this.selectPageSizeComp)
        return;
      const e = this.selectPageSizeComp.getValue();
      if (!e)
        return;
      const t = Number(e);
      isNaN(t) || t < 1 || t === this.paginationService.getPageSize() || (this.paginationService.setPageSize(t, "pageSizeSelector"), this.hasEmptyOption && this.toggleSelectDisplay(!0), this.selectPageSizeComp.getFocusableElement().focus());
    };
  }
  wireBeans(e) {
    this.paginationService = e.paginationService;
  }
  postConstruct() {
    this.addManagedPropertyListener("paginationPageSizeSelector", () => {
      this.onPageSizeSelectorValuesChange();
    }), this.addManagedEventListeners({ paginationChanged: (e) => this.handlePaginationChanged(e) });
  }
  handlePaginationChanged(e) {
    if (!this.selectPageSizeComp || !(e != null && e.newPageSize))
      return;
    const t = this.paginationService.getPageSize();
    this.getPageSizeSelectorValues().includes(t) ? this.selectPageSizeComp.setValue(t.toString()) : this.hasEmptyOption ? this.selectPageSizeComp.setValue("") : this.toggleSelectDisplay(!0);
  }
  toggleSelectDisplay(e) {
    this.selectPageSizeComp && this.reset(), e && (this.reloadPageSizesSelector(), this.selectPageSizeComp && this.appendChild(this.selectPageSizeComp));
  }
  reset() {
    oo(this.getGui()), this.selectPageSizeComp && (this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp));
  }
  onPageSizeSelectorValuesChange() {
    this.selectPageSizeComp && this.shouldShowPageSizeSelector() && this.reloadPageSizesSelector();
  }
  shouldShowPageSizeSelector() {
    return this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel") && !this.gos.get("paginationAutoPageSize") && this.gos.get("paginationPageSizeSelector") !== !1;
  }
  reloadPageSizesSelector() {
    const e = this.getPageSizeSelectorValues(), t = this.paginationService.getPageSize(), r = !t || !e.includes(t);
    r && (e.unshift(""), Se(
      `The paginationPageSize grid option is set to a value that is not in the list of page size options.
                Please make sure that the paginationPageSize grid option is set to one of the values in the 
                paginationPageSizeSelector array, or set the paginationPageSizeSelector to false to hide the page size selector.`
    )), this.selectPageSizeComp && (this.selectPageSizeComp = this.destroyBean(this.selectPageSizeComp));
    const n = this.localeService.getLocaleTextFunc(), i = n("pageSizeSelectorLabel", "Page Size:"), o = e.map((s) => ({
      value: String(s),
      text: String(s)
    })), a = n("ariaPageSizeSelectorLabel", "Page Size");
    this.selectPageSizeComp = this.createManagedBean(new DA()).addOptions(o).setValue(String(r ? "" : t)).setAriaLabel(a).setLabel(i).onValueChange(() => this.handlePageSizeItemSelected()), this.hasEmptyOption = r;
  }
  getPageSizeSelectorValues() {
    const e = [20, 50, 100], t = this.gos.get("paginationPageSizeSelector");
    return !Array.isArray(t) || !this.validateValues(t) ? e : [...t].sort((r, n) => r - n);
  }
  validateValues(e) {
    if (!e.length)
      return Se(
        `The paginationPageSizeSelector grid option is an empty array. This is most likely a mistake.
                If you want to hide the page size selector, please set the paginationPageSizeSelector to false.`
      ), !1;
    for (let t = 0; t < e.length; t++) {
      const r = e[t], n = typeof r == "number", i = r > 0;
      if (!n)
        return Se(
          `The paginationPageSizeSelector grid option contains a non-numeric value.
                    Please make sure that all values in the paginationPageSizeSelector array are numbers.`
        ), !1;
      if (!i)
        return Se(
          `The paginationPageSizeSelector grid option contains a negative number or zero.
                    Please make sure that all values in the paginationPageSizeSelector array are positive.`
        ), !1;
    }
    return !0;
  }
  destroy() {
    this.toggleSelectDisplay(!1), super.destroy();
  }
}, oze = {
  selector: "AG-PAGE-SIZE-SELECTOR",
  component: ize
}, aze = class extends XBe {
  constructor() {
    super(), this.btFirst = ft, this.btPrevious = ft, this.btNext = ft, this.btLast = ft, this.lbRecordCount = ft, this.lbFirstRowOnPage = ft, this.lbLastRowOnPage = ft, this.lbCurrent = ft, this.lbTotal = ft, this.pageSizeComp = ft, this.previousAndFirstButtonsDisabled = !1, this.nextButtonDisabled = !1, this.lastButtonDisabled = !1, this.areListenersSetup = !1, this.allowFocusInnerElement = !1;
  }
  wireBeans(e) {
    this.rowNodeBlockLoader = e.rowNodeBlockLoader, this.rowModel = e.rowModel, this.paginationService = e.paginationService, this.focusService = e.focusService;
  }
  postConstruct() {
    const e = this.gos.get("enableRtl");
    this.setTemplate(this.getTemplate(), [oze]);
    const { btFirst: t, btPrevious: r, btNext: n, btLast: i } = this;
    this.activateTabIndex([t, r, n, i]), t.insertAdjacentElement("afterbegin", to(e ? "last" : "first", this.gos)), r.insertAdjacentElement("afterbegin", to(e ? "next" : "previous", this.gos)), n.insertAdjacentElement("afterbegin", to(e ? "previous" : "next", this.gos)), i.insertAdjacentElement("afterbegin", to(e ? "first" : "last", this.gos)), this.addManagedPropertyListener("pagination", this.onPaginationChanged.bind(this)), this.addManagedPropertyListener("suppressPaginationPanel", this.onPaginationChanged.bind(this)), this.addManagedPropertyListeners(
      ["paginationPageSizeSelector", "paginationAutoPageSize", "suppressPaginationPanel"],
      () => this.onPageSizeRelatedOptionsChange()
    ), this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector()), this.initialiseTabGuard({
      // prevent tab guard default logic
      onTabKeyDown: () => {
      },
      focusInnerElement: (o) => {
        this.allowFocusInnerElement ? this.tabGuardFeature.getTabGuardCtrl().focusInnerElement(o) : this.focusService.focusGridInnerElement(o);
      },
      forceFocusOutWhenTabGuardsAreEmpty: !0
    }), this.onPaginationChanged();
  }
  setAllowFocus(e) {
    this.allowFocusInnerElement = e;
  }
  onPaginationChanged() {
    const t = this.gos.get("pagination") && !this.gos.get("suppressPaginationPanel");
    this.setDisplayed(t), t && (this.setupListeners(), this.enableOrDisableButtons(), this.updateRowLabels(), this.setCurrentPageLabel(), this.setTotalLabels(), this.onPageSizeRelatedOptionsChange());
  }
  onPageSizeRelatedOptionsChange() {
    this.pageSizeComp.toggleSelectDisplay(this.pageSizeComp.shouldShowPageSizeSelector());
  }
  setupListeners() {
    this.areListenersSetup || (this.addManagedEventListeners({ paginationChanged: this.onPaginationChanged.bind(this) }), [
      { el: this.btFirst, fn: this.onBtFirst.bind(this) },
      { el: this.btPrevious, fn: this.onBtPrevious.bind(this) },
      { el: this.btNext, fn: this.onBtNext.bind(this) },
      { el: this.btLast, fn: this.onBtLast.bind(this) }
    ].forEach((e) => {
      const { el: t, fn: r } = e;
      this.addManagedListeners(t, {
        click: r,
        keydown: (n) => {
          (n.key === ae.ENTER || n.key === ae.SPACE) && (n.preventDefault(), r());
        }
      });
    }), nze(this, this.getGui(), this.focusService), this.areListenersSetup = !0);
  }
  onBtFirst() {
    this.previousAndFirstButtonsDisabled || this.paginationService.goToFirstPage();
  }
  setCurrentPageLabel() {
    const e = this.paginationService.getTotalPages() > 0, t = this.paginationService.getCurrentPage(), r = e ? t + 1 : 0;
    this.lbCurrent.textContent = this.formatNumber(r);
  }
  formatNumber(e) {
    const t = this.gos.getCallback("paginationNumberFormatter");
    if (t)
      return t({ value: e });
    const r = this.localeService.getLocaleTextFunc(), n = r("thousandSeparator", ","), i = r("decimalSeparator", ".");
    return qNe(e, n, i);
  }
  getTemplate() {
    const e = this.localeService.getLocaleTextFunc(), t = e("page", "Page"), r = e("to", "to"), n = e("of", "of"), i = e("firstPage", "First Page"), o = e("previousPage", "Previous Page"), a = e("nextPage", "Next Page"), s = e("lastPage", "Last Page"), l = this.getCompId();
    return (
      /* html */
      `<div class="ag-paging-panel ag-unselectable" id="ag-${l}">
                <ag-page-size-selector data-ref="pageSizeComp"></ag-page-size-selector>
                <span class="ag-paging-row-summary-panel" role="status">
                    <span id="ag-${l}-first-row" data-ref="lbFirstRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-to">${r}</span>
                    <span id="ag-${l}-last-row" data-ref="lbLastRowOnPage" class="ag-paging-row-summary-panel-number"></span>
                    <span id="ag-${l}-of">${n}</span>
                    <span id="ag-${l}-row-count" data-ref="lbRecordCount" class="ag-paging-row-summary-panel-number"></span>
                </span>
                <span class="ag-paging-page-summary-panel" role="presentation">
                    <div data-ref="btFirst" class="ag-button ag-paging-button" role="button" aria-label="${i}"></div>
                    <div data-ref="btPrevious" class="ag-button ag-paging-button" role="button" aria-label="${o}"></div>
                    <span class="ag-paging-description" role="status">
                        <span id="ag-${l}-start-page">${t}</span>
                        <span id="ag-${l}-start-page-number" data-ref="lbCurrent" class="ag-paging-number"></span>
                        <span id="ag-${l}-of-page">${n}</span>
                        <span id="ag-${l}-of-page-number" data-ref="lbTotal" class="ag-paging-number"></span>
                    </span>
                    <div data-ref="btNext" class="ag-button ag-paging-button" role="button" aria-label="${a}"></div>
                    <div data-ref="btLast" class="ag-button ag-paging-button" role="button" aria-label="${s}"></div>
                </span>
            </div>`
    );
  }
  onBtNext() {
    this.nextButtonDisabled || this.paginationService.goToNextPage();
  }
  onBtPrevious() {
    this.previousAndFirstButtonsDisabled || this.paginationService.goToPreviousPage();
  }
  onBtLast() {
    this.lastButtonDisabled || this.paginationService.goToLastPage();
  }
  enableOrDisableButtons() {
    const e = this.paginationService.getCurrentPage(), t = this.rowModel.isLastRowIndexKnown(), r = this.paginationService.getTotalPages();
    this.previousAndFirstButtonsDisabled = e === 0, this.toggleButtonDisabled(this.btFirst, this.previousAndFirstButtonsDisabled), this.toggleButtonDisabled(this.btPrevious, this.previousAndFirstButtonsDisabled);
    const n = this.isZeroPagesToDisplay(), i = e === r - 1;
    this.nextButtonDisabled = i || n, this.lastButtonDisabled = !t || n || e === r - 1, this.toggleButtonDisabled(this.btNext, this.nextButtonDisabled), this.toggleButtonDisabled(this.btLast, this.lastButtonDisabled);
  }
  toggleButtonDisabled(e, t) {
    hOe(e, t), e.classList.toggle("ag-disabled", t);
  }
  updateRowLabels() {
    var a;
    const e = this.paginationService.getCurrentPage(), t = this.paginationService.getPageSize(), r = this.rowModel.isLastRowIndexKnown(), n = this.rowModel.isLastRowIndexKnown() ? this.paginationService.getMasterRowCount() : null;
    let i, o;
    if (this.isZeroPagesToDisplay() ? i = o = 0 : (i = t * e + 1, o = i + t - 1, r && o > n && (o = n)), this.lbFirstRowOnPage.textContent = this.formatNumber(i), (a = this.rowNodeBlockLoader) != null && a.isLoading()) {
      const s = this.localeService.getLocaleTextFunc();
      this.lbLastRowOnPage.innerHTML = s("pageLastRowUnknown", "?");
    } else
      this.lbLastRowOnPage.textContent = this.formatNumber(o);
  }
  isZeroPagesToDisplay() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.paginationService.getTotalPages();
    return e && t === 0;
  }
  setTotalLabels() {
    const e = this.rowModel.isLastRowIndexKnown(), t = this.paginationService.getTotalPages(), r = e ? this.paginationService.getMasterRowCount() : null;
    if (r === 1) {
      const n = this.rowModel.getRow(0);
      if (n && n.group && !(n.groupData || n.aggData)) {
        this.setTotalLabelsToZero();
        return;
      }
    }
    if (e)
      this.lbTotal.textContent = this.formatNumber(t), this.lbRecordCount.textContent = this.formatNumber(r);
    else {
      const n = this.localeService.getLocaleTextFunc()("more", "more");
      this.lbTotal.innerHTML = n, this.lbRecordCount.innerHTML = n;
    }
  }
  setTotalLabelsToZero() {
    this.lbFirstRowOnPage.textContent = this.formatNumber(0), this.lbCurrent.textContent = this.formatNumber(0), this.lbLastRowOnPage.textContent = this.formatNumber(0), this.lbTotal.textContent = this.formatNumber(0), this.lbRecordCount.textContent = this.formatNumber(0);
  }
}, sze = {
  selector: "AG-PAGINATION",
  component: aze
}, lze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "paginationService", this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = 0, this.masterRowCount = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.active = this.gos.get("pagination"), this.pageSizeFromGridOptions = this.gos.get("paginationPageSize"), this.paginateChildRows = this.isPaginateChildRows(), this.addManagedPropertyListener("pagination", this.onPaginationGridOptionChanged.bind(this)), this.addManagedPropertyListener("paginationPageSize", this.onPageSizeGridOptionChanged.bind(this));
  }
  getPaginationSelector() {
    return sze;
  }
  isPaginateChildRows() {
    return this.gos.get("groupRemoveSingleChildren") || this.gos.get("groupRemoveLowestSingleChildren") ? !0 : this.gos.get("paginateChildRows");
  }
  onPaginationGridOptionChanged() {
    this.active = this.gos.get("pagination"), this.calculatePages(), this.dispatchPaginationChangedEvent({ keepRenderedRows: !0 });
  }
  onPageSizeGridOptionChanged() {
    this.setPageSize(this.gos.get("paginationPageSize"), "gridOptions");
  }
  goToPage(e) {
    !this.active || this.currentPage === e || typeof this.currentPage != "number" || (this.currentPage = e, this.calculatePages(), this.dispatchPaginationChangedEvent({ newPage: !0 }));
  }
  isRowPresent(e) {
    return e.rowIndex >= this.topDisplayedRowIndex && e.rowIndex <= this.bottomDisplayedRowIndex;
  }
  getPageForIndex(e) {
    return Math.floor(e / this.pageSize);
  }
  goToPageWithIndex(e) {
    if (!this.active)
      return;
    const t = this.getPageForIndex(e);
    this.goToPage(t);
  }
  isRowInPage(e) {
    return this.active ? this.getPageForIndex(e.rowIndex) === this.currentPage : !0;
  }
  getCurrentPage() {
    return this.currentPage;
  }
  goToNextPage() {
    this.goToPage(this.currentPage + 1);
  }
  goToPreviousPage() {
    this.goToPage(this.currentPage - 1);
  }
  goToFirstPage() {
    this.goToPage(0);
  }
  goToLastPage() {
    const e = this.rowModel.getRowCount(), t = Math.floor(e / this.pageSize);
    this.goToPage(t);
  }
  getPageSize() {
    return this.pageSize;
  }
  getTotalPages() {
    return this.totalPages;
  }
  /** This is only for state setting before data has been loaded */
  setPage(e) {
    this.currentPage = e;
  }
  get pageSize() {
    return Me(this.pageSizeAutoCalculated) ? this.pageSizeAutoCalculated : Me(this.pageSizeFromPageSizeSelector) ? this.pageSizeFromPageSizeSelector : Me(this.pageSizeFromInitialState) ? this.pageSizeFromInitialState : Me(this.pageSizeFromGridOptions) ? this.pageSizeFromGridOptions : this.defaultPageSize;
  }
  calculatePages() {
    this.active ? this.paginateChildRows ? this.calculatePagesAllRows() : this.calculatePagesMasterRowsOnly() : this.calculatedPagesNotActive(), this.pageBoundsService.calculateBounds(this.topDisplayedRowIndex, this.bottomDisplayedRowIndex);
  }
  unsetAutoCalculatedPageSize() {
    if (this.pageSizeAutoCalculated === void 0)
      return;
    const e = this.pageSizeAutoCalculated;
    this.pageSizeAutoCalculated = void 0, this.pageSize !== e && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0 }));
  }
  setPageSize(e, t) {
    const r = this.pageSize;
    switch (t) {
      case "autoCalculated":
        this.pageSizeAutoCalculated = e;
        break;
      case "pageSizeSelector":
        this.pageSizeFromPageSizeSelector = e, this.currentPage !== 0 && this.goToFirstPage();
        break;
      case "initialState":
        this.pageSizeFromInitialState = e;
        break;
      case "gridOptions":
        this.pageSizeFromGridOptions = e, this.pageSizeFromInitialState = void 0, this.pageSizeFromPageSizeSelector = void 0, this.currentPage !== 0 && this.goToFirstPage();
        break;
    }
    r !== this.pageSize && (this.calculatePages(), this.dispatchPaginationChangedEvent({ newPageSize: !0, keepRenderedRows: !0 }));
  }
  setZeroRows() {
    this.masterRowCount = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = -1, this.currentPage = 0, this.totalPages = 0;
  }
  adjustCurrentPageIfInvalid() {
    this.currentPage >= this.totalPages && (this.currentPage = this.totalPages - 1), (!isFinite(this.currentPage) || isNaN(this.currentPage) || this.currentPage < 0) && (this.currentPage = 0);
  }
  calculatePagesMasterRowsOnly() {
    if (this.masterRowCount = this.rowModel.getTopLevelRowCount(), this.masterRowCount <= 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid();
    const t = this.pageSize * this.currentPage;
    let r = this.pageSize * (this.currentPage + 1) - 1;
    if (r > e && (r = e), this.topDisplayedRowIndex = this.rowModel.getTopLevelRowDisplayedIndex(t), r === e)
      this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
    else {
      const n = this.rowModel.getTopLevelRowDisplayedIndex(r + 1);
      this.bottomDisplayedRowIndex = n - 1;
    }
  }
  getMasterRowCount() {
    return this.masterRowCount;
  }
  calculatePagesAllRows() {
    if (this.masterRowCount = this.rowModel.getRowCount(), this.masterRowCount === 0) {
      this.setZeroRows();
      return;
    }
    const e = this.masterRowCount - 1;
    this.totalPages = Math.floor(e / this.pageSize) + 1, this.adjustCurrentPageIfInvalid(), this.topDisplayedRowIndex = this.pageSize * this.currentPage, this.bottomDisplayedRowIndex = this.pageSize * (this.currentPage + 1) - 1, this.bottomDisplayedRowIndex > e && (this.bottomDisplayedRowIndex = e);
  }
  calculatedPagesNotActive() {
    this.setPageSize(void 0, "autoCalculated"), this.totalPages = 1, this.currentPage = 0, this.topDisplayedRowIndex = 0, this.bottomDisplayedRowIndex = this.rowModel.getRowCount() - 1;
  }
  dispatchPaginationChangedEvent(e) {
    const { keepRenderedRows: t = !1, newPage: r = !1, newPageSize: n = !1 } = e, i = {
      type: "paginationChanged",
      animate: !1,
      newData: !1,
      newPage: r,
      newPageSize: n,
      keepRenderedRows: t
    };
    this.eventService.dispatchEvent(i);
  }
}, xY = {
  version: Et,
  moduleName: "@ag-grid-community/pagination-core",
  beans: [lze, rze]
}, uze = {
  version: Et,
  moduleName: "@ag-grid-community/pagination-api",
  dependantModules: [xY],
  apiFunctions: {
    paginationIsLastPageFound: UHe,
    paginationGetPageSize: KHe,
    paginationGetCurrentPage: YHe,
    paginationGetTotalPages: qHe,
    paginationGetRowCount: ZHe,
    paginationGoToNextPage: XHe,
    paginationGoToPreviousPage: QHe,
    paginationGoToFirstPage: JHe,
    paginationGoToLastPage: eze,
    paginationGoToPage: tze
  }
}, cze = {
  version: Et,
  moduleName: "@ag-grid-community/pagination",
  dependantModules: [xY, uze]
}, oe = "@ag-grid-community/core", Ia = "@ag-grid-community/client-side-row-model", jG = "@ag-grid-community/csv-export", Iy = "@ag-grid-community/infinite-row-model", Fy = "@ag-grid-enterprise/advanced-filter", qo = "@ag-grid-enterprise/charts", Hd = "@ag-grid-enterprise/clipboard", Sp = "@ag-grid-enterprise/excel-export", Ly = "@ag-grid-enterprise/master-detail", tE = "@ag-grid-enterprise/menu", rE = "@ag-grid-enterprise/range-selection", Ar = "@ag-grid-enterprise/row-grouping", ms = "@ag-grid-enterprise/server-side-row-model", Fa = "@ag-grid-enterprise/side-bar", dze = "@ag-grid-enterprise/status-bar", hze = {
  dispatchEvent: oe,
  getState: oe,
  getGridId: oe,
  destroy: oe,
  isDestroyed: oe,
  getGridOption: oe,
  setGridOption: oe,
  updateGridOptions: oe,
  setNodesSelected: oe,
  selectAll: oe,
  deselectAll: oe,
  selectAllFiltered: oe,
  deselectAllFiltered: oe,
  selectAllOnCurrentPage: oe,
  deselectAllOnCurrentPage: oe,
  getSelectedNodes: oe,
  getSelectedRows: oe,
  redrawRows: oe,
  setRowNodeExpanded: oe,
  getRowNode: oe,
  addRenderedRowListener: oe,
  getRenderedNodes: oe,
  forEachNode: oe,
  getFirstDisplayedRow: oe,
  getFirstDisplayedRowIndex: oe,
  getLastDisplayedRow: oe,
  getLastDisplayedRowIndex: oe,
  getDisplayedRowAtIndex: oe,
  getDisplayedRowCount: oe,
  getModel: oe,
  getVerticalPixelRange: oe,
  getHorizontalPixelRange: oe,
  ensureColumnVisible: oe,
  ensureIndexVisible: oe,
  ensureNodeVisible: oe,
  getFocusedCell: oe,
  clearFocusedCell: oe,
  setFocusedCell: oe,
  tabToNextCell: oe,
  tabToPreviousCell: oe,
  setFocusedHeader: oe,
  addEventListener: oe,
  addGlobalListener: oe,
  removeEventListener: oe,
  removeGlobalListener: oe,
  expireValueCache: oe,
  getValue: oe,
  getCellValue: oe,
  showColumnMenuAfterButtonClick: oe,
  showColumnMenuAfterMouseClick: oe,
  showColumnMenu: oe,
  hidePopupMenu: oe,
  onSortChanged: oe,
  getPinnedTopRowCount: oe,
  getPinnedBottomRowCount: oe,
  getPinnedTopRow: oe,
  getPinnedBottomRow: oe,
  showLoadingOverlay: oe,
  showNoRowsOverlay: oe,
  hideOverlay: oe,
  setGridAriaProperty: oe,
  refreshCells: oe,
  flashCells: oe,
  refreshHeader: oe,
  isAnimationFrameQueueEmpty: oe,
  flushAllAnimationFrames: oe,
  getSizesForCurrentTheme: oe,
  getCellRendererInstances: oe,
  addRowDropZone: oe,
  removeRowDropZone: oe,
  getRowDropZoneParams: oe,
  getColumnDef: oe,
  getColumnDefs: oe,
  sizeColumnsToFit: oe,
  setColumnGroupOpened: oe,
  getColumnGroup: oe,
  getProvidedColumnGroup: oe,
  getDisplayNameForColumn: oe,
  getDisplayNameForColumnGroup: oe,
  getColumn: oe,
  getColumns: oe,
  applyColumnState: oe,
  getColumnState: oe,
  resetColumnState: oe,
  getColumnGroupState: oe,
  setColumnGroupState: oe,
  resetColumnGroupState: oe,
  isPinning: oe,
  isPinningLeft: oe,
  isPinningRight: oe,
  getDisplayedColAfter: oe,
  getDisplayedColBefore: oe,
  setColumnVisible: oe,
  setColumnsVisible: oe,
  setColumnPinned: oe,
  setColumnsPinned: oe,
  getAllGridColumns: oe,
  getDisplayedLeftColumns: oe,
  getDisplayedCenterColumns: oe,
  getDisplayedRightColumns: oe,
  getAllDisplayedColumns: oe,
  getAllDisplayedVirtualColumns: oe,
  moveColumn: oe,
  moveColumnByIndex: oe,
  moveColumns: oe,
  setColumnWidth: oe,
  setColumnWidths: oe,
  getLeftDisplayedColumnGroups: oe,
  getCenterDisplayedColumnGroups: oe,
  getRightDisplayedColumnGroups: oe,
  getAllDisplayedColumnGroups: oe,
  autoSizeColumn: oe,
  autoSizeColumns: oe,
  autoSizeAllColumns: oe,
  undoCellEditing: oe,
  redoCellEditing: oe,
  getCellEditorInstances: oe,
  getEditingCells: oe,
  stopEditing: oe,
  startEditingCell: oe,
  getCurrentUndoSize: oe,
  getCurrentRedoSize: oe,
  isAnyFilterPresent: oe,
  onFilterChanged: oe,
  isColumnFilterPresent: oe,
  getFilterInstance: oe,
  getColumnFilterInstance: oe,
  destroyFilter: oe,
  setFilterModel: oe,
  getFilterModel: oe,
  getColumnFilterModel: oe,
  setColumnFilterModel: oe,
  showColumnFilter: oe,
  isQuickFilterPresent: oe,
  getQuickFilter: oe,
  resetQuickFilter: oe,
  paginationIsLastPageFound: oe,
  paginationGetPageSize: oe,
  paginationGetCurrentPage: oe,
  paginationGetTotalPages: oe,
  paginationGetRowCount: oe,
  paginationGoToNextPage: oe,
  paginationGoToPreviousPage: oe,
  paginationGoToFirstPage: oe,
  paginationGoToLastPage: oe,
  paginationGoToPage: oe,
  // These may need updating to say which of multiple possible modules they could be missing from.
  expandAll: oe,
  collapseAll: oe,
  onRowHeightChanged: oe,
  setRowCount: oe,
  getCacheBlockState: oe,
  onGroupExpandedOrCollapsed: Ia,
  refreshClientSideRowModel: Ia,
  forEachLeafNode: Ia,
  forEachNodeAfterFilter: Ia,
  forEachNodeAfterFilterAndSort: Ia,
  resetRowHeights: Ia,
  applyTransaction: Ia,
  applyTransactionAsync: Ia,
  flushAsyncTransactions: Ia,
  getBestCostNodeSelection: Ia,
  getDataAsCsv: jG,
  exportDataAsCsv: jG,
  refreshInfiniteCache: Iy,
  purgeInfiniteCache: Iy,
  getInfiniteRowCount: Iy,
  isLastRowIndexKnown: Iy,
  getAdvancedFilterModel: Fy,
  setAdvancedFilterModel: Fy,
  showAdvancedFilterBuilder: Fy,
  hideAdvancedFilterBuilder: Fy,
  getChartModels: qo,
  getChartRef: qo,
  getChartImageDataURL: qo,
  downloadChart: qo,
  openChartToolPanel: qo,
  closeChartToolPanel: qo,
  createRangeChart: qo,
  createPivotChart: qo,
  createCrossFilterChart: qo,
  updateChart: qo,
  restoreChart: qo,
  copyToClipboard: Hd,
  cutToClipboard: Hd,
  copySelectedRowsToClipboard: Hd,
  copySelectedRangeToClipboard: Hd,
  copySelectedRangeDown: Hd,
  pasteFromClipboard: Hd,
  getDataAsExcel: Sp,
  exportDataAsExcel: Sp,
  getSheetDataForExcel: Sp,
  getMultipleSheetsAsExcel: Sp,
  exportMultipleSheetsAsExcel: Sp,
  addDetailGridInfo: Ly,
  removeDetailGridInfo: Ly,
  getDetailGridInfo: Ly,
  forEachDetailGridInfo: Ly,
  showContextMenu: tE,
  showColumnChooser: tE,
  hideColumnChooser: tE,
  getCellRanges: rE,
  addCellRange: rE,
  clearRangeSelection: rE,
  addAggFunc: Ar,
  addAggFuncs: Ar,
  clearAggFuncs: Ar,
  setColumnAggFunc: Ar,
  isPivotMode: Ar,
  getPivotResultColumn: Ar,
  setValueColumns: Ar,
  getValueColumns: Ar,
  removeValueColumn: Ar,
  removeValueColumns: Ar,
  addValueColumn: Ar,
  addValueColumns: Ar,
  setRowGroupColumns: Ar,
  removeRowGroupColumn: Ar,
  removeRowGroupColumns: Ar,
  addRowGroupColumn: Ar,
  addRowGroupColumns: Ar,
  getRowGroupColumns: Ar,
  moveRowGroupColumn: Ar,
  setPivotColumns: Ar,
  removePivotColumn: Ar,
  removePivotColumns: Ar,
  addPivotColumn: Ar,
  addPivotColumns: Ar,
  getPivotColumns: Ar,
  setPivotResultColumns: Ar,
  getPivotResultColumns: Ar,
  getServerSideSelectionState: ms,
  setServerSideSelectionState: ms,
  applyServerSideTransaction: ms,
  applyServerSideTransactionAsync: ms,
  applyServerSideRowData: ms,
  retryServerSideLoads: ms,
  flushServerSideAsyncTransactions: ms,
  refreshServerSide: ms,
  getServerSideGroupLevelState: ms,
  isSideBarVisible: Fa,
  setSideBarVisible: Fa,
  setSideBarPosition: Fa,
  openToolPanel: Fa,
  closeToolPanel: Fa,
  getOpenedToolPanel: Fa,
  refreshToolPanel: Fa,
  isToolPanelShowing: Fa,
  getToolPanelInstance: Fa,
  getSideBar: Fa,
  getStatusPanel: dze
}, Wi = "clientSide", Mi = "serverSide", zd = "infinite", fze = {
  onGroupExpandedOrCollapsed: [Wi],
  refreshClientSideRowModel: [Wi],
  forEachLeafNode: [Wi],
  forEachNodeAfterFilter: [Wi],
  forEachNodeAfterFilterAndSort: [Wi],
  resetRowHeights: [Wi],
  applyTransaction: [Wi],
  applyTransactionAsync: [Wi],
  flushAsyncTransactions: [Wi],
  getBestCostNodeSelection: [Wi],
  getServerSideSelectionState: [Mi],
  setServerSideSelectionState: [Mi],
  applyServerSideTransaction: [Mi],
  applyServerSideTransactionAsync: [Mi],
  applyServerSideRowData: [Mi],
  retryServerSideLoads: [Mi],
  flushServerSideAsyncTransactions: [Mi],
  refreshServerSide: [Mi],
  getServerSideGroupLevelState: [Mi],
  refreshInfiniteCache: [zd],
  purgeInfiniteCache: [zd],
  getInfiniteRowCount: [zd],
  isLastRowIndexKnown: [zd],
  expandAll: [Wi, Mi],
  collapseAll: [Wi, Mi],
  onRowHeightChanged: [Wi, Mi],
  setRowCount: [zd, Mi],
  getCacheBlockState: [zd, Mi]
}, pze = {
  getValue: {
    version: "v31.3",
    new: "getCellValue"
  },
  getFirstDisplayedRow: {
    version: "v31.1",
    new: "getFirstDisplayedRowIndex"
  },
  getLastDisplayedRow: {
    version: "v31.1",
    new: "getLastDisplayedRowIndex"
  },
  getModel: {
    version: "v31.1",
    message: "Please use the appropriate grid API methods instead."
  },
  setColumnVisible: {
    version: "v31.1",
    old: "setColumnVisible(key,visible)",
    new: "setColumnsVisible([key],visible)"
  },
  setColumnPinned: {
    version: "v31.1",
    old: "setColumnPinned(key,pinned)",
    new: "setColumnsPinned([key],pinned)"
  },
  moveColumn: {
    version: "v31.1",
    old: "moveColumn(key, toIndex)",
    new: "moveColumns([key], toIndex)"
  },
  setColumnWidth: {
    version: "v31.1",
    old: "setColumnWidth(col, width)",
    new: "setColumnWidths([{key: col, newWidth: width}])"
  },
  autoSizeColumn: {
    version: "v31.1",
    old: "autoSizeColumn(key, skipHeader)",
    new: "autoSizeColumns([key], skipHeader)"
  },
  addAggFunc: {
    version: "v31.1",
    old: "addAggFunc(key, func)",
    new: "addAggFuncs({ key: func })"
  },
  removeValueColumn: {
    version: "v31.1",
    old: "removeValueColumn(colKey)",
    new: "removeValueColumns([colKey])"
  },
  addValueColumn: {
    version: "v31.1",
    old: "addValueColumn(colKey)",
    new: "addValueColumns([colKey])"
  },
  removeRowGroupColumn: {
    version: "v31.1",
    old: "removeRowGroupColumn(colKey)",
    new: "removeRowGroupColumns([colKey])"
  },
  addRowGroupColumn: {
    version: "v31.1",
    old: "addRowGroupColumn(colKey)",
    new: "addRowGroupColumns([colKey])"
  },
  removePivotColumn: {
    version: "v31.1",
    old: "removePivotColumn(colKey)",
    new: "removePivotColumns([colKey])"
  },
  addPivotColumn: {
    version: "v31.1",
    old: "addPivotColumn(colKey)",
    new: "addPivotColumns([colKey])"
  },
  showColumnMenuAfterButtonClick: {
    version: "v31.1",
    message: "Use 'IHeaderParams.showColumnMenu' within a header component, or 'api.showColumnMenu' elsewhere."
  },
  showColumnMenuAfterMouseClick: {
    version: "v31.1",
    message: "Use 'IHeaderParams.showColumnMenuAfterMouseClick' within a header component, or 'api.showColumnMenu' elsewhere."
  },
  getFilterInstance: {
    version: "v31.1",
    message: "'getFilterInstance' is deprecated. To get/set individual filter models, use 'getColumnFilterModel' or 'setColumnFilterModel' instead. To get hold of the filter instance, use 'getColumnFilterInstance' which returns the instance asynchronously."
  },
  showLoadingOverlay: {
    version: "v32",
    message: '`showLoadingOverlay` is deprecated. Use the grid option "loading"=true instead or setGridOption("loading", true).'
  }
};
function gze(e, t) {
  const r = hze[e];
  r ? Xn.__assertRegistered(r, `api.${e}`, t) && Se(`API function '${e}' not registered to module '${r}'`) : sr(`Unknown API function: '${e}' on GridApi.`);
}
function vze(e, t, r) {
  const n = pze[e];
  if (n) {
    const { version: o, new: a, old: s, message: l } = n, u = s ?? e;
    return (...c) => {
      const d = a ? `Please use ${a} instead. ` : "";
      return Se(`Since ${o} api.${u} is deprecated. ${d}${l ?? ""}`), t.apply(t, c);
    };
  }
  const i = fze[e];
  return i ? (...o) => {
    const a = r.rowModel.getType();
    if (!i.includes(a)) {
      sr(
        `api.${e} can only be called when gridOptions.rowModelType is ${i.join(" or ")}`
      );
      return;
    }
    return t.apply(t, o);
  } : t;
}
var mze = {
  columnsMenuParams: { version: "31.1", message: "Use `columnChooserParams` instead." },
  suppressMenu: { version: "31.1", message: "Use `suppressHeaderMenuButton` instead." },
  suppressCellFlash: { version: "31.2", message: "Use `enableCellChangeFlash={false}` in the ColDef" }
}, vl = (e, t) => (t.rowModelType ?? "clientSide") === "clientSide" ? {
  module: "@ag-grid-enterprise/row-grouping"
  /* RowGroupingModule */
} : null, yze = {
  // supported on all row models, but need module for client side.
  enableRowGroup: vl,
  rowGroup: vl,
  rowGroupIndex: vl,
  enablePivot: vl,
  enableValue: vl,
  pivot: vl,
  pivotIndex: vl,
  aggFunc: vl,
  cellEditor: (e) => e.cellEditor === "agRichSelect" || e.cellEditor === "agRichSelectCellEditor" ? {
    module: "@ag-grid-enterprise/rich-select"
    /* RichSelectModule */
  } : null,
  menuTabs: (e) => {
    var r;
    const t = ["columnsMenuTab", "generalMenuTab"];
    return (r = e.menuTabs) != null && r.some((n) => t.includes(n)) ? {
      module: "@ag-grid-enterprise/menu"
      /* MenuModule */
    } : null;
  },
  columnsMenuParams: {
    module: [
      "@ag-grid-enterprise/menu",
      "@ag-grid-enterprise/column-tool-panel"
      /* ColumnsToolPanelModule */
    ]
  },
  columnChooserParams: {
    module: [
      "@ag-grid-enterprise/menu",
      "@ag-grid-enterprise/column-tool-panel"
      /* ColumnsToolPanelModule */
    ]
  },
  headerCheckboxSelection: {
    supportedRowModels: ["clientSide", "serverSide"],
    dependencies: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelection is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionFilteredOnly: {
    supportedRowModels: ["clientSide"],
    dependencies: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionFilteredOnly is only supported with rowSelection=multiple"
  },
  headerCheckboxSelectionCurrentPageOnly: {
    supportedRowModels: ["clientSide"],
    dependencies: (e, { rowSelection: t }) => t === "multiple" ? null : "headerCheckboxSelectionCurrentPageOnly is only supported with rowSelection=multiple"
  },
  children: () => sh
}, Cze = {
  headerName: void 0,
  columnGroupShow: void 0,
  headerClass: void 0,
  toolPanelClass: void 0,
  headerValueGetter: void 0,
  pivotKeys: void 0,
  groupId: void 0,
  colId: void 0,
  sort: void 0,
  initialSort: void 0,
  field: void 0,
  type: void 0,
  cellDataType: void 0,
  tooltipComponent: void 0,
  tooltipField: void 0,
  headerTooltip: void 0,
  cellClass: void 0,
  showRowGroup: void 0,
  filter: void 0,
  initialAggFunc: void 0,
  defaultAggFunc: void 0,
  aggFunc: void 0,
  pinned: void 0,
  initialPinned: void 0,
  chartDataType: void 0,
  cellAriaRole: void 0,
  cellEditorPopupPosition: void 0,
  headerGroupComponent: void 0,
  headerGroupComponentParams: void 0,
  cellStyle: void 0,
  cellRenderer: void 0,
  cellRendererParams: void 0,
  cellEditor: void 0,
  cellEditorParams: void 0,
  filterParams: void 0,
  pivotValueColumn: void 0,
  headerComponent: void 0,
  headerComponentParams: void 0,
  floatingFilterComponent: void 0,
  floatingFilterComponentParams: void 0,
  tooltipComponentParams: void 0,
  refData: void 0,
  columnsMenuParams: void 0,
  columnChooserParams: void 0,
  children: void 0,
  sortingOrder: void 0,
  allowedAggFuncs: void 0,
  menuTabs: void 0,
  pivotTotalColumnIds: void 0,
  cellClassRules: void 0,
  icons: void 0,
  sortIndex: void 0,
  initialSortIndex: void 0,
  flex: void 0,
  initialFlex: void 0,
  width: void 0,
  initialWidth: void 0,
  minWidth: void 0,
  maxWidth: void 0,
  rowGroupIndex: void 0,
  initialRowGroupIndex: void 0,
  pivotIndex: void 0,
  initialPivotIndex: void 0,
  suppressCellFlash: void 0,
  suppressColumnsToolPanel: void 0,
  suppressFiltersToolPanel: void 0,
  openByDefault: void 0,
  marryChildren: void 0,
  suppressStickyLabel: void 0,
  hide: void 0,
  initialHide: void 0,
  rowGroup: void 0,
  initialRowGroup: void 0,
  pivot: void 0,
  initialPivot: void 0,
  checkboxSelection: void 0,
  showDisabledCheckboxes: void 0,
  headerCheckboxSelection: void 0,
  headerCheckboxSelectionFilteredOnly: void 0,
  headerCheckboxSelectionCurrentPageOnly: void 0,
  suppressMenu: void 0,
  suppressHeaderMenuButton: void 0,
  suppressMovable: void 0,
  lockPosition: void 0,
  lockVisible: void 0,
  lockPinned: void 0,
  unSortIcon: void 0,
  suppressSizeToFit: void 0,
  suppressAutoSize: void 0,
  enableRowGroup: void 0,
  enablePivot: void 0,
  enableValue: void 0,
  editable: void 0,
  suppressPaste: void 0,
  suppressNavigable: void 0,
  enableCellChangeFlash: void 0,
  rowDrag: void 0,
  dndSource: void 0,
  autoHeight: void 0,
  wrapText: void 0,
  sortable: void 0,
  resizable: void 0,
  singleClickEdit: void 0,
  floatingFilter: void 0,
  cellEditorPopup: void 0,
  suppressFillHandle: void 0,
  wrapHeaderText: void 0,
  autoHeaderHeight: void 0,
  dndSourceOnRowDrag: void 0,
  valueGetter: void 0,
  valueSetter: void 0,
  filterValueGetter: void 0,
  keyCreator: void 0,
  valueFormatter: void 0,
  valueParser: void 0,
  comparator: void 0,
  equals: void 0,
  pivotComparator: void 0,
  suppressKeyboardEvent: void 0,
  suppressHeaderKeyboardEvent: void 0,
  colSpan: void 0,
  rowSpan: void 0,
  getQuickFilterText: void 0,
  onCellValueChanged: void 0,
  onCellClicked: void 0,
  onCellDoubleClicked: void 0,
  onCellContextMenu: void 0,
  rowDragText: void 0,
  tooltipValueGetter: void 0,
  cellRendererSelector: void 0,
  cellEditorSelector: void 0,
  suppressSpanHeaderHeight: void 0,
  useValueFormatterForExport: void 0,
  useValueParserForImport: void 0,
  mainMenuItems: void 0,
  contextMenuItems: void 0,
  suppressFloatingFilterButton: void 0,
  suppressHeaderFilterButton: void 0,
  suppressHeaderContextMenu: void 0,
  loadingCellRenderer: void 0,
  loadingCellRendererParams: void 0,
  loadingCellRendererSelector: void 0,
  context: void 0
}, Sze = Object.keys(Cze), sh = {
  objectName: "colDef",
  allProperties: Sze,
  docsUrl: "column-properties/",
  deprecations: mze,
  validations: yze
}, wze = () => ({
  advancedFilterModel: { version: "31", message: "Use `initialState.filter.advancedFilterModel` instead." },
  suppressAsyncEvents: { version: "31", message: "Events should be handled asynchronously." },
  cellFadeDelay: { version: "31.1", renamed: "cellFadeDuration" },
  cellFlashDelay: { version: "31.1", renamed: "cellFlashDuration" },
  suppressServerSideInfiniteScroll: { version: "31.1" },
  serverSideSortOnServer: { version: "31.1" },
  serverSideFilterOnServer: { version: "31.1" },
  enableCellChangeFlash: {
    version: "31.2",
    message: "Use `enableCellChangeFlash` in the `ColDef` or `defaultColDef` for all columns."
  },
  groupIncludeFooter: { version: "31.3", message: "Use `groupTotalRow` instead." },
  groupIncludeTotalFooter: { version: "31.3", message: "Use `grandTotalRow` instead." },
  suppressLoadingOverlay: { version: "32", message: "Use `loading`=false instead." }
}), bze = {
  suppressContextMenu: !1,
  preventDefaultOnContextMenu: !1,
  allowContextMenuWithControlKey: !1,
  suppressMenuHide: !0,
  enableBrowserTooltips: !1,
  tooltipTrigger: "hover",
  tooltipShowDelay: 2e3,
  tooltipHideDelay: 1e4,
  tooltipMouseTrack: !1,
  tooltipShowMode: "standard",
  tooltipInteraction: !1,
  copyHeadersToClipboard: !1,
  copyGroupHeadersToClipboard: !1,
  clipboardDelimiter: "	",
  suppressCopyRowsToClipboard: !1,
  suppressCopySingleCellRanges: !1,
  suppressLastEmptyLineOnPaste: !1,
  suppressClipboardPaste: !1,
  suppressClipboardApi: !1,
  suppressCutToClipboard: !1,
  maintainColumnOrder: !1,
  suppressFieldDotNotation: !1,
  allowDragFromColumnsToolPanel: !1,
  suppressMovableColumns: !1,
  suppressColumnMoveAnimation: !1,
  suppressDragLeaveHidesColumns: !1,
  suppressRowGroupHidesColumns: !1,
  suppressAutoSize: !1,
  autoSizePadding: 20,
  skipHeaderOnAutoSize: !1,
  singleClickEdit: !1,
  suppressClickEdit: !1,
  readOnlyEdit: !1,
  stopEditingWhenCellsLoseFocus: !1,
  enterNavigatesVertically: !1,
  enterNavigatesVerticallyAfterEdit: !1,
  enableCellEditingOnBackspace: !1,
  undoRedoCellEditing: !1,
  undoRedoCellEditingLimit: 10,
  suppressCsvExport: !1,
  suppressExcelExport: !1,
  cacheQuickFilter: !1,
  includeHiddenColumnsInQuickFilter: !1,
  excludeChildrenWhenTreeDataFiltering: !1,
  enableAdvancedFilter: !1,
  includeHiddenColumnsInAdvancedFilter: !1,
  enableCharts: !1,
  masterDetail: !1,
  keepDetailRows: !1,
  keepDetailRowsCount: 10,
  detailRowAutoHeight: !1,
  tabIndex: 0,
  rowBuffer: 10,
  valueCache: !1,
  valueCacheNeverExpires: !1,
  enableCellExpressions: !1,
  suppressTouch: !1,
  suppressFocusAfterRefresh: !1,
  suppressAsyncEvents: !1,
  suppressBrowserResizeObserver: !1,
  suppressPropertyNamesCheck: !1,
  suppressChangeDetection: !1,
  debug: !1,
  suppressLoadingOverlay: !1,
  suppressNoRowsOverlay: !1,
  pagination: !1,
  paginationPageSize: 100,
  paginationPageSizeSelector: !0,
  paginationAutoPageSize: !1,
  paginateChildRows: !1,
  suppressPaginationPanel: !1,
  pivotMode: !1,
  pivotPanelShow: "never",
  pivotDefaultExpanded: 0,
  pivotSuppressAutoColumn: !1,
  suppressExpandablePivotGroups: !1,
  functionsReadOnly: !1,
  suppressAggFuncInHeader: !1,
  alwaysAggregateAtRootLevel: !1,
  aggregateOnlyChangedColumns: !1,
  suppressAggFilteredOnly: !1,
  removePivotHeaderRowWhenSingleValueColumn: !1,
  animateRows: !0,
  enableCellChangeFlash: !1,
  cellFlashDelay: 500,
  cellFlashDuration: 500,
  cellFadeDelay: 1e3,
  cellFadeDuration: 1e3,
  allowShowChangeAfterFilter: !1,
  domLayout: "normal",
  ensureDomOrder: !1,
  enableRtl: !1,
  suppressColumnVirtualisation: !1,
  suppressMaxRenderedRowRestriction: !1,
  suppressRowVirtualisation: !1,
  rowDragManaged: !1,
  suppressRowDrag: !1,
  suppressMoveWhenRowDragging: !1,
  rowDragEntireRow: !1,
  rowDragMultiRow: !1,
  embedFullWidthRows: !1,
  groupDisplayType: "singleColumn",
  groupDefaultExpanded: 0,
  groupMaintainOrder: !1,
  groupSelectsChildren: !1,
  groupIncludeTotalFooter: !1,
  groupSuppressBlankHeader: !1,
  groupSelectsFiltered: !1,
  showOpenedGroup: !1,
  groupRemoveSingleChildren: !1,
  groupRemoveLowestSingleChildren: !1,
  groupHideOpenParents: !1,
  groupAllowUnbalanced: !1,
  rowGroupPanelShow: "never",
  suppressMakeColumnVisibleAfterUnGroup: !1,
  treeData: !1,
  rowGroupPanelSuppressSort: !1,
  suppressGroupRowsSticky: !1,
  rowModelType: "clientSide",
  asyncTransactionWaitMillis: 50,
  suppressModelUpdateAfterUpdateTransaction: !1,
  cacheOverflowSize: 1,
  infiniteInitialRowCount: 1,
  serverSideInitialRowCount: 1,
  suppressServerSideInfiniteScroll: !1,
  cacheBlockSize: 100,
  maxBlocksInCache: -1,
  maxConcurrentDatasourceRequests: 2,
  blockLoadDebounceMillis: 0,
  purgeClosedRowNodes: !1,
  serverSideSortAllLevels: !1,
  serverSideOnlyRefreshFilteredGroups: !1,
  serverSideSortOnServer: !1,
  serverSideFilterOnServer: !1,
  serverSidePivotResultFieldSeparator: "_",
  viewportRowModelPageSize: 5,
  viewportRowModelBufferSize: 5,
  alwaysShowHorizontalScroll: !1,
  alwaysShowVerticalScroll: !1,
  debounceVerticalScrollbar: !1,
  suppressHorizontalScroll: !1,
  suppressScrollOnNewData: !1,
  suppressScrollWhenPopupsAreOpen: !1,
  suppressAnimationFrame: !1,
  suppressMiddleClickScrolls: !1,
  suppressPreventDefaultOnMouseWheel: !1,
  rowMultiSelectWithClick: !1,
  suppressRowDeselection: !1,
  suppressRowClickSelection: !1,
  suppressCellFocus: !1,
  suppressHeaderFocus: !1,
  suppressMultiRangeSelection: !1,
  enableCellTextSelection: !1,
  enableRangeSelection: !1,
  enableRangeHandle: !1,
  enableFillHandle: !1,
  fillHandleDirection: "xy",
  suppressClearOnFillReduction: !1,
  accentedSort: !1,
  unSortIcon: !1,
  suppressMultiSort: !1,
  alwaysMultiSort: !1,
  suppressMaintainUnsortedOrder: !1,
  suppressRowHoverHighlight: !1,
  suppressRowTransform: !1,
  columnHoverHighlight: !1,
  deltaSort: !1,
  enableGroupEdit: !1,
  suppressGroupMaintainValueType: !1,
  groupLockGroupColumns: 0,
  serverSideEnableClientSideSort: !1,
  suppressServerSideFullWidthLoadingRow: !1,
  pivotMaxGeneratedColumns: -1,
  columnMenu: "new",
  reactiveCustomComponents: !0
}, xze = () => ({
  sideBar: {
    module: "@ag-grid-enterprise/side-bar"
    /* SideBarModule */
  },
  statusBar: {
    module: "@ag-grid-enterprise/status-bar"
    /* StatusBarModule */
  },
  enableCharts: {
    module: "@ag-grid-enterprise/charts"
    /* GridChartsModule */
  },
  getMainMenuItems: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  getContextMenuItems: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  allowContextMenuWithControlKey: {
    module: "@ag-grid-enterprise/menu"
    /* MenuModule */
  },
  enableAdvancedFilter: {
    module: "@ag-grid-enterprise/advanced-filter"
    /* AdvancedFilterModule */
  },
  treeData: {
    supportedRowModels: ["clientSide", "serverSide"],
    module: "@ag-grid-enterprise/row-grouping",
    dependencies: (e) => {
      const t = e.rowModelType ?? "clientSide";
      switch (t) {
        case "clientSide": {
          const r = `treeData requires 'getDataPath' in the ${t} row model.`;
          return e.getDataPath ? null : r;
        }
        case "serverSide": {
          const r = `treeData requires 'isServerSideGroup' and 'getServerSideGroupKey' in the ${t} row model.`;
          return e.isServerSideGroup && e.getServerSideGroupKey ? null : r;
        }
      }
      return null;
    }
  },
  masterDetail: {
    module: "@ag-grid-enterprise/master-detail"
    /* MasterDetailModule */
  },
  enableRangeSelection: {
    module: "@ag-grid-enterprise/range-selection"
    /* RangeSelectionModule */
  },
  enableRangeHandle: {
    dependencies: {
      enableRangeSelection: [!0]
    }
  },
  enableFillHandle: {
    dependencies: {
      enableRangeSelection: [!0]
    }
  },
  groupDefaultExpanded: {
    supportedRowModels: ["clientSide"]
  },
  groupIncludeFooter: {
    supportedRowModels: ["clientSide", "serverSide"],
    dependencies: (e) => {
      switch (e.rowModelType ?? "clientSide") {
        case "clientSide":
          return null;
        case "serverSide":
          return e.suppressServerSideInfiniteScroll ? "groupIncludeFooter is not supported alongside suppressServerSideInfiniteScroll" : null;
      }
      return null;
    }
  },
  groupHideOpenParents: {
    supportedRowModels: ["clientSide"],
    dependencies: {
      groupTotalRow: [void 0, "bottom"]
    }
  },
  groupIncludeTotalFooter: {
    supportedRowModels: ["clientSide"]
  },
  groupRemoveSingleChildren: {
    dependencies: {
      groupHideOpenParents: [void 0, !1],
      groupRemoveLowestSingleChildren: [void 0, !1]
    }
  },
  groupRemoveLowestSingleChildren: {
    dependencies: {
      groupHideOpenParents: [void 0, !1],
      groupRemoveSingleChildren: [void 0, !1]
    }
  },
  groupSelectsChildren: {
    dependencies: {
      rowSelection: ["multiple"]
    }
  },
  viewportDatasource: {
    supportedRowModels: ["viewport"],
    module: "@ag-grid-enterprise/viewport-row-model"
    /* ViewportRowModelModule */
  },
  serverSideDatasource: {
    supportedRowModels: ["serverSide"],
    module: "@ag-grid-enterprise/server-side-row-model"
    /* ServerSideRowModelModule */
  },
  cacheBlockSize: {
    supportedRowModels: ["serverSide", "infinite"]
  },
  datasource: {
    supportedRowModels: ["infinite"],
    module: "@ag-grid-community/infinite-row-model"
    /* InfiniteRowModelModule */
  },
  rowData: {
    supportedRowModels: ["clientSide"],
    module: "@ag-grid-community/client-side-row-model"
    /* ClientSideRowModelModule */
  },
  columnDefs: () => sh,
  defaultColDef: () => sh,
  defaultColGroupDef: () => sh,
  autoGroupColumnDef: () => sh
}), Eze = () => ({
  objectName: "gridOptions",
  allProperties: [...iv.ALL_PROPERTIES, ...ov.EVENT_CALLBACKS],
  propertyExceptions: ["api"],
  docsUrl: "grid-options/",
  deprecations: wze(),
  validations: xze()
}), Rze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "validationService";
  }
  wireBeans(e) {
    this.beans = e, this.gridOptions = e.gridOptions;
  }
  postConstruct() {
    this.processGridOptions(this.gridOptions);
  }
  processGridOptions(e) {
    this.processOptions(e, Eze());
  }
  processColumnDefs(e) {
    this.processOptions(e, sh);
  }
  warnMissingApiFunction(e) {
    gze(e, this.gridId);
  }
  validateApiFunction(e, t) {
    return vze(e, t, this.beans);
  }
  processOptions(e, t) {
    const { validations: r, deprecations: n, allProperties: i, propertyExceptions: o, objectName: a, docsUrl: s } = t;
    i && this.gridOptions.suppressPropertyNamesCheck !== !0 && this.checkProperties(
      e,
      [...o ?? [], ...Object.keys(n)],
      i,
      a,
      s
    );
    const l = /* @__PURE__ */ new Set();
    Object.keys(e).forEach((c) => {
      const d = n[c];
      if (d)
        if ("renamed" in d) {
          const { renamed: y, version: C } = d;
          l.add(
            `As of v${C}, ${String(c)} is deprecated. Please use ${String(y)} instead.`
          ), e[y] = e[c];
        } else {
          const { message: y, version: C } = d;
          l.add(`As of v${C}, ${String(c)} is deprecated. ${y ?? ""}`);
        }
      const h = e[c];
      if (h == null || h === !1)
        return;
      const f = r[c];
      let p;
      if (f)
        if (typeof f == "function") {
          const y = f(e, this.gridOptions);
          if (!y)
            return;
          if ("objectName" in y) {
            const C = e[c];
            if (Array.isArray(C)) {
              C.forEach((S) => {
                this.processOptions(S, y);
              });
              return;
            }
            this.processOptions(e[c], y);
            return;
          }
          p = y;
        } else
          p = f;
      else return;
      const { module: g, dependencies: v, supportedRowModels: m } = p;
      if (m) {
        const y = this.gridOptions.rowModelType ?? "clientSide";
        if (!m.includes(y)) {
          l.add(`${String(c)} is not supported with the '${y}' row model.`);
          return;
        }
      }
      if (g) {
        const y = Array.isArray(g) ? g : [g];
        let C = !0;
        if (y.forEach((S) => {
          Xn.__assertRegistered(S, String(c), this.gridId) || (C = !1, l.add(`${String(c)} is only available when ${S} is loaded.`));
        }), !C)
          return;
      }
      if (v) {
        const y = this.checkForWarning(c, v, e);
        if (y) {
          l.add(y);
          return;
        }
      }
    }), l.size > 0 && l.forEach((c) => {
      Se(c);
    });
  }
  checkForWarning(e, t, r) {
    if (typeof t == "function")
      return t(r, this.gridOptions);
    const i = Object.entries(t).find(([s, l]) => {
      const u = r[s];
      return !l.includes(u);
    });
    if (!i)
      return null;
    const [o, a] = i;
    return a.length > 1 ? `'${String(e)}' requires '${o}' to be one of [${a.join(", ")}].` : `'${String(e)}' requires '${o}' to be ${a[0]}.`;
  }
  checkProperties(e, t, r, n, i) {
    const o = ["__ob__", "__v_skip", "__metadata__"], a = QOe(
      Object.getOwnPropertyNames(e),
      [...o, ...t, ...r],
      r
    );
    if (ia(a, (s, l) => {
      let u = `invalid ${n} property '${s}' did you mean any of these: ${l.slice(0, 8).join(", ")}.`;
      r.includes("context") && (u += `
If you are trying to annotate ${n} with application data, use the '${n}.context' property instead.`), Se(u);
    }), Object.keys(a).length > 0 && i) {
      const s = this.getFrameworkOverrides().getDocLink(i);
      Se(`to see all the valid ${n} properties please check: ${s}`);
    }
  }
}, _ze = {
  version: Et,
  moduleName: "@ag-grid-community/core"
  /* CommunityCoreModule */
}, Tze = {
  version: Et,
  moduleName: "@ag-grid-community/core-validations",
  beans: [Rze]
}, EY = {
  version: Et,
  moduleName: "@ag-grid-community/core-community-features",
  dependantModules: [
    _ze,
    Tze,
    BBe,
    Fke,
    jHe,
    SGe,
    M4e,
    cze,
    HHe
  ]
}, Pze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "gridDestroyService", this.destroyCalled = !1;
  }
  wireBeans(e) {
    this.beans = e;
  }
  destroy() {
    var t, r;
    if (this.destroyCalled)
      return;
    const e = {
      type: "gridPreDestroyed",
      state: ((t = this.beans.stateService) == null ? void 0 : t.getState()) ?? {}
    };
    this.eventService.dispatchEvent(e), this.destroyCalled = !0, (r = this.beans.ctrlsService.get("gridCtrl")) == null || r.destroyGridUi(), this.beans.context.destroy(), super.destroy();
  }
  isDestroyCalled() {
    return this.destroyCalled;
  }
}, y0 = /* @__PURE__ */ new Set(["gridPreDestroyed", "fillStart", "pasteStart"]), Mze = (e) => e === "checkboxSelected" || e === "rowClicked" || e === "spaceKey" || e === "uiSelectAll" || e === "uiSelectAllCurrentPage" || e === "uiSelectAllFiltered", Dze = new Map([
  ...iv.BOOLEAN_PROPERTIES.map((e) => [e, wT]),
  ...iv.NUMBER_PROPERTIES.map((e) => [e, zK]),
  ["groupAggFiltering", (e) => typeof e == "function" ? e : wT(e)],
  ["pageSize", Aa(1)],
  ["autoSizePadding", Aa(0)],
  ["keepDetailRowsCount", Aa(1)],
  ["rowBuffer", Aa(0)],
  ["infiniteInitialRowCount", Aa(1)],
  ["cacheOverflowSize", Aa(1)],
  ["cacheBlockSize", Aa(1)],
  ["serverSideInitialRowCount", Aa(1)],
  ["viewportRowModelPageSize", Aa(1)],
  ["viewportRowModelBufferSize", Aa(0)]
]);
function RY(e, t) {
  const r = Dze.get(e);
  return r ? r(t) : t;
}
function Aze(e) {
  const t = {};
  return Object.entries(e).forEach(([r, n]) => {
    const i = RY(r, n);
    t[r] = i;
  }), t;
}
var _Y = class TY extends he {
  constructor() {
    super(...arguments), this.beanName = "gos", this.domDataKey = "__AG_" + Math.random().toString(), this.propertyEventService = new wf(), this.globalEventHandlerFactory = (t) => (r, n) => {
      if (!this.isAlive())
        return;
      const i = y0.has(r);
      if (i && !t || !i && t)
        return;
      const o = ov.getCallbackForEvent(r), a = this.gridOptions[o];
      typeof a == "function" && this.frameworkOverrides.wrapOutgoing(() => {
        a(n);
      });
    };
  }
  wireBeans(t) {
    this.gridOptions = t.gridOptions, this.eGridDiv = t.eGridDiv, this.validationService = t.validationService, this.environment = t.environment, this.api = t.gridApi;
  }
  // This is quicker then having code call gridOptionsService.get('context')
  get gridOptionsContext() {
    return this.gridOptions.context;
  }
  postConstruct() {
    const t = !this.get("suppressAsyncEvents");
    this.eventService.addGlobalListener(this.globalEventHandlerFactory().bind(this), t), this.eventService.addGlobalListener(this.globalEventHandlerFactory(!0).bind(this), !1), this.propertyEventService.setFrameworkOverrides(this.frameworkOverrides), this.getScrollbarWidth(), this.addManagedEventListeners({
      gridOptionsChanged: ({ options: r }) => {
        this.updateGridOptions({ options: r, force: !0, source: "gridOptionsUpdated" });
      }
    });
  }
  /**
   * Get the raw value of the GridOptions property provided.
   * @param property
   */
  get(t) {
    return this.gridOptions[t] ?? bze[t];
  }
  /**
   * Get the GridOption callback but wrapped so that the common params of api and context are automatically applied to the params.
   * @param property GridOption callback properties based on the fact that this property has a callback with params extending AgGridCommon
   */
  getCallback(t) {
    return this.mergeGridCommonParams(this.gridOptions[t]);
  }
  /**
   * Returns `true` if a value has been specified for this GridOption.
   * @param property GridOption property
   */
  exists(t) {
    return Me(this.gridOptions[t]);
  }
  /**
   * Wrap the user callback and attach the api and context to the params object on the way through.
   * @param callback User provided callback
   * @returns Wrapped callback where the params object not require api and context
   */
  mergeGridCommonParams(t) {
    return t && ((n) => {
      const i = n;
      return i.api = this.api, i.context = this.gridOptionsContext, t(i);
    });
  }
  updateGridOptions({
    options: t,
    force: r,
    source: n = "api"
  }) {
    var a;
    const i = { id: TY.changeSetId++, properties: [] }, o = [];
    Object.entries(t).forEach(([s, l]) => {
      n === "api" && oOe[s] && Se(`${s} is an initial property and cannot be updated.`);
      const u = RY(s, l), c = r || typeof u == "object" && n === "api", d = this.gridOptions[s];
      if (c || d !== u) {
        this.gridOptions[s] = u;
        const h = {
          type: s,
          currentValue: u,
          previousValue: d,
          changeSet: i,
          source: n
        };
        o.push(h);
      }
    }), (a = this.validationService) == null || a.processGridOptions(this.gridOptions), i.properties = o.map((s) => s.type), o.forEach((s) => {
      this.gridOptions.debug && sa(`Updated property ${s.type} from`, s.previousValue, " to ", s.currentValue), this.propertyEventService.dispatchEvent(s);
    });
  }
  addPropertyEventListener(t, r) {
    this.propertyEventService.addEventListener(t, r);
  }
  removePropertyEventListener(t, r) {
    this.propertyEventService.removeEventListener(t, r);
  }
  // *************** Helper methods ************************** //
  // Methods to share common GridOptions related logic that goes above accessing a single property
  // the user might be using some non-standard scrollbar, eg a scrollbar that has zero
  // width and overlays (like the Safari scrollbar, but presented in Chrome). so we
  // allow the user to provide the scroll width before we work it out.
  getScrollbarWidth() {
    if (this.scrollbarWidth == null) {
      const r = typeof this.gridOptions.scrollbarWidth == "number" && this.gridOptions.scrollbarWidth >= 0 ? this.gridOptions.scrollbarWidth : ROe();
      r != null && (this.scrollbarWidth = r, this.eventService.dispatchEvent({
        type: "scrollbarWidthChanged"
      }));
    }
    return this.scrollbarWidth;
  }
  isRowModelType(t) {
    return this.gridOptions.rowModelType === t || t === "clientSide" && Zt(this.gridOptions.rowModelType);
  }
  isDomLayout(t) {
    return (this.gridOptions.domLayout ?? "normal") === t;
  }
  isRowSelection() {
    return this.gridOptions.rowSelection === "single" || this.gridOptions.rowSelection === "multiple";
  }
  useAsyncEvents() {
    return !this.get("suppressAsyncEvents");
  }
  isGetRowHeightFunction() {
    return typeof this.gridOptions.getRowHeight == "function";
  }
  getRowHeightForNode(t, r = !1, n) {
    if (n == null && (n = this.environment.getDefaultRowHeight()), this.isGetRowHeightFunction()) {
      if (r)
        return { height: n, estimated: !0 };
      const o = {
        node: t,
        data: t.data
      }, a = this.getCallback("getRowHeight")(o);
      if (this.isNumeric(a))
        return a === 0 && Se(
          "The return of `getRowHeight` cannot be zero. If the intention is to hide rows, use a filter instead."
        ), { height: Math.max(1, a), estimated: !1 };
    }
    return t.detail && this.get("masterDetail") ? this.getMasterDetailRowHeight() : { height: this.gridOptions.rowHeight && this.isNumeric(this.gridOptions.rowHeight) ? this.gridOptions.rowHeight : n, estimated: !1 };
  }
  getMasterDetailRowHeight() {
    return this.get("detailRowAutoHeight") ? { height: 1, estimated: !1 } : this.isNumeric(this.gridOptions.detailRowHeight) ? { height: this.gridOptions.detailRowHeight, estimated: !1 } : { height: 300, estimated: !1 };
  }
  // we don't allow dynamic row height for virtual paging
  getRowHeightAsNumber() {
    if (!this.gridOptions.rowHeight || Zt(this.gridOptions.rowHeight))
      return this.environment.getDefaultRowHeight();
    const t = this.environment.refreshRowHeightVariable();
    return t !== -1 ? t : (Se("row height must be a number if not using standard row model"), this.environment.getDefaultRowHeight());
  }
  isNumeric(t) {
    return !isNaN(t) && typeof t == "number" && isFinite(t);
  }
  getDomDataKey() {
    return this.domDataKey;
  }
  // returns the dom data, or undefined if not found
  getDomData(t, r) {
    const n = t[this.getDomDataKey()];
    return n ? n[r] : void 0;
  }
  setDomData(t, r, n) {
    const i = this.getDomDataKey();
    let o = t[i];
    Zt(o) && (o = {}, t[i] = o), o[r] = n;
  }
  getDocument() {
    let t = null;
    return this.gridOptions.getDocument && Me(this.gridOptions.getDocument) ? t = this.gridOptions.getDocument() : this.eGridDiv && (t = this.eGridDiv.ownerDocument), t && Me(t) ? t : document;
  }
  getWindow() {
    return this.getDocument().defaultView || window;
  }
  getRootNode() {
    return this.eGridDiv.getRootNode();
  }
  getActiveDomElement() {
    return this.getRootNode().activeElement;
  }
  getAsyncTransactionWaitMillis() {
    return Me(this.gridOptions.asyncTransactionWaitMillis) ? this.gridOptions.asyncTransactionWaitMillis : 50;
  }
  isAnimateRows() {
    return this.get("ensureDomOrder") ? !1 : this.get("animateRows");
  }
  isGroupRowsSticky() {
    return !(this.get("paginateChildRows") || this.get("groupHideOpenParents") || this.isDomLayout("print"));
  }
  isColumnsSortingCoupledToGroup() {
    const t = this.gridOptions.autoGroupColumnDef;
    return !(t != null && t.comparator) && !this.get("treeData");
  }
  getGroupAggFiltering() {
    const t = this.gridOptions.groupAggFiltering;
    if (typeof t == "function")
      return this.getCallback("groupAggFiltering");
    if (t === !0)
      return () => !0;
  }
  getGrandTotalRow() {
    const t = this.gridOptions.grandTotalRow;
    if (t)
      return t;
    if (this.gridOptions.groupIncludeTotalFooter)
      return "bottom";
  }
  getGroupTotalRowCallback() {
    const t = this.get("groupTotalRow");
    if (typeof t == "function")
      return this.getCallback("groupTotalRow");
    if (t)
      return () => t;
    const r = this.get("groupIncludeFooter");
    if (typeof r == "function") {
      const n = this.getCallback("groupIncludeFooter");
      return (i) => n(i) ? "bottom" : void 0;
    }
    return () => r ? "bottom" : void 0;
  }
  isGroupMultiAutoColumn() {
    return this.gridOptions.groupDisplayType ? this.gridOptions.groupDisplayType === "multipleColumns" : this.get("groupHideOpenParents");
  }
  isGroupUseEntireRow(t) {
    return t ? !1 : this.gridOptions.groupDisplayType === "groupRows";
  }
  getGridCommonParams() {
    return {
      api: this.api,
      context: this.gridOptionsContext
    };
  }
  addGridCommonParams(t) {
    const r = t;
    return r.api = this.api, r.context = this.gridOptionsContext, r;
  }
  // AG-9259 Can't use `WrappedCallback<'getRowId', ...>` here because of a strange typescript bug
  getRowIdCallback() {
    const t = this.getCallback("getRowId");
    return t === void 0 ? t : (r) => {
      let n = t(r);
      return typeof n != "string" && (Se("The getRowId callback must return a string. The ID ", n, " is being cast to a string."), n = String(n)), n;
    };
  }
};
_Y.changeSetId = 0;
var Ize = _Y, Fze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "headerPositionUtils";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.ctrlsService = e.ctrlsService;
  }
  findHeader(e, t) {
    let r, n;
    if (an(e.column) ? r = this.visibleColsService.getGroupAtDirection(e.column, t) : (n = `getCol${t}`, r = this.visibleColsService[n](e.column)), !r)
      return;
    const { headerRowIndex: i } = e;
    if (this.getHeaderRowType(i) !== "filter") {
      const s = [r];
      for (; r.getParent(); )
        r = r.getParent(), s.push(r);
      r = s[s.length - 1 - i];
    }
    const { column: o, headerRowIndex: a } = this.getHeaderIndexToFocus(r, i);
    return {
      column: o,
      headerRowIndex: a
    };
  }
  getHeaderIndexToFocus(e, t) {
    let r;
    if (an(e) && this.isAnyChildSpanningHeaderHeight(e) && e.isPadding()) {
      const n = e;
      r = n.getLeafColumns()[0];
      let i = r;
      for (; i !== n; )
        t++, i = i.getParent();
    }
    return {
      column: r || e,
      headerRowIndex: t
    };
  }
  isAnyChildSpanningHeaderHeight(e) {
    return e ? e.getLeafColumns().some((t) => t.isSpanHeaderHeight()) : !1;
  }
  getColumnVisibleParent(e, t) {
    const r = this.getHeaderRowType(t), n = r === "filter", i = r === "column";
    let o = n ? e : e.getParent(), a = t - 1, s = a;
    if (i && this.isAnyChildSpanningHeaderHeight(e.getParent())) {
      for (; o && o.isPadding(); )
        o = o.getParent(), a--;
      s = a, a < 0 && (o = e, a = t, s = void 0);
    }
    return { column: o, headerRowIndex: a, headerRowIndexWithoutSpan: s };
  }
  getColumnVisibleChild(e, t, r = "After") {
    const n = this.getHeaderRowType(t);
    let i = e, o = t + 1;
    const a = o;
    if (n === "group") {
      const s = e.getDisplayedLeafColumns(), l = r === "After" ? s[0] : Jt(s), u = [];
      let c = l;
      for (; c.getParent() !== e; )
        c = c.getParent(), u.push(c);
      if (i = l, l.isSpanHeaderHeight())
        for (let d = u.length - 1; d >= 0; d--) {
          const h = u[d];
          if (!h.isPadding()) {
            i = h;
            break;
          }
          o++;
        }
      else
        i = Jt(u), i || (i = l);
    }
    return { column: i, headerRowIndex: o, headerRowIndexWithoutSpan: a };
  }
  getHeaderRowType(e) {
    const t = this.ctrlsService.getHeaderRowContainerCtrl();
    if (t)
      return t.getRowType(e);
  }
  findColAtEdgeForHeaderRow(e, t) {
    const r = this.visibleColsService.getAllCols(), n = r[t === "start" ? 0 : r.length - 1];
    if (!n)
      return;
    const o = this.ctrlsService.getHeaderRowContainerCtrl(n.getPinned()).getRowType(e);
    if (o == "group") {
      const a = this.visibleColsService.getColGroupAtLevel(n, e);
      return {
        headerRowIndex: e,
        column: a
      };
    }
    return {
      // if type==null, means the header level didn't exist
      headerRowIndex: o == null ? -1 : e,
      column: n
    };
  }
}, Lze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "localeService";
  }
  getLocaleTextFunc() {
    const e = this.gos.getCallback("getLocaleText");
    if (e)
      return (r, n, i) => e({
        key: r,
        defaultValue: n,
        variableValues: i
      });
    const t = this.gos.get("localeText");
    return (r, n, i) => {
      let o = t && t[r];
      if (o && i && i.length) {
        let a = 0;
        for (; !(a >= i.length || o.indexOf("${variable}") === -1); )
          o = o.replace("${variable}", i[a++]);
      }
      return o ?? n;
    };
  }
}, Oze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "apiEventService", this.syncEventListeners = /* @__PURE__ */ new Map(), this.asyncEventListeners = /* @__PURE__ */ new Map(), this.syncGlobalEventListeners = /* @__PURE__ */ new Set(), this.globalEventListenerPairs = /* @__PURE__ */ new Map();
  }
  postConstruct() {
    this.frameworkEventWrappingService = new fA(this.getFrameworkOverrides());
  }
  addEventListener(e, t) {
    const r = this.frameworkEventWrappingService.wrap(t), n = this.gos.useAsyncEvents() && !y0.has(e), i = n ? this.asyncEventListeners : this.syncEventListeners;
    i.has(e) || i.set(e, /* @__PURE__ */ new Set()), i.get(e).add(r), this.eventService.addEventListener(e, r, n);
  }
  removeEventListener(e, t) {
    var o;
    const r = this.frameworkEventWrappingService.unwrap(t), n = this.asyncEventListeners.get(e), i = !!(n != null && n.delete(r));
    i || (o = this.syncEventListeners.get(e)) == null || o.delete(r), this.eventService.removeEventListener(e, r, i);
  }
  addGlobalListener(e) {
    const t = this.frameworkEventWrappingService.wrapGlobal(e);
    if (this.gos.useAsyncEvents()) {
      const n = (o, a) => {
        y0.has(o) && t(o, a);
      }, i = (o, a) => {
        y0.has(o) || t(o, a);
      };
      this.globalEventListenerPairs.set(e, { syncListener: n, asyncListener: i }), this.eventService.addGlobalListener(n, !1), this.eventService.addGlobalListener(i, !0);
    } else
      this.syncGlobalEventListeners.add(t), this.eventService.addGlobalListener(t, !1);
  }
  removeGlobalListener(e) {
    const t = this.frameworkEventWrappingService.unwrapGlobal(e);
    if (this.globalEventListenerPairs.has(t)) {
      const { syncListener: n, asyncListener: i } = this.globalEventListenerPairs.get(t);
      this.eventService.removeGlobalListener(n, !1), this.eventService.removeGlobalListener(i, !0), this.globalEventListenerPairs.delete(e);
    } else
      this.syncGlobalEventListeners.delete(t), this.eventService.removeGlobalListener(t, !1);
  }
  destroyEventListeners(e, t) {
    e.forEach((r, n) => {
      r.forEach((i) => this.eventService.removeEventListener(n, i, t)), r.clear();
    }), e.clear();
  }
  destroyGlobalListeners(e, t) {
    e.forEach((r) => this.eventService.removeGlobalListener(r, t)), e.clear();
  }
  destroy() {
    super.destroy(), this.destroyEventListeners(this.syncEventListeners, !1), this.destroyEventListeners(this.asyncEventListeners, !0), this.destroyGlobalListeners(this.syncGlobalEventListeners, !1), this.globalEventListenerPairs.forEach(({ syncListener: e, asyncListener: t }) => {
      this.eventService.removeGlobalListener(e, !1), this.eventService.removeGlobalListener(t, !0);
    }), this.globalEventListenerPairs.clear();
  }
}, Nze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsListener";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.paginationService = e.paginationService, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.addManagedEventListeners({
      modelUpdated: this.onModelUpdated.bind(this),
      recalculateRowBounds: this.calculatePages.bind(this)
    }), this.onModelUpdated();
  }
  onModelUpdated(e) {
    this.calculatePages();
    const t = {
      type: "paginationChanged",
      animate: e ? e.animate : !1,
      newData: e ? e.newData : !1,
      newPage: e ? e.newPage : !1,
      newPageSize: e ? e.newPageSize : !1,
      keepRenderedRows: e ? e.keepRenderedRows : !1
    };
    this.eventService.dispatchEvent(t);
  }
  calculatePages() {
    this.paginationService ? this.paginationService.calculatePages() : this.pageBoundsService.calculateBounds(0, this.rowModel.getRowCount() - 1);
  }
}, kze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "pageBoundsService", this.pixelOffset = 0;
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  getFirstRow() {
    return this.topRowBounds ? this.topRowBounds.rowIndex : -1;
  }
  getLastRow() {
    return this.bottomRowBounds ? this.bottomRowBounds.rowIndex : -1;
  }
  getCurrentPageHeight() {
    return Zt(this.topRowBounds) || Zt(this.bottomRowBounds) ? 0 : Math.max(this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight - this.topRowBounds.rowTop, 0);
  }
  getCurrentPagePixelRange() {
    const e = this.topRowBounds ? this.topRowBounds.rowTop : 0, t = this.bottomRowBounds ? this.bottomRowBounds.rowTop + this.bottomRowBounds.rowHeight : 0;
    return { pageFirstPixel: e, pageLastPixel: t };
  }
  calculateBounds(e, t) {
    this.topRowBounds = this.rowModel.getRowBounds(e), this.topRowBounds && (this.topRowBounds.rowIndex = e), this.bottomRowBounds = this.rowModel.getRowBounds(t), this.bottomRowBounds && (this.bottomRowBounds.rowIndex = t), this.calculatePixelOffset();
  }
  getPixelOffset() {
    return this.pixelOffset;
  }
  calculatePixelOffset() {
    const e = Me(this.topRowBounds) ? this.topRowBounds.rowTop : 0;
    this.pixelOffset !== e && (this.pixelOffset = e, this.eventService.dispatchEvent({ type: "paginationPixelOffsetChanged" }));
  }
}, Vze = class extends he {
  constructor() {
    super(), this.beanName = "ariaAnnouncementService", this.descriptionContainer = null, this.announceValue = vi(this.announceValue.bind(this), 200);
  }
  wireBeans(e) {
    this.eGridDiv = e.eGridDiv;
  }
  postConstruct() {
    const e = this.gos.getDocument(), t = this.descriptionContainer = e.createElement("div");
    t.classList.add("ag-aria-description-container"), aK(t, "polite"), dOe(t, "additions text"), cOe(t, !0), this.eGridDiv.appendChild(t);
  }
  announceValue(e) {
    this.descriptionContainer && (this.descriptionContainer.textContent = "", setTimeout(() => {
      this.isAlive() && this.descriptionContainer && (this.descriptionContainer.textContent = e);
    }, 50));
  }
  destroy() {
    super.destroy();
    const { descriptionContainer: e } = this;
    e && (oo(e), e.parentElement && e.parentElement.removeChild(e)), this.descriptionContainer = null, this.eGridDiv = null;
  }
}, Bze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnAnimationService", this.executeNextFuncs = [], this.executeLaterFuncs = [], this.active = !1, this.suppressAnimation = !1, this.animationThreadCount = 0;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.ctrlsService.whenReady((e) => this.gridBodyCtrl = e.gridBodyCtrl);
  }
  isActive() {
    return this.active && !this.suppressAnimation;
  }
  setSuppressAnimation(e) {
    this.suppressAnimation = e;
  }
  start() {
    this.active || this.gos.get("suppressColumnMoveAnimation") || this.gos.get("enableRtl") || (this.ensureAnimationCssClassPresent(), this.active = !0);
  }
  finish() {
    this.active && this.flush(() => {
      this.active = !1;
    });
  }
  executeNextVMTurn(e) {
    this.active ? this.executeNextFuncs.push(e) : e();
  }
  executeLaterVMTurn(e) {
    this.active ? this.executeLaterFuncs.push(e) : e();
  }
  ensureAnimationCssClassPresent() {
    this.animationThreadCount++;
    const e = this.animationThreadCount;
    this.gridBodyCtrl.setColumnMovingCss(!0), this.executeLaterFuncs.push(() => {
      this.animationThreadCount === e && this.gridBodyCtrl.setColumnMovingCss(!1);
    });
  }
  flush(e) {
    if (this.executeNextFuncs.length === 0 && this.executeLaterFuncs.length === 0) {
      e();
      return;
    }
    const t = (r) => {
      for (; r.length; ) {
        const n = r.pop();
        n && n();
      }
    };
    this.getFrameworkOverrides().wrapIncoming(() => {
      window.setTimeout(() => t(this.executeNextFuncs), 0), window.setTimeout(() => {
        e(), t(this.executeLaterFuncs);
      }, 200);
    });
  }
}, Gze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "columnHoverService";
  }
  setMouseOver(e) {
    this.selectedColumns = e;
    const t = {
      type: "columnHoverChanged"
    };
    this.eventService.dispatchEvent(t);
  }
  clearMouseOver() {
    this.selectedColumns = null;
    const e = {
      type: "columnHoverChanged"
    };
    this.eventService.dispatchEvent(e);
  }
  isHovered(e) {
    return !!this.selectedColumns && this.selectedColumns.indexOf(e) >= 0;
  }
}, Hze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "overlayService", this.state = 0, this.showInitialOverlay = !0;
  }
  wireBeans(e) {
    this.userComponentFactory = e.userComponentFactory, this.rowModel = e.rowModel, this.columnModel = e.columnModel;
  }
  postConstruct() {
    const e = () => this.updateOverlayVisibility();
    this.addManagedEventListeners({
      newColumnsLoaded: e,
      rowDataUpdated: e
    }), this.addManagedPropertyListener("loading", e);
  }
  registerOverlayWrapperComp(e) {
    this.overlayWrapperComp = e, this.updateOverlayVisibility();
  }
  showLoadingOverlay() {
    this.showInitialOverlay = !1;
    const e = this.gos.get("loading");
    !e && (e !== void 0 || this.gos.get("suppressLoadingOverlay")) || this.doShowLoadingOverlay();
  }
  showNoRowsOverlay() {
    this.showInitialOverlay = !1, !(this.gos.get("loading") || this.gos.get("suppressNoRowsOverlay")) && this.doShowNoRowsOverlay();
  }
  hideOverlay() {
    this.showInitialOverlay = !1, !this.gos.get("loading") && this.doHideOverlay();
  }
  updateOverlayVisibility() {
    let e = this.gos.get("loading");
    this.showInitialOverlay && e === void 0 && !this.gos.get("suppressLoadingOverlay") && (e = !this.gos.get("columnDefs") || !this.columnModel.isReady() || !this.gos.get("rowData") && this.gos.isRowModelType("clientSide")), e ? this.state !== 1 && this.doShowLoadingOverlay() : (this.showInitialOverlay = !1, this.rowModel.isEmpty() && !this.gos.get("suppressNoRowsOverlay") && this.gos.isRowModelType("clientSide") ? this.state !== 2 && this.doShowNoRowsOverlay() : this.state !== 0 && this.doHideOverlay());
  }
  doShowLoadingOverlay() {
    this.state = 1, this.showOverlay(
      this.userComponentFactory.getLoadingOverlayCompDetails({}),
      "ag-overlay-loading-wrapper",
      "loadingOverlayComponentParams"
    );
  }
  doShowNoRowsOverlay() {
    this.state = 2, this.showOverlay(
      this.userComponentFactory.getNoRowsOverlayCompDetails({}),
      "ag-overlay-no-rows-wrapper",
      "noRowsOverlayComponentParams"
    );
  }
  doHideOverlay() {
    this.state = 0, this.overlayWrapperComp.hideOverlay();
  }
  showOverlay(e, t, r) {
    const n = e.newAgStackInstance();
    this.overlayWrapperComp.showOverlay(n, t, r);
  }
}, zze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowCssClassCalculator";
  }
  wireBeans(e) {
    this.stylingService = e.stylingService;
  }
  getInitialRowClasses(e) {
    const t = [];
    return Me(e.extraCssClass) && t.push(e.extraCssClass), t.push("ag-row"), t.push(e.rowFocused ? "ag-row-focus" : "ag-row-no-focus"), e.fadeRowIn && t.push("ag-opacity-zero"), t.push(e.rowIsEven ? "ag-row-even" : "ag-row-odd"), e.rowNode.isRowPinned() && t.push("ag-row-pinned"), e.rowNode.isSelected() && t.push("ag-row-selected"), e.rowNode.footer && t.push("ag-row-footer"), t.push("ag-row-level-" + e.rowLevel), e.rowNode.stub && t.push("ag-row-loading"), e.fullWidthRow && t.push("ag-full-width-row"), e.expandable && (t.push("ag-row-group"), t.push(e.rowNode.expanded ? "ag-row-group-expanded" : "ag-row-group-contracted")), e.rowNode.dragging && t.push("ag-row-dragging"), xG(t, this.processClassesFromGridOptions(e.rowNode)), xG(t, this.preProcessRowClassRules(e.rowNode)), t.push(e.printLayout ? "ag-row-position-relative" : "ag-row-position-absolute"), e.firstRowOnPage && t.push("ag-row-first"), e.lastRowOnPage && t.push("ag-row-last"), e.fullWidthRow && (e.pinned === "left" && t.push("ag-cell-last-left-pinned"), e.pinned === "right" && t.push("ag-cell-first-right-pinned")), t;
  }
  processClassesFromGridOptions(e) {
    const t = [], r = (o) => {
      typeof o == "string" ? t.push(o) : Array.isArray(o) && o.forEach((a) => t.push(a));
    }, n = this.gos.get("rowClass");
    if (n) {
      if (typeof n == "function")
        return Se("rowClass should not be a function, please use getRowClass instead"), [];
      r(n);
    }
    const i = this.gos.getCallback("getRowClass");
    if (i) {
      const o = {
        data: e.data,
        node: e,
        rowIndex: e.rowIndex
      }, a = i(o);
      r(a);
    }
    return t;
  }
  preProcessRowClassRules(e) {
    const t = [];
    return this.processRowClassRules(
      e,
      (r) => {
        t.push(r);
      },
      () => {
      }
    ), t;
  }
  processRowClassRules(e, t, r) {
    const n = this.gos.addGridCommonParams({
      data: e.data,
      node: e,
      rowIndex: e.rowIndex
    });
    this.stylingService.processClassRules(
      void 0,
      this.gos.get("rowClassRules"),
      n,
      t,
      r
    );
  }
  calculateRowLevel(e) {
    return e.group ? e.level : e.parent ? e.parent.level + 1 : 0;
  }
}, $ze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowContainerHeightService", this.scrollY = 0, this.uiBodyHeight = 0;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  postConstruct() {
    this.addManagedEventListeners({ bodyHeightChanged: this.updateOffset.bind(this) }), this.maxDivHeight = bOe(), this.gos.get("debug") && sa("RowContainerHeightService - maxDivHeight = " + this.maxDivHeight);
  }
  isStretching() {
    return this.stretching;
  }
  getDivStretchOffset() {
    return this.divStretchOffset;
  }
  updateOffset() {
    if (!this.stretching)
      return;
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition().top, r = this.getUiBodyHeight();
    (t !== this.scrollY || r !== this.uiBodyHeight) && (this.scrollY = t, this.uiBodyHeight = r, this.calculateOffset());
  }
  calculateOffset() {
    this.setUiContainerHeight(this.maxDivHeight), this.pixelsToShave = this.modelHeight - this.uiContainerHeight, this.maxScrollY = this.uiContainerHeight - this.uiBodyHeight;
    const e = this.scrollY / this.maxScrollY, t = e * this.pixelsToShave;
    this.gos.get("debug") && sa(
      `RowContainerHeightService - Div Stretch Offset = ${t} (${this.pixelsToShave} * ${e})`
    ), this.setDivStretchOffset(t);
  }
  setUiContainerHeight(e) {
    e !== this.uiContainerHeight && (this.uiContainerHeight = e, this.eventService.dispatchEvent({ type: "rowContainerHeightChanged" }));
  }
  clearOffset() {
    this.setUiContainerHeight(this.modelHeight), this.pixelsToShave = 0, this.setDivStretchOffset(0);
  }
  setDivStretchOffset(e) {
    const t = typeof e == "number" ? Math.floor(e) : null;
    this.divStretchOffset !== t && (this.divStretchOffset = t, this.eventService.dispatchEvent({ type: "heightScaleChanged" }));
  }
  setModelHeight(e) {
    this.modelHeight = e, this.stretching = e != null && // null happens when in print layout
    this.maxDivHeight > 0 && e > this.maxDivHeight, this.stretching ? this.calculateOffset() : this.clearOffset();
  }
  getUiContainerHeight() {
    return this.uiContainerHeight;
  }
  getRealPixelPosition(e) {
    return e - this.divStretchOffset;
  }
  getUiBodyHeight() {
    const t = this.ctrlsService.getGridBodyCtrl().getScrollFeature().getVScrollPosition();
    return t.bottom - t.top;
  }
  getScrollPositionForPixel(e) {
    if (this.pixelsToShave <= 0)
      return e;
    const t = this.modelHeight - this.getUiBodyHeight(), r = e / t;
    return this.maxScrollY * r;
  }
}, Wze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowNodeSorter";
  }
  wireBeans(e) {
    this.valueService = e.valueService, this.columnModel = e.columnModel, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  postConstruct() {
    this.isAccentedSort = this.gos.get("accentedSort"), this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup(), this.addManagedPropertyListener(
      "accentedSort",
      (e) => this.isAccentedSort = e.currentValue
    ), this.addManagedPropertyListener(
      "autoGroupColumnDef",
      () => this.primaryColumnsSortGroups = this.gos.isColumnsSortingCoupledToGroup()
    );
  }
  doFullSort(e, t) {
    const r = (i, o) => ({ currentPos: o, rowNode: i }), n = e.map(r);
    return n.sort(this.compareRowNodes.bind(this, t)), n.map((i) => i.rowNode);
  }
  compareRowNodes(e, t, r) {
    const n = t.rowNode, i = r.rowNode;
    for (let o = 0, a = e.length; o < a; o++) {
      const s = e[o], l = s.sort === "desc", u = this.getValue(n, s.column), c = this.getValue(i, s.column);
      let d;
      const h = this.getComparator(s, n);
      if (h ? d = h(u, c, n, i, l) : d = FLe(u, c, this.isAccentedSort), !isNaN(d) && d !== 0)
        return s.sort === "asc" ? d : d * -1;
    }
    return t.currentPos - r.currentPos;
  }
  getComparator(e, t) {
    const r = e.column, n = r.getColDef().comparator;
    if (n != null)
      return n;
    if (!r.getColDef().showRowGroup)
      return;
    const i = !t.group && r.getColDef().field;
    if (!i)
      return;
    const o = this.columnModel.getColDefCol(i);
    if (o)
      return o.getColDef().comparator;
  }
  getValue(e, t) {
    var n, i, o;
    if (!this.primaryColumnsSortGroups)
      return this.valueService.getValue(t, e, !1, !1);
    if (e.rowGroupColumn === t) {
      if (this.gos.isGroupUseEntireRow(this.columnModel.isPivotActive())) {
        const l = (n = e.allLeafChildren) == null ? void 0 : n[0];
        return l ? this.valueService.getValue(t, l, !1, !1) : void 0;
      }
      const s = (i = this.showRowGroupColsService) == null ? void 0 : i.getShowRowGroupCol(t.getId());
      return s ? (o = e.groupData) == null ? void 0 : o[s.getId()] : void 0;
    }
    if (!(e.group && t.getColDef().showRowGroup))
      return this.valueService.getValue(t, e, !1, !1);
  }
}, Cw = class {
  constructor(e, t) {
    this.active = !0, this.nodeIdsToColumns = {}, this.mapToItems = {}, this.keepingColumns = e, this.pathRoot = {
      rowNode: t,
      children: null
    }, this.mapToItems[t.id] = this.pathRoot;
  }
  // can be set inactive by:
  // a) ClientSideRowModel, if no transactions or
  // b) PivotService, if secondary columns changed
  setInactive() {
    this.active = !1;
  }
  isActive() {
    return this.active;
  }
  depthFirstSearchChangedPath(e, t) {
    if (e.children)
      for (let r = 0; r < e.children.length; r++)
        this.depthFirstSearchChangedPath(e.children[r], t);
    t(e.rowNode);
  }
  depthFirstSearchEverything(e, t, r) {
    if (e.childrenAfterGroup)
      for (let n = 0; n < e.childrenAfterGroup.length; n++) {
        const i = e.childrenAfterGroup[n];
        i.childrenAfterGroup ? this.depthFirstSearchEverything(e.childrenAfterGroup[n], t, r) : r && t(i);
      }
    t(e);
  }
  // traverseLeafNodes -> used when NOT doing changed path, ie traversing everything. the callback
  // will be called for child nodes in addition to parent nodes.
  forEachChangedNodeDepthFirst(e, t = !1, r = !1) {
    this.active && !r ? this.depthFirstSearchChangedPath(this.pathRoot, e) : this.depthFirstSearchEverything(this.pathRoot.rowNode, e, t);
  }
  executeFromRootNode(e) {
    e(this.pathRoot.rowNode);
  }
  createPathItems(e) {
    let t = e, r = 0;
    for (; !this.mapToItems[t.id]; ) {
      const n = {
        rowNode: t,
        children: null
      };
      this.mapToItems[t.id] = n, r++, t = t.parent;
    }
    return r;
  }
  populateColumnsMap(e, t) {
    if (!this.keepingColumns || !t)
      return;
    let r = e;
    for (; r; )
      this.nodeIdsToColumns[r.id] || (this.nodeIdsToColumns[r.id] = {}), t.forEach((n) => this.nodeIdsToColumns[r.id][n.getId()] = !0), r = r.parent;
  }
  linkPathItems(e, t) {
    let r = e;
    for (let n = 0; n < t; n++) {
      const i = this.mapToItems[r.id], o = this.mapToItems[r.parent.id];
      o.children || (o.children = []), o.children.push(i), r = r.parent;
    }
  }
  // called by
  // 1) change detection (provides cols) and
  // 2) groupStage if doing transaction update (doesn't provide cols)
  addParentNode(e, t) {
    if (!e || e.isRowPinned())
      return;
    const r = this.createPathItems(e);
    this.linkPathItems(e, r), this.populateColumnsMap(e, t);
  }
  canSkip(e) {
    return this.active && !this.mapToItems[e.id];
  }
  getValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return t;
    const r = this.nodeIdsToColumns[e.id];
    return t.filter((i) => r[i.getId()]);
  }
  getNotValueColumnsForNode(e, t) {
    if (!this.keepingColumns)
      return null;
    const r = this.nodeIdsToColumns[e.id];
    return t.filter((i) => !r[i.getId()]);
  }
}, PY = class extends he {
  constructor() {
    super(...arguments), this.beanName = "selectionService", this.selectedNodes = /* @__PURE__ */ new Map(), this.selectionCtx = new YBe();
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.pageBoundsService = e.pageBoundsService;
  }
  postConstruct() {
    this.selectionCtx.init(this.rowModel), this.rowSelection = this.gos.get("rowSelection"), this.groupSelectsChildren = this.gos.get("groupSelectsChildren"), this.addManagedPropertyListeners(["groupSelectsChildren", "rowSelection"], () => {
      this.groupSelectsChildren = this.gos.get("groupSelectsChildren"), this.rowSelection = this.gos.get("rowSelection"), this.deselectAllRowNodes({ source: "api" });
    }), this.addManagedEventListeners({ rowSelected: this.onRowSelected.bind(this) });
  }
  destroy() {
    super.destroy(), this.resetNodes(), this.selectionCtx.reset();
  }
  isMultiselect() {
    return this.rowSelection === "multiple";
  }
  /**
   * We override the selection value for UI-triggered events because it's the
   * current selection state that should determine the next selection state. This
   * is a stepping stone towards removing selection logic from event listeners and
   * other code external to the selection service(s).
   */
  overrideSelectionValue(e, t) {
    if (!Mze(t))
      return e;
    const r = this.selectionCtx.getRoot();
    return r ? r.isSelected() ?? !1 : !0;
  }
  setNodesSelected(e) {
    var d;
    const { newValue: t, clearSelection: r, suppressFinishActions: n, rangeSelect: i, nodes: o, event: a, source: s } = e;
    if (o.length === 0)
      return 0;
    if (o.length > 1 && !this.isMultiselect())
      return Se("cannot multi select while rowSelection='single'"), 0;
    const l = this.groupSelectsChildren && e.groupSelectsFiltered === !0, u = o.map((h) => h.footer ? h.sibling : h);
    if (i) {
      if (u.length > 1)
        return Se("cannot range select while selecting multiple rows"), 0;
      const h = u[0], f = this.overrideSelectionValue(t, s);
      if (this.isMultiselect()) {
        if (this.selectionCtx.isInRange(h)) {
          const p = this.selectionCtx.truncate(h);
          return f && this.selectRange(p.discard, !1, s), this.selectRange(p.keep, f, s);
        } else if (this.selectionCtx.getRoot() !== h) {
          const v = this.selectionCtx.extend(h, this.groupSelectsChildren);
          return f && this.selectRange(v.discard, !1, s), this.selectRange(v.keep, f, s);
        }
      }
    }
    n || this.selectionCtx.setRoot(u[0]);
    let c = 0;
    for (let h = 0; h < u.length; h++) {
      const f = u[h];
      l && f.group || f.selectThisNode(t, a, s) && c++, this.groupSelectsChildren && ((d = f.childrenAfterGroup) != null && d.length) && (c += this.selectChildren(f, t, l, s));
    }
    return n || (t && (r || !this.isMultiselect()) && (c += this.clearOtherNodes(u[0], s)), c > 0 && (this.updateGroupsFromChildrenSelections(s), this.dispatchSelectionChanged(s))), c;
  }
  // not to be mixed up with 'cell range selection' where you drag the mouse, this is row range selection, by
  // holding down 'shift'.
  selectRange(e, t, r) {
    let n = 0;
    return e.forEach((i) => {
      if (i.group && this.groupSelectsChildren)
        return;
      i.selectThisNode(t, void 0, r) && n++;
    }), n > 0 && (this.updateGroupsFromChildrenSelections(r), this.dispatchSelectionChanged(r)), n;
  }
  selectChildren(e, t, r, n) {
    const i = r ? e.childrenAfterAggFilter : e.childrenAfterGroup;
    return Zt(i) ? 0 : this.setNodesSelected({
      newValue: t,
      clearSelection: !1,
      suppressFinishActions: !0,
      groupSelectsFiltered: r,
      source: n,
      nodes: i
    });
  }
  getSelectedNodes() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && e.push(t);
    }), e;
  }
  getSelectedRows() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t && t.data && e.push(t.data);
    }), e;
  }
  getSelectionCount() {
    return this.selectedNodes.size;
  }
  /**
   * This method is used by the CSRM to remove groups which are being disposed of,
   * events do not need fired in this case
   */
  filterFromSelection(e) {
    const t = /* @__PURE__ */ new Map();
    this.selectedNodes.forEach((r, n) => {
      r && e(r) && t.set(n, r);
    }), this.selectedNodes = t;
  }
  // should only be called if groupSelectsChildren=true
  updateGroupsFromChildrenSelections(e, t) {
    if (!this.groupSelectsChildren || this.rowModel.getType() !== "clientSide")
      return !1;
    const n = this.rowModel.getRootNode();
    t || (t = new Cw(!0, n), t.setInactive());
    let i = !1;
    return t.forEachChangedNodeDepthFirst((o) => {
      if (o !== n) {
        const a = o.calculateSelectedFromChildren();
        i = o.selectThisNode(a === null ? !1 : a, void 0, e) || i;
      }
    }), i;
  }
  clearOtherNodes(e, t) {
    const r = /* @__PURE__ */ new Map();
    let n = 0;
    return this.selectedNodes.forEach((i) => {
      if (i && i.id !== e.id) {
        const o = this.selectedNodes.get(i.id);
        n += o.setSelectedParams({
          newValue: !1,
          clearSelection: !1,
          suppressFinishActions: !0,
          source: t
        }), this.groupSelectsChildren && i.parent && r.set(i.parent.id, i.parent);
      }
    }), r.forEach((i) => {
      const o = i.calculateSelectedFromChildren();
      i.selectThisNode(o === null ? !1 : o, void 0, t);
    }), n;
  }
  onRowSelected(e) {
    const t = e.node;
    this.groupSelectsChildren && t.group || (t.isSelected() ? this.selectedNodes.set(t.id, t) : this.selectedNodes.delete(t.id));
  }
  syncInRowNode(e, t) {
    this.syncInOldRowNode(e, t), this.syncInNewRowNode(e);
  }
  // if the id has changed for the node, then this means the rowNode
  // is getting used for a different data item, which breaks
  // our selectedNodes, as the node now is mapped by the old id
  // which is inconsistent. so to keep the old node as selected,
  // we swap in the clone (with the old id and old data). this means
  // the oldNode is effectively a daemon we keep a reference to,
  // so if client calls api.getSelectedNodes(), it gets the daemon
  // in the result. when the client un-selects, the reference to the
  // daemon is removed. the daemon, because it's an oldNode, is not
  // used by the grid for rendering, it's a copy of what the node used
  // to be like before the id was changed.
  syncInOldRowNode(e, t) {
    if (Me(t) && e.id !== t.id && t) {
      const n = t.id;
      this.selectedNodes.get(n) == e && this.selectedNodes.set(t.id, t);
    }
  }
  syncInNewRowNode(e) {
    this.selectedNodes.has(e.id) ? (e.setSelectedInitialValue(!0), this.selectedNodes.set(e.id, e)) : e.setSelectedInitialValue(!1);
  }
  reset(e) {
    const t = this.getSelectionCount();
    this.resetNodes(), t && this.dispatchSelectionChanged(e);
  }
  resetNodes() {
    var e;
    (e = this.selectedNodes) == null || e.clear();
  }
  // returns a list of all nodes at 'best cost' - a feature to be used
  // with groups / trees. if a group has all it's children selected,
  // then the group appears in the result, but not the children.
  // Designed for use with 'children' as the group selection type,
  // where groups don't actually appear in the selection normally.
  getBestCostNodeSelection() {
    if (this.rowModel.getType() !== "clientSide")
      return;
    const t = this.rowModel.getTopLevelNodes();
    if (t === null)
      return;
    const r = [];
    function n(i) {
      for (let o = 0, a = i.length; o < a; o++) {
        const s = i[o];
        if (s.isSelected())
          r.push(s);
        else {
          const l = s;
          l.group && l.children && n(l.children);
        }
      }
    }
    return n(t), r;
  }
  isEmpty() {
    let e = 0;
    return this.selectedNodes.forEach((t) => {
      t && e++;
    }), e === 0;
  }
  deselectAllRowNodes(e) {
    const t = (a) => a.selectThisNode(!1, void 0, n), r = this.rowModel.getType() === "clientSide", { source: n, justFiltered: i, justCurrentPage: o } = e;
    if (o || i) {
      if (!r) {
        sr("selecting just filtered only works when gridOptions.rowModelType='clientSide'");
        return;
      }
      this.getNodesToSelect(i, o).forEach(t);
    } else
      this.selectedNodes.forEach((a) => {
        a && t(a);
      }), this.reset(n);
    this.selectionCtx.reset(), r && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(n), this.dispatchSelectionChanged(n);
  }
  getSelectedCounts(e, t) {
    let r = 0, n = 0;
    const i = (o) => {
      this.groupSelectsChildren && o.group || (o.isSelected() ? r++ : o.selectable && n++);
    };
    return this.getNodesToSelect(e, t).forEach(i), { selectedCount: r, notSelectedCount: n };
  }
  getSelectAllState(e, t) {
    const { selectedCount: r, notSelectedCount: n } = this.getSelectedCounts(e, t);
    return r === 0 && n === 0 ? !1 : r > 0 && n > 0 ? null : r > 0;
  }
  hasNodesToSelect(e = !1, t = !1) {
    return this.getNodesToSelect(e, t).filter((r) => r.selectable).length > 0;
  }
  /**
   * @param justFiltered whether to just include nodes which have passed the filter
   * @param justCurrentPage whether to just include nodes on the current page
   * @returns all nodes including unselectable nodes which are the target of this selection attempt
   */
  getNodesToSelect(e = !1, t = !1) {
    if (this.rowModel.getType() !== "clientSide")
      throw new Error(
        `selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`
      );
    const r = [];
    if (t)
      return this.forEachNodeOnPage((i) => {
        if (!i.group) {
          r.push(i);
          return;
        }
        if (!i.expanded) {
          const o = (a) => {
            var s;
            r.push(a), (s = a.childrenAfterFilter) != null && s.length && a.childrenAfterFilter.forEach(o);
          };
          o(i);
          return;
        }
        this.groupSelectsChildren || r.push(i);
      }), r;
    const n = this.rowModel;
    return e ? (n.forEachNodeAfterFilter((i) => {
      r.push(i);
    }), r) : (n.forEachNode((i) => {
      r.push(i);
    }), r);
  }
  forEachNodeOnPage(e) {
    const t = this.pageBoundsService.getFirstRow(), r = this.pageBoundsService.getLastRow();
    for (let n = t; n <= r; n++) {
      const i = this.rowModel.getRow(n);
      i && e(i);
    }
  }
  selectAllRowNodes(e) {
    if (this.rowModel.getType() !== "clientSide")
      throw new Error(
        `selectAll only available when rowModelType='clientSide', ie not ${this.rowModel.getType()}`
      );
    const { source: t, justFiltered: r, justCurrentPage: n } = e, i = this.getNodesToSelect(r, n);
    i.forEach((o) => o.selectThisNode(!0, void 0, t)), this.selectionCtx.setRoot(i[0] ?? null), this.selectionCtx.setEndRange(Jt(i) ?? null), this.rowModel.getType() === "clientSide" && this.groupSelectsChildren && this.updateGroupsFromChildrenSelections(t), this.dispatchSelectionChanged(t);
  }
  getSelectionState() {
    const e = [];
    return this.selectedNodes.forEach((t) => {
      t != null && t.id && e.push(t.id);
    }), e.length ? e : null;
  }
  setSelectionState(e, t) {
    if (!Array.isArray(e))
      return;
    const r = new Set(e), n = [];
    this.rowModel.forEachNode((i) => {
      r.has(i.id) && n.push(i);
    }), this.setNodesSelected({
      newValue: !0,
      nodes: n,
      source: t
    });
  }
  dispatchSelectionChanged(e) {
    const t = {
      type: "selectionChanged",
      source: e
    };
    this.eventService.dispatchEvent(t);
  }
}, jze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "selectableService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  postConstruct() {
    this.addManagedPropertyListener("isRowSelectable", () => this.updateSelectable());
  }
  /**
   * Used by CSRM only, to update selectable state after group state changes.
   */
  updateSelectableAfterGrouping() {
    this.updateSelectable(!0);
  }
  updateSelectable(e = !1) {
    const t = !!this.gos.get("rowSelection"), r = this.gos.get("isRowSelectable");
    if (!t || !r)
      return;
    const n = this.gos.get("groupSelectsChildren"), i = this.rowModel.getType() === "clientSide" && n, o = [], a = (s) => {
      if (e && !s.group)
        return;
      if (i && s.group) {
        const u = s.childrenAfterGroup.some((c) => c.selectable === !0);
        s.setRowSelectable(u, !0);
        return;
      }
      const l = r ? r(s) : !0;
      s.setRowSelectable(l, !0), !l && s.isSelected() && o.push(s);
    };
    if (i) {
      const s = this.rowModel;
      new Cw(!1, s.getRootNode()).forEachChangedNodeDepthFirst(a, !0, !0);
    } else
      this.rowModel.forEachNode(a);
    o.length && this.selectionService.setNodesSelected({
      nodes: o,
      newValue: !1,
      source: "selectableChanged"
    }), i && this.selectionService instanceof PY && this.selectionService.updateGroupsFromChildrenSelections("selectableChanged");
  }
}, UG = ["asc", "desc", null], Uze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "sortController";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  progressSort(e, t, r) {
    const n = this.getNextSortDirection(e);
    this.setSortForColumn(e, n, t, r);
  }
  setSortForColumn(e, t, r, n) {
    t !== "asc" && t !== "desc" && (t = null);
    const i = this.gos.isColumnsSortingCoupledToGroup();
    let o = [e];
    if (i && e.getColDef().showRowGroup) {
      const l = this.funcColsService.getSourceColumnsForGroupColumn(e), u = l == null ? void 0 : l.filter((c) => c.isSortable());
      u && (o = [e, ...u]);
    }
    o.forEach((l) => l.setSort(t, n));
    const a = (r || this.gos.get("alwaysMultiSort")) && !this.gos.get("suppressMultiSort"), s = [];
    if (!a) {
      const l = this.clearSortBarTheseColumns(o, n);
      s.push(...l);
    }
    this.updateSortIndex(e), s.push(...o), this.dispatchSortChangedEvents(n, s);
  }
  updateSortIndex(e) {
    var s;
    const t = this.gos.isColumnsSortingCoupledToGroup(), r = (s = this.showRowGroupColsService) == null ? void 0 : s.getShowRowGroupCol(e.getId()), n = t && r || e, i = this.getColumnsWithSortingOrdered();
    this.columnModel.getAllCols().forEach((l) => l.setSortIndex(null));
    const o = i.filter((l) => t && l.getColDef().showRowGroup ? !1 : l !== n);
    (n.getSort() ? [...o, n] : o).forEach((l, u) => {
      l.setSortIndex(u);
    });
  }
  // gets called by API, so if data changes, use can call this, which will end up
  // working out the sort order again of the rows.
  onSortChanged(e, t) {
    this.dispatchSortChangedEvents(e, t);
  }
  isSortActive() {
    const t = this.columnModel.getAllCols().filter((r) => !!r.getSort());
    return t && t.length > 0;
  }
  dispatchSortChangedEvents(e, t) {
    const r = {
      type: "sortChanged",
      source: e
    };
    t && (r.columns = t), this.eventService.dispatchEvent(r);
  }
  clearSortBarTheseColumns(e, t) {
    const r = [];
    return this.columnModel.getAllCols().forEach((n) => {
      e.includes(n) || (n.getSort() && r.push(n), n.setSort(void 0, t));
    }), r;
  }
  getNextSortDirection(e) {
    let t;
    if (e.getColDef().sortingOrder ? t = e.getColDef().sortingOrder : this.gos.get("sortingOrder") ? t = this.gos.get("sortingOrder") : t = UG, !Array.isArray(t) || t.length <= 0)
      return Se(`sortingOrder must be an array with at least one element, currently it's ${t}`), null;
    const r = t.indexOf(e.getSort()), n = r < 0, i = r == t.length - 1;
    let o;
    return n || i ? o = t[0] : o = t[r + 1], UG.indexOf(o) < 0 ? (Se("invalid sort type ", o), null) : o;
  }
  /**
   * @returns a map of sort indexes for every sorted column, if groups sort primaries then they will have equivalent indices
   */
  getIndexedSortMap() {
    let e = this.columnModel.getAllCols().filter((o) => !!o.getSort());
    if (this.columnModel.isPivotMode()) {
      const o = this.gos.isColumnsSortingCoupledToGroup();
      e = e.filter((a) => {
        var c;
        const s = !!a.getAggFunc(), l = !a.isPrimary(), u = o ? (c = this.showRowGroupColsService) == null ? void 0 : c.getShowRowGroupCol(a.getId()) : a.getColDef().showRowGroup;
        return s || l || u;
      });
    }
    const t = this.funcColsService.getRowGroupColumns().filter((o) => !!o.getSort()), r = {};
    e.forEach((o, a) => r[o.getId()] = a), e.sort((o, a) => {
      const s = o.getSortIndex(), l = a.getSortIndex();
      if (s != null && l != null)
        return s - l;
      if (s == null && l == null) {
        const u = r[o.getId()], c = r[a.getId()];
        return u > c ? 1 : -1;
      } else return l == null ? -1 : 1;
    });
    const n = this.gos.isColumnsSortingCoupledToGroup() && !!t.length;
    n && (e = [
      ...new Set(
        // if linked sorting, replace all columns with the display group column for index purposes, and ensure uniqueness
        e.map((o) => {
          var a;
          return ((a = this.showRowGroupColsService) == null ? void 0 : a.getShowRowGroupCol(o.getId())) ?? o;
        })
      )
    ]);
    const i = /* @__PURE__ */ new Map();
    return e.forEach((o, a) => i.set(o, a)), n && t.forEach((o) => {
      const a = this.showRowGroupColsService.getShowRowGroupCol(o.getId());
      i.set(o, i.get(a));
    }), i;
  }
  getColumnsWithSortingOrdered() {
    return [...this.getIndexedSortMap().entries()].sort(([e, t], [r, n]) => t - n).map(([e]) => e);
  }
  // used by server side row models, to sent sort to server
  getSortModel() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      colId: e.getId()
    }));
  }
  getSortOptions() {
    return this.getColumnsWithSortingOrdered().filter((e) => e.getSort()).map((e) => ({
      sort: e.getSort(),
      column: e
    }));
  }
  canColumnDisplayMixedSort(e) {
    const t = this.gos.isColumnsSortingCoupledToGroup(), r = !!e.getColDef().showRowGroup;
    return t && r;
  }
  getDisplaySortForColumn(e) {
    const t = this.funcColsService.getSourceColumnsForGroupColumn(e);
    if (!this.canColumnDisplayMixedSort(e) || !(t != null && t.length))
      return e.getSort();
    const n = e.getColDef().field != null || !!e.getColDef().valueGetter ? [e, ...t] : t, i = n[0].getSort();
    return n.every((a) => a.getSort() == i) ? i : "mixed";
  }
  getDisplaySortIndexForColumn(e) {
    return this.getIndexedSortMap().get(e);
  }
}, Kze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "syncService", this.waitingForColumns = !1;
  }
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService, this.columnModel = e.columnModel, this.rowModel = e.rowModel;
  }
  postConstruct() {
    this.addManagedPropertyListener("columnDefs", (e) => this.setColumnDefs(e));
  }
  start() {
    this.ctrlsService.whenReady(() => {
      const e = this.gos.get("columnDefs");
      e ? this.setColumnsAndData(e) : this.waitingForColumns = !0, this.gridReady();
    });
  }
  setColumnsAndData(e) {
    this.columnModel.setColumnDefs(e ?? [], "gridInitializing"), this.rowModel.start();
  }
  gridReady() {
    this.dispatchGridReadyEvent();
    const e = Xn.__isRegistered("@ag-grid-enterprise/core", this.gridId);
    this.gos.get("debug") && sa(`initialised successfully, enterprise = ${e}`);
  }
  dispatchGridReadyEvent() {
    const e = {
      type: "gridReady"
    };
    this.eventService.dispatchEvent(e);
  }
  setColumnDefs(e) {
    const t = this.gos.get("columnDefs");
    if (t) {
      if (this.waitingForColumns) {
        this.waitingForColumns = !1, this.setColumnsAndData(t);
        return;
      }
      this.columnModel.setColumnDefs(t, ah(e.source));
    }
  }
}, Yze = "paste", qze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "changeDetectionService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.rowRenderer = e.rowRenderer;
  }
  postConstruct() {
    this.rowModel.getType() === "clientSide" && (this.clientSideRowModel = this.rowModel), this.addManagedEventListeners({ cellValueChanged: this.onCellValueChanged.bind(this) });
  }
  onCellValueChanged(e) {
    e.source !== Yze && this.doChangeDetection(e.node, e.column);
  }
  doChangeDetection(e, t) {
    if (this.gos.get("suppressChangeDetection"))
      return;
    const r = [e];
    if (this.clientSideRowModel && !e.isRowPinned()) {
      const n = this.gos.get("aggregateOnlyChangedColumns"), i = new Cw(n, this.clientSideRowModel.getRootNode());
      i.addParentNode(e.parent, [t]), this.clientSideRowModel.doAggregate(i), i.forEachChangedNodeDepthFirst((o) => {
        r.push(o);
      });
    }
    this.rowRenderer.refreshCells({ rowNodes: r });
  }
}, Zze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "expressionService", this.expressionToFunctionCache = {};
  }
  evaluate(e, t) {
    if (typeof e == "string")
      return this.evaluateExpression(e, t);
    sr("value should be either a string or a function", e);
  }
  evaluateExpression(e, t) {
    try {
      return this.createExpressionFunction(e)(
        t.value,
        t.context,
        t.oldValue,
        t.newValue,
        t.value,
        t.node,
        t.data,
        t.colDef,
        t.rowIndex,
        t.api,
        t.getValue,
        t.column,
        t.columnGroup
      );
    } catch (r) {
      return sa("Processing of the expression failed"), sa("Expression = ", e), sa("Params = ", t), sa("Exception = ", r), null;
    }
  }
  createExpressionFunction(e) {
    if (this.expressionToFunctionCache[e])
      return this.expressionToFunctionCache[e];
    const t = this.createFunctionBody(e), r = new Function(
      "x, ctx, oldValue, newValue, value, node, data, colDef, rowIndex, api, getValue, column, columnGroup",
      t
    );
    return this.expressionToFunctionCache[e] = r, r;
  }
  createFunctionBody(e) {
    return e.indexOf("return") >= 0 ? e : "return " + e + ";";
  }
}, Xze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "valueCache", this.cacheVersion = 0;
  }
  postConstruct() {
    this.active = this.gos.get("valueCache"), this.neverExpires = this.gos.get("valueCacheNeverExpires");
  }
  onDataChanged() {
    this.neverExpires || this.expire();
  }
  expire() {
    this.cacheVersion++;
  }
  setValue(e, t, r) {
    this.active && (e.__cacheVersion !== this.cacheVersion && (e.__cacheVersion = this.cacheVersion, e.__cacheData = {}), e.__cacheData[t] = r);
  }
  getValue(e, t) {
    if (!(!this.active || e.__cacheVersion !== this.cacheVersion))
      return e.__cacheData[t];
  }
}, Qze = class extends he {
  constructor() {
    super(...arguments), this.beanName = "valueService", this.initialised = !1, this.isSsrm = !1;
  }
  wireBeans(e) {
    this.expressionService = e.expressionService, this.columnModel = e.columnModel, this.valueCache = e.valueCache, this.dataTypeService = e.dataTypeService;
  }
  postConstruct() {
    this.initialised || this.init();
  }
  init() {
    this.isSsrm = this.gos.isRowModelType("serverSide"), this.cellExpressions = this.gos.get("enableCellExpressions"), this.isTreeData = this.gos.get("treeData"), this.initialised = !0;
    const e = (r) => this.callColumnCellValueChangedHandler(r), t = this.gos.useAsyncEvents();
    this.eventService.addEventListener("cellValueChanged", e, t), this.addDestroyFunc(() => this.eventService.removeEventListener("cellValueChanged", e, t)), this.addManagedPropertyListener("treeData", (r) => this.isTreeData = r.currentValue);
  }
  getValue(e, t, r = !1, n = !1) {
    if (this.initialised || this.init(), !t)
      return;
    const i = e.getColDef(), o = i.field, a = e.getColId(), s = t.data;
    let l;
    const u = t.groupData && t.groupData[a] !== void 0, c = !n && t.aggData && t.aggData[a] !== void 0, d = this.isSsrm && n && !!e.getColDef().aggFunc, h = this.isSsrm && t.footer && t.field && (e.getColDef().showRowGroup === !0 || e.getColDef().showRowGroup === t.field);
    if (r && i.filterValueGetter ? l = this.executeFilterValueGetter(i.filterValueGetter, s, e, t) : this.isTreeData && c ? l = t.aggData[a] : this.isTreeData && i.valueGetter ? l = this.executeValueGetter(i.valueGetter, s, e, t) : this.isTreeData && o && s ? l = ug(s, o, e.isFieldContainsDots()) : u ? l = t.groupData[a] : c ? l = t.aggData[a] : i.valueGetter ? l = this.executeValueGetter(i.valueGetter, s, e, t) : h ? l = ug(s, t.field, e.isFieldContainsDots()) : o && s && !d && (l = ug(s, o, e.isFieldContainsDots())), this.cellExpressions && typeof l == "string" && l.indexOf("=") === 0) {
      const f = l.substring(1);
      l = this.executeValueGetter(f, s, e, t);
    }
    if (l == null) {
      const f = this.getOpenedGroup(t, e);
      if (f != null)
        return f;
    }
    return l;
  }
  parseValue(e, t, r, n) {
    const i = e.getColDef(), o = this.gos.addGridCommonParams({
      node: t,
      data: t == null ? void 0 : t.data,
      oldValue: n,
      newValue: r,
      colDef: i,
      column: e
    }), a = i.valueParser;
    return Me(a) ? typeof a == "function" ? a(o) : this.expressionService.evaluate(a, o) : r;
  }
  formatValue(e, t, r, n, i = !0) {
    let o = null, a;
    const s = e.getColDef();
    if (n ? a = n : i && (a = s.valueFormatter), a) {
      const l = this.gos.addGridCommonParams({
        value: r,
        node: t,
        data: t ? t.data : null,
        colDef: s,
        column: e
      });
      typeof a == "function" ? o = a(l) : o = this.expressionService.evaluate(a, l);
    } else if (s.refData)
      return s.refData[r] || "";
    return o == null && Array.isArray(r) && (o = r.join(", ")), o;
  }
  getOpenedGroup(e, t) {
    if (!this.gos.get("showOpenedGroup") || !t.getColDef().showRowGroup)
      return;
    const n = t.getColDef().showRowGroup;
    let i = e.parent;
    for (; i != null; ) {
      if (i.rowGroupColumn && (n === !0 || n === i.rowGroupColumn.getColId()))
        return i.key;
      i = i.parent;
    }
  }
  /**
   * Sets the value of a GridCell
   * @param rowNode The `RowNode` to be updated
   * @param colKey The `Column` to be updated
   * @param newValue The new value to be set
   * @param eventSource The event source
   * @returns `True` if the value has been updated, otherwise`False`.
   */
  setValue(e, t, r, n) {
    const i = this.columnModel.getColDefCol(t);
    if (!e || !i)
      return !1;
    Zt(e.data) && (e.data = {});
    const { field: o, valueSetter: a } = i.getColDef();
    if (Zt(o) && Zt(a))
      return Se("you need either field or valueSetter set on colDef for editing to work"), !1;
    if (this.dataTypeService && !this.dataTypeService.checkType(i, r))
      return Se("Data type of the new value does not match the cell data type of the column"), !1;
    const s = this.gos.addGridCommonParams({
      node: e,
      data: e.data,
      oldValue: this.getValue(i, e),
      newValue: r,
      colDef: i.getColDef(),
      column: i
    });
    s.newValue = r;
    let l;
    if (Me(a) ? typeof a == "function" ? l = a(s) : l = this.expressionService.evaluate(a, s) : l = this.setValueUsingField(e.data, o, r, i.isFieldContainsDots()), l === void 0 && (l = !0), !l)
      return !1;
    e.resetQuickFilterAggregateText(), this.valueCache.onDataChanged(), s.newValue = this.getValue(i, e);
    const u = {
      type: "cellValueChanged",
      event: null,
      rowIndex: e.rowIndex,
      rowPinned: e.rowPinned,
      column: s.column,
      api: s.api,
      colDef: s.colDef,
      context: s.context,
      data: e.data,
      node: e,
      oldValue: s.oldValue,
      newValue: s.newValue,
      value: s.newValue,
      source: n
    };
    return this.eventService.dispatchEvent(u), !0;
  }
  callColumnCellValueChangedHandler(e) {
    const t = e.colDef.onCellValueChanged;
    typeof t == "function" && this.getFrameworkOverrides().wrapOutgoing(() => {
      t({
        node: e.node,
        data: e.data,
        oldValue: e.oldValue,
        newValue: e.newValue,
        colDef: e.colDef,
        column: e.column,
        api: e.api,
        context: e.context
      });
    });
  }
  setValueUsingField(e, t, r, n) {
    if (!t)
      return !1;
    let i = !1;
    if (!n)
      i = e[t] === r, i || (e[t] = r);
    else {
      const o = t.split(".");
      let a = e;
      for (; o.length > 0 && a; ) {
        const s = o.shift();
        o.length === 0 ? (i = a[s] === r, i || (a[s] = r)) : a = a[s];
      }
    }
    return !i;
  }
  executeFilterValueGetter(e, t, r, n) {
    const i = this.gos.addGridCommonParams({
      data: t,
      node: n,
      column: r,
      colDef: r.getColDef(),
      getValue: this.getValueCallback.bind(this, n)
    });
    return typeof e == "function" ? e(i) : this.expressionService.evaluate(e, i);
  }
  executeValueGetter(e, t, r, n) {
    const i = r.getColId(), o = this.valueCache.getValue(n, i);
    if (o !== void 0)
      return o;
    const a = this.gos.addGridCommonParams({
      data: t,
      node: n,
      column: r,
      colDef: r.getColDef(),
      getValue: this.getValueCallback.bind(this, n)
    });
    let s;
    return typeof e == "function" ? s = e(a) : s = this.expressionService.evaluate(e, a), this.valueCache.setValue(n, i, s), s;
  }
  getValueCallback(e, t) {
    const r = this.columnModel.getColDefCol(t);
    return r ? this.getValue(r, e) : null;
  }
  // used by row grouping and pivot, to get key for a row. col can be a pivot col or a row grouping col
  getKeyForNode(e, t) {
    const r = this.getValue(e, t), n = e.getColDef().keyCreator;
    let i = r;
    if (n) {
      const o = this.gos.addGridCommonParams({
        value: r,
        colDef: e.getColDef(),
        column: e,
        node: t,
        data: t.data
      });
      i = n(o);
    }
    return typeof i == "string" || i == null || (i = String(i), i === "[object Object]" && Se(
      "a column you are grouping or pivoting by has objects as values. If you want to group by complex objects then either a) use a colDef.keyCreator (se AG Grid docs) or b) to toString() on the object to return a key"
    )), i;
  }
}, OT = class {
};
OT.gridOptions = void 0;
var Jze = 1, e5e = class {
  create(e, t, r, n, i) {
    let o = {};
    OT.gridOptions ? (To(o, OT.gridOptions, !0, !0), o = { ...o, ...t }) : o = t;
    const a = Aze(o), s = a.gridId ?? String(Jze++), l = this.getRegisteredModules(i, s), u = this.createBeansList(a.rowModelType, l, s), c = this.createProvidedBeans(e, a, i);
    if (!u) {
      sr("Failed to create grid.");
      return;
    }
    const d = {
      providedBeanInstances: c,
      beanClasses: u,
      gridId: s,
      beanInitComparator: g4e,
      beanDestroyComparator: v4e,
      derivedBeans: [a4e]
    }, h = new CNe(d);
    return this.registerModuleUserComponents(h, l), this.registerControllers(h, l), this.registerModuleApiFunctions(h, l), r(h), h.getBean("syncService").start(), n && n(h), h.getBean("gridApi");
  }
  registerControllers(e, t) {
    const r = e.getBean("ctrlsFactory");
    t.forEach((n) => {
      n.controllers && n.controllers.forEach((i) => r.register(i));
    });
  }
  getRegisteredModules(e, t) {
    const r = e ? e.modules : null, n = Xn.__getRegisteredModules(t), i = [], o = {}, a = (s, l, u) => {
      ((d) => {
        o[d.moduleName] || (o[d.moduleName] = !0, i.push(d), Xn.__register(d, s, u));
      })(l), l.dependantModules && l.dependantModules.forEach((d) => a(s, d, u));
    };
    return a(
      !!(r != null && r.length) || !Xn.__isPackageBased(),
      EY,
      void 0
    ), r && r.forEach((s) => a(!0, s, t)), n && n.forEach((s) => a(!Xn.__isPackageBased(), s, void 0)), i;
  }
  registerModuleUserComponents(e, t) {
    const r = this.extractModuleEntity(
      t,
      (i) => i.userComponents ? i.userComponents : []
    ), n = e.getBean("userComponentRegistry");
    r.forEach((i) => {
      n.registerDefaultComponent(i.name, i.classImp);
    });
  }
  registerModuleApiFunctions(e, t) {
    const r = e.getBean("apiFunctionService");
    t.forEach((n) => {
      const i = n.apiFunctions ?? {};
      Object.keys(i).forEach((a) => {
        r == null || r.addFunction(a, i[a]);
      });
    });
  }
  createProvidedBeans(e, t, r) {
    let n = r ? r.frameworkOverrides : null;
    Zt(n) && (n = new mY());
    const i = {
      gridOptions: t,
      eGridDiv: e,
      globalEventListener: r ? r.globalEventListener : null,
      globalSyncEventListener: r ? r.globalSyncEventListener : null,
      frameworkOverrides: n
    };
    return r && r.providedBeanInstances && Object.assign(i, r.providedBeanInstances), i;
  }
  createBeansList(e = "clientSide", t, r) {
    const n = t.filter(
      (l) => !l.rowModel || l.rowModel === e
    ), i = {
      clientSide: "@ag-grid-community/client-side-row-model",
      infinite: "@ag-grid-community/infinite-row-model",
      serverSide: "@ag-grid-enterprise/server-side-row-model",
      viewport: "@ag-grid-enterprise/viewport-row-model"
      /* ViewportRowModelModule */
    };
    if (!i[e]) {
      sr("Could not find row model for rowModelType = ", e);
      return;
    }
    if (!Xn.__assertRegistered(
      i[e],
      `rowModelType = '${e}'`,
      r
    ))
      return;
    const o = [
      w4e,
      C4e,
      Fze,
      Pze,
      i4e,
      eNe,
      h4e,
      f4e,
      JVe,
      RK,
      $ze,
      ZVe,
      Lze,
      WBe,
      ENe,
      rOe,
      E4e,
      Ize,
      e4e,
      PY,
      $Le,
      Lke,
      kze,
      Nze,
      zBe,
      Zze,
      zLe,
      qVe,
      Xze,
      Qze,
      GBe,
      XVe,
      wNe,
      R4e,
      YVe,
      b4e,
      r4e,
      qBe,
      KVe,
      Uze,
      Gze,
      Bze,
      jze,
      qze,
      eBe,
      s4e,
      zze,
      Wze,
      y4e,
      _4e,
      S4e,
      m4e,
      Kze,
      Hze,
      tBe,
      Oze,
      Vze,
      rBe,
      YLe,
      l4e,
      qLe,
      ULe,
      u4e,
      c4e,
      tOe,
      KLe,
      JLe,
      d4e,
      eOe
    ], a = this.extractModuleEntity(n, (l) => l.beans ? l.beans : []);
    o.push(...a);
    const s = [];
    return o.forEach((l) => {
      s.indexOf(l) < 0 && s.push(l);
    }), s;
  }
  extractModuleEntity(e, t) {
    return [].concat(...e.map(t));
  }
}, MY = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowModelHelperService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel;
  }
  postConstruct() {
    const e = this.rowModel;
    switch (e.getType()) {
      case "clientSide":
        this.clientSideRowModel = e;
        break;
      case "infinite":
        this.infiniteRowModel = e;
        break;
      case "serverSide":
        this.serverSideRowModel = e;
        break;
    }
  }
  getClientSideRowModel() {
    return this.clientSideRowModel;
  }
  getInfiniteRowModel() {
    return this.infiniteRowModel;
  }
  getServerSideRowModel() {
    return this.serverSideRowModel;
  }
};
function t5e(e) {
  e.expansionService.expandAll(!0);
}
function r5e(e) {
  e.expansionService.expandAll(!1);
}
function n5e(e) {
  var n, i;
  const t = (n = e.rowModelHelperService) == null ? void 0 : n.getClientSideRowModel(), r = (i = e.rowModelHelperService) == null ? void 0 : i.getServerSideRowModel();
  t ? t.onRowHeightChanged() : r && r.onRowHeightChanged();
}
function i5e(e, t, r) {
  var o, a;
  const n = (o = e.rowModelHelperService) == null ? void 0 : o.getServerSideRowModel();
  if (n) {
    if (e.funcColsService.isRowGroupEmpty()) {
      n.setRowCount(t, r);
      return;
    }
    sr("setRowCount cannot be used while using row grouping.");
    return;
  }
  const i = (a = e.rowModelHelperService) == null ? void 0 : a.getInfiniteRowModel();
  if (i) {
    i.setRowCount(t, r);
    return;
  }
}
function o5e(e) {
  var t;
  return ((t = e.rowNodeBlockLoader) == null ? void 0 : t.getBlockState()) ?? {};
}
var a5e = {
  version: Et,
  moduleName: "@ag-grid-community/csrm-ssrm-shared-api",
  apiFunctions: {
    expandAll: t5e,
    collapseAll: r5e,
    onRowHeightChanged: n5e
  }
}, s5e = {
  version: Et,
  moduleName: "@ag-grid-community/ssrm-infinite-shared-api",
  apiFunctions: {
    setRowCount: i5e,
    getCacheBlockState: o5e
  }
}, l5e = class {
  wrap(e, t, r = [], n) {
    const i = this.createWrapper(e, n);
    return t.forEach((o) => {
      this.createMethod(i, o, !0);
    }), r.forEach((o) => {
      this.createMethod(i, o, !1);
    }), i;
  }
  unwrap(e) {
    return e;
  }
  createMethod(e, t, r) {
    e.addMethod(t, this.createMethodProxy(e, t, r));
  }
  createMethodProxy(e, t, r) {
    return function() {
      return e.hasMethod(t) ? e.callMethod(t, arguments) : (r && Se("Framework component is missing the method " + t + "()"), null);
    };
  }
};
function u5e(e, t) {
  if (!e)
    return !1;
  const r = (a, s) => {
    const l = t[a.id], u = t[s.id], c = l !== void 0, d = u !== void 0, h = c && d, f = !c && !d;
    return h ? l - u : f ? a.__objectId - s.__objectId : c ? 1 : -1;
  };
  let n, i, o = !1;
  for (let a = 0; a < e.length - 1; a++)
    if (n = e[a], i = e[a + 1], r(n, i) > 0) {
      o = !0;
      break;
    }
  return o ? (e.sort(r), !0) : !1;
}
var Ef = typeof global > "u" ? {} : global;
Ef.HTMLElement = typeof HTMLElement > "u" ? {} : HTMLElement;
Ef.HTMLButtonElement = typeof HTMLButtonElement > "u" ? {} : HTMLButtonElement;
Ef.HTMLSelectElement = typeof HTMLSelectElement > "u" ? {} : HTMLSelectElement;
Ef.HTMLInputElement = typeof HTMLInputElement > "u" ? {} : HTMLInputElement;
Ef.Node = typeof Node > "u" ? {} : Node;
Ef.MouseEvent = typeof MouseEvent > "u" ? {} : MouseEvent;
var c5e = "ROOT_NODE_ID", nE = 0, d5e = class {
  constructor(e, t, r, n, i, o) {
    this.nextId = 0, this.rowCountReady = !1, this.allNodesMap = {}, this.rootNode = e, this.gos = t, this.eventService = r, this.funcColsService = n, this.beans = o, this.selectionService = i, this.rootNode.group = !0, this.rootNode.level = -1, this.rootNode.id = c5e, this.rootNode.allLeafChildren = [], this.rootNode.childrenAfterGroup = [], this.rootNode.childrenAfterSort = [], this.rootNode.childrenAfterAggFilter = [], this.rootNode.childrenAfterFilter = [];
  }
  getCopyOfNodesMap() {
    return ZU(this.allNodesMap);
  }
  getRowNode(e) {
    return this.allNodesMap[e];
  }
  setRowData(e) {
    if (typeof e == "string") {
      Se("rowData must be an array.");
      return;
    }
    this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(e);
    const t = this.rootNode, r = this.rootNode.sibling;
    t.childrenAfterFilter = null, t.childrenAfterGroup = null, t.childrenAfterAggFilter = null, t.childrenAfterSort = null, t.childrenMapped = null, t.updateHasChildren(), this.nextId = 0, this.allNodesMap = {}, e ? t.allLeafChildren = e.map((n) => this.createNode(n, this.rootNode, nE)) : (t.allLeafChildren = [], t.childrenAfterGroup = []), r && (r.childrenAfterFilter = t.childrenAfterFilter, r.childrenAfterGroup = t.childrenAfterGroup, r.childrenAfterAggFilter = t.childrenAfterAggFilter, r.childrenAfterSort = t.childrenAfterSort, r.childrenMapped = t.childrenMapped, r.allLeafChildren = t.allLeafChildren);
  }
  updateRowData(e, t) {
    this.rowCountReady = !0, this.dispatchRowDataUpdateStartedEvent(e.add);
    const r = {
      remove: [],
      update: [],
      add: []
    }, n = [];
    return this.executeRemove(e, r, n), this.executeUpdate(e, r, n), this.executeAdd(e, r), this.updateSelection(n, "rowDataChanged"), t && u5e(this.rootNode.allLeafChildren, t), r;
  }
  isRowCountReady() {
    return this.rowCountReady;
  }
  dispatchRowDataUpdateStartedEvent(e) {
    const t = {
      type: "rowDataUpdateStarted",
      firstRowData: e != null && e.length ? e[0] : null
    };
    this.eventService.dispatchEvent(t);
  }
  updateSelection(e, t) {
    const r = e.length > 0;
    if (r && this.selectionService.setNodesSelected({
      newValue: !1,
      nodes: e,
      suppressFinishActions: !0,
      source: t
    }), this.selectionService.updateGroupsFromChildrenSelections(t), r) {
      const n = {
        type: "selectionChanged",
        source: t
      };
      this.eventService.dispatchEvent(n);
    }
  }
  executeAdd(e, t) {
    var a;
    const { add: r, addIndex: n } = e;
    if (Dn(r))
      return;
    const i = r.map((s) => this.createNode(s, this.rootNode, nE)), o = this.rootNode.allLeafChildren;
    if (typeof n == "number" && n >= 0) {
      const s = o.length;
      let l = n;
      if (this.gos.get("treeData") && n > 0 && s > 0) {
        for (let h = 0; h < s; h++)
          if (((a = o[h]) == null ? void 0 : a.rowIndex) == n - 1) {
            l = h + 1;
            break;
          }
      }
      const c = o.slice(0, l), d = o.slice(l, o.length);
      this.rootNode.allLeafChildren = [...c, ...i, ...d];
    } else
      this.rootNode.allLeafChildren = [...o, ...i];
    this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = o), t.add = i;
  }
  executeRemove(e, t, r) {
    var o;
    const { remove: n } = e;
    if (Dn(n))
      return;
    const i = {};
    n.forEach((a) => {
      const s = this.lookupRowNode(a);
      s && (s.isSelected() && r.push(s), s.clearRowTopAndRowIndex(), i[s.id] = !0, delete this.allNodesMap[s.id], t.remove.push(s));
    }), this.rootNode.allLeafChildren = ((o = this.rootNode.allLeafChildren) == null ? void 0 : o.filter((a) => !i[a.id])) ?? null, this.rootNode.sibling && (this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren);
  }
  executeUpdate(e, t, r) {
    const { update: n } = e;
    Dn(n) || n.forEach((i) => {
      const o = this.lookupRowNode(i);
      o && (o.updateData(i), !o.selectable && o.isSelected() && r.push(o), this.setMasterForRow(o, i, nE, !1), t.update.push(o));
    });
  }
  lookupRowNode(e) {
    var n;
    const t = this.gos.getRowIdCallback();
    let r;
    if (t) {
      const i = t({ data: e, level: 0 });
      if (r = this.allNodesMap[i], !r)
        return sr(`could not find row id=${i}, data item was not found for this id`), null;
    } else if (r = (n = this.rootNode.allLeafChildren) == null ? void 0 : n.find((i) => i.data === e), !r)
      return sr("could not find data item as object was not found", e), sr("Consider using getRowId to help the Grid find matching row data"), null;
    return r || null;
  }
  createNode(e, t, r) {
    const n = new Os(this.beans);
    return n.group = !1, this.setMasterForRow(n, e, r, !0), t && (n.parent = t), n.level = r, n.setDataAndId(e, this.nextId.toString()), this.allNodesMap[n.id] && Se(
      `duplicate node id '${n.id}' detected from getRowId callback, this could cause issues in your grid.`
    ), this.allNodesMap[n.id] = n, this.nextId++, n;
  }
  setMasterForRow(e, t, r, n) {
    if (this.gos.get("treeData"))
      e.setMaster(!1), n && (e.expanded = !1);
    else {
      if (this.gos.get("masterDetail")) {
        const a = this.gos.get("isRowMaster");
        a ? e.setMaster(a(t)) : e.setMaster(!0);
      } else
        e.setMaster(!1);
      if (n) {
        const a = this.funcColsService.getRowGroupColumns(), s = a ? a.length : 0, l = r + s;
        e.expanded = e.master ? this.isExpanded(l) : !1;
      }
    }
  }
  isExpanded(e) {
    const t = this.gos.get("groupDefaultExpanded");
    return t === -1 ? !0 : e < t;
  }
}, h5e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowModel", this.onRowHeightChanged_debounced = vi(this.onRowHeightChanged.bind(this), 100), this.rowsToDisplay = [], this.hasStarted = !1, this.shouldSkipSettingDataOnStart = !1, this.isRefreshingModel = !1, this.rowCountReady = !1;
  }
  wireBeans(e) {
    this.beans = e, this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.selectionService = e.selectionService, this.valueCache = e.valueCache, this.environment = e.environment, this.filterStage = e.filterStage, this.sortStage = e.sortStage, this.flattenStage = e.flattenStage, this.groupStage = e.groupStage, this.aggregationStage = e.aggregationStage, this.pivotStage = e.pivotStage, this.filterAggregatesStage = e.filterAggregatesStage;
  }
  postConstruct() {
    const e = this.refreshModel.bind(this, {
      step: "group"
      /* EVERYTHING */
    }), t = !this.gos.get("suppressAnimationFrame"), r = this.refreshModel.bind(this, {
      step: "group",
      // after cols change, row grouping (the first stage) could of changed
      afterColumnsChanged: !0,
      keepRenderedRows: !0,
      // we want animations cos sorting or filtering could be applied
      animate: t
    });
    this.addManagedEventListeners({
      newColumnsLoaded: r,
      columnRowGroupChanged: e,
      columnValueChanged: this.onValueChanged.bind(this),
      columnPivotChanged: this.refreshModel.bind(this, {
        step: "pivot"
        /* PIVOT */
      }),
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      columnPivotModeChanged: e,
      gridStylesChanged: this.onGridStylesChanges.bind(this),
      gridReady: this.onGridReady.bind(this)
    }), this.addPropertyListeners(), this.rootNode = new Os(this.beans), this.nodeManager = new d5e(
      this.rootNode,
      this.gos,
      this.eventService,
      this.funcColsService,
      this.selectionService,
      this.beans
    );
  }
  addPropertyListeners() {
    const e = /* @__PURE__ */ new Set(["treeData", "masterDetail"]), t = /* @__PURE__ */ new Set([
      "groupDefaultExpanded",
      "groupAllowUnbalanced",
      "initialGroupOrderComparator",
      "groupHideOpenParents",
      "groupDisplayType"
    ]), r = /* @__PURE__ */ new Set(["excludeChildrenWhenTreeDataFiltering"]), n = /* @__PURE__ */ new Set([
      "removePivotHeaderRowWhenSingleValueColumn",
      "pivotRowTotals",
      "pivotColumnGroupTotals",
      "suppressExpandablePivotGroups"
    ]), i = /* @__PURE__ */ new Set([
      "getGroupRowAgg",
      "alwaysAggregateAtRootLevel",
      "groupIncludeTotalFooter",
      "suppressAggFilteredOnly",
      "grandTotalRow"
    ]), o = /* @__PURE__ */ new Set([
      "postSortRows",
      "groupDisplayType",
      "accentedSort"
    ]), a = /* @__PURE__ */ new Set([]), s = /* @__PURE__ */ new Set([
      "groupRemoveSingleChildren",
      "groupRemoveLowestSingleChildren",
      "groupIncludeFooter",
      "groupTotalRow"
    ]), l = [
      ...e,
      ...t,
      ...r,
      ...n,
      ...n,
      ...i,
      ...o,
      ...a,
      ...s
    ];
    this.addManagedPropertyListeners(l, (u) => {
      var h;
      const c = (h = u.changeSet) == null ? void 0 : h.properties;
      if (!c)
        return;
      const d = (f) => c.some((p) => f.has(p));
      if (d(e)) {
        this.setRowData(this.rootNode.allLeafChildren.map((f) => f.data));
        return;
      }
      if (d(t)) {
        this.refreshModel({
          step: "group"
          /* EVERYTHING */
        });
        return;
      }
      if (d(r)) {
        this.refreshModel({
          step: "filter"
          /* FILTER */
        });
        return;
      }
      if (d(n)) {
        this.refreshModel({
          step: "pivot"
          /* PIVOT */
        });
        return;
      }
      if (d(i)) {
        this.refreshModel({
          step: "aggregate"
          /* AGGREGATE */
        });
        return;
      }
      if (d(o)) {
        this.refreshModel({
          step: "sort"
          /* SORT */
        });
        return;
      }
      if (d(a)) {
        this.refreshModel({
          step: "filter_aggregates"
          /* FILTER_AGGREGATES */
        });
        return;
      }
      d(s) && this.refreshModel({
        step: "map"
        /* MAP */
      });
    }), this.addManagedPropertyListener("rowHeight", () => this.resetRowHeights());
  }
  start() {
    this.hasStarted = !0, this.shouldSkipSettingDataOnStart ? this.dispatchUpdateEventsAndRefresh() : this.setInitialData();
  }
  setInitialData() {
    const e = this.gos.get("rowData");
    e && (this.shouldSkipSettingDataOnStart = !0, this.setRowData(e));
  }
  ensureRowHeightsValid(e, t, r, n) {
    let i, o = !1;
    do {
      i = !1;
      const a = this.getRowIndexAtPixel(e), s = this.getRowIndexAtPixel(t), l = Math.max(a, r), u = Math.min(s, n);
      for (let c = l; c <= u; c++) {
        const d = this.getRow(c);
        if (d.rowHeightEstimated) {
          const h = this.gos.getRowHeightForNode(d);
          d.setRowHeight(h.height), i = !0, o = !0;
        }
      }
      i && this.setRowTopAndRowIndex();
    } while (i);
    return o;
  }
  setRowTopAndRowIndex() {
    const e = this.environment.getDefaultRowHeight();
    let t = 0;
    const r = /* @__PURE__ */ new Set(), n = this.gos.isDomLayout("normal");
    for (let i = 0; i < this.rowsToDisplay.length; i++) {
      const o = this.rowsToDisplay[i];
      if (o.id != null && r.add(o.id), o.rowHeight == null) {
        const a = this.gos.getRowHeightForNode(o, n, e);
        o.setRowHeight(a.height, a.estimated);
      }
      o.setRowTop(t), o.setRowIndex(i), t += o.rowHeight;
    }
    return r;
  }
  clearRowTopAndRowIndex(e, t) {
    const r = e.isActive(), n = (o) => {
      o && o.id != null && !t.has(o.id) && o.clearRowTopAndRowIndex();
    }, i = (o) => {
      if (n(o), n(o.detailNode), n(o.sibling), o.hasChildren() && o.childrenAfterGroup) {
        const a = o.level == -1;
        r && !a && !o.expanded || o.childrenAfterGroup.forEach(i);
      }
    };
    i(this.rootNode);
  }
  // returns false if row was moved, otherwise true
  ensureRowsAtPixel(e, t, r = 0) {
    const n = this.getRowIndexAtPixel(t), i = this.getRow(n), o = !this.gos.get("suppressAnimationFrame");
    return i === e[0] ? !1 : (e.forEach((a) => {
      gi(this.rootNode.allLeafChildren, a);
    }), e.forEach((a, s) => {
      BC(this.rootNode.allLeafChildren, a, Math.max(n + r, 0) + s);
    }), this.refreshModel({
      step: "group",
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: o
    }), !0);
  }
  highlightRowAtPixel(e, t) {
    const r = t != null ? this.getRowIndexAtPixel(t) : null, n = r != null ? this.getRow(r) : null;
    if (!n || !e || n === e || t == null) {
      this.lastHighlightedRow && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null);
      return;
    }
    const i = this.getHighlightPosition(t, n);
    this.lastHighlightedRow && this.lastHighlightedRow !== n && (this.lastHighlightedRow.setHighlighted(null), this.lastHighlightedRow = null), n.setHighlighted(i), this.lastHighlightedRow = n;
  }
  getHighlightPosition(e, t) {
    if (!t) {
      const i = this.getRowIndexAtPixel(e);
      if (t = this.getRow(i || 0), !t)
        return 1;
    }
    const { rowTop: r, rowHeight: n } = t;
    return e - r < n / 2 ? 0 : 1;
  }
  getLastHighlightedRowNode() {
    return this.lastHighlightedRow;
  }
  isLastRowIndexKnown() {
    return !0;
  }
  getRowCount() {
    return this.rowsToDisplay ? this.rowsToDisplay.length : 0;
  }
  getTopLevelRowCount() {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return 1;
    const t = this.rootNode.sibling ? 1 : 0, r = this.rootNode.childrenAfterAggFilter;
    return (r ? r.length : 0) + t;
  }
  getTopLevelRowDisplayedIndex(e) {
    if (this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode)
      return e;
    let r = e;
    if (this.rowsToDisplay[0].footer) {
      if (e === 0)
        return 0;
      r -= 1;
    }
    let n = this.rootNode.childrenAfterSort[r];
    if (this.gos.get("groupHideOpenParents"))
      for (; n.expanded && n.childrenAfterSort && n.childrenAfterSort.length > 0; )
        n = n.childrenAfterSort[0];
    return n.rowIndex;
  }
  getRowBounds(e) {
    if (Zt(this.rowsToDisplay))
      return null;
    const t = this.rowsToDisplay[e];
    return t ? {
      rowTop: t.rowTop,
      rowHeight: t.rowHeight
    } : null;
  }
  onRowGroupOpened() {
    const e = this.gos.isAnimateRows();
    this.refreshModel({ step: "map", keepRenderedRows: !0, animate: e });
  }
  onFilterChanged(e) {
    if (e.afterDataChange)
      return;
    const t = this.gos.isAnimateRows(), n = e.columns.length === 0 || e.columns.some((i) => i.isPrimary()) ? "filter" : "filter_aggregates";
    this.refreshModel({ step: n, keepRenderedRows: !0, animate: t });
  }
  onSortChanged() {
    const e = this.gos.isAnimateRows();
    this.refreshModel({
      step: "sort",
      keepRenderedRows: !0,
      animate: e,
      keepEditingRows: !0
    });
  }
  getType() {
    return "clientSide";
  }
  onValueChanged() {
    this.columnModel.isPivotActive() ? this.refreshModel({
      step: "pivot"
      /* PIVOT */
    }) : this.refreshModel({
      step: "aggregate"
      /* AGGREGATE */
    });
  }
  createChangePath(e) {
    const t = Dn(e), r = new Cw(!1, this.rootNode);
    return (t || this.gos.get("treeData")) && r.setInactive(), r;
  }
  isSuppressModelUpdateAfterUpdateTransaction(e) {
    if (!this.gos.get("suppressModelUpdateAfterUpdateTransaction") || e.rowNodeTransactions == null)
      return !1;
    const t = e.rowNodeTransactions.filter(
      (n) => n.add != null && n.add.length > 0 || n.remove != null && n.remove.length > 0
    );
    return t == null || t.length == 0;
  }
  buildRefreshModelParams(e) {
    let t = "group";
    const r = {
      everything: "group",
      group: "group",
      filter: "filter",
      map: "map",
      aggregate: "aggregate",
      sort: "sort",
      pivot: "pivot"
      /* PIVOT */
    };
    if (Me(e) && (t = r[e]), Zt(t)) {
      sr(`invalid step ${e}, available steps are ${Object.keys(r).join(", ")}`);
      return;
    }
    const n = !this.gos.get("suppressAnimationFrame");
    return {
      step: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: n
    };
  }
  refreshModel(e) {
    if (!this.hasStarted || this.isRefreshingModel || this.columnModel.isChangeEventsDispatching())
      return;
    const t = typeof e == "object" && "step" in e ? e : this.buildRefreshModelParams(e);
    if (!t || this.isSuppressModelUpdateAfterUpdateTransaction(t))
      return;
    const r = this.createChangePath(t.rowNodeTransactions);
    switch (this.isRefreshingModel = !0, t.step) {
      case "group":
        this.doRowGrouping(
          t.rowNodeTransactions,
          t.rowNodeOrder,
          r,
          !!t.afterColumnsChanged
        );
      case "filter":
        this.doFilter(r);
      case "pivot":
        this.doPivot(r);
      case "aggregate":
        this.doAggregate(r);
      case "filter_aggregates":
        this.doFilterAggregates(r);
      case "sort":
        this.doSort(t.rowNodeTransactions, r);
      case "map":
        this.doRowsToDisplay();
    }
    const n = this.setRowTopAndRowIndex();
    this.clearRowTopAndRowIndex(r, n), this.isRefreshingModel = !1;
    const i = {
      type: "modelUpdated",
      animate: t.animate,
      keepRenderedRows: t.keepRenderedRows,
      newData: t.newData,
      newPage: !1,
      keepUndoRedoStack: t.keepUndoRedoStack
    };
    this.eventService.dispatchEvent(i);
  }
  isEmpty() {
    const e = Zt(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;
    return Zt(this.rootNode) || e || !this.columnModel.isReady();
  }
  isRowsToRender() {
    return Me(this.rowsToDisplay) && this.rowsToDisplay.length > 0;
  }
  getNodesInRangeForSelection(e, t) {
    let r = !1, n = !1;
    const i = [], o = this.gos.get("groupSelectsChildren");
    return this.forEachNodeAfterFilterAndSort((a) => {
      if (n)
        return;
      if (r && (a === t || a === e) && (n = !0, a.group && o)) {
        i.push(...a.allLeafChildren);
        return;
      }
      if (!r) {
        if (a !== t && a !== e)
          return;
        r = !0;
      }
      if (!a.group || !o) {
        i.push(a);
        return;
      }
    }), i;
  }
  // eslint-disable-next-line
  setDatasource(e) {
    sr("should never call setDatasource on clientSideRowController");
  }
  getTopLevelNodes() {
    return this.rootNode ? this.rootNode.childrenAfterGroup : null;
  }
  getRootNode() {
    return this.rootNode;
  }
  getRow(e) {
    return this.rowsToDisplay[e];
  }
  isRowPresent(e) {
    return this.rowsToDisplay.indexOf(e) >= 0;
  }
  getRowIndexAtPixel(e) {
    if (this.isEmpty() || this.rowsToDisplay.length === 0)
      return -1;
    let t = 0, r = this.rowsToDisplay.length - 1;
    if (e <= 0)
      return 0;
    if (Jt(this.rowsToDisplay).rowTop <= e)
      return this.rowsToDisplay.length - 1;
    let i = -1, o = -1;
    for (; ; ) {
      const a = Math.floor((t + r) / 2), s = this.rowsToDisplay[a];
      if (this.isRowInPixel(s, e) || (s.rowTop < e ? t = a + 1 : s.rowTop > e && (r = a - 1), i === t && o === r))
        return a;
      i = t, o = r;
    }
  }
  isRowInPixel(e, t) {
    const r = e.rowTop, n = e.rowTop + e.rowHeight;
    return r <= t && n > t;
  }
  forEachLeafNode(e) {
    this.rootNode.allLeafChildren && this.rootNode.allLeafChildren.forEach((t, r) => e(t, r));
  }
  forEachNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterGroup || []],
      callback: e,
      recursionType: 0,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilter(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterAggFilter || []],
      callback: e,
      recursionType: 1,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachNodeAfterFilterAndSort(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [...this.rootNode.childrenAfterSort || []],
      callback: e,
      recursionType: 2,
      index: 0,
      includeFooterNodes: t
    });
  }
  forEachPivotNode(e, t = !1) {
    this.recursivelyWalkNodesAndCallback({
      nodes: [this.rootNode],
      callback: e,
      recursionType: 3,
      index: 0,
      includeFooterNodes: t
    });
  }
  // iterates through each item in memory, and calls the callback function
  // nodes - the rowNodes to traverse
  // callback - the user provided callback
  // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc
  // index - works similar to the index in forEach in javascript's array function
  recursivelyWalkNodesAndCallback(e) {
    const { nodes: t, callback: r, recursionType: n, includeFooterNodes: i } = e;
    let { index: o } = e;
    const a = (s) => {
      var f;
      const l = (f = t[0]) == null ? void 0 : f.parent;
      if (!l)
        return;
      const u = i && this.gos.getGrandTotalRow(), c = this.gos.getGroupTotalRowCallback(), d = i && c({ node: l });
      if (l === this.rootNode) {
        u === s && (l.createFooter(), r(l.sibling, o++));
        return;
      }
      d === s && (l.createFooter(), r(l.sibling, o++));
    };
    a("top");
    for (let s = 0; s < t.length; s++) {
      const l = t[s];
      if (r(l, o++), l.hasChildren() && !l.footer) {
        let u = null;
        switch (n) {
          case 0:
            u = l.childrenAfterGroup;
            break;
          case 1:
            u = l.childrenAfterAggFilter;
            break;
          case 2:
            u = l.childrenAfterSort;
            break;
          case 3:
            u = l.leafGroup ? null : l.childrenAfterSort;
            break;
        }
        u && (o = this.recursivelyWalkNodesAndCallback({
          nodes: [...u],
          callback: r,
          recursionType: n,
          index: o,
          includeFooterNodes: i
        }));
      }
    }
    return a("bottom"), o;
  }
  // it's possible to recompute the aggregate without doing the other parts
  // + api.refreshClientSideRowModel('aggregate')
  doAggregate(e) {
    var t;
    (t = this.aggregationStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doFilterAggregates(e) {
    this.filterAggregatesStage ? this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath: e }) : this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;
  }
  // + gridApi.expandAll()
  // + gridApi.collapseAll()
  expandOrCollapseAll(e) {
    const t = this.gos.get("treeData"), r = this.columnModel.isPivotActive(), n = (a) => {
      a && a.forEach((s) => {
        const l = () => {
          s.expanded = e, n(s.childrenAfterGroup);
        };
        if (t) {
          Me(s.childrenAfterGroup) && l();
          return;
        }
        if (r) {
          !s.leafGroup && l();
          return;
        }
        s.group && l();
      });
    };
    this.rootNode && n(this.rootNode.childrenAfterGroup), this.refreshModel({
      step: "map"
      /* MAP */
    });
    const o = {
      type: "expandOrCollapseAll",
      source: e ? "expandAll" : "collapseAll"
    };
    this.eventService.dispatchEvent(o);
  }
  doSort(e, t) {
    this.sortStage.execute({
      rowNode: this.rootNode,
      rowNodeTransactions: e,
      changedPath: t
    });
  }
  doRowGrouping(e, t, r, n) {
    if (this.groupStage) {
      if (e ? this.groupStage.execute({
        rowNode: this.rootNode,
        rowNodeTransactions: e,
        rowNodeOrder: t,
        changedPath: r
      }) : this.groupStage.execute({
        rowNode: this.rootNode,
        changedPath: r,
        afterColumnsChanged: n
      }), this.gos.get("groupSelectsChildren") && this.selectionService.updateGroupsFromChildrenSelections(
        "rowGroupChanged",
        r
      )) {
        const o = {
          type: "selectionChanged",
          source: "rowGroupChanged"
        };
        this.eventService.dispatchEvent(o);
      }
    } else
      this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren, this.rootNode.sibling && (this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup), this.rootNode.updateHasChildren();
    this.nodeManager.isRowCountReady() && (this.rowCountReady = !0, this.eventService.dispatchEventOnce({
      type: "rowCountReady"
    }));
  }
  doFilter(e) {
    this.filterStage.execute({ rowNode: this.rootNode, changedPath: e });
  }
  doPivot(e) {
    var t;
    (t = this.pivotStage) == null || t.execute({ rowNode: this.rootNode, changedPath: e });
  }
  getCopyOfNodesMap() {
    return this.nodeManager.getCopyOfNodesMap();
  }
  getRowNode(e) {
    if (typeof e == "string" && e.indexOf(Os.ID_PREFIX_ROW_GROUP) == 0) {
      let r;
      return this.forEachNode((n) => {
        n.id === e && (r = n);
      }), r;
    }
    return this.nodeManager.getRowNode(e);
  }
  // rows: the rows to put into the model
  setRowData(e) {
    this.selectionService.reset("rowDataChanged"), this.nodeManager.setRowData(e), this.hasStarted && this.dispatchUpdateEventsAndRefresh();
  }
  dispatchUpdateEventsAndRefresh() {
    const e = {
      type: "rowDataUpdated"
    };
    this.eventService.dispatchEvent(e), this.refreshModel({
      step: "group",
      newData: !0
    });
  }
  batchUpdateRowData(e, t) {
    if (this.applyAsyncTransactionsTimeout == null) {
      this.rowDataTransactionBatch = [];
      const r = this.gos.getAsyncTransactionWaitMillis();
      this.applyAsyncTransactionsTimeout = window.setTimeout(() => {
        this.executeBatchUpdateRowData();
      }, r);
    }
    this.rowDataTransactionBatch.push({ rowDataTransaction: e, callback: t });
  }
  flushAsyncTransactions() {
    this.applyAsyncTransactionsTimeout != null && (clearTimeout(this.applyAsyncTransactionsTimeout), this.executeBatchUpdateRowData());
  }
  executeBatchUpdateRowData() {
    this.valueCache.onDataChanged();
    const e = [], t = [];
    let r = !1;
    if (this.rowDataTransactionBatch && this.rowDataTransactionBatch.forEach((n) => {
      const i = this.nodeManager.updateRowData(n.rowDataTransaction, void 0);
      t.push(i), n.callback && e.push(n.callback.bind(null, i)), typeof n.rowDataTransaction.addIndex == "number" && (r = !0);
    }), this.commonUpdateRowData(t, void 0, r), e.length > 0 && window.setTimeout(() => {
      e.forEach((n) => n());
    }, 0), t.length > 0) {
      const n = {
        type: "asyncTransactionsFlushed",
        results: t
      };
      this.eventService.dispatchEvent(n);
    }
    this.rowDataTransactionBatch = null, this.applyAsyncTransactionsTimeout = void 0;
  }
  updateRowData(e, t) {
    this.valueCache.onDataChanged();
    const r = this.nodeManager.updateRowData(e, t), n = typeof e.addIndex == "number";
    return this.commonUpdateRowData([r], t, n), r;
  }
  createRowNodeOrder() {
    if (this.gos.get("suppressMaintainUnsortedOrder"))
      return;
    const t = {};
    if (this.rootNode && this.rootNode.allLeafChildren)
      for (let r = 0; r < this.rootNode.allLeafChildren.length; r++) {
        const n = this.rootNode.allLeafChildren[r];
        t[n.id] = r;
      }
    return t;
  }
  // common to updateRowData and batchUpdateRowData
  commonUpdateRowData(e, t, r) {
    if (!this.hasStarted)
      return;
    const n = !this.gos.get("suppressAnimationFrame");
    r && (t = this.createRowNodeOrder());
    const i = {
      type: "rowDataUpdated"
    };
    this.eventService.dispatchEvent(i), this.refreshModel({
      step: "group",
      rowNodeTransactions: e,
      rowNodeOrder: t,
      keepRenderedRows: !0,
      keepEditingRows: !0,
      animate: n
    });
  }
  doRowsToDisplay() {
    this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode });
  }
  onRowHeightChanged() {
    this.refreshModel({
      step: "map",
      keepRenderedRows: !0,
      keepEditingRows: !0,
      keepUndoRedoStack: !0
    });
  }
  /** This method is debounced. It is used for row auto-height. If we don't debounce,
   * then the Row Models will end up recalculating each row position
   * for each row height change and result in the Row Renderer laying out rows.
   * This is particularly bad if using print layout, and showing eg 1,000 rows,
   * each row will change it's height, causing Row Model to update 1,000 times.
   */
  onRowHeightChangedDebounced() {
    this.onRowHeightChanged_debounced();
  }
  resetRowHeights() {
    const e = this.resetRowHeightsForAllRowNodes();
    this.rootNode.setRowHeight(this.rootNode.rowHeight, !0), this.rootNode.sibling && this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, !0), e && this.onRowHeightChanged();
  }
  resetRowHeightsForAllRowNodes() {
    let e = !1;
    return this.forEachNode((t) => {
      t.setRowHeight(t.rowHeight, !0);
      const r = t.detailNode;
      r && r.setRowHeight(r.rowHeight, !0), t.sibling && t.sibling.setRowHeight(t.sibling.rowHeight, !0), e = !0;
    }), e;
  }
  onGridStylesChanges(e) {
    if (e.rowHeightChanged) {
      if (this.columnModel.isAutoRowHeightActive())
        return;
      this.resetRowHeights();
    }
  }
  onGridReady() {
    this.hasStarted || this.setInitialData();
  }
  isRowDataLoaded() {
    return this.rowCountReady;
  }
};
function f5e(e) {
  e.expansionService.onGroupExpandedOrCollapsed();
}
function p5e(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.refreshModel(t);
}
function g5e(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.forEachLeafNode(t);
}
function v5e(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.forEachNodeAfterFilter(t);
}
function m5e(e, t) {
  var r, n;
  (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null || n.forEachNodeAfterFilterAndSort(t);
}
function y5e(e) {
  var t, r;
  if (e.columnModel.isAutoRowHeightActive()) {
    Se("calling gridApi.resetRowHeights() makes no sense when using Auto Row Height.");
    return;
  }
  (r = (t = e.rowModelHelperService) == null ? void 0 : t.getClientSideRowModel()) == null || r.resetRowHeights();
}
function C5e(e, t) {
  return e.frameworkOverrides.wrapIncoming(
    () => {
      var r, n;
      return (n = (r = e.rowModelHelperService) == null ? void 0 : r.getClientSideRowModel()) == null ? void 0 : n.updateRowData(t);
    }
  );
}
function S5e(e, t, r) {
  e.frameworkOverrides.wrapIncoming(
    () => {
      var n, i;
      return (i = (n = e.rowModelHelperService) == null ? void 0 : n.getClientSideRowModel()) == null ? void 0 : i.batchUpdateRowData(t, r);
    }
  );
}
function w5e(e) {
  e.frameworkOverrides.wrapIncoming(
    () => {
      var t, r;
      return (r = (t = e.rowModelHelperService) == null ? void 0 : t.getClientSideRowModel()) == null ? void 0 : r.flushAsyncTransactions();
    }
  );
}
function b5e(e) {
  return e.selectionService.getBestCostNodeSelection();
}
var x5e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "filterStage";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager;
  }
  execute(e) {
    const { changedPath: t } = e;
    this.filter(t);
  }
  filter(e) {
    var r;
    const t = !!((r = this.filterManager) != null && r.isChildFilterPresent());
    this.filterNodes(t, e);
  }
  filterNodes(e, t) {
    const r = (n, i) => {
      n.hasChildren() && e && !i ? n.childrenAfterFilter = n.childrenAfterGroup.filter((o) => {
        const a = o.childrenAfterFilter && o.childrenAfterFilter.length > 0, s = o.data && this.filterManager.doesRowPassFilter({ rowNode: o });
        return a || s;
      }) : n.childrenAfterFilter = n.childrenAfterGroup, n.sibling && (n.sibling.childrenAfterFilter = n.childrenAfterFilter);
    };
    if (this.doingTreeDataFiltering()) {
      const n = (o, a) => {
        if (o.childrenAfterGroup)
          for (let s = 0; s < o.childrenAfterGroup.length; s++) {
            const l = o.childrenAfterGroup[s], u = a || this.filterManager.doesRowPassFilter({ rowNode: l });
            l.childrenAfterGroup ? n(o.childrenAfterGroup[s], u) : r(l, u);
          }
        r(o, a);
      }, i = (o) => n(o, !1);
      t.executeFromRootNode(i);
    } else {
      const n = (i) => r(i, !1);
      t.forEachChangedNodeDepthFirst(n, !0);
    }
  }
  doingTreeDataFiltering() {
    return this.gos.get("treeData") && !this.gos.get("excludeChildrenWhenTreeDataFiltering");
  }
}, E5e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "flattenStage";
  }
  wireBeans(e) {
    this.beans = e, this.columnModel = e.columnModel;
  }
  execute(e) {
    const t = e.rowNode, r = [], n = this.columnModel.isPivotMode(), i = n && t.leafGroup, o = i ? [t] : t.childrenAfterSort, a = this.getFlattenDetails();
    this.recursivelyAddToRowsToDisplay(a, o, r, n, 0);
    const s = r.length > 0;
    if (!i && // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)
    s && a.grandTotalRow) {
      t.createFooter();
      const u = a.grandTotalRow === "top";
      this.addRowNodeToRowsToDisplay(a, t.sibling, r, 0, u);
    }
    return r;
  }
  getFlattenDetails() {
    const e = this.gos.get("groupRemoveSingleChildren");
    return {
      groupRemoveLowestSingleChildren: !e && this.gos.get("groupRemoveLowestSingleChildren"),
      groupRemoveSingleChildren: e,
      isGroupMultiAutoColumn: this.gos.isGroupMultiAutoColumn(),
      hideOpenParents: this.gos.get("groupHideOpenParents"),
      grandTotalRow: this.gos.getGrandTotalRow(),
      groupTotalRow: this.gos.getGroupTotalRowCallback()
    };
  }
  recursivelyAddToRowsToDisplay(e, t, r, n, i) {
    if (!Dn(t))
      for (let o = 0; o < t.length; o++) {
        const a = t[o], s = a.hasChildren(), l = n && !s, u = e.groupRemoveSingleChildren && s && a.childrenAfterGroup.length === 1, c = e.groupRemoveLowestSingleChildren && s && a.leafGroup && a.childrenAfterGroup.length === 1, d = n && a.leafGroup, h = e.hideOpenParents && a.expanded && !a.master && !d;
        if (!l && !h && !u && !c && this.addRowNodeToRowsToDisplay(e, a, r, i), !(n && a.leafGroup)) {
          if (s) {
            const p = u || c;
            if (a.expanded || p) {
              const g = e.groupTotalRow({ node: a });
              g || a.destroyFooter();
              const v = p ? i : i + 1;
              g === "top" && (a.createFooter(), this.addRowNodeToRowsToDisplay(e, a.sibling, r, v)), this.recursivelyAddToRowsToDisplay(
                e,
                a.childrenAfterSort,
                r,
                n,
                v
              ), g === "bottom" && (a.createFooter(), this.addRowNodeToRowsToDisplay(e, a.sibling, r, v));
            }
          } else if (a.master && a.expanded) {
            const p = this.createDetailNode(a);
            this.addRowNodeToRowsToDisplay(e, p, r, i);
          }
        }
      }
  }
  // duplicated method, it's also in floatingRowModel
  addRowNodeToRowsToDisplay(e, t, r, n, i) {
    i ? r.unshift(t) : r.push(t), t.setUiLevel(e.isGroupMultiAutoColumn ? 0 : n);
  }
  createDetailNode(e) {
    if (Me(e.detailNode))
      return e.detailNode;
    const t = new Os(this.beans);
    return t.detail = !0, t.selectable = !1, t.parent = e, Me(e.id) && (t.id = "detail_" + e.id), t.data = e.data, t.level = e.level + 1, e.detailNode = t, t;
  }
}, R5e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "immutableService";
  }
  wireBeans(e) {
    this.rowModel = e.rowModel, this.selectionService = e.selectionService;
  }
  postConstruct() {
    this.rowModel.getType() === "clientSide" && (this.clientSideRowModel = this.rowModel, this.addManagedPropertyListener("rowData", () => this.onRowDataUpdated()));
  }
  isActive() {
    const e = this.gos.exists("getRowId");
    return this.gos.get("resetRowDataOnUpdate") ? !1 : e;
  }
  setRowData(e) {
    const t = this.createTransactionForRowData(e);
    if (!t)
      return;
    const [r, n] = t;
    this.clientSideRowModel.updateRowData(r, n);
  }
  // converts the setRowData() command to a transaction
  createTransactionForRowData(e) {
    if (Zt(this.clientSideRowModel)) {
      sr("ImmutableService only works with ClientSideRowModel");
      return;
    }
    const t = this.gos.getRowIdCallback();
    if (t == null) {
      sr("ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!");
      return;
    }
    const r = {
      remove: [],
      update: [],
      add: []
    }, n = this.clientSideRowModel.getCopyOfNodesMap(), o = this.gos.get("suppressMaintainUnsortedOrder") ? void 0 : {};
    return Me(e) && e.forEach((a, s) => {
      const l = t({ data: a, level: 0 }), u = n[l];
      o && (o[l] = s), u ? (u.data !== a && r.update.push(a), n[l] = void 0) : r.add.push(a);
    }), ia(n, (a, s) => {
      s && r.remove.push(s.data);
    }), [r, o];
  }
  onRowDataUpdated() {
    const e = this.gos.get("rowData");
    e && (this.isActive() ? this.setRowData(e) : (this.selectionService.reset("rowDataChanged"), this.clientSideRowModel.setRowData(e)));
  }
}, _5e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "sortService";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.funcColsService = e.funcColsService, this.rowNodeSorter = e.rowNodeSorter, this.showRowGroupColsService = e.showRowGroupColsService;
  }
  sort(e, t, r, n, i, o) {
    const a = this.gos.get("groupMaintainOrder"), s = this.columnModel.getCols().some((h) => h.isRowGroupActive());
    let l = {};
    r && n && (l = this.calculateDirtyNodes(n));
    const u = this.columnModel.isPivotMode(), c = this.gos.getCallback("postSortRows"), d = (h) => {
      var g;
      this.pullDownGroupDataForHideOpenParents(h.childrenAfterAggFilter, !0);
      const f = u && h.leafGroup;
      if (a && s && !h.leafGroup && !o) {
        const v = (g = this.funcColsService.getRowGroupColumns()) == null ? void 0 : g[h.level + 1], m = (v == null ? void 0 : v.getSort()) === null, y = h.childrenAfterAggFilter.slice(0);
        if (h.childrenAfterSort && !m) {
          const C = {};
          h.childrenAfterSort.forEach((S, b) => {
            C[S.id] = b;
          }), y.sort(
            (S, b) => (C[S.id] ?? 0) - (C[b.id] ?? 0)
          );
        }
        h.childrenAfterSort = y;
      } else !t || f ? h.childrenAfterSort = h.childrenAfterAggFilter.slice(0) : r ? h.childrenAfterSort = this.doDeltaSort(h, l, i, e) : h.childrenAfterSort = this.rowNodeSorter.doFullSort(h.childrenAfterAggFilter, e);
      if (h.sibling && (h.sibling.childrenAfterSort = h.childrenAfterSort), this.updateChildIndexes(h), c) {
        const v = { nodes: h.childrenAfterSort };
        c(v);
      }
    };
    i && i.forEachChangedNodeDepthFirst(d), this.updateGroupDataForHideOpenParents(i);
  }
  calculateDirtyNodes(e) {
    const t = {}, r = (n) => {
      n && n.forEach((i) => t[i.id] = !0);
    };
    return e && e.forEach((n) => {
      r(n.add), r(n.update), r(n.remove);
    }), t;
  }
  doDeltaSort(e, t, r, n) {
    const i = e.childrenAfterAggFilter, o = e.childrenAfterSort;
    if (!o)
      return this.rowNodeSorter.doFullSort(i, n);
    const a = {}, s = [];
    i.forEach((d) => {
      t[d.id] || !r.canSkip(d) ? s.push(d) : a[d.id] = !0;
    });
    const l = o.filter((d) => a[d.id]), u = (d, h) => ({
      currentPos: h,
      rowNode: d
    }), c = s.map(u).sort((d, h) => this.rowNodeSorter.compareRowNodes(n, d, h));
    return this.mergeSortedArrays(n, c, l.map(u)).map(
      ({ rowNode: d }) => d
    );
  }
  // Merge two sorted arrays into each other
  mergeSortedArrays(e, t, r) {
    const n = [];
    let i = 0, o = 0;
    for (; i < t.length && o < r.length; )
      this.rowNodeSorter.compareRowNodes(e, t[i], r[o]) < 0 ? n.push(t[i++]) : n.push(r[o++]);
    for (; i < t.length; )
      n.push(t[i++]);
    for (; o < r.length; )
      n.push(r[o++]);
    return n;
  }
  updateChildIndexes(e) {
    if (Zt(e.childrenAfterSort))
      return;
    const t = e.childrenAfterSort;
    for (let r = 0; r < t.length; r++) {
      const n = t[r], i = r === 0, o = r === e.childrenAfterSort.length - 1;
      n.setFirstChild(i), n.setLastChild(o), n.setChildIndex(r);
    }
  }
  updateGroupDataForHideOpenParents(e) {
    if (!this.gos.get("groupHideOpenParents"))
      return;
    if (this.gos.get("treeData"))
      return Se(
        "The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them."
      ), !1;
    const t = (r) => {
      this.pullDownGroupDataForHideOpenParents(r.childrenAfterSort, !1), r.childrenAfterSort.forEach((n) => {
        n.hasChildren() && t(n);
      });
    };
    e && e.executeFromRootNode((r) => t(r));
  }
  pullDownGroupDataForHideOpenParents(e, t) {
    !this.gos.get("groupHideOpenParents") || Zt(e) || e.forEach((r) => {
      var i;
      (((i = this.showRowGroupColsService) == null ? void 0 : i.getShowRowGroupCols()) ?? []).forEach((o) => {
        const a = o.getColDef().showRowGroup;
        if (typeof a != "string") {
          sr(
            "groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup"
          );
          return;
        }
        const s = a, l = this.columnModel.getColDefCol(s);
        if (l !== r.rowGroupColumn)
          if (t)
            r.setGroupValue(o.getId(), void 0);
          else {
            const c = r.getFirstChildOfFirstChild(l);
            c && r.setGroupValue(o.getId(), c.key);
          }
      });
    });
  }
}, T5e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "sortStage";
  }
  wireBeans(e) {
    this.sortService = e.sortService, this.sortController = e.sortController;
  }
  execute(e) {
    const t = this.sortController.getSortOptions(), r = Me(t) && t.length > 0, n = r && Me(e.rowNodeTransactions) && // in time we can remove this check, so that delta sort is always
    // on if transactions are present. it's off for now so that we can
    // selectively turn it on and test it with some select users before
    // rolling out to everyone.
    this.gos.get("deltaSort"), i = t.some((o) => this.gos.isColumnsSortingCoupledToGroup() ? o.column.isPrimary() && o.column.isRowGroupActive() : !!o.column.getColDef().showRowGroup);
    this.sortService.sort(
      t,
      r,
      n,
      e.rowNodeTransactions,
      e.changedPath,
      i
    );
  }
}, zA = "32.0.1", DY = {
  version: zA,
  moduleName: "@ag-grid-community/client-side-row-model-core",
  rowModel: "clientSide",
  beans: [h5e, x5e, T5e, E5e, _5e, R5e]
}, P5e = {
  version: zA,
  moduleName: "@ag-grid-community/client-side-row-model-api",
  beans: [MY],
  apiFunctions: {
    onGroupExpandedOrCollapsed: f5e,
    refreshClientSideRowModel: p5e,
    forEachLeafNode: g5e,
    forEachNodeAfterFilter: v5e,
    forEachNodeAfterFilterAndSort: m5e,
    resetRowHeights: y5e,
    applyTransaction: C5e,
    applyTransactionAsync: S5e,
    flushAsyncTransactions: w5e,
    getBestCostNodeSelection: b5e
  },
  dependantModules: [DY, a5e]
}, M5e = {
  version: zA,
  moduleName: "@ag-grid-community/client-side-row-model",
  dependantModules: [DY, P5e]
}, D5e = class extends he {
  setBeans(e) {
    this.beans = e;
  }
  getFileName(e) {
    const t = this.getDefaultFileExtension();
    return (e == null || !e.length) && (e = this.getDefaultFileName()), e.indexOf(".") === -1 ? `${e}.${t}` : e;
  }
  getData(e) {
    const t = this.createSerializingSession(e);
    return this.beans.gridSerializer.serialize(t, e);
  }
  getDefaultFileName() {
    return `export.${this.getDefaultFileExtension()}`;
  }
}, A5e = class {
  constructor(e) {
    this.groupColumns = [];
    const {
      columnModel: t,
      funcColsService: r,
      columnNameService: n,
      valueService: i,
      gos: o,
      processCellCallback: a,
      processHeaderCallback: s,
      processGroupHeaderCallback: l,
      processRowGroupCallback: u
    } = e;
    this.columnModel = t, this.funcColsService = r, this.columnNameService = n, this.valueService = i, this.gos = o, this.processCellCallback = a, this.processHeaderCallback = s, this.processGroupHeaderCallback = l, this.processRowGroupCallback = u;
  }
  prepare(e) {
    this.groupColumns = e.filter((t) => !!t.getColDef().showRowGroup);
  }
  extractHeaderValue(e) {
    return this.getHeaderName(this.processHeaderCallback, e) ?? "";
  }
  extractRowCellValue(e, t, r, n, i) {
    const a = (!this.gos.get("groupHideOpenParents") || i.footer) && this.shouldRenderGroupSummaryCell(i, e, t) ? this.createValueForGroupNode(e, i) : this.valueService.getValue(e, i);
    return this.processCell({
      accumulatedRowIndex: r,
      rowNode: i,
      column: e,
      value: a,
      processCellCallback: this.processCellCallback,
      type: n
    });
  }
  shouldRenderGroupSummaryCell(e, t, r) {
    var a;
    if (!(e && e.group))
      return !1;
    if (this.groupColumns.indexOf(t) !== -1) {
      if (((a = e.groupData) == null ? void 0 : a[t.getId()]) != null || this.gos.isRowModelType("serverSide") && e.group)
        return !0;
      if (e.footer && e.level === -1) {
        const s = t.getColDef();
        return s == null || s.showRowGroup === !0 || s.showRowGroup === this.funcColsService.getRowGroupColumns()[0].getId();
      }
    }
    const o = this.gos.isGroupUseEntireRow(this.columnModel.isPivotMode());
    return r === 0 && o;
  }
  getHeaderName(e, t) {
    return e ? e(this.gos.addGridCommonParams({ column: t })) : this.columnNameService.getDisplayNameForColumn(t, "csv", !0);
  }
  createValueForGroupNode(e, t) {
    if (this.processRowGroupCallback)
      return this.processRowGroupCallback(this.gos.addGridCommonParams({ column: e, node: t }));
    const r = this.gos.get("treeData"), n = this.gos.get("suppressGroupMaintainValueType"), i = (l) => {
      var c;
      if (r || n)
        return l.key;
      const u = (c = l.groupData) == null ? void 0 : c[e.getId()];
      return !u || !l.rowGroupColumn || l.rowGroupColumn.getColDef().useValueFormatterForExport === !1 ? u : this.valueService.formatValue(l.rowGroupColumn, l, u) ?? u;
    }, o = t.footer, a = [i(t)];
    if (!this.gos.isGroupMultiAutoColumn())
      for (; t.parent; )
        t = t.parent, a.push(i(t));
    const s = a.reverse().join(" -> ");
    return o ? `Total ${s}` : s;
  }
  processCell(e) {
    const { accumulatedRowIndex: t, rowNode: r, column: n, value: i, processCellCallback: o, type: a } = e;
    return o ? {
      value: o(
        this.gos.addGridCommonParams({
          accumulatedRowIndex: t,
          column: n,
          node: r,
          value: i,
          type: a,
          parseValue: (s) => this.valueService.parseValue(
            n,
            r,
            s,
            this.valueService.getValue(n, r)
          ),
          formatValue: (s) => this.valueService.formatValue(n, r, s) ?? s
        })
      ) ?? ""
    } : n.getColDef().useValueFormatterForExport !== !1 ? {
      value: i ?? "",
      valueFormatted: this.valueService.formatValue(n, r, i)
    } : { value: i ?? "" };
  }
}, I5e = class {
  static download(e, t) {
    const r = document.defaultView || window;
    if (!r) {
      Se("There is no `window` associated with the current `document`");
      return;
    }
    const n = document.createElement("a"), i = r.URL.createObjectURL(t);
    n.setAttribute("href", i), n.setAttribute("download", e), n.style.display = "none", document.body.appendChild(n), n.dispatchEvent(
      new MouseEvent("click", {
        bubbles: !1,
        cancelable: !0,
        view: r
      })
    ), document.body.removeChild(n), r.setTimeout(() => {
      r.URL.revokeObjectURL(i);
    }, 0);
  }
}, KG = `\r
`, F5e = class extends A5e {
  constructor(e) {
    super(e), this.isFirstLine = !0, this.result = "";
    const { suppressQuotes: t, columnSeparator: r } = e;
    this.suppressQuotes = t, this.columnSeparator = r;
  }
  addCustomContent(e) {
    e && (typeof e == "string" ? (/^\s*\n/.test(e) || this.beginNewLine(), e = e.replace(/\r?\n/g, KG), this.result += e) : e.forEach((t) => {
      this.beginNewLine(), t.forEach((r, n) => {
        n !== 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(r.data.value || ""), r.mergeAcross && this.appendEmptyCells(r.mergeAcross);
      });
    }));
  }
  onNewHeaderGroupingRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderGroupingRowColumn.bind(this)
    };
  }
  onNewHeaderGroupingRowColumn(e, t, r, n) {
    r != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(t), this.appendEmptyCells(n);
  }
  appendEmptyCells(e) {
    for (let t = 1; t <= e; t++)
      this.result += this.columnSeparator + this.putInQuotes("");
  }
  onNewHeaderRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewHeaderRowColumn.bind(this)
    };
  }
  onNewHeaderRowColumn(e, t) {
    t != 0 && (this.result += this.columnSeparator), this.result += this.putInQuotes(this.extractHeaderValue(e));
  }
  onNewBodyRow() {
    return this.beginNewLine(), {
      onColumn: this.onNewBodyRowColumn.bind(this)
    };
  }
  onNewBodyRowColumn(e, t, r) {
    t != 0 && (this.result += this.columnSeparator);
    const n = this.extractRowCellValue(e, t, t, "csv", r);
    this.result += this.putInQuotes(n.valueFormatted ?? n.value);
  }
  putInQuotes(e) {
    if (this.suppressQuotes)
      return e;
    if (e == null)
      return '""';
    let t;
    return typeof e == "string" ? t = e : typeof e.toString == "function" ? t = e.toString() : (Se("unknown value type during csv conversion"), t = ""), '"' + t.replace(/"/g, '""') + '"';
  }
  parse() {
    return this.result;
  }
  beginNewLine() {
    this.isFirstLine || (this.result += KG), this.isFirstLine = !1;
  }
}, L5e = class extends D5e {
  constructor() {
    super(...arguments), this.beanName = "csvCreator";
  }
  wireBeans(e) {
    this.columnModel = e.columnModel, this.columnNameService = e.columnNameService, this.funcColsService = e.funcColsService, this.valueService = e.valueService, this.gridSerializer = e.gridSerializer;
  }
  postConstruct() {
    this.setBeans({
      gridSerializer: this.gridSerializer,
      gos: this.gos
    });
  }
  getMergedParams(e) {
    const t = this.gos.get("defaultCsvExportParams");
    return Object.assign({}, t, e);
  }
  export(e) {
    if (this.isExportSuppressed()) {
      Se("Export cancelled. Export is not allowed as per your configuration.");
      return;
    }
    const t = this.getMergedParams(e), r = this.getData(t), n = new Blob(["\uFEFF", r], { type: "text/plain" }), i = typeof t.fileName == "function" ? t.fileName(this.gos.getGridCommonParams()) : t.fileName;
    I5e.download(this.getFileName(i), n);
  }
  exportDataAsCsv(e) {
    this.export(e);
  }
  getDataAsCsv(e, t = !1) {
    const r = t ? Object.assign({}, e) : this.getMergedParams(e);
    return this.getData(r);
  }
  getDefaultFileExtension() {
    return "csv";
  }
  createSerializingSession(e) {
    const { columnModel: t, columnNameService: r, funcColsService: n, valueService: i, gos: o } = this, {
      processCellCallback: a,
      processHeaderCallback: s,
      processGroupHeaderCallback: l,
      processRowGroupCallback: u,
      suppressQuotes: c,
      columnSeparator: d
    } = e;
    return new F5e({
      columnModel: t,
      columnNameService: r,
      funcColsService: n,
      valueService: i,
      gos: o,
      processCellCallback: a || void 0,
      processHeaderCallback: s || void 0,
      processGroupHeaderCallback: l || void 0,
      processRowGroupCallback: u || void 0,
      suppressQuotes: c || !1,
      columnSeparator: d || ","
    });
  }
  isExportSuppressed() {
    return this.gos.get("suppressCsvExport");
  }
};
function O5e(e, t) {
  var r;
  return (r = e.csvCreator) == null ? void 0 : r.getDataAsCsv(t);
}
function N5e(e, t) {
  var r;
  (r = e.csvCreator) == null || r.exportDataAsCsv(t);
}
var k5e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "gridSerializer";
  }
  wireBeans(e) {
    this.visibleColsService = e.visibleColsService, this.columnModel = e.columnModel, this.columnNameService = e.columnNameService, this.rowModel = e.rowModel, this.pinnedRowModel = e.pinnedRowModel, this.selectionService = e.selectionService, this.rowNodeSorter = e.rowNodeSorter, this.sortController = e.sortController;
  }
  serialize(e, t = {}) {
    const { allColumns: r, columnKeys: n, skipRowGroups: i } = t, o = this.getColumnsToExport(
      r,
      i,
      n
    );
    return GLe(
      // first pass, put in the header names of the cols
      this.prepareSession(o),
      this.prependContent(t),
      this.exportColumnGroups(t, o),
      this.exportHeaders(t, o),
      this.processPinnedTopRows(t, o),
      this.processRows(t, o),
      this.processPinnedBottomRows(t, o),
      this.appendContent(t)
    )(e).parse();
  }
  processRow(e, t, r, n) {
    var m;
    const i = t.shouldRowBeSkipped || (() => !1), o = this.gos.get("groupRemoveSingleChildren"), a = this.gos.get("groupRemoveLowestSingleChildren"), l = t.rowPositions != null || !!t.onlySelected, u = this.gos.get("groupHideOpenParents") && !l, c = this.columnModel.isPivotMode() ? n.leafGroup : !n.group, d = !!n.footer, h = a && n.leafGroup, f = n.allChildrenCount === 1 && ((m = n.childrenAfterGroup) == null ? void 0 : m.length) === 1 && (o || h);
    if (!c && !d && (t.skipRowGroups || f || u) || t.onlySelected && !n.isSelected() || t.skipPinnedTop && n.rowPinned === "top" || t.skipPinnedBottom && n.rowPinned === "bottom" || n.level === -1 && !c && !d || i(this.gos.addGridCommonParams({ node: n })))
      return;
    const v = e.onNewBodyRow(n);
    if (r.forEach((y, C) => {
      v.onColumn(y, C, n);
    }), t.getCustomContentBelowRow) {
      const y = t.getCustomContentBelowRow(this.gos.addGridCommonParams({ node: n }));
      y && e.addCustomContent(y);
    }
  }
  appendContent(e) {
    return (t) => {
      const r = e.appendContent;
      return r && t.addCustomContent(r), t;
    };
  }
  prependContent(e) {
    return (t) => {
      const r = e.prependContent;
      return r && t.addCustomContent(r), t;
    };
  }
  prepareSession(e) {
    return (t) => (t.prepare(e), t);
  }
  exportColumnGroups(e, t) {
    return (r) => {
      if (!e.skipColumnGroupHeaders) {
        const n = new rK(), i = this.visibleColsService.createGroups({
          columns: t,
          idCreator: n,
          pinned: null,
          isStandaloneStructure: !0
        });
        this.recursivelyAddHeaderGroups(
          i,
          r,
          e.processGroupHeaderCallback
        );
      }
      return r;
    };
  }
  exportHeaders(e, t) {
    return (r) => {
      if (!e.skipColumnHeaders) {
        const n = r.onNewHeaderRow();
        t.forEach((i, o) => {
          n.onColumn(i, o, void 0);
        });
      }
      return r;
    };
  }
  processPinnedTopRows(e, t) {
    return (r) => {
      const n = this.processRow.bind(this, r, e, t);
      return e.rowPositions ? e.rowPositions.filter((i) => i.rowPinned === "top").sort((i, o) => i.rowIndex - o.rowIndex).map((i) => this.pinnedRowModel.getPinnedTopRow(i.rowIndex)).forEach(n) : this.pinnedRowModel.forEachPinnedTopRow(n), r;
    };
  }
  processRows(e, t) {
    return (r) => {
      const n = this.rowModel, i = n.getType(), o = i === "clientSide", a = i === "serverSide", s = !o && e.onlySelected, l = this.processRow.bind(this, r, e, t), { exportedRows: u = "filteredAndSorted" } = e;
      if (e.rowPositions)
        e.rowPositions.filter((c) => c.rowPinned == null).sort((c, d) => c.rowIndex - d.rowIndex).map((c) => n.getRow(c.rowIndex)).forEach(l);
      else if (this.columnModel.isPivotMode())
        o ? n.forEachPivotNode(l, !0) : a ? n.forEachNodeAfterFilterAndSort(l, !0) : n.forEachNode(l);
      else if (e.onlySelectedAllPages || s) {
        const c = this.selectionService.getSelectedNodes();
        this.replicateSortedOrder(c), c.forEach(l);
      } else
        u === "all" ? n.forEachNode(l) : o || a ? n.forEachNodeAfterFilterAndSort(l, !0) : n.forEachNode(l);
      return r;
    };
  }
  replicateSortedOrder(e) {
    const t = this.sortController.getSortOptions(), r = (n, i) => {
      var o, a;
      return n.rowIndex != null && i.rowIndex != null ? n.rowIndex - i.rowIndex : n.level === i.level ? ((o = n.parent) == null ? void 0 : o.id) === ((a = i.parent) == null ? void 0 : a.id) ? this.rowNodeSorter.compareRowNodes(
        t,
        {
          rowNode: n,
          currentPos: n.rowIndex ?? -1
        },
        {
          rowNode: i,
          currentPos: i.rowIndex ?? -1
        }
      ) : r(n.parent, i.parent) : n.level > i.level ? r(n.parent, i) : r(n, i.parent);
    };
    e.sort(r);
  }
  processPinnedBottomRows(e, t) {
    return (r) => {
      const n = this.processRow.bind(this, r, e, t);
      return e.rowPositions ? e.rowPositions.filter((i) => i.rowPinned === "bottom").sort((i, o) => i.rowIndex - o.rowIndex).map((i) => this.pinnedRowModel.getPinnedBottomRow(i.rowIndex)).forEach(n) : this.pinnedRowModel.forEachPinnedBottomRow(n), r;
    };
  }
  getColumnsToExport(e = !1, t = !1, r) {
    const n = this.columnModel.isPivotMode();
    if (r && r.length)
      return this.columnModel.getColsForKeys(r);
    const i = this.gos.get("treeData");
    let o = [];
    return e && !n ? o = this.columnModel.getCols() : o = this.visibleColsService.getAllCols(), t && !i && (o = o.filter((a) => a.getColId() !== Uv)), o;
  }
  recursivelyAddHeaderGroups(e, t, r) {
    const n = [];
    e.forEach((i) => {
      const o = i;
      o.getChildren && o.getChildren().forEach((a) => n.push(a));
    }), e.length > 0 && an(e[0]) && this.doAddHeaderHeader(t, e, r), n && n.length > 0 && this.recursivelyAddHeaderGroups(
      n,
      t,
      r
    );
  }
  doAddHeaderHeader(e, t, r) {
    const n = e.onNewHeaderGroupingRow();
    let i = 0;
    t.forEach((o) => {
      const a = o;
      let s;
      r ? s = r(
        this.gos.addGridCommonParams({
          columnGroup: a
        })
      ) : s = this.columnNameService.getDisplayNameForColumnGroup(a, "header");
      const l = a.getLeafColumns().reduce((u, c, d, h) => {
        let f = Jt(u);
        return c.getColumnGroupShow() === "open" ? (!f || f[1] != null) && (f = [d], u.push(f)) : f && f[1] == null && (f[1] = d - 1), d === h.length - 1 && f && f[1] == null && (f[1] = d), u;
      }, []);
      n.onColumn(
        a,
        s || "",
        i++,
        a.getLeafColumns().length - 1,
        l
      );
    });
  }
}, $A = "32.0.1", AY = {
  version: $A,
  moduleName: "@ag-grid-community/csv-export-core",
  beans: [L5e, k5e]
}, V5e = {
  version: $A,
  moduleName: "@ag-grid-community/csv-export-api",
  apiFunctions: {
    getDataAsCsv: O5e,
    exportDataAsCsv: N5e
  },
  dependantModules: [AY]
}, B5e = {
  version: $A,
  moduleName: "@ag-grid-community/csv-export",
  dependantModules: [AY, V5e]
}, G5e = class extends jBe {
  wireBeans(e) {
    this.beans = e;
  }
  constructor(e, t, r) {
    super(e), this.parentCache = t, this.params = r, this.startRow = e * r.blockSize, this.endRow = this.startRow + r.blockSize;
  }
  postConstruct() {
    this.createRowNodes();
  }
  getBlockStateJson() {
    return {
      id: "" + this.getId(),
      state: {
        blockNumber: this.getId(),
        startRow: this.getStartRow(),
        endRow: this.getEndRow(),
        pageStatus: this.getState()
      }
    };
  }
  setDataAndId(e, t, r) {
    Me(t) ? e.setDataAndId(t, r.toString()) : e.setDataAndId(void 0, void 0);
  }
  loadFromDatasource() {
    const e = this.createLoadParams();
    if (Zt(this.params.datasource.getRows)) {
      Se("datasource is missing getRows method");
      return;
    }
    window.setTimeout(() => {
      this.params.datasource.getRows(e);
    }, 0);
  }
  processServerFail() {
  }
  createLoadParams() {
    return {
      startRow: this.getStartRow(),
      endRow: this.getEndRow(),
      successCallback: this.pageLoaded.bind(this, this.getVersion()),
      failCallback: this.pageLoadFailed.bind(this, this.getVersion()),
      sortModel: this.params.sortModel,
      filterModel: this.params.filterModel,
      context: this.gos.getGridCommonParams().context
    };
  }
  forEachNode(e, t, r) {
    this.rowNodes.forEach((n, i) => {
      this.startRow + i < r && e(n, t.next());
    });
  }
  getLastAccessed() {
    return this.lastAccessed;
  }
  getRow(e, t = !1) {
    t || (this.lastAccessed = this.params.lastAccessedSequence.next());
    const r = e - this.startRow;
    return this.rowNodes[r];
  }
  getStartRow() {
    return this.startRow;
  }
  getEndRow() {
    return this.endRow;
  }
  // creates empty row nodes, data is missing as not loaded yet
  createRowNodes() {
    this.rowNodes = [];
    for (let e = 0; e < this.params.blockSize; e++) {
      const t = this.startRow + e, r = new Os(this.beans);
      r.setRowHeight(this.params.rowHeight), r.uiLevel = 0, r.setRowIndex(t), r.setRowTop(this.params.rowHeight * t), this.rowNodes.push(r);
    }
  }
  processServerResult(e) {
    this.rowNodes.forEach((r, n) => {
      const i = e.rowData ? e.rowData[n] : void 0;
      !r.id && r.alreadyRendered && i && (this.rowNodes[n] = new Os(this.beans), this.rowNodes[n].setRowIndex(r.rowIndex), this.rowNodes[n].setRowTop(r.rowTop), this.rowNodes[n].setRowHeight(r.rowHeight), r.clearRowTopAndRowIndex()), this.setDataAndId(this.rowNodes[n], i, this.startRow + n);
    });
    const t = e.rowCount != null && e.rowCount >= 0 ? e.rowCount : void 0;
    this.parentCache.pageLoaded(this, t);
  }
  destroy() {
    this.rowNodes.forEach((e) => {
      e.clearRowTopAndRowIndex();
    }), super.destroy();
  }
}, H5e = 2, z5e = class extends he {
  constructor(e) {
    super(), this.lastRowIndexKnown = !1, this.blocks = {}, this.blockCount = 0, this.rowCount = e.initialRowCount, this.params = e;
  }
  wireBeans(e) {
    this.rowRenderer = e.rowRenderer, this.focusService = e.focusService;
  }
  // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,
  // it will want new pages in the cache as it asks for rows. only when we are inserting /
  // removing rows via the api is dontCreatePage set, where we move rows between the pages.
  getRow(e, t = !1) {
    const r = Math.floor(e / this.params.blockSize);
    let n = this.blocks[r];
    if (!n) {
      if (t)
        return;
      n = this.createBlock(r);
    }
    return n.getRow(e);
  }
  createBlock(e) {
    const t = this.createBean(new G5e(e, this, this.params));
    return this.blocks[t.getId()] = t, this.blockCount++, this.purgeBlocksIfNeeded(t), this.params.rowNodeBlockLoader.addBlock(t), t;
  }
  // we have this on infinite row model only, not server side row model,
  // because for server side, it would leave the children in inconsistent
  // state - eg if a node had children, but after the refresh it had data
  // for a different row, then the children would be with the wrong row node.
  refreshCache() {
    if (this.blockCount == 0) {
      this.purgeCache();
      return;
    }
    this.getBlocksInOrder().forEach((t) => t.setStateWaitingToLoad()), this.params.rowNodeBlockLoader.checkBlockToLoad();
  }
  destroy() {
    this.getBlocksInOrder().forEach((e) => this.destroyBlock(e)), super.destroy();
  }
  getRowCount() {
    return this.rowCount;
  }
  isLastRowIndexKnown() {
    return this.lastRowIndexKnown;
  }
  // block calls this, when page loaded
  pageLoaded(e, t) {
    this.isAlive() && (this.gos.get("debug") && sa(`InfiniteCache - onPageLoaded: page = ${e.getId()}, lastRow = ${t}`), this.checkRowCount(e, t), this.onCacheUpdated());
  }
  purgeBlocksIfNeeded(e) {
    const t = this.getBlocksInOrder().filter((a) => a != e), r = (a, s) => s.getLastAccessed() - a.getLastAccessed();
    t.sort(r);
    const n = this.params.maxBlocksInCache > 0, i = n ? this.params.maxBlocksInCache - 1 : null, o = H5e - 1;
    t.forEach((a, s) => {
      const l = a.getState() === "needsLoading" && s >= o, u = n ? s >= i : !1;
      if (l || u) {
        if (this.isBlockCurrentlyDisplayed(a) || this.isBlockFocused(a))
          return;
        this.removeBlockFromCache(a);
      }
    });
  }
  isBlockFocused(e) {
    const t = this.focusService.getFocusCellToUseAfterRefresh();
    if (!t || t.rowPinned != null)
      return !1;
    const r = e.getStartRow(), n = e.getEndRow();
    return t.rowIndex >= r && t.rowIndex < n;
  }
  isBlockCurrentlyDisplayed(e) {
    const t = e.getStartRow(), r = e.getEndRow() - 1;
    return this.rowRenderer.isRangeInRenderedViewport(t, r);
  }
  removeBlockFromCache(e) {
    e && this.destroyBlock(e);
  }
  checkRowCount(e, t) {
    if (typeof t == "number" && t >= 0)
      this.rowCount = t, this.lastRowIndexKnown = !0;
    else if (!this.lastRowIndexKnown) {
      const n = (e.getId() + 1) * this.params.blockSize + this.params.overflowSize;
      this.rowCount < n && (this.rowCount = n);
    }
  }
  setRowCount(e, t) {
    this.rowCount = e, Me(t) && (this.lastRowIndexKnown = t), this.lastRowIndexKnown || this.rowCount % this.params.blockSize === 0 && this.rowCount++, this.onCacheUpdated();
  }
  forEachNodeDeep(e) {
    const t = new jh();
    this.getBlocksInOrder().forEach((r) => r.forEachNode(e, t, this.rowCount));
  }
  getBlocksInOrder() {
    const e = (r, n) => r.getId() - n.getId();
    return xT(this.blocks).sort(e);
  }
  destroyBlock(e) {
    delete this.blocks[e.getId()], this.destroyBean(e), this.blockCount--, this.params.rowNodeBlockLoader.removeBlock(e);
  }
  // gets called 1) row count changed 2) cache purged 3) items inserted
  onCacheUpdated() {
    if (this.isAlive()) {
      this.destroyAllBlocksPastVirtualRowCount();
      const e = {
        type: "storeUpdated"
      };
      this.eventService.dispatchEvent(e);
    }
  }
  destroyAllBlocksPastVirtualRowCount() {
    const e = [];
    this.getBlocksInOrder().forEach((t) => {
      t.getId() * this.params.blockSize >= this.rowCount && e.push(t);
    }), e.length > 0 && e.forEach((t) => this.destroyBlock(t));
  }
  purgeCache() {
    this.getBlocksInOrder().forEach((e) => this.removeBlockFromCache(e)), this.lastRowIndexKnown = !1, this.rowCount === 0 && (this.rowCount = this.params.initialRowCount), this.onCacheUpdated();
  }
  getRowNodesInRange(e, t) {
    const r = [];
    let n = -1, i = !1;
    const o = new jh();
    let a = !1;
    return this.getBlocksInOrder().forEach((l) => {
      if (!a) {
        if (i && n + 1 !== l.getId()) {
          a = !0;
          return;
        }
        n = l.getId(), l.forEachNode(
          (u) => {
            const c = u === e || u === t;
            (i || c) && r.push(u), c && (i = !i);
          },
          o,
          this.rowCount
        );
      }
    }), a || i ? [] : r;
  }
}, $5e = class extends he {
  constructor() {
    super(...arguments), this.beanName = "rowModel";
  }
  wireBeans(e) {
    this.filterManager = e.filterManager, this.sortController = e.sortController, this.selectionService = e.selectionService, this.rowRenderer = e.rowRenderer, this.rowNodeBlockLoader = e.rowNodeBlockLoader;
  }
  getRowBounds(e) {
    return {
      rowHeight: this.rowHeight,
      rowTop: this.rowHeight * e
    };
  }
  // we don't implement as lazy row heights is not supported in this row model
  ensureRowHeightsValid() {
    return !1;
  }
  postConstruct() {
    this.gos.isRowModelType("infinite") && (this.rowHeight = this.gos.getRowHeightAsNumber(), this.addEventListeners(), this.addDestroyFunc(() => this.destroyCache()), this.verifyProps());
  }
  verifyProps() {
    this.gos.exists("initialGroupOrderComparator") && Se(
      "initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side"
    );
  }
  start() {
    this.setDatasource(this.gos.get("datasource"));
  }
  destroy() {
    this.destroyDatasource(), super.destroy();
  }
  destroyDatasource() {
    this.datasource && (this.destroyBean(this.datasource), this.rowRenderer.datasourceChanged(), this.datasource = null);
  }
  addEventListeners() {
    this.addManagedEventListeners({
      filterChanged: this.onFilterChanged.bind(this),
      sortChanged: this.onSortChanged.bind(this),
      newColumnsLoaded: this.onColumnEverything.bind(this),
      storeUpdated: this.onCacheUpdated.bind(this)
    }), this.addManagedPropertyListener("datasource", () => this.setDatasource(this.gos.get("datasource"))), this.addManagedPropertyListener("cacheBlockSize", () => this.resetCache()), this.addManagedPropertyListener("rowHeight", () => {
      this.rowHeight = this.gos.getRowHeightAsNumber(), this.cacheParams.rowHeight = this.rowHeight, this.updateRowHeights();
    });
  }
  onFilterChanged() {
    this.reset();
  }
  onSortChanged() {
    this.reset();
  }
  onColumnEverything() {
    let e;
    this.cacheParams ? e = this.isSortModelDifferent() : e = !0, e && this.reset();
  }
  isSortModelDifferent() {
    return !GC(this.cacheParams.sortModel, this.sortController.getSortModel());
  }
  getType() {
    return "infinite";
  }
  setDatasource(e) {
    this.destroyDatasource(), this.datasource = e, e && this.reset();
  }
  isEmpty() {
    return !this.infiniteCache;
  }
  isRowsToRender() {
    return !!this.infiniteCache;
  }
  getNodesInRangeForSelection(e, t) {
    return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(e, t) : [];
  }
  reset() {
    if (!this.datasource)
      return;
    this.gos.getRowIdCallback() != null || this.selectionService.reset("rowDataChanged"), this.resetCache();
  }
  createModelUpdatedEvent() {
    return {
      type: "modelUpdated",
      // not sure if these should all be false - noticed if after implementing,
      // maybe they should be true?
      newPage: !1,
      newPageSize: !1,
      newData: !1,
      keepRenderedRows: !0,
      animate: !1
    };
  }
  resetCache() {
    var t;
    this.destroyCache(), this.cacheParams = {
      // the user provided datasource
      datasource: this.datasource,
      // sort and filter model
      filterModel: ((t = this.filterManager) == null ? void 0 : t.getFilterModel()) ?? {},
      sortModel: this.sortController.getSortModel(),
      rowNodeBlockLoader: this.rowNodeBlockLoader,
      // properties - this way we take a snapshot of them, so if user changes any, they will be
      // used next time we create a new cache, which is generally after a filter or sort change,
      // or a new datasource is set
      initialRowCount: this.gos.get("infiniteInitialRowCount"),
      maxBlocksInCache: this.gos.get("maxBlocksInCache"),
      rowHeight: this.gos.getRowHeightAsNumber(),
      // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past
      // the current page and request first row of next page
      overflowSize: this.gos.get("cacheOverflowSize"),
      // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the
      // server for one page at a time. so the default if not specified is 100.
      blockSize: this.gos.get("cacheBlockSize"),
      // the cache could create this, however it is also used by the pages, so handy to create it
      // here as the settings are also passed to the pages
      lastAccessedSequence: new jh()
    }, this.infiniteCache = this.createBean(new z5e(this.cacheParams)), this.eventService.dispatchEventOnce({
      type: "rowCountReady"
    });
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  updateRowHeights() {
    this.forEachNode((t) => {
      t.setRowHeight(this.rowHeight), t.setRowTop(this.rowHeight * t.rowIndex);
    });
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  destroyCache() {
    this.infiniteCache && (this.infiniteCache = this.destroyBean(this.infiniteCache));
  }
  onCacheUpdated() {
    const e = this.createModelUpdatedEvent();
    this.eventService.dispatchEvent(e);
  }
  getRow(e) {
    if (this.infiniteCache && !(e >= this.infiniteCache.getRowCount()))
      return this.infiniteCache.getRow(e);
  }
  getRowNode(e) {
    let t;
    return this.forEachNode((r) => {
      r.id === e && (t = r);
    }), t;
  }
  forEachNode(e) {
    this.infiniteCache && this.infiniteCache.forEachNodeDeep(e);
  }
  getTopLevelRowCount() {
    return this.getRowCount();
  }
  getTopLevelRowDisplayedIndex(e) {
    return e;
  }
  getRowIndexAtPixel(e) {
    if (this.rowHeight !== 0) {
      const t = Math.floor(e / this.rowHeight), r = this.getRowCount() - 1;
      return t > r ? r : t;
    }
    return 0;
  }
  getRowCount() {
    return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;
  }
  isRowPresent(e) {
    return !!this.getRowNode(e.id);
  }
  refreshCache() {
    this.infiniteCache && this.infiniteCache.refreshCache();
  }
  purgeCache() {
    this.infiniteCache && this.infiniteCache.purgeCache();
  }
  // for iRowModel
  isLastRowIndexKnown() {
    return this.infiniteCache ? this.infiniteCache.isLastRowIndexKnown() : !1;
  }
  setRowCount(e, t) {
    this.infiniteCache && this.infiniteCache.setRowCount(e, t);
  }
};
function W5e(e) {
  var t, r;
  (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null || r.refreshCache();
}
function j5e(e) {
  var t, r;
  (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null || r.purgeCache();
}
function U5e(e) {
  var t, r;
  return (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null ? void 0 : r.getRowCount();
}
function K5e(e) {
  var t, r;
  return (r = (t = e.rowModelHelperService) == null ? void 0 : t.getInfiniteRowModel()) == null ? void 0 : r.isLastRowIndexKnown();
}
var WA = "32.0.1", IY = {
  version: WA,
  moduleName: "@ag-grid-community/infinite-row-model-core",
  rowModel: "infinite",
  beans: [$5e],
  dependantModules: [KBe]
}, Y5e = {
  version: WA,
  moduleName: "@ag-grid-community/infinite-row-model-api",
  beans: [MY],
  apiFunctions: {
    refreshInfiniteCache: W5e,
    purgeInfiniteCache: j5e,
    getInfiniteRowCount: U5e,
    isLastRowIndexKnown: K5e
  },
  dependantModules: [IY, s5e]
}, q5e = {
  version: WA,
  moduleName: "@ag-grid-community/infinite-row-model",
  dependantModules: [IY, Y5e]
};
Xn.__registerModules(
  [EY, M5e, q5e, B5e],
  !1,
  void 0
);
var _i = H.createContext({}), Zv = (e, t, r, n) => {
  if (!e || e.componentFromFramework || t.isDestroyed())
    return;
  const o = e.newAgStackInstance();
  if (o == null)
    return;
  let a, s, l = !1;
  return o.then((u) => {
    if (l) {
      t.destroyBean(u);
      return;
    }
    a = u, s = a.getGui(), r.appendChild(s), YG(n, a);
  }), () => {
    l = !0, a && (s && s.parentElement && s.parentElement.removeChild(s), t.destroyBean(a), n && YG(n, void 0));
  };
}, YG = (e, t) => {
  if (e)
    if (e instanceof Function)
      e(t);
    else {
      const r = e;
      r.current = t;
    }
}, na = (...e) => e.filter((r) => r != null && r !== "").join(" "), Po = class FY {
  constructor(...t) {
    this.classesMap = {}, t.forEach((r) => {
      this.classesMap[r] = !0;
    });
  }
  setClass(t, r) {
    if (!!this.classesMap[t] == r)
      return this;
    const i = new FY();
    return i.classesMap = { ...this.classesMap }, i.classesMap[t] = r, i;
  }
  toString() {
    return Object.keys(this.classesMap).filter((r) => this.classesMap[r]).join(" ");
  }
}, Rf = (e) => {
  const t = () => typeof Symbol == "function" && Symbol.for, r = () => t() ? Symbol.for("react.memo") : 60115;
  return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === r();
}, LY = Ec.createRoot != null && Ec.flushSync != null;
function Z5e() {
  return !LY;
}
var C0 = !1;
function X5e(e) {
  return C0 || setTimeout(() => C0 = !1, 0), C0 = !0, e();
}
var jA = (e, t) => {
  LY && e && !C0 ? Ec.flushSync(t) : t();
};
function UA(e, t, r) {
  if (t == null || e == null)
    return t;
  if (e === t || t.length === 0 && e.length === 0)
    return e;
  if (r || e.length === 0 && t.length > 0 || e.length > 0 && t.length === 0)
    return t;
  const n = [], i = [], o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
  for (let s = 0; s < t.length; s++) {
    const l = t[s];
    a.set(l.getInstanceId(), l);
  }
  for (let s = 0; s < e.length; s++) {
    const l = e[s];
    o.set(l.getInstanceId(), l), a.has(l.getInstanceId()) && n.push(l);
  }
  for (let s = 0; s < t.length; s++) {
    const l = t[s], u = l.getInstanceId();
    o.has(u) || i.push(l);
  }
  return n.length === e.length && i.length === 0 ? e : n.length === 0 && i.length === t.length ? t : n.length === 0 ? i : i.length === 0 ? n : [...n, ...i];
}
var OY = fn((e, t) => {
  var N;
  const { ctrlsFactory: r, context: n } = rr(_i), i = le(null), o = le(null), a = le(null), s = le(null), l = le(null), u = le(), [c, d] = Ee(), [h, f] = Ee(), [p, g] = Ee(), [v, m] = Ee(() => new Po()), [y, C] = Ee(() => new Po("ag-hidden")), [S, b] = Ee(() => new Po("ag-hidden")), [w, x] = Ee(() => new Po("ag-invisible"));
  Nc(t, () => ({
    // force new instance when grid tries to refresh
    refresh() {
      return !1;
    }
  })), ja(() => Zv(c, n, o.current), [c]);
  const E = Wt((F) => {
    if (i.current = F, !i.current) {
      n.destroyBean(u.current), u.current = null;
      return;
    }
    const G = {
      setInnerRenderer: (V, z) => {
        d(V), g(z);
      },
      setChildCount: (V) => f(V),
      addOrRemoveCssClass: (V, z) => m((k) => k.setClass(V, z)),
      setContractedDisplayed: (V) => b((z) => z.setClass("ag-hidden", !V)),
      setExpandedDisplayed: (V) => C((z) => z.setClass("ag-hidden", !V)),
      setCheckboxVisible: (V) => x((z) => z.setClass("ag-invisible", !V))
    }, M = r.getInstance("groupCellRendererCtrl");
    M && (u.current = n.createBean(M), u.current.init(
      G,
      i.current,
      a.current,
      s.current,
      l.current,
      OY,
      e
    ));
  }, []), R = ct(() => `ag-cell-wrapper ${v.toString()}`, [v]), _ = ct(() => `ag-group-expanded ${y.toString()}`, [y]), P = ct(
    () => `ag-group-contracted ${S.toString()}`,
    [S]
  ), D = ct(() => `ag-group-checkbox ${w.toString()}`, [w]), I = c && c.componentFromFramework, A = I ? c.componentClass : void 0, O = c == null && p != null, L = Za(p, !0);
  return /* @__PURE__ */ H.createElement(
    "span",
    {
      className: R,
      ref: E,
      ...e.colDef ? {} : { role: (N = u.current) == null ? void 0 : N.getCellAriaRole() }
    },
    /* @__PURE__ */ H.createElement("span", { className: _, ref: s }),
    /* @__PURE__ */ H.createElement("span", { className: P, ref: l }),
    /* @__PURE__ */ H.createElement("span", { className: D, ref: a }),
    /* @__PURE__ */ H.createElement("span", { className: "ag-group-value", ref: o }, O && /* @__PURE__ */ H.createElement(H.Fragment, null, L), I && /* @__PURE__ */ H.createElement(A, { ...c.params })),
    /* @__PURE__ */ H.createElement("span", { className: "ag-group-child-count" }, h)
  );
}), qG = OY, KA = Xl({
  setMethods: () => {
  }
}), Q5e = (e) => {
  const { initialProps: t, addUpdateCallback: r, CustomComponentClass: n, setMethods: i } = e, [o, a] = Ee(t);
  return It(() => {
    r((s) => a(s));
  }, []), /* @__PURE__ */ H.createElement(KA.Provider, { value: { setMethods: i } }, /* @__PURE__ */ H.createElement(n, { ...o }));
}, J5e = Vi(Q5e), e8e = 0;
function ZG() {
  return `agPortalKey_${++e8e}`;
}
var NY = class {
  constructor(e, t, r, n) {
    this.portal = null, this.oldPortal = null, this.reactComponent = e, this.portalManager = t, this.componentType = r, this.suppressFallbackMethods = !!n, this.statelessComponent = this.isStateless(this.reactComponent), this.key = ZG(), this.portalKey = ZG(), this.instanceCreated = this.isStatelessComponent() ? en.resolve(!1) : new en((i) => {
      this.resolveInstanceCreated = i;
    });
  }
  getGui() {
    return this.eParentElement;
  }
  /** `getGui()` returns the parent element. This returns the actual root element. */
  getRootElement() {
    return this.eParentElement.firstChild;
  }
  destroy() {
    this.componentInstance && typeof this.componentInstance.destroy == "function" && this.componentInstance.destroy();
    const e = this.portal;
    e && this.portalManager.destroyPortal(e);
  }
  createParentElement(e) {
    const t = this.portalManager.getComponentWrappingElement(), r = document.createElement(t || "div");
    return r.classList.add("ag-react-container"), e.reactContainer = r, r;
  }
  addParentContainerStyleAndClasses() {
    this.componentInstance && (this.componentInstance.getReactContainerStyle && this.componentInstance.getReactContainerStyle() && (Se(
      'Since v31.1 "getReactContainerStyle" is deprecated. Apply styling directly to ".ag-react-container" if needed.'
    ), Object.assign(this.eParentElement.style, this.componentInstance.getReactContainerStyle())), this.componentInstance.getReactContainerClasses && this.componentInstance.getReactContainerClasses() && (Se(
      'Since v31.1 "getReactContainerClasses" is deprecated. Apply styling directly to ".ag-react-container" if needed.'
    ), this.componentInstance.getReactContainerClasses().forEach((t) => this.eParentElement.classList.add(t))));
  }
  statelessComponentRendered() {
    return this.eParentElement.childElementCount > 0 || this.eParentElement.childNodes.length > 0;
  }
  getFrameworkComponentInstance() {
    return this.componentInstance;
  }
  isStatelessComponent() {
    return this.statelessComponent;
  }
  getReactComponentName() {
    return this.reactComponent.name;
  }
  getMemoType() {
    return this.hasSymbol() ? Symbol.for("react.memo") : 60115;
  }
  hasSymbol() {
    return typeof Symbol == "function" && Symbol.for;
  }
  isStateless(e) {
    return typeof e == "function" && !(e.prototype && e.prototype.isReactComponent) || typeof e == "object" && e.$$typeof === this.getMemoType();
  }
  hasMethod(e) {
    const t = this.getFrameworkComponentInstance();
    return !!t && t[e] != null || this.fallbackMethodAvailable(e);
  }
  callMethod(e, t) {
    const r = this.getFrameworkComponentInstance();
    if (this.isStatelessComponent())
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
    if (!r) {
      setTimeout(() => this.callMethod(e, t));
      return;
    }
    const n = r[e];
    if (n)
      return n.apply(r, t);
    if (this.fallbackMethodAvailable(e))
      return this.fallbackMethod(e, t && t[0] ? t[0] : {});
  }
  addMethod(e, t) {
    this[e] = t;
  }
  init(e) {
    return this.eParentElement = this.createParentElement(e), this.params = e, this.createOrUpdatePortal(e), new en((t) => this.createReactComponent(t));
  }
  createOrUpdatePortal(e) {
    this.isStatelessComponent() || (this.ref = (t) => {
      var r;
      this.componentInstance = t, this.addParentContainerStyleAndClasses(), (r = this.resolveInstanceCreated) == null || r.call(this, !0), this.resolveInstanceCreated = void 0;
    }, e.ref = this.ref), this.reactElement = this.createElement(this.reactComponent, { ...e, key: this.key }), this.portal = kT(
      this.reactElement,
      this.eParentElement,
      this.portalKey
      // fixed deltaRowModeRefreshCompRenderer
    );
  }
  createElement(e, t) {
    return uH(e, t);
  }
  createReactComponent(e) {
    this.portalManager.mountReactPortal(this.portal, this, e);
  }
  rendered() {
    return this.isStatelessComponent() && this.statelessComponentRendered() || !!(!this.isStatelessComponent() && this.getFrameworkComponentInstance());
  }
  /*
   * fallback methods - these will be invoked if a corresponding instance method is not present
   * for example if refresh is called and is not available on the component instance, then refreshComponent on this
   * class will be invoked instead
   *
   * Currently only refresh is supported
   */
  refreshComponent(e) {
    this.oldPortal = this.portal, this.createOrUpdatePortal(e), this.portalManager.updateReactPortal(this.oldPortal, this.portal);
  }
  fallbackMethod(e, t) {
    const r = this[`${e}Component`];
    if (!this.suppressFallbackMethods && r)
      return r.bind(this)(t);
  }
  fallbackMethodAvailable(e) {
    return this.suppressFallbackMethods ? !1 : !!this[`${e}Component`];
  }
};
function YA(e, t, r) {
  e.forEach((n) => {
    const i = t[n];
    i && (r[n] = i);
  });
}
var tl = class extends NY {
  constructor() {
    super(...arguments), this.awaitUpdateCallback = new en((e) => {
      this.resolveUpdateCallback = e;
    }), this.wrapperComponent = J5e;
  }
  init(e) {
    return this.sourceParams = e, super.init(this.getProps());
  }
  addMethod() {
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  getFrameworkComponentInstance() {
    return this;
  }
  createElement(e, t) {
    return super.createElement(this.wrapperComponent, {
      initialProps: t,
      CustomComponentClass: e,
      setMethods: (r) => this.setMethods(r),
      addUpdateCallback: (r) => {
        this.updateCallback = () => (r(this.getProps()), new en((n) => {
          setTimeout(() => {
            n();
          });
        })), this.resolveUpdateCallback();
      }
    });
  }
  setMethods(e) {
    this.providedMethods = e, YA(this.getOptionalMethods(), this.providedMethods, this);
  }
  getOptionalMethods() {
    return [];
  }
  getProps() {
    return {
      ...this.sourceParams,
      key: this.key,
      ref: this.ref
    };
  }
  refreshProps() {
    return this.updateCallback ? this.updateCallback() : new en(
      (e) => this.awaitUpdateCallback.then(() => {
        this.updateCallback().then(() => e());
      })
    );
  }
}, t8e = class extends tl {
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
}, r8e = class extends tl {
  constructor() {
    super(...arguments), this.date = null, this.onDateChange = (e) => this.updateDate(e);
  }
  getDate() {
    return this.date;
  }
  setDate(e) {
    this.date = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "setInputPlaceholder", "setInputAriaLabel", "setDisabled"];
  }
  updateDate(e) {
    this.setDate(e), this.sourceParams.onDateChanged();
  }
  getProps() {
    const e = super.getProps();
    return e.date = this.date, e.onDateChange = this.onDateChange, delete e.onDateChanged, e;
  }
}, n8e = class extends tl {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e), this.onUiChange = () => this.sourceParams.filterChangedCallback(), this.expectingNewMethods = !0;
  }
  isFilterActive() {
    return this.model != null;
  }
  doesFilterPass(e) {
    return this.providedMethods.doesFilterPass(e);
  }
  getModel() {
    return this.model;
  }
  setModel(e) {
    return this.expectingNewMethods = !0, this.model = e, this.refreshProps();
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
  getOptionalMethods() {
    return ["afterGuiAttached", "afterGuiDetached", "onNewRowsLoaded", "getModelAsString", "onAnyFilterChanged"];
  }
  setMethods(e) {
    var t;
    this.expectingNewMethods === !1 && ((t = this.providedMethods) == null ? void 0 : t.doesFilterPass) !== (e == null ? void 0 : e.doesFilterPass) && setTimeout(() => {
      this.sourceParams.filterChangedCallback();
    }), this.expectingNewMethods = !1, super.setMethods(e);
  }
  updateModel(e) {
    this.setModel(e).then(() => this.sourceParams.filterChangedCallback());
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e.onUiChange = this.onUiChange, delete e.filterChangedCallback, delete e.filterModifiedCallback, delete e.valueGetter, e;
  }
};
function kY(e, t) {
  e.parentFilterInstance((r) => {
    (r.setModel(t) || en.resolve()).then(() => {
      e.filterParams.filterChangedCallback();
    });
  });
}
var i8e = class {
  constructor(e, t) {
    this.floatingFilterParams = e, this.refreshProps = t, this.model = null, this.onModelChange = (r) => this.updateModel(r);
  }
  getProps() {
    return {
      ...this.floatingFilterParams,
      model: this.model,
      onModelChange: this.onModelChange
    };
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.floatingFilterParams = e, this.refreshProps();
  }
  setMethods(e) {
    YA(this.getOptionalMethods(), e, this);
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), kY(this.floatingFilterParams, e);
  }
}, o8e = class extends tl {
  constructor() {
    super(...arguments), this.model = null, this.onModelChange = (e) => this.updateModel(e);
  }
  onParentModelChanged(e) {
    this.model = e, this.refreshProps();
  }
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["afterGuiAttached"];
  }
  updateModel(e) {
    this.model = e, this.refreshProps(), kY(this.sourceParams, e);
  }
  getProps() {
    const e = super.getProps();
    return e.model = this.model, e.onModelChange = this.onModelChange, e;
  }
}, a8e = class extends tl {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, s8e = class extends tl {
  constructor() {
    super(...arguments), this.active = !1, this.expanded = !1, this.onActiveChange = (e) => this.updateActive(e);
  }
  setActive(e) {
    this.awaitSetActive(e);
  }
  setExpanded(e) {
    this.expanded = e, this.refreshProps();
  }
  getOptionalMethods() {
    return ["select", "configureDefaults"];
  }
  awaitSetActive(e) {
    return this.active = e, this.refreshProps();
  }
  updateActive(e) {
    const t = this.awaitSetActive(e);
    e && t.then(() => this.sourceParams.onItemActivated());
  }
  getProps() {
    const e = super.getProps();
    return e.active = this.active, e.expanded = this.expanded, e.onActiveChange = this.onActiveChange, delete e.onItemActivated, e;
  }
}, l8e = class extends tl {
  refresh(e) {
    this.sourceParams = e, this.refreshProps();
  }
}, u8e = class extends tl {
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
}, c8e = class extends tl {
  constructor() {
    super(...arguments), this.onStateChange = (e) => this.updateState(e);
  }
  refresh(e) {
    return this.sourceParams = e, this.refreshProps(), !0;
  }
  getState() {
    return this.state;
  }
  updateState(e) {
    this.state = e, this.refreshProps(), this.sourceParams.onStateUpdated();
  }
  getProps() {
    const e = super.getProps();
    return e.state = this.state, e.onStateChange = this.onStateChange, e;
  }
};
function qA() {
  Se("As of v32, using custom components with `reactiveCustomComponents = false` is deprecated.");
}
var d8e = 1e3, h8e = class {
  constructor(e, t, r) {
    this.destroyed = !1, this.portals = [], this.hasPendingPortalUpdate = !1, this.wrappingElement = t || "div", this.refresher = e, this.maxComponentCreationTimeMs = r || d8e;
  }
  getPortals() {
    return this.portals;
  }
  destroy() {
    this.destroyed = !0;
  }
  destroyPortal(e) {
    this.portals = this.portals.filter((t) => t !== e), this.batchUpdate();
  }
  getComponentWrappingElement() {
    return this.wrappingElement;
  }
  mountReactPortal(e, t, r) {
    this.portals = [...this.portals, e], this.waitForInstance(t, r), this.batchUpdate();
  }
  updateReactPortal(e, t) {
    this.portals[this.portals.indexOf(e)] = t, this.batchUpdate();
  }
  batchUpdate() {
    this.hasPendingPortalUpdate || (setTimeout(() => {
      this.destroyed || (this.refresher(), this.hasPendingPortalUpdate = !1);
    }), this.hasPendingPortalUpdate = !0);
  }
  waitForInstance(e, t, r = Date.now()) {
    if (this.destroyed) {
      t(null);
      return;
    }
    if (e.rendered())
      t(e);
    else {
      if (Date.now() - r >= this.maxComponentCreationTimeMs && !this.hasPendingPortalUpdate)
        return;
      window.setTimeout(() => {
        this.waitForInstance(e, t, r);
      });
    }
  }
}, f8e = (e) => {
  const { ctrl: t } = e, r = t.isAlive(), { context: n } = rr(_i), i = r ? t.getColId() : void 0, [o, a] = Ee(), s = le(null), l = le(null), u = le(null), c = le(), d = le();
  r && !d.current && (d.current = new Kv(() => s.current));
  const h = Wt((v) => {
    var C;
    if (s.current = v, !s.current || !r)
      return;
    const m = {
      setWidth: (S) => {
        s.current && (s.current.style.width = S);
      },
      addOrRemoveCssClass: (S, b) => d.current.addOrRemoveCssClass(S, b),
      setAriaSort: (S) => {
        s.current && (S ? COe(s.current, S) : SOe(s.current));
      },
      setUserCompDetails: (S) => a(S),
      getUserCompInstance: () => c.current || void 0
    };
    t.setComp(m, s.current, l.current, u.current);
    const y = t.getSelectAllGui();
    (C = l.current) == null || C.insertAdjacentElement("afterend", y);
  }, []);
  ja(
    () => Zv(o, n, u.current, c),
    [o]
  ), It(() => {
    t.setDragSource(s.current);
  }, [o]);
  const f = ct(() => !!((o == null ? void 0 : o.componentFromFramework) && Rf(o.componentClass)), [o]), p = o && o.componentFromFramework, g = o && o.componentClass;
  return /* @__PURE__ */ H.createElement("div", { ref: h, className: "ag-header-cell", "col-id": i, role: "columnheader" }, /* @__PURE__ */ H.createElement("div", { ref: l, className: "ag-header-cell-resize", role: "presentation" }), /* @__PURE__ */ H.createElement("div", { ref: u, className: "ag-header-cell-comp-wrapper", role: "presentation" }, p && f && /* @__PURE__ */ H.createElement(g, { ...o.params }), p && !f && /* @__PURE__ */ H.createElement(g, { ...o.params, ref: c })));
}, p8e = Vi(f8e), g8e = (e) => {
  const { context: t, gos: r } = rr(_i), [n, i] = Ee(
    () => new Po("ag-header-cell", "ag-floating-filter")
  ), [o, a] = Ee(() => new Po()), [s, l] = Ee(
    () => new Po("ag-floating-filter-button", "ag-hidden")
  ), [u, c] = Ee("false"), [d, h] = Ee(), [, f] = Ee(1), p = le(null), g = le(null), v = le(null), m = le(null), y = le(), C = le(), S = (L) => {
    L != null && y.current && y.current(L);
  }, { ctrl: b } = e, w = Wt((L) => {
    if (p.current = L, !p.current)
      return;
    C.current = new en((F) => {
      y.current = F;
    });
    const N = {
      addOrRemoveCssClass: (F, G) => i((M) => M.setClass(F, G)),
      addOrRemoveBodyCssClass: (F, G) => a((M) => M.setClass(F, G)),
      setButtonWrapperDisplayed: (F) => {
        l((G) => G.setClass("ag-hidden", !F)), c(F ? "false" : "true");
      },
      setWidth: (F) => {
        p.current && (p.current.style.width = F);
      },
      setCompDetails: (F) => h(F),
      getFloatingFilterComp: () => C.current ? C.current : null,
      setMenuIcon: (F) => {
        var G;
        return (G = m.current) == null ? void 0 : G.appendChild(F);
      }
    };
    b.setComp(N, p.current, m.current, g.current);
  }, []);
  ja(
    () => Zv(d, t, g.current, S),
    [d]
  );
  const x = ct(() => n.toString(), [n]), E = ct(() => o.toString(), [o]), R = ct(() => s.toString(), [s]), _ = ct(() => !!(d && d.componentFromFramework && Rf(d.componentClass)), [d]), P = ct(() => r.get("reactiveCustomComponents"), []), D = ct(() => {
    if (d)
      if (P) {
        const L = new i8e(
          d.params,
          () => f((N) => N + 1)
        );
        return S(L), L;
      } else d.componentFromFramework && qA();
  }, [d]), I = D == null ? void 0 : D.getProps(), A = d && d.componentFromFramework, O = d && d.componentClass;
  return /* @__PURE__ */ H.createElement("div", { ref: w, className: x, role: "gridcell" }, /* @__PURE__ */ H.createElement("div", { ref: g, className: E, role: "presentation" }, A && !P && /* @__PURE__ */ H.createElement(O, { ...d.params, ref: _ ? () => {
  } : S }), A && P && /* @__PURE__ */ H.createElement(
    KA.Provider,
    {
      value: {
        setMethods: (L) => D.setMethods(L)
      }
    },
    /* @__PURE__ */ H.createElement(O, { ...I })
  )), /* @__PURE__ */ H.createElement(
    "div",
    {
      ref: v,
      "aria-hidden": u,
      className: R,
      role: "presentation"
    },
    /* @__PURE__ */ H.createElement(
      "button",
      {
        ref: m,
        type: "button",
        className: "ag-button ag-floating-filter-button-button",
        tabIndex: -1
      }
    )
  ));
}, v8e = Vi(g8e), m8e = (e) => {
  const { context: t } = rr(_i), { ctrl: r } = e, [n, i] = Ee(() => new Po()), [o, a] = Ee(() => new Po()), [s, l] = Ee("false"), [u, c] = Ee(), [d, h] = Ee(), f = ct(() => r.getColId(), []), p = le(null), g = le(null), v = le(), m = Wt((x) => {
    if (p.current = x, !p.current)
      return;
    const E = {
      setWidth: (R) => {
        p.current && (p.current.style.width = R);
      },
      addOrRemoveCssClass: (R, _) => i((P) => P.setClass(R, _)),
      setUserCompDetails: (R) => h(R),
      setResizableDisplayed: (R) => {
        a((_) => _.setClass("ag-hidden", !R)), l(R ? "false" : "true");
      },
      setAriaExpanded: (R) => c(R),
      getUserCompInstance: () => v.current || void 0
    };
    r.setComp(E, p.current, g.current);
  }, []);
  ja(() => Zv(d, t, p.current), [d]), It(() => {
    p.current && r.setDragSource(p.current);
  }, [d]);
  const y = ct(() => !!((d == null ? void 0 : d.componentFromFramework) && Rf(d.componentClass)), [d]), C = ct(() => "ag-header-group-cell " + n.toString(), [n]), S = ct(
    () => "ag-header-cell-resize " + o.toString(),
    [o]
  ), b = d && d.componentFromFramework, w = d && d.componentClass;
  return /* @__PURE__ */ H.createElement("div", { ref: m, className: C, "col-id": f, role: "columnheader", "aria-expanded": u }, b && y && /* @__PURE__ */ H.createElement(w, { ...d.params }), b && !y && /* @__PURE__ */ H.createElement(w, { ...d.params, ref: v }), /* @__PURE__ */ H.createElement("div", { ref: g, "aria-hidden": s, className: S }));
}, y8e = Vi(m8e), C8e = (e) => {
  const { ctrl: t } = e, { topOffset: r, rowHeight: n } = ct(() => t.getTopAndHeight(), []), i = t.getAriaRowIndex(), o = t.getHeaderRowClass(), [a, s] = Ee(() => n + "px"), [l, u] = Ee(() => r + "px"), c = le(null), d = le(null), [h, f] = Ee(() => t.getHeaderCtrls()), p = le(null), g = Wt((y) => {
    if (p.current = y, !y)
      return;
    const C = {
      setHeight: (S) => s(S),
      setTop: (S) => u(S),
      setHeaderCtrls: (S, b, w) => {
        d.current = c.current, c.current = S;
        const x = UA(d.current, S, b);
        x !== d.current && jA(w, () => f(x));
      },
      setWidth: (S) => {
        p.current && (p.current.style.width = S);
      }
    };
    t.setComp(C, !1);
  }, []), v = ct(
    () => ({
      height: a,
      top: l
    }),
    [a, l]
  ), m = Wt((y) => {
    switch (t.getType()) {
      case IT.COLUMN_GROUP:
        return /* @__PURE__ */ H.createElement(y8e, { ctrl: y, key: y.getInstanceId() });
      case IT.FLOATING_FILTER:
        return /* @__PURE__ */ H.createElement(v8e, { ctrl: y, key: y.getInstanceId() });
      default:
        return /* @__PURE__ */ H.createElement(p8e, { ctrl: y, key: y.getInstanceId() });
    }
  }, []);
  return /* @__PURE__ */ H.createElement("div", { ref: g, className: o, role: "row", style: v, "aria-rowindex": i }, h.map(m));
}, S8e = Vi(C8e), w8e = (e) => {
  const [t, r] = Ee(!0), [n, i] = Ee([]), { context: o } = rr(_i), a = le(null), s = le(null), l = le(null), u = e.pinned === "left", c = e.pinned === "right", d = !u && !c, h = Wt((g) => {
    if (a.current = g, !a.current) {
      o.destroyBean(l.current), l.current = null;
      return;
    }
    const v = {
      setDisplayed: r,
      setCtrls: (m) => i(m),
      // centre only
      setCenterWidth: (m) => {
        s.current && (s.current.style.width = m);
      },
      setViewportScrollLeft: (m) => {
        a.current && (a.current.scrollLeft = m);
      },
      // pinned only
      setPinnedContainerWidth: (m) => {
        a.current && (a.current.style.width = m, a.current.style.minWidth = m, a.current.style.maxWidth = m);
      }
    };
    l.current = o.createBean(new Zke(e.pinned)), l.current.setComp(v, a.current);
  }, []), f = t ? "" : "ag-hidden", p = () => n.map((g) => /* @__PURE__ */ H.createElement(S8e, { ctrl: g, key: g.getInstanceId() }));
  return /* @__PURE__ */ H.createElement(H.Fragment, null, u && /* @__PURE__ */ H.createElement(
    "div",
    {
      ref: h,
      className: "ag-pinned-left-header " + f,
      "aria-hidden": !t,
      role: "rowgroup"
    },
    p()
  ), c && /* @__PURE__ */ H.createElement(
    "div",
    {
      ref: h,
      className: "ag-pinned-right-header " + f,
      "aria-hidden": !t,
      role: "rowgroup"
    },
    p()
  ), d && /* @__PURE__ */ H.createElement("div", { ref: h, className: "ag-header-viewport " + f, role: "presentation" }, /* @__PURE__ */ H.createElement("div", { ref: s, className: "ag-header-container", role: "rowgroup" }, p())));
}, iE = Vi(w8e), b8e = () => {
  const [e, t] = Ee(() => new Po()), [r, n] = Ee(), { context: i } = rr(_i), o = le(null), a = le(null), s = Wt((c) => {
    if (o.current = c, !c) {
      i.destroyBean(a.current), a.current = null;
      return;
    }
    const d = {
      addOrRemoveCssClass: (h, f) => t((p) => p.setClass(h, f)),
      setHeightAndMinHeight: (h) => n(h)
    };
    a.current = i.createBean(new Oke()), a.current.setComp(d, o.current, o.current);
  }, []), l = ct(() => "ag-header " + e.toString(), [e]), u = ct(
    () => ({
      height: r,
      minHeight: r
    }),
    [r]
  );
  return /* @__PURE__ */ H.createElement("div", { ref: s, className: l, style: u, role: "presentation" }, /* @__PURE__ */ H.createElement(iE, { pinned: "left" }), /* @__PURE__ */ H.createElement(iE, { pinned: null }), /* @__PURE__ */ H.createElement(iE, { pinned: "right" }));
}, x8e = Vi(b8e), E8e = (e, t) => {
  It(() => {
    const r = t.current;
    if (r) {
      const n = r.parentElement;
      if (n) {
        const i = document.createComment(e);
        return n.insertBefore(i, r), () => {
          n.removeChild(i);
        };
      }
    }
  }, [e]);
}, Xu = E8e, R8e = class {
  constructor(e, t) {
    this.cellEditorParams = e, this.refreshProps = t, this.instanceCreated = new en((r) => {
      this.resolveInstanceCreated = r;
    }), this.onValueChange = (r) => this.updateValue(r), this.value = e.value;
  }
  getProps() {
    return {
      ...this.cellEditorParams,
      initialValue: this.cellEditorParams.value,
      value: this.value,
      onValueChange: this.onValueChange
    };
  }
  getValue() {
    return this.value;
  }
  refresh(e) {
    this.cellEditorParams = e, this.refreshProps();
  }
  setMethods(e) {
    YA(this.getOptionalMethods(), e, this);
  }
  getInstance() {
    return this.instanceCreated.then(() => this.componentInstance);
  }
  setRef(e) {
    var t;
    this.componentInstance = e, (t = this.resolveInstanceCreated) == null || t.call(this), this.resolveInstanceCreated = void 0;
  }
  getOptionalMethods() {
    return ["isCancelBeforeStart", "isCancelAfterEnd", "focusIn", "focusOut", "afterGuiAttached"];
  }
  updateValue(e) {
    this.value = e, this.refreshProps();
  }
}, _8e = (e) => {
  const t = le(e), r = le(), n = le(!1), i = le(!1), [, o] = Ee(0);
  n.current && (i.current = !0), It(() => (n.current || (r.current = t.current(), n.current = !0), o((a) => a + 1), () => {
    i.current && r.current && r.current();
  }), []);
}, T8e = (e) => {
  const [t, r] = Ee(), { context: n, popupService: i, localeService: o, gos: a, editService: s } = rr(_i);
  return _8e(() => {
    const { editDetails: l, cellCtrl: u, eParentCell: c } = e, { compDetails: d } = l, h = a.get("stopEditingWhenCellsLoseFocus"), f = n.createBean(s.createPopupEditorWrapper(d.params)), p = f.getGui();
    if (e.jsChildComp) {
      const S = e.jsChildComp.getGui();
      S && p.appendChild(S);
    }
    const g = {
      column: u.getColumn(),
      rowNode: u.getRowNode(),
      type: "popupCellEditor",
      eventSource: c,
      ePopup: p,
      position: l.popupPosition,
      keepWithinBounds: !0
    }, v = i.positionPopupByComponent.bind(i, g), m = o.getLocaleTextFunc(), y = i.addPopup({
      modal: h,
      eChild: p,
      closeOnEsc: !0,
      closedCallback: () => {
        u.onPopupEditorClosed();
      },
      anchorToElement: c,
      positionCallback: v,
      ariaLabel: m("ariaLabelCellEditor", "Cell Editor")
    }), C = y ? y.hideFunc : void 0;
    return r(f), e.jsChildComp && e.jsChildComp.afterGuiAttached && e.jsChildComp.afterGuiAttached(), () => {
      C != null && C(), n.destroyBean(f);
    };
  }), /* @__PURE__ */ H.createElement(H.Fragment, null, t && e.wrappedContent && kT(e.wrappedContent, t.getGui()));
}, XG = Vi(T8e), P8e = (e, t, r, n, i, o) => {
  const { context: a } = rr(_i), s = Wt(() => {
    const l = i.current;
    if (!l)
      return;
    const u = l.getGui();
    u && u.parentElement && u.parentElement.removeChild(u), a.destroyBean(l), i.current = void 0;
  }, []);
  It(() => {
    const l = e != null, u = e && e.compDetails && !e.compDetails.componentFromFramework, c = t && r == null;
    if (!(l && u && !c)) {
      s();
      return;
    }
    const h = e.compDetails;
    if (i.current) {
      const p = i.current, v = p.refresh != null && e.force == !1 ? p.refresh(h.params) : !1;
      if (v === !0 || v === void 0)
        return;
      s();
    }
    const f = h.newAgStackInstance();
    f != null && f.then((p) => {
      if (!p)
        return;
      const g = p.getGui();
      if (!g)
        return;
      (t ? r : o.current).appendChild(g), i.current = p;
    });
  }, [e, t, n]), It(() => s, []);
}, M8e = P8e, D8e = (e, t, r) => {
  const { compProxy: n } = e;
  r(n);
  const i = n.getProps(), o = Rf(t);
  return /* @__PURE__ */ H.createElement(
    KA.Provider,
    {
      value: {
        setMethods: (a) => n.setMethods(a)
      }
    },
    o && /* @__PURE__ */ H.createElement(t, { ...i }),
    !o && /* @__PURE__ */ H.createElement(t, { ...i, ref: (a) => n.setRef(a) })
  );
}, QG = (e, t, r) => {
  const n = e.compProxy;
  return /* @__PURE__ */ H.createElement(H.Fragment, null, !n && /* @__PURE__ */ H.createElement(t, { ...e.compDetails.params, ref: r }), n && D8e(e, t, r));
}, A8e = (e, t, r, n, i, o) => {
  const a = e.compDetails, s = a.componentClass, l = a.componentFromFramework && !e.popup, u = a.componentFromFramework && e.popup, c = !a.componentFromFramework && e.popup;
  return /* @__PURE__ */ H.createElement(H.Fragment, null, l && QG(e, s, t), u && /* @__PURE__ */ H.createElement(
    XG,
    {
      editDetails: e,
      cellCtrl: i,
      eParentCell: n,
      wrappedContent: QG(e, s, r)
    }
  ), c && o && /* @__PURE__ */ H.createElement(
    XG,
    {
      editDetails: e,
      cellCtrl: i,
      eParentCell: n,
      jsChildComp: o
    }
  ));
}, I8e = (e, t, r, n, i, o, a) => {
  const { compDetails: s, value: l } = e, u = !s, c = s && s.componentFromFramework, d = s && s.componentClass, h = l != null && l.toString ? l.toString() : l, f = () => /* @__PURE__ */ H.createElement(H.Fragment, null, u && /* @__PURE__ */ H.createElement(H.Fragment, null, h), c && !o && /* @__PURE__ */ H.createElement(d, { ...s.params, key: t, ref: n }), c && o && /* @__PURE__ */ H.createElement(d, { ...s.params, key: t }));
  return /* @__PURE__ */ H.createElement(H.Fragment, null, i ? /* @__PURE__ */ H.createElement("span", { role: "presentation", id: `cell-${r}`, className: "ag-cell-value", ref: a }, f()) : f());
}, F8e = (e) => {
  const { context: t } = rr(_i), { cellCtrl: r, printLayout: n, editingRow: i } = e, o = r.getTabIndex(), a = r.getColumnIdSanitised(), s = r.getInstanceId(), [l, u] = Ee(
    () => r.isCellRenderer() ? void 0 : { compDetails: void 0, value: r.getValueToDisplay(), force: !1 }
  ), [c, d] = Ee(), [h, f] = Ee(1), [p, g] = Ee(), [v, m] = Ee(!1), [y, C] = Ee(!1), [S, b] = Ee(!1), [w, x] = Ee(), E = ct(() => r.isForceWrapper(), [r]), R = ct(() => r.getCellAriaRole(), [r]), _ = le(null), P = le(null), D = le(), I = le(), A = le(), O = le([]), L = le(), [N, F] = Ee(0), G = Wt((X) => {
    L.current = X, F((Y) => Y + 1);
  }, []), M = l != null && (v || S || y), V = E || M, z = Wt(
    (X, Y) => {
      I.current = Y, Y && Y.isCancelBeforeStart && Y.isCancelBeforeStart() && setTimeout(() => {
        r.stopEditing(!0), r.focusCell(!0);
      });
    },
    [r]
  ), k = Wt(
    (X) => z(!0, X),
    [z]
  ), $ = Wt(
    (X) => z(!1, X),
    [z]
  ), W = le();
  W.current || (W.current = new Kv(() => _.current)), M8e(l, V, L.current, N, D, _);
  const j = le();
  ja(() => {
    const X = j.current, Y = l;
    if (j.current = l, X == null || X.compDetails == null || Y == null || Y.compDetails == null)
      return;
    const de = X.compDetails, K = Y.compDetails;
    if (de.componentClass != K.componentClass || P.current == null || P.current.refresh == null)
      return;
    P.current.refresh(K.params) != !0 && f((Ce) => Ce + 1);
  }, [l]), ja(() => {
    if (!(c && !c.compDetails.componentFromFramework))
      return;
    const Y = c.compDetails, de = c.popup === !0, K = Y.newAgStackInstance();
    return K.then((ie) => {
      if (!ie)
        return;
      const Ce = ie.getGui();
      if (z(de, ie), !de) {
        const Te = (E ? A : _).current;
        Te == null || Te.appendChild(Ce), ie.afterGuiAttached && ie.afterGuiAttached();
      }
      x(ie);
    }), () => {
      K.then((ie) => {
        const Ce = ie.getGui();
        t.destroyBean(ie), z(de, void 0), x(void 0), Ce && Ce.parentElement && Ce.parentElement.removeChild(Ce);
      });
    };
  }, [c]);
  const U = Wt(
    (X) => {
      if (A.current = X, !A.current) {
        O.current.forEach((de) => de()), O.current = [];
        return;
      }
      const Y = (de) => {
        var K;
        if (de) {
          const ie = de.getGui();
          (K = A.current) == null || K.insertAdjacentElement("afterbegin", ie), O.current.push(() => {
            t.destroyBean(de), Oc(ie);
          });
        }
        return de;
      };
      if (v) {
        const de = r.createSelectionCheckbox();
        Y(de);
      }
      S && Y(r.createDndSource()), y && Y(r.createRowDragComp());
    },
    [r, t, S, y, v]
  ), Z = Wt((X) => {
    if (_.current = X, !_.current || !r)
      return;
    const Y = {
      addOrRemoveCssClass: (K, ie) => W.current.addOrRemoveCssClass(K, ie),
      setUserStyles: (K) => g(K),
      getFocusableElement: () => _.current,
      setIncludeSelection: (K) => m(K),
      setIncludeRowDrag: (K) => C(K),
      setIncludeDndSource: (K) => b(K),
      getCellEditor: () => I.current || null,
      getCellRenderer: () => P.current ? P.current : D.current,
      getParentOfValue: () => L.current ? L.current : A.current ? A.current : _.current,
      setRenderDetails: (K, ie, Ce) => {
        u((Te) => (Te == null ? void 0 : Te.compDetails) !== K || (Te == null ? void 0 : Te.value) !== ie || (Te == null ? void 0 : Te.force) !== Ce ? {
          value: ie,
          compDetails: K,
          force: Ce
        } : Te);
      },
      setEditDetails: (K, ie, Ce, Te) => {
        if (K) {
          let Ie;
          Te ? Ie = new R8e(
            K.params,
            () => f((we) => we + 1)
          ) : K.componentFromFramework && qA(), d({
            compDetails: K,
            popup: ie,
            popupPosition: Ce,
            compProxy: Ie
          }), ie || u(void 0);
        } else
          d((Ie) => {
            Ie != null && Ie.compProxy && (I.current = void 0);
          });
      }
    }, de = A.current || void 0;
    r.setComp(Y, _.current, de, n, i);
  }, []), ee = ct(() => !!(l && l.compDetails && l.compDetails.componentFromFramework && Rf(l.compDetails.componentClass)), [l]);
  ja(() => {
    var X;
    _.current && (W.current.addOrRemoveCssClass("ag-cell-value", !V), W.current.addOrRemoveCssClass("ag-cell-inline-editing", !!c && !c.popup), W.current.addOrRemoveCssClass("ag-cell-popup-editing", !!c && !!c.popup), W.current.addOrRemoveCssClass("ag-cell-not-inline-editing", !c || !!c.popup), (X = r.getRowCtrl()) == null || X.setInlineEditingCss(!!c), r.shouldRestoreFocus() && !r.isEditing() && _.current.focus({ preventScroll: !0 }));
  });
  const J = () => /* @__PURE__ */ H.createElement(H.Fragment, null, l != null && I8e(
    l,
    h,
    s,
    P,
    V,
    ee,
    G
  ), c != null && A8e(
    c,
    $,
    k,
    _.current,
    r,
    w
  ));
  return /* @__PURE__ */ H.createElement("div", { ref: Z, style: p, tabIndex: o, role: R, "col-id": a }, V ? /* @__PURE__ */ H.createElement("div", { className: "ag-cell-wrapper", role: "presentation", ref: U }, J()) : J());
}, L8e = Vi(F8e), O8e = (e) => {
  const { context: t, gos: r } = rr(_i), { rowCtrl: n, containerType: i } = e, o = n.getTabIndex(), a = le(n.getDomOrder()), s = n.isFullWidth(), l = n.getRowNode().displayed, [u, c] = Ee(() => l ? n.getRowIndex() : null), [d, h] = Ee(() => n.getRowId()), [f, p] = Ee(() => n.getBusinessKey()), [g, v] = Ee(() => n.getRowStyles()), m = le(null), y = le(null), [C, S] = Ee(() => null), [b, w] = Ee(), [x, E] = Ee(
    () => l ? n.getInitialRowTop(i) : void 0
  ), [R, _] = Ee(
    () => l ? n.getInitialTransform(i) : void 0
  ), P = le(null), D = le(), I = le(!1), [A, O] = Ee(0);
  It(() => {
    var j;
    if (I.current || !b || A > 10)
      return;
    const W = (j = P.current) == null ? void 0 : j.firstChild;
    W ? (n.setupDetailRowAutoHeight(W), I.current = !0) : O((U) => U + 1);
  }, [b, A]);
  const L = le();
  L.current || (L.current = new Kv(() => P.current));
  const N = Wt((W) => {
    if (P.current = W, !P.current) {
      n.unsetComp(i);
      return;
    }
    if (!n.isAlive())
      return;
    const j = {
      // the rowTop is managed by state, instead of direct style manipulation by rowCtrl (like all the other styles)
      // as we need to have an initial value when it's placed into he DOM for the first time, for animation to work.
      setTop: E,
      setTransform: _,
      // i found using React for managing classes at the row level was to slow, as modifying classes caused a lot of
      // React code to execute, so avoiding React for managing CSS Classes made the grid go much faster.
      addOrRemoveCssClass: (U, Z) => L.current.addOrRemoveCssClass(U, Z),
      setDomOrder: (U) => a.current = U,
      setRowIndex: c,
      setRowId: h,
      setRowBusinessKey: p,
      setUserStyles: v,
      // if we don't maintain the order, then cols will be ripped out and into the dom
      // when cols reordered, which would stop the CSS transitions from working
      setCellCtrls: (U, Z) => {
        y.current = m.current, m.current = U;
        const ee = UA(y.current, U, a.current);
        ee !== y.current && jA(Z, () => S(ee));
      },
      showFullWidth: (U) => w(U),
      getFullWidthCellRenderer: () => D.current,
      refreshFullWidth: (U) => z.current ? (w((Z) => ({
        ...Z,
        params: U()
      })), !0) : !D.current || !D.current.refresh ? !1 : D.current.refresh(U())
    };
    n.setComp(j, P.current, i);
  }, []);
  ja(
    () => Zv(b, t, P.current, D),
    [b]
  );
  const F = ct(() => {
    const W = { top: x, transform: R };
    return Object.assign(W, g), W;
  }, [x, R, g]), G = s && b && b.componentFromFramework, M = !s && C != null, V = ct(() => !!((b == null ? void 0 : b.componentFromFramework) && Rf(b.componentClass)), [b]), z = le(!1);
  It(() => {
    z.current = V && !!b && !!r.get("reactiveCustomComponents");
  }, [V, b]);
  const k = () => C == null ? void 0 : C.map((W) => /* @__PURE__ */ H.createElement(
    L8e,
    {
      cellCtrl: W,
      editingRow: n.isEditing(),
      printLayout: n.isPrintLayout(),
      key: W.getInstanceId()
    }
  )), $ = () => {
    const W = b.componentClass;
    return /* @__PURE__ */ H.createElement(H.Fragment, null, V && /* @__PURE__ */ H.createElement(W, { ...b.params }), !V && /* @__PURE__ */ H.createElement(W, { ...b.params, ref: D }));
  };
  return /* @__PURE__ */ H.createElement(
    "div",
    {
      ref: N,
      role: "row",
      style: F,
      "row-index": u,
      "row-id": d,
      "row-business-key": f,
      tabIndex: o
    },
    M && k(),
    G && $()
  );
}, N8e = Vi(O8e), k8e = (e) => {
  const { context: t } = rr(_i), { name: r } = e, n = ct(() => aY(r), [r]), i = le(null), o = le(null), a = le([]), s = le([]), [l, u] = Ee(() => []), c = le(!1), d = le(), h = ct(() => na(n.viewport), [n]), f = ct(() => na(n.container), [n]), p = n.type === "center", g = p ? i : o;
  Xu(" AG Row Container " + r + " ", g);
  const v = Wt(() => p ? i.current != null && o.current != null : o.current != null, []), m = Wt(() => p ? i.current == null && o.current == null : o.current == null, []), y = Wt(() => {
    if (m() && (t.destroyBean(d.current), d.current = null), v()) {
      const w = (E) => {
        const R = UA(
          s.current,
          a.current,
          c.current
        );
        R !== s.current && (s.current = R, jA(E, () => u(R)));
      }, x = {
        setViewportHeight: (E) => {
          i.current && (i.current.style.height = E);
        },
        setRowCtrls: ({ rowCtrls: E, useFlushSync: R }) => {
          const _ = !!R && a.current.length > 0 && E.length > 0;
          a.current = E, w(_);
        },
        setDomOrder: (E) => {
          c.current != E && (c.current = E, w(!1));
        },
        setContainerWidth: (E) => {
          o.current && (o.current.style.width = E);
        },
        setOffsetTop: (E) => {
          o.current && (o.current.style.transform = `translateY(${E})`);
        }
      };
      d.current = t.createBean(new UVe(r)), d.current.setComp(x, o.current, i.current);
    }
  }, [v, m]), C = Wt(
    (w) => {
      o.current = w, y();
    },
    [y]
  ), S = Wt(
    (w) => {
      i.current = w, y();
    },
    [y]
  ), b = () => /* @__PURE__ */ H.createElement("div", { className: f, ref: C, role: "rowgroup" }, l.map((w) => /* @__PURE__ */ H.createElement(
    N8e,
    {
      rowCtrl: w,
      containerType: n.type,
      key: w.getInstanceId()
    }
  )));
  return /* @__PURE__ */ H.createElement(H.Fragment, null, p ? /* @__PURE__ */ H.createElement("div", { className: h, ref: S, role: "presentation" }, b()) : b());
}, V8e = Vi(k8e), B8e = () => {
  const { context: e, resizeObserverService: t } = rr(_i), [r, n] = Ee(""), [i, o] = Ee(0), [a, s] = Ee(0), [l, u] = Ee("0px"), [c, d] = Ee("0px"), [h, f] = Ee("100%"), [p, g] = Ee("0px"), [v, m] = Ee("0px"), [y, C] = Ee("100%"), [S, b] = Ee(""), [w, x] = Ee(""), [E, R] = Ee(null), [_, P] = Ee(""), [D, I] = Ee(null), [A, O] = Ee("ag-layout-normal"), L = le();
  L.current || (L.current = new Kv(() => N.current));
  const N = le(null), F = le(null), G = le(null), M = le(null), V = le(null), z = le(null), k = le(null), $ = le([]), W = le([]);
  Xu(" AG Grid Body ", N), Xu(" AG Pinned Top ", F), Xu(" AG Sticky Top ", G), Xu(" AG Middle ", z), Xu(" AG Pinned Bottom ", k);
  const j = Wt((Re) => {
    if (N.current = Re, !N.current) {
      e.destroyBeans($.current), W.current.forEach((Q) => Q()), $.current = [], W.current = [];
      return;
    }
    if (!e)
      return;
    const _e = (Q, ye) => {
      Q.appendChild(ye), W.current.push(() => Q.removeChild(ye));
    }, He = (Q) => {
      const ye = e.createBean(new Q());
      return $.current.push(ye), ye;
    }, Ve = (Q, ye, Ge) => {
      _e(Q, document.createComment(Ge)), _e(Q, He(ye).getGui());
    };
    Ve(N.current, Qke, " AG Fake Horizontal Scroll "), Ve(N.current, Xke, " AG Overlay Wrapper "), V.current && Ve(V.current, Jke, " AG Fake Vertical Scroll ");
    const $e = {
      setRowAnimationCssOnBodyViewport: n,
      setColumnCount: (Q) => {
        N.current && mOe(N.current, Q);
      },
      setRowCount: (Q) => {
        N.current && gOe(N.current, Q);
      },
      setTopHeight: o,
      setBottomHeight: s,
      setStickyTopHeight: u,
      setStickyTopTop: d,
      setStickyTopWidth: f,
      setTopDisplay: b,
      setBottomDisplay: x,
      setColumnMovingCss: (Q, ye) => L.current.addOrRemoveCssClass(Q, ye),
      updateLayoutClasses: O,
      setAlwaysVerticalScrollClass: R,
      setPinnedTopBottomOverflowY: P,
      setCellSelectableCss: (Q, ye) => I(ye ? Q : null),
      setBodyViewportWidth: (Q) => {
        z.current && (z.current.style.width = Q);
      },
      registerBodyViewportResizeListener: (Q) => {
        if (z.current) {
          const ye = t.observeResize(z.current, Q);
          W.current.push(() => ye());
        }
      },
      setStickyBottomHeight: g,
      setStickyBottomBottom: m,
      setStickyBottomWidth: C
    }, Je = e.createBean(new iVe());
    $.current.push(Je), Je.setComp(
      $e,
      N.current,
      z.current,
      F.current,
      k.current,
      G.current,
      M.current
    );
  }, []), U = ct(() => na("ag-root", "ag-unselectable", A), [A]), Z = ct(
    () => na(
      "ag-body-viewport",
      r,
      A,
      E,
      D
    ),
    [r, A, E, D]
  ), ee = ct(() => na("ag-body", A), [A]), J = ct(() => na("ag-floating-top", D), [D]), X = ct(() => na("ag-sticky-top", D), [D]), Y = ct(() => na("ag-sticky-bottom", D), [D]), de = ct(() => na("ag-floating-bottom", D), [D]), K = ct(
    () => ({
      height: i,
      minHeight: i,
      display: S,
      overflowY: _
    }),
    [i, S, _]
  ), ie = ct(
    () => ({
      height: l,
      top: c,
      width: h
    }),
    [l, c, h]
  ), Ce = ct(
    () => ({
      height: p,
      bottom: v,
      width: y
    }),
    [p, v, y]
  ), Te = ct(
    () => ({
      height: a,
      minHeight: a,
      display: w,
      overflowY: _
    }),
    [a, w, _]
  ), Ie = (Re) => /* @__PURE__ */ H.createElement(V8e, { name: Re, key: `${Re}-container` }), we = ({
    section: Re,
    children: _e,
    className: He,
    style: Ve
  }) => /* @__PURE__ */ H.createElement("div", { ref: Re, className: He, role: "presentation", style: Ve }, _e.map(Ie));
  return /* @__PURE__ */ H.createElement("div", { ref: j, className: U, role: "treegrid" }, /* @__PURE__ */ H.createElement(x8e, null), we({
    section: F,
    className: J,
    style: K,
    children: ["topLeft", "topCenter", "topRight", "topFullWidth"]
  }), /* @__PURE__ */ H.createElement("div", { className: ee, ref: V, role: "presentation" }, we({
    section: z,
    className: Z,
    children: ["left", "center", "right", "fullWidth"]
  })), we({
    section: G,
    className: X,
    style: ie,
    children: ["stickyTopLeft", "stickyTopCenter", "stickyTopRight", "stickyTopFullWidth"]
  }), we({
    section: M,
    className: Y,
    style: Ce,
    children: ["stickyBottomLeft", "stickyBottomCenter", "stickyBottomRight", "stickyBottomFullWidth"]
  }), we({
    section: k,
    className: de,
    style: Te,
    children: ["bottomLeft", "bottomCenter", "bottomRight", "bottomFullWidth"]
  }));
}, G8e = Vi(B8e), H8e = (e, t) => {
  const { children: r, eFocusableElement: n, onTabKeyDown: i, gridCtrl: o, forceFocusOutWhenTabGuardsAreEmpty: a } = e, { context: s } = rr(_i), l = le(null), u = le(null), c = le(), d = (v) => {
    const m = v == null ? void 0 : parseInt(v, 10).toString();
    [l, u].forEach((y) => {
      var C, S;
      m === void 0 ? (C = y.current) == null || C.removeAttribute("tabindex") : (S = y.current) == null || S.setAttribute("tabindex", m);
    });
  };
  Nc(t, () => ({
    forceFocusOutOfContainer(v) {
      var m;
      (m = c.current) == null || m.forceFocusOutOfContainer(v);
    }
  }));
  const h = Wt(() => {
    if (!l.current && !u.current) {
      s.destroyBean(c.current), c.current = null;
      return;
    }
    if (l.current && u.current) {
      const v = {
        setTabIndex: d
      };
      c.current = s.createBean(
        new vY({
          comp: v,
          eTopGuard: l.current,
          eBottomGuard: u.current,
          eFocusableElement: n,
          onTabKeyDown: i,
          forceFocusOutWhenTabGuardsAreEmpty: a,
          focusInnerElement: (m) => o.focusInnerElement(m)
        })
      );
    }
  }, []), f = Wt(
    (v) => {
      l.current = v, h();
    },
    [h]
  ), p = Wt(
    (v) => {
      u.current = v, h();
    },
    [h]
  ), g = (v) => {
    const m = v === "top" ? m0.TAB_GUARD_TOP : m0.TAB_GUARD_BOTTOM;
    return /* @__PURE__ */ H.createElement(
      "div",
      {
        className: `${m0.TAB_GUARD} ${m}`,
        role: "presentation",
        ref: v === "top" ? f : p
      }
    );
  };
  return /* @__PURE__ */ H.createElement(H.Fragment, null, g("top"), r, g("bottom"));
}, z8e = fn(H8e), $8e = Vi(z8e), W8e = ({ context: e }) => {
  const [t, r] = Ee(""), [n, i] = Ee(""), [o, a] = Ee(null), [s, l] = Ee(null), [u, c] = Ee(!1), [d, h] = Ee(), f = le(null), p = le(null), g = le(), [v, m] = Ee(null), y = le(() => {
  }), C = le(), S = le([]), b = Wt(() => {
  }, []), w = ct(() => e.isDestroyed() ? null : e.getBeans(), [e]);
  Xu(" AG Grid ", p);
  const x = Wt((D) => {
    if (p.current = D, !p.current) {
      e.destroyBean(f.current), f.current = null;
      return;
    }
    if (e.isDestroyed())
      return;
    f.current = e.createBean(new T4e());
    const I = f.current;
    y.current = I.focusInnerElement.bind(I);
    const A = {
      destroyGridUi: () => {
      },
      // do nothing, as framework users destroy grid by removing the comp
      setRtlClass: r,
      forceFocusOutOfContainer: (O) => {
        var L, N;
        if (!O && ((L = C.current) != null && L.isDisplayed())) {
          C.current.forceFocusOutOfContainer(O);
          return;
        }
        (N = g.current) == null || N.forceFocusOutOfContainer(O);
      },
      updateLayoutClasses: i,
      getFocusableContainers: () => {
        var N;
        const O = [], L = (N = p.current) == null ? void 0 : N.querySelector(".ag-root");
        return L && O.push({ getGui: () => L }), S.current.forEach((F) => {
          F.isDisplayed() && O.push(F);
        }), O;
      },
      setCursor: a,
      setUserSelect: l
    };
    I.setComp(A, p.current, p.current), c(!0);
  }, []);
  It(() => {
    if (!d || !w || !f.current || !v || !p.current)
      return;
    const D = f.current, I = [], {
      watermarkSelector: A,
      paginationSelector: O,
      sideBarSelector: L,
      statusBarSelector: N,
      gridHeaderDropZonesSelector: F
    } = D.getOptionalSelectors(), G = [], M = p.current;
    if (F) {
      const z = e.createBean(new F.component()), k = z.getGui();
      M.insertAdjacentElement("afterbegin", k), G.push(k), I.push(z);
    }
    if (L) {
      const z = e.createBean(new L.component()), k = z.getGui(), $ = v.querySelector(".ag-tab-guard-bottom");
      $ && ($.insertAdjacentElement("beforebegin", k), G.push(k)), I.push(z), S.current.push(z);
    }
    const V = (z) => {
      const k = e.createBean(new z()), $ = k.getGui();
      return M.insertAdjacentElement("beforeend", $), G.push($), I.push(k), k;
    };
    if (N && V(N.component), O) {
      const z = V(O.component);
      C.current = z, S.current.push(z);
    }
    return A && V(A.component), () => {
      e.destroyBeans(I), G.forEach((z) => {
        z.parentElement && z.parentElement.removeChild(z);
      });
    };
  }, [d, v, w]);
  const E = ct(
    () => na("ag-root-wrapper", t, n),
    [t, n]
  ), R = ct(
    () => na("ag-root-wrapper-body", "ag-focus-managed", n),
    [n]
  ), _ = ct(
    () => ({
      userSelect: s ?? "",
      WebkitUserSelect: s ?? "",
      cursor: o ?? ""
    }),
    [s, o]
  ), P = Wt((D) => {
    g.current = D, h(D !== null);
  }, []);
  return /* @__PURE__ */ H.createElement("div", { ref: x, className: E, style: _, role: "presentation" }, /* @__PURE__ */ H.createElement("div", { className: R, ref: m, role: "presentation" }, u && v && w && /* @__PURE__ */ H.createElement(_i.Provider, { value: w }, /* @__PURE__ */ H.createElement(
    $8e,
    {
      ref: P,
      eFocusableElement: v,
      onTabKeyDown: b,
      gridCtrl: f.current,
      forceFocusOutWhenTabGuardsAreEmpty: !0
    },
    // we wait for initialised before rending the children, so GridComp has created and registered with it's
    // GridCtrl before we create the child GridBodyComp. Otherwise the GridBodyComp would initialise first,
    // before we have set the the Layout CSS classes, causing the GridBodyComp to render rows to a grid that
    // doesn't have it's height specified, which would result if all the rows getting rendered (and if many rows,
    // hangs the UI)
    /* @__PURE__ */ H.createElement(G8e, null)
  ))));
}, j8e = Vi(W8e), U8e = class extends he {
  wireBeans(e) {
    this.ctrlsService = e.ctrlsService;
  }
  areHeaderCellsRendered() {
    return this.ctrlsService.getHeaderRowContainerCtrls().every((e) => e.getAllCtrls().every((t) => t.areCellsRendered()));
  }
}, VY = (e) => {
  var g;
  const t = le(), r = le(null), n = le(null), i = le([]), o = le([]), a = le(e), s = le(), l = le(!1), [u, c] = Ee(void 0), [, d] = Ee(0), h = Wt((v) => {
    if (r.current = v, !r.current) {
      i.current.forEach((_) => _()), i.current.length = 0;
      return;
    }
    const m = e.modules || [];
    n.current || (n.current = new h8e(
      () => d((_) => _ + 1),
      e.componentWrappingElement,
      e.maxComponentCreationTimeMs
    ), i.current.push(() => {
      var _;
      (_ = n.current) == null || _.destroy(), n.current = null;
    }));
    const y = aOe(e.gridOptions, e), C = () => {
      if (l.current) {
        const _ = () => {
          var D;
          return (D = s.current) != null && D.shouldQueueUpdates() ? void 0 : o.current.shift();
        };
        let P = _();
        for (; P; )
          P(), P = _();
      }
    }, S = Z5e() ? new Z8e(C) : new BY();
    s.current = S;
    const b = new U8e(), w = {
      providedBeanInstances: {
        frameworkComponentWrapper: new Y8e(
          n.current,
          y.reactiveCustomComponents ?? !0
        ),
        renderStatusService: b
      },
      modules: m,
      frameworkOverrides: S
    }, x = (_) => {
      c(_), _.createBean(b), i.current.push(() => {
        _.destroy();
      }), _.getBean("ctrlsService").whenReady(() => {
        if (_.isDestroyed())
          return;
        const D = t.current;
        D && e.setGridApi && e.setGridApi(D);
      });
    }, E = (_) => {
      _.getBean("ctrlsService").whenReady(() => {
        o.current.forEach((D) => D()), o.current.length = 0, l.current = !0;
      });
    }, R = new e5e();
    t.current = R.create(
      r.current,
      y,
      x,
      E,
      w
    );
  }, []), f = ct(() => ({
    height: "100%",
    ...e.containerStyle || {}
  }), [e.containerStyle]), p = Wt((v) => {
    var m;
    l.current && !((m = s.current) != null && m.shouldQueueUpdates()) ? v() : o.current.push(v);
  }, []);
  return It(() => {
    const v = K8e(a.current, e);
    a.current = e, p(() => {
      t.current && sOe(v, t.current);
    });
  }, [e]), /* @__PURE__ */ H.createElement("div", { style: f, className: e.className, ref: h }, u && !u.isDestroyed() ? /* @__PURE__ */ H.createElement(j8e, { context: u }) : null, ((g = n.current) == null ? void 0 : g.getPortals()) ?? null);
};
function K8e(e, t) {
  const r = {};
  return Object.keys(t).forEach((n) => {
    const i = t[n];
    e[n] !== i && (r[n] = i);
  }), r;
}
var Y8e = class extends l5e {
  constructor(e, t) {
    super(), this.parent = e, this.reactiveCustomComponents = t;
  }
  createWrapper(e, t) {
    if (this.reactiveCustomComponents) {
      const i = ((o) => {
        switch (o) {
          case "filter":
            return n8e;
          case "floatingFilterComponent":
            return o8e;
          case "dateComponent":
            return r8e;
          case "loadingOverlayComponent":
            return a8e;
          case "noRowsOverlayComponent":
            return l8e;
          case "statusPanel":
            return u8e;
          case "toolPanel":
            return c8e;
          case "menuItem":
            return s8e;
          case "cellRenderer":
            return t8e;
        }
      })(t.propertyName);
      if (i)
        return new i(e, this.parent, t);
    } else
      switch (t.propertyName) {
        case "filter":
        case "floatingFilterComponent":
        case "dateComponent":
        case "loadingOverlayComponent":
        case "noRowsOverlayComponent":
        case "statusPanel":
        case "toolPanel":
        case "menuItem":
        case "cellRenderer":
          qA();
          break;
      }
    const r = !t.cellRenderer && t.propertyName !== "toolPanel";
    return new NY(e, this.parent, t, r);
  }
}, q8e = fn((e, t) => {
  const { ctrlsFactory: r, context: n, gos: i, resizeObserverService: o, rowModel: a } = rr(_i), [s, l] = Ee(() => new Po()), [u, c] = Ee(() => new Po()), [d, h] = Ee(), [f, p] = Ee(), g = le(), v = le(null), m = le(), y = ct(() => Xn.__getGridRegisteredModules(e.api.getGridId()), [e]), C = ct(() => s.toString() + " ag-details-row", [s]), S = ct(() => u.toString() + " ag-details-grid", [u]);
  t && Nc(t, () => ({
    refresh() {
      var x;
      return ((x = g.current) == null ? void 0 : x.refresh()) ?? !1;
    }
  })), e.template && Se(
    "detailCellRendererParams.template is not supported by AG Grid React. To change the template, provide a Custom Detail Cell Renderer. See https://ag-grid.com/react-data-grid/master-detail-custom-detail/"
  );
  const b = Wt((x) => {
    if (v.current = x, !v.current) {
      n.destroyBean(g.current), m.current && m.current();
      return;
    }
    const E = {
      addOrRemoveCssClass: (_, P) => l((D) => D.setClass(_, P)),
      addOrRemoveDetailGridCssClass: (_, P) => c((D) => D.setClass(_, P)),
      setDetailGrid: (_) => h(_),
      setRowData: (_) => p(_),
      getGui: () => v.current
    }, R = r.getInstance("detailCellRenderer");
    if (R && (n.createBean(R), R.init(E, e), g.current = R, i.get("detailRowAutoHeight"))) {
      const _ = () => {
        if (v.current == null)
          return;
        const P = v.current.clientHeight;
        P != null && P > 0 && setTimeout(() => {
          e.node.setRowHeight(P), (a.getType() === "clientSide" || a.getType() === "serverSide") && a.onRowHeightChanged();
        }, 0);
      };
      m.current = o.observeResize(v.current, _), _();
    }
  }, []), w = Wt((x) => {
    var E;
    (E = g.current) == null || E.registerDetailWithMaster(x);
  }, []);
  return /* @__PURE__ */ H.createElement("div", { className: C, ref: b }, d && /* @__PURE__ */ H.createElement(
    VY,
    {
      className: S,
      ...d,
      modules: y,
      rowData: f,
      setGridApi: w
    }
  ));
}), BY = class extends mY {
  constructor() {
    super("react"), this.frameworkComponents = {
      agGroupCellRenderer: qG,
      agGroupRowRenderer: qG,
      agDetailCellRenderer: q8e
    }, this.wrapIncoming = (e, t) => t === "ensureVisible" ? X5e(e) : e(), this.renderingEngine = "react";
  }
  frameworkComponent(e) {
    return this.frameworkComponents[e];
  }
  isFrameworkComponent(e) {
    if (!e)
      return !1;
    const t = e.prototype;
    return !(t && "getGui" in t);
  }
  shouldQueueUpdates() {
    return !1;
  }
  getLockOnRefreshError() {
    return " This error can also occur if using 'ReactDOM.render' instead of 'createRoot'. If so, please upgrade to 'createRoot'.";
  }
}, Z8e = class extends BY {
  constructor(e) {
    super(), this.processQueuedUpdates = e, this.queueUpdates = !1;
  }
  getLockOnRefresh() {
    this.queueUpdates = !0;
  }
  releaseLockOnRefresh() {
    this.queueUpdates = !1, this.processQueuedUpdates();
  }
  shouldQueueUpdates() {
    return this.queueUpdates;
  }
  getLockOnRefreshError() {
    return "";
  }
}, X8e = class extends iq {
  constructor() {
    super(...arguments), this.apiListeners = [], this.setGridApi = (e) => {
      this.api = e, this.apiListeners.forEach((t) => t(e));
    };
  }
  registerApiListener(e) {
    this.apiListeners.push(e);
  }
  componentWillUnmount() {
    this.apiListeners.length = 0;
  }
  render() {
    return /* @__PURE__ */ H.createElement(VY, { ...this.props, setGridApi: this.setGridApi });
  }
};
const Q8e = () => /^((?!chrome|android).)*safari/i.test(navigator.userAgent), GY = (e) => Array.isArray(e) && e.every(
  (t) => typeof t == "object" && !(t instanceof Array)
), J8e = (e) => Array.isArray(e) && e.every(
  (t) => Array.isArray(t)
), e3e = (e) => Array.from(
  e.map((t) => Object.keys(t)).reduce((t, r) => /* @__PURE__ */ new Set([...t, ...r]), [])
), t3e = (e, t) => {
  t = t || e3e(e);
  let r = t, n = t;
  GY(t) && (r = t.map((o) => o.label), n = t.map((o) => o.key));
  const i = e.map((o) => n.map((a) => r3e(a, o)));
  return [r, ...i];
}, r3e = (e, t) => {
  const r = e.replace(/\[([^\]]+)]/g, ".$1").split(".").reduce(function(n, i, o, a) {
    const s = n[i];
    if (s == null)
      a.splice(1);
    else
      return s;
  }, t);
  return r === void 0 ? e in t ? t[e] : "" : r;
}, n3e = (e) => typeof e > "u" || e === null ? "" : e, HY = (e, t = ",", r = '"') => e.filter((n) => n).map(
  (n) => n.map((i) => n3e(i)).map((i) => `${r}${i}${r}`).join(t)
).join(`
`), i3e = (e, t, r, n) => HY(t ? [t, ...e] : e, r, n), o3e = (e, t, r, n) => HY(t3e(e, t), r, n), a3e = (e, t, r, n) => t ? `${t.join(r)}
${e}` : e.replace(/"/g, '""'), zY = (e, t, r, n) => {
  if (GY(e)) return o3e(e, t, r, n);
  if (J8e(e)) return i3e(e, t, r, n);
  if (typeof e == "string") return a3e(e, t, r);
  throw new TypeError('Data should be a "String", "Array of arrays" OR "Array of objects" ');
}, $Y = (e, t, r, n, i) => {
  const o = zY(e, r, n, i), a = Q8e() ? "application/csv" : "text/csv", s = new Blob([t ? "\uFEFF" : "", o], { type: a }), l = `data:${a};charset=utf-8,${t ? "\uFEFF" : ""}${o}`, u = window.URL || window.webkitURL;
  return typeof u.createObjectURL > "u" ? l : u.createObjectURL(s);
};
var NT = { exports: {} }, Oy = { exports: {} }, Sr = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var JG;
function s3e() {
  if (JG) return Sr;
  JG = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, h = e ? Symbol.for("react.suspense_list") : 60120, f = e ? Symbol.for("react.memo") : 60115, p = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, m = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
  function C(b) {
    if (typeof b == "object" && b !== null) {
      var w = b.$$typeof;
      switch (w) {
        case t:
          switch (b = b.type, b) {
            case l:
            case u:
            case n:
            case o:
            case i:
            case d:
              return b;
            default:
              switch (b = b && b.$$typeof, b) {
                case s:
                case c:
                case p:
                case f:
                case a:
                  return b;
                default:
                  return w;
              }
          }
        case r:
          return w;
      }
    }
  }
  function S(b) {
    return C(b) === u;
  }
  return Sr.AsyncMode = l, Sr.ConcurrentMode = u, Sr.ContextConsumer = s, Sr.ContextProvider = a, Sr.Element = t, Sr.ForwardRef = c, Sr.Fragment = n, Sr.Lazy = p, Sr.Memo = f, Sr.Portal = r, Sr.Profiler = o, Sr.StrictMode = i, Sr.Suspense = d, Sr.isAsyncMode = function(b) {
    return S(b) || C(b) === l;
  }, Sr.isConcurrentMode = S, Sr.isContextConsumer = function(b) {
    return C(b) === s;
  }, Sr.isContextProvider = function(b) {
    return C(b) === a;
  }, Sr.isElement = function(b) {
    return typeof b == "object" && b !== null && b.$$typeof === t;
  }, Sr.isForwardRef = function(b) {
    return C(b) === c;
  }, Sr.isFragment = function(b) {
    return C(b) === n;
  }, Sr.isLazy = function(b) {
    return C(b) === p;
  }, Sr.isMemo = function(b) {
    return C(b) === f;
  }, Sr.isPortal = function(b) {
    return C(b) === r;
  }, Sr.isProfiler = function(b) {
    return C(b) === o;
  }, Sr.isStrictMode = function(b) {
    return C(b) === i;
  }, Sr.isSuspense = function(b) {
    return C(b) === d;
  }, Sr.isValidElementType = function(b) {
    return typeof b == "string" || typeof b == "function" || b === n || b === u || b === o || b === i || b === d || b === h || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === f || b.$$typeof === a || b.$$typeof === s || b.$$typeof === c || b.$$typeof === v || b.$$typeof === m || b.$$typeof === y || b.$$typeof === g);
  }, Sr.typeOf = C, Sr;
}
var wr = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var eH;
function l3e() {
  return eH || (eH = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, r = e ? Symbol.for("react.portal") : 60106, n = e ? Symbol.for("react.fragment") : 60107, i = e ? Symbol.for("react.strict_mode") : 60108, o = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, h = e ? Symbol.for("react.suspense_list") : 60120, f = e ? Symbol.for("react.memo") : 60115, p = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, v = e ? Symbol.for("react.fundamental") : 60117, m = e ? Symbol.for("react.responder") : 60118, y = e ? Symbol.for("react.scope") : 60119;
    function C(Y) {
      return typeof Y == "string" || typeof Y == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Y === n || Y === u || Y === o || Y === i || Y === d || Y === h || typeof Y == "object" && Y !== null && (Y.$$typeof === p || Y.$$typeof === f || Y.$$typeof === a || Y.$$typeof === s || Y.$$typeof === c || Y.$$typeof === v || Y.$$typeof === m || Y.$$typeof === y || Y.$$typeof === g);
    }
    function S(Y) {
      if (typeof Y == "object" && Y !== null) {
        var de = Y.$$typeof;
        switch (de) {
          case t:
            var K = Y.type;
            switch (K) {
              case l:
              case u:
              case n:
              case o:
              case i:
              case d:
                return K;
              default:
                var ie = K && K.$$typeof;
                switch (ie) {
                  case s:
                  case c:
                  case p:
                  case f:
                  case a:
                    return ie;
                  default:
                    return de;
                }
            }
          case r:
            return de;
        }
      }
    }
    var b = l, w = u, x = s, E = a, R = t, _ = c, P = n, D = p, I = f, A = r, O = o, L = i, N = d, F = !1;
    function G(Y) {
      return F || (F = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), M(Y) || S(Y) === l;
    }
    function M(Y) {
      return S(Y) === u;
    }
    function V(Y) {
      return S(Y) === s;
    }
    function z(Y) {
      return S(Y) === a;
    }
    function k(Y) {
      return typeof Y == "object" && Y !== null && Y.$$typeof === t;
    }
    function $(Y) {
      return S(Y) === c;
    }
    function W(Y) {
      return S(Y) === n;
    }
    function j(Y) {
      return S(Y) === p;
    }
    function U(Y) {
      return S(Y) === f;
    }
    function Z(Y) {
      return S(Y) === r;
    }
    function ee(Y) {
      return S(Y) === o;
    }
    function J(Y) {
      return S(Y) === i;
    }
    function X(Y) {
      return S(Y) === d;
    }
    wr.AsyncMode = b, wr.ConcurrentMode = w, wr.ContextConsumer = x, wr.ContextProvider = E, wr.Element = R, wr.ForwardRef = _, wr.Fragment = P, wr.Lazy = D, wr.Memo = I, wr.Portal = A, wr.Profiler = O, wr.StrictMode = L, wr.Suspense = N, wr.isAsyncMode = G, wr.isConcurrentMode = M, wr.isContextConsumer = V, wr.isContextProvider = z, wr.isElement = k, wr.isForwardRef = $, wr.isFragment = W, wr.isLazy = j, wr.isMemo = U, wr.isPortal = Z, wr.isProfiler = ee, wr.isStrictMode = J, wr.isSuspense = X, wr.isValidElementType = C, wr.typeOf = S;
  }()), wr;
}
var tH;
function WY() {
  return tH || (tH = 1, process.env.NODE_ENV === "production" ? Oy.exports = s3e() : Oy.exports = l3e()), Oy.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var oE, rH;
function u3e() {
  if (rH) return oE;
  rH = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, r = Object.prototype.propertyIsEnumerable;
  function n(o) {
    if (o == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(o);
  }
  function i() {
    try {
      if (!Object.assign)
        return !1;
      var o = new String("abc");
      if (o[5] = "de", Object.getOwnPropertyNames(o)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return oE = i() ? Object.assign : function(o, a) {
    for (var s, l = n(o), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var d in s)
        t.call(s, d) && (l[d] = s[d]);
      if (e) {
        u = e(s);
        for (var h = 0; h < u.length; h++)
          r.call(s, u[h]) && (l[u[h]] = s[u[h]]);
      }
    }
    return l;
  }, oE;
}
var aE, nH;
function ZA() {
  if (nH) return aE;
  nH = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return aE = e, aE;
}
var sE, iH;
function jY() {
  return iH || (iH = 1, sE = Function.call.bind(Object.prototype.hasOwnProperty)), sE;
}
var lE, oH;
function c3e() {
  if (oH) return lE;
  oH = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = ZA(), r = {}, n = jY();
    e = function(o) {
      var a = "Warning: " + o;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function i(o, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in o)
        if (n(o, c)) {
          var d;
          try {
            if (typeof o[c] != "function") {
              var h = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw h.name = "Invariant Violation", h;
            }
            d = o[c](a, c, l, s, null, t);
          } catch (p) {
            d = p;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in r)) {
            r[d.message] = !0;
            var f = u ? u() : "";
            e(
              "Failed " + s + " type: " + d.message + (f ?? "")
            );
          }
        }
    }
  }
  return i.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (r = {});
  }, lE = i, lE;
}
var uE, aH;
function d3e() {
  if (aH) return uE;
  aH = 1;
  var e = WY(), t = u3e(), r = ZA(), n = jY(), i = c3e(), o = function() {
  };
  process.env.NODE_ENV !== "production" && (o = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return uE = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(M) {
      var V = M && (u && M[u] || M[c]);
      if (typeof V == "function")
        return V;
    }
    var h = "<<anonymous>>", f = {
      array: m("array"),
      bigint: m("bigint"),
      bool: m("boolean"),
      func: m("function"),
      number: m("number"),
      object: m("object"),
      string: m("string"),
      symbol: m("symbol"),
      any: y(),
      arrayOf: C,
      element: S(),
      elementType: b(),
      instanceOf: w,
      node: _(),
      objectOf: E,
      oneOf: x,
      oneOfType: R,
      shape: D,
      exact: I
    };
    function p(M, V) {
      return M === V ? M !== 0 || 1 / M === 1 / V : M !== M && V !== V;
    }
    function g(M, V) {
      this.message = M, this.data = V && typeof V == "object" ? V : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function v(M) {
      if (process.env.NODE_ENV !== "production")
        var V = {}, z = 0;
      function k(W, j, U, Z, ee, J, X) {
        if (Z = Z || h, J = J || U, X !== r) {
          if (l) {
            var Y = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Y.name = "Invariant Violation", Y;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var de = Z + ":" + U;
            !V[de] && // Avoid spamming the console because they are often not actionable except for lib authors
            z < 3 && (o(
              "You are manually calling a React.PropTypes validation function for the `" + J + "` prop on `" + Z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), V[de] = !0, z++);
          }
        }
        return j[U] == null ? W ? j[U] === null ? new g("The " + ee + " `" + J + "` is marked as required " + ("in `" + Z + "`, but its value is `null`.")) : new g("The " + ee + " `" + J + "` is marked as required in " + ("`" + Z + "`, but its value is `undefined`.")) : null : M(j, U, Z, ee, J);
      }
      var $ = k.bind(null, !1);
      return $.isRequired = k.bind(null, !0), $;
    }
    function m(M) {
      function V(z, k, $, W, j, U) {
        var Z = z[k], ee = L(Z);
        if (ee !== M) {
          var J = N(Z);
          return new g(
            "Invalid " + W + " `" + j + "` of type " + ("`" + J + "` supplied to `" + $ + "`, expected ") + ("`" + M + "`."),
            { expectedType: M }
          );
        }
        return null;
      }
      return v(V);
    }
    function y() {
      return v(a);
    }
    function C(M) {
      function V(z, k, $, W, j) {
        if (typeof M != "function")
          return new g("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var U = z[k];
        if (!Array.isArray(U)) {
          var Z = L(U);
          return new g("Invalid " + W + " `" + j + "` of type " + ("`" + Z + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var ee = 0; ee < U.length; ee++) {
          var J = M(U, ee, $, W, j + "[" + ee + "]", r);
          if (J instanceof Error)
            return J;
        }
        return null;
      }
      return v(V);
    }
    function S() {
      function M(V, z, k, $, W) {
        var j = V[z];
        if (!s(j)) {
          var U = L(j);
          return new g("Invalid " + $ + " `" + W + "` of type " + ("`" + U + "` supplied to `" + k + "`, expected a single ReactElement."));
        }
        return null;
      }
      return v(M);
    }
    function b() {
      function M(V, z, k, $, W) {
        var j = V[z];
        if (!e.isValidElementType(j)) {
          var U = L(j);
          return new g("Invalid " + $ + " `" + W + "` of type " + ("`" + U + "` supplied to `" + k + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return v(M);
    }
    function w(M) {
      function V(z, k, $, W, j) {
        if (!(z[k] instanceof M)) {
          var U = M.name || h, Z = G(z[k]);
          return new g("Invalid " + W + " `" + j + "` of type " + ("`" + Z + "` supplied to `" + $ + "`, expected ") + ("instance of `" + U + "`."));
        }
        return null;
      }
      return v(V);
    }
    function x(M) {
      if (!Array.isArray(M))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? o(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : o("Invalid argument supplied to oneOf, expected an array.")), a;
      function V(z, k, $, W, j) {
        for (var U = z[k], Z = 0; Z < M.length; Z++)
          if (p(U, M[Z]))
            return null;
        var ee = JSON.stringify(M, function(X, Y) {
          var de = N(Y);
          return de === "symbol" ? String(Y) : Y;
        });
        return new g("Invalid " + W + " `" + j + "` of value `" + String(U) + "` " + ("supplied to `" + $ + "`, expected one of " + ee + "."));
      }
      return v(V);
    }
    function E(M) {
      function V(z, k, $, W, j) {
        if (typeof M != "function")
          return new g("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var U = z[k], Z = L(U);
        if (Z !== "object")
          return new g("Invalid " + W + " `" + j + "` of type " + ("`" + Z + "` supplied to `" + $ + "`, expected an object."));
        for (var ee in U)
          if (n(U, ee)) {
            var J = M(U, ee, $, W, j + "." + ee, r);
            if (J instanceof Error)
              return J;
          }
        return null;
      }
      return v(V);
    }
    function R(M) {
      if (!Array.isArray(M))
        return process.env.NODE_ENV !== "production" && o("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var V = 0; V < M.length; V++) {
        var z = M[V];
        if (typeof z != "function")
          return o(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + F(z) + " at index " + V + "."
          ), a;
      }
      function k($, W, j, U, Z) {
        for (var ee = [], J = 0; J < M.length; J++) {
          var X = M[J], Y = X($, W, j, U, Z, r);
          if (Y == null)
            return null;
          Y.data && n(Y.data, "expectedType") && ee.push(Y.data.expectedType);
        }
        var de = ee.length > 0 ? ", expected one of type [" + ee.join(", ") + "]" : "";
        return new g("Invalid " + U + " `" + Z + "` supplied to " + ("`" + j + "`" + de + "."));
      }
      return v(k);
    }
    function _() {
      function M(V, z, k, $, W) {
        return A(V[z]) ? null : new g("Invalid " + $ + " `" + W + "` supplied to " + ("`" + k + "`, expected a ReactNode."));
      }
      return v(M);
    }
    function P(M, V, z, k, $) {
      return new g(
        (M || "React class") + ": " + V + " type `" + z + "." + k + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function D(M) {
      function V(z, k, $, W, j) {
        var U = z[k], Z = L(U);
        if (Z !== "object")
          return new g("Invalid " + W + " `" + j + "` of type `" + Z + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var ee in M) {
          var J = M[ee];
          if (typeof J != "function")
            return P($, W, j, ee, N(J));
          var X = J(U, ee, $, W, j + "." + ee, r);
          if (X)
            return X;
        }
        return null;
      }
      return v(V);
    }
    function I(M) {
      function V(z, k, $, W, j) {
        var U = z[k], Z = L(U);
        if (Z !== "object")
          return new g("Invalid " + W + " `" + j + "` of type `" + Z + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var ee = t({}, z[k], M);
        for (var J in ee) {
          var X = M[J];
          if (n(M, J) && typeof X != "function")
            return P($, W, j, J, N(X));
          if (!X)
            return new g(
              "Invalid " + W + " `" + j + "` key `" + J + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(z[k], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(M), null, "  ")
            );
          var Y = X(U, J, $, W, j + "." + J, r);
          if (Y)
            return Y;
        }
        return null;
      }
      return v(V);
    }
    function A(M) {
      switch (typeof M) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !M;
        case "object":
          if (Array.isArray(M))
            return M.every(A);
          if (M === null || s(M))
            return !0;
          var V = d(M);
          if (V) {
            var z = V.call(M), k;
            if (V !== M.entries) {
              for (; !(k = z.next()).done; )
                if (!A(k.value))
                  return !1;
            } else
              for (; !(k = z.next()).done; ) {
                var $ = k.value;
                if ($ && !A($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function O(M, V) {
      return M === "symbol" ? !0 : V ? V["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && V instanceof Symbol : !1;
    }
    function L(M) {
      var V = typeof M;
      return Array.isArray(M) ? "array" : M instanceof RegExp ? "object" : O(V, M) ? "symbol" : V;
    }
    function N(M) {
      if (typeof M > "u" || M === null)
        return "" + M;
      var V = L(M);
      if (V === "object") {
        if (M instanceof Date)
          return "date";
        if (M instanceof RegExp)
          return "regexp";
      }
      return V;
    }
    function F(M) {
      var V = N(M);
      switch (V) {
        case "array":
        case "object":
          return "an " + V;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + V;
        default:
          return V;
      }
    }
    function G(M) {
      return !M.constructor || !M.constructor.name ? h : M.constructor.name;
    }
    return f.checkPropTypes = i, f.resetWarningCache = i.resetWarningCache, f.PropTypes = f, f;
  }, uE;
}
var cE, sH;
function h3e() {
  if (sH) return cE;
  sH = 1;
  var e = ZA();
  function t() {
  }
  function r() {
  }
  return r.resetWarningCache = t, cE = function() {
    function n(a, s, l, u, c, d) {
      if (d !== e) {
        var h = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw h.name = "Invariant Violation", h;
      }
    }
    n.isRequired = n;
    function i() {
      return n;
    }
    var o = {
      array: n,
      bigint: n,
      bool: n,
      func: n,
      number: n,
      object: n,
      string: n,
      symbol: n,
      any: n,
      arrayOf: i,
      element: n,
      elementType: n,
      instanceOf: i,
      node: n,
      objectOf: i,
      oneOf: i,
      oneOfType: i,
      shape: i,
      exact: i,
      checkPropTypes: r,
      resetWarningCache: t
    };
    return o.PropTypes = o, o;
  }, cE;
}
if (process.env.NODE_ENV !== "production") {
  var f3e = WY(), p3e = !0;
  NT.exports = d3e()(f3e.isElement, p3e);
} else
  NT.exports = h3e()();
var vo = NT.exports;
const UY = {
  data: vo.oneOfType([vo.string, vo.array, vo.func]).isRequired,
  headers: vo.array,
  target: vo.string,
  separator: vo.string,
  filename: vo.string,
  uFEFF: vo.bool,
  onClick: vo.func,
  asyncOnClick: vo.bool,
  enclosingCharacter: vo.string
}, KY = {
  separator: ",",
  filename: "generatedBy_react-csv.csv",
  uFEFF: !0,
  asyncOnClick: !1,
  enclosingCharacter: '"'
}, g3e = {
  target: "_blank"
};
class lH extends H.Component {
  constructor(t) {
    super(t), this.state = {};
  }
  buildURI() {
    return $Y(...arguments);
  }
  componentDidMount() {
    const { data: t, headers: r, separator: n, enclosingCharacter: i, uFEFF: o, target: a, specs: s, replace: l } = this.props;
    this.state.page = window.open(
      this.buildURI(t, o, r, n, i),
      a,
      s,
      l
    );
  }
  getWindow() {
    return this.state.page;
  }
  render() {
    return null;
  }
}
Ff(lH, "defaultProps", Object.assign(
  KY,
  g3e
)), Ff(lH, "propTypes", UY);
var Ny;
let v3e = (Ny = class extends H.Component {
  constructor(t) {
    super(t), this.buildURI = this.buildURI.bind(this);
  }
  buildURI() {
    return $Y(...arguments);
  }
  /**
   * In IE11 this method will trigger the file download
   */
  handleLegacy(t, r = !1) {
    if (window.navigator.msSaveOrOpenBlob) {
      t.preventDefault();
      const {
        data: n,
        headers: i,
        separator: o,
        filename: a,
        enclosingCharacter: s,
        uFEFF: l
      } = this.props, u = r && typeof n == "function" ? n() : n;
      let c = new Blob([l ? "\uFEFF" : "", zY(u, i, o, s)]);
      return window.navigator.msSaveBlob(c, a), !1;
    }
  }
  handleAsyncClick(t) {
    const r = (n) => {
      if (n === !1) {
        t.preventDefault();
        return;
      }
      this.handleLegacy(t, !0);
    };
    this.props.onClick(t, r);
  }
  handleSyncClick(t) {
    if (this.props.onClick(t) === !1) {
      t.preventDefault();
      return;
    }
    this.handleLegacy(t);
  }
  handleClick() {
    return (t) => {
      if (typeof this.props.onClick == "function")
        return this.props.asyncOnClick ? this.handleAsyncClick(t) : this.handleSyncClick(t);
      this.handleLegacy(t);
    };
  }
  render() {
    const {
      data: t,
      headers: r,
      separator: n,
      filename: i,
      uFEFF: o,
      children: a,
      onClick: s,
      asyncOnClick: l,
      enclosingCharacter: u,
      ...c
    } = this.props, h = typeof window > "u" ? "" : this.buildURI(t, o, r, n, u);
    return /* @__PURE__ */ ce.jsx(
      "a",
      {
        download: i,
        ...c,
        ref: (f) => this.link = f,
        target: "_self",
        href: h,
        onClick: this.handleClick(),
        children: a
      }
    );
  }
}, Ff(Ny, "defaultProps", KY), Ff(Ny, "propTypes", UY), Ny);
const m3e = v3e;
function M3e({
  title: e,
  summary: t,
  rowData: r,
  columnDefs: n
}) {
  return /* @__PURE__ */ ce.jsxs(
    fr,
    {
      vertical: !0,
      gap: 16,
      style: {
        width: "100%"
      },
      children: [
        /* @__PURE__ */ ce.jsx(
          Lo,
          {
            size: "small",
            bordered: !0,
            hoverable: !0,
            style: {
              backgroundColor: "var(--foreground)",
              width: "100%"
            },
            styles: {
              header: {
                backgroundColor: "#FFF"
              }
            },
            title: /* @__PURE__ */ ce.jsxs(fr, { justify: "space-between", style: { width: "100%" }, children: [
              /* @__PURE__ */ ce.jsx(Ur, { children: e }),
              /* @__PURE__ */ ce.jsx(m3e, { data: r, children: /* @__PURE__ */ ce.jsx(Hc, { title: "download as CSV", children: /* @__PURE__ */ ce.jsx(vH, { size: 20 }) }) })
            ] }),
            children: /* @__PURE__ */ ce.jsx(
              "div",
              {
                style: {
                  width: "100%",
                  height: 300
                },
                children: /* @__PURE__ */ ce.jsx(X8e, { rowData: r, columnDefs: n })
              }
            )
          }
        ),
        /* @__PURE__ */ ce.jsx(Ur, { children: /* @__PURE__ */ ce.jsx(CS, { children: t }) })
      ]
    }
  );
}
const D3e = () => /* @__PURE__ */ ce.jsxs(ce.Fragment, { children: [
  /* @__PURE__ */ ce.jsxs(
    fr,
    {
      align: "center",
      gap: 8,
      style: {
        position: "absolute",
        top: 16,
        left: 16,
        cursor: "pointer"
      },
      onClick: () => {
        window.open("https://houseware.io", "_blank");
      },
      children: [
        /* @__PURE__ */ ce.jsx(yv, { src: "/app-logo.png", height: 30, width: 30, preview: !1 }),
        /* @__PURE__ */ ce.jsx(
          Ur.Title,
          {
            style: {
              fontFamily: "Libre Franklin, sans-serif",
              fontSize: "1rem",
              margin: 0,
              fontWeight: 600
            },
            level: 5,
            children: "houseware"
          }
        )
      ]
    }
  ),
  /* @__PURE__ */ ce.jsxs(
    fr,
    {
      vertical: !0,
      style: {
        position: "absolute",
        bottom: 16,
        right: 16,
        zIndex: 1
      },
      gap: 16,
      children: [
        /* @__PURE__ */ ce.jsx(
          Qn,
          {
            size: "large",
            shape: "circle",
            type: "text",
            onClick: () => {
              window.open("https://x.com/gethouseware", "_blank");
            },
            icon: /* @__PURE__ */ ce.jsx(
              SH,
              {
                size: "1.5rem",
                weight: "duotone",
                color: "var(--secondary-text)"
              }
            )
          }
        ),
        /* @__PURE__ */ ce.jsx(
          Qn,
          {
            size: "large",
            shape: "circle",
            type: "text",
            onClick: () => {
              window.open(
                "https://www.linkedin.com/company/gethouseware",
                "_blank"
              );
            },
            icon: /* @__PURE__ */ ce.jsx(
              yH,
              {
                size: "1.5rem",
                weight: "duotone",
                color: "var(--secondary-text)"
              }
            )
          }
        ),
        /* @__PURE__ */ ce.jsx(
          Qn,
          {
            size: "large",
            shape: "circle",
            type: "text",
            onClick: () => {
              window.open("https://www.youtube.com/@getHouseware", "_blank");
            },
            icon: /* @__PURE__ */ ce.jsx(
              wH,
              {
                size: "1.5rem",
                weight: "duotone",
                color: "var(--secondary-text)"
              }
            )
          }
        )
      ]
    }
  )
] }), A3e = () => {
  const { currentTheme: e, toggleTheme: t } = Cv(), r = () => {
    const n = e === "light" ? "dark" : "light";
    localStorage == null || localStorage.setItem("appThemeMode", n), t();
  };
  return /* @__PURE__ */ ce.jsx(
    "div",
    {
      style: {
        position: "absolute",
        bottom: 16,
        left: 16,
        zIndex: 1
      },
      children: /* @__PURE__ */ ce.jsx("button", { className: `toggle ${e}`, onClick: r, children: /* @__PURE__ */ ce.jsxs("div", { className: "icon-container", children: [
        /* @__PURE__ */ ce.jsx("div", { className: "icon icon--sun", children: /* @__PURE__ */ ce.jsxs(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 47.5 47.5",
            id: "sun",
            children: [
              /* @__PURE__ */ ce.jsx("defs", { children: /* @__PURE__ */ ce.jsx("clipPath", { id: "a", children: /* @__PURE__ */ ce.jsx("path", { d: "M0 38h38V0H0v38Z" }) }) }),
              /* @__PURE__ */ ce.jsx(
                "g",
                {
                  fill: "#ffac33",
                  clipPath: "url(#a)",
                  transform: "matrix(1.25 0 0 -1.25 0 47.5)",
                  children: /* @__PURE__ */ ce.jsx("path", { d: "M17 35s0 2 2 2 2-2 2-2v-2s0-2-2-2-2 2-2 2v2zM35 21s2 0 2-2-2-2-2-2h-2s-2 0-2 2 2 2 2 2h2zM5 21s2 0 2-2-2-2-2-2H3s-2 0-2 2 2 2 2 2h2zM10.121 29.706s1.414-1.414 0-2.828-2.828 0-2.828 0l-1.415 1.414s-1.414 1.414 0 2.829c1.415 1.414 2.829 0 2.829 0l1.414-1.415ZM31.121 8.707s1.414-1.414 0-2.828-2.828 0-2.828 0l-1.414 1.414s-1.414 1.414 0 2.828 2.828 0 2.828 0l1.414-1.414ZM30.708 26.879s-1.414-1.414-2.828 0 0 2.828 0 2.828l1.414 1.414s1.414 1.414 2.828 0 0-2.828 0-2.828l-1.414-1.414ZM9.708 5.879s-1.414-1.414-2.828 0 0 2.828 0 2.828l1.414 1.414s1.414 1.414 2.828 0 0-2.828 0-2.828L9.708 5.879ZM17 5s0 2 2 2 2-2 2-2V3s0-2-2-2-2 2-2 2v2zM29 19c0 5.523-4.478 10-10 10-5.523 0-10-4.477-10-10 0-5.522 4.477-10 10-10 5.522 0 10 4.478 10 10" })
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ ce.jsx("div", { className: "icon icon--moon", children: /* @__PURE__ */ ce.jsx(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "30",
            height: "30",
            viewBox: "0 0 512 512",
            id: "moon",
            children: /* @__PURE__ */ ce.jsxs("g", { children: [
              /* @__PURE__ */ ce.jsx(
                "path",
                {
                  fill: "#6A6D68",
                  d: "M412.95,381.15c-8.05,10.119-16.94,19.33-26.55,27.54c-2.271,1.939-4.58,3.819-6.92,5.64   c-0.261,0.21-0.521,0.42-0.78,0.63c-0.09,0.07-0.19,0.13-0.28,0.2c-5.979,4.6-12.2,8.83-18.64,12.689   c-1.92,1.15-3.851,2.28-5.811,3.37c-18.14,10.061-37.819,17.221-58.42,21.16c-12.27,2.34-24.87,3.55-37.66,3.55   c-27.92,0-54.94-5.739-80.32-17.04c-7.74-3.46-15.3-7.43-22.47-11.81c-6.96-4.24-13.77-9-20.24-14.14   c-5.28-4.19-10.3-8.62-15.07-13.25c-1.3-1.261-2.57-2.54-3.82-3.83c-30.43-31.21-49.57-71.37-54.6-115.38   c-4.54-39.75,2.83-79.04,20.95-113.75c4.99-9.561,10.81-18.78,17.41-27.561c0.2-0.26,0.4-0.529,0.6-0.79   c0.9-1.18,1.81-2.359,2.74-3.529c37.77-47.521,94.29-74.78,155.07-74.78c45.101,0,87.641,14.87,123.021,42.99   c1.54,1.22,2.89,2.33,4.14,3.39c3.16,2.64,6.29,5.43,9.51,8.5c0.49,0.47,0.99,0.94,1.471,1.43c1.3,1.25,2.58,2.54,3.84,3.83   c32.41,33.351,51.979,77.011,55.31,123.75C458.97,293.51,443.88,342.23,412.95,381.15z",
                  opacity: ".9"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "path",
                {
                  fill: "#A3AAA0",
                  d: "M408.95,377.15c-8.05,10.119-16.94,19.33-26.55,27.54c-2.271,1.939-4.58,3.819-6.92,5.64   c-0.261,0.21-0.521,0.42-0.78,0.63c-0.09,0.07-0.19,0.13-0.28,0.2c-5.979,4.6-12.2,8.83-18.64,12.689   c-1.92,1.15-3.851,2.28-5.811,3.37c-19.76,10.96-41.359,18.471-63.979,22.141c-10.51,1.699-21.23,2.569-32.101,2.569   c-27.92,0-54.94-5.739-80.32-17.04c-7.74-3.46-15.3-7.43-22.47-11.81c-6.96-4.24-13.77-9-20.24-14.14   c-5.21-4.141-10.17-8.511-14.89-13.08c-0.06-0.051-0.12-0.11-0.18-0.17c-32.64-31.721-53.18-73.381-58.42-119.21   c-4.54-39.75,2.83-79.04,20.95-113.75c4.99-9.561,10.81-18.78,17.41-27.561c1.09-1.449,2.2-2.89,3.34-4.319   c0.55-0.69,1.1-1.37,1.65-2.051c37.76-46.25,93.52-72.729,153.42-72.729c45.101,0,87.641,14.87,123.021,42.99   c1.54,1.22,2.89,2.33,4.14,3.39c3.16,2.64,6.29,5.43,9.51,8.5c1.811,1.72,3.58,3.48,5.311,5.26c0.05,0.061,0.11,0.11,0.16,0.17   c32.319,33.33,51.83,76.92,55.149,123.58C454.97,289.51,439.88,338.23,408.95,377.15z"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "circle",
                {
                  cx: "285",
                  cy: "156",
                  r: "44.5",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "circle",
                {
                  cx: "385",
                  cy: "300",
                  r: "21.5",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "circle",
                {
                  cx: "166",
                  cy: "296.5",
                  r: "27.84",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "circle",
                {
                  cx: "261.25",
                  cy: "272.75",
                  r: "14.75",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "circle",
                {
                  cx: "151.5",
                  cy: "184",
                  r: "28",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "circle",
                {
                  cx: "297.5",
                  cy: "382.501",
                  r: "27.5",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "circle",
                {
                  cx: "395",
                  cy: "213",
                  r: "18.5",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "circle",
                {
                  cx: "317",
                  cy: "216",
                  r: "8",
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ ce.jsx(
                "path",
                {
                  fill: "#666865",
                  stroke: "#5E5E5D",
                  strokeMiterlimit: "10",
                  strokeWidth: "4",
                  d: "M299.55,450.38   c-12.27,2.34-24.87,3.55-37.66,3.55c-27.92,0-54.94-5.739-80.32-17.04c-7.74-3.46-15.3-7.43-22.47-11.81   c-6.96-4.24-13.77-9-20.24-14.14c-5.28-4.19-10.3-8.62-15.07-13.25c-1.3-1.261-2.57-2.54-3.82-3.83   c-0.06-0.051-0.12-0.11-0.18-0.17c-32.64-31.721-53.18-73.381-58.42-119.21c-4.54-39.75,2.83-79.04,20.95-113.75   c4.99-9.561,10.81-18.78,17.41-27.561c1.09-1.449,2.2-2.89,3.34-4.319c0.55-0.69,1.1-1.37,1.65-2.051   c-0.16,3.011-0.29,6.2-0.39,9.58c-2.39,79.15,12.97,253.43,185.661,310.98C293.12,448.41,296.31,449.42,299.55,450.38z",
                  opacity: ".2"
                }
              )
            ] })
          }
        ) })
      ] }) })
    }
  );
};
export {
  M3e as AiMessageTable,
  w3e as AppThemeProvider,
  J8 as ChatInput,
  E3e as ChatScreenPA,
  D3e as HousewareBranding,
  A3e as ThemeToggle,
  x3e as WelcomeScreenAds,
  b3e as WelcomeScreenConversations,
  Cv as useThemeManager
};
